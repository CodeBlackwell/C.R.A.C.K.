#!/usr/bin/env python3
"""
Airgeddon Helper - WiFi Security Auditing Tool
Simplifies airgeddon execution with focused attack methods and educational guidance

WARNING: Wireless attacks are NOT in OSCP exam scope (relevant for OSWP/PEN-210)
"""

import argparse
import subprocess
import sys
import os
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from themes import Colors
from config import ConfigManager


class AirgeddonHelper:
    """Interactive airgeddon execution helper"""

    def __init__(self):
        self.config = ConfigManager()

        # Check if airgeddon is installed
        self.airgeddon_path = self._find_airgeddon()

        if not self.airgeddon_path:
            print(f"{Colors.RED}✗ Error:{Colors.END} airgeddon not found")
            print(f"\n{Colors.YELLOW}Installation Instructions:{Colors.END}")
            print(f"  cd ~/tools")
            print(f"  git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git")
            print(f"  cd airgeddon")
            print(f"  sudo bash airgeddon.sh")
            sys.exit(1)

    def _find_airgeddon(self):
        """Find airgeddon installation"""
        # Common installation locations
        search_paths = [
            Path.home() / 'tools' / 'airgeddon' / 'airgeddon.sh',
            Path('/opt/airgeddon/airgeddon.sh'),
            Path('/usr/share/airgeddon/airgeddon.sh'),
            Path.home() / 'airgeddon' / 'airgeddon.sh'
        ]

        for path in search_paths:
            if path.exists():
                return path

        # Check if it's in PATH
        try:
            result = subprocess.run(['which', 'airgeddon'],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return Path(result.stdout.strip())
        except:
            pass

        return None

    def print_banner(self):
        """Display tool banner"""
        banner = f"""
{Colors.CYAN}╔═══════════════════════════════════════════════════════════════╗
║  CRACK Airgeddon Helper - WiFi Security Auditing              ║
║  Wireless Attack Automation (OSWP/PEN-210)                    ║
╚═══════════════════════════════════════════════════════════════╝{Colors.END}

{Colors.YELLOW}⚠  WARNING:{Colors.END} Wireless attacks are {Colors.RED}NOT{Colors.END} in OSCP exam scope!
   This tool is for OSWP certification and post-OSCP learning.

{Colors.YELLOW}⚠  LEGAL:{Colors.END} Only test networks you {Colors.GREEN}own{Colors.END} or have {Colors.GREEN}written authorization{Colors.END} for.
   Unauthorized WiFi attacks are illegal (Computer Fraud & Abuse Act).
"""
        print(banner)

    def load_config_values(self):
        """Load configuration values with defaults"""
        return {
            'INTERFACE': self.config.get_variable('INTERFACE') or self._detect_interface(),
            'ESSID': self.config.get_variable('ESSID') or '',
            'BSSID': self.config.get_variable('BSSID') or '',
            'CHANNEL': self.config.get_variable('CHANNEL') or '',
            'WORDLIST': self.config.get_variable('WORDLIST') or '/usr/share/wordlists/rockyou.txt',
            'OUTPUT_DIR': self.config.get_variable('OUTPUT_DIR') or str(Path.home() / 'wifi_captures')
        }

    def _detect_interface(self):
        """Detect wireless interface"""
        try:
            result = subprocess.run(['iwconfig'],
                                  capture_output=True, text=True, timeout=2)
            for line in result.stdout.split('\n'):
                if 'IEEE 802.11' in line or 'ESSID' in line:
                    return line.split()[0]
        except:
            pass
        return 'wlan0'

    def select_method(self):
        """Interactive method selection"""
        print(f"\n{Colors.YELLOW}Select Attack Method:{Colors.END}\n")
        methods = [
            ("Monitor Mode Setup", "Enable/disable monitor mode on wireless interface"),
            ("Network Discovery", "Scan for WiFi networks (2.4GHz and 5GHz)"),
            ("WPS Pixie Dust Attack", "Fast WPS PIN attack (works on vulnerable routers)"),
            ("PMKID Capture Attack", "Clientless WPA/WPA2 attack (no handshake needed)"),
            ("Handshake Capture", "Capture WPA/WPA2 4-way handshake for offline cracking"),
            ("Evil Twin Attack", "Fake AP to harvest credentials (phishing)"),
            ("KARMA/MANA Attack", "Auto-connect exploitation (trusted networks)"),
            ("Hash Cracking", "Crack captured handshakes/PMKID with hashcat"),
            ("PCAP Analysis", "Analyze captured WiFi traffic"),
            ("Full Airgeddon Menu", "Launch complete airgeddon interface (60+ options)")
        ]

        for i, (name, desc) in enumerate(methods, 1):
            print(f"  {Colors.GREEN}{i:2}.{Colors.END} {Colors.CYAN}{name}{Colors.END}")
            print(f"      {Colors.BRIGHT_BLACK}{desc}{Colors.END}")

        print(f"\n{Colors.BRIGHT_BLACK}Recommended Order: 1 → 2 → 3/4/5 → 8{Colors.END}")

        while True:
            try:
                choice = input(f"\n{Colors.YELLOW}Choice [2]:{Colors.END} ").strip()
                if not choice:
                    return 2
                choice_num = int(choice)
                if 1 <= choice_num <= 10:
                    return choice_num
                print(f"{Colors.RED}Invalid choice. Enter 1-10.{Colors.END}")
            except ValueError:
                print(f"{Colors.RED}Invalid input. Enter a number.{Colors.END}")

    def review_config(self, config):
        """Review and edit configuration"""
        print(f"\n{Colors.CYAN}Current Configuration:{Colors.END}")
        print(f"  INTERFACE:  {Colors.GREEN}{config['INTERFACE']}{Colors.END} " +
              ("✓ (detected)" if not self.config.get_variable('INTERFACE') else "✓ (from config)"))
        print(f"  ESSID:      {Colors.GREEN}{config['ESSID'] or '(not set)'}{Colors.END}")
        print(f"  BSSID:      {Colors.GREEN}{config['BSSID'] or '(not set)'}{Colors.END}")
        print(f"  CHANNEL:    {Colors.GREEN}{config['CHANNEL'] or '(auto-detect)'}{Colors.END}")
        print(f"  WORDLIST:   {Colors.GREEN}{config['WORDLIST']}{Colors.END}")
        print(f"  OUTPUT_DIR: {Colors.GREEN}{config['OUTPUT_DIR']}{Colors.END}")

        edit = input(f"\n{Colors.YELLOW}Edit values? (y/n) [n]:{Colors.END} ").strip().lower()

        if edit == 'y':
            for key in ['INTERFACE', 'ESSID', 'BSSID', 'CHANNEL', 'WORDLIST', 'OUTPUT_DIR']:
                new_value = input(f"  {key} [{config[key]}]: ").strip()
                if new_value:
                    config[key] = new_value

        return config

    def explain_flags(self, command, explanations):
        """Display command with flag explanations"""
        print(f"\n{Colors.CYAN}Command:{Colors.END} {command}\n")
        print(f"{Colors.YELLOW}Flag Explanations:{Colors.END}")
        for flag, explanation in explanations.items():
            print(f"  {Colors.GREEN}{flag:25}{Colors.END} {explanation}")

    def check_monitor_mode(self, interface):
        """Check if interface is in monitor mode"""
        try:
            result = subprocess.run(['iwconfig', interface],
                                  capture_output=True, text=True, timeout=2)
            return 'Mode:Monitor' in result.stdout
        except:
            return False

    def method_monitor_mode(self, config):
        """Method 1: Monitor mode setup"""
        print(f"\n{Colors.CYAN}═══ Method 1: Monitor Mode Setup ═══{Colors.END}\n")

        interface = config['INTERFACE']
        is_monitor = self.check_monitor_mode(interface)

        if is_monitor:
            print(f"{Colors.GREEN}✓ Interface {interface} is already in monitor mode{Colors.END}")

            disable_cmd = f"sudo airmon-ng stop {interface}"

            print(f"\n{Colors.YELLOW}To disable monitor mode:{Colors.END}")
            self.explain_flags(disable_cmd, {
                'airmon-ng': 'Aircrack-ng monitor mode manager',
                'stop': 'Disable monitor mode',
                interface: 'Wireless interface name'
            })

            disable = input(f"\n{Colors.YELLOW}Disable monitor mode? (y/n) [n]:{Colors.END} ").strip().lower()
            if disable == 'y':
                print(f"\n{Colors.GREEN}Disabling monitor mode...{Colors.END}")
                subprocess.run(['sudo', 'airmon-ng', 'stop', interface])
        else:
            print(f"{Colors.YELLOW}ℹ Interface {interface} is in managed mode{Colors.END}")

            enable_cmd = f"sudo airmon-ng start {interface}"

            print(f"\n{Colors.YELLOW}To enable monitor mode:{Colors.END}")
            self.explain_flags(enable_cmd, {
                'airmon-ng': 'Aircrack-ng monitor mode manager',
                'start': 'Enable monitor mode',
                interface: 'Wireless interface (will become {interface}mon)'
            })

            print(f"\n{Colors.YELLOW}Kill Interfering Processes:{Colors.END}")
            print(f"  sudo airmon-ng check kill")
            self.explain_flags("airmon-ng check kill", {
                'check': 'Check for interfering processes',
                'kill': 'Kill NetworkManager, wpa_supplicant, etc.'
            })

            enable = input(f"\n{Colors.GREEN}Enable monitor mode now? (y/n) [y]:{Colors.END} ").strip().lower()
            if enable != 'n':
                print(f"\n{Colors.GREEN}Killing interfering processes...{Colors.END}")
                subprocess.run(['sudo', 'airmon-ng', 'check', 'kill'])

                print(f"\n{Colors.GREEN}Enabling monitor mode on {interface}...{Colors.END}")
                subprocess.run(['sudo', 'airmon-ng', 'start', interface])

                print(f"\n{Colors.GREEN}✓ Monitor mode enabled (interface: {interface}mon){Colors.END}")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Monitor mode required for packet injection attacks")
        print(f"{Colors.YELLOW}Next Step:{Colors.END} Run network discovery (Method 2)")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Always check for interfering processes (~30 sec)")

    def method_network_discovery(self, config):
        """Method 2: Network discovery"""
        print(f"\n{Colors.CYAN}═══ Method 2: Network Discovery ═══{Colors.END}\n")

        interface = config['INTERFACE']

        if not self.check_monitor_mode(interface):
            interface_mon = f"{interface}mon"
            print(f"{Colors.YELLOW}⚠ Interface must be in monitor mode{Colors.END}")
            print(f"  Try: {interface_mon} (or run Method 1 first)")
            return

        scan_cmd = f"sudo airodump-ng {interface}"

        print(f"{Colors.YELLOW}Scanning for WiFi networks...{Colors.END}")
        self.explain_flags(scan_cmd, {
            'airodump-ng': 'Aircrack-ng packet capture tool',
            interface: 'Monitor mode interface',
            'Output': 'BSSID, PWR, CH, ENC (encryption type)'
        })

        print(f"\n{Colors.YELLOW}Read the Output:{Colors.END}")
        print(f"  {Colors.GREEN}BSSID:{Colors.END}       MAC address of access point")
        print(f"  {Colors.GREEN}PWR:{Colors.END}        Signal strength (closer to 0 = stronger)")
        print(f"  {Colors.GREEN}CH:{Colors.END}         Channel number")
        print(f"  {Colors.GREEN}ENC:{Colors.END}        Encryption (WPA2, WPA, WEP)")
        print(f"  {Colors.GREEN}ESSID:{Colors.END}      Network name")
        print(f"  {Colors.GREEN}#/s:{Colors.END}        Packets per second (activity indicator)")

        print(f"\n{Colors.YELLOW}Target Selection Criteria:{Colors.END}")
        print(f"  1. Strong signal (PWR closer to 0)")
        print(f"  2. Active clients (shows in 'STATION' section)")
        print(f"  3. WPA/WPA2 encryption (modern, crackable)")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Identify target networks for attack")
        print(f"{Colors.YELLOW}Scan Time:{Colors.END} 2-5 minutes to see all networks")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Note BSSID, ESSID, and channel for next steps")

        start = input(f"\n{Colors.GREEN}Start network scan now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting scan on {interface}...{Colors.END}")
            print(f"{Colors.YELLOW}Press Ctrl+C to stop{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'airodump-ng', interface])
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Scan stopped{Colors.END}")

    def method_wps_pixie_dust(self, config):
        """Method 3: WPS Pixie Dust attack"""
        print(f"\n{Colors.CYAN}═══ Method 3: WPS Pixie Dust Attack ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About WPS Pixie Dust:{Colors.END}")
        print(f"  • Exploits weak WPS PIN generation")
        print(f"  • Fast attack (2-10 minutes)")
        print(f"  • Works on ~30% of routers")
        print(f"  • No handshake capture needed")

        print(f"\n{Colors.YELLOW}Requirements:{Colors.END}")
        print(f"  • WPS must be enabled on target")
        print(f"  • Router must be vulnerable (test with reaver)")

        command = "reaver -i wlan0mon -b 00:11:22:33:44:55 -vv -c 6 -K"

        self.explain_flags(command, {
            'reaver': 'WPS attack tool',
            '-i': 'Interface in monitor mode',
            '-b': 'Target BSSID (MAC address)',
            '-vv': 'Very verbose output',
            '-c': 'Target channel',
            '-K': 'Pixie Dust attack mode'
        })

        print(f"\n{Colors.YELLOW}Success Indicators:{Colors.END}")
        print(f"  • 'WPS PIN: 12345670' (PIN recovered)")
        print(f"  • 'WPA PSK: password123' (WiFi password)")

        print(f"\n{Colors.YELLOW}Failure Indicators:{Colors.END}")
        print(f"  • 'WPS transaction failed' (not vulnerable)")
        print(f"  • 'Receive timeout' (weak signal)")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Fast WPS exploit (alternative to handshake)")
        print(f"{Colors.YELLOW}Attack Time:{Colors.END} 2-10 minutes")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Try this BEFORE handshake capture")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon automates this in menu: DoS/Evil Twin/WPS attacks → WPS Pixie Dust")

        self._launch_airgeddon_prompt()

    def method_pmkid_capture(self, config):
        """Method 4: PMKID capture attack"""
        print(f"\n{Colors.CYAN}═══ Method 4: PMKID Capture Attack ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About PMKID Attack:{Colors.END}")
        print(f"  • Clientless attack (no devices need to connect)")
        print(f"  • Captures RSN IE from AP itself")
        print(f"  • Faster than handshake capture")
        print(f"  • Works on ~70% of modern routers")

        command = "hcxdumptool -i wlan0mon -o pmkid.pcapng --enable_status=1"

        self.explain_flags(command, {
            'hcxdumptool': 'WiFi capture tool (optimized for PMKID)',
            '-i': 'Interface in monitor mode',
            '-o': 'Output PCAP file',
            '--enable_status=1': 'Show real-time status'
        })

        print(f"\n{Colors.YELLOW}Convert to Hashcat Format:{Colors.END}")
        convert_cmd = "hcxpcapngtool -o pmkid.hc22000 pmkid.pcapng"
        print(f"  {Colors.BOLD}{convert_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}Crack with Hashcat:{Colors.END}")
        crack_cmd = "hashcat -m 22000 pmkid.hc22000 /usr/share/wordlists/rockyou.txt"
        print(f"  {Colors.BOLD}{crack_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}Success Indicators:{Colors.END}")
        print(f"  • 'PMKID found' in hcxdumptool output")
        print(f"  • Non-zero file size for .hc22000")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Capture PMKID for offline cracking (no clients needed)")
        print(f"{Colors.YELLOW}Capture Time:{Colors.END} 1-5 minutes")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Fastest attack if router is vulnerable (~10 min total)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon automates this in menu: Offline WPA/WPA2 decrypt menu → PMKID attack")

        self._launch_airgeddon_prompt()

    def method_handshake_capture(self, config):
        """Method 5: Handshake capture"""
        print(f"\n{Colors.CYAN}═══ Method 5: Handshake Capture ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About Handshake Capture:{Colors.END}")
        print(f"  • Capture WPA/WPA2 4-way handshake")
        print(f"  • Requires client to (re)connect")
        print(f"  • Most reliable method (works on all WPA/WPA2)")
        print(f"  • Can force reconnect with deauth attack")

        capture_cmd = "airodump-ng -c 6 --bssid 00:11:22:33:44:55 -w capture wlan0mon"

        print(f"\n{Colors.YELLOW}Step 1: Start Capture{Colors.END}")
        self.explain_flags(capture_cmd, {
            'airodump-ng': 'Packet capture tool',
            '-c': 'Lock to specific channel',
            '--bssid': 'Target access point MAC',
            '-w': 'Write to file (creates capture-01.cap)',
            'wlan0mon': 'Monitor mode interface'
        })

        deauth_cmd = "aireplay-ng -0 5 -a 00:11:22:33:44:55 wlan0mon"

        print(f"\n{Colors.YELLOW}Step 2: Force Reconnect (Deauth){Colors.END}")
        self.explain_flags(deauth_cmd, {
            'aireplay-ng': 'Packet injection tool',
            '-0': 'Deauthentication attack',
            '5': 'Number of deauth packets',
            '-a': 'Target AP BSSID',
            'wlan0mon': 'Monitor mode interface'
        })

        print(f"\n{Colors.YELLOW}Success Indicator:{Colors.END}")
        print(f"  • Upper right corner shows: {Colors.GREEN}WPA handshake: 00:11:22:33:44:55{Colors.END}")

        crack_cmd = "aircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap"

        print(f"\n{Colors.YELLOW}Step 3: Crack Handshake{Colors.END}")
        print(f"  {Colors.BOLD}{crack_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Classic WPA/WPA2 attack (offline cracking)")
        print(f"{Colors.YELLOW}Capture Time:{Colors.END} 1-10 minutes (depends on client activity)")
        print(f"{Colors.YELLOW}Crack Time:{Colors.END} Minutes to days (depends on password)")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Standard exam method (~15-30 min)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon automates this in menu: Offline WPA/WPA2 decrypt menu → Handshake capture")

        self._launch_airgeddon_prompt()

    def method_evil_twin(self, config):
        """Method 6: Evil Twin attack"""
        print(f"\n{Colors.CYAN}═══ Method 6: Evil Twin Attack ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About Evil Twin:{Colors.END}")
        print(f"  • Create fake AP with same ESSID as target")
        print(f"  • Deauth clients from real AP")
        print(f"  • Clients connect to fake AP")
        print(f"  • Capture credentials via captive portal")

        print(f"\n{Colors.YELLOW}Attack Flow:{Colors.END}")
        print(f"  1. Clone target AP (same ESSID)")
        print(f"  2. Start captive portal (fake login page)")
        print(f"  3. Deauth clients from real AP")
        print(f"  4. Clients auto-reconnect to fake AP")
        print(f"  5. Redirect to 'firmware update' login page")
        print(f"  6. User enters WiFi password → captured")

        print(f"\n{Colors.YELLOW}Requirements:{Colors.END}")
        print(f"  • Two wireless interfaces (one for AP, one for deauth)")
        print(f"  • Or use airgeddon in 'automode' (one interface)")

        print(f"\n{Colors.YELLOW}Success Indicators:{Colors.END}")
        print(f"  • Clients appear in fake AP list")
        print(f"  • Captive portal shows login attempts")
        print(f"  • Password captured in credentials file")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Social engineering attack (user provides password)")
        print(f"{Colors.YELLOW}Attack Time:{Colors.END} 10-30 minutes (depends on user awareness)")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Effective against aware users (~20 min)")
        print(f"{Colors.YELLOW}Legal:{Colors.END} Requires written authorization (deceptive attack)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon automates this in menu: DoS/Evil Twin/WPS attacks → Evil Twin attacks")

        self._launch_airgeddon_prompt()

    def method_karma_mana(self, config):
        """Method 7: KARMA/MANA attack"""
        print(f"\n{Colors.CYAN}═══ Method 7: KARMA/MANA Attack ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About KARMA/MANA:{Colors.END}")
        print(f"  • Exploit auto-connect to 'trusted networks'")
        print(f"  • Device broadcasts 'looking for NetworkName'")
        print(f"  • Fake AP responds 'I am NetworkName'")
        print(f"  • Device auto-connects without user interaction")

        print(f"\n{Colors.YELLOW}Attack Flow:{Colors.END}")
        print(f"  1. Start fake AP in KARMA mode")
        print(f"  2. Listen for probe requests")
        print(f"  3. Respond to ALL probe requests")
        print(f"  4. Devices auto-connect")
        print(f"  5. Capture credentials/traffic")

        print(f"\n{Colors.YELLOW}Effective Against:{Colors.END}")
        print(f"  • Phones with saved home networks")
        print(f"  • Laptops with saved work networks")
        print(f"  • IoT devices with hardcoded SSIDs")

        print(f"\n{Colors.YELLOW}Requirements:{Colors.END}")
        print(f"  • Hostapd-mana or hostapd-wpe")
        print(f"  • DHCP server (dnsmasq)")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Automated MitM via auto-connect exploitation")
        print(f"{Colors.YELLOW}Attack Time:{Colors.END} 5-15 minutes (depends on device proximity)")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Effective in crowded areas (coffee shops)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon supports this in menu: DoS/Evil Twin/WPS attacks → KARMA/MANA")

        self._launch_airgeddon_prompt()

    def method_hash_cracking(self, config):
        """Method 8: Hash cracking"""
        print(f"\n{Colors.CYAN}═══ Method 8: Hash Cracking ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}Cracking Methods:{Colors.END}\n")

        # Aircrack-ng
        aircrack_cmd = "aircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap"
        print(f"{Colors.GREEN}1. Aircrack-ng (CPU, slower){Colors.END}")
        self.explain_flags(aircrack_cmd, {
            'aircrack-ng': 'WPA/WPA2 cracker',
            '-w': 'Wordlist file',
            'capture-01.cap': 'PCAP with handshake'
        })

        # Hashcat
        hashcat_cmd = "hashcat -m 22000 -a 0 pmkid.hc22000 /usr/share/wordlists/rockyou.txt"
        print(f"\n{Colors.GREEN}2. Hashcat (GPU, faster){Colors.END}")
        self.explain_flags(hashcat_cmd, {
            'hashcat': 'GPU-accelerated password cracker',
            '-m 22000': 'WPA-PBKDF2-PMKID+EAPOL mode',
            '-a 0': 'Straight dictionary attack',
            'pmkid.hc22000': 'Hash file',
            'rockyou.txt': 'Wordlist (14M passwords)'
        })

        # John the Ripper
        john_cmd = "john --wordlist=/usr/share/wordlists/rockyou.txt --format=wpapsk handshake.hccap"
        print(f"\n{Colors.GREEN}3. John the Ripper (CPU, with rules){Colors.END}")
        print(f"  {Colors.BOLD}{john_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}Wordlist Locations:{Colors.END}")
        print(f"  • {Colors.GREEN}/usr/share/wordlists/rockyou.txt{Colors.END} (14M passwords)")
        print(f"  • {Colors.GREEN}/usr/share/wordlists/dirb/common.txt{Colors.END} (4K common)")
        print(f"  • {Colors.GREEN}/usr/share/seclists/Passwords/{Colors.END} (many categories)")

        print(f"\n{Colors.YELLOW}Speed Comparison:{Colors.END}")
        print(f"  • Aircrack-ng: ~1,000 passwords/second (CPU)")
        print(f"  • Hashcat (GPU): ~100,000 passwords/second (RTX 3070)")
        print(f"  • John: ~5,000 passwords/second (CPU with rules)")

        print(f"\n{Colors.YELLOW}Time Estimates (rockyou.txt):{Colors.END}")
        print(f"  • Aircrack-ng: ~4 hours")
        print(f"  • Hashcat (GPU): ~2 minutes")
        print(f"  • John: ~45 minutes")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Offline password recovery from captured hashes")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Use GPU if available (massively faster)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon automates this in menu: Offline WPA/WPA2 decrypt menu → Decrypt")

        self._launch_airgeddon_prompt()

    def method_pcap_analysis(self, config):
        """Method 9: PCAP analysis"""
        print(f"\n{Colors.CYAN}═══ Method 9: PCAP Analysis ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}Analysis Tools:{Colors.END}\n")

        # Wireshark
        print(f"{Colors.GREEN}1. Wireshark (GUI, comprehensive){Colors.END}")
        print(f"  wireshark capture-01.cap")
        print(f"  {Colors.BRIGHT_BLACK}Filters: wlan.fc.type_subtype == 0x08 (beacons), eapol (handshakes){Colors.END}")

        # Tshark
        tshark_cmd = "tshark -r capture-01.cap -Y 'eapol'"
        print(f"\n{Colors.GREEN}2. Tshark (CLI, scriptable){Colors.END}")
        self.explain_flags(tshark_cmd, {
            'tshark': 'Terminal Wireshark',
            '-r': 'Read from file',
            '-Y': 'Display filter',
            'eapol': 'Show EAPOL frames (handshake)'
        })

        # Pyrit
        pyrit_cmd = "pyrit -r capture-01.cap analyze"
        print(f"\n{Colors.GREEN}3. Pyrit (handshake verification){Colors.END}")
        print(f"  {Colors.BOLD}{pyrit_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}Common Analysis Tasks:{Colors.END}")
        print(f"  • Verify handshake capture: pyrit analyze")
        print(f"  • Extract SSIDs: tshark -r file.cap -Y 'wlan.fc.type_subtype == 0x08' -T fields -e wlan.ssid")
        print(f"  • Count deauth packets: tshark -r file.cap -Y 'wlan.fc.type_subtype == 0x0c' | wc -l")
        print(f"  • Export credentials: wireshark filter → File → Export Objects")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Verify captures, extract data, troubleshoot failed attacks")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Always verify handshake before cracking (~2 min)")

        print(f"\n{Colors.BOLD}{Colors.GREEN}Airgeddon Integration:{Colors.END}")
        print(f"  Airgeddon shows live capture stats during attacks")

        self._launch_airgeddon_prompt()

    def method_full_menu(self, config):
        """Method 10: Full airgeddon menu"""
        print(f"\n{Colors.CYAN}═══ Method 10: Full Airgeddon Menu ═══{Colors.END}\n")

        print(f"{Colors.YELLOW}About Full Menu:{Colors.END}")
        print(f"  • 60+ attack methods")
        print(f"  • Advanced features:")
        print(f"    - BeEF integration (browser exploitation)")
        print(f"    - Enterprise attacks (RADIUS/EAP)")
        print(f"    - Rogue AP detection")
        print(f"    - WEP attacks (legacy)")

        print(f"\n{Colors.YELLOW}When to Use Full Menu:{Colors.END}")
        print(f"  • Methods 1-9 don't cover your use case")
        print(f"  • Enterprise WPA2-Enterprise attacks")
        print(f"  • Custom attack chains")
        print(f"  • Advanced features (BeEF, Bettercap)")

        print(f"\n{Colors.YELLOW}Menu Categories:{Colors.END}")
        print(f"  1. DoS/Evil Twin/WPS attacks")
        print(f"  2. Offline WPA/WPA2 decrypt menu")
        print(f"  3. Enterprise attacks")
        print(f"  4. WEP attacks")
        print(f"  5. Handshake/PMKID tools")
        print(f"  6. BeEF options")

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Access full airgeddon capabilities")
        print(f"{Colors.YELLOW}OSWP Tip:{Colors.END} Menu is well-documented, use 'i' for info")

        self._launch_airgeddon_prompt()

    def _launch_airgeddon_prompt(self):
        """Prompt to launch airgeddon"""
        launch = input(f"\n{Colors.GREEN}Launch airgeddon now? (y/n) [y]:{Colors.END} ").strip().lower()

        if launch != 'n':
            print(f"\n{Colors.GREEN}Launching airgeddon...{Colors.END}")
            print(f"{Colors.YELLOW}Use 'i' in menus for detailed information{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'bash', str(self.airgeddon_path)])
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Airgeddon closed{Colors.END}")

    def run(self):
        """Main execution flow"""
        self.print_banner()

        # Load configuration
        config = self.load_config_values()

        # Select method
        method = self.select_method()

        # Review configuration
        config = self.review_config(config)

        # Execute selected method
        methods = {
            1: self.method_monitor_mode,
            2: self.method_network_discovery,
            3: self.method_wps_pixie_dust,
            4: self.method_pmkid_capture,
            5: self.method_handshake_capture,
            6: self.method_evil_twin,
            7: self.method_karma_mana,
            8: self.method_hash_cracking,
            9: self.method_pcap_analysis,
            10: self.method_full_menu
        }

        methods[method](config)

        print(f"\n{Colors.GREEN}═══════════════════════════════════════════════════{Colors.END}")
        print(f"{Colors.YELLOW}Next Steps:{Colors.END}")
        print(f"  1. Document findings in CRACK Track")
        print(f"  2. Crack captured hashes (Method 8)")
        print(f"  3. Verify results with PCAP analysis (Method 9)")
        print(f"{Colors.YELLOW}OSWP Resources:{Colors.END}")
        print(f"  • PEN-210 course: https://www.offsec.com/courses/pen-210/")
        print(f"  • WiFu book: https://www.hackers-arise.com/wifu")
        print(f"{Colors.GREEN}═══════════════════════════════════════════════════{Colors.END}\n")


def main():
    """Entry point"""
    parser = argparse.ArgumentParser(
        description='Airgeddon Helper - WiFi Security Auditing (OSWP/PEN-210)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  crack airgeddon                              # Interactive wizard
  crack airgeddon --essid "TargetAP"           # Pre-configure ESSID
  crack airgeddon --method wps-pixie           # Direct method

Methods Available:
  1. Monitor Mode Setup                        # Enable packet injection
  2. Network Discovery                         # Scan for targets
  3. WPS Pixie Dust Attack                     # Fast WPS exploit
  4. PMKID Capture Attack                      # Clientless attack
  5. Handshake Capture                         # Classic WPA/WPA2
  6. Evil Twin Attack                          # Phishing AP
  7. KARMA/MANA Attack                         # Auto-connect exploit
  8. Hash Cracking                             # Offline cracking
  9. PCAP Analysis                             # Verify captures
  10. Full Airgeddon Menu                      # 60+ methods

OSWP Exam Tips:
  - Recommended flow: 1 → 2 → 4/5 → 8
  - PMKID faster than handshake (if vulnerable)
  - Always verify handshake before cracking
  - GPU cracking ~50x faster than CPU

WARNING:
  - NOT in OSCP exam scope (relevant for OSWP/PEN-210)
  - Only test networks you own or have written authorization for
  - Unauthorized WiFi attacks are illegal (Computer Fraud & Abuse Act)
        """
    )

    parser.add_argument('--essid', help='Pre-configure target ESSID')
    parser.add_argument('--bssid', help='Pre-configure target BSSID')
    parser.add_argument('--interface', help='Pre-configure wireless interface')
    parser.add_argument('--method', help='Direct method selection (monitor, discover, wps-pixie, pmkid, handshake, evil-twin, karma, crack, pcap, full)')

    args = parser.parse_args()

    try:
        helper = AirgeddonHelper()

        # Pre-configure if args provided
        if args.essid:
            helper.config.set_variable('ESSID', args.essid)
        if args.bssid:
            helper.config.set_variable('BSSID', args.bssid)
        if args.interface:
            helper.config.set_variable('INTERFACE', args.interface)

        # Direct method if specified
        if args.method:
            method_map = {
                'monitor': 1, 'discover': 2, 'wps-pixie': 3,
                'pmkid': 4, 'handshake': 5, 'evil-twin': 6,
                'karma': 7, 'crack': 8, 'pcap': 9, 'full': 10
            }
            if args.method in method_map:
                config = helper.load_config_values()
                methods = {
                    1: helper.method_monitor_mode,
                    2: helper.method_network_discovery,
                    3: helper.method_wps_pixie_dust,
                    4: helper.method_pmkid_capture,
                    5: helper.method_handshake_capture,
                    6: helper.method_evil_twin,
                    7: helper.method_karma_mana,
                    8: helper.method_hash_cracking,
                    9: helper.method_pcap_analysis,
                    10: helper.method_full_menu
                }
                methods[method_map[args.method]](config)
                return

        helper.run()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Interrupted by user{Colors.END}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}✗ Error:{Colors.END} {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
