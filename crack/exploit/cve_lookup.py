#!/usr/bin/env python3
"""
CVE lookup using searchsploit for discovered services
Maps service versions to known vulnerabilities and exploits
"""

import subprocess
import re
from pathlib import Path

try:
    from crack.themes import Colors
except ImportError:
    class Colors:
        HEADER = '\033[95m'
        BLUE = '\033[94m'
        CYAN = '\033[96m'
        GREEN = '\033[92m'
        YELLOW = '\033[93m'
        RED = '\033[91m'
        BOLD = '\033[1m'
        END = '\033[0m'


class CVELookup:
    """Search for exploits using searchsploit"""

    def __init__(self, scan_file):
        self.scan_file = Path(scan_file)
        self.services = []
        self.exploits = {}

    def parse_services(self):
        """
        Extract service names and versions from nmap scan
        Returns list of (port, service, version) tuples
        """
        if not self.scan_file.exists():
            return []

        with open(self.scan_file, 'r') as f:
            content = f.read()

        services = []

        # Parse nmap output for service versions
        # Look for lines like: "80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))"
        pattern = r'(\d+)/tcp\s+open\s+(\S+)\s+(.+?)(?:\n|$)'

        for match in re.finditer(pattern, content):
            port = match.group(1)
            service = match.group(2)
            version_line = match.group(3).strip()

            # Clean up version string
            # Remove extra info in parentheses (handles nested/multiple parentheses)
            # Using greedy match to capture all content from first ( to last )
            # This handles ((Ubuntu)), (Ubuntu) (Extra), etc. in one pass
            while '(' in version_line:
                version_line = re.sub(r'\s*\(.*\)\s*', '', version_line)
            version = version_line.strip()

            if version and version != service:
                services.append((port, service, version))

        self.services = services
        return services

    def search_exploits(self, query, max_results=5):
        """
        Search exploitdb using searchsploit
        Returns list of exploit entries
        """
        try:
            # Run searchsploit
            cmd = ['searchsploit', '--colour', query]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                return []

            # Parse output
            lines = result.stdout.split('\n')
            exploits = []

            for line in lines:
                # Skip header/footer lines
                if '---' in line or 'Exploit Title' in line or 'Shellcodes' in line:
                    continue

                # Extract exploit info
                # Format: "Title | Path"
                if '|' in line:
                    parts = line.split('|')
                    if len(parts) >= 2:
                        title = parts[0].strip()
                        path = parts[1].strip()

                        if title and path:
                            exploits.append({
                                'title': title,
                                'path': path
                            })

                        if len(exploits) >= max_results:
                            break

            return exploits

        except subprocess.TimeoutExpired:
            return []
        except FileNotFoundError:
            print(f"{Colors.RED}✗ searchsploit not found{Colors.END}")
            return []
        except Exception:
            return []

    def lookup_all(self):
        """
        Search for exploits for all discovered services
        """
        print(f"\n{Colors.BOLD}[CVE & EXPLOIT LOOKUP]{Colors.END}")
        print(f"{Colors.CYAN}=" * 60 + Colors.END)

        if not self.services:
            self.parse_services()

        if not self.services:
            print(f"{Colors.YELLOW}No services with versions found{Colors.END}")
            return {}

        print(f"\n{Colors.YELLOW}Searching exploitdb for {len(self.services)} services...{Colors.END}\n")

        for port, service, version in self.services:
            # Create search query
            # Try to extract the main product name and version
            query = version

            print(f"{Colors.CYAN}[Port {port}]{Colors.END} {service} - {version}")

            exploits = self.search_exploits(query, max_results=3)

            if exploits:
                self.exploits[port] = {
                    'service': service,
                    'version': version,
                    'exploits': exploits
                }

                for exploit in exploits:
                    print(f"  {Colors.GREEN}→{Colors.END} {exploit['title']}")
                    print(f"    {Colors.BLUE}{exploit['path']}{Colors.END}")
            else:
                print(f"  {Colors.YELLOW}No exploits found{Colors.END}")

            print()

        return self.exploits

    def get_summary(self):
        """Generate summary of exploit findings"""
        if not self.exploits:
            return f"{Colors.YELLOW}No exploits found in searchsploit{Colors.END}"

        summary = []
        summary.append(f"\n{Colors.BOLD}[EXPLOIT SUMMARY]{Colors.END}")
        summary.append(f"{Colors.CYAN}-" * 40 + Colors.END)

        total_exploits = sum(len(data['exploits']) for data in self.exploits.values())
        summary.append(f"  Services with exploits: {len(self.exploits)}")
        summary.append(f"  Total exploits found: {total_exploits}")

        return '\n'.join(summary)

    def generate_commands(self):
        """
        Generate manual searchsploit commands for documentation
        """
        if not self.services:
            return []

        commands = []
        commands.append(f"\n{Colors.BOLD}[MANUAL CVE RESEARCH COMMANDS]{Colors.END}")
        commands.append(f"{Colors.CYAN}-" * 40 + Colors.END)
        commands.append(f"\n{Colors.YELLOW}Run these commands to research vulnerabilities:{Colors.END}\n")

        for port, service, version in self.services:
            # Suggest searchsploit command
            cmd = f"searchsploit {version}"
            commands.append(f"# Port {port}: {service}")
            commands.append(f"searchsploit \"{version}\"")
            commands.append("")

        return '\n'.join(commands)
