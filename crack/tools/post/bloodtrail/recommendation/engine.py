"""
BloodTrail Recommendation Engine.

Core state machine that:
1. Receives findings from enumerators
2. Matches findings against trigger rules
3. Generates and prioritizes recommendations
4. Tracks state to avoid repetition
"""

import uuid
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime

from .models import (
    Finding,
    FindingType,
    Recommendation,
    RecommendationPriority,
    AttackState,
    Credential,
    CredentialType,
)
from .triggers import (
    TriggerRule,
    TRIGGER_RULES,
    get_recommendations_for_finding,
    match_finding,
)
from .decoders import (
    decode_value,
    decrypt_vnc_password,
    extract_vnc_password_from_reg,
    looks_like_password,
    DecodeResult,
)


class RecommendationEngine:
    """
    Core recommendation engine for BloodTrail.

    Manages the finding â†’ recommendation flow:
    1. Add findings from enumeration
    2. Process findings through trigger rules
    3. Generate prioritized recommendations
    4. Track completed/skipped actions
    5. Present one recommendation at a time
    """

    def __init__(
        self,
        target: str,
        domain: Optional[str] = None,
        rules: Optional[List[TriggerRule]] = None,
    ):
        """
        Initialize the recommendation engine.

        Args:
            target: Target IP or hostname
            domain: Domain name (if known)
            rules: Custom trigger rules (defaults to built-in rules)
        """
        self.state = AttackState(target=target, domain=domain)
        self.rules = rules or TRIGGER_RULES
        self._finding_callbacks: List[Callable[[Finding], None]] = []
        self._recommendation_callbacks: List[Callable[[Recommendation], None]] = []

    # ========================================================================
    # PUBLIC API
    # ========================================================================

    def add_finding(self, finding: Finding) -> List[Recommendation]:
        """
        Add a new finding and process it.

        Args:
            finding: The finding to add

        Returns:
            List of new recommendations generated by this finding
        """
        # Skip if we already have this finding
        if finding.id in self.state.findings:
            return []

        # Store the finding
        self.state.add_finding(finding)

        # Notify callbacks
        for callback in self._finding_callbacks:
            callback(finding)

        # Process through trigger rules
        new_recommendations = self._process_finding(finding)

        # Add to state and notify
        for rec in new_recommendations:
            self.state.add_recommendation(rec)
            for callback in self._recommendation_callbacks:
                callback(rec)

        return new_recommendations

    def add_credential(
        self,
        username: str,
        password: str,
        credential_type: CredentialType = CredentialType.PASSWORD,
        validated: bool = False,
        access_level: Optional[str] = None,
        source_finding: Optional[str] = None,
        domain: Optional[str] = None,
    ) -> Credential:
        """
        Add a discovered credential.

        Args:
            username: The username
            password: The password/hash/etc
            credential_type: Type of credential
            validated: Whether credential has been tested
            access_level: Access level if validated
            source_finding: Finding ID that led to this credential
            domain: Domain for this credential

        Returns:
            The created Credential object
        """
        cred = Credential(
            id=f"cred_{username}_{uuid.uuid4().hex[:8]}",
            username=username,
            credential_type=credential_type,
            value=password,
            domain=domain or self.state.domain,
            validated=validated,
            access_level=access_level,
            source_finding=source_finding,
        )

        self.state.add_credential(cred)

        # If validated, create a finding for it
        if validated:
            finding = Finding(
                id=f"finding_valid_cred_{cred.id}",
                finding_type=FindingType.CREDENTIAL,
                source="credential_validation",
                target=username,
                raw_value=password,
                tags=["validated"],
                metadata={
                    "username": username,
                    "access_level": access_level,
                    "credential_id": cred.id,
                },
            )
            self.add_finding(finding)

        return cred

    def validate_credential(
        self,
        credential_id: str,
        access_level: str = "user",
    ) -> None:
        """Mark a credential as validated."""
        if credential_id in self.state.credentials:
            cred = self.state.credentials[credential_id]
            cred.validated = True
            cred.access_level = access_level
            self.state.current_access_level = access_level
            self.state.current_user = cred.username

    def get_next_recommendation(self) -> Optional[Recommendation]:
        """
        Get the highest priority pending recommendation.

        Returns:
            Next recommendation or None if queue is empty
        """
        return self.state.get_next_recommendation()

    def complete_recommendation(self, rec_id: str) -> None:
        """Mark a recommendation as completed."""
        self.state.complete_recommendation(rec_id)

    def skip_recommendation(self, rec_id: str) -> None:
        """Mark a recommendation as skipped."""
        self.state.skip_recommendation(rec_id)

    def on_finding(self, callback: Callable[[Finding], None]) -> None:
        """Register a callback for new findings."""
        self._finding_callbacks.append(callback)

    def on_recommendation(self, callback: Callable[[Recommendation], None]) -> None:
        """Register a callback for new recommendations."""
        self._recommendation_callbacks.append(callback)

    # ========================================================================
    # FINDING CREATION HELPERS
    # ========================================================================

    def create_ldap_attribute_finding(
        self,
        username: str,
        attribute_name: str,
        attribute_value: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """
        Create a finding for a custom LDAP attribute.

        Auto-decodes the value if it looks encoded.
        """
        finding = Finding(
            id=f"ldap_attr_{username}_{attribute_name}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.LDAP_ATTRIBUTE,
            source=source,
            target=attribute_name,
            raw_value=attribute_value,
            metadata={
                "username": username,
                "attribute_name": attribute_name,
            },
        )

        # Try to auto-decode
        result = decode_value(attribute_value)
        if result.success:
            finding.decoded_value = result.decoded
            finding.decode_method = result.method.name if result.method else None
            finding.add_tag("decoded")
            finding.add_tag(result.method.name.lower() if result.method else "unknown")
            if looks_like_password(result.decoded):
                finding.add_tag("likely_password")

        return finding

    def create_file_finding(
        self,
        file_path: str,
        file_content: Optional[str] = None,
        source: str = "smb_crawl",
        tags: Optional[List[str]] = None,
    ) -> Finding:
        """
        Create a finding for an interesting file.

        Extracts embedded credentials for known file types.
        """
        finding = Finding(
            id=f"file_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.FILE,
            source=source,
            target=file_path,
            raw_value=file_content,
            tags=tags or [],
            metadata={
                "file_path": file_path,
                "has_content": file_content is not None,
            },
        )

        # Check for VNC registry file
        if file_path.lower().endswith('.reg') and 'vnc' in file_path.lower():
            finding.add_tag("vnc")
            if file_content:
                encrypted_hex = extract_vnc_password_from_reg(file_content)
                if encrypted_hex:
                    finding.metadata["encrypted_hex"] = encrypted_hex
                    finding.add_tag("encrypted_password")

                    # Try to decrypt
                    result = decrypt_vnc_password(encrypted_hex)
                    if result.success:
                        finding.decoded_value = result.decoded
                        finding.decode_method = "VNC_DES"
                        finding.add_tag("decrypted")

        # Check for SQLite
        if any(file_path.lower().endswith(ext) for ext in ['.db', '.sqlite', '.sqlite3']):
            finding.add_tag("database")

        # Check for .NET binary
        if any(file_path.lower().endswith(ext) for ext in ['.exe', '.dll']):
            if file_content and (b'mscorlib' in file_content.encode() if isinstance(file_content, str) else b'mscorlib' in file_content):
                finding.add_tag("dotnet")

        return finding

    def create_group_membership_finding(
        self,
        username: str,
        group_name: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """Create a finding for an interesting group membership."""
        finding = Finding(
            id=f"group_{username}_{group_name}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.GROUP_MEMBERSHIP,
            source=source,
            target=group_name,
            raw_value=group_name,
            metadata={
                "username": username,
                "group_name": group_name,
            },
        )

        # Tag privileged groups
        privileged_patterns = [
            "admin", "domain admin", "enterprise admin", "recycle bin",
            "backup operator", "server operator", "account operator",
            "dnsadmin", "gpo creator", "schema admin",
        ]
        for pattern in privileged_patterns:
            if pattern in group_name.lower():
                finding.add_tag("privileged_group")
                break

        return finding

    def create_user_flag_finding(
        self,
        username: str,
        flag: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """Create a finding for an interesting user account flag."""
        finding = Finding(
            id=f"flag_{username}_{flag}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.USER_FLAG,
            source=source,
            target=username,
            raw_value=flag,
            tags=[flag.upper()],
            metadata={
                "username": username,
                "flag": flag,
            },
        )

        return finding

    # ========================================================================
    # INTERNAL METHODS
    # ========================================================================

    def _process_finding(self, finding: Finding) -> List[Recommendation]:
        """
        Process a finding through trigger rules.

        Returns list of recommendations generated.
        """
        return get_recommendations_for_finding(
            finding=finding,
            target=self.state.target,
            domain=self.state.domain,
            username=self.state.current_user,
            password=self._get_current_password(),
            rules=self.rules,
        )

    def _get_current_password(self) -> Optional[str]:
        """Get password for current authenticated user."""
        if not self.state.current_user:
            return None

        for cred in self.state.credentials.values():
            if cred.username == self.state.current_user and cred.validated:
                return cred.value

        return None

    # ========================================================================
    # STATE INSPECTION
    # ========================================================================

    def get_findings_by_type(self, finding_type: FindingType) -> List[Finding]:
        """Get all findings of a specific type."""
        return [
            f for f in self.state.findings.values()
            if f.finding_type == finding_type
        ]

    def get_pending_count(self) -> int:
        """Get number of pending recommendations."""
        return len(self.state.pending_recommendations)

    def get_completed_count(self) -> int:
        """Get number of completed recommendations."""
        return len(self.state.completed_actions)

    def get_stats(self) -> Dict[str, Any]:
        """Get engine statistics."""
        return {
            "target": self.state.target,
            "domain": self.state.domain,
            "access_level": self.state.current_access_level,
            "current_user": self.state.current_user,
            "findings": len(self.state.findings),
            "credentials": len(self.state.credentials),
            "validated_credentials": len(self.state.get_validated_credentials()),
            "pending_recommendations": len(self.state.pending_recommendations),
            "completed_actions": len(self.state.completed_actions),
            "skipped_actions": len(self.state.skipped_actions),
            "session_duration": (datetime.now() - self.state.session_start).seconds,
        }

    def export_state(self) -> Dict[str, Any]:
        """Export current state for persistence."""
        return {
            "target": self.state.target,
            "domain": self.state.domain,
            "findings": {
                fid: {
                    "id": f.id,
                    "type": f.finding_type.name,
                    "source": f.source,
                    "target": f.target,
                    "raw_value": str(f.raw_value),
                    "decoded_value": f.decoded_value,
                    "tags": f.tags,
                    "metadata": f.metadata,
                }
                for fid, f in self.state.findings.items()
            },
            "credentials": {
                cid: {
                    "id": c.id,
                    "username": c.username,
                    "type": c.credential_type.name,
                    "validated": c.validated,
                    "access_level": c.access_level,
                }
                for cid, c in self.state.credentials.items()
            },
            "completed_actions": self.state.completed_actions,
            "skipped_actions": self.state.skipped_actions,
            "access_level": self.state.current_access_level,
            "current_user": self.state.current_user,
        }
