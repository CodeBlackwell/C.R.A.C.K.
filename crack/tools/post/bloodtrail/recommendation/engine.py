"""
BloodTrail Recommendation Engine.

Core state machine that:
1. Receives findings from enumerators
2. Matches findings against trigger rules
3. Generates and prioritizes recommendations
4. Tracks state to avoid repetition
"""

import uuid
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime

from .models import (
    Finding,
    FindingType,
    Recommendation,
    RecommendationPriority,
    AttackState,
    Credential,
    CredentialType,
)
from .triggers import (
    TriggerRule,
    TRIGGER_RULES,
    get_recommendations_for_finding,
    match_finding,
)
from .decoders import (
    decode_value,
    decrypt_vnc_password,
    extract_vnc_password_from_reg,
    looks_like_password,
    DecodeResult,
)


class RecommendationEngine:
    """
    Core recommendation engine for BloodTrail.

    Manages the finding → recommendation flow:
    1. Add findings from enumeration
    2. Process findings through trigger rules
    3. Generate prioritized recommendations
    4. Track completed/skipped actions
    5. Present one recommendation at a time
    """

    def __init__(
        self,
        target: str,
        domain: Optional[str] = None,
        rules: Optional[List[TriggerRule]] = None,
    ):
        """
        Initialize the recommendation engine.

        Args:
            target: Target IP or hostname
            domain: Domain name (if known)
            rules: Custom trigger rules (defaults to built-in rules)
        """
        self.state = AttackState(target=target, domain=domain)
        self.rules = rules or TRIGGER_RULES
        self._finding_callbacks: List[Callable[[Finding], None]] = []
        self._recommendation_callbacks: List[Callable[[Recommendation], None]] = []

    # ========================================================================
    # PUBLIC API
    # ========================================================================

    def add_finding(self, finding: Finding) -> List[Recommendation]:
        """
        Add a new finding and process it.

        Args:
            finding: The finding to add

        Returns:
            List of new recommendations generated by this finding
        """
        # Skip if we already have this finding
        if finding.id in self.state.findings:
            return []

        # Store the finding
        self.state.add_finding(finding)

        # Notify callbacks
        for callback in self._finding_callbacks:
            callback(finding)

        # Process through trigger rules
        new_recommendations = self._process_finding(finding)

        # Add to state and notify
        for rec in new_recommendations:
            self.state.add_recommendation(rec)
            for callback in self._recommendation_callbacks:
                callback(rec)

        return new_recommendations

    def add_credential(
        self,
        username: str,
        password: str,
        credential_type: CredentialType = CredentialType.PASSWORD,
        validated: bool = False,
        access_level: Optional[str] = None,
        source_finding: Optional[str] = None,
        domain: Optional[str] = None,
    ) -> Credential:
        """
        Add a discovered credential.

        Args:
            username: The username
            password: The password/hash/etc
            credential_type: Type of credential
            validated: Whether credential has been tested
            access_level: Access level if validated
            source_finding: Finding ID that led to this credential
            domain: Domain for this credential

        Returns:
            The created Credential object
        """
        cred = Credential(
            id=f"cred_{username}_{uuid.uuid4().hex[:8]}",
            username=username,
            credential_type=credential_type,
            value=password,
            domain=domain or self.state.domain,
            validated=validated,
            access_level=access_level,
            source_finding=source_finding,
        )

        self.state.add_credential(cred)

        # If validated, create a finding for it
        if validated:
            finding = Finding(
                id=f"finding_valid_cred_{cred.id}",
                finding_type=FindingType.CREDENTIAL,
                source="credential_validation",
                target=username,
                raw_value=password,
                tags=["validated"],
                metadata={
                    "username": username,
                    "access_level": access_level,
                    "credential_id": cred.id,
                },
            )
            self.add_finding(finding)

        return cred

    def validate_credential(
        self,
        credential_id: str,
        access_level: str = "user",
    ) -> None:
        """Mark a credential as validated."""
        if credential_id in self.state.credentials:
            cred = self.state.credentials[credential_id]
            cred.validated = True
            cred.access_level = access_level
            self.state.current_access_level = access_level
            self.state.current_user = cred.username

    def get_next_recommendation(self) -> Optional[Recommendation]:
        """
        Get the highest priority pending recommendation.

        Returns:
            Next recommendation or None if queue is empty
        """
        return self.state.get_next_recommendation()

    def complete_recommendation(self, rec_id: str) -> None:
        """Mark a recommendation as completed."""
        self.state.complete_recommendation(rec_id)

    def complete_recommendation_with_result(
        self,
        rec_id: str,
        success: bool,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> List[Recommendation]:
        """
        Complete a recommendation and process on_success/on_failure chains.

        This is used by the auto-orchestrator to chain recommendations together.

        Args:
            rec_id: Recommendation ID
            success: Whether execution succeeded
            metadata: Additional context (e.g., access_level for creds)

        Returns:
            List of new recommendations queued from the chain
        """
        # Find the recommendation before completing it
        rec = None
        for r in self.state.pending_recommendations:
            if r.id == rec_id:
                rec = r
                break

        if not rec:
            return []

        # Mark as complete
        self.complete_recommendation(rec_id)

        # Process chain
        new_recs = []
        chain_templates = rec.on_success if success else rec.on_failure

        if not chain_templates:
            return new_recs

        # Create chained recommendations
        for template_name in chain_templates:
            chained_rec = self._create_chained_recommendation(
                template_name=template_name,
                source_rec=rec,
                metadata=metadata or {},
            )
            if chained_rec:
                self.state.add_recommendation(chained_rec)
                new_recs.append(chained_rec)

                # Notify callbacks
                for callback in self._recommendation_callbacks:
                    callback(chained_rec)

        return new_recs

    def _create_chained_recommendation(
        self,
        template_name: str,
        source_rec: Recommendation,
        metadata: Dict[str, Any],
    ) -> Optional[Recommendation]:
        """
        Create a recommendation from an on_success/on_failure template.

        Args:
            template_name: Name of the template to instantiate
            source_rec: The source recommendation that triggered this
            metadata: Additional context from execution result

        Returns:
            New recommendation or None if template not found
        """
        from .triggers import (
            create_smb_enum_recommendation,
            create_winrm_check_recommendation,
            create_bloodhound_recommendation,
            create_smb_crawl_recommendation,
            create_crack_hash_recommendation,
            create_test_cracked_credential_recommendation,
            create_pass_the_hash_recommendation,
            # Privilege escalation chain
            create_user_exchange_perms_recommendation,
            create_add_objectacl_recommendation,
            create_dcsync_recommendation,
        )

        # Get credential context from source rec or metadata
        username = metadata.get("username") or source_rec.metadata.get("username")
        password = metadata.get("password") or source_rec.metadata.get("password")
        access_level = metadata.get("access_level", "user")

        # Create a synthetic finding for the chained recommendation
        finding = Finding(
            id=f"chain_{source_rec.id}_{template_name}",
            finding_type=FindingType.CREDENTIAL,
            source="auto_chain",
            target=username or "unknown",
            raw_value="chained",
            tags=["validated", "chained"],
            metadata={
                "username": username,
                "password": password,
                "access_level": access_level,
                "source_rec": source_rec.id,
            },
        )

        # Map template names to creation functions

        # Hash cracking templates
        if template_name == "crack_hash":
            hash_value = metadata.get("hash")
            hash_type = metadata.get("hash_type", "asrep")
            if hash_value and username:
                return create_crack_hash_recommendation(
                    finding=finding,
                    hash_value=hash_value,
                    hash_type=hash_type,
                    username=username,
                    target=self.state.target,
                    domain=self.state.domain,
                )

        # Credential testing templates
        elif template_name == "test_cracked_credential":
            if username and password:
                return create_test_cracked_credential_recommendation(
                    finding=finding,
                    username=username,
                    password=password,
                    target=self.state.target,
                    domain=self.state.domain,
                )

        # Pass-the-hash templates
        elif template_name == "pass_the_hash":
            ntlm_hash = metadata.get("full_hash") or metadata.get("admin_hash")
            pth_user = metadata.get("username", "Administrator")
            if ntlm_hash:
                return create_pass_the_hash_recommendation(
                    finding=finding,
                    username=pth_user,
                    ntlm_hash=ntlm_hash,
                    target=self.state.target,
                    domain=self.state.domain,
                )

        # SMB enumeration
        elif template_name == "enumerate_smb_shares" and username and password:
            return create_smb_enum_recommendation(
                finding=finding,
                target=self.state.target,
                username=username,
                password=password,
                domain=self.state.domain,
            )

        # WinRM check
        elif template_name == "check_winrm" and username and password:
            return create_winrm_check_recommendation(
                finding=finding,
                target=self.state.target,
                username=username,
                password=password,
                domain=self.state.domain,
            )

        # BloodHound collection
        elif template_name == "collect_bloodhound" and username and password:
            return create_bloodhound_recommendation(
                finding=finding,
                target=self.state.target,
                username=username,
                password=password,
                domain=self.state.domain,
            )

        # SMB share crawling
        elif template_name == "crawl_smb_shares" and username and password:
            return create_smb_crawl_recommendation(
                finding=finding,
                target=self.state.target,
                username=username,
                password=password,
                domain=self.state.domain,
            )

        # =====================================================================
        # PRIVILEGE ESCALATION CHAIN (Forest-style)
        # =====================================================================

        # Account Operators → Create user → Add to Exchange Windows Permissions
        elif template_name == "create_user_exchange_perms" and username and password:
            return create_user_exchange_perms_recommendation(
                finding=finding,
                target=self.state.target,
                username=username,
                password=password,
                domain=self.state.domain,
            )

        # Exchange Windows Permissions → Grant DCSync rights via Add-ObjectACL
        elif template_name == "add_objectacl_dcsync":
            # Get DCSync user credentials from source_rec metadata (created user)
            dcsync_user = metadata.get("new_user") or source_rec.metadata.get("new_user", "bloodtrail")
            dcsync_pass = metadata.get("new_password") or source_rec.metadata.get("new_password", "B1oodTr@il123!")
            return create_add_objectacl_recommendation(
                finding=finding,
                target=self.state.target,
                domain=self.state.domain,
                dcsync_user=dcsync_user,
                dcsync_pass=dcsync_pass,
            )

        # DCSync - Extract all domain hashes using secretsdump
        elif template_name == "dcsync_secretsdump":
            # Get DCSync user credentials from source_rec metadata
            dcsync_user = metadata.get("dcsync_user") or source_rec.metadata.get("dcsync_user", "bloodtrail")
            dcsync_pass = metadata.get("dcsync_password") or source_rec.metadata.get("dcsync_password", "B1oodTr@il123!")
            return create_dcsync_recommendation(
                finding=finding,
                target=self.state.target,
                domain=self.state.domain,
                dcsync_user=dcsync_user,
                dcsync_pass=dcsync_pass,
            )

        # Unknown template
        return None

    def skip_recommendation(self, rec_id: str) -> None:
        """Mark a recommendation as skipped."""
        self.state.skip_recommendation(rec_id)

    def on_finding(self, callback: Callable[[Finding], None]) -> None:
        """Register a callback for new findings."""
        self._finding_callbacks.append(callback)

    def on_recommendation(self, callback: Callable[[Recommendation], None]) -> None:
        """Register a callback for new recommendations."""
        self._recommendation_callbacks.append(callback)

    # ========================================================================
    # FINDING CREATION HELPERS
    # ========================================================================

    def create_ldap_attribute_finding(
        self,
        username: str,
        attribute_name: str,
        attribute_value: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """
        Create a finding for a custom LDAP attribute.

        Auto-decodes the value if it looks encoded.
        """
        finding = Finding(
            id=f"ldap_attr_{username}_{attribute_name}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.LDAP_ATTRIBUTE,
            source=source,
            target=attribute_name,
            raw_value=attribute_value,
            metadata={
                "username": username,
                "attribute_name": attribute_name,
            },
        )

        # Try to auto-decode
        result = decode_value(attribute_value)
        if result.success:
            finding.decoded_value = result.decoded
            finding.decode_method = result.method.name if result.method else None
            finding.add_tag("decoded")
            finding.add_tag(result.method.name.lower() if result.method else "unknown")
            if looks_like_password(result.decoded):
                finding.add_tag("likely_password")

        return finding

    def create_file_finding(
        self,
        file_path: str,
        file_content: Optional[str] = None,
        source: str = "smb_crawl",
        tags: Optional[List[str]] = None,
    ) -> Finding:
        """
        Create a finding for an interesting file.

        Extracts embedded credentials for known file types.
        """
        finding = Finding(
            id=f"file_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.FILE,
            source=source,
            target=file_path,
            raw_value=file_content,
            tags=tags or [],
            metadata={
                "file_path": file_path,
                "has_content": file_content is not None,
            },
        )

        # Check for VNC registry file
        if file_path.lower().endswith('.reg') and 'vnc' in file_path.lower():
            finding.add_tag("vnc")
            if file_content:
                encrypted_hex = extract_vnc_password_from_reg(file_content)
                if encrypted_hex:
                    finding.metadata["encrypted_hex"] = encrypted_hex
                    finding.add_tag("encrypted_password")

                    # Try to decrypt
                    result = decrypt_vnc_password(encrypted_hex)
                    if result.success:
                        finding.decoded_value = result.decoded
                        finding.decode_method = "VNC_DES"
                        finding.add_tag("decrypted")

        # Check for SQLite
        if any(file_path.lower().endswith(ext) for ext in ['.db', '.sqlite', '.sqlite3']):
            finding.add_tag("database")

        # Check for .NET binary
        if any(file_path.lower().endswith(ext) for ext in ['.exe', '.dll']):
            if file_content and (b'mscorlib' in file_content.encode() if isinstance(file_content, str) else b'mscorlib' in file_content):
                finding.add_tag("dotnet")

        return finding

    def create_group_membership_finding(
        self,
        username: str,
        group_name: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """Create a finding for an interesting group membership."""
        finding = Finding(
            id=f"group_{username}_{group_name}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.GROUP_MEMBERSHIP,
            source=source,
            target=group_name,
            raw_value=group_name,
            metadata={
                "username": username,
                "group_name": group_name,
            },
        )

        # Tag privileged groups
        privileged_patterns = [
            "admin", "domain admin", "enterprise admin", "recycle bin",
            "backup operator", "server operator", "account operator",
            "dnsadmin", "gpo creator", "schema admin",
        ]
        for pattern in privileged_patterns:
            if pattern in group_name.lower():
                finding.add_tag("privileged_group")
                break

        # Specific group tags for privilege escalation triggers
        group_lower = group_name.lower()

        # Account Operators - can create users and add to groups
        if "account operator" in group_lower:
            finding.add_tag("ACCOUNT_OPERATORS")

        # Exchange Windows Permissions - has WriteDACL on domain
        if "exchange windows permissions" in group_lower:
            finding.add_tag("EXCHANGE_WINDOWS_PERMISSIONS")

        # AD Recycle Bin - can read deleted objects
        if "recycle bin" in group_lower:
            finding.add_tag("RECYCLE_BIN")

        # Backup Operators - can backup/restore
        if "backup operator" in group_lower:
            finding.add_tag("BACKUP_OPERATORS")

        return finding

    def create_user_flag_finding(
        self,
        username: str,
        flag: str,
        source: str = "ldap_enum",
    ) -> Finding:
        """Create a finding for an interesting user account flag."""
        finding = Finding(
            id=f"flag_{username}_{flag}_{uuid.uuid4().hex[:8]}",
            finding_type=FindingType.USER_FLAG,
            source=source,
            target=username,
            raw_value=flag,
            tags=[flag.upper()],
            metadata={
                "username": username,
                "flag": flag,
            },
        )

        return finding

    # ========================================================================
    # INTERNAL METHODS
    # ========================================================================

    def _process_finding(self, finding: Finding) -> List[Recommendation]:
        """
        Process a finding through trigger rules.

        Returns list of recommendations generated.
        """
        return get_recommendations_for_finding(
            finding=finding,
            target=self.state.target,
            domain=self.state.domain,
            username=self.state.current_user,
            password=self._get_current_password(),
            rules=self.rules,
        )

    def _get_current_password(self) -> Optional[str]:
        """Get password for current authenticated user."""
        if not self.state.current_user:
            return None

        for cred in self.state.credentials.values():
            if cred.username == self.state.current_user and cred.validated:
                return cred.value

        return None

    # ========================================================================
    # STATE INSPECTION
    # ========================================================================

    def get_findings_by_type(self, finding_type: FindingType) -> List[Finding]:
        """Get all findings of a specific type."""
        return [
            f for f in self.state.findings.values()
            if f.finding_type == finding_type
        ]

    def get_pending_count(self) -> int:
        """Get number of pending recommendations."""
        return len(self.state.pending_recommendations)

    def get_completed_count(self) -> int:
        """Get number of completed recommendations."""
        return len(self.state.completed_actions)

    def get_stats(self) -> Dict[str, Any]:
        """Get engine statistics."""
        return {
            "target": self.state.target,
            "domain": self.state.domain,
            "access_level": self.state.current_access_level,
            "current_user": self.state.current_user,
            "findings": len(self.state.findings),
            "credentials": len(self.state.credentials),
            "validated_credentials": len(self.state.get_validated_credentials()),
            "pending_recommendations": len(self.state.pending_recommendations),
            "completed_actions": len(self.state.completed_actions),
            "skipped_actions": len(self.state.skipped_actions),
            "session_duration": (datetime.now() - self.state.session_start).seconds,
        }

    def export_state(self) -> Dict[str, Any]:
        """Export current state for persistence."""
        return {
            "target": self.state.target,
            "domain": self.state.domain,
            "findings": {
                fid: {
                    "id": f.id,
                    "type": f.finding_type.name,
                    "source": f.source,
                    "target": f.target,
                    "raw_value": str(f.raw_value),
                    "decoded_value": f.decoded_value,
                    "tags": f.tags,
                    "metadata": f.metadata,
                }
                for fid, f in self.state.findings.items()
            },
            "credentials": {
                cid: {
                    "id": c.id,
                    "username": c.username,
                    "type": c.credential_type.name,
                    "validated": c.validated,
                    "access_level": c.access_level,
                }
                for cid, c in self.state.credentials.items()
            },
            "completed_actions": self.state.completed_actions,
            "skipped_actions": self.state.skipped_actions,
            "access_level": self.state.current_access_level,
            "current_user": self.state.current_user,
        }
