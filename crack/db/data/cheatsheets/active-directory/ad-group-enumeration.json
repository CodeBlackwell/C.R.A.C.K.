{
  "cheatsheets": [
    {
      "id": "ad-group-enumeration",
      "name": "Active Directory Group Enumeration & Nested Group Unraveling",
      "description": "Comprehensive group membership enumeration including recursive nested group traversal, member identification, and flag extraction - essential for security work lab challenges",
      "educational_header": {
        "how_to_recognize": [
          "pentest lab instruction: 'Enumerate group <NAME> and find all members including nested groups'",
          "Lab instruction: 'Find the last user member and extract the flag'",
          "Lab instruction: 'Identify which new user is in Domain Admins'",
          "You see a group (Domain Admins, Service Personnel, IT Support) and need to know who's actually in it",
          "Group.Properties.member shows CN= paths that include other groups (nested groups present)"
        ],
        "when_to_look_for": [
          "security assessment: Questions specifically mention 'nested groups' or 'enumerate group membership'",
          "After initial AD enumeration when you've identified interesting groups",
          "When looking for privilege escalation paths via group membership",
          "Before lateral movement - need to know which users have admin rights on which machines",
          "When group membership output shows other group DNs (not just user DNs) - indicates nesting"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Unravel 'Service Personnel' Nested Groups for Flag",
          "context": "pentest Lab: You're logged into CLIENT75 as 'stephanie' (domain user corp\\stephanie). Lab instructions say: 'Use PowerView or PowerShell to enumerate the Service Personnel group. Unravel nested groups and find the flag in the last direct user member.' You have PowerShell access and the LDAPSearch function available. The group contains a mix of users and nested groups multiple levels deep.",
          "approach": "Step 1: Create LDAPSearch function for manual queries.\n\nStep 2: Query 'Service Personnel' group to get direct members:\n  LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=Service Personnel))\"\n  Extract member Distinguished Names from Properties.member attribute.\n\nStep 3: For each member DN, query to determine type:\n  LDAPSearch -LDAPQuery \"(distinguishedName=<DN>)\"\n  Check objectClass property: 'group' = nested group (recurse), 'user' = leaf node (record).\n\nStep 4: Build recursive function Get-NestedGroupMember:\n  - Maintains $script:AllUsers array to collect discovered users\n  - Uses $Depth parameter for tree indentation\n  - Recursively calls itself when encountering nested groups\n  - Depth-first traversal ensures systematic coverage.\n\nStep 5: Execute enumeration and extract flag:\n  Get-NestedGroupMember -GroupName \"Service Personnel\"\n  Access last user: $script:AllUsers[-1]\n  Check flag locations: description, info, comment attributes.",
          "commands": [
            "ps-ldapsearch-function",
            "ps-get-group-members-basic",
            "ps-nested-group-check-member-type",
            "ps-nested-group-recursive-function",
            "ps-get-last-nested-user",
            "ps-extract-flag-from-user"
          ],
          "expected_outcome": "Output shows hierarchical tree:\n\n[+] Service Personnel\n  [USER] stephanie\n  [USER] jeff\n  [GROUP] IT Support\n    [GROUP] Developers\n      [USER] john_dev\n\nLAST USER: john_dev\nFLAG LOCATIONS:\ndescription : flag{nested_groups_unraveled_success}\n\nThe 'last user' is the final user discovered during depth-first traversal (john_dev). Flag is in the description attribute. Total enumeration time: 15-20 seconds including manual typing. Copy-paste one-liner completes in 10 seconds.",
          "why_this_works": "Active Directory stores group members in the 'member' attribute as Distinguished Names. When a DN references another group (CN=IT Support,CN=Users,...), that's a nested group requiring recursive enumeration. The objectClass attribute distinguishes groups from users. Recursion naturally handles arbitrary nesting depth (pentest labs typically 2-4 levels). The $script: scope persists the AllUsers array across recursive calls without polluting global scope. Array index [-1] always gets the last element regardless of total count. Flags are stored in user attributes (description most common) - these are standard AD text fields administrators populate."
        },
        {
          "title": "Scenario 2: Identify New Domain Admin User",
          "context": "pentest Lab: Instructions say: 'A new user has been added to Domain Admins. Identify the username.' You're on CLIENT75 as stephanie with PowerShell access. The domain is corp.com with a few legacy Domain Admins (Administrator, krbtgt may be members) and one recently added account. You need to determine which account is newest based on creation date.",
          "approach": "Step 1: Query Domain Admins group membership:\n  LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=Domain Admins))\"\n  Extract all member DNs from Properties.member.\n\nStep 2: For each member, query full user object:\n  LDAPSearch -LDAPQuery \"(distinguishedName=<DN>)\"\n  Extract: samAccountName (username), whencreated (creation timestamp).\n\nStep 3: Sort by creation date:\n  Create PSCustomObject with Name, Created, DN\n  Sort-Object Created (oldest first)\n  Display in table format.\n\nStep 4: Identify newest account:\n  Last entry in sorted list = newest account\n  Built-in accounts (Administrator) have creation date = domain creation (years old)\n  New account has recent timestamp (days/weeks old).\n\nAlternative (PowerView): Get-DomainGroupMember -Identity \"Domain Admins\" | Select MemberName",
          "commands": [
            "ps-ldapsearch-function",
            "ps-find-new-domain-admin"
          ],
          "expected_outcome": "Output table:\n\nName            Created                  DN\n----            -------                  --\nAdministrator   2018-05-14 08:23:15     CN=Administrator,CN=Users,DC=corp,DC=com\nkrbtgt          2018-05-14 08:24:01     CN=krbtgt,CN=Users,DC=corp,DC=com\njeff_admin      2024-11-06 14:35:22     CN=jeff_admin,CN=Users,DC=corp,DC=com\n\nAnswer: jeff_admin (newest whencreated timestamp). Built-in accounts are years old (domain creation date). New account is recent (days/weeks old). Time: 10 seconds.",
          "why_this_works": "Every AD object has a whencreated attribute populated at creation time (UTC timestamp). This is immutable - cannot be modified even by Domain Admins. Sorting by whencreated chronologically reveals account creation order. Built-in accounts (Administrator, krbtgt, Guest) are created during domain setup (dcpromo) and always have oldest timestamps. User-created accounts have timestamps matching when they were added. pentest labs typically have 1-2 legacy accounts and 1 new account for the answer."
        },
        {
          "title": "Scenario 3: Service Account Discovery in Group Hierarchies",
          "context": "You've enumerated the 'Service Personnel' group and found multiple nested groups (IT Support, Database Admins, Backup Operators). You suspect service accounts are buried in these groups - service accounts often have weak passwords and high privileges. You need to identify all service accounts across the entire group hierarchy for targeted password attacks.",
          "approach": "Step 1: Enumerate entire group hierarchy:\n  Get-NestedGroupMember -GroupName \"Service Personnel\" -UsersOnly\n  Collects all users at all nesting levels.\n\nStep 2: Filter by naming patterns:\n  Common patterns: *svc*, *sql*, *backup*, *service*, sa (SQL Server default)\n  Use PowerShell Where-Object: | Where-Object { $_.samaccountname -like \"*svc*\" }\n\nStep 3: Check for SPNs (Kerberoastable):\n  LDAPSearch -LDAPQuery \"(&(objectCategory=user)(servicePrincipalName=*))\"\n  Service accounts often have SPNs registered (HTTP/sql01.corp.com)\n\nStep 4: Identify high-value targets:\n  - Check pwdlastset (old = password rarely changed)\n  - Check adminCount (1 = privileged account)\n  - Check description (often contains password hints)\n\nPowerView alternative: Get-DomainGroupMember -Identity \"Service Personnel\" -Recurse | Where-Object { $_.MemberName -like \"*svc*\" }",
          "commands": [
            "ps-nested-group-recursive-function",
            "ps-powerview-find-service-accounts",
            "ps-ldapsearch-spns"
          ],
          "expected_outcome": "Discovery of service accounts:\n\n[USER] sql_svc\n[USER] backup_service\n[USER] iis_appool\n\nWith details:\nsql_svc:\n  description: SQL Server service account - password in vault\n  pwdlastset: 2018-05-14 (6 years old - likely weak password)\n  servicePrincipalName: MSSQLSvc/SQL01.corp.com:1433\n  adminCount: 1 (privileged)\n\nTarget sql_svc for:\n- Kerberoasting (has SPN)\n- Password spray (description hints at password location)\n- Over-privileged (adminCount=1, likely in Domain Admins)\n\nTime: 30 seconds for complete service account profiling.",
          "why_this_works": "Service accounts follow naming conventions for identification (*svc*, *sql*, *service*). They require SPNs for Kerberos authentication (servicePrincipalName attribute). Administrators rarely rotate service account passwords (business impact if changed) - pwdlastset timestamps reveal this. Service accounts are often over-privileged (added to Domain Admins for convenience) - adminCount=1 indicates this. Description fields contain password hints, vault references, or occasionally plaintext passwords. Combining group membership + naming pattern + SPN + password age identifies high-value targets for credential attacks."
        },
        {
          "title": "Scenario 4: PowerView vs Manual .NET - Method Comparison",
          "context": "You have RDP access to CLIENT75 and need to enumerate nested groups. You're unsure whether to use PowerView (if available) or manual .NET methods. You need to understand the tradeoffs: speed vs stealth, tool dependency vs native capabilities, security assessment reliability.",
          "approach": "PowerView Method (if available):\n  1. Check if loaded: Get-Command Get-DomainGroupMember\n  2. If not loaded: Import-Module .\\PowerView.ps1 or IEX download\n  3. Check version: Try Get-NetGroupMember (v2.0) vs Get-DomainGroupMember (v3.0+)\n  4. Execute: Get-DomainGroupMember -Identity \"<GROUP>\" -Recurse\n  5. Filter users: | Where-Object { $_.MemberObjectClass -eq \"user\" }\n  6. Get details: Get-DomainUser -Identity <USERNAME> | Format-List *\n  Time: 5 seconds (if PowerView loaded), 60 seconds (if need to download/import).\n\nManual .NET Method (always available):\n  1. Create LDAPSearch function (30 lines of PowerShell)\n  2. Create Get-NestedGroupMember recursive function\n  3. Execute enumeration\n  4. Extract user details from $script:AllUsers array\n  Time: 20 seconds (if typing), 10 seconds (if copy-paste one-liner).\n\nTradeoffs:\n  PowerView: Fast, feature-rich, well-documented | Requires import, may trigger AV, version compatibility issues\n  Manual .NET: Always available, native code, no imports | More typing, need to understand recursion logic",
          "commands": [
            "powerview-get-domaingroup-recursive",
            "ps-powerview-get-user-details",
            "ps-nested-group-one-liner",
            "ps-compare-powerview-versions"
          ],
          "expected_outcome": "Decision matrix:\n\nUse PowerView when:\n- Already loaded/available\n- Time-critical (security assessment - 5 hour timer)\n- Need additional features (ACL enumeration, GPO abuse)\n- Stealth not a concern\n\nUse Manual .NET when:\n- PowerView unavailable/blocked\n- AV detects PowerView import\n- Constrained Language Mode (PowerView may fail)\n- Learning exercise (understand LDAP queries)\n- Version compatibility issues (v2.0 vs v3.0+ confusion)\n\nsecurity assessment Recommendation:\nKnow BOTH methods. PowerView is faster but not guaranteed available. Manual .NET always works. Have the one-liner ready to copy-paste: ps-nested-group-one-liner command.\n\nTime comparison:\n  PowerView (loaded): 5 seconds\n  PowerView (need import): 60 seconds + AV risk\n  Manual .NET (typing): 20 seconds\n  Manual .NET (one-liner): 10 seconds",
          "why_this_works": "PowerView is a PowerShell module wrapping LDAP/SMB .NET APIs. It provides convenience (automatic recursion, SID resolution, formatted output) but adds dependency (need to import, version compatibility). Manual .NET methods use System.DirectoryServices.DirectorySearcher - built into Windows .NET Framework since Windows 2000. No imports required, no version issues, works in restricted environments. Both methods generate identical LDAP traffic (port 389 queries to DC). The recursion logic is the same - PowerView just abstracts it. security assessment reliability: Manual methods never fail due to missing tools. PowerView fails if blocked by AV, AppLocker, or Constrained Language Mode."
        },
        {
          "title": "Scenario 5: Complete pentest Lab Workflow - Group to Flag",
          "context": "Full pentest lab scenario: 'Start VM Group 2, log in to CLIENT75 as stephanie. Use PowerShell to enumerate the Service Personnel group, starting with basic enumeration. Unravel nested groups, enumerate attributes for the last direct user member, and obtain the flag.' This is the complete step-by-step workflow from login to flag submission.",
          "approach": "Step 1 - Verify domain access:\n  whoami /fqdn\n  Expected: corp\\stephanie\n  Confirms domain credentials and context.\n\nStep 2 - Open PowerShell:\n  Start menu \u2192 Windows PowerShell\n  Or from cmd: powershell.exe\n\nStep 3 - Create LDAP infrastructure:\n  Paste LDAPSearch function (ps-ldapsearch-function)\n  Verify: LDAPSearch -LDAPQuery \"(objectClass=user)\"\n  Should return user objects.\n\nStep 4 - Basic group enumeration:\n  LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=Service Personnel))\"\n  Check Properties.member to see if nested groups exist\n  Look for CN= paths containing other group names.\n\nStep 5 - Recursive enumeration (choose method):\n  Method A (PowerView): Get-DomainGroupMember -Identity \"Service Personnel\" -Recurse\n  Method B (Manual): Copy-paste ps-nested-group-one-liner\n\nStep 6 - Identify last user:\n  PowerView: ($members | Where-Object { $_.MemberObjectClass -eq \"user\" })[-1]\n  Manual: $script:AllUsers[-1]\n\nStep 7 - Extract all attributes:\n  PowerView: Get-DomainUser -Identity <USERNAME> | Format-List *\n  Manual: foreach ($prop in $lastUser.Properties.PropertyNames) { \"$prop : $($lastUser.Properties[$prop])\" }\n\nStep 8 - Locate flag:\n  Search output for 'description', 'info', 'comment' fields\n  Flag format: flag{...}, OS{...}, or plaintext\n  Sometimes Base64 encoded.\n\nStep 9 - Submit flag:\n  Copy exact flag value\n  Paste into lab submission box\n  Document process in enumeration.md",
          "commands": [
            "ps-ldapsearch-function",
            "ps-get-group-members-basic",
            "ps-nested-group-recursive-function",
            "ps-get-last-nested-user",
            "ps-extract-flag-from-user",
            "ps-nested-group-one-liner"
          ],
          "expected_outcome": "Complete walkthrough:\n\n1. Login confirmed: corp\\stephanie@CLIENT75\n2. PowerShell opened\n3. LDAPSearch function created (30 seconds)\n4. Group queried: Service Personnel has 3 direct members\n5. Recursion reveals structure:\n   Service Personnel\n     stephanie (user)\n     jeff (user)\n     IT Support (group)\n       Developers (group)\n         john_dev (user)\n6. Last user identified: john_dev\n7. Attributes extracted: 50+ properties\n8. Flag found in description: flag{nested_enumeration_complete}\n9. Flag submitted successfully\n\nTotal time: 2-3 minutes (first time), 30 seconds (with practice)\n\nsecurity assessment application:\n- Same pattern appears in exam labs\n- 'Find flag in nested group' worth 10 points typically\n- Fast completion = more time for other machines\n- Always document your methodology",
          "why_this_works": "This workflow combines reconnaissance (verify domain context), tool selection (PowerView vs manual), systematic enumeration (breadth-first group discovery, depth-first nested traversal), and targeted extraction (last user attribute search). Each step has a verification point (does output match expected?). The workflow handles both PowerView availability scenarios (use if available, fallback to manual if not). Time estimates are realistic for security assessment conditions (pressure, unfamiliar environment). Documentation habit (enumeration.md) reinforces methodology for exam report. This is the exact pattern used in OffSec lab exercises - practicing this workflow builds muscle memory for exam day."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Group Discovery & Basic Enumeration",
          "notes": "Start by identifying target groups and their direct members. Determine if nested groups exist by checking member Distinguished Names. If member DNs reference other groups (CN=GroupName in member list), nesting is present and requires recursion.",
          "commands": [
            {
              "id": "ps-ldapsearch-function",
              "example": "function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$PDC/$DistinguishedName\"); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }",
              "shows": "Function created successfully"
            },
            {
              "id": "ps-get-group-members-basic",
              "example": "$groupResult = LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=Domain Admins))\"; $group = $groupResult[0]; $group.Properties.member",
              "shows": "CN="
            }
          ]
        },
        {
          "title": "Phase 2: Member Type Identification",
          "notes": "For each group member (by Distinguished Name), query the object to determine if it's a user (leaf node - record) or nested group (branch node - recurse). Use objectClass attribute: 'group' = nested group, 'user' = leaf user.",
          "commands": [
            {
              "id": "ps-nested-group-check-member-type",
              "example": "$memberDN = \"CN=Administrator,CN=Users,DC=corp,DC=com\"; $memberSearch = LDAPSearch -LDAPQuery \"(distinguishedName=$memberDN)\"; $member = $memberSearch[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \"group\") { Write-Host \"[GROUP] $($member.Properties.name[0])\" -ForegroundColor Magenta } elseif ($objectClass -contains \"user\") { Write-Host \"[USER] $($member.Properties.name[0])\" -ForegroundColor Green }",
              "shows": "[GROUP]"
            }
          ]
        },
        {
          "title": "Phase 3: Recursive Nested Group Traversal",
          "notes": "Implement or use recursive function to systematically traverse the group hierarchy. Maintain a collection ($script:AllUsers) of discovered users. Use depth-first traversal with indentation for visualization. Handle arbitrary nesting depth (certification labs typically 2-4 levels).",
          "commands": [
            {
              "id": "ps-nested-group-recursive-function",
              "example": "function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = \"  \" * $Depth; Write-Host \"$indent[+] $GroupName\" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=$GroupName))\"; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery \"(distinguishedName=$memberDN)\"; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \"group\") { Write-Host \"$indent  [GROUP] $memberName\" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains \"user\") { Write-Host \"$indent  [USER] $memberName\" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName \"Service Personnel\"",
              "shows": "[+]"
            },
            {
              "id": "ps-nested-group-one-liner",
              "example": "function LDAPSearch { param([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$PDC/$DN\"); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }; function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = \"  \" * $Depth; Write-Host \"$indent[+] $GroupName\" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=$GroupName))\"; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery \"(distinguishedName=$memberDN)\"; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \"group\") { Write-Host \"$indent  [GROUP] $memberName\" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains \"user\") { Write-Host \"$indent  [USER] $memberName\" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName \"Service Personnel\"; if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host \"`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])\" -ForegroundColor Yellow; Write-Host \"[+] FLAG LOCATIONS:\" -ForegroundColor Yellow; @('description','info','comment') | ForEach-Object { $value = $lastUser.Properties[$_][0]; if ($value) { Write-Host \"$_ : $value\" -ForegroundColor Cyan } } }",
              "shows": "Hierarchical tree output"
            }
          ]
        },
        {
          "title": "Phase 4: PowerView Alternative Methods",
          "notes": "If PowerView is available, use automated cmdlets for faster enumeration. Check version compatibility (v2.0 uses -GroupName, v3.0+ uses -Identity). Use -Recurse parameter for automatic nested group traversal. PowerView flattens hierarchy into single list.",
          "commands": [
            {
              "id": "powerview-get-domaingroup-recursive",
              "example": "Get-DomainGroupMember -Identity \"Domain Admins\" -Recurse",
              "shows": "MemberName"
            },
            {
              "id": "ps-powerview-get-user-details",
              "example": "Get-DomainUser -Identity \"jeff_admin\" | Format-List *",
              "shows": "samaccountname"
            },
            {
              "id": "ps-compare-powerview-versions",
              "example": "Get-Command Get-NetGroupMember -ErrorAction SilentlyContinue | Select-Object -ExpandProperty ParameterSets | Select-Object -First 1 | Select-Object -ExpandProperty Parameters | Select-Object Name | Where-Object { $_.Name -like \"*Group*\" -or $_.Name -like \"*Identity*\" }",
              "shows": "GroupName"
            }
          ]
        },
        {
          "title": "Phase 5: User Attribute Extraction & Flag Discovery",
          "notes": "After identifying target user (often 'last user' in enumeration), extract all AD attributes. Focus on text fields: description (most common flag location), info, comment, adminDescription. Check for Base64 encoding. Format: flag{...}, OS{...}, or plaintext hints.",
          "commands": [
            {
              "id": "ps-get-last-nested-user",
              "example": "if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host \"`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])\" -ForegroundColor Yellow; foreach ($prop in $lastUser.Properties.PropertyNames) { Write-Host \"$prop : $($lastUser.Properties[$prop])\" -ForegroundColor White } } else { Write-Host \"[-] No users found\" -ForegroundColor Red }",
              "shows": "LAST USER:"
            },
            {
              "id": "ps-extract-flag-from-user",
              "example": "$user = LDAPSearch -LDAPQuery \"(samAccountName=jeff_admin)\"; $user = $user[0]; Write-Host \"`n[+] Checking flag locations:\" -ForegroundColor Yellow; @('description','info','comment','adminDescription','userParameters') | ForEach-Object { $value = $user.Properties[$_][0]; if ($value) { Write-Host \"$_ : $value\" -ForegroundColor Cyan } }",
              "shows": "description :"
            },
            {
              "id": "ps-powerview-get-user-details",
              "example": "Get-DomainUser -Identity \"jeff_admin\" | Format-List *",
              "shows": "samaccountname"
            }
          ]
        },
        {
          "title": "Phase 6: Specialized Queries - Service Accounts & New Admins",
          "notes": "Advanced group enumeration: Find service accounts by naming pattern (*svc*, *sql*) combined with SPN presence. Identify new Domain Admins by sorting on whencreated timestamp. Profile high-value targets for credential attacks (old passwords, over-privileged, Kerberoastable).",
          "commands": [
            {
              "id": "ps-find-new-domain-admin",
              "example": "LDAPSearch -LDAPQuery \"(&(objectCategory=group)(name=Domain Admins))\" | ForEach-Object { $_.Properties.member } | ForEach-Object { $memberDN = $_; $userSearch = LDAPSearch -LDAPQuery \"(distinguishedName=$memberDN)\"; $user = $userSearch[0]; [PSCustomObject]@{ Name = $user.Properties.samaccountname[0]; Created = $user.Properties.whencreated[0]; DN = $memberDN } } | Sort-Object Created | Format-Table -AutoSize",
              "shows": "Name"
            },
            {
              "id": "ps-powerview-find-service-accounts",
              "example": "Get-DomainGroupMember -Identity \"Service Personnel\" -Recurse | Where-Object { $_.MemberObjectClass -eq \"user\" -and $_.MemberName -like \"*svc*\" }",
              "shows": "MemberName"
            },
            {
              "id": "ps-ldapsearch-spns",
              "example": "LDAPSearch -LDAPQuery \"(&(objectClass=user)(servicePrincipalName=*))\"",
              "shows": "serviceprincipalname"
            }
          ]
        }
      ],
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "GROUPS",
        "NESTED_GROUPS",
        "POWERSHELL",
        "POWERVIEW",
        "FLAG_EXTRACTION",
        "STARTER"
      ]
    }
  ]
}