{
  "cheatsheets": [
    {
      "id": "ad-initial-reconnaissance",
      "name": "Active Directory Initial Reconnaissance",
      "description": "First steps when landing on a domain-joined Windows machine - discover domain structure, identify critical objects, and establish enumeration baseline",
      "educational_header": {
        "how_to_recognize": [
          "You have command execution on a Windows machine (shell, RDP, WinRM)",
          "Machine is domain-joined (systeminfo shows Domain: not WORKGROUP)",
          "You have domain user credentials (even low-privilege)",
          "Need to understand AD environment before targeted attacks"
        ],
        "when_to_look_for": [
          "Immediately after initial access to any domain-joined Windows machine",
          "Before attempting Kerberoasting, ACL abuse, or lateral movement",
          "When credentials work but you don't know the domain structure",
          "During OSCP exam when you compromise a Windows box (always check domain membership)"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Initial Shell on Domain Workstation",
          "context": "You exploited a web vulnerability and got a reverse shell as 'corp\\webuser' on a Windows 10 workstation. The shell is interactive but you don't have PowerShell access yet. You need to quickly determine if this is a domain environment and what the domain structure looks like.",
          "approach": "Start with zero-dependency tools (net.exe) to confirm domain membership and enumerate basic objects. These commands work from any Windows shell (cmd.exe) without requiring PowerShell, admin rights, or external tools. Build situational awareness before loading advanced tooling.",
          "commands": [
            "net-user-domain-list",
            "net-group-domain-admins",
            "net-group-domain-computers",
            "setspn-list-all",
            "net-domain-controllers"
          ],
          "expected_outcome": "You'll discover: domain name (corp.com), domain controllers (DC01.corp.com), privileged users (Domain Admins members), service accounts (SPNs registered), and computer count. This baseline tells you whether this is a simple 1-DC setup or complex multi-tier environment.",
          "why_this_works": "Built-in net.exe and setspn.exe communicate directly with domain controllers via LDAP (port 389) and SMB (port 445). These tools are available on all Windows versions and require only domain user credentials (which you already have as corp\\webuser). No special permissions needed for read-only enumeration."
        },
        {
          "title": "Scenario 2: RDP Access with PowerShell Available",
          "context": "You discovered credentials 'corp\\helpdesk:Password123' and successfully logged in via RDP. You have PowerShell access and want to perform comprehensive enumeration without loading external modules (avoiding detection). The domain is corp.com with multiple domain controllers.",
          "approach": "Use manual PowerShell LDAP queries (.NET DirectorySearcher) to enumerate objects without importing PowerView or other suspicious modules. This approach uses native Windows .NET framework classes that are present on all domain-joined machines and generate normal LDAP traffic.",
          "commands": [
            "ps-ldapsearch-function",
            "ps-ldapsearch-users",
            "ps-ldapsearch-computers",
            "ps-ldapsearch-groups",
            "ps-ldapsearch-spns",
            "ps-ldapsearch-admins"
          ],
          "expected_outcome": "You'll extract: all user accounts (with properties like lastLogon, pwdLastSet, userAccountControl), all computers (with OS version, lastLogon), all groups (with memberOf chains), and all SPNs (Kerberoastable targets). Output is PowerShell objects that you can filter/sort (e.g., 'where adminCount -eq 1' for privileged accounts).",
          "why_this_works": "DirectorySearcher is a .NET class that performs LDAP queries. It's built into Windows (System.DirectoryServices assembly) and used by legitimate Windows tools (Active Directory Users and Computers). Your LDAP queries look identical to normal AD authentication traffic, making them hard to detect. You're essentially replicating what PowerView does, but with native code."
        },
        {
          "title": "Scenario 3: PowerView Available - Comprehensive Enumeration",
          "context": "You have a stable PowerShell session, already imported PowerView (Dev.ps1), and need to perform rapid comprehensive enumeration. Time is limited (OSCP exam scenario) and you need actionable intelligence quickly. The domain is corp.com with 200+ users and 50+ computers.",
          "approach": "Use PowerView's automated cmdlets to enumerate all critical objects in parallel. PowerView aggregates LDAP queries, resolves SIDs, and presents data in attacker-friendly format. This is the fastest enumeration method when stealth is not a concern.",
          "commands": [
            "powerview-get-netdomain",
            "powerview-get-netdomaincontroller",
            "powerview-get-netuser-spn",
            "powerview-get-netgroup-recursive",
            "powerview-get-netcomputer-ping",
            "powerview-get-netou",
            "powerview-get-netgpo"
          ],
          "expected_outcome": "Within 2-3 minutes you'll have: domain metadata (forest structure, trusts, DCs), all Kerberoastable accounts (for AS-REP roasting), group memberships (who's in Domain Admins), live computers (pingable targets), OUs (organizational structure), and GPOs (potential GPP passwords in SYSVOL). This gives you multiple attack vectors to pursue.",
          "why_this_works": "PowerView is a PowerShell wrapper around LDAP/SMB APIs. It performs the same queries as manual LDAP enumeration but automates filtering, SID resolution, and recursive group membership lookups. Each cmdlet generates normal LDAP traffic (port 389) that blends with legitimate AD operations. Detection requires endpoint monitoring (PowerShell logging) not network-based detection."
        },
        {
          "title": "Scenario 4: Restricted Shell - Legacy Tools Only",
          "context": "You have command execution via a web shell but PowerShell is blocked (AppLocker/WDAC policy). The environment only allows legacy Windows executables (net.exe, dsquery.exe, setspn.exe). You need to enumerate the domain using only these constrained tools.",
          "approach": "Leverage dsquery.exe for advanced LDAP queries when net.exe output is insufficient. Dsquery provides LDAP filter capabilities without requiring PowerShell. Combine with setspn.exe for SPN discovery. This is your fallback enumeration strategy when modern tools are blocked.",
          "commands": [
            "dsquery-users",
            "dsquery-computers",
            "dsquery-admins",
            "setspn-list-all",
            "dsquery-domain-controllers"
          ],
          "expected_outcome": "You'll enumerate: all user DNs (distinguished names like CN=jsmith,OU=Users,DC=corp,DC=com), computer DNs, Domain Admins group members, SPNs (for Kerberoasting), and DC hostnames. Output is less friendly than PowerView (LDAP DNs instead of usernames) but contains the same intelligence. Pipe output to 'dsget user -samid' to convert DNs to usernames.",
          "why_this_works": "Dsquery.exe is a built-in Windows tool (installed with RSAT or available on domain controllers) that performs LDAP queries. It predates PowerShell and is often overlooked by security policies that block PowerShell but allow legacy executables. The tool communicates directly with domain controllers via LDAP (port 389) using your domain credentials."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Confirm Domain Membership & Identify DCs",
          "notes": "First verify you're in a domain environment (not standalone/workgroup). Identify domain controllers (primary targets for enumeration). These commands work from any Windows shell without special privileges.",
          "commands": [
            {
              "id": "net-user-domain-list",
              "example": "net user /domain",
              "shows": "User accounts for \\\\"
            },
            {
              "id": "net-domain-controllers",
              "example": "nltest /dclist:corp.com",
              "shows": "PDC"
            }
          ]
        },
        {
          "title": "Phase 2: Basic Object Enumeration (Legacy Tools)",
          "notes": "Enumerate users, groups, and computers using built-in net.exe commands. This works in highly restricted environments (AppLocker, constrained language mode). Start here if PowerShell is unavailable or blocked.",
          "commands": [
            {
              "id": "net-user-domain-list",
              "example": "net user /domain",
              "shows": "User accounts for \\\\"
            },
            {
              "id": "net-group-domain-admins",
              "example": "net group \"Domain Admins\" /domain",
              "shows": "Group name"
            },
            {
              "id": "net-group-domain-computers",
              "example": "net group \"Domain Computers\" /domain",
              "shows": "Group name"
            },
            {
              "id": "setspn-list-all",
              "example": "setspn -T corp.com -Q */*",
              "shows": "CN="
            }
          ]
        },
        {
          "title": "Phase 3: Manual PowerShell LDAP Queries",
          "notes": "If PowerShell is available but you can't/won't import modules (opsec concern), use native .NET DirectorySearcher. Create the LDAPSearch function once, then run targeted queries. This approach avoids 'Invoke-' cmdlets that trigger alerts.",
          "commands": [
            {
              "id": "ps-ldapsearch-function",
              "example": "function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$PDC/$DistinguishedName\"); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }",
              "shows": "Function created successfully"
            },
            {
              "id": "ps-ldapsearch-users",
              "example": "LDAPSearch -LDAPQuery \"(objectClass=user)\"",
              "shows": "Properties"
            },
            {
              "id": "ps-ldapsearch-computers",
              "example": "LDAPSearch -LDAPQuery \"(objectClass=computer)\"",
              "shows": "dnshostname"
            },
            {
              "id": "ps-ldapsearch-groups",
              "example": "LDAPSearch -LDAPQuery \"(objectClass=group)\"",
              "shows": "cn"
            },
            {
              "id": "ps-ldapsearch-spns",
              "example": "LDAPSearch -LDAPQuery \"(&(objectClass=user)(servicePrincipalName=*))\"",
              "shows": "serviceprincipalname"
            }
          ]
        },
        {
          "title": "Phase 4: PowerView Comprehensive Enumeration",
          "notes": "If PowerView is loaded (or can be loaded), use automated cmdlets for rapid enumeration. This is the fastest approach but generates more PowerShell event log entries (4103, 4104). Use when speed > stealth.",
          "commands": [
            {
              "id": "powerview-get-netdomain",
              "example": "Get-NetDomain",
              "shows": "Forest"
            },
            {
              "id": "powerview-get-netdomaincontroller",
              "example": "Get-NetDomainController",
              "shows": "Forest"
            },
            {
              "id": "powerview-get-netuser-all",
              "example": "Get-NetUser | select samaccountname,description,pwdlastset,lastlogon",
              "shows": "samaccountname"
            },
            {
              "id": "powerview-get-netuser-spn",
              "example": "Get-NetUser -SPN | select samaccountname,serviceprincipalname",
              "shows": "samaccountname"
            },
            {
              "id": "powerview-get-netgroup-recursive",
              "example": "Get-NetGroupMember -GroupName \"Domain Admins\" -Recurse",
              "shows": "MemberName"
            },
            {
              "id": "powerview-get-netcomputer-all",
              "example": "Get-NetComputer | select dnshostname,operatingsystem,lastlogon",
              "shows": "dnshostname"
            },
            {
              "id": "powerview-get-netou",
              "example": "Get-NetOU | select name,distinguishedname",
              "shows": "name"
            },
            {
              "id": "powerview-get-netgpo",
              "example": "Get-NetGPO | select displayname,whenchanged",
              "shows": "displayname"
            }
          ]
        },
        {
          "title": "Phase 5: Advanced Queries (dsquery)",
          "notes": "Fallback option when PowerShell is blocked but dsquery.exe is available (often on older systems or DCs). Provides LDAP filter capabilities without PowerShell. Less friendly output (DNs not usernames) but same intelligence.",
          "commands": [
            {
              "id": "dsquery-users",
              "example": "dsquery user",
              "shows": "CN="
            },
            {
              "id": "dsquery-computers",
              "example": "dsquery computer",
              "shows": "CN="
            },
            {
              "id": "dsquery-admins",
              "example": "dsquery group -name \"Domain Admins\" | dsget group -members",
              "shows": "CN="
            },
            {
              "id": "dsquery-domain-controllers",
              "example": "dsquery server",
              "shows": "CN="
            }
          ]
        }
      ],
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "RECONNAISSANCE",
        "OSCP:HIGH",
        "STARTER",
        "DOMAIN_RECON"
      ]
    }
  ]
}