{
  "cheatsheets": [
    {
      "id": "web-app-enumeration-breadth",
      "name": "Web Application Enumeration - Breadth-First Methodology",
      "description": "Systematic breadth-first approach to web application enumeration for discovering initial foothold opportunities. Cast a wide net before going deep on specific vulnerabilities.",
      "educational_header": {
        "how_to_recognize": [
          "HTTP/HTTPS services discovered on ports 80, 443, 8080, 8443, 8000, 3000 or other non-standard ports",
          "Nmap service scan shows HTTP server (Apache, nginx, IIS, lighttpd, Node.js)",
          "Any web-facing application requiring systematic attack surface mapping",
          "Multiple virtual hosts suspected on single IP (common in CTFs and real environments)",
          "Unknown technology stack requiring identification before exploitation"
        ],
        "when_to_look_for": [
          "IMMEDIATELY after port scan reveals web services - prioritize over deep-dive on single finding",
          "When initial directory scan returns nothing interesting - expand horizontally",
          "Before committing to specific exploit research - map ALL attack surface first",
          "When stuck on a machine - go back to breadth enumeration to find missed paths",
          "On security assessment - allocate first 15-20 minutes per machine to breadth enumeration"
        ],
        "philosophy": "BREADTH BEFORE DEPTH: Discover ALL entry points before investing time exploiting any single one. A wider net catches more fish. Map the entire attack surface, then prioritize based on findings."
      },
      "scenarios": [
        {
          "title": "Scenario 1: Fresh Web Target - Full Attack Surface Discovery",
          "context": "Nmap reveals ports 80 and 443 open on 192.168.1.100. Unknown web application. No prior knowledge of technology stack. Goal: Map complete attack surface before any exploitation attempts.",
          "approach": "Phase 1: HTTP headers + whatweb for tech stack. Phase 2: robots.txt, sitemap.xml, common files. Phase 3: Virtual host discovery. Phase 4: Directory enumeration with appropriate extensions. Phase 5: CMS-specific scans if detected. Phase 6: Parameter discovery on dynamic pages. Total time: 15-20 minutes MAXIMUM before moving to exploitation.",
          "commands": [
            "curl-header-enum",
            "whatweb-enum",
            "gobuster-dir",
            "ffuf-vhost-fuzz"
          ],
          "expected_outcome": "Technology stack identified (PHP 7.x, Apache 2.4, Laravel). Virtual hosts found (dev.target.com, admin.target.com). Interesting directories discovered (/admin, /api, /uploads, /backup). Hidden parameters found on login page. CMS identified if present. Attack vectors prioritized: 1) Admin panel, 2) File upload, 3) SQL injection in search.",
          "why_this_works": "Breadth-first enumeration prevents tunnel vision on a single attack vector. By mapping everything first, you identify the EASIEST path to foothold, not just the first one you find. pentest time management: 15-20 minutes enumeration can save hours of dead-end exploitation."
        },
        {
          "title": "Scenario 2: Hidden Virtual Hosts - Expanding Attack Surface",
          "context": "Initial gobuster found only /index.html on target.htb. Whatweb shows Apache 2.4 with no interesting headers. Direct IP access returns default page. Goal: Find hidden virtual hosts that may contain the actual application.",
          "approach": "Step 1: Verify /etc/hosts has domain entry. Step 2: ffuf vhost fuzzing with subdomain wordlist. Step 3: Filter by response size (baseline = default page size). Step 4: Add discovered vhosts to /etc/hosts. Step 5: Repeat directory enumeration on each vhost independently.",
          "commands": [
            "ffuf-vhost-fuzz",
            "gobuster-dir"
          ],
          "expected_outcome": "Virtual hosts discovered: api.target.htb (REST API), dev.target.htb (development environment with debug mode), admin.target.htb (admin panel). Each vhost has completely different functionality and attack surface. The main target.htb was a decoy - real application on vhosts.",
          "why_this_works": "Apache/nginx virtual hosting allows multiple distinct applications on one IP. The Host header determines which site is served. CTFs and real engagements commonly hide the actual application on a subdomain while the main domain shows nothing. This is a CRITICAL breadth technique - many testers miss entire applications by skipping vhost enumeration."
        },
        {
          "title": "Scenario 3: CMS Detection and Systematic Enumeration",
          "context": "Whatweb identifies WordPress 5.8.1 on target. Default WordPress installation visible. wp-admin shows login page. Goal: Enumerate WordPress completely to find weakest entry point.",
          "approach": "Step 1: wpscan full enumeration (users, plugins, themes). Step 2: Check for default credentials (admin:admin). Step 3: Enumerate vulnerable plugins with known CVEs. Step 4: Brute-force if user enumeration succeeds. Step 5: Check XML-RPC for amplification attacks. Step 6: Search theme/plugin-specific directories.",
          "commands": [
            "wpscan-enumerate-all",
            "wpscan-aggressive-detection",
            "wpscan-password-attack"
          ],
          "expected_outcome": "Users: admin, editor, john_doe. Plugins: Contact Form 7 (up to date), WP File Manager 6.0 (VULNERABLE - CVE-2020-25213). Theme: twentytwenty (default). XML-RPC enabled. Attack priority: 1) WP File Manager RCE, 2) Brute force admin, 3) XML-RPC brute force.",
          "why_this_works": "WordPress installations often have vulnerable plugins more than core vulnerabilities. Complete enumeration reveals multiple attack paths. Plugin vulnerabilities (especially file upload/RCE) are often easier than brute forcing. The breadth approach finds the EASIEST path, not just one path."
        },
        {
          "title": "Scenario 4: API Discovery and Endpoint Enumeration",
          "context": "Web application uses JavaScript frontend. XHR requests visible in browser dev tools pointing to /api/. Swagger documentation not publicly accessible. Goal: Map all API endpoints for testing.",
          "approach": "Step 1: Intercept traffic in Burp, identify API patterns. Step 2: Directory brute-force /api/ with API-specific wordlist. Step 3: Check for /api/docs, /api/swagger, /api/v1, /api/v2. Step 4: Test discovered endpoints for auth bypass. Step 5: Fuzz parameters on each endpoint. Step 6: Check for IDOR on resource IDs.",
          "commands": [
            "gobuster-dir",
            "ffuf-param-fuzz",
            "curl-post"
          ],
          "expected_outcome": "API endpoints: /api/users, /api/users/{id}, /api/admin/reports, /api/upload, /api/config. Auth required for /api/admin/* but not /api/users. IDOR vulnerability: /api/users/1 returns admin user data. Upload endpoint accepts arbitrary files. Attack priority: 1) IDOR for credentials, 2) Upload for webshell.",
          "why_this_works": "Modern applications separate frontend/backend - the API is often the actual attack surface. API enumeration reveals endpoints that may be missing authentication or have business logic flaws. Breadth enumeration of all endpoints before testing any single one ensures you find the weakest link."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Initial Fingerprinting (2-3 minutes)",
          "notes": "FIRST PRIORITY: Identify technology stack before any other enumeration. Tech stack determines wordlist selection, file extensions, and exploit research direction. Never skip this phase.",
          "commands": [
            {
              "id": "curl-header-enum",
              "example": "curl -I -X GET http://192.168.1.100/",
              "shows": "Server: Apache/2.4.41, X-Powered-By: PHP/7.4.3"
            },
            {
              "id": "whatweb-enum",
              "example": "whatweb -v http://192.168.1.100",
              "shows": "Apache, PHP, jQuery, Bootstrap, WordPress 5.8"
            },
            {
              "id": "nikto-scan",
              "example": "nikto -h http://192.168.1.100 -o nikto.txt",
              "shows": "Server leaks inodes, interesting files found"
            }
          ]
        },
        {
          "title": "Phase 2: Low-Hanging Fruit Check (1-2 minutes)",
          "notes": "Quick checks for common misconfigurations BEFORE time-consuming brute-forcing. These take seconds and often yield results.",
          "commands": [
            {
              "id": "curl-post",
              "example": "curl http://192.168.1.100/robots.txt",
              "shows": "Disallow: /admin, /backup, /config"
            },
            {
              "id": "curl-post",
              "example": "curl http://192.168.1.100/sitemap.xml",
              "shows": "XML sitemap with all pages listed"
            },
            {
              "id": "curl-post",
              "example": "curl http://192.168.1.100/.git/HEAD",
              "shows": "ref: refs/heads/master (Git exposed!)"
            },
            {
              "id": "curl-post",
              "example": "curl http://192.168.1.100/README.md",
              "shows": "Application readme with version info"
            }
          ]
        },
        {
          "title": "Phase 3: Virtual Host Discovery (3-5 minutes)",
          "notes": "CRITICAL: Run in parallel with directory enumeration. Many CTFs hide the real application on a vhost. Filter results by response size to identify valid vhosts.",
          "commands": [
            {
              "id": "ffuf-vhost-fuzz",
              "example": "ffuf -u http://192.168.1.100 -H 'Host: FUZZ.target.htb' -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -fs 0",
              "shows": "dev, admin, api, staging vhosts discovered"
            },
            {
              "id": "gobuster-dir",
              "example": "gobuster vhost -u http://target.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt --append-domain",
              "shows": "Found: dev.target.htb, admin.target.htb"
            }
          ]
        },
        {
          "title": "Phase 4: Directory Enumeration (5-7 minutes)",
          "notes": "Run multiple scans in parallel with DIFFERENT wordlists and extensions based on tech stack. PHP site = .php extension, ASP = .aspx, Java = .jsp. Use medium wordlist, NOT huge ones initially.",
          "commands": [
            {
              "id": "gobuster-dir",
              "example": "gobuster dir -u http://192.168.1.100 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x php,txt,bak -t 50",
              "shows": "/admin, /uploads, /backup, config.php.bak"
            },
            {
              "id": "ffuf-dir-fuzz",
              "example": "ffuf -u http://192.168.1.100/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt -e .php,.txt,.html -fc 404",
              "shows": "Discovered paths with status codes"
            },
            {
              "id": "gobuster-dir",
              "example": "gobuster dir -u http://192.168.1.100 -w /usr/share/seclists/Discovery/Web-Content/raft-medium-files.txt -t 50",
              "shows": "Common backup files, logs, configs"
            }
          ]
        },
        {
          "title": "Phase 5: CMS-Specific Enumeration (if detected)",
          "notes": "Only if CMS detected in Phase 1. Use dedicated scanners - they have CVE databases and plugin enumeration. WordPress, Joomla, Drupal each have specific tooling.",
          "commands": [
            {
              "id": "wpscan-enumerate-all",
              "example": "wpscan --url http://192.168.1.100 --enumerate u,vp,vt --plugins-detection aggressive",
              "shows": "Users, vulnerable plugins, vulnerable themes"
            },
            {
              "id": "droopescan-enumerate",
              "example": "droopescan scan drupal -u http://192.168.1.100",
              "shows": "Drupal version, installed modules"
            },
            {
              "id": "nikto-scan",
              "example": "joomscan -u http://192.168.1.100",
              "shows": "Joomla version, vulnerable components"
            }
          ]
        },
        {
          "title": "Phase 6: Parameter Discovery (2-3 minutes)",
          "notes": "For dynamic pages found in Phase 4 (login.php, search.php, index.php?id=). Discover hidden parameters that may be injectable. Run on each dynamic endpoint.",
          "commands": [
            {
              "id": "wfuzz-params",
              "example": "wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt --hc 404 'http://192.168.1.100/index.php?FUZZ=test'",
              "shows": "Hidden parameters: debug, id, user, admin"
            },
            {
              "id": "ffuf-param-fuzz",
              "example": "ffuf -u 'http://192.168.1.100/search.php?FUZZ=test' -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -fs 0",
              "shows": "Parameters with different responses"
            }
          ]
        },
        {
          "title": "Phase 7: Quick Vulnerability Surface Check (2-3 minutes)",
          "notes": "NOT full exploitation - just quick checks to identify WHICH vulnerabilities exist. Prioritize findings, then commit to exploitation phase. Test each input field once.",
          "commands": [
            {
              "id": "sqli-manual-test",
              "example": "' OR 1=1-- (in login/search fields)",
              "shows": "SQL error or behavior change = injectable"
            },
            {
              "id": "lfi-test",
              "example": "../../../../../../etc/passwd (in file parameters)",
              "shows": "root:x:0:0:root = LFI confirmed"
            },
            {
              "id": "xss-test",
              "example": "<script>alert(1)</script> (in input fields)",
              "shows": "Alert box = XSS, encoded output = filtered"
            }
          ]
        },
        {
          "title": "Phase 8: Attack Surface Summary (1 minute)",
          "notes": "PAUSE and document before exploitation. List all findings, prioritize by exploitation ease. Easiest path first: known CVEs > file upload > SQLi > auth bypass > brute force.",
          "commands": [
            {
              "id": "web-manual-enumeration",
              "example": "Document findings in enumeration.md",
              "shows": "Prioritized attack vector list"
            }
          ]
        }
      ],
      "tags": [
        "WEB",
        "METHODOLOGY",
        "ENUMERATION",
        "BREADTH_FIRST",
        "ATTACK_SURFACE",
        "RECONNAISSANCE"
      ]
    }
  ]
}