{
  "cheatsheets": [
    {
      "id": "windows-enumeration-procedures",
      "name": "Windows Local Enumeration Procedures",
      "description": "Comprehensive Windows local enumeration methodology for privilege escalation reconnaissance. Based on OSCP Module 17 - covers situational awareness, user/group discovery, network enumeration, sensitive information hunting, PowerShell artifacts, and automated tools.",
      "educational_header": {
        "how_to_recognize": [
          "You gained shell access on a Windows machine (bind shell, reverse shell, RDP, WinRM)",
          "Need to understand current privileges before attempting privilege escalation",
          "Machine is standalone or workgroup (not domain-joined, or doing local-only enumeration)",
          "Looking for sensitive information, credentials, or privilege escalation vectors"
        ],
        "when_to_look_for": [
          "Immediately after gaining initial foothold on Windows target",
          "Before attempting any privilege escalation techniques",
          "When you need to understand user landscape for credential attacks",
          "During OSCP exam when compromising Windows standalone machines"
        ],
        "key_concepts": [
          "SID Structure: S-R-X-Y format where RID >= 1000 = custom users, well-known SIDs include S-1-5-32-544 (Administrators)",
          "Access Tokens: Primary token = process identity, Impersonation token = different security context",
          "Integrity Levels: System > High > Medium > Low > Untrusted (UAC uses filtered admin tokens at Medium level)",
          "Get-History vs PSReadline: Clear-History does NOT clear PSReadline's ConsoleHost_history.txt",
          "Cyclical Re-enumeration: After pivoting to a new user, RESTART sensitive file searches. Files that returned 'Access Denied' may now be readable. Each new user context expands your search scope - this is critical for OSCP Module 17.1.3 Hidden in Plain View technique."
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Initial Shell - Complete Situational Awareness",
          "context": "You exploited a vulnerability and got a bind shell on port 4444 as user 'dave' on CLIENTWK220. You need to understand who you are, what system you're on, and what users exist before attempting privilege escalation.",
          "approach": "Run identity commands first (whoami, groups, privileges), then system info, then user/group enumeration. This establishes complete situational awareness within 2-3 minutes. Focus on identifying local administrators and interesting group memberships.",
          "commands": [
            "win-whoami-basic",
            "win-whoami-groups",
            "win-whoami-priv",
            "win-systeminfo-basic",
            "ps-get-localuser",
            "ps-get-localgroup",
            "ps-get-localgroupmember"
          ],
          "expected_outcome": "You'll know: current user and hostname, group memberships (Remote Desktop Users, helpdesk, etc.), whether Potato exploits are viable (SeImpersonatePrivilege), OS version for kernel exploit research, all local users (identify admin-like names: daveadmin, backupadmin), and who is in Administrators group. This baseline enables targeted privilege escalation.",
          "why_this_works": "Windows built-in commands provide all this information without any tool uploads. Situational awareness prevents wasted time on attacks that won't work (e.g., Potato exploits without SeImpersonate, kernel exploits on patched systems). Understanding user landscape reveals credential reuse opportunities."
        },
        {
          "title": "Scenario 2: User and Group Deep Dive",
          "context": "Initial enumeration revealed interesting users (backupadmin, daveadmin) and custom groups (adminteam, helpdesk). You need to understand the full access picture: who has admin rights, who can RDP, who can use WinRM.",
          "approach": "Enumerate membership of all security-relevant groups. Focus on Administrators (escalation targets), Remote Desktop Users (RDP access), Remote Management Users (WinRM access), and Backup Operators (file access). For interesting users, get detailed information including last logon and group memberships.",
          "commands": [
            "ps-get-localgroupmember",
            "win-net-localgroup-members",
            "win-net-user-detail"
          ],
          "expected_outcome": "Complete map of who has what access: 'backupadmin and daveadmin are local Administrators', 'steve can RDP and WinRM', 'dave is only in helpdesk group'. This tells you which credentials to target and what access each credential would provide.",
          "why_this_works": "Group membership determines attack vectors. Local Administrators = SYSTEM access after credential theft. Remote Desktop Users = GUI access (valuable for runas). Remote Management Users = evil-winrm access. Backup Operators = can read/write any file (privilege escalation vector)."
        },
        {
          "title": "Scenario 3: Sensitive Information Hunt",
          "context": "You know KeePass and XAMPP are installed (from Get-ItemProperty enumeration). Users often store passwords in text files and configuration files contain plaintext credentials. Time to search for low-hanging fruit before attempting complex privilege escalation.",
          "approach": "Search for password manager databases (.kdbx), application configuration files (*.ini, *.txt in XAMPP), and user documents that might contain credentials. Check Desktop, Documents, and Downloads for meeting notes or password files. Always search XAMPP/WAMP/IIS directories for database credentials.",
          "commands": [
            "ps-get-installed-apps",
            "ps-search-kdbx",
            "ps-search-config-files",
            "ps-search-user-docs"
          ],
          "expected_outcome": "Potential finds: KeePass database (crack with keepass2john + hashcat), meeting notes with test passwords (asdf.txt containing 'Steve's password: securityIsNotAnOption++++++'), MySQL config with database passwords (my.ini with 'admin123admin123!'), web.config with connection strings. Any of these could provide immediate privilege escalation.",
          "why_this_works": "Users are lazy about password security. Meeting notes, text files on Desktop, and configuration files frequently contain plaintext credentials. XAMPP/WAMP/IIS installations commonly have default or weak database passwords. Password reuse is extremely common - a password found for one service often works for user accounts."
        },
        {
          "title": "Scenario 4: PowerShell Artifact Analysis",
          "context": "The user 'dave' has been using PowerShell. Administrators often type credentials directly into PowerShell commands and mistakenly use Clear-History thinking it removes all traces. PowerShell transcription may also be enabled, recording commands and output.",
          "approach": "Check Get-History for current session (likely empty if new shell). The gold mine is PSReadline's ConsoleHost_history.txt - it persists across all sessions and is NOT cleared by Clear-History. Also search for transcript files which record commands AND output.",
          "commands": [
            "ps-get-history",
            "ps-get-psreadline-path",
            "ps-read-psreadline",
            "ps-search-transcripts"
          ],
          "expected_outcome": "PSReadline history often contains: ConvertTo-SecureString with plaintext passwords, Enter-PSSession with credentials, Set-Secret storing passwords in vault. Transcripts show full session output including successful authentication. Example find: '$password = ConvertTo-SecureString \"qwertqwertqwert123!!\" -AsPlainText -Force' with '$cred = New-Object PSCredential(\"daveadmin\", $password)'",
          "why_this_works": "Administrators misunderstand PowerShell history. Clear-History only clears the in-memory Get-History, NOT the persistent PSReadline history file. PSReadline stores ALL commands from ALL sessions, often for months. Transcription (when enabled) is even better - it shows exact credentials in context with their usage."
        },
        {
          "title": "Scenario 5: Automated Enumeration and Credential Testing",
          "context": "Manual enumeration found potential credentials (passwords from files, PSReadline history). Before testing each credential individually, run WinPEAS for comprehensive automated enumeration that might reveal additional vectors. Then test found credentials using runas or evil-winrm.",
          "approach": "Transfer and run WinPEAS for automated discovery of unquoted service paths, AlwaysInstallElevated, cached credentials, scheduled tasks, etc. Review findings focusing on RED highlights. Then test any discovered or collected credentials against privileged user accounts identified in earlier enumeration.",
          "commands": [
            "win-privesc-winpeas",
            "win-runas-cmd"
          ],
          "expected_outcome": "WinPEAS may reveal: unquoted service paths (C:\\Program Files\\My Service\\service.exe), AlwaysInstallElevated registry keys, AutoLogon credentials, weak service permissions. Combined with found credentials, you can test access: runas /user:backupadmin cmd with password 'admin123admin123!' found in my.ini. Success = privilege escalation achieved.",
          "why_this_works": "WinPEAS automates dozens of manual checks in minutes. While it may miss some findings (always validate with manual checks), it provides comprehensive overview. Testing credentials works because password reuse is pervasive - a MySQL password is often also the user's Windows password. Administrators often use the same password across multiple accounts."
        },
        {
          "title": "Scenario 6: Hidden in Plain View - Credential Pivot",
          "context": "You've compromised a low-privilege user (dave) and identified KeePass and XAMPP are installed. Search for credentials in config files and user documents, then pivot to a new user. After each pivot, restart the search with new permissions - files that returned 'Access Denied' may now be readable.",
          "approach": "Target installed applications for credential files: password manager databases, config files with database passwords, and user documents with meeting notes. Read found files carefully - permission denied errors indicate files to revisit after privilege escalation. Test found credentials by checking target user's groups first (Remote Desktop Users? Administrators?), then use appropriate access method (RDP, WinRM, runas).",
          "commands": [
            "ps-get-installed-apps",
            "ps-search-kdbx",
            "ps-search-app-config",
            "ps-search-user-docs",
            "ps-type-file",
            "ps-registry-autologon",
            "win-net-user-detail",
            "win-runas-cmd"
          ],
          "expected_outcome": "Find cleartext credentials in config files (XAMPP my.ini: 'password = admin123admin123!'), meeting notes (asdf.txt: 'Steve's password: securityIsNotAnOption++++++'), or password files. Verify target user groups with 'net user steve' (Remote Desktop Users for RDP, Administrators for high-value target), then pivot using runas (GUI required) or evil-winrm. CRITICAL: After pivoting to new user, restart sensitive file search - previously denied files may now be readable (e.g., my.ini as steve that dave couldn't read).",
          "why_this_works": "Users store passwords in text files instead of password managers. Config files contain cleartext database credentials often reused for Windows accounts. Permission errors during search indicate high-value files - note them for re-check after privilege escalation. The cyclical nature of enumeration means each new user access expands your search scope. Example from OSCP module: dave -> steve (found password in asdf.txt) -> backupadmin (found password in my.ini that steve could read but dave couldn't)."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Identity and Context",
          "notes": "First commands after gaining shell access. Establishes who you are, your group memberships, and privileges. Check for SeImpersonatePrivilege (Potato exploits viable).",
          "commands": [
            {
              "id": "win-whoami-basic",
              "example": "whoami",
              "shows": "clientwk220\\dave"
            },
            {
              "id": "win-whoami-groups",
              "example": "whoami /groups",
              "shows": "GROUP INFORMATION: helpdesk, Remote Desktop Users, Users..."
            },
            {
              "id": "win-whoami-priv",
              "example": "whoami /priv",
              "shows": "PRIVILEGES INFORMATION: SeChangeNotifyPrivilege, SeIncreaseWorkingSetPrivilege..."
            }
          ]
        },
        {
          "title": "Phase 2: User and Group Enumeration",
          "notes": "Identify all local users and groups. Look for admin-like usernames (daveadmin, backupadmin). Check Administrators group for escalation targets. Use PowerShell or legacy net commands based on availability.",
          "commands": [
            {
              "id": "ps-get-localuser",
              "example": "Get-LocalUser",
              "shows": "Name: Administrator (Disabled), BackupAdmin, dave, daveadmin, steve..."
            },
            {
              "id": "ps-get-localgroup",
              "example": "Get-LocalGroup",
              "shows": "Administrators, adminteam, BackupUsers, helpdesk, Remote Desktop Users..."
            },
            {
              "id": "ps-get-localgroupmember",
              "example": "Get-LocalGroupMember Administrators",
              "shows": "Administrator, backupadmin, daveadmin, offsec"
            },
            {
              "id": "win-net-user-local",
              "example": "net user",
              "shows": "User accounts for \\\\CLIENTWK220: Administrator, BackupAdmin, dave..."
            },
            {
              "id": "win-net-user-detail",
              "example": "net user steve",
              "shows": "Local Group Memberships: *helpdesk *Remote Desktop Users *Remote Management Users"
            }
          ]
        },
        {
          "title": "Phase 3: System Information",
          "notes": "Understand OS version, architecture, and patch level. Critical for kernel exploit research and tool compatibility (32-bit vs 64-bit).",
          "commands": [
            {
              "id": "win-systeminfo-basic",
              "example": "systeminfo",
              "shows": "OS Name: Microsoft Windows 11 Pro, System Type: x64-based PC, Hotfix(s): KB5015684..."
            }
          ]
        },
        {
          "title": "Phase 4: Network Enumeration",
          "notes": "Understand network position, identify other connected users, discover running services. Active RDP connections indicate other users (potential credential capture with Mimikatz after privesc).",
          "commands": [
            {
              "id": "win-ipconfig-all",
              "example": "ipconfig /all",
              "shows": "IPv4 Address: 192.168.50.220, DNS Servers: 8.8.8.8, DHCP Enabled: No"
            },
            {
              "id": "win-route-print",
              "example": "route print",
              "shows": "IPv4 Route Table: 0.0.0.0/0.0.0.0 via 192.168.50.254"
            },
            {
              "id": "win-netstat-ano",
              "example": "netstat -ano",
              "shows": "TCP 0.0.0.0:80 LISTENING 3340, TCP 192.168.50.220:3389 ESTABLISHED 1148"
            }
          ]
        },
        {
          "title": "Phase 5: Applications and Processes",
          "notes": "Identify installed applications for exploit research and credential opportunities. Running processes reveal services (correlate with netstat PIDs). Look for password managers, FTP clients, databases.",
          "commands": [
            {
              "id": "ps-get-installed-apps",
              "example": "Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" | select displayname",
              "shows": "FileZilla 3.63.1, KeePass Password Safe 2.51.1, XAMPP, VMware Tools..."
            },
            {
              "id": "ps-get-process",
              "example": "Get-Process",
              "shows": "httpd (3340), mysqld (3508), powershell (9756), filezilla (2632)..."
            }
          ]
        },
        {
          "title": "Phase 6: Sensitive Information Discovery",
          "notes": "Search for password files, configuration files, documents, and registry credentials. Target installed applications (XAMPP, KeePass, IIS), deployment files (unattend.xml), user directories, and registry AutoLogon. CRITICAL: Note files returning 'Access Denied' for re-check after privilege escalation.",
          "commands": [
            {
              "id": "ps-search-kdbx",
              "example": "Get-ChildItem -Path C:\\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\Users\\dave\\Documents\\Passwords.kdbx"
            },
            {
              "id": "ps-search-app-config",
              "example": "Get-ChildItem -Path C:\\xampp -Include *.txt,*.ini,*.config,*.xml -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\xampp\\passwords.txt, C:\\xampp\\mysql\\bin\\my.ini"
            },
            {
              "id": "ps-search-user-docs",
              "example": "Get-ChildItem -Path C:\\Users\\dave\\ -Include *.txt,*.pdf,*.doc,*.docx,*.xls,*.xlsx -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\Users\\dave\\Desktop\\asdf.txt"
            },
            {
              "id": "ps-type-file",
              "example": "type C:\\xampp\\mysql\\bin\\my.ini",
              "shows": "[client] password = admin123admin123!"
            },
            {
              "id": "ps-search-deployment-files",
              "example": "Get-ChildItem -Path C:\\ -Include unattend.xml,sysprep.xml,sysprep.inf -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\Windows\\Panther\\unattend.xml"
            },
            {
              "id": "ps-search-webconfig",
              "example": "Get-ChildItem -Path C:\\inetpub\\wwwroot -Include web.config,*.config -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\inetpub\\wwwroot\\myapp\\web.config"
            },
            {
              "id": "ps-search-password-patterns",
              "example": "Get-ChildItem -Path C:\\Users -Include *password*,*cred*,*secret* -File -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\Users\\dave\\Desktop\\passwords.txt"
            },
            {
              "id": "ps-registry-autologon",
              "example": "Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' | Select-Object DefaultUserName,DefaultPassword",
              "shows": "DefaultUserName: backupadmin, DefaultPassword: admin123admin123!"
            },
            {
              "id": "ps-cmdkey-list",
              "example": "cmdkey /list",
              "shows": "Target: TERMSRV/dc01.corp.local Type: Domain Password User: corp\\admin"
            }
          ]
        },
        {
          "title": "Phase 7: PowerShell Artifacts",
          "notes": "CRITICAL: Check PSReadline history - it persists even after Clear-History! Contains credentials from all previous sessions. Also search for transcript files which record commands AND output.",
          "commands": [
            {
              "id": "ps-get-history",
              "example": "Get-History",
              "shows": "Id CommandLine (empty if new session or Clear-History was run)"
            },
            {
              "id": "ps-get-psreadline-path",
              "example": "(Get-PSReadlineOption).HistorySavePath",
              "shows": "C:\\Users\\dave\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt"
            },
            {
              "id": "ps-read-psreadline",
              "example": "type C:\\Users\\dave\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt",
              "shows": "Set-Secret -Name \"Server02 Admin PW\" -Secret \"paperEarMonitor33@\"\nClear-History\nStart-Transcript..."
            },
            {
              "id": "ps-search-transcripts",
              "example": "Get-ChildItem -Path C:\\Users\\ -Include *transcript* -Recurse -ErrorAction SilentlyContinue",
              "shows": "C:\\Users\\Public\\Transcripts\\transcript01.txt"
            }
          ]
        },
        {
          "title": "Phase 8: Credential Leveraging and Automation",
          "notes": "Test found credentials with runas (requires GUI) or evil-winrm. Run WinPEAS for automated enumeration of privilege escalation vectors. WinPEAS may miss findings - always verify manually.",
          "commands": [
            {
              "id": "win-privesc-winpeas",
              "example": "winPEASany.exe",
              "shows": "RED highlights for vulnerabilities: Unquoted Service Paths, AlwaysInstallElevated, AutoLogon credentials..."
            },
            {
              "id": "win-runas-cmd",
              "example": "runas /user:backupadmin cmd",
              "shows": "Enter password for backupadmin: (new window opens as backupadmin)"
            }
          ]
        }
      ],
      "tags": [
        "WINDOWS",
        "ENUMERATION",
        "POST_EXPLOITATION",
        "PRIVILEGE_ESCALATION",
        "CREDENTIAL_HUNTING",
        "OSCP:HIGH"
      ],
      "oscp_relevance": "high"
    }
  ]
}
