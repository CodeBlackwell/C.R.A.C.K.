{
  "cheatsheets": [
    {
      "id": "keepass-database-cracking",
      "name": "KeePass Password Manager Cracking",
      "description": "Complete workflow for discovering, extracting, and cracking KeePass database master passwords",
      "educational_header": {
        "how_to_recognize": [
          "File enumeration reveals .kdbx files (KeePass 2.x database format) in: ~/Documents, Desktop, Downloads, network shares",
          "Process enumeration shows KeePass.exe or keepass2 running (user actively using password manager)",
          "Registry keys found: HKCU\\Software\\KeePass or configuration files in %APPDATA%\\KeePass",
          "File searches discover: Database.kdbx, passwords.kdbx, vault.kdbx, company.kdbx",
          "KeePass portable installation found in: USB drives, network shares, cloud sync folders (Dropbox, OneDrive)"
        ],
        "when_to_look_for": [
          "Post-exploitation: After gaining initial access (web shell, RCE, low-privilege user)",
          "File enumeration: When searching for sensitive files (find / -name '*.kdbx' 2>/dev/null)",
          "Network share access: SMB shares with user directories or IT department folders",
          "Backup discoveries: Found database backups in: archive folders, version control (.git), network drives",
          "security assessment: When you've exhausted other password discovery methods and need credential access"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: KeePass Discovery on Windows Desktop",
          "context": "You've gained low-privilege access to Windows 10 workstation via RCE vulnerability. Username: john.doe. You need to escalate privileges or find credentials for lateral movement. Enumerate user's files and discover: C:\\Users\\john.doe\\Documents\\Passwords.kdbx (4.2 MB). File is recent (modified 2 days ago). You suspect john uses this for storing credentials. Goal: Extract master password hash and crack it.",
          "approach": "1. Download Passwords.kdbx to attacker machine (SMB, HTTP, base64 exfiltration). 2. Verify file integrity: file Passwords.kdbx (should show 'Keepass password database'). 3. Extract hash using keepass2john: keepass2john Passwords.kdbx > keepass.hash. 4. Clean hash: Remove 'Passwords:' prefix for Hashcat (keep for John). 5. Identify hash format: $keepass$*2*60000*... ($keepass$ = KeePass, *2* = version 2.x, *60000* = 60k transform rounds). 6. Benchmark: hashcat -b -m 13400 (KeePass mode). 7. Calculate time based on benchmark results.",
          "commands": [
            "keepass2john-extract",
            "hashid",
            "hash-rate-benchmark",
            "calculate-crack-time",
            "attack-mode-decision"
          ],
          "expected_outcome": "keepass2john outputs: Passwords.kdbx:$keepass$*2*60000*0*hash_data_here. File command confirms: 'Keepass password database 2.x KDBX'. Benchmark shows: ~10 H/s (extremely slow - bcrypt-level). Time calculation: rockyou (14M) \u00f7 10 H/s = 1.4M seconds = 389 hours = 16 days (NOT viable). Decision: Use top 10k wordlist (10k \u00f7 10 = 1,000 seconds = 16 minutes - viable). If fails, try top 100k (2.7 hours). Key insight: KeePass designed to resist cracking - must use targeted wordlists.",
          "why_this_works": "KeePass uses AES-256 encryption with key derivation (PBKDF2 or Argon2). Transform rounds parameter (60,000 default) slows down each password attempt. Each guess requires 60,000 SHA-256 iterations before AES decryption attempt. GPU advantage minimal (memory-hard on version 2.x). 10 H/s typical on high-end GPU. Success depends on: User chose WEAK master password (defeats purpose of password manager!), Password in top N of wordlist, Patience (slow cracking requires time). Alternative: If john.doe reuses passwords, try: Known passwords from other services, Variations of username, Company name + year patterns."
        },
        {
          "title": "Scenario 2: Network Share KeePass Discovery",
          "context": "You've compromised user account via password spraying (sarah.jones:Summer2024!). SMB enumeration reveals writeable share: \\\\fileserver\\IT-Dept\\. Browse share and find: Backups\\Database_2024.kdbx, README.txt ('Master password: Company policy - FirstnameYear!'). This intelligence drastically narrows password space. You have Sarah's credentials but need elevated access. Hypothesis: Database master password follows pattern Sarah2024!",
          "approach": "1. Download Database_2024.kdbx from SMB share. 2. Extract hash: keepass2john Database_2024.kdbx > db.hash. 3. Create custom wordlist based on intelligence: Common first names (Sarah, John, Michael, Emily) + years (2020-2024) + special chars (!@#). 4. Generate variations: Sarah2024!, sarah2024!, SARAH2024!. 5. Total candidates: 20 names \u00d7 5 years \u00d7 3 special chars \u00d7 3 capitalizations = ~900 passwords. 6. Calculate time: 900 \u00f7 10 H/s = 90 seconds. 7. Run targeted attack: hashcat -m 13400 db.hash custom.txt.",
          "commands": [
            "keepass2john-extract",
            "create-policy-rules",
            "wordlist-effectiveness",
            "calculate-crack-time",
            "hashcat-keepass-crack"
          ],
          "expected_outcome": "Custom wordlist attack completes in ~90 seconds. Success: Database_2024.kdbx:$keepass$...:Michael2024! (IT admin's first name + year). Verification: keepass2 Database_2024.kdbx (open with cracked password). Database contains: Domain admin credentials, Service account passwords, Network device passwords, Application API keys. Immediate privilege escalation or lateral movement. Time investment: 10 minutes (wordlist creation) + 90 seconds (cracking) = 11 minutes total vs 16 days (blind attack).",
          "why_this_works": "Intelligence dramatically reduces keyspace. README.txt provided pattern (accidental information disclosure). Corporate password policies often mandate patterns (easy for users, predictable for attackers). Pattern 'FirstnameYear!' extremely common (compliance with: uppercase, lowercase, digit, special char requirements). Math: 900 targeted candidates vs 14M generic = 15,555x reduction. KeePass slow speed (10 H/s) becomes manageable. Lesson: Always search for intelligence BEFORE attacking (documentation, README files, comments, policies). Intelligence-driven > Brute-force for slow hashes."
        },
        {
          "title": "Scenario 3: KeePass with Keyfile Authentication",
          "context": "You've extracted KeePass database from compromised system: vault.kdbx. Attempt to crack hash fails (no hits after 100k rockyou). Investigate further: find vault.key file in same directory. KeePass supports dual authentication: Master password + Keyfile. Both required to decrypt. You have keyfile but not master password. Challenge: Crack master password WITH keyfile present.",
          "approach": "1. Download BOTH vault.kdbx and vault.key. 2. Extract hash: keepass2john -k vault.key vault.kdbx > vault.hash (NOTE: -k flag includes keyfile in hash). 3. Hash format changes: includes keyfile data in hash string. 4. Benchmark unchanged: still ~10 H/s. 5. Strategy: Keyfile reduces user's perceived need for strong password (false sense of security). Try common weak passwords: password, Password1, 123456, qwerty. 6. Run attack with small wordlist first (top 1k). 7. Expand if needed (top 10k, top 100k).",
          "commands": [
            "keepass2john-extract",
            "wordlist-effectiveness",
            "hashcat-keepass-crack",
            "john-keepass-crack"
          ],
          "expected_outcome": "Keyfile hash extraction: vault.kdbx:$keepass$*2*...*keyfile_data*.... Top 1k wordlist completes in 100 seconds (1k \u00f7 10 H/s). Success: vault:$keepass$...:password (user chose 'password' because keyfile provides 'real' security). Verification requires BOTH: keepass2 vault.kdbx --keyfile vault.key (enter 'password', database unlocks). Key insight: Dual-factor authentication undermines password strength (users compensate with weaker passwords). Keyfile must be included in hash extraction (-k flag) for crack to succeed.",
          "why_this_works": "KeePass keyfile authentication: User provides password + keyfile path, KeePass derives key from: SHA-256(password + keyfile_contents), Combined key decrypts database. Without keyfile, password alone fails. Psychological factor: Users think keyfile = security, so they choose weak passwords ('keyfile is the REAL password'). This defeats purpose - attacker with filesystem access has BOTH files. Keyfile format: Usually .key file (binary data) or any file (image, text, executable). Hash must include keyfile data for cracking tools to replicate key derivation. Success because: User chose weak password, Keyfile available to attacker, Tools support keyfile-based hashes. Defense: Strong password + keyfile (both should be strong)."
        },
        {
          "title": "Scenario 4: Cracking Old KeePass Database",
          "context": "During filesystem enumeration, you discover old backup: Database_OLD.kdb (note: .kdb not .kdbx). KeePass 1.x format (deprecated since 2013). You're curious if it contains stale but useful credentials. Extract hash and notice: $keepass$*1*... (*1* = version 1.x). Benchmark shows: ~1,000 H/s (100x faster than version 2.x!). Older encryption = faster cracking.",
          "approach": "1. Identify version: file Database_OLD.kdb \u2192 'Keepass password database 1.x'. 2. Extract hash: keepass2john Database_OLD.kdb > old.hash. 3. Hash shows: $keepass$*1*... (version 1.x indicator). 4. Benchmark: hashcat -b -m 13400 (same mode for 1.x and 2.x). Observe: ~1,000 H/s (much faster). 5. Calculate: rockyou (14M) \u00f7 1,000 H/s = 14,000 seconds = 3.8 hours. 6. Strategy: Version 1.x cracks faster - full rockyou viable. 7. Add rules if straight fails: rockyou + best64 = 14M \u00d7 64 \u00f7 1k H/s = ~10 days (still manageable overnight with rules subset).",
          "commands": [
            "keepass2john-extract",
            "hashid",
            "hash-rate-benchmark",
            "calculate-crack-time",
            "hashcat-keepass-crack",
            "hashcat-rule-attack"
          ],
          "expected_outcome": "Straight rockyou completes in ~4 hours. Success: Database_OLD.kdb:$keepass$*1*...:welcome123 (old weak password). Database contains: Outdated but potentially reused credentials, Historical admin passwords (may still work on old systems), API keys for legacy services, VPN credentials. Even if credentials expired, useful for: Password pattern analysis (user's password habits), Cracking other hashes (password reuse), Understanding environment (service names, usernames). Time: 4 hours (unattended, run overnight) vs 16 days (version 2.x).",
          "why_this_works": "KeePass 1.x uses weaker encryption (AES-256 but fewer transform rounds by default). Version 1.x default: 6,000 rounds vs 2.x: 60,000 rounds (10x difference). Older algorithm implementations less optimized for resistance. Hash rate: 1,000 H/s (v1.x) vs 10 H/s (v2.x) = 100x faster. Database deprecated but may contain: Credentials never rotated, Passwords reused on current systems, Patterns revealing user habits. Success because: Weaker legacy encryption, Old passwords (likely weak - pre-policy era), Full wordlist viable in reasonable time. Lesson: Always check old backups - weaker security, potential password reuse."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: KeePass Database Discovery",
          "notes": "Search for KeePass databases across filesystem and network shares. Common locations: Windows: C:\\Users\\*\\Documents, Desktop, Downloads, AppData\\Roaming\\KeePass. Linux: ~/Documents, ~/.config/keepass, /opt/KeePass. Network: SMB shares (IT-Dept, Backups, Users, Shared Documents). Cloud sync: Dropbox, OneDrive, Google Drive folders. File extensions: .kdbx (KeePass 2.x, current), .kdb (KeePass 1.x, legacy). Search commands: Windows: dir /s /b *.kdbx, Linux: find / -name '*.kdbx' 2>/dev/null. Check file age: Recent = actively used, Old = backup/stale credentials.",
          "commands": []
        },
        {
          "title": "Phase 2: Hash Extraction and Identification",
          "notes": "Extract hash using keepass2john tool (part of John the Ripper suite). Syntax: keepass2john <DATABASE> > <HASH_FILE>. For keyfile authentication: keepass2john -k <KEYFILE> <DATABASE> > <HASH_FILE>. Clean hash for Hashcat: Remove 'filename:' prefix (keep for John). Identify version: *1* = KeePass 1.x (faster cracking), *2* = KeePass 2.x (slower). Note transform rounds: *60000* = 60k rounds (slower), *6000* = 6k rounds (faster). Higher rounds = longer crack time (exponentially).",
          "commands": [
            {
              "id": "keepass2john-extract",
              "example": "keepass2john Database.kdbx > keepass.hash",
              "shows": "$keepass$*2*"
            },
            {
              "id": "hashid",
              "example": "hashid '5f4dcc3b5aa765d61d8327deb882cf99' -m",
              "shows": "[+] MD5"
            },
            {
              "id": "hash-identifier",
              "example": "hash-identifier",
              "shows": "Possible Hashs:"
            }
          ]
        },
        {
          "title": "Phase 3: Benchmark and Strategy",
          "notes": "Benchmark KeePass hash cracking speed on your hardware. Hashcat mode 13400 for both 1.x and 2.x. Typical rates: Version 1.x = 500-1,500 H/s (GPU), Version 2.x = 5-15 H/s (GPU). Calculate time: (Wordlist size \u00f7 Hash rate) = Seconds. Strategy decision: <1 hour = Full rockyou viable, 1-10 hours = Top 100k or targeted wordlist, >10 hours = Custom intelligence-based wordlist only. Remember: KeePass DESIGNED to resist cracking - respect the math.",
          "commands": [
            {
              "id": "hash-rate-benchmark",
              "example": "hashcat -b -m 1000 | grep -A3 'Hashmode:'",
              "shows": "Hash rate displayed (H/s, kH/s, MH/s, GH/s)"
            },
            {
              "id": "calculate-crack-time",
              "example": "python3 -c \"keyspace=218340105584896; hash_rate=1000000000; seconds=keyspace/hash_rate; hours=seconds/3600; print(f'Time: {hours:.2f} hours ({hours/24:.2f} days)')\"",
              "shows": "Time estimate displayed"
            },
            {
              "id": "calculate-keyspace",
              "example": "python3 -c \"import math; charset=62; length=8; print(f'Keyspace: {charset**length:,} combinations')\"",
              "shows": "Keyspace displayed"
            },
            {
              "id": "attack-mode-decision",
              "example": "echo 'Attack Mode Decision Tree:\\n1. Straight Wordlist (fastest, try first)\\n2. Wordlist + Rules (best balance)\\n3. Combinator (merge wordlists)\\n4. Mask Attack (known pattern)\\n5. Brute Force (last resort)'",
              "shows": "Decision tree displayed"
            },
            {
              "id": "wordlist-effectiveness",
              "example": "wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \"lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"",
              "shows": "Line count displayed"
            }
          ]
        },
        {
          "title": "Phase 4: Intelligence Gathering",
          "notes": "Before blind attacks, search for intelligence to create targeted wordlist. Look for: README files (may contain password hints or policies), Configuration files (KeePass.config.xml in AppData), Documentation (IT policies, password requirements), User patterns (usernames, email addresses, company info), Related files (text files in same directory as .kdbx). Common KeePass password patterns: Company name + year + special (Contoso2024!), Username + digits (john1234), Keyboard patterns (qwerty123), Policy compliance (Password1!). Create custom wordlist based on findings (100-1000 words better than 14M generic).",
          "commands": [
            {
              "id": "create-policy-rules",
              "example": "echo -e 'c $2024 $!\\nc $2024 $@\\nc $2024 $#' > policy.rule",
              "shows": "Rule file created"
            },
            {
              "id": "rule-capitalize-append",
              "example": "echo 'c $!' > cap-special.rule",
              "shows": "Rule file created"
            },
            {
              "id": "rule-prepend-year",
              "example": "echo '^2 ^0 ^2 ^4' > prepend-year.rule",
              "shows": "Rule file created"
            },
            {
              "id": "wordlist-effectiveness",
              "example": "wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \"lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"",
              "shows": "Line count displayed"
            }
          ]
        },
        {
          "title": "Phase 5: Cracking Execution",
          "notes": "Launch cracking attack with appropriate strategy. For FAST hashes (v1.x): Try rockyou straight, then rockyou + best64 rules. For SLOW hashes (v2.x): Start with top 10k, then custom wordlist, then top 100k if time allows. Use session management: hashcat --session=keepass-crack (enables pause/resume). Monitor progress: hashcat --session=keepass-crack --status. Hashcat alternative: John the Ripper (john --wordlist=rockyou.txt keepass.hash). John may be faster for KeePass on some hardware. Compare benchmarks between tools.",
          "commands": [
            {
              "id": "hashcat-keepass-crack",
              "example": "hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force",
              "shows": "Cracked"
            },
            {
              "id": "john-keepass-crack",
              "example": "john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules keepass.hash",
              "shows": "Loaded 1 password hash (KeePass [SHA256 AES])"
            },
            {
              "id": "hashcat-rule-attack",
              "example": "hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force",
              "shows": "Guess.Mod........: Rules"
            },
            {
              "id": "session-management",
              "example": "hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt --session=exam-target1 -o cracked.txt --outfile-format=2",
              "shows": "Session started"
            },
            {
              "id": "monitor-crack-progress",
              "example": "watch -n 5 'hashcat --session=exam-target1 --status 2>&1 | grep -E \"Progress|Speed|Recovered|Time\"'",
              "shows": "Progress percentage increasing"
            }
          ]
        },
        {
          "title": "Phase 6: Database Access and Exploitation",
          "notes": "After successful crack: Verify password immediately: keepass2 <DATABASE> or KeePass.exe. If keyfile required: keepass2 <DATABASE> --keyfile <KEYFILE>. Explore database contents: Credentials (usernames, passwords, URLs), Notes (network diagrams, procedures, API keys), Attachments (SSH keys, certificates, scripts). Document all findings: Screenshot entries, Export credentials to file, Note password patterns for other attacks. Test credentials immediately: SSH, RDP, SMB, web applications. Check for: Password reuse across services, Privileged accounts, Service accounts with excessive permissions.",
          "commands": [
            {
              "id": "hashcat-show-cracked",
              "example": "hashcat -m 0 hashes.txt --show",
              "shows": "<HASH>:<PASSWORD>"
            }
          ]
        }
      ],
      "tags": [
        "PASSWORD_ATTACKS",
        "KEEPASS",
        "PASSWORD_MANAGER",
        "HASH_CRACKING"
      ]
    }
  ]
}