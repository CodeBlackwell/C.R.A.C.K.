{"category": "enumeration", "description": "Active Directory enumeration using manual PowerShell LDAP queries with .NET classes (no PowerView dependency)", "commands": [{"id": "ps-get-current-domain", "name": "Get Current Domain (PowerShell)", "category": "enumeration", "command": "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()", "description": "Retrieve current AD domain information including forest, domain controllers, and PDC role owner using .NET Framework", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", ".NET", "DOMAIN", "STARTER", "OSCP:HIGH"], "variables": [], "flag_explanations": {}, "success_indicators": ["Forest", "DomainControllers", "PdcRoleOwner", "Name"], "failure_indicators": ["Exception calling", "Cannot find type", "Access is denied"], "next_steps": ["ps-get-pdc", "ps-build-ldap-path", "Extract domain name from Name property", "Extract PDC from PdcRoleOwner property"], "alternatives": ["Get-NetDomain", "$env:USERDNSDOMAIN"], "prerequisites": [], "troubleshooting": {"Cannot find type": "PowerShell version too old. Use PowerShell 3.0+. Check version: $PSVersionTable", "Access is denied": "Not logged in with domain account. Verify: whoami /fqdn"}, "notes": "Uses .NET System.DirectoryServices.ActiveDirectory namespace - available in PowerShell by default without imports. Returns domain object with critical properties: PdcRoleOwner (primary DC for enumeration), DomainControllers (all DCs in domain), Forest (multi-domain environments), Name (domain DNS name). OSCP: This is exam-safe - no PowerView or special tools required, works on any domain-joined Windows machine with PowerShell.", "oscp_relevance": "high"}, {"id": "ps-get-pdc", "name": "Get Primary Domain Controller (PowerShell)", "category": "enumeration", "command": "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name", "description": "Extract the Primary Domain Controller hostname - the most authoritative DC for LDAP queries", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", ".NET", "DOMAIN_CONTROLLER", "OSCP:HIGH"], "variables": [], "flag_explanations": {".PdcRoleOwner.Name": "Accesses the PdcRoleOwner property (which DC holds PDC role) and extracts its Name (hostname). PDC is the most up-to-date DC - use this for enumeration to ensure accurate results."}, "success_indicators": [".corp.com", "DC name in FQDN format"], "failure_indicators": ["Exception calling", "Property 'PdcRoleOwner' cannot be found"], "next_steps": ["ps-build-ldap-path", "Use PDC hostname in LDAP connection string", "Store in variable: $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name"], "alternatives": ["Get-NetDomainController", "nltest /dclist:<DOMAIN>", "nslookup -type=SRV _ldap._tcp.dc._msdcs.<DOMAIN>"], "prerequisites": ["ps-get-current-domain"], "troubleshooting": {"Property cannot be found": "Domain object not populated. Run full command: [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() first"}, "notes": "PDC (Primary Domain Controller) holds the most authoritative and up-to-date AD data. There is only ONE PDC per domain. Querying non-PDC DCs may return stale replication data (accounts/groups not yet synced). For enumeration accuracy, always target the PDC. OSCP: Use this to build the LDAP path for DirectorySearcher queries.", "oscp_relevance": "high"}, {"id": "ps-get-distinguished-name", "name": "Get Domain Distinguished Name (PowerShell)", "category": "enumeration", "command": "([adsi]'').distinguishedName", "description": "Retrieve the domain's Distinguished Name in LDAP format (DC=corp,DC=com)", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", "ADSI", "OSCP:HIGH"], "variables": [], "flag_explanations": {"[adsi]''": "ADSI (Active Directory Service Interfaces) accelerator. Empty string queries the root of the AD hierarchy (the domain itself).", ".distinguishedName": "Returns the DN (Distinguished Name) - LDAP-formatted path to the domain object. Format: DC=domain,DC=tld."}, "success_indicators": ["DC=", "Distinguished Name in LDAP format"], "failure_indicators": ["Exception calling", "Unable to contact the server"], "next_steps": ["ps-build-ldap-path", "Store in variable: $DN = ([adsi]'').distinguishedName", "Use in LDAP path: LDAP://<PDC>/$DN"], "alternatives": ["$env:USERDNSDOMAIN | ForEach-Object { 'DC=' + ($_ -replace '\\.',',DC=') }", "Get-ADDomain | select DistinguishedName"], "prerequisites": [], "troubleshooting": {"Unable to contact the server": "Not logged in to domain or DC unreachable. Verify: whoami /fqdn"}, "notes": "Distinguished Names (DN) are unique identifiers in LDAP. Format: CN=name,OU=container,DC=domain,DC=tld. Reading right-to-left: DC components define the domain (top of hierarchy), OU/CN components define location within domain. For domain 'corp.com', DN is 'DC=corp,DC=com'. This is the searchbase for LDAP queries. OSCP: Required component for building LDAP connection strings.", "oscp_relevance": "high"}, {"id": "ps-build-ldap-path", "name": "Build Complete LDAP Path (PowerShell)", "category": "enumeration", "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $LDAP", "description": "Construct full LDAP path for DirectorySearcher queries by combining PDC hostname and Distinguished Name", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", "OSCP:HIGH"], "variables": [], "flag_explanations": {}, "success_indicators": ["LDAP://", "DC=", "Full LDAP path format"], "failure_indicators": ["Exception", "Variable is null"], "next_steps": ["ps-directorysearcher-users", "Use in DirectoryEntry: New-Object System.DirectoryServices.DirectoryEntry($LDAP)", "Use in DirectorySearcher queries"], "alternatives": ["Hardcode if known: $LDAP = 'LDAP://DC1.corp.com/DC=corp,DC=com'"], "prerequisites": ["ps-get-pdc", "ps-get-distinguished-name"], "troubleshooting": {"LDAP path incomplete": "Check variables populated: echo $PDC; echo $DN", "Query fails with invalid path": "Verify DC reachable: ping $PDC"}, "notes": "LDAP path format: LDAP://HostName/DistinguishedName. HostName = PDC for accuracy. DistinguishedName = domain DN (searchbase). This path tells DirectorySearcher WHERE to search (PDC) and WHAT to search (entire domain from root). OSCP: This is the foundation for all manual LDAP enumeration - memorize this pattern.", "oscp_relevance": "high"}, {"id": "ps-directorysearcher-users", "name": "Enumerate Users with DirectorySearcher (PowerShell)", "category": "enumeration", "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"samAccountType=805306368\"; $dirsearcher.FindAll()", "description": "Search Active Directory for all user objects using DirectorySearcher .NET class with LDAP filter", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", ".NET", "USERS", "OSCP:HIGH"], "variables": [], "flag_explanations": {"DirectoryEntry": "Encapsulates an AD object (the domain root in this case). Provides the LDAP connection for queries.", "DirectorySearcher": "Performs LDAP queries against AD. Requires DirectoryEntry as searchbase.", "filter": "LDAP filter syntax. samAccountType=805306368 filters for normal user accounts (decimal value for 0x30000000).", "FindAll()": "Executes the search and returns ALL matching objects (all users in this case)."}, "success_indicators": ["Path", "Properties", "LDAP://", "CN=Users"], "failure_indicators": ["Exception", "Access Denied", "Cannot find type"], "next_steps": ["Parse output: $result = $dirsearcher.FindAll(); foreach($obj in $result){$obj.Properties}", "Filter properties: $obj.Properties.samaccountname", "Extract specific users: $dirsearcher.filter=\"name=administrator\""], "alternatives": ["Get-NetUser", "net user /domain"], "prerequisites": ["ps-build-ldap-path"], "troubleshooting": {"No results": "LDAP filter may be wrong. Test without filter: $dirsearcher.filter=\"objectClass=user\"; $dirsearcher.FindAll()", "Too much output": "Filter specific attributes: $obj.Properties | select samaccountname,description"}, "notes": "samAccountType values: 805306368 (users), 805306369 (computers), 268435456 (groups). LDAP filter syntax: (attribute=value) for equality, (attribute=*value*) for wildcards, (&(filter1)(filter2)) for AND, (|(filter1)(filter2)) for OR. Output contains ALL user attributes - pipe to select for clean output. OSCP: This is PowerView-free enumeration - works in restricted environments where imports are blocked.", "oscp_relevance": "high"}, {"id": "ps-directorysearcher-groups", "name": "Enumerate Groups with DirectorySearcher (PowerShell)", "category": "enumeration", "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"objectClass=group\"; $result = $dirsearcher.FindAll(); foreach($group in $result){$group.properties | select {$_.cn},{$_.member}}", "description": "Search Active Directory for all group objects and display group names with members", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", ".NET", "GROUPS", "OSCP:HIGH"], "variables": [], "flag_explanations": {"objectClass=group": "LDAP filter for group objects. More inclusive than samAccountType - returns all group types (security groups, distribution groups, domain local, global, universal).", "foreach loop": "Iterates through each group object in results.", "select {$_.cn},{$_.member}": "Extracts Common Name (group name) and member attribute (group members)."}, "success_indicators": ["Domain Admins", "Enterprise Admins", "CN=", "Group members listed"], "failure_indicators": ["Exception", "No results", "Access Denied"], "next_steps": ["Filter specific group: $dirsearcher.filter=\"(&(objectClass=group)(cn=Domain Admins))\"", "Check for nested groups in member attribute (starts with CN=)", "Enumerate nested groups recursively"], "alternatives": ["Get-NetGroup", "net group /domain"], "prerequisites": ["ps-build-ldap-path"], "troubleshooting": {"Nested groups not showing users": "Member attribute shows distinguished names. CN=user is a user, CN=group,CN=Users is a nested group. Query nested group separately.", "Output format messy": "Use select-object: $group.properties.member | Format-List"}, "notes": "Group member attribute contains distinguished names (DNs). Format: 'CN=username,CN=Users,DC=corp,DC=com' for users, 'CN=groupname,CN=Users,DC=corp,DC=com' for nested groups. Nested groups are common - if member DN contains 'CN=Users' or 'OU=', it's likely a group, not a user. Enumerate recursively to find all users. OSCP: Look for groups with 'Admin', 'IT', 'Service' in CN - often have elevated privileges.", "oscp_relevance": "high"}, {"id": "ps-directorysearcher-computers", "name": "Enumerate Computers with DirectorySearcher (PowerShell)", "category": "enumeration", "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"samAccountType=805306369\"; $result = $dirsearcher.FindAll(); foreach($computer in $result){$computer.properties | select {$_.cn},{$_.operatingsystem},{$_.dnshostname}}", "description": "Search Active Directory for all computer objects and display hostnames with operating systems", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", ".NET", "COMPUTERS", "OSCP:HIGH"], "variables": [], "flag_explanations": {"samAccountType=805306369": "LDAP filter for computer objects (decimal for 0x30000001). Matches domain-joined workstations, servers, and domain controllers.", "{$_.cn}": "Common Name - computer hostname without domain suffix.", "{$_.operatingsystem}": "OS version (Windows 10, Windows Server 2019, etc.) - useful for targeting legacy systems.", "{$_.dnshostname}": "Fully qualified domain name (hostname.domain.com) - use this for network connections."}, "success_indicators": ["Windows", "operatingsystem", "dnshostname", "Computer hostnames"], "failure_indicators": ["Exception", "No results", "Access Denied"], "next_steps": ["Target legacy OS: $dirsearcher.filter=\"(&(samAccountType=805306369)(operatingSystem=*Server 2008*))\"; $dirsearcher.FindAll()", "Identify DCs: $dirsearcher.filter=\"(&(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=8192))\"; $dirsearcher.FindAll()", "Ping reachable hosts: foreach($computer in $result){Test-Connection -ComputerName $computer.properties.dnshostname -Count 1 -Quiet}"], "alternatives": ["Get-NetComputer", "dsquery computer", "nmap -sn <SUBNET>"], "prerequisites": ["ps-build-ldap-path"], "troubleshooting": {"Operating system field empty": "Some computer objects don't have OS populated. Check other attributes: $computer.properties", "DC not showing": "Use userAccountControl filter for DCs. Flag 8192 = Domain Controller."}, "notes": "Computer objects reveal network topology without port scanning. operatingsystem attribute identifies vulnerable legacy systems (Windows 7, Server 2008) for targeting. operatingsystemversion provides exact build number. lastLogon shows active vs dormant computers. OSCP: Focus on legacy OS versions and servers - higher chance of unpatched vulnerabilities.", "oscp_relevance": "high"}, {"id": "ps-ldapsearch-function", "name": "Reusable LDAP Search Function (PowerShell)", "category": "enumeration", "command": "function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$PDC/$DistinguishedName\"); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }", "description": "Create reusable PowerShell function for LDAP queries - accepts LDAP filter as parameter", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "POWERSHELL", "LDAP", "FUNCTION", "REUSABLE", "OSCP:HIGH"], "variables": [], "flag_explanations": {"param ([string]$LDAPQuery)": "Function parameter - accepts LDAP filter string from command line", "return $DirectorySearcher.FindAll()": "Returns all matching AD objects for the provided filter"}, "success_indicators": ["Function created successfully", "Import-Module completes", "LDAPSearch command available"], "failure_indicators": ["Syntax error", "Function not recognized"], "next_steps": ["Save to file: function | Out-File LDAPSearch.ps1", "Import: Import-Module .\\LDAPSearch.ps1", "Use: LDAPSearch -LDAPQuery \"(samAccountType=805306368)\"", "Filter users: LDAPSearch -LDAPQuery \"(&(objectCategory=user)(adminCount=1))\"", "Filter groups: LDAPSearch -LDAPQuery \"(objectCategory=group)\" | select -ExpandProperty Properties | select cn,member"], "alternatives": ["Save as script and dot-source: . .\\LDAPSearch.ps1", "Add to PowerShell profile for persistence"], "prerequisites": ["ps-build-ldap-path", "ps-directorysearcher-users"], "troubleshooting": {"Function not found": "Import module first: Import-Module .\\LDAPSearch.ps1", "LDAP query syntax error": "Test filter manually first with DirectorySearcher", "No results": "Verify LDAP filter syntax. Common filters: (objectClass=user), (objectCategory=group), (samAccountType=805306368)"}, "notes": "This function encapsulates all previous LDAP enumeration steps into a reusable tool. Usage examples: LDAPSearch \"(samAccountType=805306368)\" for users, LDAPSearch \"(objectCategory=group)\" for groups, LDAPSearch \"(&(objectCategory=user)(servicePrincipalName=*))\" for Kerberoastable accounts. OSCP: Save this function to a file and import it at the start of AD enumeration - eliminates repetitive typing and reduces errors. This is PowerView-free, exam-safe enumeration.", "oscp_relevance": "high"}, {"id": "ps-ldapsearch-users", "name": "LDAP Query All Users (PowerShell)", "category": "enumeration", "command": "LDAPSearch -LDAPQuery \"(objectClass=user)\"", "description": "Query all user objects using manual LDAP search function", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "USERS", "LDAP", "POWERSHELL", "OSCP:HIGH"], "variables": [], "flag_explanations": {"(objectClass=user)": "LDAP filter matching all user objects. Returns both user accounts and computer accounts (computers inherit from user class)."}, "success_indicators": ["Properties", "samaccountname", "distinguishedname"], "failure_indicators": ["Function not defined", "Access denied", "Cannot contact domain"], "next_steps": ["Filter results: LDAPSearch -LDAPQuery \"(&(objectClass=user)(!(objectClass=computer)))\""], "alternatives": ["Get-NetUser", "net user /domain"], "prerequisites": ["ps-ldapsearch-function"], "troubleshooting": {"Function not defined": "Create LDAPSearch function first: ps-ldapsearch-function", "Returns computer accounts": "Filter computers: (&(objectClass=user)(!(objectClass=computer)))"}, "notes": "Requires LDAPSearch function defined first. Returns user AND computer objects (computers inherit from user class in AD schema). Filter out computers with LDAP filter or PowerShell: | ? {$_.Properties.samaccountname -notmatch '\\$$'}", "oscp_relevance": "high"}, {"id": "ps-ldapsearch-computers", "name": "LDAP Query All Computers (PowerShell)", "category": "enumeration", "command": "LDAPSearch -LDAPQuery \"(objectClass=computer)\"", "description": "Query all computer objects in the domain", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "COMPUTERS", "LDAP", "POWERSHELL", "OSCP:MEDIUM"], "variables": [], "flag_explanations": {"(objectClass=computer)": "LDAP filter matching computer accounts. Computer SAM names end with $."}, "success_indicators": ["dnshostname", "operatingsystem"], "failure_indicators": ["Function not defined"], "next_steps": ["Check OS versions: | select -ExpandProperty Properties | select dnshostname,operatingsystem"], "alternatives": ["Get-NetComputer"], "prerequisites": ["ps-ldapsearch-function"], "troubleshooting": {}, "notes": "Returns all domain-joined computers with properties like OS version, last logon, DNS hostname.", "oscp_relevance": "medium"}, {"id": "ps-ldapsearch-groups", "name": "LDAP Query All Groups (PowerShell)", "category": "enumeration", "command": "LDAPSearch -LDAPQuery \"(objectClass=group)\"", "description": "Query all group objects in the domain", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "GROUPS", "LDAP", "POWERSHELL", "OSCP:MEDIUM"], "variables": [], "flag_explanations": {"(objectClass=group)": "LDAP filter for group objects. Includes security and distribution groups."}, "success_indicators": ["cn", "member"], "failure_indicators": ["Function not defined"], "next_steps": ["Get group members: $group.Properties.member"], "alternatives": ["Get-NetGroup"], "prerequisites": ["ps-ldapsearch-function"], "troubleshooting": {}, "notes": "Returns all groups. Focus on privileged groups: Domain Admins, Enterprise Admins, Administrators.", "oscp_relevance": "medium"}, {"id": "ps-ldapsearch-spns", "name": "LDAP Query Kerberoastable Accounts (PowerShell)", "category": "enumeration", "command": "LDAPSearch -LDAPQuery \"(&(objectClass=user)(servicePrincipalName=*))\"", "description": "Query all user accounts with SPNs registered (Kerberoastable)", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "SPN", "KERBEROASTING", "LDAP", "POWERSHELL", "OSCP:HIGH"], "variables": [], "flag_explanations": {"(&(objectClass=user)(servicePrincipalName=*))": "Compound LDAP filter: user objects AND has SPN attribute. The & means AND, * means any value."}, "success_indicators": ["serviceprincipalname", "samaccountname"], "failure_indicators": ["Function not defined", "No results"], "next_steps": ["Request TGS tickets for discovered accounts"], "alternatives": ["Get-NetUser -SPN", "setspn -T <DOMAIN> -Q */*"], "prerequisites": ["ps-ldapsearch-function"], "troubleshooting": {"No results": "No SPNs registered. Try PowerView: Get-NetUser -SPN"}, "notes": "Critical for Kerberoasting. User accounts with SPNs allow requesting TGS tickets encrypted with service account password hash.", "oscp_relevance": "high"}, {"id": "ps-ldapsearch-admins", "name": "LDAP Query Privileged Accounts (PowerShell)", "category": "enumeration", "command": "LDAPSearch -LDAPQuery \"(adminCount=1)\"", "description": "Query all accounts with adminCount=1 (privileged accounts)", "tags": ["ACTIVE_DIRECTORY", "ENUMERATION", "PRIVILEGED_ACCOUNTS", "LDAP", "POWERSHELL", "OSCP:HIGH"], "variables": [], "flag_explanations": {"(adminCount=1)": "Identifies accounts protected by AdminSDHolder. These are privileged accounts (Domain Admins, Enterprise Admins, etc.). AdminSDHolder sets inheritance flag and ACLs hourly."}, "success_indicators": ["adminCount", "samaccountname"], "failure_indicators": ["Function not defined"], "next_steps": ["Check group membership for discovered accounts"], "alternatives": ["Get-NetUser -AdminCount"], "prerequisites": ["ps-ldapsearch-function"], "troubleshooting": {}, "notes": "adminCount=1 indicates account is/was in privileged group. AdminSDHolder process sets this flag on Domain Admins, Enterprise Admins, and other high-privilege groups.", "oscp_relevance": "high"}]}