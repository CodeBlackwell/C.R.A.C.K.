{
  "category": "enumeration",
  "description": "Hash extraction and formatting tools for password cracking",
  "commands": [
    {
      "id": "keepass2john-extract",
      "name": "Extract KeePass Database Hash",
      "category": "enumeration",
      "command": "keepass2john <KEEPASS_DB> > <OUTPUT_FILE>",
      "description": "Convert KeePass database to John/Hashcat compatible hash format",
      "tags": [
        "HASH_FORMATTING",
        "KEEPASS",
        "PASSWORD_MANAGER",
        "JOHN",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<KEEPASS_DB>",
          "description": "Path to KeePass database file (.kdbx)",
          "example": "Database.kdbx",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output file for hash",
          "example": "keepass.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "keepass2john": "Extraction tool from JtR suite. Extracts master password hash from KeePass database. Supports KeePass 1.x and 2.x formats. Output format: filename:$keepass$*version*rounds*...*hash. For Hashcat: remove 'filename:' prefix. For John: use as-is."
      },
      "success_indicators": [
        "$keepass$*2*",
        "Database:$keepass$"
      ],
      "failure_indicators": [
        "Error opening file",
        "Not a valid KeePass file"
      ],
      "next_steps": [
        "hashcat-keepass-crack",
        "john-keepass-crack"
      ],
      "troubleshooting": {
        "Not a valid KeePass file": "File corrupted or not KeePass format. Verify: file Database.kdbx (should show 'Keepass password database')",
        "Command not found": "Install john: apt install john"
      },
      "notes": "OSCP TIP:\nKeePass databases found in:\n~/Documents, Desktop, network shares, Downloads.\n\nSearch:\nfind / -name '*.kdbx' 2>/dev/null.\n\nAfter extraction, REMOVE 'Database:' prefix for Hashcat (keep for John).\n\nHash format:\n$keepass$*2*60*0*hash_data.\n\nThe *2* indicates KeePass 2.x, *60* is transform rounds (in thousands).",
      "oscp_relevance": "high"
    },
    {
      "id": "ssh2john-extract",
      "name": "Extract SSH Private Key Hash",
      "category": "enumeration",
      "command": "ssh2john <PRIVATE_KEY> > <OUTPUT_FILE>",
      "description": "Convert SSH private key to John/Hashcat compatible hash format",
      "tags": [
        "HASH_FORMATTING",
        "SSH",
        "PRIVATE_KEY",
        "JOHN",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<PRIVATE_KEY>",
          "description": "Path to SSH private key file",
          "example": "id_rsa",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output file for hash",
          "example": "ssh.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "ssh2john": "Extraction tool from JtR suite. Extracts passphrase hash from encrypted SSH private keys. Supports RSA, DSA, EC keys. Supports all OpenSSH ciphers (aes-256-cbc, aes-256-ctr, etc.). Output format: filename:$sshng$*cipher*...*hash. For Hashcat: remove 'filename:' prefix AND verify cipher support (mode 22921 = aes-256-cbc only). For John: use as-is (supports all ciphers)."
      },
      "success_indicators": [
        "$sshng$",
        "id_rsa:$sshng$"
      ],
      "failure_indicators": [
        "Error: Not an encrypted key",
        "Command not found"
      ],
      "next_steps": [
        "hashcat-ssh-key-crack",
        "john-ssh-key-crack"
      ],
      "troubleshooting": {
        "Not an encrypted key": "SSH key has no passphrase - can use directly without cracking. Test: ssh -i id_rsa user@target (if no passphrase prompt = no encryption)",
        "Token length exception in Hashcat": "SSH key uses aes-256-ctr cipher (Hashcat unsupported). Use John the Ripper instead"
      },
      "notes": "OSCP TIP:\nSSH keys found in:\n~/.ssh/id_rsa, /root/.ssh/id_rsa, web server file disclosure, backup files.\n\nSearch:\nfind / -name id_rsa 2>/dev/null.\n\nAfter extraction, check hash for cipher:\n$sshng$X$ where X=cipher indicator ($6$=aes-256-cbc, etc.).\n\nModern keys often use aes-256-ctr (John only, NOT Hashcat).\n\nRemove 'id_rsa:' prefix before cracking.",
      "oscp_relevance": "high"
    },
    {
      "id": "zip2john-extract",
      "name": "Extract Encrypted ZIP Hash",
      "category": "enumeration",
      "command": "zip2john <ZIP_FILE> > <OUTPUT_FILE>",
      "description": "Convert encrypted ZIP file to crackable hash format",
      "tags": [
        "HASH_FORMATTING",
        "ZIP",
        "ARCHIVE",
        "JOHN",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<ZIP_FILE>",
          "description": "Path to encrypted ZIP file",
          "example": "encrypted.zip",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "zip.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "zip2john": "Extraction tool for password-protected ZIP archives. Extracts hash from ZIP encryption metadata. Supports ZipCrypto (traditional) and AES encryption. Output includes all encrypted files in archive. Multiple files = multiple hash lines (crack any to access all if same password)."
      },
      "success_indicators": [
        "$zip2$",
        "encrypted.zip/"
      ],
      "failure_indicators": [
        "Error: Not a ZIP file",
        "No encrypted files found"
      ],
      "next_steps": [
        "john-wordlist-attack"
      ],
      "notes": "ZIP files often contain:\nbackup data, sensitive documents, password lists.\n\nAfter cracking, extract with:\nunzip encrypted.zip (enter cracked password).\n\nCheck if ZIP actually requires password:\nunzip -l encrypted.zip (if succeeds = no password needed).",
      "oscp_relevance": "medium"
    },
    {
      "id": "rar2john-extract",
      "name": "Extract Encrypted RAR Hash",
      "category": "enumeration",
      "command": "rar2john <RAR_FILE> > <OUTPUT_FILE>",
      "description": "Convert encrypted RAR archive to crackable hash format",
      "tags": [
        "HASH_FORMATTING",
        "RAR",
        "ARCHIVE",
        "JOHN",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<RAR_FILE>",
          "description": "Path to encrypted RAR file",
          "example": "encrypted.rar",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "rar.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "rar2john": "Extraction tool for password-protected RAR archives. Supports RAR3 and RAR5 formats. RAR5 significantly slower to crack (stronger KDF). Output format indicates RAR version. Single password for all files in archive."
      },
      "success_indicators": [
        "$rar5$",
        "$rar3$"
      ],
      "notes": "RAR5 uses much stronger encryption than RAR3 (similar to bcrypt slowness).\n\nAfter cracking, extract with:\nunrar x encrypted.rar (or 7z x encrypted.rar).",
      "oscp_relevance": "medium"
    },
    {
      "id": "office2john-extract",
      "name": "Extract Microsoft Office Document Hash",
      "category": "enumeration",
      "command": "office2john <OFFICE_FILE> > <OUTPUT_FILE>",
      "description": "Convert password-protected Office documents to crackable hash",
      "tags": [
        "HASH_FORMATTING",
        "OFFICE",
        "DOCUMENT",
        "JOHN",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<OFFICE_FILE>",
          "description": "Path to encrypted Office file (.docx, .xlsx, .pptx)",
          "example": "encrypted.docx",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "office.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "office2john": "Extraction tool for password-protected Office documents (Word, Excel, PowerPoint). Supports Office 2007+ formats (.docx, .xlsx, .pptx). Uses strong encryption (AES) - slow cracking. Output indicates Office version and encryption type."
      },
      "success_indicators": [
        "$office$",
        "encrypted.docx:"
      ],
      "notes": "Office 2007+ uses AES encryption (slow cracking).\n\nFocus on targeted wordlists.\n\nCommon scenario:\npassword-protected spreadsheets with credentials, macros, sensitive data.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hash-identifier",
      "name": "Identify Hash Type",
      "category": "enumeration",
      "command": "hash-identifier",
      "description": "Interactive hash type identifier tool",
      "tags": [
        "HASH_IDENTIFICATION",
        "HASH_TYPE",
        "ANALYSIS",
        "OSCP:MEDIUM"
      ],
      "variables": [],
      "flag_explanations": {
        "hash-identifier": "Interactive tool - paste hash, get possible hash types. Lists multiple possibilities (many hashes look similar - MD2/MD4/MD5 all 32 hex chars). Use context clues (source system, application) to determine correct type. Alternative: hashid (command-line, non-interactive)."
      },
      "success_indicators": [
        "Possible Hashs:",
        "[+] MD5",
        "[+] NTLM"
      ],
      "notes": "OSCP TIP:\nHash identification by characteristics - Length 32 hex:\nMD5/MD4/MD2/NTLM, Length 40 hex:\nSHA1, Length 64 hex:\nSHA256.\n\nContext helps:\nWindows = NTLM, Linux /etc/shadow = sha512crypt ($6$), Web apps = MD5/bcrypt.\n\nCannot always distinguish - may need to try multiple modes.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashid",
      "name": "Hashid - Modern Hash Identifier",
      "category": "enumeration",
      "command": "hashid '<HASH>' -m",
      "description": "Identify hash type with Hashcat/John mode numbers",
      "tags": [
        "HASH_IDENTIFICATION",
        "HASH_TYPE",
        "HASHCAT",
        "JOHN",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<HASH>",
          "description": "Hash string to identify (quote if contains special chars)",
          "example": "5f4dcc3b5aa765d61d8327deb882cf99",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m": "Mode numbers - Display Hashcat (-m) and John (--format) mode numbers for identified hash types. Extremely useful - directly tells you which mode to use. Saves time vs manual lookup in --help."
      },
      "success_indicators": [
        "[+] MD5",
        "Hashcat Mode: 0",
        "JtR Format: raw-md5"
      ],
      "notes": "OSCP TIP:\nUse hashid instead of hash-identifier for modern workflows.\n\nCommand-line (scriptable) + shows exact modes for Hashcat/John.\n\nExample:\nhashid '$6$rounds=5000$...' -m \u2192 identifies sha512crypt with Hashcat mode 1800 and JtR format sha512crypt.\n\nQuote hashes to prevent shell interpretation of special chars ($, !).",
      "oscp_relevance": "high",
      "prerequisites": [],
      "alternatives": [
        "hash-identifier",
        "hash-identifier-run"
      ],
      "next_steps": [
        "hashcat-benchmark",
        "hash-rate-benchmark",
        "hashcat-crack",
        "john-crack"
      ]
    },
    {
      "id": "pdf2john-extract",
      "name": "Extract PDF Password Hash",
      "category": "enumeration",
      "command": "pdf2john <PDF_FILE> > <OUTPUT_FILE>",
      "description": "Convert password-protected PDF to crackable hash",
      "tags": [
        "HASH_FORMATTING",
        "PDF",
        "DOCUMENT",
        "JOHN",
        "OSCP:LOW"
      ],
      "variables": [
        {
          "name": "<PDF_FILE>",
          "description": "Path to encrypted PDF file",
          "example": "encrypted.pdf",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "pdf.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "pdf2john": "Extraction tool for password-protected PDFs. PDFs can have two password types: 1) User password (open document), 2) Owner password (modify/print). Tool extracts both if present. PDF encryption varies - some versions weaker than others."
      },
      "success_indicators": [
        "$pdf$",
        "encrypted.pdf:"
      ],
      "notes": "PDFs often contain:\ndocumentation, password lists, network diagrams.\n\nTwo password types:\nuser (viewing) and owner (editing).\n\nMay only need user password for access.",
      "oscp_relevance": "low"
    },
    {
      "id": "python-hash-generator",
      "name": "Generate Hash for Testing",
      "category": "enumeration",
      "command": "echo -n '<PASSWORD>' | md5sum",
      "description": "Generate MD5 hash for testing/verification",
      "tags": [
        "HASH_GENERATION",
        "TESTING",
        "MD5",
        "VERIFICATION",
        "OSCP:LOW"
      ],
      "variables": [
        {
          "name": "<PASSWORD>",
          "description": "Plaintext password to hash",
          "example": "password123",
          "required": true
        }
      ],
      "flag_explanations": {
        "echo -n": "No newline - Essential flag! Without -n, newline is appended to string, changing the hash. Compare: echo 'test' | md5sum (includes \\n) vs echo -n 'test' | md5sum (excludes \\n). Always use -n for password hashing.",
        "md5sum": "Generate MD5 hash. Alternatives: sha1sum, sha256sum, sha512sum. Used for: 1) Testing hash cracking setup 2) Verifying cracked passwords 3) Understanding hash behavior"
      },
      "success_indicators": [
        "32 hex character hash",
        "hash  -"
      ],
      "notes": "OSCP TIP:\nVerify crack success by regenerating hash.\n\nExample:\nCracked password = 'secret1', verify:\necho -n 'secret1' | sha256sum (compare to original hash).\n\nUse for understanding:\nsame plaintext \u2192 same hash, different plaintext \u2192 different hash.\n\nGenerate test hashes:\nfor pw in pass password 123456; do echo -n \"$pw\" | md5sum; done",
      "oscp_relevance": "low"
    },
    {
      "id": "base64-decode-hash",
      "name": "Base64 Decode Hash",
      "category": "enumeration",
      "command": "echo '<ENCODED_STRING>' | base64 -d",
      "description": "Decode base64-encoded strings (sometimes contain hashes)",
      "tags": [
        "DECODING",
        "BASE64",
        "HASH_FORMATTING",
        "OSCP:LOW"
      ],
      "variables": [
        {
          "name": "<ENCODED_STRING>",
          "description": "Base64-encoded string",
          "example": "cGFzc3dvcmQxMjM=",
          "required": true
        }
      ],
      "flag_explanations": {
        "base64 -d": "Decode base64 - Sometimes passwords/hashes are base64-encoded for transport/storage. Not encryption (easily reversible). Encoding != security. Decode to reveal actual hash or password. Identify base64: Ends with = or ==, uses A-Z, a-z, 0-9, +, /"
      },
      "success_indicators": [
        "decoded plaintext output"
      ],
      "notes": "Base64 is encoding, NOT encryption.\n\nSome applications store passwords/hashes base64-encoded.\n\nAlways try decoding suspicious base64 strings.\n\nEncode:\necho -n 'password123' | base64.\n\nDecode:\necho 'cGFzc3dvcmQxMjM=' | base64 -d",
      "oscp_relevance": "low"
    }
  ]
}