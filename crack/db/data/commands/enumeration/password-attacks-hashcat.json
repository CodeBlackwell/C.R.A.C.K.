{
  "category": "enumeration",
  "description": "Password hash cracking using Hashcat (GPU/CPU accelerated)",
  "commands": [
    {
      "id": "hashcat-benchmark",
      "name": "Hashcat Benchmark Hash Rates",
      "category": "enumeration",
      "command": "hashcat -b",
      "description": "Benchmark all hash algorithms to determine cracking speed",
      "tags": [
        "HASHCAT",
        "BENCHMARK",
        "PERFORMANCE",
        "HASH_CRACKING"
      ],
      "variables": [],
      "flag_explanations": {
        "-b": "Benchmark mode - Tests all supported hash algorithms and displays hash rate (hashes per second). Critical for: 1) Calculating cracking time before starting 2) Comparing GPU vs CPU performance 3) Determining hardware bottlenecks. Results in MH/s (millions of hashes/second). GPU typically 10-100x faster than CPU for most algorithms."
      },
      "success_indicators": [
        "Speed.#1.........: ",
        "MH/s",
        "Benchmark completed"
      ],
      "failure_indicators": [
        "No devices found",
        "OpenCL initialization failed",
        "CUDA initialization failed"
      ],
      "troubleshooting": {
        "No devices found": "No GPU detected or drivers missing. Install: apt install ocl-icd-opencl-dev nvidia-opencl-icd (NVIDIA) or amdgpu-pro (AMD)",
        "OpenCL initialization failed": "OpenCL runtime not installed. Solution: apt install ocl-icd-libopencl1",
        "Running on CPU": "Expected in Kali VM without GPU passthrough. Use --force flag to suppress warnings"
      },
      "notes": "certification TIP:\nRun benchmark BEFORE exam to understand your hardware capabilities.\n\nCalculate cracking time = keyspace / hash_rate.\n\nExample:\nMD5 @ 68,000 MH/s vs SHA256 @ 9,000 MH/s.\n\nGPU benchmark requires GPU passthrough in VM or physical machine.\n\nVM without GPU will use CPU (much slower).",
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "hashcat-md5-crack",
        "hashcat-ntlm-crack",
        "hashcat-sha256-crack"
      ]
    },
    {
      "id": "hashcat-md5-crack",
      "name": "Crack MD5 Hash (Mode 0)",
      "category": "enumeration",
      "command": "hashcat -m 0 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack MD5 hashes using dictionary attack",
      "tags": [
        "HASHCAT",
        "MD5",
        "DICTIONARY_ATTACK",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing MD5 hash(es) - one per line",
          "example": "md5_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 0": "Hash mode 0 - MD5 algorithm. Use 'hashcat --help' or hashcat wiki to find modes. Common: 0=MD5, 100=SHA1, 1400=SHA256, 1000=NTLM, 3200=bcrypt, 1800=sha512crypt. Mode MUST match hash type or cracking fails silently.",
        "--force": "Force execution - Ignore warnings about drivers/OpenCL. REQUIRED in Kali VM without GPU. WARNING: May produce incorrect results in edge cases - verify found passwords manually when using --force. Only use when necessary (VM testing, driver issues)."
      },
      "success_indicators": [
        "Cracked",
        "Status...........: Cracked",
        "<HASH>:<PASSWORD>"
      ],
      "failure_indicators": [
        "Exhausted",
        "Status...........: Exhausted",
        "No hashes loaded"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "hashcat-rule-attack",
        "ssh-login-password"
      ],
      "alternatives": [
        "john-wordlist-attack"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "No hashes loaded": "Hash format incorrect. Solution: Ensure one hash per line, no extra spaces. Remove usernames if present (user:hash \u2192 hash only unless hash:pass format expected)",
        "Token length exception": "Hash format doesn't match mode. Solution: Verify hash type with hash-identifier or hashid",
        "Separator unmatched": "Hash file has incorrect format. For username:hash format, use --username flag"
      },
      "notes": "certification TIP:\nMD5 is FAST (68,000 MH/s on GPU = 68 billion hashes/second).\n\n8-char password with full charset = 6.5 hours.\n\nAlways try straight dictionary attack before rules.\n\nRemove 'username:' prefix from hash file unless using --username flag.\n\nVerify mode matches hash type.",
      "filled_example": "hashcat -m 0 md5_hashes.txt /usr/share/wordlists/rockyou.txt --force"
    },
    {
      "id": "hashcat-sha256-crack",
      "name": "Crack SHA256 Hash (Mode 1400)",
      "category": "enumeration",
      "command": "hashcat -m 1400 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack SHA-256 hashes using dictionary attack",
      "tags": [
        "HASHCAT",
        "SHA256",
        "DICTIONARY_ATTACK",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing SHA-256 hash(es)",
          "example": "sha256_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 1400": "Hash mode 1400 - SHA-256 algorithm. Slower than MD5 but still fast (9,000 MH/s on GPU vs 68,000 for MD5). Common in modern applications. SHA-256 hash = 64 hex characters."
      },
      "success_indicators": [
        "Status...........: Cracked",
        "Recovered........: 1/1"
      ],
      "notes": "SHA-256 hash length:\n64 characters.\n\nExample:\n5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6 = 'secret1'.\n\nSlower than MD5 but still GPU-friendly.",
      "prerequisites": [],
      "alternatives": [
        "john-wordlist-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "hashcat-rule-attack"
      ],
      "filled_example": "hashcat -m 1400 sha256_hashes.txt /usr/share/wordlists/rockyou.txt --force"
    },
    {
      "id": "hashcat-ntlm-crack",
      "name": "Crack NTLM Hash (Mode 1000)",
      "category": "enumeration",
      "command": "hashcat -m 1000 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack Windows NTLM hashes",
      "tags": [
        "HASHCAT",
        "NTLM",
        "WINDOWS",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing NTLM hash(es)",
          "example": "ntlm_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 1000": "Hash mode 1000 - NTLM (Windows password hashes). VERY FAST to crack (even faster than MD5). Extracted from SAM database, memory (mimikatz), or SMB authentication. Format: 32 hex characters. No salt = rainbow table vulnerable."
      },
      "success_indicators": [
        "Cracked",
        "Recovered........: 1/1"
      ],
      "notes": "certification TIP:\nNTLM hashes from Windows SAM, memory dumps, or SMBv1/v2 captures.\n\nEXTREMELY fast cracking (no salt).\n\nCommon in Windows domain environments.\n\nExtract with:\nmimikatz, secretsdump.py, reg save HKLM\\SAM sam.save",
      "prerequisites": [
        "secretsdump-hashes",
        "ad-sam-dump-reg-save"
      ],
      "alternatives": [
        "john-wordlist-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "pth-evil-winrm",
        "crackmapexec-validate-admin"
      ],
      "filled_example": "hashcat -m 1000 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --force"
    },
    {
      "id": "hashcat-rule-attack",
      "name": "Hashcat Rule-Based Attack",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Apply mutation rules to wordlist passwords",
      "tags": [
        "HASHCAT",
        "RULES",
        "MUTATION",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash type mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Path to rule file",
          "example": "/usr/share/hashcat/rules/best64.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r": "Rule file - Apply mutation rules to wordlist. Rules modify passwords (append, prepend, capitalize, etc.). Hashcat includes proven rules in /usr/share/hashcat/rules/. Best rules: best64.rule (fast), rockyou-30000.rule (thorough), dive.rule (comprehensive). Custom rules format: one rule per line, uses hashcat rule syntax ($1 = append '1', c = capitalize, etc.)"
      },
      "success_indicators": [
        "Guess.Mod........: Rules",
        "Cracked"
      ],
      "prerequisites": [
        "hashcat-test-rules"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "alternatives": [
        "john-rules-attack",
        "hashcat-best64-rules"
      ],
      "notes": "certification TIP:\nRule-based attacks crack passwords that don't exist in wordlist.\n\nPassword policies require complexity = users modify base words (Password \u2192 Password123!).\n\nBest rules for certification:\nbest64.rule (fast testing), rockyou-30000.rule (designed for rockyou.txt).\n\nDramatically increases keyspace (14M passwords \u00d7 30,000 rules = 420B attempts).\n\nMonitor with --status to track progress.",
      "filled_example": "hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"
    },
    {
      "id": "hashcat-keepass-crack",
      "name": "Crack KeePass Database (Mode 13400)",
      "category": "enumeration",
      "command": "hashcat -m 13400 <KEEPASS_HASH> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack KeePass master password",
      "tags": [
        "HASHCAT",
        "KEEPASS",
        "PASSWORD_MANAGER",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<KEEPASS_HASH>",
          "description": "KeePass hash file (from keepass2john)",
          "example": "keepass.hash",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for mutations",
          "example": "/usr/share/hashcat/rules/rockyou-30000.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 13400": "Hash mode 13400 - KeePass 1 (AES/Twofish) and KeePass 2 (AES). Password manager master password. SLOW algorithm (by design - bcrypt-based KDF with iterations). CPU cracking may be comparable to GPU for KeePass. Hash extracted with keepass2john tool."
      },
      "success_indicators": [
        "Cracked",
        "$keepass$*...:PASSWORD"
      ],
      "prerequisites": [
        "keepass2john-extract"
      ],
      "alternatives": [
        "john-keepass-crack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "ssh-login-password",
        "evil-winrm-shell"
      ],
      "troubleshooting": {
        "Token length exception": "Hash format invalid. Solution: Ensure keepass2john output is correct format, remove 'filename:' prefix before first $keepass$"
      },
      "notes": "certification TIP:\nKeePass databases found in user Documents, Desktop, or network shares.\n\nExtract hash with keepass2john Database.kdbx > keepass.hash.\n\nRemove 'Database:' prefix.\n\nKeePass uses strong KDF (slow hashing) - cracking takes longer than simple hashes.\n\nFocus on targeted wordlists based on user password patterns.\n\nCommon user behavior:\nreuse password fragments with policy modifications (Password1! \u2192 Password123!).",
      "filled_example": "hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force"
    },
    {
      "id": "hashcat-ssh-key-crack",
      "name": "Crack SSH Private Key Passphrase (Mode 22921)",
      "category": "enumeration",
      "command": "hashcat -m 22921 <SSH_HASH> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack SSH private key passphrase (aes-256-cbc cipher)",
      "tags": [
        "HASHCAT",
        "SSH",
        "PRIVATE_KEY",
        "PASSPHRASE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<SSH_HASH>",
          "description": "SSH key hash file (from ssh2john)",
          "example": "ssh.hash",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "custom_wordlist.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for mutations",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 22921": "Hash mode 22921 - SSH private keys (RSA/DSA/EC) encrypted with aes-256-cbc cipher ($6$ in hash). WARNING: Modern SSH keys may use aes-256-ctr cipher which Hashcat does NOT support. If you get 'Token length exception', use John the Ripper instead (john supports aes-256-ctr)."
      },
      "success_indicators": [
        "Cracked",
        "$sshng$...:PASSPHRASE"
      ],
      "failure_indicators": [
        "Token length exception",
        "Hashfile on line X: Token length exception"
      ],
      "prerequisites": [
        "ssh2john-extract"
      ],
      "alternatives": [
        "john-ssh-key-crack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "ssh-connect-password"
      ],
      "troubleshooting": {
        "Token length exception": "SSH key uses unsupported cipher (likely aes-256-ctr). Solution: Use John the Ripper instead - it supports more SSH ciphers including aes-256-ctr",
        "No hashes loaded": "Hash format incorrect. Ensure ssh2john output format, remove 'filename:' prefix"
      },
      "notes": "certification TIP:\nSSH private keys found in ~/.ssh/id_rsa, web server file disclosure vulnerabilities, or backup files.\n\nExtract hash with ssh2john id_rsa > ssh.hash.\n\nRemove 'id_rsa:' prefix.\n\nCheck hash for cipher type:\n$6$ = aes-256-cbc (Hashcat OK), others may require JtR.\n\nModern keys often use aes-256-ctr (JtR required).\n\nBuild custom wordlists from user information (names, dates, common words found in notes.txt).",
      "filled_example": "hashcat -m 22921 ssh.hash custom_wordlist.txt -r custom.rule --force"
    },
    {
      "id": "hashcat-combination-attack",
      "name": "Hashcat Combination Attack",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 1 <HASH_FILE> <WORDLIST1> <WORDLIST2> --force",
      "description": "Combine words from two wordlists (word1+word2)",
      "tags": [
        "HASHCAT",
        "COMBINATION",
        "HYBRID",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST1>",
          "description": "First wordlist (left side)",
          "example": "words1.txt",
          "required": true
        },
        {
          "name": "<WORDLIST2>",
          "description": "Second wordlist (right side)",
          "example": "words2.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 1": "Attack mode 1 - Combination attack. Concatenates each word from wordlist1 with each word from wordlist2. Example: wordlist1=['pass','admin'] + wordlist2=['word','123'] = passwords: password, pass123, adminword, admin123. Keyspace = wordlist1_size \u00d7 wordlist2_size. Useful for passwords like firstname+lastname, word+year, prefix+suffix."
      },
      "success_indicators": [
        "Guess.Base.......: File, File (combination)",
        "Cracked"
      ],
      "notes": "Combination attack for compound passwords.\n\nExample:\nFirst names + Last names, Words + Years, Common prefixes + Common words.\n\nKeyspace explodes quickly (1000 \u00d7 1000 = 1M passwords).\n\nConsider using small focused lists.",
      "filled_example": "hashcat -m 0 -a 1 hashes.txt words1.txt words2.txt --force"
    },
    {
      "id": "hashcat-mask-attack",
      "name": "Hashcat Mask Attack (Brute-Force Pattern)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> <MASK> --force",
      "description": "Brute-force attack using character mask pattern",
      "tags": [
        "HASHCAT",
        "MASK",
        "BRUTE_FORCE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Character mask pattern",
          "example": "?u?l?l?l?l?d?d?d?s",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 3": "Attack mode 3 - Mask attack (pure brute-force with pattern). Define character positions: ?l=lowercase, ?u=uppercase, ?d=digit, ?s=special. Example: ?u?l?l?l?l?d?d?d?s = Uppercase + 4 lowercase + 3 digits + 1 special (Password123!). Faster than full brute-force by constraining character sets per position. Use when password policy is known.",
        "<MASK>": "Character mask - ?l=lowercase (a-z), ?u=uppercase (A-Z), ?d=digits (0-9), ?s=special (!@#$%...), ?a=all. Example masks: ?d?d?d?d?d?d (6 digits), ?u?l?l?l?l?d?d?s (Pass12!), ?a?a?a?a?a?a?a?a (8-char full brute). Keyspace = charset_size^positions."
      },
      "success_indicators": [
        "Guess.Mask.......: <MASK>",
        "Cracked"
      ],
      "notes": "Use mask attacks when password policy is known.\n\nExample:\n'Must start with capital, end with number and special char, 8 chars min' \u2192 ?u?l?l?l?l?d?d?s.\n\nWARNING:\nBrute-force is SLOW.\n\n8-char full charset (?a?a?a?a?a?a?a?a) = years on CPU.\n\nOnly use for short passwords or constrained charsets.",
      "prerequisites": [],
      "alternatives": [
        "hashcat-increment",
        "john-incremental-mode"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "filled_example": "hashcat -m 0 -a 3 hashes.txt ?u?l?l?l?l?d?d?d?s --force"
    },
    {
      "id": "hashcat-hybrid-attack",
      "name": "Hashcat Hybrid Attack (Wordlist + Mask)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 6 <HASH_FILE> <WORDLIST> <MASK> --force",
      "description": "Append mask pattern to wordlist words",
      "tags": [
        "HASHCAT",
        "HYBRID",
        "MASK",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Mask to append",
          "example": "?d?d?s",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 6": "Attack mode 6 - Hybrid wordlist + mask. Appends mask to each wordlist word. Example: wordlist='password' + mask='?d?d?s' = password00!, password01!, password00@, etc. Mode 7 prepends mask instead. Efficient for 'base word + numbers + special' pattern (common user behavior)."
      },
      "success_indicators": [
        "Guess.Base.......: File, Mask",
        "Cracked"
      ],
      "notes": "Hybrid attacks for common password patterns:\nbase_word + digits + special.\n\nExample:\nrockyou.txt + ?d?d?s (2 digits + 1 special) = Password12!, Welcome99#, etc.\n\nMore efficient than full rule-based attack for this specific pattern.",
      "prerequisites": [],
      "alternatives": [
        "hashcat-rule-attack",
        "hashcat-mask-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "filled_example": "hashcat -m 0 -a 6 hashes.txt /usr/share/wordlists/rockyou.txt ?d?d?s --force"
    },
    {
      "id": "hashcat-show-cracked",
      "name": "Show Cracked Passwords",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> --show",
      "description": "Display previously cracked passwords from potfile",
      "tags": [
        "HASHCAT",
        "RESULTS",
        "OUTPUT",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Original hash file",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--show": "Show cracked - Display passwords from hashcat.potfile (persistent storage). Hashcat automatically saves cracked hashes to ~/.hashcat/hashcat.potfile. Use --show to view results without re-running attack. Format: hash:password or username:hash:password."
      },
      "success_indicators": [
        "<HASH>:<PASSWORD>",
        "Recovered........: X/Y"
      ],
      "notes": "certification TIP:\nHashcat saves ALL cracked passwords to ~/.hashcat/hashcat.potfile permanently.\n\nUse --show to retrieve results.\n\nCritical for documentation - always run --show after successful crack to capture passwords for report.\n\nPotfile persists across sessions.",
      "prerequisites": [
        "hashcat-md5-crack",
        "hashcat-ntlm-crack"
      ],
      "alternatives": [
        "john-show-cracked"
      ],
      "next_steps": [
        "crackmapexec-validate-admin",
        "evil-winrm-shell",
        "ssh-login-password"
      ],
      "filled_example": "hashcat -m 0 hashes.txt --show"
    },
    {
      "id": "hashcat-output-format",
      "name": "Hashcat Output Format Control",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> --show --outfile-format=2",
      "description": "Control output format for cracked passwords",
      "tags": [
        "HASHCAT",
        "OUTPUT",
        "FORMAT",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--outfile-format": "Output format - Controls --show output. Values: 1=hash, 2=plain, 3=hex_plain, 5=hash:plain (default). Use format 2 for password-only output (useful for scripting). Format 5 shows hash:password pairs (best for documentation)."
      },
      "success_indicators": [
        "PASSWORD (format 2)",
        "HASH:PASSWORD (format 5)"
      ],
      "notes": "Output formats:\n2=password only (scripting), 5=hash:password (documentation).\n\nDefault format 5 is best for certification reporting.",
      "filled_example": "hashcat -m 0 hashes.txt --show --outfile-format=2"
    },
    {
      "id": "hashcat-status-timer",
      "name": "Hashcat Auto-Status Updates",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --status --status-timer=10",
      "description": "Display progress status every N seconds",
      "tags": [
        "HASHCAT",
        "STATUS",
        "PROGRESS",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--status": "Status display - Show progress updates. Press 's' key manually for on-demand status. Displays: Progress %, Speed (H/s), Time (running/estimated), Recovered hashes, Rejected, Temperature, etc.",
        "--status-timer": "Auto-status interval - Seconds between automatic status displays. Default: manual only. Use 10-60 for long-running attacks to monitor progress. Lower values = more output spam."
      },
      "success_indicators": [
        "Progress.........: X/Y",
        "Speed.#1.........: ",
        "Time.Estimated...: "
      ],
      "notes": "certification TIP:\nUse --status --status-timer=30 for long attacks (rule-based, large wordlists).\n\nProvides ETA for completion.\n\nCritical for time management in exam - know when to abandon attack if ETA exceeds available time.",
      "filled_example": "hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt --status --status-timer=10"
    },
    {
      "id": "hashcat-increment",
      "name": "Hashcat Increment Mode (Progressive Length)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> ?a?a?a?a?a?a --increment --increment-min=<MIN> --increment-max=<MAX> --force",
      "description": "Brute-force with incrementing password length",
      "tags": [
        "HASHCAT",
        "INCREMENT",
        "BRUTE_FORCE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<MIN>",
          "description": "Minimum password length",
          "example": "4",
          "required": true
        },
        {
          "name": "<MAX>",
          "description": "Maximum password length",
          "example": "8",
          "required": true
        }
      ],
      "flag_explanations": {
        "--increment": "Increment mode - Start with --increment-min length, progressively increase to --increment-max. Example: min=4, max=8 \u2192 tries all 4-char, then all 5-char, then 6, 7, 8. More efficient than starting at max length. Short passwords crack first.",
        "--increment-min": "Minimum length - Starting password length for increment mode. Use known password policy minimum. Default: 1 (usually wasteful).",
        "--increment-max": "Maximum length - Maximum password length for increment mode. Constrained by mask length. Example: mask=?a?a?a?a?a?a?a?a (8 chars) with --increment-max=8 tries lengths 1-8."
      },
      "notes": "Increment mode for brute-force when password length is unknown but constrained (policy:\n4-12 chars).\n\nWARNING:\nStill extremely slow.\n\n8-char full charset = years.\n\nOnly viable for fast hashes (MD5, NTLM) and short passwords (\u22646 chars).",
      "prerequisites": [],
      "alternatives": [
        "hashcat-mask-attack",
        "john-incremental-mode"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "filled_example": "hashcat -m 0 -a 3 hashes.txt ?a?a?a?a?a?a --increment --increment-min=4 --increment-max=8 --force"
    },
    {
      "id": "hashcat-potfile-disable",
      "name": "Hashcat Disable Potfile",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --potfile-disable --force",
      "description": "Disable automatic saving of cracked hashes",
      "tags": [
        "HASHCAT",
        "POTFILE",
        "CONFIG",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--potfile-disable": "Disable potfile - Don't save cracked hashes to hashcat.potfile. Use when: 1) Testing/debugging 2) Don't want persistent storage 3) Privacy concerns. WARNING: Results lost after session unless manually saved with --outfile."
      },
      "notes": "Rarely needed - potfile is BENEFICIAL for certification (persistent results, no re-cracking same hashes).\n\nOnly disable for testing or privacy.\n\nAlways use --outfile if potfile disabled.",
      "filled_example": "hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt --potfile-disable --force"
    },
    {
      "id": "hashcat-username-format",
      "name": "Hashcat Username:Hash Format",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --username --force",
      "description": "Handle hash files with username:hash format",
      "tags": [
        "HASHCAT",
        "USERNAME",
        "FORMAT",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "1000",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File with username:hash format",
          "example": "ntlm_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--username": "Username parsing - Enable if hash file format is 'username:hash' (one per line). Hashcat extracts username for output. Results show: 'username:hash:password'. Common for NTLM dumps (user:hash from SAM or secretsdump.py output). Without flag, Hashcat treats entire line as hash (fails)."
      },
      "success_indicators": [
        "Separator unmatched (without --username flag)",
        "username:hash:password (with flag)"
      ],
      "troubleshooting": {
        "Separator unmatched": "Hash file contains colons (username:hash format). Solution: Add --username flag or remove usernames (extract hash-only column)"
      },
      "notes": "certification TIP:\nsecretsdump.py, mimikatz, and SAM dumps often output username:hash format.\n\nUse --username flag to preserve username-password mapping for documentation.\n\nOutput format:\nuser:hash:password (critical for privilege escalation reporting).",
      "filled_example": "hashcat -m 1000 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --username --force"
    },
    {
      "id": "hashcat-custom-charset",
      "name": "Hashcat Custom Character Set",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> -1 <CHARSET> <MASK> --force",
      "description": "Define custom character set for mask attack",
      "tags": [
        "HASHCAT",
        "CUSTOM_CHARSET",
        "MASK",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<CHARSET>",
          "description": "Custom character set definition",
          "example": "abc123!@#",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Mask using custom charset (use ?1 for -1 charset)",
          "example": "?1?1?1?1?1?1",
          "required": true
        }
      ],
      "flag_explanations": {
        "-1": "Custom charset 1 - Define custom character set. Use ?1 in mask to reference it. Up to -4 custom charsets (-1, -2, -3, -4). Example: -1 'aeiou' ?1?1?1?1 = 4-char passwords using only vowels. Useful for: Limited charset passwords, hex-only, specific symbols, etc.",
        "?1": "Reference to custom charset 1 (defined with -1 flag). ?2 = charset 2 (-2), ?3 = charset 3 (-3), ?4 = charset 4 (-4)."
      },
      "notes": "Custom charsets for constrained brute-force.\n\nExample:\nHex passwords \u2192 -1 '0123456789abcdef' ?1?1?1?1?1?1.\n\nReduces keyspace dramatically (16^6 vs 95^6 for 6-char).",
      "prerequisites": [],
      "alternatives": [
        "hashcat-mask-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "filled_example": "hashcat -m 0 -a 3 hashes.txt -1 abc123!@# ?1?1?1?1?1?1 --force"
    },
    {
      "id": "hashcat-bcrypt-crack",
      "name": "Crack bcrypt Hash (Mode 3200)",
      "category": "enumeration",
      "command": "hashcat -m 3200 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack bcrypt hashes (SLOW algorithm)",
      "tags": [
        "HASHCAT",
        "BCRYPT",
        "SLOW_HASH",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing bcrypt hashes",
          "example": "bcrypt_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist (use focused list)",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 3200": "Hash mode 3200 - bcrypt algorithm. INTENTIONALLY SLOW (designed to resist cracking). Hash rate: ~100-10,000 H/s (compared to MD5: 68,000,000,000 H/s). GPU advantage minimal for bcrypt - CPU may be comparable. Common in modern web apps (Linux /etc/shadow $2y$, password managers). Requires FOCUSED wordlists (rockyou.txt = months/years)."
      },
      "success_indicators": [
        "Cracked",
        "Speed.#1.........: XXX H/s (not MH/s or GH/s)"
      ],
      "troubleshooting": {
        "Extremely slow progress": "Expected behavior - bcrypt is slow by design. Solution: 1) Use small focused wordlist 2) Rule-based attack with best rules only 3) Consider if viable given time constraints"
      },
      "notes": "certification WARNING:\nbcrypt cracking is VERY SLOW (1000-10000 passwords/second vs billions for MD5).\n\n14M rockyou.txt = 23-233 hours for straight dictionary.\n\nNOT viable for exam time constraints unless:\n1) Small focused wordlist 2) Password reuse suspected 3) No other attack vectors.\n\nFocus on other vulnerabilities first.",
      "prerequisites": [],
      "alternatives": [
        "john-wordlist-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "ssh-login-password"
      ],
      "filled_example": "hashcat -m 3200 bcrypt_hashes.txt /usr/share/wordlists/rockyou.txt --force"
    },
    {
      "id": "hashcat-debug-mode",
      "name": "Hashcat Debug Mode (Test Rules)",
      "category": "enumeration",
      "command": "hashcat <WORDLIST> -r <RULE_FILE> --stdout",
      "description": "Test rule mutations without cracking (debug mode)",
      "tags": [
        "HASHCAT",
        "DEBUG",
        "RULES",
        "TESTING"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist to mutate",
          "example": "test_words.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file to test",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "--stdout": "Debug mode - Output mutated passwords to stdout instead of cracking. No hash mode (-m) required. Used for: 1) Testing custom rules before cracking 2) Generating mutated wordlists 3) Verifying rule syntax. Can pipe output to file: hashcat wordlist -r rules --stdout > mutated.txt"
      },
      "success_indicators": [
        "Password1",
        "password!",
        "mutated output displayed"
      ],
      "notes": "certification TIP:\nAlways test custom rules with --stdout before running full crack.\n\nVerify mutations match expected password policy.\n\nExample:\necho 'password' | hashcat -r rules --stdout (test single word).\n\nSaves time vs discovering rule errors mid-crack.",
      "filled_example": "hashcat test_words.txt -r custom.rule --stdout"
    },
    {
      "id": "hashcat-optimized-kernel",
      "name": "Hashcat Optimized Kernel",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -O --force",
      "description": "Use optimized kernel for speed boost (password length \u226431)",
      "tags": [
        "HASHCAT",
        "OPTIMIZATION",
        "PERFORMANCE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-O": "Optimized kernel - Enable performance-optimized kernels for faster cracking. LIMITATION: Password length restricted to \u226431 characters (vs \u2264256 without -O). Speed increase: ~2x for many algorithms. Use when: 1) Password policy has length limit \u226431 2) No evidence of long passwords. WARNING: Will NOT crack passwords >31 chars."
      },
      "success_indicators": [
        "Optimized kernel based on rules file",
        "Faster H/s rate"
      ],
      "notes": "Speed boost (~2x) but limits password length to 31 chars.\n\nSafe for most real-world passwords (policies rarely allow >31).\n\nCheck password policy before using.",
      "filled_example": "hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -O --force"
    },
    {
      "id": "hashcat-crack-asrep",
      "name": "Crack Kerberos AS-REP Hash (Mode 18200)",
      "category": "enumeration",
      "command": "hashcat -m 18200 <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack Kerberos AS-REP hashes (AS-REP Roasting attack)",
      "tags": [
        "HASHCAT",
        "KERBEROS",
        "AS-REP",
        "ACTIVE_DIRECTORY",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing Kerberos AS-REP hashes from impacket-GetNPUsers or Rubeus",
          "example": "hashes.asreproast",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for password mutations",
          "example": "/usr/share/hashcat/rules/best64.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 18200": "Hash mode 18200 - Kerberos 5 AS-REP etype 23 (RC4-HMAC). Used for AS-REP Roasting attacks. Hash format: $krb5asrep$23$user@DOMAIN.COM:hash_data. Extracted from users with 'Do not require Kerberos preauthentication' enabled. FAST to crack (RC4-HMAC = no expensive KDF).",
        "-r": "Rule file - Apply password mutations (best64.rule recommended for security work - adds common patterns like Password1!, Password123, etc.)",
        "--force": "Force execution in VM without GPU (required in Kali VM)"
      },
      "success_indicators": [
        "Cracked",
        "Status...........: Cracked",
        "$krb5asrep$23$user@DOMAIN.COM:hash:password"
      ],
      "failure_indicators": [
        "Exhausted",
        "Token length exception",
        "No hashes loaded"
      ],
      "next_steps": [
        "crackmapexec-validate-admin",
        "hashcat-show-cracked"
      ],
      "alternatives": [],
      "prerequisites": [
        "impacket-getnpusers-asreproast",
        "rubeus-asreproast"
      ],
      "troubleshooting": {
        "Token length exception": "Hash format incorrect. Verify: (1) Used /nowrap flag with Rubeus (prevents line breaks). (2) Hash starts with $krb5asrep$23$. (3) Hash is single line (no line breaks mid-hash).",
        "No hashes loaded": "Hash file empty or wrong format. Verify file contains $krb5asrep$23$ hashes. Check for username: prefix (remove or use --username flag).",
        "Exhausted": "Password not in wordlist. Try: (1) Larger wordlist (rockyou.txt \u2192 xato-net-10-million). (2) Different rules (best64.rule \u2192 rockyou-30000.rule). (3) Targeted wordlist (user's name, company name, common patterns)."
      },
      "notes": "AS-REP ROASTING HASH CRACKING for users with Kerberos preauthentication disabled.\n\nHASH SOURCE:\nimpacket-GetNPUsers (Linux) or Rubeus asreproast (Windows).\n\nHASH FORMAT CRITICAL:\nMust be SINGLE LINE.\n\nRubeus without /nowrap flag produces MULTI-LINE hashes that Hashcat rejects.\n\nAlways use /nowrap.\n\nHASH MODE IDENTIFICATION:\nhashcat --help | grep -i 'Kerberos' | grep 'AS-REP' shows mode 18200.\n\nCRACKING SPEED:\nRC4-HMAC (etype 23) is FAST.\n\nGPU:\n~500 MH/s (rockyou.txt straight = <1 second).\n\nCPU (Kali VM):\n~500 KH/s (rockyou.txt straight = ~30 seconds).\n\nRULE-BASED ATTACK:\nhashcat -m 18200 hashes.asreproast rockyou.txt -r best64.rule --force adds 77 mutations per password (Password \u2192 Password1, Password!, Password123, etc.).\n\nTIME ESTIMATE:\nStraight dictionary (14M passwords) = <1 min on CPU, <1 sec on GPU.\n\nRule-based (14M \u00d7 77 = 1B+ combinations) = 5-30 min on CPU, 1-5 min on GPU.\n\ncertification TIP:\nTry straight dictionary FIRST (fastest).\n\nIf fails, add best64.rule.\n\nIf still fails, try rockyou-30000.rule (30K mutations, much slower but thorough).\n\nWeak passwords (Password1!, Welcome2023!) crack in <5 min.\n\nMONITORING:\nPress 's' key for status.\n\n--status --status-timer=30 for automatic updates every 30 seconds.\n\nRESULT STORAGE:\nCracked passwords automatically saved to ~/.hashcat/hashcat.potfile.\n\nView with:\nhashcat -m 18200 hashes.asreproast --show.\n\nALTERNATIVE HASH FORMAT:\nJohn the Ripper format also supported by some tools but Hashcat uses different mode.\n\nStick with Hashcat format from impacket/Rubeus.\n\ncertification EXAM:\nAS-REP roasting is QUICK WIN if vulnerable users exist (rare but possible).\n\nTotal time:\n30 sec enumeration + 1-30 min cracking = potential domain credentials in <30 minutes.",
      "filled_example": "hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"
    },
    {
      "id": "hashcat-sha512crypt-crack",
      "name": "Crack SHA512crypt Hash (Mode 1800)",
      "category": "enumeration",
      "command": "hashcat -m 1800 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack Linux SHA512crypt hashes ($6$ prefix from /etc/shadow)",
      "tags": [
        "HASHCAT",
        "SHA512CRYPT",
        "LINUX",
        "SHADOW",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing SHA512crypt hashes from /etc/shadow",
          "example": "shadow_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 1800": "Hash mode 1800 - sha512crypt ($6$ format). Linux password hashes from /etc/shadow. SLOW algorithm by design (5000+ rounds). Format: $6$salt$hash",
        "--force": "Force execution in Kali VM without GPU"
      },
      "success_indicators": [
        "Cracked",
        "Status...........: Cracked",
        "$6$...:password"
      ],
      "failure_indicators": [
        "Exhausted",
        "No hashes loaded"
      ],
      "notes": "SHA512crypt from Linux /etc/shadow ($6$ prefix). SLOW - uses 5000+ rounds by design. Extract with: unshadow /etc/passwd /etc/shadow > unshadowed.txt. GPU advantage limited due to algorithm design.",
      "prerequisites": [],
      "alternatives": [
        "john-wordlist-attack"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "ssh-login-password"
      ],
      "filled_example": "hashcat -m 1800 shadow_hashes.txt /usr/share/wordlists/rockyou.txt --force"
    },
    {
      "id": "hashcat-crack-tgsrep",
      "name": "Crack Kerberos TGS-REP Hash (Mode 13100)",
      "category": "enumeration",
      "command": "hashcat -m 13100 <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack Kerberos TGS-REP hashes (Kerberoasting attack)",
      "tags": [
        "HASHCAT",
        "KERBEROS",
        "TGS-REP",
        "KERBEROASTING",
        "ACTIVE_DIRECTORY",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing Kerberos TGS-REP hashes from impacket-GetUserSPNs or Rubeus",
          "example": "hashes.kerberoast",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for password mutations",
          "example": "/usr/share/hashcat/rules/best64.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 13100": "Hash mode 13100 - Kerberos 5 TGS-REP etype 23 (RC4-HMAC). Used for Kerberoasting attacks against service accounts. Hash format: $krb5tgs$23$*service_account$REALM$spn*$hash_data. CRITICAL: Computer accounts (MACHINE$) and Managed Service Accounts have 120-character random passwords = UNCRACKABLE. Only crack hashes from USER service accounts.",
        "-r": "Rule file - Mutations for service account password patterns (ServiceName123!, CompanySQL2023!, etc.)",
        "--force": "Force execution in VM without GPU"
      },
      "success_indicators": [
        "Cracked",
        "Status...........: Cracked",
        "$krb5tgs$23$*service_account$...:password"
      ],
      "failure_indicators": [
        "Exhausted",
        "Token length exception",
        "No hashes loaded"
      ],
      "next_steps": [
        "crackmapexec-validate-admin",
        "hashcat-show-cracked"
      ],
      "alternatives": [],
      "prerequisites": [
        "impacket-getuserspns-kerberoast",
        "rubeus-kerberoast"
      ],
      "troubleshooting": {
        "Token length exception": "Hash format incorrect. Verify: (1) Hash starts with $krb5tgs$23$ (RC4) not $krb5tgs$17$ or $krb5tgs$18$ (AES). (2) Single line format. (3) Extracted from USER account (not computer account).",
        "No hashes loaded": "Hash file empty, wrong format, or contains computer account hashes only. Filter: grep -v '\\$@' hashes.kerberoast (removes computer accounts ending in $).",
        "Exhausted after hours": "Possible causes: (1) Strong password (service accounts sometimes have complex passwords). (2) AES encryption (modes 19600/19700 = 10x slower). (3) Computer/MSA account (120-char password = uncrackable). Verify hash is from USER account, not computer account."
      },
      "notes": "KERBEROASTING HASH CRACKING for service account SPNs.\n\nHASH SOURCE:\nimpacket-GetUserSPNs (Linux) or Rubeus kerberoast (Windows).\n\nTARGET ACCOUNTS:\nUser accounts with servicePrincipalName attribute (sql_service, iis_service, svc_backup, etc.).\n\nUNCRACKABLE ACCOUNTS:\nComputer accounts (ending in $) and Managed Service Accounts have 120-character RANDOM passwords - DO NOT ATTEMPT TO CRACK.\n\nFilter these out before cracking.\n\nHASH FORMAT:\n$krb5tgs$23$ = RC4-HMAC (etype 23).\n\n$krb5tgs$17$ or $krb5tgs$18$ = AES256 or AES128 (slower).\n\nRC4 VS AES:\nRC4 cracking ~10x faster than AES.\n\nUse Rubeus /tgtdeleg flag to force RC4 downgrade on AES-enabled accounts.\n\nCRACKING SPEED:\nRC4 hash rate similar to NTLM (very fast).\n\nGPU:\n~500 MH/s.\n\nCPU:\n~500 KH/s.\n\nSERVICE ACCOUNT PASSWORD PATTERNS:\nOften follow conventions:\n(1) ServiceName + number (SQL \u2192 MSSQLService123!).\n\n(2) Company + service (Acme \u2192 AcmeSQL2019!).\n\n(3) Generic weak (Password1!, ServiceAccount123!).\n\n(4) Unchanged for YEARS (service accounts rarely rotated).\n\nATTACK STRATEGY:\n(1) STRAIGHT DICTIONARY:\nhashcat -m 13100 hashes.kerberoast rockyou.txt --force (fast, try first).\n\n(2) RULE-BASED:\nAdd best64.rule for common mutations (5-30 min).\n\n(3) TARGETED:\nCreate custom wordlist from:\nCompany name (Acme), Service type (SQL, IIS, Backup), Common patterns (Service123!, ServiceAccount2019!).\n\n(4) COMPREHENSIVE:\nUse rockyou-30000.rule for thorough attack (hours but higher success rate).\n\nTIME ESTIMATE:\nWeak password (dict word + number) = 5-30 min with rules.\n\nMedium password (10 random chars) = hours to days.\n\nStrong password (12+ random) = infeasible.\n\ncertification SUCCESS RATE:\nHIGH - 60-80% of corporate domains have Kerberoastable accounts with weak passwords.\n\nService accounts often neglected (set once, never changed, weak password chosen for 'memorability').\n\nMONITORING:\n--status --status-timer=30 for progress updates.\n\nRESULT EXTRACTION:\nhashcat -m 13100 hashes.kerberoast --show displays cracked passwords.\n\n--outfile-format=2 for passwords only, =5 for hash:password pairs.\n\ncertification EXAM:\nKerberoasting is HIGH-PRIORITY attack.\n\nTotal time:\n10 sec SPN enum + 10 sec TGS request + 5-120 min cracking.\n\nOften leads to:\n(1) Service account with Domain Admin privileges (immediate win).\n\n(2) Local admin on servers (lateral movement).\n\n(3) High-privilege service account (privilege escalation opportunities).\n\nCRITICAL WARNING:\nIf all SPNs are on computer accounts (names ending in $), hashes are UNCRACKABLE.\n\nDocument finding and proceed to alternative attacks (AS-REP roasting, password spraying, local privilege escalation).",
      "filled_example": "hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"
    }
  ]
}