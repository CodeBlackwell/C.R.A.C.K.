{
  "category": "enumeration",
  "description": "Password hash cracking using John the Ripper (CPU-optimized)",
  "commands": [
    {
      "id": "john-single-crack",
      "name": "John Single Crack Mode",
      "category": "enumeration",
      "command": "john --single <HASH_FILE>",
      "description": "Single crack mode using username-based variations",
      "tags": [
        "JOHN",
        "JTR",
        "SINGLE_MODE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing username:hash pairs",
          "example": "shadow.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--single": "Single crack mode - Generates password candidates based on username and GECOS fields. Most effective when hash file contains usernames (user:hash format). JtR applies intelligent mutations to username (john \u2192 john1, john123, John, JOHN, nhoj, etc.). Very fast - try FIRST before wordlist attacks. Success rate ~5-15% for weak passwords."
      },
      "success_indicators": [
        "Loaded X password hash",
        "guesses: X",
        "username (user)"
      ],
      "failure_indicators": [
        "No password hashes loaded",
        "0 password hashes cracked"
      ],
      "next_steps": [
        "john-wordlist-attack",
        "john-show-cracked"
      ],
      "alternatives": [],
      "prerequisites": [],
      "notes": "PRACTICAL TIP:\nAlways run single mode FIRST - it's fast (<1 minute) and surprisingly effective.\n\nCommon successes:\nusername123, Username1!, Username@2023.\n\nRequires username:hash format.\n\nMost effective on /etc/shadow dumps where GECOS fields provide hints (full names, departments).",
      "filled_example": "john --single shadow.txt"
    },
    {
      "id": "john-wordlist-attack",
      "name": "John Wordlist Attack",
      "category": "enumeration",
      "command": "john --wordlist=<WORDLIST> <HASH_FILE>",
      "description": "Dictionary attack using wordlist",
      "tags": [
        "JOHN",
        "JTR",
        "WORDLIST",
        "DICTIONARY_ATTACK",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Path to password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--wordlist": "Wordlist mode - Straight dictionary attack without mutations. Each password from wordlist tested as-is. Faster than rules mode but less coverage. Use for initial quick scan with common password lists. Default wordlist (if no path): /usr/share/john/password.lst (3,559 passwords)."
      },
      "success_indicators": [
        "Loaded X password hash",
        "guesses: X"
      ],
      "notes": "Standard dictionary attack.\n\nRun after --single mode.\n\nUse rockyou.txt for comprehensive coverage (14M passwords).\n\nJtR auto-detects hash format in most cases.",
      "prerequisites": [],
      "alternatives": [
        "hashcat-md5-crack",
        "hashcat-ntlm-crack"
      ],
      "next_steps": [
        "john-show-cracked",
        "john-rules-attack"
      ],
      "filled_example": "john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt"
    },
    {
      "id": "john-rules-attack",
      "name": "John Rule-Based Attack",
      "category": "enumeration",
      "command": "john --wordlist=<WORDLIST> --rules=<RULESET> <HASH_FILE>",
      "description": "Apply mutation rules to wordlist",
      "tags": [
        "JOHN",
        "JTR",
        "RULES",
        "MUTATION",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULESET>",
          "description": "Rule name from john.conf",
          "example": "sshRules",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "ssh.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "--rules": "Rules mode - Apply mutation rules from /etc/john/john.conf. Rules modify wordlist passwords (append, prepend, capitalize, etc.). Built-in rules: Wordlist (default), Extra, Jumbo, KoreLogic, All. Custom rules: Add [List.Rules:RuleName] section to john.conf. Rules dramatically increase coverage (password \u2192 Password1!, password123, etc.)."
      },
      "success_indicators": [
        "guesses: X",
        "Proceeding with wordlist mode"
      ],
      "prerequisites": [
        "john-test-rules"
      ],
      "alternatives": [
        "hashcat-rule-attack",
        "hashcat-best64-rules"
      ],
      "next_steps": [
        "john-show-cracked"
      ],
      "notes": "PRACTICAL TIP:\nRule-based attacks crack passwords not in wordlist.\n\nUsers modify base words to meet policies (Password \u2192 Password123!).\n\nCustom rules in /etc/john/john.conf:\n[List.Rules:sshRules] then rule functions.\n\nDefault rules often sufficient - try before custom.",
      "filled_example": "john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules ssh.hash"
    },
    {
      "id": "john-format-specify",
      "name": "John Specify Hash Format",
      "category": "enumeration",
      "command": "john --format=<FORMAT> --wordlist=<WORDLIST> <HASH_FILE>",
      "description": "Explicitly specify hash format (when auto-detect fails)",
      "tags": [
        "JOHN",
        "JTR",
        "FORMAT",
        "HASH_TYPE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<FORMAT>",
          "description": "Hash format identifier",
          "example": "raw-md5",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--format": "Hash format - Override auto-detection. Required when: 1) Auto-detect fails 2) Multiple hash types possible (MD2/MD4/MD5 look identical) 3) Custom format needed. List formats: john --list=formats. Common: raw-md5, raw-sha1, raw-sha256, nt (NTLM), bcrypt, descrypt, md5crypt, sha512crypt."
      },
      "success_indicators": [
        "Loaded X password hash (FORMAT)",
        "format confirmed in output"
      ],
      "failure_indicators": [
        "No password hashes loaded (check --format)",
        "Unknown format name"
      ],
      "notes": "List all formats:\njohn --list=formats | grep -i <hash_type>.\n\nCommon formats:\nraw-md5 (plain MD5), nt (NTLM), Raw-SHA256, bcrypt, md5crypt ($1$), sha512crypt ($6$).\n\nAuto-detect usually works but explicit format avoids ambiguity.",
      "filled_example": "john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt"
    },
    {
      "id": "john-show-cracked",
      "name": "Show Cracked Passwords",
      "category": "enumeration",
      "command": "john --show <HASH_FILE>",
      "description": "Display previously cracked passwords from john.pot",
      "tags": [
        "JOHN",
        "JTR",
        "RESULTS",
        "OUTPUT",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "Original hash file",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--show": "Show cracked - Display passwords from ~/.john/john.pot (persistent storage). JtR automatically saves cracked hashes. Format: username:password or hash:password. Use for: 1) Viewing results 2) Extracting passwords for documentation 3) Checking crack status."
      },
      "success_indicators": [
        "username:password",
        "X password hash cracked, Y left"
      ],
      "notes": "REQUIREMENT:\nDocument all cracked passwords.\n\nAlways run --show after successful crack.\n\nJtR saves to ~/.john/john.pot permanently.\n\nCombine with --format if needed:\njohn --show --format=raw-md5 hashes.txt",
      "prerequisites": [
        "john-wordlist-attack"
      ],
      "alternatives": [
        "hashcat-show-cracked"
      ],
      "next_steps": [
        "crackmapexec-validate-admin",
        "evil-winrm-shell",
        "ssh-login-password"
      ],
      "filled_example": "john --show hashes.txt"
    },
    {
      "id": "john-ssh-key-crack",
      "name": "Crack SSH Private Key Passphrase",
      "category": "enumeration",
      "command": "john --wordlist=<WORDLIST> --rules=<RULESET> <SSH_HASH>",
      "description": "Crack SSH private key passphrase (supports all ciphers)",
      "tags": [
        "JOHN",
        "JTR",
        "SSH",
        "PRIVATE_KEY",
        "PASSPHRASE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "custom_wordlist.txt",
          "required": true
        },
        {
          "name": "<RULESET>",
          "description": "Rule name from john.conf",
          "example": "sshRules",
          "required": true
        },
        {
          "name": "<SSH_HASH>",
          "description": "SSH key hash file (from ssh2john)",
          "example": "ssh.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "SSH format": "John automatically detects SSH format from ssh2john output. Supports ALL SSH ciphers including aes-256-ctr (which Hashcat does NOT support). No --format flag needed for ssh2john output."
      },
      "success_indicators": [
        "Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH])",
        "PASSPHRASE (key)"
      ],
      "prerequisites": [
        "ssh2john-extract"
      ],
      "alternatives": [
        "hashcat-ssh-key-crack"
      ],
      "next_steps": [
        "john-show-cracked",
        "ssh-connect-password"
      ],
      "notes": "PRACTICAL TIP:\nJtR supports MORE SSH ciphers than Hashcat.\n\nUse JtR for SSH keys (especially modern keys with aes-256-ctr).\n\nExtract hash:\nssh2john id_rsa > ssh.hash.\n\nBuild custom wordlist from user information (notes.txt, common words, dates).\n\nApply rules based on password policy.",
      "filled_example": "john --wordlist=custom_wordlist.txt --rules=sshRules ssh.hash"
    },
    {
      "id": "john-keepass-crack",
      "name": "Crack KeePass Database",
      "category": "enumeration",
      "command": "john --wordlist=<WORDLIST> --rules=<RULESET> <KEEPASS_HASH>",
      "description": "Crack KeePass master password",
      "tags": [
        "JOHN",
        "JTR",
        "KEEPASS",
        "PASSWORD_MANAGER",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULESET>",
          "description": "Rule name",
          "example": "sshRules",
          "required": true
        },
        {
          "name": "<KEEPASS_HASH>",
          "description": "KeePass hash file (from keepass2john)",
          "example": "keepass.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "KeePass format": "John auto-detects KeePass format from keepass2john output. Supports KeePass 1.x and 2.x. CPU-based cracking often comparable to GPU for KeePass (slow algorithm by design)."
      },
      "success_indicators": [
        "Loaded 1 password hash (KeePass [SHA256 AES])",
        "PASSWORD (Database)"
      ],
      "prerequisites": [
        "keepass2john-extract"
      ],
      "alternatives": [
        "hashcat-keepass-crack"
      ],
      "next_steps": [
        "john-show-cracked",
        "ssh-login-password",
        "evil-winrm-shell"
      ],
      "notes": "Extract hash:\nkeepass2john Database.kdbx > keepass.hash.\n\nRemove 'Database:' prefix.\n\nKeePass uses slow KDF - focused wordlists essential.\n\nUser password patterns critical (reuse with policy modifications).",
      "filled_example": "john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules keepass.hash"
    },
    {
      "id": "john-incremental-mode",
      "name": "John Incremental Mode (Brute-Force)",
      "category": "enumeration",
      "command": "john --incremental <HASH_FILE>",
      "description": "Brute-force attack with intelligent character frequency",
      "tags": [
        "JOHN",
        "JTR",
        "INCREMENTAL",
        "BRUTE_FORCE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--incremental": "Incremental mode - Brute-force with character frequency analysis. NOT pure brute-force - uses statistical model based on common passwords. Tries likely character combinations first (e \u2192 a \u2192 o vs rare combos). Modes: ASCII (all printable), Alnum (alphanumeric), Digits (numbers only), LowerNum, UpperNum. Specify: --incremental=Digits. Very slow - use as last resort."
      },
      "success_indicators": [
        "Proceeding with incremental mode",
        "guesses: X"
      ],
      "notes": "Last resort attack - extremely slow.\n\nUse only when:\n1) No wordlist success 2) Short password suspected 3) Fast hash (MD5, NTLM).\n\nNOT viable for pentest time constraints unless very short password (<6 chars).",
      "prerequisites": [
        "john-wordlist-attack",
        "john-rules-attack"
      ],
      "alternatives": [
        "hashcat-increment",
        "hashcat-mask-attack"
      ],
      "next_steps": [
        "john-show-cracked"
      ],
      "filled_example": "john --incremental hashes.txt"
    },
    {
      "id": "john-status",
      "name": "John Show Status",
      "category": "enumeration",
      "command": "john --status",
      "description": "Display status of running/paused cracking session",
      "tags": [
        "JOHN",
        "JTR",
        "STATUS",
        "PROGRESS",
        "HASH_CRACKING"
      ],
      "variables": [],
      "flag_explanations": {
        "--status": "Status display - Show progress of current/last session. Information: Time running, Progress %, Passwords tested, Guesses (cracked), Current word, ETA. Use to monitor long-running attacks. Press any key during run to see status without --status flag."
      },
      "success_indicators": [
        "Session..........: ",
        "Progress.........: ",
        "Time running.....: "
      ],
      "notes": "Monitor long attacks:\njohn --status.\n\nDuring active session, press any key for instant status update (no need for separate command).\n\nCritical for pentest time management - check ETA regularly."
    },
    {
      "id": "john-restore-session",
      "name": "John Restore Session",
      "category": "enumeration",
      "command": "john --restore",
      "description": "Resume previously interrupted cracking session",
      "tags": [
        "JOHN",
        "JTR",
        "RESTORE",
        "SESSION",
        "HASH_CRACKING"
      ],
      "variables": [],
      "flag_explanations": {
        "--restore": "Restore session - Resume from last checkpoint. JtR auto-saves progress to ~/.john/john.rec. Restore after: Ctrl+C, crash, reboot. Continues from exact position. All parameters restored automatically (no need to specify wordlist, rules, etc.)."
      },
      "success_indicators": [
        "Restored session",
        "Proceeding with <mode>"
      ],
      "failure_indicators": [
        "No session file found"
      ],
      "notes": "JtR auto-saves to ~/.john/john.rec.\n\nResume with:\njohn --restore.\n\nUseful for multi-hour attacks interrupted by network issues or intentional pause.\n\nSession file cleared after successful completion."
    },
    {
      "id": "john-list-formats",
      "name": "List All Supported Formats",
      "category": "enumeration",
      "command": "john --list=formats | grep -i <SEARCH>",
      "description": "List all hash formats supported by John",
      "tags": [
        "JOHN",
        "JTR",
        "FORMATS",
        "REFERENCE",
        "HASH_CRACKING"
      ],
      "variables": [
        {
          "name": "<SEARCH>",
          "description": "Optional search term to filter formats",
          "example": "ssh",
          "required": false
        }
      ],
      "flag_explanations": {
        "--list=formats": "List formats - Display all supported hash types. Use grep to filter (john --list=formats | grep -i md5). Common prefixes: raw- (simple hashes), dynamic- (complex formats), crypt- (Unix crypt variants). Hundreds of formats supported."
      },
      "success_indicators": [
        "descrypt",
        "raw-md5",
        "nt"
      ],
      "notes": "Reference command - find correct format name.\n\nExamples:\nraw-md5, raw-sha256, nt (NTLM), bcrypt, SSH, KeePass.\n\nGrep for hash type:\njohn --list=formats | grep -i keepass",
      "filled_example": "john --list=formats | grep -i ssh"
    },
    {
      "id": "john-add-custom-rules",
      "name": "Add Custom Rules to john.conf",
      "category": "enumeration",
      "command": "sudo sh -c 'cat <RULE_FILE> >> /etc/john/john.conf'",
      "description": "Append custom rules to John configuration",
      "tags": [
        "JOHN",
        "JTR",
        "RULES",
        "CUSTOM",
        "CONFIG"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "File containing custom rules with [List.Rules:Name] header",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "Rule format": "Rules must start with [List.Rules:RuleName] header, then one rule per line. Rule syntax: c=capitalize, $X=append X, ^X=prepend X, d=duplicate, r=reverse, etc. See /etc/john/john.conf for examples. Reference: john --list=rules"
      },
      "success_indicators": [
        "File appended successfully"
      ],
      "prerequisites": [
        "john-test-rules"
      ],
      "notes": "PRACTICAL TIP:\nCreate custom rules based on password policy.\n\nExample:\nPolicy requires capital + 3 digits + special \u2192 Rules:\nc $1 $3 $7 $!, c $1 $2 $3 $!.\n\nFormat:\n[List.Rules:sshRules] then c $1 $3 $7 $!.\n\nTest first:\necho 'password' > test.txt && john --wordlist=test.txt --rules=sshRules --stdout (verify mutations).",
      "filled_example": "sudo sh -c 'cat custom.rule >> /etc/john/john.conf'"
    }
  ]
}