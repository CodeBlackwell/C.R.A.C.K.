{
  "category": "enumeration",
  "description": "Active Directory enumeration using manual PowerShell LDAP queries with .NET classes (no PowerView dependency)",
  "commands": [
    {
      "id": "ps-get-current-domain",
      "name": "Get Current Domain (PowerShell)",
      "category": "enumeration",
      "command": "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()",
      "description": "Retrieve current AD domain information including forest, domain controllers, and PDC role owner using .NET Framework",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        ".NET",
        "DOMAIN",
        "STARTER"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Forest",
        "DomainControllers",
        "PdcRoleOwner",
        "Name"
      ],
      "failure_indicators": [
        "Exception calling",
        "Cannot find type",
        "Access is denied"
      ],
      "next_steps": [
        "ps-get-pdc",
        "ps-build-ldap-path"
      ],
      "alternatives": [
        "get-netdomain"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "Cannot find type": "PowerShell version too old. Use PowerShell 3.0+. Check version: $PSVersionTable",
        "Access is denied": "Not logged in with domain account. Verify: whoami /fqdn"
      },
      "notes": ".NET SYSTEM.DIRECTORYSERVICES:\nAvailable in PowerShell by default (no imports needed).\n\nCOMMAND:\n  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()\n\nRETURNS:\n- PdcRoleOwner:\nPrimary DC for enumeration\n- DomainControllers:\nAll DCs in domain\n- Forest:\nMulti-domain environments\n- Name:\nDomain DNS name\n\nADVANTAGE:\nNo PowerView or special tools required.\nWorks on any domain-joined Windows machine with PowerShell.\n\nALTERNATIVE:\n  $env:userdnsdomain\n\nTime:\n<5 seconds",
      "methodology_guidance": {
        "after_success": "Extract domain name from Name property Extract PDC from PdcRoleOwner property"
      }
    },
    {
      "id": "ps-get-pdc",
      "name": "Get Primary Domain Controller (PowerShell)",
      "category": "enumeration",
      "command": "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name",
      "description": "Extract the Primary Domain Controller hostname - the most authoritative DC for LDAP queries",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        ".NET",
        "DOMAIN_CONTROLLER"
      ],
      "variables": [],
      "flag_explanations": {
        ".PdcRoleOwner.Name": "Accesses the PdcRoleOwner property (which DC holds PDC role) and extracts its Name (hostname). PDC is the most up-to-date DC - use this for enumeration to ensure accurate results."
      },
      "success_indicators": [
        ".corp.com",
        "DC name in FQDN format"
      ],
      "failure_indicators": [
        "Exception calling",
        "Property 'PdcRoleOwner' cannot be found"
      ],
      "next_steps": [
        "ps-build-ldap-path"
      ],
      "alternatives": [
        "net-domain-controllers"
      ],
      "prerequisites": [
        "ps-get-current-domain"
      ],
      "troubleshooting": {
        "Property cannot be found": "Domain object not populated. Run full command: [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() first"
      },
      "notes": "WHY TARGET THE PDC:\n- Most authoritative and up-to-date AD data\n- Only ONE PDC per domain\n- Non-PDC DCs may have stale replication data\n\nCOMMAND:\n  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name\n\nUSAGE:\nStore in variable:\n  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name\n\npractical:\nUse this to build LDAP path for DirectorySearcher queries.\n\nTime:\n<5 seconds",
      "methodology_guidance": {
        "after_success": "Use PDC hostname in LDAP connection string Store in variable: $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name"
      }
    },
    {
      "id": "ps-get-distinguished-name",
      "name": "Get Domain Distinguished Name (PowerShell)",
      "category": "enumeration",
      "command": "([adsi]'').distinguishedName",
      "description": "Retrieve the domain's Distinguished Name in LDAP format (DC=corp,DC=com)",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        "ADSI"
      ],
      "variables": [],
      "flag_explanations": {
        "[adsi]''": "ADSI (Active Directory Service Interfaces) accelerator. Empty string queries the root of the AD hierarchy (the domain itself).",
        ".distinguishedName": "Returns the DN (Distinguished Name) - LDAP-formatted path to the domain object. Format: DC=domain,DC=tld."
      },
      "success_indicators": [
        "DC=",
        "Distinguished Name in LDAP format"
      ],
      "failure_indicators": [
        "Exception calling",
        "Unable to contact the server"
      ],
      "next_steps": [
        "ps-build-ldap-path"
      ],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "Unable to contact the server": "Not logged in to domain or DC unreachable. Verify: whoami /fqdn"
      },
      "notes": "DISTINGUISHED NAMES (DN):\nUnique identifiers in LDAP.\n\nFORMAT:\nCN=name,OU=container,DC=domain,DC=tld\n\nREAD RIGHT-TO-LEFT:\n- DC components:\nDomain (top of hierarchy)\n- OU/CN components:\nLocation within domain\n\nEXAMPLE:\nDomain 'corp.com' \u2192 DN is 'DC=corp,DC=com'\n\nCOMMAND:\n  ([adsi]'').distinguishedName\n\npractical:\nRequired for building LDAP connection strings.\n\nTime:\n<5 seconds",
      "methodology_guidance": {
        "after_success": "Store in variable: $DN = ([adsi]'').distinguishedName Use in LDAP path: LDAP://<PDC>/$DN"
      }
    },
    {
      "id": "ps-build-ldap-path",
      "name": "Build Complete LDAP Path (PowerShell)",
      "category": "enumeration",
      "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $LDAP",
      "description": "Construct full LDAP path for DirectorySearcher queries by combining PDC hostname and Distinguished Name",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "LDAP://",
        "DC=",
        "Full LDAP path format"
      ],
      "failure_indicators": [
        "Exception",
        "Variable is null"
      ],
      "next_steps": [
        "ps-directorysearcher-users"
      ],
      "alternatives": [],
      "prerequisites": [
        "ps-get-pdc",
        "ps-get-distinguished-name"
      ],
      "troubleshooting": {
        "LDAP path incomplete": "Check variables populated: echo $PDC; echo $DN",
        "Query fails with invalid path": "Verify DC reachable: ping $PDC"
      },
      "notes": "LDAP PATH FORMAT:\nLDAP://HostName/DistinguishedName\n\nCOMPONENTS:\n- HostName:\nPDC for accuracy\n- DistinguishedName:\nDomain DN (searchbase)\n\nTELLS DIRECTORYSEARCHER:\n- WHERE to search:\nPDC\n- WHAT to search:\nEntire domain from root\n\nCOMMAND:\n  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name\n  $DN = ([adsi]'').distinguishedName\n  $LDAP = \"LDAP://$PDC/$DN\"\n  $LDAP\n\npractical:\nFoundation for all manual LDAP enumeration.\nMemorize this pattern.\n\nTime:\n5-10 seconds",
      "methodology_guidance": {
        "after_success": "Use in DirectoryEntry: New-Object System.DirectoryServices.DirectoryEntry($LDAP) Use in DirectorySearcher queries"
      }
    },
    {
      "id": "ps-directorysearcher-users",
      "name": "Enumerate Users with DirectorySearcher (PowerShell)",
      "category": "enumeration",
      "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"samAccountType=805306368\"; $dirsearcher.FindAll()",
      "description": "Search Active Directory for all user objects using DirectorySearcher .NET class with LDAP filter",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        ".NET",
        "USERS"
      ],
      "variables": [],
      "flag_explanations": {
        "DirectoryEntry": "Encapsulates an AD object (the domain root in this case). Provides the LDAP connection for queries.",
        "DirectorySearcher": "Performs LDAP queries against AD. Requires DirectoryEntry as searchbase.",
        "filter": "LDAP filter syntax. samAccountType=805306368 filters for normal user accounts (decimal value for 0x30000000).",
        "FindAll()": "Executes the search and returns ALL matching objects (all users in this case)."
      },
      "success_indicators": [
        "Path",
        "Properties",
        "LDAP://",
        "CN=Users"
      ],
      "failure_indicators": [
        "Exception",
        "Access Denied",
        "Cannot find type"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netuser"
      ],
      "prerequisites": [
        "ps-build-ldap-path"
      ],
      "troubleshooting": {
        "No results": "LDAP filter may be wrong. Test without filter: $dirsearcher.filter=\"objectClass=user\"; $dirsearcher.FindAll()",
        "Too much output": "Filter specific attributes: $obj.Properties | select samaccountname,description"
      },
      "notes": "SAMACCOUNTTYPE VALUES:\n- 805306368:\nUsers\n- 805306369:\nComputers  \n- 268435456:\nGroups\n\nLDAP FILTER SYNTAX:\n- (attribute=value):\nEquality\n- (attribute=*value*):\nWildcards\n- (&(filter1)(filter2)):\nAND\n- (|(filter1)(filter2)):\nOR\n\nOUTPUT:\nContains ALL user attributes.\nPipe to select for clean output:\n  | ForEach-Object {$_.Properties.samaccountname}\n\npractical:\nPowerView-free enumeration.\nWorks in restricted environments where imports blocked.\n\nTime:\n10-30 seconds",
      "methodology_guidance": {
        "after_success": "Parse output: $result = $dirsearcher.FindAll(); foreach($obj in $result){$obj.Properties} Filter properties: $obj.Properties.samaccountname Extract specific users: $dirsearcher.filter=\"name=administrator\""
      }
    },
    {
      "id": "ps-directorysearcher-groups",
      "name": "Enumerate Groups with DirectorySearcher (PowerShell)",
      "category": "enumeration",
      "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"objectClass=group\"; $result = $dirsearcher.FindAll(); foreach($group in $result){$group.properties | select {$_.cn},{$_.member}}",
      "description": "Search Active Directory for all group objects and display group names with members",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        ".NET",
        "GROUPS"
      ],
      "variables": [],
      "flag_explanations": {
        "objectClass=group": "LDAP filter for group objects. More inclusive than samAccountType - returns all group types (security groups, distribution groups, domain local, global, universal).",
        "foreach loop": "Iterates through each group object in results.",
        "select {$_.cn},{$_.member}": "Extracts Common Name (group name) and member attribute (group members)."
      },
      "success_indicators": [
        "Domain Admins",
        "Enterprise Admins",
        "CN=",
        "Group members listed"
      ],
      "failure_indicators": [
        "Exception",
        "No results",
        "Access Denied"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netgroup"
      ],
      "prerequisites": [
        "ps-build-ldap-path"
      ],
      "troubleshooting": {
        "Nested groups not showing users": "Member attribute shows distinguished names. CN=user is a user, CN=group,CN=Users is a nested group. Query nested group separately.",
        "Output format messy": "Use select-object: $group.properties.member | Format-List"
      },
      "notes": "GROUP MEMBER ATTRIBUTE:\nContains distinguished names (DNs).\n\nFORMAT:\n- Users:\nCN=username,CN=Users,DC=corp,DC=com\n- Nested groups:\nCN=groupname,CN=Users,DC=corp,DC=com\n\nNESTED GROUP DETECTION:\nIf member DN contains 'CN=Users' or 'OU=' \u2192 likely a group.\nEnumerate recursively to find all users.\n\nTARGETS:\nLook for groups with 'Admin', 'IT', 'Service' in CN.\nOften have elevated privileges.\n\nTime:\n10-30 seconds",
      "methodology_guidance": {
        "after_success": "Filter specific group: $dirsearcher.filter=\"(&(objectClass=group)(cn=Domain Admins))\" Check for nested groups in member attribute (starts with CN=) Enumerate nested groups recursively"
      }
    },
    {
      "id": "ps-directorysearcher-computers",
      "name": "Enumerate Computers with DirectorySearcher (PowerShell)",
      "category": "enumeration",
      "command": "$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = \"LDAP://$PDC/$DN\"; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=\"samAccountType=805306369\"; $result = $dirsearcher.FindAll(); foreach($computer in $result){$computer.properties | select {$_.cn},{$_.operatingsystem},{$_.dnshostname}}",
      "description": "Search Active Directory for all computer objects and display hostnames with operating systems",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        ".NET",
        "COMPUTERS"
      ],
      "variables": [],
      "flag_explanations": {
        "samAccountType=805306369": "LDAP filter for computer objects (decimal for 0x30000001). Matches domain-joined workstations, servers, and domain controllers.",
        "{$_.cn}": "Common Name - computer hostname without domain suffix.",
        "{$_.operatingsystem}": "OS version (Windows 10, Windows Server 2019, etc.) - useful for targeting legacy systems.",
        "{$_.dnshostname}": "Fully qualified domain name (hostname.domain.com) - use this for network connections."
      },
      "success_indicators": [
        "Windows",
        "operatingsystem",
        "dnshostname",
        "Computer hostnames"
      ],
      "failure_indicators": [
        "Exception",
        "No results",
        "Access Denied"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netcomputer",
        "dsquery-computer"
      ],
      "prerequisites": [
        "ps-build-ldap-path"
      ],
      "troubleshooting": {
        "Operating system field empty": "Some computer objects don't have OS populated. Check other attributes: $computer.properties",
        "DC not showing": "Use userAccountControl filter for DCs. Flag 8192 = Domain Controller."
      },
      "notes": "COMPUTER OBJECTS:\nReveal network topology without port scanning.\n\nKEY ATTRIBUTES:\n- operatingsystem:\nIdentify legacy systems (Windows 7, Server 2008)\n- operatingsystemversion:\nExact build number\n- lastLogon:\nActive vs dormant computers\n- dnshostname:\nFQDN for connections\n\nTARGETS:\nFocus on legacy OS versions and servers.\nHigher chance of unpatched vulnerabilities.\n\nTime:\n10-30 seconds",
      "methodology_guidance": {
        "after_success": "Target legacy OS: $dirsearcher.filter=\"(&(samAccountType=805306369)(operatingSystem=*Server 2008*))\"; $dirsearcher.FindAll() Identify DCs: $dirsearcher.filter=\"(&(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=8192))\"; $dirsearcher.FindAll() Ping reachable hosts: foreach($computer in $result){Test-Connection -ComputerName $computer.properties.dnshostname -Count 1 -Quiet}"
      }
    },
    {
      "id": "ps-ldapsearch-function",
      "name": "Reusable LDAP Search Function (PowerShell)",
      "category": "enumeration",
      "command": "function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\"LDAP://$PDC/$DistinguishedName\"); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }",
      "description": "Create reusable PowerShell function for LDAP queries - accepts LDAP filter as parameter",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "POWERSHELL",
        "LDAP",
        "FUNCTION",
        "REUSABLE"
      ],
      "variables": [],
      "flag_explanations": {
        "param ([string]$LDAPQuery)": "Function parameter - accepts LDAP filter string from command line",
        "return $DirectorySearcher.FindAll()": "Returns all matching AD objects for the provided filter"
      },
      "success_indicators": [
        "Function created successfully",
        "Import-Module completes",
        "LDAPSearch command available"
      ],
      "failure_indicators": [
        "Syntax error",
        "Function not recognized"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [
        "ps-build-ldap-path",
        "ps-directorysearcher-users"
      ],
      "troubleshooting": {
        "Function not found": "Import module first: Import-Module .\\LDAPSearch.ps1",
        "LDAP query syntax error": "Test filter manually first with DirectorySearcher",
        "No results": "Verify LDAP filter syntax. Common filters: (objectClass=user), (objectCategory=group), (samAccountType=805306368)"
      },
      "notes": "REUSABLE LDAP FUNCTION:\nEncapsulates all previous LDAP steps.\n\nUSAGE EXAMPLES:\n- Users:\nLDAPSearch \"(samAccountType=805306368)\"\n- Groups:\nLDAPSearch \"(objectCategory=group)\"\n- Kerberoastable:\nLDAPSearch \"(&(objectCategory=user)(servicePrincipalName=*))\"\n\nWORKFLOW:\n1.\n\nSave function to file:\nfunction | Out-File LDAPSearch.ps1\n\n2.\n\nImport at start:\nImport-Module .\\LDAPSearch.ps1\n\n3.\n\nUse throughout enumeration\n\nADVANTAGE:\nPowerView-free, exam-safe enumeration.\nEliminates repetitive typing.\n\nTime:\nFunction creation 10 seconds, usage <5 seconds",
      "methodology_guidance": {
        "after_success": "Save to file: function | Out-File LDAPSearch.ps1 Import: Import-Module .\\LDAPSearch.ps1 Use: LDAPSearch -LDAPQuery \"(samAccountType=805306368)\" Filter users: LDAPSearch -LDAPQuery \"(&(objectCategory=user)(adminCount=1))\" Filter groups: LDAPSearch -LDAPQuery \"(objectCategory=group)\" | select -ExpandProperty Properties | select cn,member"
      }
    },
    {
      "id": "ps-ldapsearch-users",
      "name": "LDAP Query All Users (PowerShell)",
      "category": "enumeration",
      "command": "LDAPSearch -LDAPQuery \"(objectClass=user)\"",
      "description": "Query all user objects using manual LDAP search function",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "USERS",
        "LDAP",
        "POWERSHELL"
      ],
      "variables": [],
      "flag_explanations": {
        "(objectClass=user)": "LDAP filter matching all user objects. Returns both user accounts and computer accounts (computers inherit from user class)."
      },
      "success_indicators": [
        "Properties",
        "samaccountname",
        "distinguishedname"
      ],
      "failure_indicators": [
        "Function not defined",
        "Access denied",
        "Cannot contact domain"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netuser"
      ],
      "prerequisites": [
        "ps-ldapsearch-function"
      ],
      "troubleshooting": {
        "Function not defined": "Create LDAPSearch function first: ps-ldapsearch-function",
        "Returns computer accounts": "Filter computers: (&(objectClass=user)(!(objectClass=computer)))"
      },
      "notes": "REQUIRES:\nLDAPSearch function defined first.\n\nRETURNS:\nUser AND computer objects (computers inherit from user class).\n\nFILTER COMPUTERS:\n- LDAP:\n(&(objectClass=user)(!(objectClass=computer)))\n- PowerShell:\n| ? {$_.Properties.samaccountname -notmatch '\\$$'}\n\nTime:\n<10 seconds",
      "methodology_guidance": {
        "after_success": "Filter results: LDAPSearch -LDAPQuery \"(&(objectClass=user)(!(objectClass=computer)))\""
      }
    },
    {
      "id": "ps-ldapsearch-computers",
      "name": "LDAP Query All Computers (PowerShell)",
      "category": "enumeration",
      "command": "LDAPSearch -LDAPQuery \"(objectClass=computer)\"",
      "description": "Query all computer objects in the domain",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "COMPUTERS",
        "LDAP",
        "POWERSHELL"
      ],
      "variables": [],
      "flag_explanations": {
        "(objectClass=computer)": "LDAP filter matching computer accounts. Computer SAM names end with $."
      },
      "success_indicators": [
        "dnshostname",
        "operatingsystem"
      ],
      "failure_indicators": [
        "Function not defined"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netcomputer"
      ],
      "prerequisites": [
        "ps-ldapsearch-function"
      ],
      "troubleshooting": {},
      "notes": "QUERY ALL COMPUTERS:\nRETURNS:\n- DNS hostname\n- OS version\n- Last logon\n- Operating system details\n\nUSAGE:\n  LDAPSearch -LDAPQuery \"(objectClass=computer)\" | select -ExpandProperty Properties | select dnshostname,operatingsystem\n\nTime:\n<10 seconds",
      "methodology_guidance": {
        "after_success": "Check OS versions: | select -ExpandProperty Properties | select dnshostname,operatingsystem"
      }
    },
    {
      "id": "ps-ldapsearch-groups",
      "name": "LDAP Query All Groups (PowerShell)",
      "category": "enumeration",
      "command": "LDAPSearch -LDAPQuery \"(objectClass=group)\"",
      "description": "Query all group objects in the domain",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "GROUPS",
        "LDAP",
        "POWERSHELL"
      ],
      "variables": [],
      "flag_explanations": {
        "(objectClass=group)": "LDAP filter for group objects. Includes security and distribution groups."
      },
      "success_indicators": [
        "cn",
        "member"
      ],
      "failure_indicators": [
        "Function not defined"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netgroup"
      ],
      "prerequisites": [
        "ps-ldapsearch-function"
      ],
      "troubleshooting": {},
      "notes": "QUERY ALL GROUPS:\nFOCUS ON:\n- Domain Admins\n- Enterprise Admins\n- Administrators\n- Custom admin groups\n\nGET MEMBERS:\n  $group.Properties.member\n\nTime:\n<10 seconds",
      "methodology_guidance": {
        "after_success": "Get group members: $group.Properties.member"
      }
    },
    {
      "id": "ps-ldapsearch-spns",
      "name": "LDAP Query Kerberoastable Accounts (PowerShell)",
      "category": "enumeration",
      "command": "LDAPSearch -LDAPQuery \"(&(objectClass=user)(servicePrincipalName=*))\"",
      "description": "Query all user accounts with SPNs registered (Kerberoastable)",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "SPN",
        "KERBEROASTING",
        "LDAP",
        "POWERSHELL"
      ],
      "variables": [],
      "flag_explanations": {
        "(&(objectClass=user)(servicePrincipalName=*))": "Compound LDAP filter: user objects AND has SPN attribute. The & means AND, * means any value."
      },
      "success_indicators": [
        "serviceprincipalname",
        "samaccountname"
      ],
      "failure_indicators": [
        "Function not defined",
        "No results"
      ],
      "next_steps": [],
      "alternatives": [
        "get-netuser"
      ],
      "prerequisites": [
        "ps-ldapsearch-function"
      ],
      "troubleshooting": {
        "No results": "No SPNs registered. Try PowerView: Get-NetUser -SPN"
      },
      "notes": "KERBEROASTING TARGETS:\nQUERY:\n  LDAPSearch -LDAPQuery \"(&(objectClass=user)(servicePrincipalName=*))\"\n\nWHY THIS MATTERS:\nUser accounts with SPNs \u2192 can request TGS tickets.\nTGS encrypted with service account password hash.\nCrack offline, no account lockout.\n\nNEXT STEPS:\n- Request TGS tickets\n- Extract with Rubeus/Mimikatz\n- Crack with hashcat\n\nTime:\n<10 seconds",
      "methodology_guidance": {
        "after_success": "Request TGS tickets for discovered accounts"
      }
    },
    {
      "id": "ps-ldapsearch-admins",
      "name": "LDAP Query Privileged Accounts (PowerShell)",
      "category": "enumeration",
      "command": "LDAPSearch -LDAPQuery \"(adminCount=1)\"",
      "description": "Query all accounts with adminCount=1 (privileged accounts)",
      "tags": [
        "ACTIVE_DIRECTORY",
        "ENUMERATION",
        "PRIVILEGED_ACCOUNTS",
        "LDAP",
        "POWERSHELL"
      ],
      "variables": [],
      "flag_explanations": {
        "(adminCount=1)": "Identifies accounts protected by AdminSDHolder. These are privileged accounts (Domain Admins, Enterprise Admins, etc.). AdminSDHolder sets inheritance flag and ACLs hourly."
      },
      "success_indicators": [
        "adminCount",
        "samaccountname"
      ],
      "failure_indicators": [
        "Function not defined"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [
        "ps-ldapsearch-function"
      ],
      "troubleshooting": {},
      "notes": "ADMINCOUNT ATTRIBUTE:\nQUERY:\n  LDAPSearch -LDAPQuery \"(adminCount=1)\"\n\nWHAT IT MEANS:\nAccount is/was in privileged group.\n\nADMINSDHOLDER PROCESS:\nSets this flag on:\n- Domain Admins\n- Enterprise Admins  \n- Account Operators\n- Backup Operators\n- Server Operators\n- Other high-privilege groups\n\npractical:\nIdentify privileged accounts for targeting.\n\nTime:\n<10 seconds",
      "methodology_guidance": {
        "after_success": "Check group membership for discovered accounts"
      }
    }
  ]
}