{
  "category": "monitoring",
  "subcategory": "linux-process-monitoring",
  "description": "Linux process and service monitoring commands for enumeration and privilege escalation",
  "commands": [
    {
      "id": "systemctl-list",
      "name": "List Systemd Services",
      "category": "monitoring",
      "subcategory": "linux-process-monitoring",
      "command": "systemctl list-units --type=service --state=<STATE>",
      "description": "List systemd services filtered by state. Essential for discovering running services, identifying attack surface, and finding privilege escalation vectors through writable service files.",
      "variables": [
        {
          "name": "<STATE>",
          "description": "Service state to filter by",
          "example": "running",
          "required": false,
          "common_values": [
            "running",
            "failed",
            "active",
            "inactive",
            "all"
          ]
        }
      ],
      "flag_explanations": {
        "--type=service": "Filter to show only service units (not timers, sockets, etc). Critical for focusing on exploitable services. in assessments, service units often run as root and may have writable configuration files or exploitable binaries.",
        "--state=<STATE>": "Filter by service state (running/failed/active/inactive/all). Use 'running' to find active attack surface. Use 'failed' to identify misconfigured services that might reveal privilege escalation paths. Use 'all' for comprehensive enumeration.",
        "--all": "Show all units regardless of state. Reveals disabled services that might be exploitable if you can enable them. More verbose than --state=all.",
        "--no-pager": "Output results directly to terminal without using the pager (less). Essential when output is being piped to grep or redirected to a file. Always use in automated scripts.",
        "--failed": "Shortcut for --state=failed. Quick way to identify broken services that might reveal misconfigurations or permission issues exploitable for privilege escalation."
      },
      "success_indicators": [
        "List of services with UNIT, LOAD, ACTIVE, SUB, DESCRIPTION columns",
        "Services ending in .service extension",
        "State indicators: loaded, active (running), enabled",
        "Number of loaded units shown at bottom"
      ],
      "failure_indicators": [
        "Failed to connect to bus: No such file or directory (not systemd-based)",
        "Permission denied (rare - systemctl list-units usually allowed for all users)",
        "Unknown unit type 'service' (wrong systemd version)",
        "Empty output with 0 loaded units (rare - indicates no services)"
      ],
      "troubleshooting": {
        "No services listed": "Verify systemd is the init system with 'ps -p 1'. Some systems use SysVinit (check /etc/init.d/). Use 'service --status-all' as alternative on SysVinit systems.",
        "Permission denied errors": "systemctl list-units should work for all users. If denied, system may have custom security module (AppArmor/SELinux). Try 'systemctl list-units --user' to list user services.",
        "Failed to connect to bus": "System not using systemd. Check init system with 'ps -p 1 -o comm='. On SysVinit, use 'chkconfig --list' (RHEL/CentOS) or 'service --status-all' (Debian/Ubuntu).",
        "Output truncated or using pager": "Add --no-pager flag to prevent paging: 'systemctl list-units --type=service --no-pager'. Essential when piping to grep or redirecting to file."
      },
      "prerequisites": [],
      "alternatives": [
        "service-status-all-sysv"
      ],
      "next_steps": [
        "systemctl-running-services",
        "linux-writable-services"
      ],
      "tags": [
        "LINUX",
        "ENUMERATION",
        "PRIVILEGE_ESCALATION",
        "SYSTEMD",
        "SERVICE_ENUMERATION"
      ],
      "notes": "**METHODOLOGY - Service Enumeration for PrivEsc:**\n\n**1. WHY This Command (Context):**\nSystemd services often run as root and are prime targets for privilege escalation. Writable service files, exploitable binaries, or PATH hijacking in service ExecStart directives can lead to root shells. This command is the first step in service-based privilege escalation methodology.\n\n**2. MANUAL ALTERNATIVES (No Tool Available):**\n- SysVinit systems: `ls -la /etc/init.d/` and `service --status-all`\n- Read systemd unit files directly: `ls -la /etc/systemd/system/*.service`\n- Check service status: `ps aux | grep <service_name>`\n- Alternative init systems: `chkconfig --list` (RHEL/CentOS), `update-rc.d` (Debian)\n\n**3. WORKFLOW (Typical Usage):**\n```bash\n# Step 1: List all running services\nsystemctl list-units --type=service --state=running --no-pager\n\n# Step 2: List failed services (often reveal misconfigurations)\nsystemctl list-units --type=service --state=failed --no-pager\n\n# Step 3: Get detailed service info\nsystemctl status <service_name>\n\n# Step 4: Check service file permissions\nsystemctl show <service_name> -p FragmentPath --no-pager\nls -la $(systemctl show <service_name> -p FragmentPath --no-pager | cut -d= -f2)\n\n# Step 5: Read service configuration for ExecStart path\nsystemctl cat <service_name>\n\n# Step 6: Check if ExecStart binary is writable\nls -la /path/to/binary\n```\n\n**4. PRIVILEGE ESCALATION VECTORS:**\n- **Writable Service Files**: If you can write to /etc/systemd/system/<service>.service, modify ExecStart to run your payload as root\n- **Writable ExecStart Binary**: If the binary in ExecStart is writable, replace it with malicious code\n- **PATH Hijacking**: If ExecStart uses relative paths, exploit PATH variable to run your binary first\n- **Failed Services**: Services in failed state often reveal permission issues or missing dependencies you can exploit\n- **Timer Units**: Check for .timer units that run services - these might run as root on schedule\n\n**5. TIME ESTIMATES (Pentest):**\n- Initial enumeration: 2-5 minutes\n- Analyzing each interesting service: 3-5 minutes per service\n- Testing writable service files: 5-10 minutes\n- Full service-based privesc attempt: 15-30 minutes total\n\n**6. COMMON PITFALLS:**\n- Don't just list services - analyze each one. Check permissions, ExecStart binaries, and configuration files.\n- Failed services are gold - they often reveal misconfigurations you can exploit.\n- Always check service file permissions: `ls -la /etc/systemd/system/` and `/lib/systemd/system/`\n- Don't forget timer units: `systemctl list-timers --all` shows scheduled tasks\n\n**7. WHAT TO LOOK FOR (pentest Success Indicators):**\n- Services running as root with writable configuration files\n- ExecStart directives with writable binaries or relative paths\n- Services in failed state with permission denied errors\n- Custom services in /etc/systemd/system/ (more likely to have misconfigurations)\n- Services with EnvironmentFile directives pointing to writable files\n\n**8. ALTERNATIVE COMMANDS (Same Goal):**\n- `service --status-all` - SysVinit alternative, shows all services\n- `chkconfig --list` - RHEL/CentOS service listing\n- `ps aux | grep <service>` - Manual process verification\n- `ls /etc/systemd/system/*.service` - Direct file listing\n- `find / -name '*.service' -type f 2>/dev/null` - Find all service files\n\n**9. INTEGRATION WITH OTHER ENUM:**\nCombine with:\n- `linpeas.sh` or `linenum.sh` - Automated privilege escalation enumeration\n- `find / -writable -type f 2>/dev/null` - Find all writable files\n- `getcap -r / 2>/dev/null` - Check for capabilities\n- `sudo -l` - Check sudo permissions\n\n**CRITICAL PRACTICAL TIP**: Don't just run this command and move on. For EACH running service, check: (1) Service file permissions, (2) ExecStart binary permissions, (3) EnvironmentFile permissions, (4) User/Group the service runs as. One writable file = root shell.",
      "filled_example": "systemctl list-units --type=service --state=running"
    },
    {
      "id": "lsof-list",
      "name": "List Open Files and Network Connections",
      "category": "monitoring",
      "subcategory": "linux-process-monitoring",
      "command": "lsof -i <PROTOCOL>:<PORT> -n -P",
      "description": "List open files, network connections, and file descriptors. Critical for discovering internal services, active connections, unix sockets, and file locks that reveal privilege escalation vectors or lateral movement opportunities.",
      "variables": [
        {
          "name": "<PROTOCOL>",
          "description": "Network protocol to filter by",
          "example": "TCP",
          "required": false,
          "common_values": [
            "TCP",
            "UDP",
            ""
          ]
        },
        {
          "name": "<PORT>",
          "description": "Port number to filter by",
          "example": "8080",
          "required": false
        }
      ],
      "flag_explanations": {
        "-i": "List network connections (internet sockets). Without arguments, shows all IPv4/IPv6 connections. With <protocol>:<port>, filters to specific connections. Critical for discovering internal services not visible from nmap external scans (127.0.0.1 bindings).",
        "-i TCP:<port>": "Show only TCP connections on specific port. Essential for verifying if a service is listening locally (127.0.0.1) vs externally (0.0.0.0). Local-only services often have weaker security and no firewall protection.",
        "-i UDP:<port>": "Show only UDP connections on specific port. Useful for discovering DNS servers, SNMP agents, or custom UDP services. UDP services less commonly scanned = more likely to be vulnerable.",
        "-n": "Disable DNS resolution for hostnames. Shows raw IP addresses instead of hostnames. Essential in assessments - DNS lookups slow down enumeration and may reveal your presence in logs. Always use -n for speed.",
        "-P": "Disable port name resolution. Shows raw port numbers (3306) instead of names (mysql). Critical for accurate enumeration - you want exact ports, not service guesses. Always pair with -n.",
        "-u <user>": "Show only files/connections owned by specific user. Essential for privilege escalation - check what files root has open vs your current user. Files opened by root might be writable by you.",
        "-p <pid>": "Show only files/connections for specific process ID. Useful when you've identified an interesting process and want to see all its file descriptors, sockets, and connections.",
        "-c <command>": "Show files/connections for processes matching command name. Example: 'lsof -c apache' shows all files opened by apache processes. Useful for application-specific enumeration.",
        "+D <directory>": "List all open files under specific directory recursively. Critical for finding which processes are using files in sensitive directories like /tmp or /var. Can reveal lock files or IPC mechanisms.",
        "-U": "Show Unix domain sockets only. Unix sockets often used for local privilege escalation - processes communicate without network authentication. Look for sockets in /tmp or /var/run you can write to."
      },
      "success_indicators": [
        "COMMAND, PID, USER, FD, TYPE, DEVICE, SIZE/OFF, NODE, NAME columns",
        "Network connections show protocol (TCP/UDP), local address, foreign address, state",
        "File descriptors show file paths, permissions, inode numbers",
        "LISTEN state indicates services accepting connections"
      ],
      "failure_indicators": [
        "lsof: command not found (not installed - use alternatives)",
        "lsof: WARNING: can't stat() <filesystem> (permission issue or unmounted filesystem)",
        "Permission denied errors (normal for some files - lsof shows what you can access)",
        "No output (valid - might mean no matching connections/files)"
      ],
      "troubleshooting": {
        "lsof command not found": "lsof not installed. MANUAL ALTERNATIVES: (1) Check /proc/<pid>/fd/ to see file descriptors: 'ls -la /proc/*/fd/'. (2) Check listening ports: 'netstat -tulpn' or 'ss -tulpn'. (3) Check network connections: 'netstat -anp' or 'ss -anp'. (4) Install lsof if you have sudo: 'sudo apt install lsof' or 'sudo yum install lsof'.",
        "Permission denied on some files": "Normal behavior - lsof shows files accessible to your user. Run as root/sudo to see all files: 'sudo lsof'. in assessments, if you can't sudo, focus on files you CAN see - those might be your privilege escalation vector.",
        "Output too verbose": "Use filters: (1) Specific port: 'lsof -i :8080 -n -P'. (2) Specific user: 'lsof -u www-data'. (3) Specific process: 'lsof -p 1234'. (4) Network only: 'lsof -i -n -P'. (5) Pipe to grep: 'lsof -n -P | grep LISTEN'.",
        "Can't see internal services (127.0.0.1)": "From external scan you won't see localhost-bound services. Once you have shell access, run 'lsof -i -n -P' to discover services bound to 127.0.0.1. These are high-value targets - often unfiltered and less hardened.",
        "No network connections shown": "Verify you're using -i flag: 'lsof -i'. Without -i, lsof shows all open files (verbose). To see only network: 'lsof -i -n -P'. To see only listening: 'lsof -i -n -P | grep LISTEN'."
      },
      "prerequisites": [],
      "alternatives": [
        "netstat-listening-tcp",
        "ss-listening-all"
      ],
      "next_steps": [
        "ssh-local-port-forward"
      ],
      "tags": [
        "LINUX",
        "ENUMERATION",
        "NETWORK",
        "LATERAL_MOVEMENT",
        "INTERNAL_SERVICE_DISCOVERY",
        "PRIVILEGE_ESCALATION"
      ],
      "notes": "**METHODOLOGY - Internal Service Discovery:**\n\n**1. WHY This Command (Context):**\nlsof is critical for post-exploitation enumeration. It reveals services bound to localhost (127.0.0.1) that aren't visible from external nmap scans. These internal services often lack authentication, have weaker security, and provide direct privilege escalation or lateral movement paths. Many lab boxes have MySQL, Redis, or web services on localhost with no credentials required.\n\n**2. MANUAL ALTERNATIVES (No lsof Available):**\n```bash\n# Method 1: Check /proc filesystem\nls -la /proc/*/fd/ | grep socket\nfor pid in /proc/[0-9]*; do ls -la $pid/fd/ 2>/dev/null | grep socket; done\n\n# Method 2: netstat (usually available)\nnetstat -tulpn  # TCP/UDP listening ports\nnetstat -anp    # All network connections\n\n# Method 3: ss (modern netstat replacement)\nss -tulpn       # TCP/UDP listening ports\nss -anp         # All connections\n\n# Method 4: Read /proc/net directly\ncat /proc/net/tcp    # Active TCP connections (hex format)\ncat /proc/net/udp    # Active UDP connections\ncat /proc/net/unix   # Unix domain sockets\n\n# Method 5: Check specific ports\ncat /proc/net/tcp | awk '{print $2}' | cut -d: -f2 | sort -u | while read port; do echo \"Port: $((16#$port))\"; done\n```\n\n**3. WORKFLOW (Typical Usage):**\n```bash\n# Step 1: Discover all listening services (internal + external)\nlsof -i -n -P | grep LISTEN\n\n# Step 2: Focus on localhost-only services (127.0.0.1)\nlsof -i -n -P | grep \"127.0.0.1.*LISTEN\"\n\n# Step 3: Check specific interesting ports\nlsof -i :3306 -n -P  # MySQL\nlsof -i :6379 -n -P  # Redis\nlsof -i :8080 -n -P  # HTTP alternate\nlsof -i :5432 -n -P  # PostgreSQL\n\n# Step 4: See what files root has open\nlsof -u root | head -50\n\n# Step 5: Find Unix domain sockets (local IPC)\nlsof -U\n\n# Step 6: Check what processes are using /tmp (privesc vector)\nlsof +D /tmp\n```\n\n**4. PRIVILEGE ESCALATION VECTORS:**\n- **Localhost MySQL/PostgreSQL (no password)**: Connect locally, escalate via UDF, raptor exploit, or file writes\n- **Localhost Redis (no auth)**: Use Redis RCE techniques - write SSH keys, cron jobs, or load modules\n- **Unix Sockets in /tmp**: If writable, might allow privilege escalation via socket injection\n- **Writable files open by root**: If root has files open that you can write to, modify them for code execution\n- **Internal web services**: Often lack authentication when bound to 127.0.0.1 - direct access to admin panels\n\n**5. LATERAL MOVEMENT (Port Forwarding):**\nOnce you discover localhost services, pivot to access them:\n```bash\n# SSH local port forward (from your kali to target's localhost)\nssh -L 3306:127.0.0.1:3306 user@target\n\n# SSH remote port forward (expose target's localhost to your kali)\nssh -R 8080:127.0.0.1:80 kali@<your_ip>\n\n# Chisel (when SSH not available)\n# On kali: ./chisel server -p 8000 --reverse\n# On target: ./chisel client <kali_ip>:8000 R:3306:127.0.0.1:3306\n```\n\n**6. TIME ESTIMATES (Pentest):**\n- Initial lsof enumeration: 2-3 minutes\n- Analyzing each internal service: 5-10 minutes per service\n- Setting up port forward: 5 minutes\n- Exploiting internal service: 10-30 minutes\n- Full internal service discovery workflow: 20-40 minutes total\n\n**7. COMMON PITFALLS:**\n- Don't skip lsof just because nmap found all ports - localhost services won't show in nmap\n- Always use -n and -P flags to prevent DNS/port lookups (faster and stealthier)\n- Don't ignore Unix domain sockets (-U flag) - these can be privilege escalation vectors\n- Remember to check what files root has open (lsof -u root) - might find writable configs\n\n**8. HIGH-VALUE TARGETS (What to Look For):**\n- **MySQL on 127.0.0.1:3306**: Try connecting with no password, check for UDF privilege escalation\n- **Redis on 127.0.0.1:6379**: No auth = full control, write SSH keys or cron jobs\n- **PostgreSQL on 127.0.0.1:5432**: Similar to MySQL, UDF exploits possible\n- **HTTP on 127.0.0.1:8080/8000/3000**: Internal admin panels, often no authentication\n- **Elasticsearch on 127.0.0.1:9200**: File write via log injection, code execution\n- **Memcached on 127.0.0.1:11211**: Might contain credentials or session tokens\n- **Unix sockets in /tmp or /var/run**: IPC mechanisms, sometimes exploitable\n\n**9. ALTERNATIVE COMMANDS (Same Goal):**\n- `netstat -tulpn` - Show TCP/UDP listening ports (similar to lsof -i | grep LISTEN)\n- `ss -tulpn` - Modern netstat replacement, faster\n- `netstat -anp` - Show all network connections with PIDs\n- `ss -anp` - Modern alternative to netstat -anp\n- `ls -la /proc/*/fd/` - Manual method, check file descriptors in /proc\n- `cat /proc/net/tcp` - Raw TCP connection table (hex format)\n\n**10. INTEGRATION WITH OTHER ENUM:**\nCombine with:\n- `ps aux` - Identify interesting processes, then use lsof -p <pid>\n- `netstat -tulpn` - Verify lsof results, cross-reference listening ports\n- `linpeas.sh` - Automated enumeration includes lsof output\n- `curl http://127.0.0.1:<port>` - Test discovered localhost services\n- `mysql -h 127.0.0.1 -u root` - Test localhost MySQL with no password\n\n**CRITICAL PRACTICAL TIP**: Immediately after getting shell access, run 'lsof -i -n -P | grep LISTEN' to discover localhost services. These are GOLD - often no authentication, no firewall, direct root access. A localhost MySQL or Redis with no password is often a direct path to root. Don't skip this step.",
      "filled_example": "lsof -i TCP:8080 -n -P"
    }
  ]
}