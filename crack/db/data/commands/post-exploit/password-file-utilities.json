{
  "category": "post-exploit",
  "subcategory": "utilities",
  "description": "Password cracking, file identification, and user switching utilities for post-exploitation",
  "commands": [
    {
      "id": "john-crack-bcrypt",
      "name": "John Crack Bcrypt Hashes",
      "category": "post-exploit",
      "subcategory": "password-cracking",
      "command": "john --format=bcrypt --wordlist=<WORDLIST> <HASH_FILE>",
      "description": "Crack bcrypt password hashes extracted from web applications (Laravel, Django, etc.) using John the Ripper",
      "tags": [
        "BCRYPT",
        "HASH_CRACKING",
        "JOHN",
        "JTR",
        "PASSWORD_CRACKING",
        "POST_EXPLOITATION",
        "WEB"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Path to password wordlist for dictionary attack",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing bcrypt hashes (one per line or username:hash format)",
          "example": "bcrypt_hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--format=bcrypt": "Specify hash format as bcrypt - CRITICAL for bcrypt hashes. Without this, John may misdetect hash type. Bcrypt format: $2a$, $2b$, $2y$ (algorithm identifier) + cost factor + 22-char salt + 31-char hash. Very slow by design (defense against brute force)",
        "--wordlist": "Dictionary attack mode using specified wordlist - tests each word from wordlist against hash. for security work, use rockyou.txt (14M passwords). Faster than brute force but limited to wordlist contents"
      },
      "success_indicators": [
        "Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])",
        "Session completed",
        "1g 0:00:XX:XX",
        "username (hash_value)",
        "password found in pot file"
      ],
      "failure_indicators": [
        "No password hashes loaded",
        "Unknown ciphertext format",
        "Session aborted",
        "0 password hashes cracked, 1 left"
      ],
      "next_steps": [
        "ssh-connect-password",
        "su-user-switch",
        "web-login-admin-panel"
      ],
      "alternatives": [],
      "prerequisites": [
        "sqlmap-dump-table"
      ],
      "troubleshooting": {
        "unknown_format": "Verify hash format. Bcrypt starts with $2a$, $2b$, or $2y$. Check with: head -1 <HASH_FILE>. If different format, use john --list=formats | grep -i <type>",
        "no_hashes_loaded": "Hash file format incorrect. John expects: hash or username:hash (one per line). Remove any headers, quotes, or extra formatting. Test: echo '$2y$10$abcdefghijklmnopqrstuv0123456789ABCDEFGHIJK' > test.txt && john --format=bcrypt test.txt",
        "too_slow": "Bcrypt is VERY slow by design (cost factor). Cost $10 = ~100 hashes/sec, Cost $12 = ~25 hashes/sec. Use smaller wordlist first. Or use hashcat with GPU (100x faster). Check cost: second field after $2y$ (e.g., $2y$10$ = cost 10)",
        "session_interrupted": "Resume with: john --restore. John saves progress in ~/.john/john.rec. Check cracked passwords so far: john --show --format=bcrypt <HASH_FILE>"
      },
      "notes": "CRITICAL WEB EXPLOITATION: Bcrypt hashes commonly found in web app databases.\n\nBcrypt hash format:\n$2y$10$abcdefghijklmnopqrstuv0123456789ABCDEFGHIJK\n\u2502  \u2502 \u2502 \u2502                     \u2502\n\u2502  \u2502 \u2502 \u2514\u2500 22-char salt      \u2514\u2500 31-char hash (base64)\n\u2502  \u2502 \u2514\u2500 Cost factor (2^10 = 1024 rounds)\n\u2502  \u2514\u2500 Minor version (a, b, y)\n\u2514\u2500 Bcrypt identifier\n\nCost factor impact (exponential):\nCost  Rounds    Speed\n04    16        ~10,000/sec\n10    1,024     ~100/sec\n12    4,096     ~25/sec\n14    16,384    ~6/sec\n\nworkflow for web app exploitation:\n1. SQL injection \u2192 Dump users table\n   sqlmap -r request.txt -p param --dump -D database -T users\n\n2. Extract bcrypt hashes\n   Look for $2y$, $2a$, $2b$ in password column\n   Save to file: echo '$2y$10$...' > hashes.txt\n\n3. Crack with John (THIS COMMAND)\n   john --format=bcrypt --wordlist=rockyou.txt hashes.txt\n\n4. Test credentials\n   a. Web admin panel login\n   b. SSH: ssh user@target\n   c. su: su - user\n\n5. Document in breakthrough.md\n\nBcrypt vs other hash types:\n(1) MD5/SHA1 - FAST (millions/sec) \u2192 Easy to crack\n(2) bcrypt - SLOW (hundreds/sec) \u2192 Hard to crack, better security\n(3) NTLM - FAST (billions/sec with GPU) \u2192 Very weak\n(4) SHA-512 (Linux shadow) - MEDIUM (thousands/sec)\n\nTime estimates (rockyou.txt, cost $10):\n- John (CPU): 40-50 hours for full rockyou.txt\n- Hashcat (GPU): 4-5 hours for full rockyou.txt\n- Common passwords: 5-30 minutes\n\nOptimization strategies:\n(1) Use smaller targeted wordlist first\n    Common passwords: /usr/share/wordlists/fasttrack.txt\n    Top 10k: head -10000 rockyou.txt > top10k.txt\n\n(2) Use rules for mutations\n    john --format=bcrypt --wordlist=top10k.txt --rules=best64 hashes.txt\n\n(3) Switch to hashcat with GPU\n    hashcat -m 3200 -a 0 hashes.txt rockyou.txt -O\n\n(4) Check pot file periodically\n    john --show --format=bcrypt hashes.txt\n\nCommon bcrypt sources in practical:\n- Laravel: users table, password column ($2y$10$...)\n- WordPress: wp_users table, user_pass column ($P$... = phpass, not bcrypt)\n- Django: auth_user table, password column (bcrypt$...)\n- Flask: users table, password_hash column\n\nExtracting hashes from SQLMap output:\n# SQLMap CSV format\ngrep '$2y$' ~/.local/share/sqlmap/output/*/dump/*/users.csv | cut -d',' -f3 > hashes.txt\n\n# Or from manual SQL injection\nUNION SELECT username,password FROM users WHERE password LIKE '$2y$%'\n\nChecking already cracked:\njohn --show --format=bcrypt hashes.txt\nOutput: username:cracked_password:...\n\nManual verification:\n# Verify hash format\necho 'test_password' | htpasswd -nBC 10 test | cut -d':' -f2\n# Should produce $2y$10$... format\n\n# Test cracked password immediately\nssh admin@target  # Try cracked password\nsu - admin        # From existing shell\n\npentest tip: Start bcrypt cracking EARLY (background process). Use small wordlist first (top 10k rockyou). If no success in 15 minutes, move on and let it run in background (tmux/screen). Check back periodically. Document in failed_attempts.md if unsuccessful.\n\nTime estimate:\n- Setup: 1-2 minutes\n- Cracking: 5 minutes - 50 hours (depends on password complexity and cost)\n- Common passwords: 5-30 minutes success rate ~30%\n",
      "methodology_guidance": {
        "after_success": "hashcat -m 3200 -a 0 <HASH_FILE> <WORDLIST> john --format=bcrypt <HASH_FILE>"
      },
      "filled_example": "john --format=bcrypt --wordlist=/usr/share/wordlists/rockyou.txt bcrypt_hashes.txt"
    },
    {
      "id": "file-identify-type",
      "name": "Identify File Type",
      "category": "post-exploit",
      "subcategory": "file-utilities",
      "command": "file <FILE>",
      "description": "Identify file type by examining file headers and magic bytes, bypassing file extension to determine actual content type",
      "tags": [
        "ENUMERATION",
        "FILE_ANALYSIS",
        "LINUX",
        "POST_EXPLOITATION"
      ],
      "variables": [
        {
          "name": "<FILE>",
          "description": "Path to file to identify",
          "example": "suspicious_file",
          "required": true
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "File type identified (e.g., 'ELF 64-bit LSB executable')",
        "File format described (e.g., 'PNG image data')",
        "Encoding detected (e.g., 'ASCII text')",
        "Architecture shown (e.g., 'x86-64')"
      ],
      "failure_indicators": [
        "cannot open (No such file or directory)",
        "Permission denied",
        "data (unknown type)"
      ],
      "next_steps": [
        "chmod-executable",
        "file-rename-extension"
      ],
      "alternatives": [],
      "troubleshooting": {
        "permission_denied": "Can't read file. Check permissions: ls -la <FILE>. May need to copy to /tmp first",
        "shows_data": "File type unknown to magic database. Check hex: xxd <FILE> | head. Search magic bytes online",
        "wrong_type_reported": "File may be corrupted or intentionally obfuscated. Verify with hex dump: xxd <FILE> | head -20"
      },
      "notes": "CRITICAL SKILL: Files without extensions or with wrong extensions are common in CTFs.\n\nCommon lab scenarios:\n(1) Executable without .exe extension\n    file suspicious_file \u2192 ELF 64-bit LSB executable\n    \u2192 chmod +x suspicious_file && ./suspicious_file\n\n(2) Image file with wrong extension\n    file backup.txt \u2192 PNG image data\n    \u2192 mv backup.txt backup.png && open backup.png\n\n(3) Compressed archive disguised\n    file data \u2192 gzip compressed data\n    \u2192 mv data data.gz && gunzip data.gz\n\n(4) Script with no extension\n    file script \u2192 Python script, ASCII text\n    \u2192 python3 script\n\n(5) Database file\n    file db \u2192 SQLite 3.x database\n    \u2192 sqlite3 db\n\nFile type identification workflow:\n1. List files: ls -la\n2. Identify type (THIS COMMAND): file *\n3. Rename if needed: mv file.txt file.png\n4. Process accordingly:\n   - Executables: chmod +x, run with ./ or analyze\n   - Archives: extract with tar/unzip/gunzip\n   - Images: view or check for steganography\n   - Text: cat/less to read\n   - Databases: sqlite3/strings to examine\n\nMagic bytes (file signatures):\nELF:    7F 45 4C 46                 (Linux executable)\nPE:     4D 5A                       (Windows .exe)\nPNG:    89 50 4E 47                 (PNG image)\nJPEG:   FF D8 FF                    (JPEG image)\nPDF:    25 50 44 46                 (%PDF)\nZIP:    50 4B 03 04                 (ZIP archive)\nGZIP:   1F 8B                       (gzip compressed)\nTAR:    75 73 74 61 72              (tar archive)\nSQLite: 53 51 4C 69 74 65           (SQLite database)\n\nFile command output interpretation:\nELF 64-bit LSB executable, x86-64, dynamically linked\n\u2502   \u2502      \u2502              \u2502         \u2514\u2500 Linking type\n\u2502   \u2502      \u2502              \u2514\u2500 Architecture\n\u2502   \u2502      \u2514\u2500 Byte order (LSB=little-endian)\n\u2502   \u2514\u2500 Bit width\n\u2514\u2500 File format (Executable and Linkable Format)\n\nManual verification:\n# Check magic bytes directly\nxxd <FILE> | head -1\n# First 16 bytes show file signature\n\n# Multiple files\nfile * | grep -v directory\n\n# Recursive\nfind . -type f -exec file {} \\; | grep -v directory\n\nAdvanced analysis:\n# Check for hidden data (steganography)\nbinwalk <FILE>\nstrings <FILE>\nexiftool <FILE>\n\n# Check encoding\nfile -i <FILE>  # Shows MIME type and charset\n\n# Check architecture compatibility\nfile binary | grep -o 'x86-64\\|ARM\\|i386'\n\npentest scenarios:\n(1) Found file in web directory without extension\n    \u2192 file identifies as ELF executable\n    \u2192 Download, chmod +x, run for privesc\n\n(2) Backup file with .txt extension\n    \u2192 file reveals gzip compressed\n    \u2192 Extract with gunzip for credentials\n\n(3) Image upload bypass verification\n    \u2192 Upload PHP shell as image.jpg\n    \u2192 file image.jpg shows: PHP script, ASCII text\n    \u2192 Proves upload filter only checks extension\n\n(4) Binary analysis for reversing\n    \u2192 file binary shows architecture and linking\n    \u2192 Helps choose correct decompiler/debugger\n\nQuick reference:\nfile <FILE>           - Basic type identification\nfile -b <FILE>        - Brief output (no filename)\nfile -i <FILE>        - MIME type and encoding\nfile -z <FILE>        - Look inside compressed files\nfile -L <FILE>        - Follow symlinks\n\npentest tip: ALWAYS run 'file' on unknown files before attempting to use them. Saves time trying to execute images or decompress executables. Common pattern: find . -type f -exec file {} \\; | grep -i 'executable\\|archive\\|image'.\n\nTime estimate: <5 seconds per file",
      "methodology_guidance": {
        "after_success": "xxd <FILE> | head hexdump -C <FILE> | head binwalk <FILE>"
      },
      "filled_example": "file suspicious_file"
    },
    {
      "id": "su-user-switch",
      "name": "Switch User with su",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "su - <USER>",
      "description": "Switch to another user account with password for lateral movement or privilege escalation to root",
      "tags": [
        "LATERAL_MOVEMENT",
        "LINUX",
        "PRIVILEGE_ESCALATION",
        "USER_SWITCHING"
      ],
      "variables": [
        {
          "name": "<USER>",
          "description": "Target username to switch to (omit for root)",
          "example": "admin",
          "required": false
        }
      ],
      "flag_explanations": {
        "-": "Login shell - Provides full login environment (PATH, HOME, SHELL, etc.) as if user logged in directly. Without hyphen, retains current environment which may cause permission issues or missing binaries. ALWAYS use hyphen for clean environment"
      },
      "success_indicators": [
        "Password prompt appears",
        "Shell prompt changes to new user",
        "whoami shows new username",
        "Environment variables reflect new user (echo $HOME, echo $USER)"
      ],
      "failure_indicators": [
        "Authentication failure",
        "su: user <USER> does not exist",
        "Permission denied",
        "must be root to run this command (for 'su' without user)"
      ],
      "next_steps": [
        "check-sudo-privs",
        "linux-enumerate-users",
        "capture-user-flag"
      ],
      "alternatives": [],
      "prerequisites": [
        "john-crack-bcrypt",
        "sqlmap-dump-table"
      ],
      "troubleshooting": {
        "authentication_failure": "Password incorrect. Verify password from credential dump. Try password variations (uppercase, special chars). Check if user account locked: passwd -S <USER>",
        "user_not_exist": "Username typo or user doesn't exist. Check /etc/passwd: grep <USER> /etc/passwd. List valid users: cut -d: -f1 /etc/passwd",
        "no_password_prompt": "su requires password for non-root users. If no prompt, check if user has no password set (security issue): sudo grep <USER> /etc/shadow | cut -d: -f2",
        "environment_broken": "Missing hyphen (-) causes environment issues. Always use 'su - <USER>' not just 'su <USER>'. Check environment: echo $HOME $PATH $SHELL",
        "stuck_in_su_shell": "Exit with: exit or Ctrl+D. Don't nest too many su shells (confusing). Check current user: whoami"
      },
      "notes": "CRITICAL LATERAL MOVEMENT: Password reuse across user accounts is common.\n\nsu command variations:\nsu              - Switch to root (requires root password)\nsu -            - Switch to root with login environment\nsu <USER>       - Switch to <USER> (keeps current environment)\nsu - <USER>     - Switch to <USER> with login environment (RECOMMENDED)\n\nLogin environment (-) vs current environment:\nWITH hyphen (su - user):\n- HOME=/home/user\n- PATH=/usr/local/bin:/usr/bin:/bin\n- SHELL=/bin/bash\n- PWD=/home/user\n- All user's login scripts run (.bashrc, .profile)\n\nWITHOUT hyphen (su user):\n- HOME=/root (old value)\n- PATH=/usr/sbin:/usr/bin (old value)\n- SHELL=/bin/bash (old value)\n- PWD=/root (old value)\n- May cause permission errors, missing commands\n\nworkflow for password reuse:\n1. Gain initial foothold (web shell, RCE)\n2. Enumerate users: cat /etc/passwd | grep /bin/bash\n3. Extract credentials:\n   a. SQLi dump: sqlmap --dump -T users\n   b. Config files: grep -r 'password' /var/www/\n   c. Crack hashes: john --format=bcrypt hashes.txt\n4. Test credentials with su (THIS COMMAND)\n5. Escalate to root if user has sudo\n\nCommon lab scenarios:\n(1) Web admin password works for SSH user\n    su - admin\n    Password: WebAdminPass123\n    \u2192 Lateral movement successful\n\n(2) Database credentials work for user account\n    su - dbuser\n    Password: db_password_123\n    \u2192 Access to user with sudo rights\n\n(3) Cracked hash enables root access\n    su -\n    Password: cracked_from_shadow\n    \u2192 Root shell obtained\n\n(4) Password found in config file\n    cat /var/www/config.php \u2192 password: 'SecretPass123'\n    su - www-data\n    Password: SecretPass123\n\nPassword testing strategy:\n# Test single password against all users\nfor user in $(cut -d: -f1 /etc/passwd | grep -v 'nologin\\|false\\|sync'); do\n  echo \"Testing $user\"\n  echo 'password123' | su - $user -c 'whoami' 2>/dev/null && echo \"SUCCESS: $user\"\ndone\n\n# Test multiple passwords for specific user\nwhile IFS= read -r pass; do\n  echo \"Testing: $pass\"\n  echo \"$pass\" | su - admin -c 'whoami' 2>/dev/null && echo \"SUCCESS: $pass\" && break\ndone < passwords.txt\n\nsu vs sudo:\nsu - <USER>:\n- Requires target user's password\n- Full login shell as target user\n- No audit trail\n- Used for: Lateral movement, root access\n\nsudo -u <USER> <COMMAND>:\n- Requires YOUR password (current user)\n- Runs single command as target user\n- Logged in /var/log/auth.log\n- Used for: Temporary privilege escalation\n\nsudo su - <USER>:\n- Requires YOUR password\n- Switches to target user via sudo\n- Useful when you know YOUR password but not target's\n\nVerification after su:\nwhoami           - Confirm current user\nid               - Show UID, GID, groups\necho $HOME       - Verify home directory changed\necho $USER       - Verify USER variable\npwd              - Current working directory\nsudo -l          - Check new user's sudo rights\n\nprivilege escalation with su:\n1. Find user with sudo rights:\n   grep -E '^[^#]*sudo' /etc/group\n   \u2192 Lists users in sudo group\n\n2. Switch to that user:\n   su - sudo_user\n   Password: found_password\n\n3. Escalate to root:\n   sudo su -\n   \u2192 Root shell\n\nAdvanced flags:\n-c <COMMAND>  - Run single command as user\n-s <SHELL>    - Use specific shell instead of user's default\n-l            - Simulate full login (same as hyphen)\n-m            - Preserve environment (opposite of hyphen)\n\npentest tip: ALWAYS test found credentials with su immediately. Test against all enumerated users (password reuse). Document all working credentials in credentials.txt. If su succeeds, check sudo -l for privilege escalation path.\n\nTime estimate: 30 seconds (successful) + 2-5 minutes (testing multiple users/passwords)",
      "methodology_guidance": {
        "after_success": "sudo su - <USER> sudo -i -u <USER> ssh <USER>@localhost"
      },
      "filled_example": "su - admin"
    }
  ]
}