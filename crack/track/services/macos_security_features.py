"""
macOS Security Features Enumeration Plugin

Generates tasks for macOS security mechanism analysis including:
- Gatekeeper (application signing, notarization, quarantine)
- Code Signing (signature verification, entitlements, requirements)
- System Integrity Protection (SIP status, rootless, sealed snapshots)
- AppleMobileFileIntegrity (AMFI enforcement, library validation)
- TCC (Transparency, Consent, Control permissions)
- XProtect (anti-malware, Yara rules)
- Background Task Management (persistence detection)

Extracted from HackTricks: macos-security-protections/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSSecurityFeaturesPlugin(ServicePlugin):
    """macOS Security Features enumeration plugin"""

    @property
    def name(self) -> str:
        return "macos-security"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based

    @property
    def service_names(self) -> List[str]:
        return ['macos', 'darwin', 'osx']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect macOS systems"""
        ostype = port_info.get('ostype', '').lower()
        product = port_info.get('product', '').lower()
        service = port_info.get('service', '').lower()

        # Check for macOS indicators
        if any(indicator in ostype for indicator in ['darwin', 'macos', 'mac os']):
            return True

        if any(indicator in product for indicator in ['darwin', 'macos', 'apple']):
            return True

        if 'afp' in service or 'apple' in service:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS security features enumeration task tree"""

        tasks = {
            'id': f'macos-security-enum',
            'name': 'macOS Security Features Enumeration',
            'type': 'parent',
            'children': []
        }

        # GATEKEEPER ENUMERATION
        tasks['children'].append(self._gatekeeper_tasks(target))

        # CODE SIGNING ENUMERATION
        tasks['children'].append(self._code_signing_tasks(target))

        # SIP ENUMERATION
        tasks['children'].append(self._sip_tasks(target))

        # AMFI ENUMERATION
        tasks['children'].append(self._amfi_tasks(target))

        # TCC ENUMERATION
        tasks['children'].append(self._tcc_tasks(target))

        # XPROTECT ENUMERATION
        tasks['children'].append(self._xprotect_tasks(target))

        # BACKGROUND TASK MANAGEMENT
        tasks['children'].append(self._btm_tasks(target))

        return tasks

    def _gatekeeper_tasks(self, target: str) -> Dict[str, Any]:
        """Generate Gatekeeper enumeration tasks"""
        return {
            'id': 'macos-gatekeeper',
            'name': 'Gatekeeper Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'gatekeeper-status',
                    'name': 'Check Gatekeeper Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'spctl --status',
                        'description': 'Check if Gatekeeper signature enforcement is enabled',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'spctl': 'System Policy Control tool - manages Gatekeeper',
                            '--status': 'Display current Gatekeeper status (enabled/disabled)'
                        },
                        'success_indicators': [
                            'assessments enabled - Gatekeeper is active',
                            'assessments disabled - Gatekeeper bypassed'
                        ],
                        'failure_indicators': [
                            'Permission denied - need elevated privileges',
                            'Command not found - not a macOS system'
                        ],
                        'next_steps': [
                            'If disabled, unsigned apps can run without checks',
                            'Check quarantine attributes on downloaded files',
                            'Review spctl policy database'
                        ],
                        'alternatives': [
                            'Check System Settings > Privacy & Security > Security',
                            'sqlite3 /var/db/SystemPolicy (requires root)',
                            'log stream --predicate \'process == "syspolicyd"\''
                        ],
                        'notes': 'On macOS 15+ (Sequoia), spctl cannot modify Gatekeeper - must use MDM profiles'
                    }
                },
                {
                    'id': 'gatekeeper-assess-app',
                    'name': 'Assess Application Signature',
                    'type': 'command',
                    'metadata': {
                        'command': 'spctl --assess -v /Applications/TargetApp.app',
                        'description': 'Check if application will pass Gatekeeper validation',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '--assess': 'Evaluate security policy for file',
                            '-v': 'Verbose output showing signature details'
                        },
                        'success_indicators': [
                            'accepted - App will run without warning',
                            'source=Developer ID - Properly signed by identified developer'
                        ],
                        'failure_indicators': [
                            'rejected - App blocked by Gatekeeper',
                            'source=no usable signature - Unsigned application'
                        ],
                        'next_steps': [
                            'Extract code signature: codesign -dvvv <app>',
                            'Check for bypass vulnerabilities',
                            'Review app bundle structure for tampering'
                        ],
                        'alternatives': [
                            'codesign --verify --verbose /Applications/App.app',
                            'Right-click app > Get Info (check signature in GUI)'
                        ],
                        'notes': 'Gatekeeper only checks apps with quarantine xattr - bypass by removing attribute'
                    }
                },
                {
                    'id': 'check-quarantine-xattr',
                    'name': 'Check Quarantine Extended Attributes',
                    'type': 'command',
                    'metadata': {
                        'command': 'xattr file.app',
                        'description': 'Check if file has quarantine flag (triggers Gatekeeper)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'xattr': 'Extended attribute utility',
                            'file.app': 'Target file/application to inspect'
                        },
                        'success_indicators': [
                            'com.apple.quarantine - File flagged for Gatekeeper check',
                            'com.apple.provenance - Ventura+ provenance tracking'
                        ],
                        'failure_indicators': [
                            'No attributes - File not quarantined',
                            'Permission denied - Need file access'
                        ],
                        'next_steps': [
                            'View details: xattr -l <file>',
                            'Remove quarantine: xattr -d com.apple.quarantine <file>',
                            'Check quarantine database: ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV2'
                        ],
                        'alternatives': [
                            'xattr -l file.app (show attribute values)',
                            'ls -lO@ file.app (show xattr with file listing)',
                            'find . -exec xattr {} \\; | grep quarantine'
                        ],
                        'notes': 'Quarantine flag format: [flags];[timestamp];[app];[UUID] - 0x0040 flag = user approved'
                    }
                },
                {
                    'id': 'remove-quarantine',
                    'name': 'Remove Quarantine Attribute (Bypass)',
                    'type': 'command',
                    'metadata': {
                        'command': 'xattr -d com.apple.quarantine /path/to/file',
                        'description': 'Remove quarantine flag to bypass Gatekeeper check',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            '-d': 'Delete specified extended attribute',
                            'com.apple.quarantine': 'Quarantine attribute name'
                        },
                        'success_indicators': [
                            'Attribute removed silently',
                            'File executes without Gatekeeper prompt'
                        ],
                        'failure_indicators': [
                            'Operation not permitted - SIP protected file',
                            'Attribute not found - Already removed'
                        ],
                        'next_steps': [
                            'Execute app - should run without Gatekeeper check',
                            'Bulk removal: find . -print0 | xargs -0 xattr -d com.apple.quarantine',
                            'Check if provenance xattr also present (Ventura+)'
                        ],
                        'alternatives': [
                            'xattr -c <file> (clear ALL attributes)',
                            'Download via curl (doesn\'t set quarantine)',
                            'Use non-sandboxed downloader'
                        ],
                        'notes': 'Classic Gatekeeper bypass - removed file won\'t trigger signature check'
                    }
                },
                {
                    'id': 'gatekeeper-policy-db',
                    'name': 'Enumerate Gatekeeper Policy Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo sqlite3 /var/db/SystemPolicy "SELECT requirement,allow,disabled,label FROM authority WHERE label != \'GKE\' AND disabled=0"',
                        'description': 'Query Gatekeeper policy rules from syspolicyd database',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'sqlite3': 'SQLite database command-line tool',
                            '/var/db/SystemPolicy': 'Gatekeeper policy database (not SIP-protected)',
                            'authority': 'Table containing signature requirements',
                            'label != \'GKE\'': 'Exclude Apple internal GKE entries'
                        },
                        'success_indicators': [
                            'anchor apple - Apple-signed allowed',
                            'anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6]... - Notarized Developer ID',
                            'Custom rules showing allowed certificates'
                        ],
                        'failure_indicators': [
                            'unable to open database - Need root',
                            'no such table - Database corrupted'
                        ],
                        'next_steps': [
                            'Check GKE hash whitelist: SELECT cdhash FROM authority WHERE label=\'GKE\' LIMIT 10',
                            'Review custom rules: spctl --list',
                            'Examine rule bundles: /var/db/gke.bundle/'
                        ],
                        'alternatives': [
                            'spctl --list (user-friendly rule listing)',
                            'strings /var/db/SystemPolicy (crude inspection)',
                            'log show --predicate \'process=="syspolicyd"\' --last 1h'
                        ],
                        'notes': 'Database is writable by root and unrestricted by SIP - potential privesc target'
                    }
                },
                {
                    'id': 'gatekeeper-disable',
                    'name': 'Disable Gatekeeper (Pre-Sequoia)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo spctl --master-disable',
                        'description': 'Completely disable Gatekeeper signature checks (requires root)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                        'flag_explanations': {
                            '--master-disable': 'Disable all Gatekeeper enforcement system-wide',
                            'sudo': 'Requires root privileges'
                        },
                        'success_indicators': [
                            'Gatekeeper disabled silently',
                            'spctl --status shows "assessments disabled"',
                            'Unsigned apps run without prompts'
                        ],
                        'failure_indicators': [
                            'Operation not permitted - macOS 15+ (Sequoia)',
                            'Permission denied - Need root'
                        ],
                        'next_steps': [
                            'Run unsigned code without prompts',
                            'Load malicious libraries',
                            'Re-enable: sudo spctl --master-enable'
                        ],
                        'alternatives': [
                            'sudo spctl --global-disable (alternative flag)',
                            'On Sequoia: Use MDM profile with com.apple.systempolicy.control',
                            'NVRAM manipulation (boot args)'
                        ],
                        'notes': 'macOS 15+ (Sequoia) blocks spctl modification - must use MDM configuration profiles'
                    }
                },
                {
                    'id': 'gatekeeper-add-rule',
                    'name': 'Add Gatekeeper Whitelist Rule',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo spctl --add --label "whitelist" /Applications/UnsignedApp.app && sudo spctl --enable --label "whitelist"',
                        'description': 'Whitelist specific app to bypass Gatekeeper',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'flag_explanations': {
                            '--add': 'Add new policy rule to database',
                            '--label': 'Tag rule with identifier for management',
                            '--enable': 'Activate the labeled rule'
                        },
                        'success_indicators': [
                            'Rule added silently',
                            'spctl --assess accepts app',
                            'App runs without Gatekeeper prompt'
                        ],
                        'failure_indicators': [
                            'Permission denied - Need root',
                            'macOS 15+ - spctl modification blocked'
                        ],
                        'next_steps': [
                            'Verify: spctl --assess -v /Applications/UnsignedApp.app',
                            'List rules: spctl --list',
                            'Remove rule: sudo spctl --remove --label "whitelist"'
                        ],
                        'alternatives': [
                            'Edit /var/db/SystemPolicy directly (risky)',
                            'xattr -d com.apple.quarantine (simpler bypass)'
                        ],
                        'notes': 'Persistence technique - rule survives reboots'
                    }
                }
            ]
        }

    def _code_signing_tasks(self, target: str) -> Dict[str, Any]:
        """Generate code signing enumeration tasks"""
        return {
            'id': 'macos-code-signing',
            'name': 'Code Signing Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'codesign-verify',
                    'name': 'Verify Code Signature',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign --verify --verbose /Applications/TargetApp.app',
                        'description': 'Verify application code signature integrity',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '--verify': 'Check signature validity',
                            '--verbose': 'Show detailed verification status'
                        },
                        'success_indicators': [
                            'No output - Signature valid',
                            'valid on disk - Signature intact'
                        ],
                        'failure_indicators': [
                            'code object is not signed at all',
                            'invalid signature (code or signature have been modified)',
                            'a sealed resource is missing or invalid'
                        ],
                        'next_steps': [
                            'Extract full signature: codesign -dvvv <app>',
                            'Check entitlements: codesign -d --entitlements :- <app>',
                            'Verify sealed resources: codesign --verify --deep <app>'
                        ],
                        'alternatives': [
                            'codesign -dv <app> (show signing info)',
                            'spctl --assess -v <app> (Gatekeeper assessment)',
                            'pkgutil --check-signature <pkg> (for packages)'
                        ],
                        'notes': 'Code signatures validated by AMFI kernel extension, not every execution'
                    }
                },
                {
                    'id': 'codesign-display-detailed',
                    'name': 'Display Detailed Code Signature',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -dvvv /Applications/TargetApp.app 2>&1 | grep -E "Authority|TeamIdentifier|Signature|CDHash"',
                        'description': 'Extract signing certificate, Team ID, and code directory hash',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-d': 'Display signature information',
                            '-vvv': 'Maximum verbosity (triple verbose)',
                            'grep -E': 'Filter key signature fields',
                            '2>&1': 'Redirect stderr to stdout'
                        },
                        'success_indicators': [
                            'Authority=Apple... - Apple-signed',
                            'Authority=Developer ID Application: [Name] (TeamID) - Third-party developer',
                            'TeamIdentifier=XXXXXXXXXX - 10-character Team ID',
                            'CDHash=abc123... - Code Directory hash (unique identifier)'
                        ],
                        'failure_indicators': [
                            'code object is not signed',
                            'Authority=(empty) - Ad-hoc signature'
                        ],
                        'next_steps': [
                            'Search Team ID on searchsploit/Google',
                            'Check CDHash in Gatekeeper database',
                            'Compare Authority chain to detect tampering'
                        ],
                        'alternatives': [
                            'codesign -dv --entitlements :- <app> (show entitlements)',
                            'spctl --assess --raw <app> (raw Gatekeeper data)',
                            'security cms -D -i /path/to/signature'
                        ],
                        'notes': 'TeamIdentifier links apps from same developer - check for other apps with dangerous entitlements'
                    }
                },
                {
                    'id': 'extract-entitlements',
                    'name': 'Extract Binary Entitlements',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -d --entitlements :- /System/Applications/Automator.app',
                        'description': 'Extract XML entitlements from signed binary',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '--entitlements': 'Extract entitlements plist',
                            ':-': 'Output to stdout instead of file'
                        },
                        'success_indicators': [
                            'XML plist with <key>...</key> entries',
                            'com.apple.security.* - Security entitlements',
                            'com.apple.private.* - Private Apple entitlements'
                        ],
                        'failure_indicators': [
                            'No entitlements found',
                            'Not signed - Cannot extract'
                        ],
                        'next_steps': [
                            'Look for dangerous entitlements (see macos-dangerous-entitlements.md)',
                            'Check TCC permissions: grep kTCC',
                            'Check SIP bypass: grep rootless.install'
                        ],
                        'alternatives': [
                            'jtool --ent <binary> (requires jtool)',
                            'ldid -e <binary> (iOS/jailbreak tool)',
                            '/usr/libexec/PlistBuddy -c Print <entitlements.plist>'
                        ],
                        'notes': 'Dangerous entitlements: com.apple.rootless.install, com.apple.security.get-task-allow, com.apple.private.tcc.manager'
                    }
                },
                {
                    'id': 'check-code-requirements',
                    'name': 'Display Code Signing Requirements',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -d -r- /Applications/Safari.app',
                        'description': 'Show designated requirement (what signature must satisfy)',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            '-r-': 'Display requirements in human-readable format'
                        },
                        'success_indicators': [
                            'designated => identifier "..." and anchor apple',
                            'certificate leaf[subject.OU] = TEAMID - Team ID requirement'
                        ],
                        'failure_indicators': [
                            'No requirements - Unsigned',
                            'Invalid format'
                        ],
                        'next_steps': [
                            'Check if requirements are too permissive',
                            'Compile requirements: csreq -b output.csreq -r=\'...\'',
                            'Test custom requirement: codesign --verify -R \'requirement text\' <app>'
                        ],
                        'alternatives': [
                            'security cms -D -i signature (for detached sigs)',
                            'csreq -t -r <compiled.csreq> (decompile requirement)'
                        ],
                        'notes': 'Requirements define what certificates/TeamIDs can sign the app - used for updates and library validation'
                    }
                },
                {
                    'id': 'check-page-hashes',
                    'name': 'Verify Code Page Hashes',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -dvvvvvv /bin/ps 2>&1 | grep -E "^[[:space:]]+-?[0-9]+=.*"',
                        'description': 'Display per-page hashes of executable (detects tampering)',
                        'tags': ['OSCP:LOW', 'ENUM'],
                        'flag_explanations': {
                            '-dvvvvvv': 'Maximum verbosity to show page hashes',
                            'grep -E': 'Extract hash lines (format: -N=hash or N=hash)'
                        },
                        'success_indicators': [
                            'Multiple hash lines shown (format: 0=abc..., 1=def...)',
                            'Special slots: -1 to -7 (info.plist, requirements, entitlements)'
                        ],
                        'failure_indicators': [
                            'No hashes shown - Unsigned or stripped',
                            'Hash mismatch - Binary tampered'
                        ],
                        'next_steps': [
                            'Manually verify: dd if=<binary> bs=4096 skip=N count=1 | openssl sha256',
                            'Check special slot -5 for entitlements hash',
                            'Compare to original binary'
                        ],
                        'alternatives': [
                            'Manual page hash calculation with dd/openssl',
                            'jtool --sig <binary> (show signature details)'
                        ],
                        'notes': 'Binaries hashed in 4KB pages. Special slots: -7=app-specific, -6=unused, -5=entitlements, -4=app-specific, -3=unused, -2=resources, -1=info.plist'
                    }
                },
                {
                    'id': 'sign-binary-adhoc',
                    'name': 'Ad-hoc Sign Binary (Testing)',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -s - /path/to/binary',
                        'description': 'Sign binary with ad-hoc signature (no developer cert)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'flag_explanations': {
                            '-s': 'Specify signing identity',
                            '-': 'Ad-hoc signature (no certificate)'
                        },
                        'success_indicators': [
                            'Binary signed silently',
                            'codesign -dv shows adhoc signature'
                        ],
                        'failure_indicators': [
                            'Permission denied - File not writable',
                            'Invalid binary format'
                        ],
                        'next_steps': [
                            'Sign with entitlements: codesign -s - --entitlements ent.plist <binary>',
                            'Test execution - ad-hoc sigs work for local testing',
                            'For distribution, need real Developer ID'
                        ],
                        'alternatives': [
                            'codesign -f -s - <binary> (force re-sign)',
                            'codesign -s "Developer ID" <binary> (with cert)',
                            'ldid -S <binary> (iOS signing tool)'
                        ],
                        'notes': 'Ad-hoc signatures satisfy code signing requirement but won\'t pass Gatekeeper for distribution'
                    }
                }
            ]
        }

    def _sip_tasks(self, target: str) -> Dict[str, Any]:
        """Generate SIP enumeration tasks"""
        return {
            'id': 'macos-sip',
            'name': 'System Integrity Protection (SIP) Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'sip-status',
                    'name': 'Check SIP Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'csrutil status',
                        'description': 'Check if System Integrity Protection is enabled',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'csrutil': 'Configurable Security Runtime utility',
                            'status': 'Display current SIP configuration'
                        },
                        'success_indicators': [
                            'System Integrity Protection status: enabled',
                            'System Integrity Protection status: disabled (SIP bypass!)'
                        ],
                        'failure_indicators': [
                            'Command not found - Not macOS',
                            'Operation not permitted'
                        ],
                        'next_steps': [
                            'If disabled, can modify SIP-protected paths',
                            'Check individual protections: csrutil status --verbose',
                            'Test write access to /System/, /usr/, /bin/'
                        ],
                        'alternatives': [
                            'nvram csr-active-config (Intel - show config flags)',
                            'nvram lp-sip0 (Apple Silicon)',
                            'Check protected directories: ls -lOd /usr/ (look for "restricted")'
                        ],
                        'notes': 'SIP can only be disabled from Recovery Mode. Flags in csr.h: CSR_ALLOW_UNRESTRICTED_FS=0x2, CSR_ALLOW_TASK_FOR_PID=0x4, CSR_ALLOW_KERNEL_DEBUGGER=0x8'
                    }
                },
                {
                    'id': 'check-sip-protected-paths',
                    'name': 'Enumerate SIP-Protected Paths',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -lOd /System /bin /sbin /usr | grep -E "restricted|sunlnk"',
                        'description': 'Check which directories have SIP protection flags',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'ls': 'List directory details',
                            '-l': 'Long format',
                            '-O': 'Show file flags (macOS-specific)',
                            '-d': 'Show directory itself, not contents',
                            'restricted': 'SIP protection - no modifications allowed',
                            'sunlnk': 'SIP protection - directory cannot be deleted'
                        },
                        'success_indicators': [
                            'restricted flag - Full SIP protection',
                            'sunlnk flag - Deletion protection only',
                            'No flags - Not SIP protected'
                        ],
                        'failure_indicators': [
                            'Permission denied',
                            'No such directory'
                        ],
                        'next_steps': [
                            'Check exceptions in /System/Library/Sandbox/rootless.conf',
                            'Look for * prefixed paths (SIP exceptions)',
                            'Test: touch /usr/test_sip (should fail if SIP enabled)'
                        ],
                        'alternatives': [
                            'cat /System/Library/Sandbox/rootless.conf (SIP rules)',
                            'xattr -l <file> | grep com.apple.rootless (SIP xattr check)',
                            'find /usr -xattr -print | grep rootless'
                        ],
                        'notes': 'SIP protects: /System, /bin, /sbin, /usr (except /usr/local). Exceptions marked with * in rootless.conf'
                    }
                },
                {
                    'id': 'check-rootless-conf',
                    'name': 'Review SIP Exception List',
                    'type': 'command',
                    'metadata': {
                        'command': 'cat /System/Library/Sandbox/rootless.conf | grep "^\\*"',
                        'description': 'List directories excluded from SIP protection',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'rootless.conf': 'SIP configuration file',
                            '^\\*': 'Grep for lines starting with * (SIP exceptions)'
                        },
                        'success_indicators': [
                            '* /usr/local - Exception for user-installed software',
                            '* /usr/libexec/cups - CUPS printing exception',
                            'List of writable paths despite SIP'
                        ],
                        'failure_indicators': [
                            'File not found - Old macOS',
                            'Empty output'
                        ],
                        'next_steps': [
                            'Test write to exception paths',
                            'Look for persistence opportunities in exceptions',
                            'Check if non-existent exception paths can be created'
                        ],
                        'alternatives': [
                            'cat /System/Library/Sandbox/rootless.conf (full config)',
                            'strings /System/Library/Sandbox/rootless.conf'
                        ],
                        'notes': 'Paths in rootless.conf without * are SIP-protected. With * are exceptions. Non-existent exception paths can potentially be created for persistence'
                    }
                },
                {
                    'id': 'check-authenticated-root',
                    'name': 'Check Authenticated Root (Sealed Snapshots)',
                    'type': 'command',
                    'metadata': {
                        'command': 'csrutil authenticated-root status',
                        'description': 'Check if system volume is sealed (Big Sur+)',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'authenticated-root': 'Check signed system snapshot status',
                            'status': 'Display current seal state'
                        },
                        'success_indicators': [
                            'Authenticated Root status: enabled',
                            'System volume is sealed and verified'
                        ],
                        'failure_indicators': [
                            'disabled - System modifications possible',
                            'Command not recognized - Pre-Big Sur'
                        ],
                        'next_steps': [
                            'Check snapshots: diskutil apfs list',
                            'Verify mount: mount | grep "sealed"',
                            'If disabled, system volume can be modified'
                        ],
                        'alternatives': [
                            'mount | grep "/System/Volumes/Update/mnt1" (check sealed mount)',
                            'diskutil apfs list | grep -A 10 "Snapshot Sealed"',
                            'ls -la / (check if / is read-only snapshot)'
                        ],
                        'notes': 'Big Sur+ uses sealed APFS snapshots. System modifications require new snapshot or seal bypass. User data in separate volume'
                    }
                },
                {
                    'id': 'enumerate-apfs-snapshots',
                    'name': 'Enumerate APFS Snapshots',
                    'type': 'command',
                    'metadata': {
                        'command': 'diskutil apfs list | grep -A 15 "APFS Volume Disk (Role).*System"',
                        'description': 'List system volume snapshots and seal status',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'diskutil apfs list': 'List all APFS volumes and snapshots',
                            'grep -A 15': 'Show System volume + 15 lines context',
                            'Role.*System': 'Filter for System role volumes'
                        },
                        'success_indicators': [
                            'Snapshot Sealed: Yes - System protected',
                            'Snapshot Mount Point: / - Root filesystem',
                            'Sealed: Broken - Seal compromised'
                        ],
                        'failure_indicators': [
                            'No APFS containers - Not APFS',
                            'No snapshots found'
                        ],
                        'next_steps': [
                            'Check Data volume: grep "APFS Volume Disk (Role).*Data"',
                            'If seal broken, investigate compromise',
                            'Check snapshot disk: mount | grep disk*s*s*'
                        ],
                        'alternatives': [
                            'mount | grep apfs (show mounted APFS volumes)',
                            'tmutil listlocalsnapshots / (Time Machine snapshots)',
                            'ls -la / (check if root is snapshot)'
                        ],
                        'notes': 'System volume mounted at / is sealed snapshot. User data at /System/Volumes/Data. Seal prevents system modifications without new snapshot'
                    }
                },
                {
                    'id': 'test-sip-write',
                    'name': 'Test SIP Write Protection',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo touch /usr/bin/test_sip_bypass 2>&1',
                        'description': 'Attempt to write to SIP-protected directory',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                        'flag_explanations': {
                            'sudo': 'Execute as root (SIP blocks even root)',
                            'touch': 'Create empty file',
                            '/usr/bin/': 'SIP-protected system directory',
                            '2>&1': 'Capture error output'
                        },
                        'success_indicators': [
                            'File created - SIP DISABLED or BYPASSED',
                            'ls /usr/bin/test_sip_bypass succeeds'
                        ],
                        'failure_indicators': [
                            'Operation not permitted - SIP active',
                            'Read-only file system - Sealed snapshot'
                        ],
                        'next_steps': [
                            'If successful, SIP is bypassed - document finding',
                            'Test other protected paths: /System, /bin, /sbin',
                            'Cleanup: sudo rm /usr/bin/test_sip_bypass'
                        ],
                        'alternatives': [
                            'echo test | sudo tee /usr/bin/test_sip_bypass',
                            'sudo cp /bin/ls /usr/bin/test_sip_bypass',
                            'Test deletion: sudo rm /usr/bin/ls (don\'t actually do this!)'
                        ],
                        'notes': 'SIP blocks root from modifying protected paths. If writable, major security issue or SIP disabled'
                    }
                },
                {
                    'id': 'check-sip-entitlements',
                    'name': 'Find Processes with SIP Bypass Entitlements',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /System/Library /Library -name "*.app" -o -name "*.bundle" 2>/dev/null | while read app; do codesign -d --entitlements :- "$app" 2>/dev/null | grep -q "com.apple.rootless.install" && echo "$app"; done | head -20',
                        'description': 'Search for binaries with SIP bypass entitlements',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'find /System/Library /Library': 'Search system app directories',
                            '-name "*.app" -o -name "*.bundle"': 'Find applications and bundles',
                            'codesign -d --entitlements :-': 'Extract entitlements',
                            'grep -q "com.apple.rootless.install"': 'Check for SIP bypass entitlement',
                            'head -20': 'Limit output to first 20 matches'
                        },
                        'success_indicators': [
                            'List of apps with com.apple.rootless.install',
                            'System installers and update tools'
                        ],
                        'failure_indicators': [
                            'No matches - No SIP bypass apps',
                            'Permission denied - Need access'
                        ],
                        'next_steps': [
                            'Check for com.apple.rootless.install.heritable (inheritable)',
                            'Analyze found apps for exploitation',
                            'Look for symlink/race conditions'
                        ],
                        'alternatives': [
                            'grep -r "com.apple.rootless" /System/Library (crude search)',
                            'Check specific app: codesign -d --entitlements :- /path/to/app | grep rootless'
                        ],
                        'notes': 'CVE-2019-8561, CVE-2020-9854, CVE-2021-30892 all exploited com.apple.rootless.install.heritable entitlement via system_installd'
                    }
                }
            ]
        }

    def _amfi_tasks(self, target: str) -> Dict[str, Any]:
        """Generate AMFI enumeration tasks"""
        return {
            'id': 'macos-amfi',
            'name': 'AppleMobileFileIntegrity (AMFI) Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-amfi-status',
                    'name': 'Check AMFI Kernel Extension Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'kextstat | grep -i amfi',
                        'description': 'Verify AMFI kernel extension is loaded',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'kextstat': 'List loaded kernel extensions',
                            'grep -i amfi': 'Filter for AppleMobileFileIntegrity'
                        },
                        'success_indicators': [
                            'com.apple.driver.AppleMobileFileIntegrity - AMFI loaded',
                            'Index number and version shown'
                        ],
                        'failure_indicators': [
                            'No output - AMFI not loaded (major issue)',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check AMFI dependencies: kextstat | grep dependencies',
                            'Look for boot args: nvram boot-args',
                            'Check for amfi_get_out_of_my_way boot arg (disables AMFI)'
                        ],
                        'alternatives': [
                            'kextstat | grep " 19 " (AMFI usually index 19)',
                            'system_profiler SPExtensionsDataType | grep -i amfi',
                            'sysctl -a | grep amfi'
                        ],
                        'notes': 'AMFI enforces code signatures. If missing or disabled, unsigned code can execute. Boot args: amfi_unrestricted_task_for_pid, amfi_allow_any_signature, cs_enforcement_disable'
                    }
                },
                {
                    'id': 'check-amfi-boot-args',
                    'name': 'Check AMFI Boot Arguments',
                    'type': 'command',
                    'metadata': {
                        'command': 'nvram boot-args 2>&1 | grep -E "amfi|cs_enforcement"',
                        'description': 'Check for AMFI-weakening boot arguments',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'nvram boot-args': 'Read non-volatile RAM boot arguments',
                            'grep -E "amfi|cs_enforcement"': 'Filter AMFI-related flags'
                        },
                        'success_indicators': [
                            'amfi_get_out_of_my_way=0x1 - AMFI FULLY DISABLED',
                            'amfi_unrestricted_task_for_pid - task_for_pid allowed',
                            'amfi_allow_any_signature - Any signature accepted',
                            'cs_enforcement_disable=1 - Code signing disabled'
                        ],
                        'failure_indicators': [
                            'No amfi flags - AMFI fully enabled',
                            'nvram: Error - Need root or not macOS'
                        ],
                        'next_steps': [
                            'If weakened, unsigned code may execute',
                            'Document as critical finding',
                            'Check who set boot args: ls -la /Library/Preferences/SystemConfiguration/'
                        ],
                        'alternatives': [
                            'nvram -p | grep -i amfi',
                            'ioreg -p IODeviceTree -n chosen -d 1 | grep boot-args'
                        ],
                        'notes': 'Setting these requires SIP disabled or Recovery Mode. Presence indicates prior compromise or intentional weakening'
                    }
                },
                {
                    'id': 'check-library-validation',
                    'name': 'Check Library Validation Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -dvvv /Applications/TargetApp.app 2>&1 | grep -E "flags|CodeDirectory"',
                        'description': 'Check if app has library validation enabled',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'flags': 'Code signing flags field',
                            'CodeDirectory': 'Code signature metadata',
                            'runtime': 'Hardened runtime flag (includes library validation)',
                            'library-validation': 'Explicit library validation flag'
                        },
                        'success_indicators': [
                            'flags=0x10000(runtime) - Hardened runtime with validation',
                            'flags=0x2000(library-validation) - Library validation enforced'
                        ],
                        'failure_indicators': [
                            'No runtime or library-validation flags',
                            'App can load unsigned libraries'
                        ],
                        'next_steps': [
                            'If missing, attempt dylib injection',
                            'Check for disable-library-validation entitlement',
                            'Test: DYLD_INSERT_LIBRARIES=/tmp/evil.dylib /path/to/app'
                        ],
                        'alternatives': [
                            'codesign -d --entitlements :- <app> | grep disable-library-validation',
                            'Check hardened runtime: codesign -dv <app> | grep runtime'
                        ],
                        'notes': 'Library validation requires loaded dylibs match app TeamID or be Apple-signed. Entitlement com.apple.security.cs.disable-library-validation disables it'
                    }
                },
                {
                    'id': 'find-get-task-allow',
                    'name': 'Find Apps with get-task-allow Entitlement',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Applications -name "*.app" 2>/dev/null | while read app; do codesign -d --entitlements :- "$app" 2>/dev/null | grep -q "get-task-allow" && echo "$app"; done',
                        'description': 'Search for apps allowing debugging/task port access',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'find /Applications': 'Search installed applications',
                            'codesign -d --entitlements :-': 'Extract entitlements',
                            'grep -q "get-task-allow"': 'Check for debugging entitlement'
                        },
                        'success_indicators': [
                            'List of apps with com.apple.security.get-task-allow',
                            'Development/debug builds found'
                        ],
                        'failure_indicators': [
                            'No matches - No debuggable apps',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Apps with get-task-allow can be debugged',
                            'Inject code: lldb -p $(pgrep <app>)',
                            'Use for privilege escalation if app is privileged'
                        ],
                        'alternatives': [
                            'Check specific app: codesign -d --entitlements :- /Applications/App.app | grep task-allow',
                            'Find task_for_pid-allow: grep "task_for_pid-allow"'
                        ],
                        'notes': 'get-task-allow allows debuggers to attach. Should only be in development builds, not production. Can be exploited for code injection'
                    }
                },
                {
                    'id': 'check-amfid-daemon',
                    'name': 'Check amfid Daemon Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep -i amfid | grep -v grep',
                        'description': 'Verify AMFI user-mode daemon is running',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'ps aux': 'List all processes',
                            'grep -i amfid': 'Filter for AMFI daemon',
                            'grep -v grep': 'Exclude grep itself'
                        },
                        'success_indicators': [
                            '/usr/libexec/amfid running',
                            'Process owned by root'
                        ],
                        'failure_indicators': [
                            'No amfid process - AMFI not enforcing',
                            'Multiple amfid instances (suspicious)'
                        ],
                        'next_steps': [
                            'Check for hijacked amfid: ls -la /usr/libexec/amfid',
                            'Verify signature: codesign -dvvv /usr/libexec/amfid',
                            'Historical jailbreaks replaced amfid binary'
                        ],
                        'alternatives': [
                            'launchctl list | grep amfid',
                            'pgrep -fl amfid',
                            'lsof -c amfid (check open files)'
                        ],
                        'notes': 'amfid validates code signatures for AMFI.kext via mach port 18 (HOST_AMFID_PORT). Jailbreaks historically backdoored this daemon'
                    }
                },
                {
                    'id': 'enumerate-provisioning-profiles',
                    'name': 'Enumerate Provisioning Profiles',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /var/MobileDeviceProvisioningProfiles /Library/Developer/ProvisioningProfiles ~/Library/MobileDevice/Provisioning\\ Profiles -name "*.mobileprovision" -o -name "*.provisionprofile" 2>/dev/null | head -10',
                        'description': 'Find developer provisioning profiles',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'find': 'Search multiple directories',
                            '/var/MobileDeviceProvisioningProfiles': 'System provisioning profiles',
                            '*.mobileprovision': 'iOS-style profile extension',
                            '*.provisionprofile': 'macOS profile extension'
                        },
                        'success_indicators': [
                            'List of provisioning profile files',
                            'Developer/Enterprise profiles found'
                        ],
                        'failure_indicators': [
                            'No profiles - No development environment',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Dump profile: security cms -D -i <profile>',
                            'Check TeamIdentifier, entitlements, expiration',
                            'Look for enterprise profiles (broader distribution)'
                        ],
                        'alternatives': [
                            'security cms -D -i /path/to/profile (dump profile)',
                            'openssl asn1parse -inform der -in <profile>'
                        ],
                        'notes': 'Provisioning profiles contain certificates + entitlements. Enterprise profiles work on all devices. Extract with security cms -D'
                    }
                },
                {
                    'id': 'check-trust-cache',
                    'name': 'Check AMFI Trust Cache (Advanced)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'AMFI maintains trust cache of ad-hoc signed hashes in kext __TEXT.__const section',
                        'tags': ['OSCP:LOW', 'ENUM'],
                        'notes': 'Trust cache cannot be easily enumerated without kernel debugging. Contains CDHashes of trusted binaries. Only relevant for low-level iOS research or kernel exploitation',
                        'alternatives': [
                            'Requires kernel debugger or lldb on AMFI.kext',
                            'Historical research: Check kernelcache for trust cache data',
                            'Not practical for typical macOS pentesting'
                        ],
                        'next_steps': [
                            'Focus on entitlements and provisioning profiles instead',
                            'Trust cache mainly iOS concern'
                        ]
                    }
                }
            ]
        }

    def _tcc_tasks(self, target: str) -> Dict[str, Any]:
        """Generate TCC enumeration tasks"""
        return {
            'id': 'macos-tcc',
            'name': 'Transparency, Consent, and Control (TCC) Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'dump-tcc-system-db',
                    'name': 'Dump System TCC Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo sqlite3 /Library/Application\\ Support/com.apple.TCC/TCC.db "SELECT service, client, auth_value, auth_reason FROM access"',
                        'description': 'Extract system-wide TCC permissions (requires root)',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'sqlite3': 'SQLite database tool',
                            '/Library/Application Support/com.apple.TCC/TCC.db': 'System TCC database',
                            'service': 'TCC service (e.g., kTCCServiceSystemPolicyAllFiles)',
                            'client': 'Application bundle ID',
                            'auth_value': 'Permission status (0=denied, 1=unknown, 2=allowed, 3=limited)',
                            'auth_reason': 'How permission was granted (1=error, 2=user, 3=MDM, 4=system)'
                        },
                        'success_indicators': [
                            'List of apps with system-wide permissions',
                            'kTCCServiceSystemPolicyAllFiles - Full Disk Access',
                            'kTCCServiceAccessibility - Accessibility permissions'
                        ],
                        'failure_indicators': [
                            'unable to open database - Need root + FDA',
                            'Operation not permitted - Terminal needs FDA'
                        ],
                        'next_steps': [
                            'Check user TCC: ~/Library/Application Support/com.apple.TCC/TCC.db',
                            'Look for dangerous permissions (FDA, kext approval)',
                            'Find apps with TCC manager entitlement'
                        ],
                        'alternatives': [
                            'tccutil dump (user-level permissions)',
                            'sqlite3 TCC.db .dump (full database dump)',
                            'Use third-party tools: Privacy.app, TCC Explorer'
                        ],
                        'notes': 'Terminal needs Full Disk Access to read TCC database. Auth_value: 0=denied, 2=allowed. Important services: kTCCServiceSystemPolicyAllFiles (FDA), kTCCServiceAppleEvents, kTCCServiceAccessibility'
                    }
                },
                {
                    'id': 'dump-tcc-user-db',
                    'name': 'Dump User TCC Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sqlite3 ~/Library/Application\\ Support/com.apple.TCC/TCC.db "SELECT service, client, auth_value FROM access"',
                        'description': 'Extract current user TCC permissions',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '~/Library/Application Support/com.apple.TCC/TCC.db': 'User-specific TCC database',
                            'service': 'TCC service requested',
                            'client': 'Application bundle ID',
                            'auth_value': '2=allowed, 0=denied'
                        },
                        'success_indicators': [
                            'List of user-granted permissions',
                            'kTCCServiceMicrophone, kTCCServiceCamera permissions',
                            'kTCCServiceScreenCapture, kTCCServiceListenEvent'
                        ],
                        'failure_indicators': [
                            'Database locked - TCC in use',
                            'No such table'
                        ],
                        'next_steps': [
                            'Identify high-privilege apps',
                            'Check for unsigned apps with permissions',
                            'Look for apps with AppleEvents (automation) access'
                        ],
                        'alternatives': [
                            'tccutil dump (higher-level interface)',
                            'System Settings > Privacy & Security (GUI)',
                            'sqlite3 TCC.db .schema (see database structure)'
                        ],
                        'notes': 'User TCC separate from system. Does not require root. Key services: kTCCServiceCamera, kTCCServiceMicrophone, kTCCServiceScreenCapture, kTCCServiceAppleEvents'
                    }
                },
                {
                    'id': 'find-tcc-manager-entitlement',
                    'name': 'Find Apps with TCC Manager Entitlement',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /System/Library /Applications -name "*.app" 2>/dev/null | while read app; do codesign -d --entitlements :- "$app" 2>/dev/null | grep -q "com.apple.private.tcc.manager" && echo "$app"; done | head -10',
                        'description': 'Search for apps that can modify TCC database',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'find /System/Library /Applications': 'Search system apps',
                            'codesign -d --entitlements :-': 'Extract entitlements',
                            'grep "com.apple.private.tcc.manager"': 'Check for TCC manager entitlement',
                            'head -10': 'Limit to 10 results'
                        },
                        'success_indicators': [
                            'List of apps with TCC modification power',
                            'System utilities and management tools'
                        ],
                        'failure_indicators': [
                            'No matches - No TCC manager apps accessible',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check for vulnerabilities in found apps',
                            'Also search for: com.apple.rootless.storage.TCC',
                            'Look for exploitable XPC services in these apps'
                        ],
                        'alternatives': [
                            'grep -r "tcc.manager" /System/Library (crude search)',
                            'Check specific app: codesign -d --entitlements :- <app> | grep tcc'
                        ],
                        'notes': 'com.apple.private.tcc.manager and com.apple.rootless.storage.TCC allow TCC database modification. Extremely dangerous if exploitable. Historical CVEs exploited these apps'
                    }
                },
                {
                    'id': 'enumerate-tcc-services',
                    'name': 'List All TCC Service Types',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Common TCC services to check for',
                        'tags': ['OSCP:MEDIUM', 'REFERENCE'],
                        'notes': '''Key TCC Services:
- kTCCServiceSystemPolicyAllFiles - Full Disk Access (HIGHEST RISK)
- kTCCServiceSystemPolicySysAdminFiles - Admin file access
- kTCCServiceAccessibility - Control other apps (HIGH RISK)
- kTCCServiceAppleEvents - Send AppleEvents (automation)
- kTCCServiceCamera - Camera access
- kTCCServiceMicrophone - Microphone access
- kTCCServiceScreenCapture - Screen recording
- kTCCServiceSystemPolicyAppBundles - Modify app bundles
- kTCCServiceEndpointSecurityClient - Write TCC database
- kTCCServiceListenEvent - Input monitoring
- kTCCServicePostEvent - Synthetic events
- kTCCServiceMediaLibrary - Photos library access
- kTCCServiceAddressBook - Contacts access
- kTCCServiceCalendar - Calendar access
- kTCCServiceReminders - Reminders access
- kTCCServiceUbiquityKVStore - iCloud key-value store
- kTCCServiceAll - Request all TCC permissions''',
                        'alternatives': [
                            'Check TCC.db: SELECT DISTINCT service FROM access',
                            'Review System Settings > Privacy & Security',
                            'Check /System/Library/PrivateFrameworks/TCC.framework/Versions/A/Resources/tccd'
                        ],
                        'next_steps': [
                            'Query each service: sqlite3 TCC.db "SELECT * FROM access WHERE service=\'kTCCServiceSystemPolicyAllFiles\'"',
                            'Prioritize FDA and Accessibility permissions',
                            'Check which apps have AppleEvents to control high-privilege apps'
                        ]
                    }
                },
                {
                    'id': 'test-tcc-synthetic-click',
                    'name': 'Test TCC Synthetic Click Bypass',
                    'type': 'command',
                    'metadata': {
                        'command': 'osascript -e \'tell app "System Settings" to activate\' -e \'tell application "System Events" to click button "Allow" of window 1 of process "System Settings"\'',
                        'description': 'Attempt synthetic click to bypass TCC prompt (requires Accessibility)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            'osascript': 'Execute AppleScript',
                            'tell app "System Settings"': 'Target System Settings app',
                            'System Events': 'Accessibility API for UI automation',
                            'click button': 'Synthetic button click'
                        },
                        'success_indicators': [
                            'Button clicked successfully',
                            'TCC prompt bypassed via automation'
                        ],
                        'failure_indicators': [
                            'Not authorized to send Apple events - Need AppleEvents permission',
                            'Button not found - Wrong window/prompt'
                        ],
                        'next_steps': [
                            'If successful, can automate TCC approvals',
                            'Chain with app that has Accessibility permission',
                            'Modern macOS blocks this - test older versions'
                        ],
                        'alternatives': [
                            'cliclick - Command-line clicking tool',
                            'Python with pyautogui',
                            'Accessibility API via Swift/ObjC'
                        ],
                        'notes': 'Synthetic clicks to approve TCC largely mitigated in modern macOS. Requires app with Accessibility permission. Historical bypass technique'
                    }
                },
                {
                    'id': 'tcc-reset-service',
                    'name': 'Reset TCC Permissions for App',
                    'type': 'command',
                    'metadata': {
                        'command': 'tccutil reset All com.example.app',
                        'description': 'Clear TCC permissions for specific application',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'flag_explanations': {
                            'tccutil': 'TCC utility for managing permissions',
                            'reset': 'Clear permissions',
                            'All': 'All TCC services (or specify service like Camera)',
                            'com.example.app': 'Bundle ID of target app'
                        },
                        'success_indicators': [
                            'Permissions reset silently',
                            'App will re-prompt on next access'
                        ],
                        'failure_indicators': [
                            'Invalid bundle ID',
                            'Operation not permitted'
                        ],
                        'next_steps': [
                            'Relaunch app to trigger new prompts',
                            'Reset all apps: tccutil reset All',
                            'Check specific service: tccutil reset Camera'
                        ],
                        'alternatives': [
                            'Delete from TCC.db manually: sqlite3 ~/Library/.../TCC.db "DELETE FROM access WHERE client=..."',
                            'System Settings > Privacy & Security (GUI reset)',
                            'rm ~/Library/Application Support/com.apple.TCC/TCC.db (nuclear option)'
                        ],
                        'notes': 'Useful for testing or resetting after exploitation. Can force re-prompts for social engineering'
                    }
                },
                {
                    'id': 'check-tcc-bypass-nfshome',
                    'name': 'Check TCC Bypass via NFSHomeDirectory',
                    'type': 'command',
                    'metadata': {
                        'command': 'dscl . -read /Users/$USER NFSHomeDirectory',
                        'description': 'Check home directory path (TCC bypass if modified)',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'dscl': 'Directory Service command-line utility',
                            '. -read': 'Read from local directory service',
                            '/Users/$USER': 'Current user record',
                            'NFSHomeDirectory': 'Home directory attribute'
                        },
                        'success_indicators': [
                            'NFSHomeDirectory: /Users/username - Normal',
                            'NFSHomeDirectory: /tmp/fake_home - BYPASS ATTEMPT'
                        ],
                        'failure_indicators': [
                            'No such key',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'If modified, TCC can be bypassed (reads TCC.db from fake home)',
                            'Check for kTCCServiceSystemPolicySysAdminFiles permission',
                            'Document as critical finding'
                        ],
                        'alternatives': [
                            'echo $HOME (environment variable)',
                            'getent passwd $USER',
                            'dscacheutil -q user -a name $USER'
                        ],
                        'notes': 'CVE: Changing NFSHomeDirectory to attacker-controlled path bypasses TCC (reads attacker TCC.db). Requires kTCCServiceSystemPolicySysAdminFiles entitlement'
                    }
                }
            ]
        }

    def _xprotect_tasks(self, target: str) -> Dict[str, Any]:
        """Generate XProtect enumeration tasks"""
        return {
            'id': 'macos-xprotect',
            'name': 'XProtect Anti-Malware Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-xprotect-version',
                    'name': 'Check XProtect Version',
                    'type': 'command',
                    'metadata': {
                        'command': 'system_profiler SPInstallHistoryDataType 2>/dev/null | grep -A 4 "XProtectPlistConfigData" | tail -5',
                        'description': 'Display XProtect database version and update date',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'system_profiler SPInstallHistoryDataType': 'Query installation history',
                            'grep -A 4 "XProtectPlistConfigData"': 'Find XProtect update entry + 4 lines',
                            'tail -5': 'Show last 5 lines (version info)'
                        },
                        'success_indicators': [
                            'Version number and install date shown',
                            'Recent update = active XProtect'
                        ],
                        'failure_indicators': [
                            'No XProtect entries - Not installed or outdated',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check XProtect bundle: /Library/Apple/System/Library/CoreServices/XProtect.bundle',
                            'Review Yara rules: /Library/Apple/System/Library/CoreServices/XProtect.bundle/Contents/Resources/XProtect.yara',
                            'Check malware database: XProtect.bundle/Contents/Resources/gk.db'
                        ],
                        'alternatives': [
                            'ls -la /Library/Apple/System/Library/CoreServices/XProtect.bundle',
                            'defaults read /Library/Apple/System/Library/CoreServices/XProtect.bundle/Contents/version.plist',
                            'softwareupdate --list | grep XProtect'
                        ],
                        'notes': 'XProtect auto-updates via Apple. Old versions indicate blocked updates or offline system'
                    }
                },
                {
                    'id': 'review-xprotect-yara',
                    'name': 'Review XProtect Yara Rules',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo cat /Library/Apple/System/Library/CoreServices/XProtect.bundle/Contents/Resources/XProtect.yara 2>/dev/null | head -100',
                        'description': 'View XProtect malware detection rules',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'XProtect.yara': 'Yara rules for malware signatures',
                            'head -100': 'Show first 100 lines'
                        },
                        'success_indicators': [
                            'Yara rules shown with malware signatures',
                            'rule XProtect_* entries',
                            'Strings and hex patterns'
                        ],
                        'failure_indicators': [
                            'File not found - Old macOS or missing XProtect',
                            'Permission denied - Need root'
                        ],
                        'next_steps': [
                            'Identify what malware families are detected',
                            'Test payload against rules: yara XProtect.yara /path/to/file',
                            'Check for evasion opportunities'
                        ],
                        'alternatives': [
                            'strings XProtect.yara (basic inspection)',
                            'grep "rule " XProtect.yara (list rule names)',
                            'Use yara command-line tool for testing'
                        ],
                        'notes': 'XProtect.yara contains signatures for known macOS malware. Useful for evasion research. Rules updated by Apple'
                    }
                },
                {
                    'id': 'check-xprotect-gk-db',
                    'name': 'Query XProtect Gatekeeper Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo sqlite3 /Library/Apple/System/Library/CoreServices/XProtect.bundle/Contents/Resources/gk.db "SELECT DISTINCT teamid FROM authority" | head -20',
                        'description': 'List blocked Team IDs and app hashes',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'sqlite3': 'SQLite database tool',
                            'gk.db': 'XProtect Gatekeeper blocked apps database',
                            'teamid': 'Apple Developer Team IDs blocked',
                            'DISTINCT': 'Unique values only'
                        },
                        'success_indicators': [
                            'List of Team IDs blocked by XProtect',
                            'Known malware developer IDs'
                        ],
                        'failure_indicators': [
                            'Database locked or not readable',
                            'Need root access'
                        ],
                        'next_steps': [
                            'Check app hashes: SELECT cdhash FROM authority',
                            'Cross-reference Team IDs with found apps',
                            'Look for blocked but installed apps'
                        ],
                        'alternatives': [
                            'sqlite3 gk.db .dump (full database)',
                            'sqlite3 gk.db "SELECT * FROM authority LIMIT 10"',
                            'strings gk.db | grep -i team'
                        ],
                        'notes': 'gk.db contains CDHashes and TeamIDs of blocked malware. XProtect blocks execution even if Gatekeeper would allow'
                    }
                },
                {
                    'id': 'check-xprotect-meta-plist',
                    'name': 'Review XProtect Metadata',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo plutil -p /Library/Apple/System/Library/CoreServices/XProtect.bundle/Contents/Resources/XProtect.meta.plist 2>/dev/null | grep -A 5 "MinimumVersion\\|PluginBlacklist"',
                        'description': 'Check blocked plugins and minimum versions',
                        'tags': ['OSCP:LOW', 'ENUM'],
                        'flag_explanations': {
                            'plutil -p': 'Pretty-print plist file',
                            'XProtect.meta.plist': 'Metadata about blocked extensions/plugins',
                            'MinimumVersion': 'Minimum allowed version of plugin',
                            'PluginBlacklist': 'Blocked browser plugins'
                        },
                        'success_indicators': [
                            'List of plugins with minimum versions',
                            'Blocked Flash, Java, Silverlight versions'
                        ],
                        'failure_indicators': [
                            'File not found',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check if any installed plugins are outdated/blocked',
                            'Review browser extension restrictions',
                            'Document blocked software'
                        ],
                        'alternatives': [
                            'cat XProtect.meta.plist (raw XML)',
                            'defaults read XProtect.meta.plist'
                        ],
                        'notes': 'XProtect.meta.plist blocks outdated browser plugins via bundle ID and minimum version. Mainly historical (Flash, Java)'
                    }
                },
                {
                    'id': 'check-xprotect-remediator',
                    'name': 'Check XProtect Remediator Activity',
                    'type': 'command',
                    'metadata': {
                        'command': 'log show --last 2h --predicate \'subsystem == "com.apple.XProtectFramework" || category CONTAINS "XProtect"\' --style syslog | head -50',
                        'description': 'View recent XProtect scanning and remediation activity',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'log show': 'Query unified logging system',
                            '--last 2h': 'Last 2 hours of logs',
                            '--predicate': 'Filter by XProtect subsystem',
                            '--style syslog': 'Traditional syslog format'
                        },
                        'success_indicators': [
                            'XProtect scan events shown',
                            'Remediator execution logs',
                            'Malware detection alerts'
                        ],
                        'failure_indicators': [
                            'No logs - XProtect not active',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Look for malware detections',
                            'Check scan frequency',
                            'Review what files were scanned'
                        ],
                        'alternatives': [
                            'log stream --predicate \'subsystem=="com.apple.XProtectFramework"\' (live)',
                            'Console.app > Filter: XProtect',
                            'ls /Library/Apple/System/Library/CoreServices/XProtect.app'
                        ],
                        'notes': 'XProtect Remediator runs periodic background scans via launchd. Different from real-time Gatekeeper checks. Logs show what was scanned and detected'
                    }
                },
                {
                    'id': 'locate-mrt',
                    'name': 'Locate Malware Removal Tool (MRT)',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -la /Library/Apple/System/Library/CoreServices/MRT.app && /Library/Apple/System/Library/CoreServices/MRT.app/Contents/MacOS/MRT --version 2>&1',
                        'description': 'Check MRT presence and version',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'ls -la': 'List MRT application bundle',
                            'MRT.app/Contents/MacOS/MRT': 'MRT binary',
                            '--version': 'Display version (may not work)'
                        },
                        'success_indicators': [
                            'MRT.app found',
                            'Version information shown',
                            'Executable is signed by Apple'
                        ],
                        'failure_indicators': [
                            'MRT not found - Removed or old macOS',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check signature: codesign -dvvv MRT.app',
                            'Review MRT logs for past malware removals',
                            'MRT signatures embedded in binary (no external files)'
                        ],
                        'alternatives': [
                            'system_profiler SPInstallHistoryDataType | grep MRT',
                            'strings /Library/Apple/System/Library/CoreServices/MRT.app/Contents/MacOS/MRT'
                        ],
                        'notes': 'MRT removes detected malware. Runs automatically after OS updates. Signatures in binary, not readable files'
                    }
                }
            ]
        }

    def _btm_tasks(self, target: str) -> Dict[str, Any]:
        """Generate Background Task Management enumeration tasks"""
        return {
            'id': 'macos-btm',
            'name': 'Background Task Management Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'dump-btm-database',
                    'name': 'Dump Background Task Management Items',
                    'type': 'command',
                    'metadata': {
                        'command': 'sfltool dumpbtm',
                        'description': 'List all background tasks and persistence mechanisms',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'sfltool': 'System File Logger tool',
                            'dumpbtm': 'Dump Background Task Management database'
                        },
                        'success_indicators': [
                            'List of LaunchDaemons, LaunchAgents, Login Items',
                            'App bundle IDs and executable paths',
                            'Attribution to known applications'
                        ],
                        'failure_indicators': [
                            'Requires user password prompt',
                            'Permission denied - Need user auth'
                        ],
                        'next_steps': [
                            'Identify suspicious persistence items',
                            'Check for unsigned binaries',
                            'Cross-reference with /Library/LaunchDaemons'
                        ],
                        'alternatives': [
                            'DumpBTM tool (requires FDA): ./dumpBTM',
                            'launchctl list (shows running services)',
                            'Direct DB: /private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v4.btm'
                        ],
                        'notes': 'BTM tracks persistence mechanisms and alerts users. Requires password. Alternative: grant Terminal FDA and use DumpBTM tool'
                    }
                },
                {
                    'id': 'check-btm-database-direct',
                    'name': 'Check BTM Database Directly (Requires FDA)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo ls -la /private/var/db/com.apple.backgroundtaskmanagement/',
                        'description': 'Inspect BTM database files (requires Full Disk Access)',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            '/private/var/db/com.apple.backgroundtaskmanagement/': 'BTM database directory',
                            'BackgroundItems-v4.btm': 'Main BTM database file'
                        },
                        'success_indicators': [
                            'BackgroundItems-v4.btm file shown',
                            'Database modification timestamps'
                        ],
                        'failure_indicators': [
                            'Operation not permitted - Need FDA',
                            'Directory not found - macOS version issue'
                        ],
                        'next_steps': [
                            'Use DumpBTM to parse database',
                            'Check for tampering: modification time vs system uptime',
                            'BTM resets can hide persistence'
                        ],
                        'alternatives': [
                            'sfltool dumpbtm (official tool, no FDA needed)',
                            'DumpBTM (third-party parser)',
                            'System Settings > General > Login Items'
                        ],
                        'notes': 'BTM database stores all persistence items. Terminal needs Full Disk Access to read directly'
                    }
                },
                {
                    'id': 'check-btm-daemon',
                    'name': 'Check BTM Daemon Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep backgroundtaskmanagementd | grep -v grep',
                        'description': 'Verify BTM daemon is running',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'ps aux': 'List all processes',
                            'grep backgroundtaskmanagementd': 'Filter for BTM daemon',
                            'grep -v grep': 'Exclude grep itself'
                        },
                        'success_indicators': [
                            'backgroundtaskmanagementd running',
                            'Process owned by root'
                        ],
                        'failure_indicators': [
                            'No process found - BTM not running (suspicious)',
                            'Multiple instances (unusual)'
                        ],
                        'next_steps': [
                            'Check agent: ps aux | grep BackgroundTaskManagementAgent',
                            'If stopped, check if SIGSTOP sent (bypass technique)',
                            'Verify daemon signature: codesign -dvvv <daemon path>'
                        ],
                        'alternatives': [
                            'launchctl list | grep backgroundtaskmanagement',
                            'pgrep -fl backgroundtaskmanagement'
                        ],
                        'notes': 'BTM daemon monitors FSEvents for persistence. Can be stopped with SIGSTOP to bypass alerts. Agent alerts user in GUI'
                    }
                },
                {
                    'id': 'check-btm-agent',
                    'name': 'Check BTM Agent Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep BackgroundTaskManagementAgent | grep -v grep && ps -o state $(pgrep BackgroundTaskManagementAgent)',
                        'description': 'Check if BTM alert agent is running (not stopped)',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'BackgroundTaskManagementAgent': 'User-level BTM alerting agent',
                            'ps -o state': 'Show process state',
                            'pgrep': 'Get process ID'
                        },
                        'success_indicators': [
                            'Agent running with state "S" (sleeping) or "R" (running)',
                            'Process active'
                        ],
                        'failure_indicators': [
                            'State "T" - Agent STOPPED (bypass active!)',
                            'No agent process - Not running'
                        ],
                        'next_steps': [
                            'If state=T, agent bypassed with SIGSTOP',
                            'Check who sent SIGSTOP: ps -p $(pgrep BackgroundTaskManagementAgent) -o ppid,user,command',
                            'Resume: kill -SIGCONT <pid>'
                        ],
                        'alternatives': [
                            'ps -p $(pgrep BackgroundTaskManagementAgent) -o stat',
                            'launchctl list | grep BackgroundTaskManagement'
                        ],
                        'notes': 'Attackers can SIGSTOP the agent to prevent user alerts about new persistence. State "T" = stopped = bypass active'
                    }
                },
                {
                    'id': 'test-btm-reset',
                    'name': 'Test BTM Reset (Bypass Technique)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo sfltool resettbtm && echo "BTM database reset - new persistence will not alert until reboot"',
                        'description': 'Reset BTM database (bypass - stops alerting)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            'sfltool resettbtm': 'Reset BTM database',
                            'sudo': 'Requires root privileges'
                        },
                        'success_indicators': [
                            'Database reset successfully',
                            'New persistence installations won\'t alert until reboot'
                        ],
                        'failure_indicators': [
                            'Permission denied - Need root',
                            'Command not found'
                        ],
                        'next_steps': [
                            'Install persistence - no alerts until reboot',
                            'This is a known bypass technique',
                            'Database rebuilds on reboot'
                        ],
                        'alternatives': [
                            'Direct database deletion (requires FDA)',
                            'SIGSTOP BackgroundTaskManagementAgent (doesn\'t require root)'
                        ],
                        'notes': 'Known BTM bypass: resettbtm stops alerts for new persistence until reboot. Requires root. Alternative: SIGSTOP agent (no root needed)'
                    }
                },
                {
                    'id': 'review-btm-attributions',
                    'name': 'Review BTM Known Apps List',
                    'type': 'command',
                    'metadata': {
                        'command': 'plutil -p /System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/Resources/attributions.plist | grep -A 10 "us.zoom\\|com.microsoft" | head -30',
                        'description': 'Check Apple\'s whitelist of known persistence apps',
                        'tags': ['OSCP:LOW', 'ENUM'],
                        'flag_explanations': {
                            'attributions.plist': 'Apple-maintained list of known persistent apps',
                            'plutil -p': 'Pretty-print plist',
                            'grep zoom|microsoft': 'Sample entries'
                        },
                        'success_indicators': [
                            'List of bundle IDs with attributions',
                            'AssociatedBundleIdentifiers, Attribution, TeamIdentifier'
                        ],
                        'failure_indicators': [
                            'File not found - Old macOS',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Compare installed persistence to whitelist',
                            'Unknown persistence = suspicious',
                            'Check TeamIdentifiers of persistent apps'
                        ],
                        'alternatives': [
                            'cat attributions.plist (raw XML)',
                            'grep -i "TeamIdentifier" attributions.plist'
                        ],
                        'notes': 'attributions.plist contains known legitimate persistent apps. BTM uses this to provide context in alerts. Unknown apps are more suspicious'
                    }
                }
            ]
        }
