"""
iOS Protocol Handlers & URL Schemes plugin

Generates tasks for iOS app inter-communication security testing including:
- Custom URI handlers / deeplinks / custom schemes
- Universal links and AASA file analysis
- UIActivity sharing mechanisms
- UIPasteboard data leakage
- URL scheme fuzzing and hijacking
- Protocol handler validation
- App-to-app communication testing

Extracted from HackTricks: mobile-pentesting/ios-pentesting/
Generated by: CrackPot v1.0

Note: This plugin focuses on iOS application-level security testing.
Requires iOS device (physical/simulator) with testing tools installed.
Primarily for mobile application penetration testing engagements.
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class iOSProtocolsPlugin(ServicePlugin):
    """iOS protocol handlers and URL schemes security testing plugin"""

    @property
    def name(self) -> str:
        return "ios-protocols"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based; application-level testing

    @property
    def service_names(self) -> List[str]:
        return ['ios-app', 'ios-mobile', 'mobile-app', 'ios-protocols']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect iOS protocol handler testing context

        This plugin does not auto-detect from network scans.
        It's designed for manual invocation during iOS app pentesting.
        """
        # Manual-only plugin for iOS app security testing
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate iOS protocol handler security testing task tree"""

        app_name = service_info.get('app_name', 'target iOS app')
        bundle_id = service_info.get('bundle_id', 'com.example.app')
        ios_version = service_info.get('ios_version', 'iOS 14+')

        tasks = {
            'id': 'ios-protocols-test',
            'name': f'iOS Protocol Handler Security Testing: {app_name}',
            'type': 'parent',
            'children': []
        }

        # ========================================
        # SECTION 1: CUSTOM URI SCHEMES / DEEPLINKS
        # ========================================

        uri_schemes_tasks = {
            'id': 'custom-uri-schemes',
            'name': 'Custom URI Schemes & Deeplinks Testing',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Extract registered URL schemes from Info.plist
        uri_schemes_tasks['children'].append({
            'id': 'extract-url-schemes',
            'name': 'Extract Registered URL Schemes',
            'type': 'command',
            'metadata': {
                'command': f'plutil -p {app_name}.app/Info.plist | grep -A 10 CFBundleURLTypes',
                'description': 'Extract custom URL schemes from app Info.plist',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-p': 'Print property list in human-readable format',
                    'grep -A 10': 'Show 10 lines after match (captures full URL scheme config)',
                    'CFBundleURLTypes': 'Key containing registered URL schemes array'
                },
                'success_indicators': [
                    'CFBundleURLSchemes array displayed',
                    'Custom schemes identified (e.g., myapp://, customscheme://)',
                    'URL type roles and identifiers revealed'
                ],
                'failure_indicators': [
                    'No CFBundleURLTypes found (app may not use custom schemes)',
                    'Permission denied (need IPA extraction first)'
                ],
                'next_steps': [
                    'Document all discovered URL schemes',
                    'Test each scheme for parameter injection',
                    'Attempt URL hijacking by registering same scheme in test app'
                ],
                'alternatives': [
                    'Extract from IPA: unzip app.ipa && plutil -p Payload/*.app/Info.plist',
                    'Use iMazing/iFunBox to browse app bundle on device',
                    'Frida: ObjC.classes.NSBundle.mainBundle().infoDictionary().objectForKey_("CFBundleURLTypes")',
                    'Manual: Open Info.plist in Xcode'
                ],
                'notes': """
Custom URL schemes enable app-to-app communication using protocols like myapp://action?param=value.

Security Concerns:
- Any app can register the same scheme (hijacking risk)
- Parameters may not be validated (injection attacks)
- Sensitive actions triggered via deep links (e.g., skype://call?number=premium)

OSCP Context: While not directly applicable to network pentesting, understanding mobile
app attack surfaces is valuable for web-to-mobile attack chains (e.g., malicious website
triggering vulnerable app via custom scheme).
                """
            }
        })

        # Task 1.2: Extract LSApplicationQueriesSchemes
        uri_schemes_tasks['children'].append({
            'id': 'extract-query-schemes',
            'name': 'Extract Application Query Schemes (LSApplicationQueriesSchemes)',
            'type': 'command',
            'metadata': {
                'command': f'plutil -extract LSApplicationQueriesSchemes xml1 -o - {app_name}.app/Info.plist',
                'description': 'Extract schemes the app queries for (canOpenURL: whitelist)',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-extract': 'Extract specific key from plist',
                    'xml1': 'Output in XML format',
                    '-o -': 'Output to stdout',
                    'LSApplicationQueriesSchemes': 'iOS 9+ whitelist for canOpenURL: queries'
                },
                'success_indicators': [
                    'List of queryable schemes displayed',
                    'Target apps identified (fb://, twitter://, etc.)'
                ],
                'failure_indicators': [
                    'Key not found (app may not check for other apps)',
                    'Empty array'
                ],
                'next_steps': [
                    'Identify apps this app communicates with',
                    'Test if app behavior differs when target apps are/aren\'t installed',
                    'Check for hardcoded scheme assumptions in code'
                ],
                'alternatives': [
                    'grep -A 20 LSApplicationQueriesSchemes Info.plist',
                    'plutil -p Info.plist | grep -A 20 LSApplicationQueriesSchemes',
                    'Open in Xcode and inspect'
                ],
                'notes': """
LSApplicationQueriesSchemes (iOS 9+) prevents app enumeration by requiring apps to
declare which URL schemes they'll query with canOpenURL:.

Limit: Maximum 50 schemes can be declared.

Pentesting Value:
- Reveals app integrations and dependencies
- May expose undocumented features or partnerships
- Useful for understanding app ecosystem
                """
            }
        })

        # Task 1.3: Source code analysis - URL handling methods
        uri_schemes_tasks['children'].append({
            'id': 'analyze-url-handlers',
            'name': 'Analyze URL Handling Methods (Source Code)',
            'type': 'parent',
            'children': [
                {
                    'id': 'grep-openurl-methods',
                    'name': 'Locate openURL Handler Methods',
                    'type': 'command',
                    'metadata': {
                        'command': f'rabin2 -zq {app_name}.app/{app_name} | grep -iE "(openURL|handleOpenURL|continueUserActivity)"',
                        'description': 'Find URL handling method references in binary',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'IOS'],
                        'flag_explanations': {
                            '-zq': 'Extract strings quietly (no headers)',
                            'grep -iE': 'Case-insensitive extended regex',
                            'openURL': 'Modern URL handler method',
                            'handleOpenURL': 'Deprecated URL handler',
                            'continueUserActivity': 'Universal links handler'
                        },
                        'success_indicators': [
                            'URL handler method names found',
                            'Handler methods: application:openURL:options:',
                            'Deprecated methods identified'
                        ],
                        'alternatives': [
                            'Hopper Disassembler: Search for method names',
                            'Ghidra: Search strings for "openURL"',
                            'class-dump: Extract method signatures',
                            'Frida: Hook ObjC methods and log calls'
                        ],
                        'notes': """
Key URL handling methods to analyze:

Modern (iOS 9+):
- application:openURL:options:completionHandler:
- application:openURL:sourceApplication:annotation:
- scene:openURLContexts: (iOS 13+)

Deprecated (Security Risk if still used):
- application:handleOpenURL: (iOS 2-9)
- application:openURL:sourceApplication:annotation: (iOS 4.2-9)

Universal Links:
- application:continueUserActivity:restorationHandler:
                        """
                    }
                },
                {
                    'id': 'decompile-url-validation',
                    'name': 'Decompile URL Validation Logic',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reverse engineer URL parameter validation in handler methods',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Analyze URL handler implementations for security flaws:

1. Parameter Validation:
   - Are URL components validated before use?
   - Is there input sanitization?
   - Are parameters used in dangerous operations (file access, SQL, etc.)?

2. Authorization Checks:
   - Does the handler verify the source application?
   - Are sensitive actions gated by authentication?
   - Can arbitrary URLs trigger privileged operations?

3. Malformed URL Handling:
   - How does app handle missing parameters?
   - What happens with unexpected URL formats?
   - Are there crashes or undefined behavior?

Tools:
- Hopper Disassembler: Decompile to pseudo-code
- Ghidra: Full disassembly and decompilation
- class-dump: Extract Objective-C headers
- Frida: Dynamic hooking and tracing

Example Vulnerable Pattern:
myapp://download?file=<USER_INPUT>
If app doesn't validate, attacker could use:
myapp://download?file=../../../etc/passwd
                        """,
                        'alternatives': [
                            'Static: Hopper/Ghidra decompilation',
                            'Dynamic: Frida hook handlers and log parameters',
                            'Hybrid: Decompile + runtime testing'
                        ],
                        'success_indicators': [
                            'URL parsing logic identified',
                            'Validation checks (or lack thereof) documented',
                            'Vulnerable parameters discovered'
                        ]
                    }
                }
            ]
        })

        # Task 1.4: URL scheme fuzzing
        uri_schemes_tasks['children'].append({
            'id': 'fuzz-url-schemes',
            'name': 'Fuzz URL Schemes for Memory Corruption',
            'type': 'command',
            'metadata': {
                'command': f'frida -U SpringBoard -l ios-url-scheme-fuzzing.js',
                'description': 'Automated URL scheme fuzzing with Frida to detect crashes',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY', 'IOS'],
                'flag_explanations': {
                    '-U': 'Connect to USB device',
                    'SpringBoard': 'Target iOS SpringBoard process (handles URL opening)',
                    '-l': 'Load JavaScript fuzzing script'
                },
                'success_indicators': [
                    'Fuzzing loop running',
                    'Crash logs generated in /var/mobile/Library/Logs/CrashReporter/',
                    'Memory corruption detected'
                ],
                'failure_indicators': [
                    'Frida connection failed (need USB device or jailbreak)',
                    'No crashes after extensive fuzzing (app may be robust)'
                ],
                'next_steps': [
                    'Analyze crash logs for exploitability',
                    'Refine payloads based on crash patterns',
                    'Report memory corruption bugs to vendor'
                ],
                'alternatives': [
                    'Manual: xcrun simctl openurl booted "myapp://fuzz?param=AAAA..." (simulator)',
                    'Manual: Open Safari and navigate to myapp://... URLs',
                    'Custom fuzzer: Write Python script with pymobiledevice3',
                    'Burp Suite: Intercept web-to-app redirects and fuzz'
                ],
                'notes': """
Frida URL Scheme Fuzzing Script (ios-url-scheme-fuzzing.js):

function fuzz(appName, urlTemplate) {
    console.log("[*] Fuzzing " + appName);

    var payloads = [
        "A".repeat(100),
        "A".repeat(1000),
        "A".repeat(10000),
        "../../../etc/passwd",
        "javascript:alert(1)",
        "%00%00%00",
        "\\x00\\x00\\x00"
    ];

    payloads.forEach(function(payload) {
        var url = urlTemplate.replace("{0}", payload);
        console.log("[*] Testing: " + url);

        ObjC.classes.UIApplication.sharedApplication().openURL_options_completionHandler_(
            ObjC.classes.NSURL.URLWithString_(url),
            ObjC.classes.NSDictionary.dictionary(),
            null
        );

        // Check for crashes
        Thread.sleep(1);
    });
}

// Usage: fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")

Available at: https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/
                """
            }
        })

        # Task 1.5: URL scheme hijacking test
        uri_schemes_tasks['children'].append({
            'id': 'test-url-hijacking',
            'name': 'Test Custom URL Scheme Hijacking',
            'type': 'manual',
            'metadata': {
                'description': 'Create malicious app that registers same URL scheme to test hijacking',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH', 'IOS'],
                'notes': """
URL Scheme Hijacking Attack:

Vulnerability:
Multiple apps can register the same custom URL scheme (e.g., myapp://).
When a URL is opened, iOS presents an ambiguous dialog or may default to the
last-installed app, allowing malicious apps to intercept deep links.

Attack Scenario (OAuth Token Theft):
1. Legitimate app uses OAuth with custom scheme redirect: myapp://oauth/callback
2. Attacker creates malicious app that also registers myapp://
3. Malicious app opens ASWebAuthenticationSession with attacker-controlled page
4. OAuth flow redirects to myapp://oauth/callback?code=SECRET
5. Malicious app intercepts the callback and steals the OAuth code

Proof of Concept:
1. Create test Xcode project
2. Add to Info.plist:
   <key>CFBundleURLTypes</key>
   <array>
       <dict>
           <key>CFBundleURLSchemes</key>
           <array>
               <string>targetapp</string>  <!-- Same as victim app -->
           </array>
       </dict>
   </array>

3. Implement application:openURL:options: to log received URLs
4. Install on device alongside legitimate app
5. Trigger URL from Safari: targetapp://test?secret=123
6. Observe which app receives the URL

Mitigation:
- Use Universal Links (validated via AASA file) instead of custom schemes
- Validate source application in openURL handler
- Use iOS Keychain with kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly

Reference: https://evanconnelly.github.io/post/ios-oauth/
                """,
                'alternatives': [
                    'Use Frida to hook and intercept openURL calls',
                    'Monitor URL handling with Burp Suite mobile assistant',
                    'Create minimal Swift app for testing'
                ],
                'success_indicators': [
                    'Malicious app successfully intercepts URLs',
                    'OAuth token or sensitive data captured',
                    'User presented with app selection dialog'
                ],
                'failure_indicators': [
                    'iOS always routes to legitimate app (installation order may matter)',
                    'App validates source and rejects malicious app'
                ]
            }
        })

        tasks['children'].append(uri_schemes_tasks)

        # ========================================
        # SECTION 2: UNIVERSAL LINKS
        # ========================================

        universal_links_tasks = {
            'id': 'universal-links-test',
            'name': 'Universal Links Security Testing',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Extract associated domains
        universal_links_tasks['children'].append({
            'id': 'extract-associated-domains',
            'name': 'Extract Associated Domains Entitlement',
            'type': 'command',
            'metadata': {
                'command': f'plutil -extract com.apple.developer.associated-domains xml1 -o - {app_name}.app/{app_name}.entitlements',
                'description': 'Extract universal links domain associations from entitlements',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-extract': 'Extract specific entitlement key',
                    'com.apple.developer.associated-domains': 'Universal links domain list',
                    'xml1': 'XML output format',
                    '-o -': 'Print to stdout'
                },
                'success_indicators': [
                    'Associated domains array displayed',
                    'Domains prefixed with "applinks:" (e.g., applinks:example.com)'
                ],
                'failure_indicators': [
                    'Key not found (app doesn\'t use universal links)',
                    'Need to extract entitlements from compiled binary first'
                ],
                'next_steps': [
                    'Download AASA file for each domain',
                    'Validate AASA file configuration',
                    'Test if domains are properly configured'
                ],
                'alternatives': [
                    'Extract from IPA: codesign -d --entitlements :- app.app/ExecutableName',
                    'ldid -e app.app/ExecutableName (on jailbroken device)',
                    'Grep binary: strings app | grep "applinks:"',
                    'Xcode: View entitlements in project settings'
                ],
                'notes': """
Universal Links provide secure app-to-web associations verified via HTTPS.

Format: applinks:domain.com or applinks:*.domain.com

Advantages over custom URL schemes:
- Verified via apple-app-site-association (AASA) file
- Cannot be hijacked by other apps
- Fallback to Safari if app not installed
- No ambiguous app selection dialog

Example entitlement:
<key>com.apple.developer.associated-domains</key>
<array>
    <string>applinks:telegram.me</string>
    <string>applinks:t.me</string>
</array>
                """
            }
        })

        # Task 2.2: Retrieve AASA files
        universal_links_tasks['children'].append({
            'id': 'retrieve-aasa-files',
            'name': 'Retrieve Apple App Site Association (AASA) Files',
            'type': 'command',
            'metadata': {
                'command': 'for d in $(plutil -extract com.apple.developer.associated-domains xml1 -o - ent.xml | grep -oE "applinks:[^<]+" | cut -d":" -f2); do echo "[+] Fetching AASA for $d"; curl -sk "https://$d/.well-known/apple-app-site-association" | jq \'.\'; done',
                'description': 'Download and validate AASA files for all associated domains',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    'plutil -extract': 'Extract domains from entitlements',
                    'grep -oE': 'Extract applinks: entries',
                    'cut -d":" -f2': 'Extract domain name after applinks:',
                    'curl -sk': 'Download AASA (skip cert validation for testing)',
                    '/.well-known/apple-app-site-association': 'Standard AASA location (iOS 9+)',
                    'jq .': 'Pretty-print JSON'
                },
                'success_indicators': [
                    'AASA file downloaded successfully',
                    'Valid JSON structure',
                    'applinks section with paths defined'
                ],
                'failure_indicators': [
                    '404 Not Found (misconfigured server)',
                    'Invalid JSON (app won\'t work)',
                    'HTTP instead of HTTPS (iOS requires HTTPS)',
                    'Content-Type not application/json'
                ],
                'next_steps': [
                    'Analyze AASA for overly-broad wildcards',
                    'Test if server returns 404 for undefined paths',
                    'Check for subdomain wildcard vulnerabilities'
                ],
                'alternatives': [
                    'Try legacy location: curl -sk https://domain.com/apple-app-site-association',
                    'Use AASA validator: https://branch.io/resources/aasa-validator/',
                    'Use GetUniversal.link: https://getuniversal.link/',
                    'Manual: Browser download and inspect'
                ],
                'notes': """
AASA File Structure:

{
  "applinks": {
    "apps": [],
    "details": [
      {
        "appID": "TEAMID.com.example.app",
        "paths": [
          "/products/*",
          "/user/*/profile",
          "NOT /admin/*"
        ]
      }
    ]
  }
}

iOS 13+ (components syntax):
{
  "applinks": {
    "details": [{
      "appIDs": ["TEAMID.com.example.app"],
      "components": [
        {
          "/": "/buy/*",
          "?": { "id": "?*" }
        }
      ]
    }]
  }
}

Security Checks:
- File served over HTTPS only
- Content-Type: application/json
- No redirects (direct 200 OK)
- Signed by valid TLS certificate
                """
            }
        })

        # Task 2.3: AASA security audit
        universal_links_tasks['children'].append({
            'id': 'audit-aasa-security',
            'name': 'Security Audit of AASA Configuration',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-wildcard-paths',
                    'name': 'Check for Overly-Broad Wildcard Paths',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify dangerous wildcard patterns that allow universal link hijacking',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
AASA Wildcard Vulnerabilities:

Dangerous Patterns:
1. Root wildcard: "paths": ["/", "*"]
   - Allows ANY path on domain
   - Attacker can claim all universal links

2. Broad wildcards: "paths": ["/a/*"]
   - Any path under /a/ is claimable
   - Example: Temu.com bug (May 2025) - /a/* allowed hijacking

3. Query parameter wildcards (iOS 11+):
   "components": [{"?": {"*": "*"}}]
   - Matches any query parameters
   - Potential for parameter injection

4. Subdomain wildcards: "applinks:*.example.com"
   - If any subdomain is taken over, attacker gains universal links
   - S3 bucket takeovers, expired DNS, etc.

Audit Checklist:
[ ] No root-level wildcards (/, *)
[ ] Specific path prefixes only (/app/feature/*)
[ ] No subdomain wildcards unless all subdomains secured
[ ] Query parameter rules are restrictive
[ ] Trailing slashes handled consistently

Example Attack (Temu.com CVE):
AASA: "paths": ["/a/*"]
Attacker creates malicious app with same domain association
User clicks: https://temu.com/a/phishing?steal=credentials
Malicious app opens instead of legitimate app
                        """,
                        'alternatives': [
                            'Use AASA validator tools',
                            'Manual JSON inspection',
                            'Test with actual URL patterns'
                        ],
                        'success_indicators': [
                            'Dangerous wildcards identified',
                            'Overly-permissive rules documented',
                            'Potential hijacking vectors found'
                        ]
                    }
                },
                {
                    'id': 'test-undefined-paths',
                    'name': 'Test Server Response for Undefined Paths',
                    'type': 'command',
                    'metadata': {
                        'command': 'curl -I https://example.com/nonexistent-path-12345',
                        'description': 'Verify server returns 404 for paths not in AASA',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'IOS'],
                        'flag_explanations': {
                            '-I': 'HEAD request (fetch headers only)',
                            '/nonexistent-path-12345': 'Random path not in AASA file'
                        },
                        'success_indicators': [
                            'HTTP 404 Not Found returned',
                            'Server properly validates paths'
                        ],
                        'failure_indicators': [
                            'HTTP 200 OK for non-existent paths',
                            'HTTP 302 redirect to attacker-controlled content',
                            'Wildcard catch-all serving arbitrary content'
                        ],
                        'next_steps': [
                            'If 200/302 returned, test if arbitrary content can be hosted',
                            'Document server-side validation gaps',
                            'Test for open redirects'
                        ],
                        'alternatives': [
                            'Burp Suite: Send requests for undefined paths',
                            'Browser: Navigate to random paths and observe',
                            'Automated: Script to test all AASA paths + random paths'
                        ],
                        'notes': """
Server-Side Validation Importance:

Without proper 404 responses:
- Attackers can host content on allowed paths
- Phishing pages served via legitimate domain
- Session token theft via universal link

Example Attack:
AASA allows: /app/*
Server returns 200 for all /app/* paths (even if they don't exist)
Attacker hosts phishing page at: https://legitimate.com/app/phishing
Universal link opens in app, bypassing browser security
                        """
                    }
                },
                {
                    'id': 'check-wildcard-subdomains',
                    'name': 'Check for Subdomain Wildcard Vulnerabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if wildcard subdomains can be exploited via subdomain takeover',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Subdomain Wildcard Risk:

Entitlement: "applinks:*.example.com"
Vulnerability: If ANY subdomain is taken over, attacker gains universal links

Common Takeover Vectors:
1. Unused S3 buckets: old.example.com -> CNAME to s3 bucket (bucket deleted)
2. Expired DNS: test.example.com -> CNAME to heroku/github pages (expired)
3. Cloud services: staging.example.com -> Azure/GCP instance (deleted)

Testing:
1. Enumerate subdomains:
   - subfinder -d example.com
   - amass enum -d example.com
   - Certificate Transparency logs: crt.sh

2. Test each subdomain for takeover:
   - dig subdomain.example.com
   - Check for dangling CNAMEs
   - Attempt to claim service (S3, Heroku, etc.)

3. If takeover possible:
   - Create AASA file on taken-over subdomain
   - Register app with same domain association
   - Test universal link interception

Prevention:
- Avoid wildcard subdomains in entitlements
- Explicitly list only required subdomains
- Monitor DNS for stale records
                        """,
                        'alternatives': [
                            'Automated: subjack -w subdomains.txt -t 100 -timeout 30',
                            'Manual: Test each subdomain with dig/nslookup',
                            'Cloud-specific: Check S3/Azure/GCP for unclaimed names'
                        ],
                        'success_indicators': [
                            'Subdomain takeover successful',
                            'AASA file hostable on taken-over domain',
                            'Universal link hijacking demonstrated'
                        ]
                    }
                }
            ]
        })

        # Task 2.4: Analyze app-side universal link handling
        universal_links_tasks['children'].append({
            'id': 'analyze-continueUserActivity',
            'name': 'Analyze application:continueUserActivity Handler',
            'type': 'manual',
            'metadata': {
                'description': 'Reverse engineer universal link handler for validation issues',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH', 'IOS'],
                'notes': """
Universal Link Handler Analysis:

Method: application:continueUserActivity:restorationHandler:

Security Checks Required:
1. Verify activityType is NSUserActivityTypeBrowsingWeb
2. Validate URL scheme is HTTPS only
3. Validate host matches expected domains
4. Parse and sanitize URL parameters
5. Verify source application if needed

Vulnerable Pattern (CVE-2024-10474 - Mozilla Focus):
func application(_ app: UIApplication, open url: URL, ...) -> Bool {
    // NO VALIDATION - directly opens URL
    application.open(url, options: [:], completionHandler: nil)
    return true
}

Attack: Internal page can trigger arbitrary URLs bypassing URL bar checks

Secure Pattern:
func application(_ application: UIApplication,
                 continue userActivity: NSUserActivity,
                 restorationHandler: @escaping ([Any]?) -> Void) -> Bool {

    // 1. Verify activity type
    guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,
          let url = userActivity.webpageURL else {
        return false
    }

    // 2. Parse and validate URL
    guard let components = NSURLComponents(url: url, resolvingAgainstBaseURL: true),
          let path = components.path else {
        return false
    }

    // 3. Whitelist allowed hosts
    let allowedHosts = ["example.com", "www.example.com"]
    guard let host = components.host,
          allowedHosts.contains(host) else {
        return false
    }

    // 4. Validate and sanitize parameters
    guard let params = components.queryItems,
          let safeValue = params.first(where: { $0.name == "id" })?.value,
          safeValue.range(of: "^[0-9]+$", options: .regularExpression) != nil else {
        return false
    }

    // 5. Process securely
    processUniversalLink(path: path, id: safeValue)
    return true
}

Frida Hook for Testing:
var UIApplicationDelegate = ObjC.protocols.UIApplicationDelegate;
var continueUserActivity = UIApplicationDelegate.methods['- application:continueUserActivity:restorationHandler:'];

Interceptor.attach(continueUserActivity.implementation, {
    onEnter: function(args) {
        var activity = new ObjC.Object(args[3]);
        var url = activity.webpageURL();
        console.log("[*] Universal Link: " + url);
    }
});
                """,
                'alternatives': [
                    'Static: Hopper/Ghidra decompilation',
                    'Dynamic: Frida hook and log all parameters',
                    'Hybrid: Decompile + fuzz with malformed URLs'
                ],
                'success_indicators': [
                    'Handler implementation decompiled',
                    'Validation logic (or lack thereof) documented',
                    'Vulnerable parameters identified'
                ]
            }
        })

        # Task 2.5: Universal link validation tools
        universal_links_tasks['children'].append({
            'id': 'use-validation-tools',
            'name': 'Use Universal Link Validation Tools',
            'type': 'parent',
            'children': [
                {
                    'id': 'getuniversallink-validator',
                    'name': 'GetUniversal.link AASA Validator',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Validate AASA file configuration and test link behavior',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'IOS'],
                        'notes': """
GetUniversal.link: https://getuniversal.link/

Features:
- AASA file integrity validation
- Link behavior testing
- Apple indexing schedule prediction
- Dashboard for testing multiple links

Usage:
1. Enter domain: example.com
2. Tool fetches and validates AASA
3. Provides link testing interface
4. Shows when Apple will re-index AASA

Useful for:
- Quick validation without device
- Testing before deployment
- Debugging universal link issues
                        """,
                        'alternatives': [
                            'Branch.io AASA Validator',
                            'Apple Search API Validation Tool',
                            'Manual curl + jq validation'
                        ]
                    }
                },
                {
                    'id': 'knil-testing-tool',
                    'name': 'Knil - On-Device Universal Link Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test universal links directly on iOS device',
                        'tags': ['OSCP:MEDIUM', 'IOS'],
                        'notes': """
Knil: https://github.com/ethanhuang13/knil

Open-source iOS utility for testing universal links.

Features:
- Fetches AASA files for any domain
- Parses universal link configurations
- Tap-test every link directly on device
- Validates app associations

Installation:
1. Clone repo: git clone https://github.com/ethanhuang13/knil
2. Open in Xcode
3. Build and run on device

Usage:
1. Enter domain in app
2. App fetches AASA
3. Tap any link to test behavior
4. Observe which app opens (or Safari fallback)

Ideal for:
- Manual testing during pentests
- Validating AASA changes
- Debugging link handling
                        """
                    }
                },
                {
                    'id': 'universal-link-validator-cli',
                    'name': 'universal-link-validator (CLI)',
                    'type': 'command',
                    'metadata': {
                        'command': 'npx universal-link-validator https://example.com',
                        'description': 'CLI tool for strict AASA conformance checks',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'IOS'],
                        'flag_explanations': {
                            'npx': 'Run npm package without installing',
                            'universal-link-validator': 'AASA validation tool',
                            'https://example.com': 'Domain to validate'
                        },
                        'success_indicators': [
                            'AASA file passes validation',
                            'No dangerous wildcards detected',
                            'Strict conformance checks passed'
                        ],
                        'alternatives': [
                            'Install globally: npm install -g universal-link-validator',
                            'Web interface: https://github.com/urbangems/universal-link-validator'
                        ],
                        'notes': """
Tool: https://github.com/urbangems/universal-link-validator

Features:
- Strict AASA conformance validation
- Highlights dangerous wildcards
- CLI and web interface
- JSON output for automation

Example Output:
✓ AASA file found at /.well-known/apple-app-site-association
✓ Valid JSON structure
✗ WARNING: Wildcard path detected: "/*"
✗ FAIL: Overly-permissive configuration
                        """
                    }
                }
            ]
        })

        tasks['children'].append(universal_links_tasks)

        # ========================================
        # SECTION 3: UIActivity SHARING
        # ========================================

        uiactivity_tasks = {
            'id': 'uiactivity-sharing-test',
            'name': 'UIActivity Sharing Security Testing',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Identify shared data types
        uiactivity_tasks['children'].append({
            'id': 'identify-activity-items',
            'name': 'Identify Shared Data via UIActivityViewController',
            'type': 'command',
            'metadata': {
                'command': f'rabin2 -zq {app_name}.app/{app_name} | grep -i activityItems',
                'description': 'Find UIActivityViewController initialization strings',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-zq': 'Extract strings quietly',
                    'grep -i activityItems': 'Find UIActivityViewController init methods'
                },
                'success_indicators': [
                    'initWithActivityItems:applicationActivities: found',
                    'Activity sharing implementation identified'
                ],
                'alternatives': [
                    'class-dump: Extract method signatures',
                    'Hopper: Search for UIActivityViewController references',
                    'Frida: Hook init methods and log parameters'
                ],
                'notes': """
UIActivity Sharing (iOS 6+):

Apps share data via system share sheet using UIActivityViewController.

Initialized with:
- activityItems: Array of items to share (text, URLs, images, custom)
- applicationActivities: Custom sharing activities (optional)

Security Concerns:
1. Sensitive data exposure via share sheet
2. Unintended data leakage to third-party apps
3. Pasteboard persistence of shared data
4. No user awareness of data recipients

Example:
let items = [sensitiveURL, privateText, userPhoto]
let activityVC = UIActivityViewController(activityItems: items,
                                          applicationActivities: nil)
present(activityVC, animated: true)

Built-in Activities:
- UIActivity.ActivityType.postToFacebook
- UIActivity.ActivityType.postToTwitter
- UIActivity.ActivityType.message
- UIActivity.ActivityType.mail
- UIActivity.ActivityType.copyToPasteboard
- UIActivity.ActivityType.airDrop
                """
            }
        })

        # Task 3.2: Analyze excluded activity types
        uiactivity_tasks['children'].append({
            'id': 'check-excluded-activities',
            'name': 'Check Excluded Activity Types',
            'type': 'manual',
            'metadata': {
                'description': 'Identify which sharing options are disabled and why',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'IOS'],
                'notes': """
Excluded Activity Types Analysis:

Property: excludedActivityTypes
Purpose: Prevent specific sharing methods

Example:
activityVC.excludedActivityTypes = [
    .postToFacebook,
    .copyToPasteboard,
    .airDrop
]

Analysis Questions:
1. Why are certain activities excluded?
   - Privacy concerns?
   - Data sensitivity?
   - Regulatory compliance?

2. Are the right activities excluded?
   - Should clipboard access be blocked?
   - Is AirDrop secure enough for this data?
   - Are social media posts appropriate?

3. What's NOT excluded?
   - Can sensitive data be copied to pasteboard?
   - Can data be AirDropped to strangers?
   - Can data be exported to unknown apps?

Frida Hook to Monitor:
var activityVC = ObjC.classes.UIActivityViewController;
Interceptor.attach(activityVC['- setExcludedActivityTypes:'].implementation, {
    onEnter: function(args) {
        var excluded = new ObjC.Object(args[2]);
        console.log("[*] Excluded activities: " + excluded);
    }
});

Red Flags:
- No exclusions (all sharing methods allowed)
- Pasteboard not excluded for sensitive data
- AirDrop allowed for confidential information
                """
            }
        })

        # Task 3.3: Hook share operations
        uiactivity_tasks['children'].append({
            'id': 'hook-share-operations',
            'name': 'Dynamic Hooking of Share Operations',
            'type': 'command',
            'metadata': {
                'command': f'frida -U -f {bundle_id} -l hook-uiactivity.js --no-pause',
                'description': 'Hook UIActivityViewController to intercept shared data',
                'tags': ['OSCP:HIGH', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-U': 'Connect to USB device',
                    '-f': 'Spawn app with bundle ID',
                    bundle_id: 'App bundle identifier (com.example.app)',
                    '-l': 'Load Frida script',
                    '--no-pause': 'Don\'t pause at startup'
                },
                'success_indicators': [
                    'Frida attached to app',
                    'Share operations logged',
                    'Activity items captured'
                ],
                'alternatives': [
                    'Objection: ios hooking watch class UIActivityViewController',
                    'Manual: Xcode debugger with breakpoints',
                    'Proxy: Burp Suite mobile assistant'
                ],
                'notes': """
Frida Script (hook-uiactivity.js):

// Hook UIActivityViewController initialization
var UIActivityViewController = ObjC.classes.UIActivityViewController;

Interceptor.attach(
    UIActivityViewController['- initWithActivityItems:applicationActivities:'].implementation,
    {
        onEnter: function(args) {
            console.log("[*] UIActivityViewController initialized");

            // Extract activity items (NSArray)
            var items = new ObjC.Object(args[2]);
            console.log("[*] Activity items count: " + items.count());

            for (var i = 0; i < items.count(); i++) {
                var item = items.objectAtIndex_(i);
                console.log("[*] Item " + i + ": " + item);

                // Check type
                if (item.isKindOfClass_(ObjC.classes.NSString)) {
                    console.log("    [TEXT] " + item.toString());
                } else if (item.isKindOfClass_(ObjC.classes.NSURL)) {
                    console.log("    [URL] " + item.absoluteString());
                } else if (item.isKindOfClass_(ObjC.classes.UIImage)) {
                    console.log("    [IMAGE] Size: " + item.size());
                }
            }

            // Extract custom activities
            var customActivities = new ObjC.Object(args[3]);
            if (customActivities && !customActivities.isNull()) {
                console.log("[*] Custom activities: " + customActivities);
            }
        }
    }
);

// Hook excluded activity types
Interceptor.attach(
    UIActivityViewController['- setExcludedActivityTypes:'].implementation,
    {
        onEnter: function(args) {
            var excluded = new ObjC.Object(args[2]);
            console.log("[*] Excluded activity types:");
            for (var i = 0; i < excluded.count(); i++) {
                console.log("    - " + excluded.objectAtIndex_(i));
            }
        }
    }
);

console.log("[*] UIActivity hooks installed");
                """
            }
        })

        # Task 3.4: Test receiving shared data
        uiactivity_tasks['children'].append({
            'id': 'test-receiving-data',
            'name': 'Test App\'s Handling of Received Share Data',
            'type': 'manual',
            'metadata': {
                'description': 'Test how app validates and processes data from other apps via share sheet',
                'tags': ['OSCP:HIGH', 'MANUAL', 'IOS'],
                'notes': """
Testing Data Reception:

Apps declare receivable data types in Info.plist:

1. UTExportedTypeDeclarations: Custom types this app exports
2. UTImportedTypeDeclarations: Third-party types this app handles
3. CFBundleDocumentTypes: Document types app can open

Test Methodology:

1. Identify accepted types from Info.plist:
   plutil -p Info.plist | grep -E "(UTExportedTypeDeclarations|UTImportedTypeDeclarations|CFBundleDocumentTypes)"

2. Create test files of each accepted type:
   - Text files
   - Images
   - PDFs
   - Custom formats

3. Share to app from another app:
   - Use iOS Files app
   - Use email attachment
   - Use AirDrop
   - Trigger "Open with..." dialog

4. Hook app's receiver method:
   - application:openURL:options:
   - application:openURL:sourceApplication:annotation:

5. Test with malformed files:
   - Oversized files
   - Malformed headers
   - Path traversal filenames: ../../../etc/passwd
   - Null bytes in filenames
   - Special characters

6. Monitor app behavior:
   - Crashes (fuzzing success)
   - Error messages (validation details)
   - File system writes (where does data go?)

Frida Hook for Receiver:
var AppDelegate = ObjC.classes.AppDelegate;

Interceptor.attach(
    AppDelegate['- application:openURL:options:'].implementation,
    {
        onEnter: function(args) {
            var url = new ObjC.Object(args[3]);
            var options = new ObjC.Object(args[4]);

            console.log("[*] Receiving shared data:");
            console.log("    URL: " + url);
            console.log("    Options: " + options);

            // Extract source app
            var sourceApp = options.objectForKey_("UIApplicationOpenURLOptionsSourceApplicationKey");
            if (sourceApp) {
                console.log("    Source: " + sourceApp);
            }
        }
    }
);

Security Checks:
[ ] File type validation before processing
[ ] File size limits enforced
[ ] Filename sanitization (no path traversal)
[ ] Virus scanning (if applicable)
[ ] Source app verification
[ ] Graceful error handling (no crashes)
                """
            }
        })

        tasks['children'].append(uiactivity_tasks)

        # ========================================
        # SECTION 4: UIPasteboard SECURITY
        # ========================================

        pasteboard_tasks = {
            'id': 'uipasteboard-test',
            'name': 'UIPasteboard Data Leakage Testing',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Monitor general pasteboard
        pasteboard_tasks['children'].append({
            'id': 'monitor-general-pasteboard',
            'name': 'Monitor General Pasteboard Access',
            'type': 'command',
            'metadata': {
                'command': f'objection -g {bundle_id} explore --startup-command "ios pasteboard monitor"',
                'description': 'Monitor systemwide pasteboard for data leakage (5-second polling)',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'IOS'],
                'flag_explanations': {
                    '-g': 'Gadget mode (connect to app)',
                    bundle_id: 'Target app bundle ID',
                    'explore': 'Start interactive shell',
                    '--startup-command': 'Run command on startup',
                    'ios pasteboard monitor': 'Objection pasteboard monitoring'
                },
                'success_indicators': [
                    'Pasteboard monitor running',
                    'Changes detected and logged',
                    'Sensitive data captured'
                ],
                'failure_indicators': [
                    'No pasteboard access (app doesn\'t use it)',
                    'Objection connection failed'
                ],
                'next_steps': [
                    'Document what data is copied to pasteboard',
                    'Check if sensitive data persists across app restarts',
                    'Test if data is accessible to other apps'
                ],
                'alternatives': [
                    'Frida custom script (see notes)',
                    'Manual: Copy data in app, then check in another app',
                    'Xcode debugger: Print UIPasteboard.general.string'
                ],
                'notes': """
UIPasteboard Security Concerns:

1. Systemwide General Pasteboard:
   - Accessible by ANY app when in foreground (iOS 9+)
   - Persists across device restarts (iOS 10+)
   - No user permission required
   - No visibility into which apps access it

2. Custom/Named Pasteboards:
   - Shared only within same team ID (iOS 10+)
   - Do NOT persist (cleared on app termination)
   - Less risky but still analyzable

Frida Pasteboard Monitor (Alternative):

const UIPasteboard = ObjC.classes.UIPasteboard;
const Pasteboard = UIPasteboard.generalPasteboard();
var items = "";
var count = Pasteboard.changeCount().toString();

setInterval(function () {
  const currentCount = Pasteboard.changeCount().toString();
  const currentItems = Pasteboard.items().toString();

  if (currentCount === count) {
    return;
  }

  items = currentItems;
  count = currentCount;

  console.log(
    "[* Pasteboard changed] count: " +
      count +
      " hasStrings: " +
      Pasteboard.hasStrings().toString() +
      " hasURLs: " +
      Pasteboard.hasURLs().toString() +
      " hasImages: " +
      Pasteboard.hasImages().toString()
  );
  console.log(items);
}, 1000 * 5);  // Poll every 5 seconds

Save as pasteboard-monitor.js and run:
frida -U -f com.example.app -l pasteboard-monitor.js --no-pause
                """
            }
        })

        # Task 4.2: Check for custom pasteboards
        pasteboard_tasks['children'].append({
            'id': 'identify-custom-pasteboards',
            'name': 'Identify Custom Pasteboards',
            'type': 'command',
            'metadata': {
                'command': f'rabin2 -zq {app_name}.app/{app_name} | grep -iE "(pasteboardWithName|pasteboardWithUniqueName)"',
                'description': 'Find custom pasteboard creation in app binary',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'IOS'],
                'flag_explanations': {
                    '-zq': 'Extract strings quietly',
                    'pasteboardWithName:create:': 'Named pasteboard creation',
                    'pasteboardWithUniqueName': 'Unique pasteboard creation'
                },
                'success_indicators': [
                    'Custom pasteboard methods found',
                    'Named pasteboards identified'
                ],
                'alternatives': [
                    'Hopper: Search for UIPasteboard class usage',
                    'class-dump: Extract pasteboard-related methods',
                    'Frida: Hook pasteboard creation methods'
                ],
                'notes': """
Custom Pasteboards:

Creation Methods:
1. pasteboardWithName:create: - Named pasteboard
2. pasteboardWithUniqueName - Auto-generated unique name

Security Notes:
- Named pasteboards shared only within same team ID (iOS 10+)
- Persistence is DEPRECATED (don't use setPersistent:)
- Should use shared containers instead

Frida Hook:
var UIPasteboard = ObjC.classes.UIPasteboard;

// Hook named pasteboard creation
Interceptor.attach(
    UIPasteboard['+ pasteboardWithName:create:'].implementation,
    {
        onEnter: function(args) {
            var name = new ObjC.Object(args[2]);
            var create = args[3];
            console.log("[*] Creating named pasteboard: " + name);
            console.log("    Create if not exists: " + create);
        },
        onLeave: function(retval) {
            var pb = new ObjC.Object(retval);
            console.log("    Name: " + pb.name());
        }
    }
);

// Hook unique pasteboard creation
Interceptor.attach(
    UIPasteboard['+ pasteboardWithUniqueName'].implementation,
    {
        onLeave: function(retval) {
            var pb = new ObjC.Object(retval);
            console.log("[*] Created unique pasteboard: " + pb.name());
        }
    }
);
                """
            }
        })

        # Task 4.3: Check for persistence (deprecated)
        pasteboard_tasks['children'].append({
            'id': 'check-pasteboard-persistence',
            'name': 'Check for Deprecated Pasteboard Persistence',
            'type': 'manual',
            'metadata': {
                'description': 'Verify app does not use deprecated persistent pasteboards',
                'tags': ['OSCP:LOW', 'MANUAL', 'IOS'],
                'notes': """
Deprecated: setPersistent: (iOS 10+)

Security Issue:
Persistent named pasteboards stored data permanently, creating privacy risks.

Modern Alternative:
Use shared containers for team-scoped data sharing.

Static Check:
grep -r "setPersistent" source_code/

Frida Hook:
var UIPasteboard = ObjC.classes.UIPasteboard;
var setPersistent = UIPasteboard['- setPersistent:'];

if (setPersistent) {
    Interceptor.attach(setPersistent.implementation, {
        onEnter: function(args) {
            var persistent = args[2];
            console.log("[!] DEPRECATED: setPersistent called: " + persistent);
            console.log("    Recommendation: Use shared containers instead");
        }
    });
} else {
    console.log("[+] setPersistent not available (iOS 10+ deprecation)");
}

Recommendation:
If found, report to developers to migrate to shared containers.
                """
            }
        })

        # Task 4.4: Test pasteboard data types
        pasteboard_tasks['children'].append({
            'id': 'analyze-pasteboard-data-types',
            'name': 'Analyze Pasteboard Data Types',
            'type': 'manual',
            'metadata': {
                'description': 'Identify what types of data app writes to/reads from pasteboard',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'IOS'],
                'notes': """
Pasteboard Data Type Analysis:

Standard Types:
- String: UIPasteboard.general.string
- URL: UIPasteboard.general.url
- Image: UIPasteboard.general.image
- Color: UIPasteboard.general.color

Custom Types:
- setData:forPasteboardType: (custom UTI)
- setItems:options: (multiple items with custom types)

Frida Script to Monitor Data Types:

var UIPasteboard = ObjC.classes.UIPasteboard;
var generalPB = UIPasteboard.generalPasteboard();

// Hook string setter
Interceptor.attach(generalPB['- setString:'].implementation, {
    onEnter: function(args) {
        var str = new ObjC.Object(args[2]);
        console.log("[*] Pasteboard.string SET: " + str);

        // Check for sensitive patterns
        if (str.toString().match(/password|token|api[_-]?key|secret/i)) {
            console.log("[!] SENSITIVE DATA DETECTED IN PASTEBOARD");
        }
    }
});

// Hook URL setter
Interceptor.attach(generalPB['- setURL:'].implementation, {
    onEnter: function(args) {
        var url = new ObjC.Object(args[2]);
        console.log("[*] Pasteboard.URL SET: " + url.absoluteString());
    }
});

// Hook custom data setter
Interceptor.attach(generalPB['- setData:forPasteboardType:'].implementation, {
    onEnter: function(args) {
        var data = new ObjC.Object(args[2]);
        var type = new ObjC.Object(args[3]);
        console.log("[*] Pasteboard custom data SET:");
        console.log("    Type: " + type);
        console.log("    Data length: " + data.length());
    }
});

// Hook setItems (multiple items)
Interceptor.attach(generalPB['- setItems:options:'].implementation, {
    onEnter: function(args) {
        var items = new ObjC.Object(args[2]);
        var options = new ObjC.Object(args[3]);

        console.log("[*] Pasteboard.setItems called:");
        console.log("    Item count: " + items.count());

        // Check options for expiry/local-only
        if (options && !options.isNull()) {
            console.log("    Options: " + options);
        }
    }
});

Security Analysis Questions:
1. What sensitive data is copied to pasteboard?
   - Passwords, tokens, API keys?
   - Personal information (SSN, credit cards)?
   - Session cookies?

2. Is data cleared after use?
   - UIPasteboard.general.string = nil
   - Or does it persist indefinitely?

3. Are expiry options used? (iOS 10+)
   - UIPasteboardOptionExpirationDate
   - UIPasteboardOptionLocalOnly

4. Can other apps access this data?
   - Test by copying in app, then checking from another app
                """
            }
        })

        # Task 4.5: Test Universal Clipboard (cross-device)
        pasteboard_tasks['children'].append({
            'id': 'test-universal-clipboard',
            'name': 'Test Universal Clipboard Data Exposure',
            'type': 'manual',
            'metadata': {
                'description': 'Test if sensitive data leaks across devices via Handoff/Universal Clipboard',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'IOS'],
                'notes': """
Universal Clipboard (iOS 10+):

Feature: Pasteboard content automatically synced across iCloud-connected devices via Handoff.

Security Concern:
Sensitive data copied on iPhone automatically appears on Mac/iPad without user awareness.

Testing:
1. Enable Handoff on test devices (Settings > General > AirPlay & Handoff)
2. Sign in to same iCloud account on multiple devices
3. Copy sensitive data in target app on Device A
4. Check pasteboard on Device B: ⌘V to paste

Disabling Universal Clipboard (Developer Perspective):
UIPasteboard.general.setItems([["item": data]],
                              options: [.localOnly: true])

Options (iOS 10+):
- UIPasteboardOptionLocalOnly: Prevent sync to other devices
- UIPasteboardOptionExpirationDate: Auto-delete after date

Frida Check for Options:
Interceptor.attach(
    ObjC.classes.UIPasteboard['- setItems:options:'].implementation,
    {
        onEnter: function(args) {
            var options = new ObjC.Object(args[3]);

            if (options.objectForKey_("UIPasteboardOptionLocalOnly")) {
                console.log("[+] Local-only option SET (won't sync)");
            } else {
                console.log("[!] No local-only option (WILL SYNC via Universal Clipboard)");
            }

            var expiry = options.objectForKey_("UIPasteboardOptionExpirationDate");
            if (expiry) {
                console.log("[+] Expiration set: " + expiry);
            } else {
                console.log("[!] No expiration (persists indefinitely)");
            }
        }
    }
);

Recommendation:
Sensitive data should ALWAYS use:
- .localOnly to prevent cross-device sync
- .expirationDate to auto-clear
- Or avoid pasteboard entirely for sensitive data
                """
            }
        })

        tasks['children'].append(pasteboard_tasks)

        # ========================================
        # SECTION 5: GENERAL TESTING METHODOLOGY
        # ========================================

        methodology_tasks = {
            'id': 'ios-protocol-methodology',
            'name': 'General iOS Protocol Testing Methodology',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Static analysis workflow
        methodology_tasks['children'].append({
            'id': 'static-analysis-workflow',
            'name': 'Static Analysis Workflow',
            'type': 'manual',
            'metadata': {
                'description': 'Systematic static analysis of iOS app protocol handlers',
                'tags': ['OSCP:HIGH', 'MANUAL', 'METHODOLOGY', 'IOS'],
                'notes': """
iOS Protocol Handler Static Analysis:

Phase 1: IPA Extraction & Unpacking
1. Obtain IPA file:
   - Jailbroken device: Copy from /var/containers/Bundle/Application/
   - iTunes backup: Use iMazing/iFunBox
   - App Store download: Use tools like ipatool

2. Unpack IPA:
   unzip app.ipa
   cd Payload/
   ls -la *.app/

Phase 2: Info.plist Analysis
1. Extract Info.plist:
   plutil -p app.app/Info.plist > info.txt

2. Check for URL schemes:
   grep -A 10 CFBundleURLTypes info.txt

3. Check for universal links:
   grep -A 10 "com.apple.developer.associated-domains" info.txt

4. Check for document types:
   grep -A 10 "CFBundleDocumentTypes" info.txt

5. Check for query schemes:
   grep -A 10 "LSApplicationQueriesSchemes" info.txt

Phase 3: Entitlements Extraction
1. Extract from binary:
   codesign -d --entitlements :- app.app/ExecutableName > entitlements.xml

2. Or use ldid (jailbroken):
   ldid -e app.app/ExecutableName > entitlements.xml

3. Parse with plutil:
   plutil -p entitlements.xml

Phase 4: Binary Analysis
1. Extract strings:
   rabin2 -zq app.app/ExecutableName > strings.txt

2. Search for protocol handlers:
   grep -iE "(openURL|handleOpenURL|continueUserActivity|activityItems|pasteboard)" strings.txt

3. Class dump:
   class-dump app.app/ExecutableName > headers.h

4. Search headers:
   grep -E "(openURL|UIActivity|Pasteboard)" headers.h

Phase 5: Decompilation
1. Hopper Disassembler:
   - Load binary
   - Search for method: application:openURL:options:
   - Generate pseudo-code
   - Analyze parameter validation

2. Ghidra:
   - Import iOS binary
   - Analyze Objective-C runtime
   - Locate URL handlers
   - Review control flow

Phase 6: Source Code Review (if available)
1. Search for vulnerable patterns:
   grep -r "openURL.*options" source/
   grep -r "UIActivityViewController" source/
   grep -r "UIPasteboard.general" source/

2. Analyze validation logic:
   - NSURLComponents parsing
   - Host/scheme whitelisting
   - Parameter sanitization

Phase 7: Documentation
[ ] URL schemes identified
[ ] Universal link domains identified
[ ] Handler implementations located
[ ] Validation logic analyzed
[ ] Vulnerabilities documented
[ ] PoC payloads created
                """
            }
        })

        # Task 5.2: Dynamic analysis workflow
        methodology_tasks['children'].append({
            'id': 'dynamic-analysis-workflow',
            'name': 'Dynamic Analysis Workflow',
            'type': 'manual',
            'metadata': {
                'description': 'Systematic runtime testing of iOS protocol handlers',
                'tags': ['OSCP:HIGH', 'MANUAL', 'METHODOLOGY', 'IOS'],
                'notes': """
iOS Protocol Handler Dynamic Analysis:

Phase 1: Environment Setup
1. Device preparation:
   - Jailbroken device (checkra1n, unc0ver, Taurine)
   - Or iOS Simulator (limited capabilities)

2. Install Frida:
   # On device (via Cydia/Sileo):
   - Add repo: https://build.frida.re
   - Install: Frida

   # On host:
   pip3 install frida-tools

3. Verify connection:
   frida-ps -U

4. Install Objection (optional):
   pip3 install objection

Phase 2: App Instrumentation
1. Identify bundle ID:
   frida-ps -Ua

2. Attach to app:
   frida -U -f com.example.app --no-pause

3. Or use Objection:
   objection -g com.example.app explore

Phase 3: Protocol Handler Hooking
1. Hook URL handlers:
   # Load Frida script
   frida -U -f com.example.app -l hook-protocols.js --no-pause

2. Hook pasteboard access:
   frida -U -f com.example.app -l pasteboard-monitor.js --no-pause

3. Hook UIActivity:
   frida -U -f com.example.app -l hook-uiactivity.js --no-pause

Phase 4: Manual Testing
1. Custom URL schemes:
   # Safari navigation
   Open Safari → Navigate to: myapp://test?param=value

   # Command-line (simulator):
   xcrun simctl openurl booted "myapp://test"

   # Command-line (device):
   idevicedebug run com.example.app --args myapp://test

2. Universal links:
   # Safari navigation
   Navigate to: https://example.com/path

   # Notes app
   Type link → Tap to open

3. Share sheet:
   # Share from Safari
   Safari → Share button → Select app

   # Share from Photos
   Photos → Select image → Share → Select app

4. Pasteboard:
   # Copy in one app
   App A → Copy text

   # Paste in another
   App B → Paste → Observe

Phase 5: Fuzzing
1. URL scheme fuzzing:
   myapp://test?param=AAAA...  (100, 1000, 10000 A's)
   myapp://test?param=../../../etc/passwd
   myapp://test?param=%00%00%00
   myapp://test?param=javascript:alert(1)

2. Universal link fuzzing:
   https://example.com/%00%00%00
   https://example.com/../../etc/passwd
   https://example.com/path?param=<script>

3. Share data fuzzing:
   - Oversized files
   - Malformed images (corrupted headers)
   - Files with path traversal names
   - Null bytes in filenames

Phase 6: Crash Monitoring
1. Monitor crash logs:
   # On device
   cd /var/mobile/Library/Logs/CrashReporter/
   tail -f *.crash

2. Analyze crashes:
   # Symbolicate crash logs
   symbolicatecrash crash.crash app.app.dSYM

3. Identify exploitability:
   - Stack overflow?
   - Heap corruption?
   - Use-after-free?

Phase 7: Network Monitoring (Universal Links)
1. Proxy setup:
   Device Settings → Wi-Fi → HTTP Proxy → Burp Suite

2. Monitor AASA requests:
   - Observe Apple CDN requests for AASA files
   - Intercept and modify AASA responses
   - Test app behavior with tampered AASA

Phase 8: Documentation
[ ] Hooks successfully installed
[ ] Handler calls intercepted and logged
[ ] Parameter values extracted
[ ] Vulnerabilities confirmed
[ ] Crashes reproduced
[ ] Exploitability assessed
                """
            }
        })

        # Task 5.3: Reporting template
        methodology_tasks['children'].append({
            'id': 'vulnerability-reporting',
            'name': 'iOS Protocol Handler Vulnerability Reporting',
            'type': 'manual',
            'metadata': {
                'description': 'Template for reporting iOS protocol handler vulnerabilities',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'DOCUMENTATION', 'IOS'],
                'notes': """
iOS Protocol Vulnerability Report Template:

TITLE:
[App Name] - [Vulnerability Type] in [Protocol Handler]

Example: "MyBankApp - Parameter Injection in Custom URL Scheme Handler"

SEVERITY:
[ ] Critical - Remote code execution, authentication bypass
[ ] High - Sensitive data exposure, privilege escalation
[ ] Medium - Information disclosure, limited impact
[ ] Low - Minor privacy issue

AFFECTED VERSIONS:
App Version: X.Y.Z
iOS Version: iOS 14.0 - 16.4
Bundle ID: com.example.app

VULNERABILITY DETAILS:
1. Vulnerability Type:
   [ ] Custom URL scheme hijacking
   [ ] Universal link misconfiguration
   [ ] Parameter injection in URL handler
   [ ] Pasteboard data leakage
   [ ] UIActivity sensitive data exposure
   [ ] Missing input validation
   [ ] Path traversal
   [ ] Memory corruption

2. Root Cause:
   [Detailed technical explanation]

3. Vulnerable Component:
   File: AppDelegate.swift
   Method: application(_:open:options:)
   Lines: 123-145

PROOF OF CONCEPT:
1. Prerequisites:
   - iOS device with app installed
   - [Any other requirements]

2. Steps to Reproduce:
   1) Open Safari on iOS device
   2) Navigate to: myapp://vulnerable?param=../../../etc/passwd
   3) Observe: App crashes / Data disclosed / Unauthorized action

3. PoC Payload:
   myapp://transfer?amount=1000000&to=attacker@evil.com

4. Expected Behavior:
   App should validate parameters and reject malformed URLs.

5. Actual Behavior:
   App processes URL without validation, performing unauthorized transfer.

IMPACT:
- User Impact: [What can attacker do to users?]
- Business Impact: [Financial/reputation damage?]
- Exploitability: [Easy/Medium/Hard]

Example:
"An attacker can craft a malicious link that, when clicked by a victim,
initiates an unauthorized bank transfer without authentication. The link
can be distributed via SMS, email, or malicious websites."

REMEDIATION:
1. Immediate Fix:
   - Validate URL scheme matches expected value
   - Whitelist allowed URL hosts/paths
   - Sanitize all URL parameters before use
   - Require user confirmation for sensitive actions

2. Code Example:
   ```swift
   func application(_ app: UIApplication,
                    open url: URL,
                    options: [UIApplication.OpenURLOptionsKey : Any]) -> Bool {

       // 1. Validate scheme
       guard url.scheme == "myapp" else {
           return false
       }

       // 2. Parse components safely
       guard let components = URLComponents(url: url, resolvingAgainstBaseURL: true),
             let host = components.host,
             let queryItems = components.queryItems else {
           return false
       }

       // 3. Whitelist allowed hosts
       let allowedHosts = ["transfer", "settings", "profile"]
       guard allowedHosts.contains(host) else {
           return false
       }

       // 4. Validate and sanitize parameters
       guard let amountStr = queryItems.first(where: { $0.name == "amount" })?.value,
             let amount = Decimal(string: amountStr),
             amount > 0 && amount <= 1000 else {
           return false
       }

       // 5. Require user confirmation for sensitive actions
       showConfirmation(action: "transfer", amount: amount) { confirmed in
           if confirmed {
               processTransfer(amount: amount)
           }
       }

       return true
   }
   ```

3. Long-term Recommendations:
   - Migrate from custom URL schemes to Universal Links
   - Implement proper entitlement validation
   - Use system authentication (Face ID/Touch ID) before sensitive actions
   - Add rate limiting to prevent automated abuse
   - Log all URL handler invocations for monitoring

REFERENCES:
- OWASP MASVS: MASVS-PLATFORM-1, MASVS-PLATFORM-2
- Apple Documentation: [Link]
- Similar CVEs: CVE-2024-10474 (Mozilla Focus)

DISCLOSURE TIMELINE:
- [Date] - Vulnerability discovered
- [Date] - Vendor notified
- [Date] - Vendor acknowledgment
- [Date] - Fix released
- [Date] - Public disclosure
                """
            }
        })

        tasks['children'].append(methodology_tasks)

        return tasks
