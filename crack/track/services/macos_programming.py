"""
macOS Objective-C & Swift programming analysis plugin

Generates tasks for analyzing macOS applications written in Objective-C and Swift:
- Class structure extraction (class-dump)
- Binary analysis and reverse engineering
- Runtime analysis and method inspection
- Objective-C specific reconnaissance
- Application structure enumeration
- Dynamic analysis techniques

Extracted from HackTricks: macos-basic-objective-c.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSProgrammingPlugin(ServicePlugin):
    """macOS Objective-C/Swift application analysis plugin"""

    @property
    def name(self) -> str:
        return "macos-programming"

    @property
    def default_ports(self) -> List[int]:
        # This plugin doesn't have default ports - triggers on macOS context
        return []

    @property
    def service_names(self) -> List[str]:
        return ['macos', 'osx', 'darwin']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect macOS environments or contexts where Objective-C/Swift analysis is relevant

        Triggers on:
        - Service names containing 'macos', 'osx', 'darwin'
        - macOS-specific services (afp, apple-*, mdns)
        - OS detection indicating macOS/Darwin
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        ostype = port_info.get('ostype', '').lower()
        extrainfo = port_info.get('extrainfo', '').lower()

        # Check for macOS-specific services
        macos_services = [
            'macos', 'osx', 'darwin', 'apple',
            'afp',  # Apple Filing Protocol
            'airport',  # Apple AirPort
            'mdns',  # mDNS (common on macOS)
        ]

        for macos_svc in macos_services:
            if (macos_svc in service or
                macos_svc in product or
                macos_svc in ostype or
                macos_svc in extrainfo):
                return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS Objective-C/Swift analysis task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', '')
        ostype = service_info.get('ostype', '')

        tasks = {
            'id': f'macos-programming-{port}',
            'name': f'macOS Application Analysis (Objective-C/Swift)',
            'type': 'parent',
            'children': []
        }

        # Phase 1: Binary Collection
        tasks['children'].append({
            'id': f'macos-binary-collection-{port}',
            'name': 'Binary Collection & Identification',
            'type': 'parent',
            'children': [
                {
                    'id': f'locate-macos-apps-{port}',
                    'name': 'Locate macOS Applications',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find macOS .app bundles and Mach-O binaries for analysis',
                        'alternatives': [
                            'find /Applications -name "*.app" 2>/dev/null',
                            'find /System/Applications -name "*.app" 2>/dev/null',
                            'find ~/Applications -name "*.app" 2>/dev/null',
                            'mdfind "kMDItemKind == Application"',
                            'ls -la /Applications/',
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RECON', 'MACOS'],
                        'success_indicators': [
                            'Application bundles (.app) found',
                            'Mach-O binaries identified',
                            'Application paths collected'
                        ],
                        'failure_indicators': [
                            'Permission denied on /Applications',
                            'No .app bundles found',
                            'SIP blocking directory access'
                        ],
                        'next_steps': [
                            'Extract binary from .app bundle: .app/Contents/MacOS/',
                            'Verify binary format: file <binary>',
                            'Check code signing: codesign -dv <app>',
                            'List application bundles for analysis'
                        ],
                        'notes': 'macOS applications are .app bundles. The actual binary is in Contents/MacOS/. Universal binaries may contain multiple architectures (x86_64, arm64).'
                    }
                },
                {
                    'id': f'identify-mach-o-{port}',
                    'name': 'Identify Mach-O Binary Format',
                    'type': 'command',
                    'metadata': {
                        'command': 'file <APP_BINARY>',
                        'description': 'Verify binary is Mach-O format and identify architecture',
                        'flag_explanations': {
                            'file': 'Determine file type and metadata',
                            '<APP_BINARY>': 'Path to extracted macOS binary (e.g., App.app/Contents/MacOS/App)'
                        },
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'MACOS'],
                        'success_indicators': [
                            'Mach-O 64-bit executable x86_64',
                            'Mach-O universal binary with 2 architectures',
                            'Mach-O 64-bit executable arm64',
                            'dynamically linked'
                        ],
                        'failure_indicators': [
                            'Not a Mach-O binary',
                            'Unsupported architecture',
                            'File not found',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'If universal binary: lipo -info <binary> to see architectures',
                            'Extract specific architecture: lipo -thin x86_64 <binary> -output <binary>_x86',
                            'Check code signing status',
                            'Proceed to class dumping'
                        ],
                        'alternatives': [
                            'otool -hv <binary>  # Mach-O header details',
                            'lipo -info <binary>  # Architecture info',
                            'strings <binary> | grep -i mach'
                        ],
                        'estimated_time': '30 seconds',
                        'notes': 'Universal binaries contain multiple architectures. Use lipo to extract specific arch for analysis. Modern macOS apps are arm64 (Apple Silicon) or x86_64 (Intel).'
                    }
                },
                {
                    'id': f'check-code-signing-{port}',
                    'name': 'Check Code Signing Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'codesign -dv <APP_PATH>',
                        'description': 'Verify code signature and entitlements (affects runtime injection)',
                        'flag_explanations': {
                            'codesign': 'macOS code signing utility',
                            '-d': 'Display code signature information',
                            '-v': 'Verbose output with signature details',
                            '<APP_PATH>': 'Path to .app bundle or binary'
                        },
                        'tags': ['OSCP:HIGH', 'RECON', 'MACOS'],
                        'success_indicators': [
                            'Signature is valid',
                            'TeamIdentifier displayed',
                            'Entitlements listed',
                            'Hardened Runtime enabled'
                        ],
                        'failure_indicators': [
                            'not signed',
                            'signature invalid',
                            'permission denied'
                        ],
                        'next_steps': [
                            'Check entitlements: codesign -d --entitlements :- <app>',
                            'If unsigned: easier to inject/modify',
                            'If hardened runtime: limited injection capabilities',
                            'Note App Store vs Developer ID signing'
                        ],
                        'alternatives': [
                            'codesign --verify --verbose <app>',
                            'spctl -a -vvv <app>  # Gatekeeper assessment',
                            'codesign -d --entitlements :- <app>  # Show entitlements'
                        ],
                        'estimated_time': '1 minute',
                        'notes': 'Code signing affects runtime analysis. Hardened Runtime limits DYLD_INSERT_LIBRARIES and debugging. Check entitlements for security restrictions.'
                    }
                }
            ]
        })

        # Phase 2: Class Dumping (Primary Objective-C Analysis)
        tasks['children'].append({
            'id': f'macos-class-dump-{port}',
            'name': 'Objective-C Class Dumping',
            'type': 'parent',
            'children': [
                {
                    'id': f'class-dump-install-{port}',
                    'name': 'Install class-dump Tool',
                    'type': 'command',
                    'metadata': {
                        'command': 'brew install class-dump',
                        'description': 'Install class-dump for extracting Objective-C class declarations from Mach-O binaries',
                        'flag_explanations': {
                            'brew': 'macOS package manager',
                            'install': 'Install package',
                            'class-dump': 'Objective-C class structure extraction tool'
                        },
                        'tags': ['OSCP:HIGH', 'SETUP', 'MACOS'],
                        'success_indicators': [
                            'class-dump installed',
                            'Homebrew installation complete'
                        ],
                        'failure_indicators': [
                            'Homebrew not installed',
                            'Permission denied',
                            'Network connectivity issues'
                        ],
                        'next_steps': [
                            'Verify installation: class-dump --version',
                            'Alternative: Download from https://github.com/nygard/class-dump',
                            'Proceed to dump target application'
                        ],
                        'alternatives': [
                            'git clone https://github.com/nygard/class-dump && cd class-dump && make',
                            'Download precompiled binary from GitHub releases',
                            'Use otool as alternative: otool -oV <binary>'
                        ],
                        'estimated_time': '2-3 minutes',
                        'notes': 'class-dump extracts Objective-C class declarations from Mach-O binaries. CRITICAL for understanding app structure and attack surface.'
                    }
                },
                {
                    'id': f'class-dump-binary-{port}',
                    'name': 'Dump Objective-C Classes',
                    'type': 'command',
                    'metadata': {
                        'command': 'class-dump <APP_BINARY> > <OUTPUT_FILE>.h',
                        'description': 'Extract ALL Objective-C class declarations, methods, properties, and protocols from binary',
                        'flag_explanations': {
                            'class-dump': 'Objective-C runtime structure extraction tool',
                            '<APP_BINARY>': 'Path to Mach-O binary (e.g., App.app/Contents/MacOS/App)',
                            '>': 'Redirect output to file',
                            '<OUTPUT_FILE>.h': 'Output header file (e.g., AppDump.h)'
                        },
                        'tags': ['OSCP:HIGH', 'ENUM', 'MACOS', 'QUICK_WIN'],
                        'success_indicators': [
                            '@interface declarations extracted',
                            'Method signatures visible',
                            'Property definitions listed',
                            'Protocol implementations shown',
                            'File size > 0 bytes'
                        ],
                        'failure_indicators': [
                            'No Objective-C runtime information',
                            'Swift-only binary (no Objective-C classes)',
                            'Stripped binary',
                            'Empty output file'
                        ],
                        'next_steps': [
                            'Analyze dumped header file for sensitive methods',
                            'Look for authentication/authorization methods',
                            'Identify crypto/key management methods',
                            'Search for API endpoints/URL strings',
                            'Grep for passwords/credentials: grep -i "password\\|credential\\|secret" <output>.h'
                        ],
                        'alternatives': [
                            'class-dump -H <binary> -o <output_dir>  # Generate header files per class',
                            'otool -oV <binary> | less  # View Objective-C segments',
                            'dsdump <binary>  # Alternative dumper for Swift/Objective-C'
                        ],
                        'estimated_time': '1-2 minutes',
                        'notes': 'Objective-C binaries retain full class structure at runtime. This reveals ALL class names, methods, properties, and protocols - invaluable for reverse engineering. Note: Swift classes may not appear unless they inherit from NSObject.'
                    }
                },
                {
                    'id': f'analyze-class-dump-{port}',
                    'name': 'Analyze Dumped Class Structure',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review class dump output for security-relevant methods and attack surface',
                        'alternatives': [
                            'grep -i "auth\\|login\\|password\\|credential\\|token\\|key\\|secret" <dump>.h',
                            'grep -i "decrypt\\|encrypt\\|crypto\\|hash\\|sign" <dump>.h',
                            'grep -i "api\\|url\\|endpoint\\|request\\|http" <dump>.h',
                            'grep -i "admin\\|root\\|privilege\\|permission" <dump>.h',
                            'grep "@property" <dump>.h | grep -i "password\\|token"',
                            'grep "- (void)" <dump>.h  # Instance methods',
                            'grep "+ (void)" <dump>.h  # Class methods'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM', 'MACOS'],
                        'success_indicators': [
                            'Security-relevant methods identified',
                            'Authentication mechanisms discovered',
                            'API endpoints/URLs found',
                            'Crypto methods located',
                            'Sensitive property names visible'
                        ],
                        'failure_indicators': [
                            'No useful information in dump',
                            'Heavily obfuscated class names',
                            'Empty or minimal class structure'
                        ],
                        'next_steps': [
                            'Document all authentication-related methods',
                            'Identify methods that handle sensitive data',
                            'Look for debug/test methods that might bypass security',
                            'Map application flow from method names',
                            'Prepare for runtime hooking of identified methods'
                        ],
                        'notes': 'Focus on methods with security implications: authentication, authorization, crypto, API calls, data storage. Class/method names often reveal application logic.'
                    }
                }
            ]
        })

        # Phase 3: Runtime Analysis
        tasks['children'].append({
            'id': f'macos-runtime-analysis-{port}',
            'name': 'Objective-C Runtime Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'nm-symbols-{port}',
                    'name': 'Extract Binary Symbols',
                    'type': 'command',
                    'metadata': {
                        'command': 'nm -a <APP_BINARY> > symbols.txt',
                        'description': 'List all symbols (functions, objects, variables) in binary for analysis',
                        'flag_explanations': {
                            'nm': 'List symbols from object files',
                            '-a': 'Display all symbol table entries (including debug)',
                            '<APP_BINARY>': 'Path to Mach-O binary',
                            '>': 'Save output to file for analysis'
                        },
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MACOS'],
                        'success_indicators': [
                            'Symbol list generated',
                            'Objective-C method symbols visible (_[ClassName methodName])',
                            'External library references shown',
                            'Function addresses displayed'
                        ],
                        'failure_indicators': [
                            'Binary stripped (no symbols)',
                            'Empty output',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'grep "_\\[.*\\]" symbols.txt  # Objective-C methods',
                            'grep -i "password\\|auth\\|secret" symbols.txt',
                            'Identify interesting functions for hooking',
                            'Compare with class-dump output'
                        ],
                        'alternatives': [
                            'nm -gU <binary>  # External symbols only',
                            'nm -u <binary>  # Undefined symbols (imports)',
                            'objdump -t <binary>  # Symbol table',
                            'otool -tV <binary>  # Disassembly with symbols'
                        ],
                        'estimated_time': '1-2 minutes',
                        'notes': 'nm reveals function/method names even in stripped binaries (to some degree). Combine with class-dump for complete picture.'
                    }
                },
                {
                    'id': f'strings-analysis-{port}',
                    'name': 'Extract Hardcoded Strings',
                    'type': 'command',
                    'metadata': {
                        'command': 'strings <APP_BINARY> > strings.txt',
                        'description': 'Extract all printable strings from binary (URLs, API keys, passwords, messages)',
                        'flag_explanations': {
                            'strings': 'Extract printable character sequences from binary',
                            '<APP_BINARY>': 'Mach-O binary file'
                        },
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'MACOS'],
                        'success_indicators': [
                            'URLs/endpoints extracted',
                            'API keys or tokens found',
                            'Hardcoded credentials discovered',
                            'Configuration paths visible',
                            'Error messages revealing logic'
                        ],
                        'failure_indicators': [
                            'Encrypted/obfuscated strings',
                            'No useful strings found',
                            'Empty output'
                        ],
                        'next_steps': [
                            'grep -E "https?://" strings.txt  # URLs',
                            'grep -i "api.*key\\|token\\|secret" strings.txt',
                            'grep -i "password\\|passwd\\|pwd" strings.txt',
                            'grep "\\.plist\\|\\.db\\|\\.sqlite" strings.txt  # File paths',
                            'Look for SQL queries, file paths, debug messages'
                        ],
                        'alternatives': [
                            'strings -a <binary>  # All strings (including data sections)',
                            'strings -n 8 <binary>  # Minimum length 8 chars',
                            'rabin2 -z <binary>  # radare2 string extraction',
                            'grep -Eo "[0-9a-fA-F]{32,}" strings.txt  # Potential hashes/keys'
                        ],
                        'estimated_time': '2-3 minutes',
                        'notes': 'Hardcoded strings often reveal: API endpoints, crypto keys, file paths, SQL queries, debug messages, error strings. High-value for pentesting.'
                    }
                },
                {
                    'id': f'otool-libraries-{port}',
                    'name': 'List Linked Libraries & Dependencies',
                    'type': 'command',
                    'metadata': {
                        'command': 'otool -L <APP_BINARY>',
                        'description': 'Enumerate all dynamically linked libraries (frameworks) to understand dependencies and attack surface',
                        'flag_explanations': {
                            'otool': 'macOS object file displaying tool',
                            '-L': 'List shared libraries/frameworks used by binary',
                            '<APP_BINARY>': 'Mach-O executable path'
                        },
                        'tags': ['OSCP:MEDIUM', 'RECON', 'MACOS'],
                        'success_indicators': [
                            'System frameworks listed',
                            'Third-party libraries identified',
                            'Vulnerable library versions found',
                            'Custom frameworks discovered'
                        ],
                        'failure_indicators': [
                            'No libraries listed (static binary)',
                            'Permission denied',
                            'Invalid binary format'
                        ],
                        'next_steps': [
                            'Research known vulnerabilities in listed frameworks',
                            'Check for outdated library versions',
                            'Identify custom frameworks for analysis: grep -v "/System" output',
                            'Look for security frameworks: grep -i "security\\|crypto" output',
                            'Check for DYLD_INSERT_LIBRARIES injection opportunities'
                        ],
                        'alternatives': [
                            'otool -l <binary> | grep -A3 LC_LOAD_DYLIB  # Detailed load commands',
                            'dyldinfo -dylibs <binary>  # Modern alternative',
                            'vmmap <pid>  # Runtime library mapping (requires running process)'
                        ],
                        'estimated_time': '1 minute',
                        'notes': 'Frameworks reveal app capabilities. Security.framework = crypto/keychain, Foundation = core objects, WebKit = web rendering. Custom frameworks may have exploitable dylib hijacking vulnerabilities.'
                    }
                },
                {
                    'id': f'frida-setup-{port}',
                    'name': 'Setup Frida for Runtime Hooking',
                    'type': 'command',
                    'metadata': {
                        'command': 'pip3 install frida-tools',
                        'description': 'Install Frida dynamic instrumentation framework for method hooking and runtime manipulation',
                        'flag_explanations': {
                            'pip3': 'Python package installer',
                            'install': 'Install package',
                            'frida-tools': 'Frida CLI tools for dynamic instrumentation'
                        },
                        'tags': ['OSCP:MEDIUM', 'SETUP', 'MACOS'],
                        'success_indicators': [
                            'frida-tools installed',
                            'frida command available',
                            'frida-trace command available'
                        ],
                        'failure_indicators': [
                            'pip3 not found',
                            'Installation failed',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Verify: frida --version',
                            'List running processes: frida-ps',
                            'Hook specific app: frida -U -f <bundle_id>',
                            'Trace Objective-C methods: frida-trace -U -f <bundle_id> -m "-[ClassName methodName]"'
                        ],
                        'alternatives': [
                            'brew install frida',
                            'Download from https://frida.re',
                            'Use Cycript for similar functionality: cycript -p <app>'
                        ],
                        'estimated_time': '3-5 minutes',
                        'notes': 'Frida enables runtime method hooking, parameter inspection, return value modification. Essential for dynamic analysis of Objective-C apps. Requires SIP disabled or app not hardened.'
                    }
                },
                {
                    'id': f'frida-objc-trace-{port}',
                    'name': 'Trace Objective-C Method Calls',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida-trace -U -f <BUNDLE_ID> -m "-[ClassName *]"',
                        'description': 'Dynamically trace ALL method calls for specific Objective-C class at runtime',
                        'flag_explanations': {
                            'frida-trace': 'Frida method tracing utility',
                            '-U': 'Connect to USB device (or local if no device)',
                            '-f': 'Spawn application with bundle ID',
                            '<BUNDLE_ID>': 'App bundle identifier (e.g., com.example.MyApp)',
                            '-m': 'Method pattern to trace',
                            '"-[ClassName *]"': 'Trace all instance methods (-) of ClassName. * = wildcard for all methods'
                        },
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MACOS'],
                        'success_indicators': [
                            'Method calls logged in real-time',
                            'Parameters and return values visible',
                            'Application flow traced',
                            'Hooks successfully attached'
                        ],
                        'failure_indicators': [
                            'App hardened runtime blocks injection',
                            'SIP enabled blocking injection',
                            'Bundle ID not found',
                            'Class name incorrect'
                        ],
                        'next_steps': [
                            'Analyze traced method calls for sensitive operations',
                            'Identify authentication method flow',
                            'Hook specific methods: -m "-[AuthController validatePassword:]"',
                            'Modify return values with custom Frida script',
                            'Extract crypto keys from method parameters'
                        ],
                        'alternatives': [
                            'frida -U -f <bundle> -l hook_script.js  # Custom hooking script',
                            'cycript -p <app>  # Interactive runtime manipulation',
                            'dtrace for system-level tracing (requires admin)',
                            'lldb for debugger-based method inspection'
                        ],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Method tracing reveals runtime behavior: auth flows, API calls, crypto operations. Requires disabling SIP or app without hardened runtime. Use class-dump output to identify methods to trace.'
                    }
                }
            ]
        })

        # Phase 4: Code Examples & Compilation
        tasks['children'].append({
            'id': f'macos-objc-compilation-{port}',
            'name': 'Objective-C Code Analysis & Compilation',
            'type': 'parent',
            'children': [
                {
                    'id': f'compile-objc-test-{port}',
                    'name': 'Compile Test Objective-C Program',
                    'type': 'command',
                    'metadata': {
                        'command': 'gcc -framework Foundation test.m -o test',
                        'description': 'Compile Objective-C source code to Mach-O binary for testing/exploitation',
                        'flag_explanations': {
                            'gcc': 'GNU C Compiler (supports Objective-C)',
                            '-framework': 'Link against macOS framework',
                            'Foundation': 'Foundation framework (NSObject, NSString, etc.)',
                            'test.m': 'Objective-C source file (.m extension)',
                            '-o': 'Output binary name',
                            'test': 'Compiled executable name'
                        },
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MACOS'],
                        'success_indicators': [
                            'Compilation successful',
                            'Executable created',
                            'No compiler errors',
                            'Binary runs successfully: ./test'
                        ],
                        'failure_indicators': [
                            'Syntax errors',
                            'Framework not found',
                            'Linker errors',
                            'Xcode command line tools not installed'
                        ],
                        'next_steps': [
                            'Run compiled binary: ./test',
                            'Test class-dump on output: class-dump ./test',
                            'Verify Objective-C runtime: nm ./test | grep "_\\["',
                            'Use as PoC for exploitation',
                            'Create malicious Objective-C payload'
                        ],
                        'alternatives': [
                            'clang -framework Foundation test.m -o test  # Clang compiler',
                            'gcc -framework Foundation -framework AppKit test.m -o test  # With GUI',
                            'xcodebuild for full Xcode projects',
                            'swiftc for Swift code compilation'
                        ],
                        'estimated_time': '1-2 minutes',
                        'notes': 'Foundation framework required for NSObject, NSString, NSArray. Objective-C files use .m extension. Common frameworks: Foundation (core), AppKit (GUI), Security (crypto/keychain).'
                    }
                },
                {
                    'id': f'objc-code-examples-{port}',
                    'name': 'Objective-C Code Pattern Reference',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reference common Objective-C patterns for exploitation and testing',
                        'notes': '''Common Objective-C Patterns for Analysis:

1. CLASS DECLARATION:
   @interface MyClass : NSObject
   @property NSString *propertyName;
   - (void)instanceMethod;
   + (void)classMethod;
   @end

2. METHOD CALLING:
   [object methodName];
   [object methodWithParam:value];
   [ClassName classMethod];

3. PROPERTY ACCESS:
   object.propertyName = @"value";  // Setter
   NSString *val = object.propertyName;  // Getter

4. BLOCKS (Lambda functions):
   returnType (^blockName)(params) = ^(params){
       // code
   };

5. STRING CREATION:
   NSString *str = @"Literal string";
   NSString *str = [[NSString alloc] initWithCString:"C string" encoding:NSUTF8StringEncoding];

6. FILE OPERATIONS:
   NSFileManager *fm = [NSFileManager defaultManager];
   [fm fileExistsAtPath:@"/path"];
   [fm copyItemAtPath:@"/src" toPath:@"/dst" error:nil];

Key for Reversing:
- Instance methods start with "-"
- Class methods start with "+"
- Method parameters use ":"
- Properties auto-generate getters/setters
- Protocols define interfaces (like Java interfaces)
- Categories add methods to existing classes
''',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'REFERENCE', 'MACOS'],
                        'alternatives': [
                            'See class-dump output for real examples',
                            'Review Foundation framework headers: /System/Library/Frameworks/Foundation.framework/Headers/',
                            'Apple Developer Objective-C documentation',
                            'Analyze existing open-source macOS apps'
                        ]
                    }
                }
            ]
        })

        # Phase 5: Advanced Reverse Engineering
        tasks['children'].append({
            'id': f'macos-advanced-re-{port}',
            'name': 'Advanced Binary Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'hopper-analysis-{port}',
                    'name': 'Disassemble with Hopper/IDA/Ghidra',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use disassembler to analyze binary at assembly level and decompile Objective-C methods',
                        'alternatives': [
                            'Hopper Disassembler (macOS native, excellent Objective-C support)',
                            'IDA Pro/Free (industry standard, Objective-C plugin available)',
                            'Ghidra (free, NSA tool, Objective-C support via plugins)',
                            'radare2: r2 -A <binary>  # Open source alternative',
                            'Binary Ninja (modern UI, good macOS support)'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'MACOS'],
                        'success_indicators': [
                            'Assembly code visible',
                            'Objective-C method names preserved',
                            'Pseudo-code decompilation generated',
                            'Call graph shows method relationships',
                            'String references identified'
                        ],
                        'failure_indicators': [
                            'Heavily obfuscated code',
                            'Anti-debugging protections active',
                            'Stripped symbols make analysis difficult'
                        ],
                        'next_steps': [
                            'Analyze authentication method implementations',
                            'Identify crypto key generation/storage',
                            'Trace user input validation logic',
                            'Look for hardcoded bypass mechanisms',
                            'Identify code signing verification checks'
                        ],
                        'notes': 'Hopper Disassembler has best Objective-C support for macOS binaries. Combines class-dump info with disassembly. Look for msgSend calls (Objective-C method dispatch).'
                    }
                },
                {
                    'id': f'lldb-debugging-{port}',
                    'name': 'Debug with LLDB',
                    'type': 'command',
                    'metadata': {
                        'command': 'lldb <APP_BINARY>',
                        'description': 'Launch binary in debugger for dynamic analysis, breakpoints, and runtime inspection',
                        'flag_explanations': {
                            'lldb': 'LLVM debugger (Xcode debugger)',
                            '<APP_BINARY>': 'Mach-O binary to debug'
                        },
                        'tags': ['OSCP:MEDIUM', 'MACOS'],
                        'success_indicators': [
                            'Debugger attached',
                            'Breakpoints set successfully',
                            'Can step through code',
                            'Can inspect variables/registers'
                        ],
                        'failure_indicators': [
                            'SIP blocks debugging',
                            'App has anti-debugging checks',
                            'Permission denied',
                            'Binary crashes immediately'
                        ],
                        'next_steps': [
                            'Set breakpoint on method: br set -n "-[ClassName methodName:]"',
                            'Run program: r',
                            'Step through: s (step into), n (step over)',
                            'Inspect objects: po <object>',
                            'Print Objective-C method: po [object description]',
                            'Modify runtime: expr <variable> = <value>'
                        ],
                        'alternatives': [
                            'lldb -p <pid>  # Attach to running process',
                            'lldb -n <process_name>  # Attach by process name',
                            'gdb (outdated for macOS, lldb preferred)',
                            'Xcode debugger (GUI version of lldb)'
                        ],
                        'estimated_time': '10-20 minutes',
                        'notes': 'LLDB is macOS native debugger. Use "po" command to print Objective-C objects. Requires SIP disabled for system apps. Set breakpoints on interesting methods from class-dump.'
                    }
                },
                {
                    'id': f'detect-obfuscation-{port}',
                    'name': 'Detect Code Obfuscation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify if application uses code obfuscation to hinder reverse engineering',
                        'alternatives': [
                            'class-dump output: Look for randomized class names (a, b, AA, AB)',
                            'strings output: Check for readable vs gibberish strings',
                            'otool -tV: Look for unusual control flow (anti-disassembly)',
                            'Check for anti-debugging: grep -i "ptrace\\|sysctl\\|isDebugger" strings.txt',
                            'Identify packer/protector signatures'
                        ],
                        'tags': ['OSCP:MEDIUM', 'RECON', 'MACOS'],
                        'success_indicators': [
                            'Obfuscation detected',
                            'Anti-debugging checks found',
                            'Encrypted strings identified',
                            'Control flow flattening present'
                        ],
                        'failure_indicators': [
                            'Clear, readable class/method names',
                            'No anti-debugging found',
                            'Standard binary structure'
                        ],
                        'next_steps': [
                            'If obfuscated: Use dynamic analysis (Frida, lldb) instead of static',
                            'Bypass anti-debugging with Frida scripts',
                            'Dump decrypted strings from memory',
                            'Use emulation (unicorn) for deobfuscation'
                        ],
                        'notes': 'Common obfuscation: class/method renaming, string encryption, control flow flattening, anti-debugging checks, packing. Dynamic analysis more effective against obfuscation.'
                    }
                }
            ]
        })

        # Phase 6: Exploitation Preparation
        tasks['children'].append({
            'id': f'macos-exploit-prep-{port}',
            'name': 'Exploitation Preparation',
            'type': 'parent',
            'children': [
                {
                    'id': f'document-attack-surface-{port}',
                    'name': 'Document Attack Surface',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Compile findings into actionable attack surface map',
                        'alternatives': [
                            'List all authentication methods found',
                            'Document crypto implementations (look for weak algos)',
                            'Identify input validation methods',
                            'Note file I/O operations (path traversal risks)',
                            'Map network communication methods (API endpoints)',
                            'Document privilege escalation opportunities',
                            'Identify stored credentials/keys locations'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM', 'MACOS'],
                        'success_indicators': [
                            'Attack surface documented',
                            'High-value targets identified',
                            'Exploitation plan created',
                            'Risk areas prioritized'
                        ],
                        'next_steps': [
                            'Prioritize targets by risk and exploitability',
                            'Develop PoC exploits for identified vulnerabilities',
                            'Test runtime hooks on authentication methods',
                            'Attempt to extract crypto keys',
                            'Try DYLD_INSERT_LIBRARIES injection if applicable'
                        ],
                        'notes': 'Focus on: authentication bypass, crypto weaknesses, hardcoded credentials, file access, network endpoints, privilege escalation. Use class-dump + strings + runtime analysis findings.'
                    }
                },
                {
                    'id': f'search-vulns-{port}',
                    'name': 'Search for Known Vulnerabilities',
                    'type': 'command',
                    'metadata': {
                        'command': 'searchsploit <APP_NAME> <VERSION>',
                        'description': 'Search exploit-db for known vulnerabilities in target application or frameworks',
                        'flag_explanations': {
                            'searchsploit': 'Exploit-DB command-line search',
                            '<APP_NAME>': 'Application name or framework name',
                            '<VERSION>': 'Version number from binary analysis'
                        },
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'MACOS'],
                        'success_indicators': [
                            'Exploits found for app version',
                            'Framework vulnerabilities identified',
                            'PoC exploits available'
                        ],
                        'failure_indicators': [
                            'No exploits found',
                            'Version too new',
                            'Application not in database'
                        ],
                        'next_steps': [
                            'Review found exploits for applicability',
                            'Search CVE databases: cve.mitre.org',
                            'Check GitHub for PoCs',
                            'Research framework vulnerabilities from otool -L output',
                            'Test exploits in controlled environment'
                        ],
                        'alternatives': [
                            'searchsploit -w <term>  # Get online exploit URLs',
                            'Google: "<app> <version> CVE"',
                            'https://nvd.nist.gov/ for CVE details',
                            'GitHub search for exploit PoCs'
                        ],
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        })

        return tasks


# Example Objective-C test program for reference
EXAMPLE_OBJC_PROGRAM = '''
// test_obj.m - Example Objective-C program
// Compile: gcc -framework Foundation test_obj.m -o test_obj

#import <Foundation/Foundation.h>

@protocol myVehicleProtocol
- (void) startEngine;
@required
- (void) addWheels:(int)value;
@optional
- (void) makeLongTruck;
@end

@interface MyVehicle : NSObject <myVehicleProtocol>
@property int numberOfWheels;
- (void)startEngine;
- (void)addWheels:(int)value;
- (void)makeLongTruck;
@end

@implementation MyVehicle : NSObject

- (void)startEngine {
    NSLog(@"Engine started");
}

- (void)addWheels:(int)value {
    self.numberOfWheels += value;
}

- (void)makeLongTruck {
    _numberOfWheels = +10000;
    NSLog(@"Number of wheels: %i", self.numberOfWheels);
}

@end

int main() {
    @autoreleasepool {
        MyVehicle* mySuperCar = [MyVehicle new];
        [mySuperCar startEngine];
        mySuperCar.numberOfWheels = 4;
        NSLog(@"Number of wheels: %i", mySuperCar.numberOfWheels);
        [mySuperCar setNumberOfWheels:3];
        NSLog(@"Number of wheels: %i", mySuperCar.numberOfWheels);
        [mySuperCar makeLongTruck];
    }
    return 0;
}
'''
