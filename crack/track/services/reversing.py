"""
Reversing & Binary Analysis service plugin

Generates tasks for reversing and binary analysis including:
- WebAssembly (WASM) decompilation
- Binary analysis tools (Ghidra, radare2, IDA, dnSpy)
- Shellcode analysis and debugging
- Decompilation techniques (.NET, Java, Python)
- Symbolic execution (angr, Z3)

Extracted from HackTricks: reversing/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ReversingPlugin(ServicePlugin):
    """Reversing & Binary Analysis plugin"""

    @property
    def name(self) -> str:
        return "reversing"

    @property
    def default_ports(self) -> List[int]:
        return []

    @property
    def service_names(self) -> List[str]:
        return ['wasm', 'binary', 'reverse-engineering', 'reversing']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect reversing-related services (primarily for manual triggering)"""
        # This plugin is primarily for manual analysis tasks
        # It can detect WebAssembly endpoints or binary download services
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # Check for web services that might serve WASM or binaries
        if 'wasm' in service or 'wasm' in product:
            return True

        # Check for common binary-serving patterns
        if any(keyword in service for keyword in ['download', 'file', 'binary']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate reversing task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'reversing-analysis-{port}',
            'name': f'Reversing & Binary Analysis (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: WebAssembly Analysis
        tasks['children'].append({
            'id': f'wasm-analysis-{port}',
            'name': 'WebAssembly (WASM) Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'wasm-download-{port}',
                    'name': 'Download WASM Binary',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Download .wasm binary from web application',
                        'tags': ['MANUAL', 'OSCP:MEDIUM'],
                        'alternatives': [
                            f'Browser DevTools: Network tab -> Filter by .wasm',
                            f'curl http://{target}:{port}/file.wasm -o file.wasm',
                            f'wget http://{target}:{port}/file.wasm'
                        ],
                        'success_indicators': [
                            'WASM binary downloaded successfully',
                            'File starts with magic bytes 0x00 0x61 0x73 0x6D'
                        ],
                        'failure_indicators': [
                            '404 Not Found - WASM file not at expected location',
                            'File is not valid WASM format'
                        ],
                        'next_steps': [
                            'Verify WASM magic bytes: file file.wasm',
                            'Decompile to WAT (text format)',
                            'Analyze for sensitive data or vulnerabilities'
                        ],
                        'notes': 'WebAssembly files often contain business logic that can reveal vulnerabilities'
                    }
                },
                {
                    'id': f'wasm-decompile-{port}',
                    'name': 'Decompile WASM to WAT',
                    'type': 'command',
                    'metadata': {
                        'command': 'wasm2wat file.wasm -o file.wat',
                        'description': 'Decompile WASM binary to human-readable WAT text format',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'flag_explanations': {
                            'wasm2wat': 'WebAssembly binary to text converter (part of WABT toolkit)',
                            'file.wasm': 'Input WASM binary file',
                            '-o': 'Output file path',
                            'file.wat': 'Output WAT (WebAssembly Text) file'
                        },
                        'success_indicators': [
                            'WAT file created successfully',
                            'Text output contains (module ...) S-expressions',
                            'Function names and imports visible'
                        ],
                        'failure_indicators': [
                            'Invalid WASM format error',
                            'Corrupted binary',
                            'wasm2wat not installed'
                        ],
                        'next_steps': [
                            'Review WAT file for sensitive strings',
                            'Identify imported functions and APIs',
                            'Look for crypto operations or auth logic',
                            'Try decompiling to higher-level code with wasmdec'
                        ],
                        'alternatives': [
                            'Online: https://webassembly.github.io/wabt/demo/wasm2wat/',
                            'Manual: strings file.wasm | grep -i password',
                            'ghidra-wasm-plugin for Ghidra analysis'
                        ],
                        'notes': 'Install WABT: apt install wabt or from https://github.com/WebAssembly/wabt'
                    }
                },
                {
                    'id': f'wasm-advanced-decompile-{port}',
                    'name': 'Advanced WASM Decompilation',
                    'type': 'command',
                    'metadata': {
                        'command': 'wasmdec file.wasm -o file.c',
                        'description': 'Decompile WASM to C-like pseudocode for easier analysis',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'flag_explanations': {
                            'wasmdec': 'WASM decompiler producing C-like output',
                            'file.wasm': 'Input WASM binary',
                            '-o': 'Output file',
                            'file.c': 'Decompiled C-like pseudocode'
                        },
                        'success_indicators': [
                            'C-like pseudocode generated',
                            'Function logic more readable than WAT',
                            'Variable names and control flow visible'
                        ],
                        'failure_indicators': [
                            'wasmdec not installed',
                            'Decompilation produces unreadable output',
                            'Complex WASM features not supported'
                        ],
                        'next_steps': [
                            'Analyze decompiled C code for vulnerabilities',
                            'Compare with original JavaScript if available',
                            'Identify authentication or encryption weaknesses'
                        ],
                        'alternatives': [
                            'Online: https://wwwg.github.io/web-wasmdec/',
                            'JEB decompiler: https://www.pnfsoftware.com/jeb/demo',
                            'Manual WAT analysis with text editor'
                        ],
                        'notes': 'Install: git clone https://github.com/wwwg/wasmdec && cd wasmdec && make'
                    }
                }
            ]
        })

        # TASK 2: .NET Decompilation
        tasks['children'].append({
            'id': f'dotnet-analysis-{port}',
            'name': '.NET Binary Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'dotnet-dnspy-{port}',
                    'name': 'Decompile with dnSpy',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Decompile .NET assemblies (.dll, .exe) with dnSpy for analysis and modification',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'WINDOWS'],
                        'alternatives': [
                            'Windows: Download dnSpyEx from https://github.com/dnSpyEx/dnSpy/releases',
                            'Linux: Use ILSpy VSCode extension or command-line ilspycmd',
                            'dotPeek (Windows): https://www.jetbrains.com/decompiler/',
                            '.NET Reflector: https://www.red-gate.com/products/reflector/'
                        ],
                        'success_indicators': [
                            'Assembly loaded successfully in dnSpy',
                            'Source code decompiled and readable',
                            'Namespaces and classes visible'
                        ],
                        'failure_indicators': [
                            'Assembly is obfuscated (unreadable names)',
                            'Native code or mixed assemblies',
                            'Corrupted or protected binary'
                        ],
                        'next_steps': [
                            'Search for hardcoded credentials: Edit -> Search -> String',
                            'Look for crypto keys and connection strings',
                            'Modify methods: Right-click method -> Edit Method',
                            'Add logging: File.AppendAllText() for debugging',
                            'Recompile: File -> Save Module'
                        ],
                        'notes': 'For OSCP: dnSpy is Windows-only. On Kali, use ILSpy or ilspycmd for Linux compatibility'
                    }
                },
                {
                    'id': f'dotnet-ilspy-{port}',
                    'name': 'Decompile with ILSpy (Linux)',
                    'type': 'command',
                    'metadata': {
                        'command': 'ilspycmd assembly.dll -o decompiled/',
                        'description': 'Decompile .NET assembly to C# source code on Linux',
                        'tags': ['OSCP:MEDIUM', 'LINUX'],
                        'flag_explanations': {
                            'ilspycmd': 'ILSpy command-line decompiler for .NET',
                            'assembly.dll': 'Target .NET assembly (.dll or .exe)',
                            '-o': 'Output directory for decompiled source',
                            'decompiled/': 'Directory to save C# files'
                        },
                        'success_indicators': [
                            'C# source files created in output directory',
                            'Namespaces and class structure preserved',
                            '.csproj project file generated'
                        ],
                        'failure_indicators': [
                            'ilspycmd not found - not installed',
                            'Obfuscated assembly produces unreadable code',
                            'Native or mixed-mode assembly'
                        ],
                        'next_steps': [
                            'grep -r "password\\|key\\|token" decompiled/',
                            'Review authentication and crypto logic',
                            'Check for SQL injection in database queries',
                            'Identify API endpoints and secrets'
                        ],
                        'alternatives': [
                            'VSCode: Install ILSpy extension from Extensions marketplace',
                            'Manual: strings assembly.dll | grep -i password',
                            'Online: https://www.decompiler.com/ (upload small files)'
                        ],
                        'notes': 'Install: apt install ilspycmd or dotnet tool install -g ilspycmd'
                    }
                }
            ]
        })

        # TASK 3: Shellcode Analysis
        tasks['children'].append({
            'id': f'shellcode-analysis-{port}',
            'name': 'Shellcode Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'shellcode-scdbg-{port}',
                    'name': 'Analyze Shellcode with scDbg',
                    'type': 'command',
                    'metadata': {
                        'command': 'scdbg.exe -f shellcode.bin -r',
                        'description': 'Analyze shellcode behavior without execution (Windows)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                        'flag_explanations': {
                            'scdbg.exe': 'Shellcode emulator and analyzer',
                            '-f': 'Input shellcode file',
                            'shellcode.bin': 'Raw shellcode binary',
                            '-r': 'Show analysis report at end'
                        },
                        'success_indicators': [
                            'API calls discovered and logged',
                            'Decoded shellcode dumped (if self-decoding)',
                            'Network indicators extracted (IPs, ports)'
                        ],
                        'failure_indicators': [
                            'Invalid shellcode format',
                            'Emulation crashes or hangs',
                            'Anti-emulation detected'
                        ],
                        'next_steps': [
                            'Review discovered API calls for functionality',
                            'Extract IPs/domains for C2 infrastructure',
                            'Use -d flag to dump decoded shellcode',
                            'Debug with Cutter or IDA for deeper analysis'
                        ],
                        'alternatives': [
                            'Linux: Use radare2 or Cutter for emulation',
                            'scdbg.exe -f shellcode.bin -d #Dump decoded',
                            'CyberChef: Disassemble x86 recipe',
                            'speakeasy (Python): github.com/mandiant/speakeasy'
                        ],
                        'notes': 'Download: http://sandsprite.com/blogs/index.php?uid=7&pid=152'
                    }
                },
                {
                    'id': f'shellcode-blobrunner-{port}',
                    'name': 'Debug Shellcode with BlobRunner',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Allocate shellcode in memory and attach debugger for dynamic analysis',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'WINDOWS'],
                        'alternatives': [
                            'BlobRunner: https://github.com/OALabs/BlobRunner/releases',
                            'jmp2it: Similar tool with eternal loop approach',
                            'Manual: VirtualAlloc + memcpy + CreateThread in custom loader'
                        ],
                        'success_indicators': [
                            'Shellcode allocated at displayed memory address',
                            'Debugger (x64dbg/IDA) attached successfully',
                            'Breakpoint hit at shellcode entry point'
                        ],
                        'failure_indicators': [
                            'Shellcode crashes immediately',
                            'Anti-debugging detected',
                            'Incorrect architecture (x86 vs x64)'
                        ],
                        'next_steps': [
                            'Step through shellcode instruction-by-instruction',
                            'Monitor API calls with debugger',
                            'Dump decoded payloads from memory',
                            'Identify C2 communication logic'
                        ],
                        'notes': 'BlobRunner workflow: 1) Run BlobRunner 2) Note memory address 3) Attach debugger 4) Set breakpoint 5) Resume'
                    }
                },
                {
                    'id': f'shellcode-cutter-{port}',
                    'name': 'Emulate Shellcode with Cutter',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Emulate and analyze shellcode using Cutter (radare2 GUI)',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'LINUX'],
                        'alternatives': [
                            'Cutter: https://github.com/rizinorg/cutter/releases',
                            'radare2 CLI: r2 -a x86 -b 32 shellcode.bin',
                            'QEMU user-mode emulation for analysis'
                        ],
                        'success_indicators': [
                            'Shellcode loaded and disassembled',
                            'Emulation runs without errors',
                            'Register and memory states visible'
                        ],
                        'failure_indicators': [
                            'Emulation fails or crashes',
                            'Wrong architecture selected',
                            'Position-dependent code issues'
                        ],
                        'next_steps': [
                            'Set breakpoints at key instructions',
                            'Monitor stack and heap in hex view',
                            'Extract strings and API calls',
                            'Export decompiled pseudocode'
                        ],
                        'notes': 'Cutter: File -> Open Shellcode (not Open File) for proper loading'
                    }
                }
            ]
        })

        # TASK 4: Binary Analysis Tools
        tasks['children'].append({
            'id': f'binary-analysis-tools-{port}',
            'name': 'Binary Analysis Tools Setup',
            'type': 'parent',
            'children': [
                {
                    'id': f'ghidra-setup-{port}',
                    'name': 'Analyze with Ghidra',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reverse engineer binary with NSA Ghidra decompiler',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'BOTH_OS'],
                        'alternatives': [
                            'Ghidra: https://ghidra-sre.org/ (free, open-source)',
                            'IDA Free: https://hex-rays.com/ida-free/ (limited)',
                            'Binary Ninja: https://binary.ninja/ (commercial)',
                            'radare2/Cutter: Free alternative to Ghidra'
                        ],
                        'success_indicators': [
                            'Binary loaded and analyzed successfully',
                            'Functions decompiled to C pseudocode',
                            'Strings and cross-references found'
                        ],
                        'failure_indicators': [
                            'Binary is packed or obfuscated',
                            'Anti-debugging measures active',
                            'Stripped binary with no symbols'
                        ],
                        'next_steps': [
                            'Identify main() or entry point',
                            'Search for strings: Window -> Defined Strings',
                            'Find crypto constants (0x67452301 for MD5, etc.)',
                            'Analyze network functions (connect, send, recv)',
                            'Export function graphs and decompilation'
                        ],
                        'notes': 'Ghidra plugins: GhidraGBA (Game Boy), goomba (Golang), FindCrypt (crypto)'
                    }
                },
                {
                    'id': f'radare2-analysis-{port}',
                    'name': 'Analyze with radare2',
                    'type': 'command',
                    'metadata': {
                        'command': 'r2 -A binary',
                        'description': 'Analyze binary with radare2 reverse engineering framework',
                        'tags': ['OSCP:MEDIUM', 'LINUX'],
                        'flag_explanations': {
                            'r2': 'radare2 command-line interface',
                            '-A': 'Auto-analyze binary (aaa command)',
                            'binary': 'Target executable file'
                        },
                        'success_indicators': [
                            'Binary analyzed successfully',
                            'Functions discovered and named',
                            'Entry point identified'
                        ],
                        'failure_indicators': [
                            'Unknown file format',
                            'Corrupted or packed binary',
                            'radare2 not installed'
                        ],
                        'next_steps': [
                            'List functions: afl',
                            'Disassemble main: pdf @main',
                            'Find strings: iz',
                            'Search for hex: /x 4881ec',
                            'Graph view: VV (visual mode)',
                            'Export: pdc @main (decompile)'
                        ],
                        'alternatives': [
                            'Cutter GUI: Same as radare2 but with graphical interface',
                            'r2ghidra plugin: Use Ghidra decompiler in radare2',
                            'IDA or Binary Ninja for more advanced analysis'
                        ],
                        'notes': 'Install: apt install radare2 or use latest from GitHub releases'
                    }
                }
            ]
        })

        # TASK 5: Symbolic Execution & Constraint Solving
        tasks['children'].append({
            'id': f'symbolic-execution-{port}',
            'name': 'Symbolic Execution & Constraint Solving',
            'type': 'parent',
            'children': [
                {
                    'id': f'angr-analysis-{port}',
                    'name': 'Symbolic Execution with angr',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use angr framework for automated binary analysis and constraint solving',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED'],
                        'alternatives': [
                            'angr Python framework: pip install angr',
                            'Z3 constraint solver: pip install z3-solver',
                            'Manual reversing with Ghidra/IDA',
                            'Dynamic analysis with gdb/pwndbg'
                        ],
                        'success_indicators': [
                            'angr successfully loads binary',
                            'Symbolic execution finds target state',
                            'Constraints solved for input values'
                        ],
                        'failure_indicators': [
                            'State explosion (too many paths)',
                            'Unsupported binary features',
                            'Execution timeout'
                        ],
                        'next_steps': [
                            'Create angr project: proj = angr.Project("binary")',
                            'Define find/avoid addresses',
                            'Run simulation: simgr.explore(find=addr)',
                            'Extract solution: simgr.found[0].posix.dumps(0)'
                        ],
                        'notes': 'angr is powerful for CTF challenges but less practical for OSCP exam due to time constraints'
                    }
                },
                {
                    'id': f'z3-constraints-{port}',
                    'name': 'Constraint Solving with Z3',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use Z3 SMT solver to find input values satisfying complex constraints',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED'],
                        'alternatives': [
                            'Z3: pip install z3-solver',
                            'Manual calculation with paper and pen',
                            'Brute-force with custom script',
                            'angr symbolic execution'
                        ],
                        'success_indicators': [
                            'Z3 solver returns "sat" (satisfiable)',
                            'Model provides concrete values',
                            'Solution validates in target binary'
                        ],
                        'failure_indicators': [
                            'Solver returns "unsat" (no solution)',
                            'Constraints incorrectly modeled',
                            'Timeout on complex problems'
                        ],
                        'next_steps': [
                            'Define variables: x = BitVec("x", 32)',
                            'Add constraints: s.add(x + y == 100)',
                            'Check satisfiability: s.check()',
                            'Get solution: m = s.model(); print(m[x])'
                        ],
                        'notes': 'Z3 useful for keygen/license challenges and complex math validation'
                    }
                }
            ]
        })

        # TASK 6: Language-Specific Decompilation
        tasks['children'].append({
            'id': f'language-decompile-{port}',
            'name': 'Language-Specific Decompilation',
            'type': 'parent',
            'children': [
                {
                    'id': f'java-decompile-{port}',
                    'name': 'Decompile Java (.jar/.class)',
                    'type': 'command',
                    'metadata': {
                        'command': 'jadx app.jar -d output/',
                        'description': 'Decompile Java bytecode to source code',
                        'tags': ['OSCP:MEDIUM', 'JAVA'],
                        'flag_explanations': {
                            'jadx': 'Dex to Java decompiler (supports .jar, .apk, .dex)',
                            'app.jar': 'Target Java archive or .class file',
                            '-d': 'Output directory',
                            'output/': 'Directory for decompiled source'
                        },
                        'success_indicators': [
                            'Java source files created',
                            'Class structure preserved',
                            'Readable code with variable names'
                        ],
                        'failure_indicators': [
                            'Obfuscated code (unreadable names)',
                            'Encrypted strings or resources',
                            'jadx crashes or hangs'
                        ],
                        'next_steps': [
                            'grep -r "password\\|secret\\|key" output/',
                            'Review authentication logic',
                            'Check for hardcoded credentials',
                            'Identify API endpoints and tokens'
                        ],
                        'alternatives': [
                            'jd-gui: https://github.com/java-decompiler/jd-gui',
                            'Krakatau: Alternative decompiler',
                            'Manual: jar xf app.jar && javap -c Class.class'
                        ],
                        'notes': 'Install: apt install jadx or download from https://github.com/skylot/jadx'
                    }
                },
                {
                    'id': f'python-decompile-{port}',
                    'name': 'Decompile Python (.pyc/.pyo)',
                    'type': 'command',
                    'metadata': {
                        'command': 'uncompyle6 file.pyc > file.py',
                        'description': 'Decompile Python bytecode to source code',
                        'tags': ['OSCP:MEDIUM', 'PYTHON'],
                        'flag_explanations': {
                            'uncompyle6': 'Python bytecode decompiler (supports 2.7, 3.3-3.8)',
                            'file.pyc': 'Compiled Python bytecode',
                            '>': 'Redirect output to file',
                            'file.py': 'Decompiled Python source'
                        },
                        'success_indicators': [
                            'Valid Python source code generated',
                            'Code runs without syntax errors',
                            'Logic and variable names preserved'
                        ],
                        'failure_indicators': [
                            'Unsupported Python version',
                            'Corrupted bytecode',
                            'Obfuscated with tools like PyArmor'
                        ],
                        'next_steps': [
                            'Review for hardcoded secrets',
                            'Check for backdoors or malicious code',
                            'Analyze authentication and crypto logic',
                            'Extract embedded resources'
                        ],
                        'alternatives': [
                            'pycdc: https://github.com/zrax/pycdc',
                            'decompyle3: For Python 3.7+',
                            'Manual: dis.dis() in Python for bytecode analysis',
                            'strings file.pyc | grep -i password'
                        ],
                        'notes': 'Install: pip install uncompyle6. For .exe use PyInstaller Extractor first'
                    }
                },
                {
                    'id': f'golang-analysis-{port}',
                    'name': 'Analyze Golang Binaries',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reverse engineer Go binaries with specialized tools',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'GOLANG'],
                        'alternatives': [
                            'IDA with golang_loader_assist plugin',
                            'Ghidra with goomba plugin',
                            'redress: https://github.com/goretk/redress',
                            'Manual: strings binary | grep "go.string"'
                        ],
                        'success_indicators': [
                            'Go function names recovered',
                            'Package structure identified',
                            'Standard library calls recognized'
                        ],
                        'failure_indicators': [
                            'Stripped binary with no symbols',
                            'Heavy obfuscation applied',
                            'Custom runtime modifications'
                        ],
                        'next_steps': [
                            'Identify main.main function',
                            'Search for crypto/tls usage',
                            'Extract embedded strings and configs',
                            'Analyze network communication'
                        ],
                        'notes': 'Go binaries are large and statically linked. Focus on main package and imports'
                    }
                }
            ]
        })

        return tasks
