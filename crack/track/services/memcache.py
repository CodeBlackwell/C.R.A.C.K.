"""
Memcache service enumeration plugin

Generates tasks for Memcache distributed caching system including:
- Banner grabbing and version detection
- Slab and item enumeration
- Key dumping techniques (version-specific)
- Data exfiltration from cache
- Manual and automated enumeration

Extracted from HackTricks: network-services-pentesting/11211-memcache/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MemcachePlugin(ServicePlugin):
    """Memcache distributed caching system enumeration plugin"""

    @property
    def name(self) -> str:
        return "memcache"

    @property
    def default_ports(self) -> List[int]:
        return [11211]

    @property
    def service_names(self) -> List[str]:
        return ['memcache', 'memcached', 'memcache-server']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Memcache services"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')

        # Check service name
        if 'memcache' in service or 'memcache' in product:
            return True

        # Check common port
        if port == 11211:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Memcache enumeration task tree"""
        version = service_info.get('version', 'unknown')

        tasks = {
            'id': f'memcache-enum-{port}',
            'name': f'Memcache Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner Grabbing & Version Check
        tasks['children'].append({
            'id': f'memcache-version-{port}',
            'name': 'Memcache Version Detection',
            'type': 'command',
            'metadata': {
                'command': f'echo "version" | nc -vn -w 1 {target} {port}',
                'description': 'Grab Memcache version banner (critical for exploit selection)',
                'flag_explanations': {
                    'echo "version"': 'Send Memcache version command',
                    'nc': 'Netcat - manual TCP connection',
                    '-vn': 'Verbose output, no DNS resolution',
                    '-w 1': 'Wait 1 second for response timeout',
                    '| (pipe)': 'Send command output to nc stdin'
                },
                'success_indicators': [
                    'VERSION x.x.x response',
                    'Connection accepted',
                    'Version string returned'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Connection timeout',
                    'No response (firewall/filtering)',
                    'Protocol error'
                ],
                'next_steps': [
                    'Note version for exploit research',
                    'Versions <1.4.31 use "stats cachedump" for key enumeration',
                    'Versions >=1.4.31 use "lru_crawler metadump all"',
                    'Check for SASL authentication (rare)'
                ],
                'alternatives': [
                    f'telnet {target} {port} → type "version"',
                    f'printf "version\\r\\n" | nc {target} {port}',
                    f'nmap -p {port} --script memcached-info {target}'
                ],
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'estimated_time': '30 seconds',
                'notes': 'Most Memcache instances are exposed WITHOUT authentication (SASL rarely enabled). Memcache is a RAM cache - data appears/disappears dynamically.'
            }
        })

        # Task 2: Statistics Gathering
        tasks['children'].append({
            'id': f'memcache-stats-{port}',
            'name': 'Gather Memcache Statistics',
            'type': 'command',
            'metadata': {
                'command': f'echo "stats" | nc -vn -w 1 {target} {port}',
                'description': 'Retrieve Memcache runtime statistics (connections, memory, operations)',
                'flag_explanations': {
                    'stats': 'Memcache command to display general statistics',
                    '-w 1': '1 second timeout (sufficient for local/fast networks)'
                },
                'success_indicators': [
                    'STAT pid <value> - Process ID shown',
                    'STAT curr_items <N> - Number of cached items',
                    'STAT bytes <N> - Memory usage displayed',
                    'STAT get_hits / get_misses - Cache efficiency metrics',
                    'END marker - Complete response received'
                ],
                'failure_indicators': [
                    'Connection timeout',
                    'Empty response',
                    'ERROR response',
                    'Connection closed immediately'
                ],
                'next_steps': [
                    'Check curr_items > 0 (data exists to exfiltrate)',
                    'Note uptime and connections (server activity)',
                    'Identify evictions > 0 (memory pressure, data loss)',
                    'Proceed to slab enumeration'
                ],
                'alternatives': [
                    f'echo "stats slabs" | nc {target} {port} (memory allocation stats)',
                    f'echo "stats items" | nc {target} {port} (per-slab item counts)',
                    f'memcstat --servers={target}:{port} (requires libmemcached-tools)'
                ],
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'estimated_time': '1 minute',
                'notes': '''Key stats to check:
- curr_items: Number of cached objects (target for extraction)
- bytes: Total memory used
- evictions: If >0, cache is full (data loss occurs)
- get_hits/misses: Cache effectiveness
- limit_maxbytes: Max memory allocation (default 64MB)'''
            }
        })

        # Task 3: Slab Enumeration
        tasks['children'].append({
            'id': f'memcache-slabs-{port}',
            'name': 'Enumerate Memcache Slabs',
            'type': 'command',
            'metadata': {
                'command': f'echo "stats slabs" | nc -vn -w 1 {target} {port}',
                'description': 'List Memcache slab classes (memory organization)',
                'flag_explanations': {
                    'stats slabs': 'Display slab allocator statistics (chunk sizes, pages, memory usage)'
                },
                'success_indicators': [
                    'STAT <slab_id>:chunk_size <bytes>',
                    'STAT <slab_id>:chunks_per_page <N>',
                    'STAT <slab_id>:total_pages <N>',
                    'STAT active_slabs <N> (number of active slabs)',
                    'END marker'
                ],
                'failure_indicators': [
                    'No STAT output',
                    'ERROR response',
                    'Empty slab list (no data cached)'
                ],
                'next_steps': [
                    'Identify active slabs (slabs with used_chunks > 0)',
                    'Enumerate items in active slabs with "stats items"',
                    'Proceed to key dumping for active slabs',
                    'Estimate total cached data size'
                ],
                'alternatives': [
                    f'echo "stats items" | nc {target} {port} (item counts per slab)',
                    f'memcstat --servers={target}:{port} (libmemcached-tools)',
                    'Manual: Connect via telnet and issue commands interactively'
                ],
                'tags': ['OSCP:HIGH', 'ENUM'],
                'estimated_time': '1-2 minutes',
                'notes': '''Memcache slab memory organization:
- Slab class: Group of memory chunks of similar size
- chunk_size: Size of each memory slot (e.g., 96 bytes, 100 bytes, etc.)
- Keys are stored in slabs matching their data size
- Active slabs = slabs with cached items

Example output:
STAT 1:chunk_size 96
STAT 1:used_chunks 13106
STAT 1:total_chunks 13107
→ Slab 1 has 13106 items to extract'''
            }
        })

        # Task 4: Item Enumeration
        tasks['children'].append({
            'id': f'memcache-items-{port}',
            'name': 'Enumerate Items in Slabs',
            'type': 'command',
            'metadata': {
                'command': f'echo "stats items" | nc -vn -w 1 {target} {port}',
                'description': 'List item counts and metadata per slab class',
                'flag_explanations': {
                    'stats items': 'Display per-slab item statistics (counts, ages, evictions)'
                },
                'success_indicators': [
                    'STAT items:<slab_id>:number <count>',
                    'STAT items:<slab_id>:age <seconds>',
                    'Item counts > 0 in slabs',
                    'END marker'
                ],
                'failure_indicators': [
                    'All item counts = 0',
                    'No items stored',
                    'ERROR response'
                ],
                'next_steps': [
                    'Note slab IDs with number > 0 (contain data)',
                    'Proceed to key dumping for populated slabs',
                    'Prioritize slabs with high item counts',
                    'Check item ages (older = more stable data)'
                ],
                'alternatives': [
                    'Combine slabs + items output for complete picture',
                    f'php -r \'$c = new Memcached(); $c->addServer("{target}", {port}); var_dump($c->getAllKeys());\' (PHP method)',
                    'Use automated extraction with Metasploit auxiliary/gather/memcached_extractor'
                ],
                'tags': ['OSCP:HIGH', 'ENUM'],
                'estimated_time': '1 minute',
                'notes': '''Example output:
STAT items:1:number 220  ← Slab 1 has 220 items
STAT items:1:age 83095   ← Oldest item is 83095 seconds old
STAT items:2:number 7

Next step: Dump keys from slabs 1 and 2'''
            }
        })

        # Task 5: Key Dumping (Version-Specific)
        key_dump_task = {
            'id': f'memcache-keys-{port}',
            'name': 'Dump Cached Keys',
            'type': 'parent',
            'children': []
        }

        # Method 1: Old versions (<1.4.31)
        key_dump_task['children'].append({
            'id': f'memcache-cachedump-{port}',
            'name': 'Key Dump (Version <1.4.31)',
            'type': 'command',
            'metadata': {
                'command': f'echo "stats cachedump <SLAB_ID> 0" | nc -vn -w 1 {target} {port}',
                'description': 'Dump keys from specific slab (old method, versions <1.4.31)',
                'flag_explanations': {
                    'stats cachedump': 'Legacy command to dump keys (unofficial, may be removed)',
                    '<SLAB_ID>': 'Slab class number from "stats items" output',
                    '0': 'Unlimited output size (dump all keys in slab)',
                    'Limitations': 'Only dumps 1MB per slab, max 1 page per slab class'
                },
                'success_indicators': [
                    'ITEM <key_name> [<size> b; <timestamp> s]',
                    'Multiple ITEM entries returned',
                    'Key names revealed',
                    'END marker'
                ],
                'failure_indicators': [
                    'ERROR response (wrong slab ID)',
                    'Empty response (no items in slab)',
                    'Command not supported (version >=1.4.31)'
                ],
                'next_steps': [
                    'Repeat for all active slabs (iterate slab IDs)',
                    'Extract key names from ITEM entries',
                    'Use "get <key>" to retrieve cached values',
                    'Prioritize keys with interesting names (session, user, auth, admin, etc.)'
                ],
                'alternatives': [
                    f'Iterate slabs: for i in {{1..10}}; do echo "stats cachedump $i 0" | nc {target} {port}; done',
                    'Use PHP/Perl/Ruby scripts (see HackTricks dumping tools table)',
                    f'metasploit: use auxiliary/gather/memcached_extractor'
                ],
                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                'estimated_time': '2-5 minutes',
                'notes': '''WARNING: This command is UNOFFICIAL and may not work in newer versions.
Limitation: Only dumps 1MB per slab (may miss data in large caches).
For versions >=1.4.31, use "lru_crawler metadump all" instead.

Example workflow:
1. stats items → Slab 1 has 220 items
2. stats cachedump 1 0 → ITEM session_abc123 [256 b; 1699564800 s]
3. get session_abc123 → Retrieve cached session data'''
            }
        })

        # Method 2: New versions (>=1.4.31)
        key_dump_task['children'].append({
            'id': f'memcache-metadump-{port}',
            'name': 'Key Dump (Version >=1.4.31)',
            'type': 'command',
            'metadata': {
                'command': f'echo "lru_crawler metadump all" | nc {target} {port}',
                'description': 'Dump all keys using non-blocking LRU crawler (safe for production)',
                'flag_explanations': {
                    'lru_crawler': 'LRU (Least Recently Used) crawler component',
                    'metadump': 'Dump metadata for cached items',
                    'all': 'Dump from all slab classes',
                    'Non-blocking': 'Safe for production use (does not freeze Memcache)'
                },
                'success_indicators': [
                    'key=<key_name> exp=<expiry> la=<last_access>',
                    'Multiple key entries streamed',
                    'Metadata for all keys received',
                    'END marker'
                ],
                'failure_indicators': [
                    'ERROR response (old version, use cachedump)',
                    'Empty response (no cached items)',
                    'Connection timeout'
                ],
                'next_steps': [
                    'Parse key names from output',
                    'Filter interesting keys with grep',
                    'Retrieve values with "get <key>"',
                    'Save output for offline analysis'
                ],
                'alternatives': [
                    f'echo "lru_crawler metadump all" | nc {target} {port} | grep "key=" | cut -d= -f2 (extract keys)',
                    f'echo "lru_crawler metadump all" | nc {target} {port} | grep "session" (filter sessions)',
                    f'memcdump --servers={target}:{port} (libmemcached-tools)'
                ],
                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                'estimated_time': '2-5 minutes',
                'notes': '''Introduced in Memcache 1.4.31+ as a safer alternative to cachedump.
Non-blocking mode = production-safe (does not lock cache).
Output format: key=mykey exp=-1 la=1699564800 cas=123 fetch=yes

Use grep to filter:
- Session keys: grep "session"
- User data: grep "user"
- Authentication: grep "auth\\|token\\|jwt"'''
            }
        })

        # Method 3: Automated tools
        key_dump_task['children'].append({
            'id': f'memcache-automated-dump-{port}',
            'name': 'Automated Key Extraction (Tools)',
            'type': 'parent',
            'children': [
                {
                    'id': f'memcache-libmemcached-{port}',
                    'name': 'libmemcached-tools Extraction',
                    'type': 'command',
                    'metadata': {
                        'command': f'memcdump --servers={target}:{port} && memccat --servers={target}:{port} $(memcdump --servers={target}:{port})',
                        'description': 'Dump all keys and values using libmemcached-tools',
                        'flag_explanations': {
                            'memcdump': 'Dump all key names from Memcache',
                            '--servers=': 'Target Memcache server (host:port)',
                            'memccat': 'Retrieve values for specific keys',
                            '$(memcdump)': 'Command substitution - pass dumped keys to memccat'
                        },
                        'success_indicators': [
                            'Key names listed by memcdump',
                            'Key values displayed by memccat',
                            'Data successfully extracted'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Command not found (install: apt install libmemcached-tools)',
                            'No keys returned'
                        ],
                        'next_steps': [
                            'Save extracted data to file',
                            'Analyze cached values for sensitive data',
                            'Check for session tokens, credentials, API keys',
                            'Correlate with target application logic'
                        ],
                        'alternatives': [
                            f'memcstat --servers={target}:{port} (statistics)',
                            'PHP: $c = new Memcached(); $c->getAllKeys()',
                            'Perl/Ruby scripts (see HackTricks tools table)',
                            'Manual: Dump keys then iterate with "get <key>"'
                        ],
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'estimated_time': '3-10 minutes',
                        'notes': '''Install libmemcached-tools:
sudo apt install libmemcached-tools

Usage:
1. memcstat: Get server stats
2. memcdump: Dump key names
3. memccat: Retrieve values for keys

This method works across all Memcache versions.'''
                    }
                },
                {
                    'id': f'memcache-metasploit-{port}',
                    'name': 'Metasploit memcached_extractor',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfconsole -q -x "use auxiliary/gather/memcached_extractor; set RHOSTS {target}; set RPORT {port}; run; exit"',
                        'description': 'Automated Memcache data extraction using Metasploit',
                        'flag_explanations': {
                            'auxiliary/gather/memcached_extractor': 'Metasploit module for Memcache enumeration',
                            'RHOSTS': 'Target host(s)',
                            'RPORT': 'Target port (default 11211)',
                            '-q': 'Quiet mode (suppress banner)',
                            '-x': 'Execute commands and exit'
                        },
                        'success_indicators': [
                            'Module execution complete',
                            'Keys and values extracted',
                            'Data saved to loot directory',
                            'Summary of extracted items displayed'
                        ],
                        'failure_indicators': [
                            'Connection failed',
                            'No data extracted',
                            'Module error',
                            'Empty cache'
                        ],
                        'next_steps': [
                            'Check ~/.msf4/loot/ for extracted data',
                            'Analyze extracted cache for sensitive information',
                            'Test for session hijacking with found session IDs',
                            'Check for credentials, API keys, tokens'
                        ],
                        'alternatives': [
                            'Interactive msf: use auxiliary/gather/memcached_extractor',
                            'auxiliary/scanner/memcached/memcached_amp (DDoS amplification test)',
                            'nmap --script memcached-info',
                            'Manual extraction with nc/telnet'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Metasploit module automates the entire extraction process. Good for quick wins but manual methods provide more control and learning value for OSCP exam.'
                    }
                }
            ]
        })

        tasks['children'].append(key_dump_task)

        # Task 6: Data Exfiltration
        tasks['children'].append({
            'id': f'memcache-get-values-{port}',
            'name': 'Retrieve Cached Values',
            'type': 'command',
            'metadata': {
                'command': f'echo "get <KEY_NAME>" | nc {target} {port}',
                'description': 'Retrieve cached value for specific key (replace <KEY_NAME> with found key)',
                'flag_explanations': {
                    'get': 'Memcache command to retrieve value by key',
                    '<KEY_NAME>': 'Key name from previous enumeration (e.g., session_abc123)'
                },
                'success_indicators': [
                    'VALUE <key> <flags> <bytes>',
                    'Cached data returned',
                    'END marker',
                    'Data displayed between VALUE and END'
                ],
                'failure_indicators': [
                    'END only (key not found or expired)',
                    'ERROR response',
                    'Connection closed'
                ],
                'next_steps': [
                    'Analyze cached data for sensitive information',
                    'Check for session tokens, cookies, JWTs',
                    'Look for database query results, user data',
                    'Test session hijacking if session tokens found',
                    'Iterate through all interesting keys'
                ],
                'alternatives': [
                    f'Batch retrieval: for key in $(memcdump --servers={target}:{port}); do memccat --servers={target}:{port} $key; done',
                    f'memccat --servers={target}:{port} key1 key2 key3',
                    'PHP: $memcache->get("key_name")',
                    'Python pika library for programmatic access'
                ],
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'estimated_time': '1-2 minutes per key',
                'notes': '''Example workflow:
1. metadump finds: key=user_session_token
2. get user_session_token
3. VALUE user_session_token 0 64
   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ...
   END
4. Decode JWT, test for privilege escalation

Common interesting key patterns:
- session*, sess:*, PHPSESSID*
- user*, account*
- auth*, token*, jwt*
- admin*, api_key*
- cache:query:* (database results)'''
            }
        })

        # Task 7: Vulnerability Research
        tasks['children'].append({
            'id': f'memcache-research-{port}',
            'name': 'Memcache Vulnerability Research',
            'type': 'parent',
            'children': [
                {
                    'id': f'memcache-nmap-scripts-{port}',
                    'name': 'Nmap Memcache Scripts',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -n -sV --script memcached-info -p {port} {target}',
                        'description': 'Run Nmap NSE scripts for Memcache enumeration',
                        'flag_explanations': {
                            '-n': 'No DNS resolution (faster)',
                            '-sV': 'Service version detection',
                            '--script memcached-info': 'NSE script for Memcache information gathering',
                            '-p': 'Specify port'
                        },
                        'success_indicators': [
                            'Memcache version detected',
                            'Statistics displayed',
                            'Server information gathered'
                        ],
                        'failure_indicators': [
                            'Script execution failed',
                            'No response from target',
                            'Service not identified as Memcache'
                        ],
                        'next_steps': [
                            'Note version for exploit research',
                            'Check for UDP amplification vulnerability',
                            'Proceed to manual enumeration'
                        ],
                        'alternatives': [
                            'Manual enumeration with nc/telnet (more OSCP-relevant)',
                            f'nmap --script memcached-* -p {port} {target} (all memcache scripts)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'QUICK_WIN']
                    }
                },
                {
                    'id': f'memcache-ddos-amp-{port}',
                    'name': 'UDP DDoS Amplification Test',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfconsole -q -x "use auxiliary/scanner/memcached/memcached_amp; set RHOSTS {target}; run; exit"',
                        'description': 'Test if Memcache server is vulnerable to UDP amplification attacks',
                        'flag_explanations': {
                            'memcached_amp': 'Metasploit module for UDP amplification testing',
                            'UDP port 11211': 'Memcache also listens on UDP (if enabled)',
                            'Amplification': 'Small UDP request → Large UDP response (DDoS vector)'
                        },
                        'success_indicators': [
                            'UDP port 11211 open',
                            'Amplification factor > 1',
                            'Large responses to small requests'
                        ],
                        'failure_indicators': [
                            'UDP port filtered or closed',
                            'No amplification detected',
                            'TCP-only configuration'
                        ],
                        'next_steps': [
                            'Report UDP amplification vulnerability if found',
                            'Recommend firewall UDP 11211',
                            'Focus on TCP enumeration for data extraction'
                        ],
                        'alternatives': [
                            f'nmap -sU -p {port} {target} (UDP port scan)',
                            f'nc -u {target} {port} → stats (manual UDP test)',
                            'hping3 for manual amplification testing'
                        ],
                        'tags': ['OSCP:LOW', 'RESEARCH', 'VULN_SCAN'],
                        'notes': 'UDP amplification is a DDoS vector, not direct compromise. Low OSCP relevance but good to document in reports.'
                    }
                },
                {
                    'id': f'memcache-shodan-{port}',
                    'name': 'Shodan: Exposed Memcache Servers',
                    'type': 'research',
                    'metadata': {
                        'command': 'shodan search \'port:11211 "STAT pid"\'',
                        'description': 'Find publicly exposed Memcache servers on Shodan',
                        'tags': ['RESEARCH', 'OSCP:LOW'],
                        'notes': '''Shodan queries:
- port:11211 "STAT pid"
- "STAT pid" (general Memcache)

Exposes unsecured cache servers worldwide. Most lack authentication.'''
                    }
                }
            ]
        })

        # Task 8: Educational Notes
        tasks['children'].append({
            'id': f'memcache-notes-{port}',
            'name': 'Memcache Pentesting Notes',
            'type': 'manual',
            'metadata': {
                'description': 'Educational context and OSCP exam tips for Memcache',
                'notes': '''
MEMCACHE PENTESTING SUMMARY:

**What is Memcache?**
- Distributed memory caching system
- Caches database queries, API responses, session data in RAM
- Default port: 11211 (TCP and UDP)
- Most instances: NO AUTHENTICATION (SASL rarely enabled)

**Attack Surface:**
1. No auth → Direct data access
2. Session tokens → Session hijacking
3. Cached credentials → Lateral movement
4. API responses → Information disclosure
5. UDP amplification → DDoS vector (low priority)

**OSCP Exam Strategy:**
1. Quick wins first (version, stats, items)
2. Manual methods preferred (nc/telnet)
3. Automated tools as fallback (libmemcached, msf)
4. Focus on data exfiltration, not DDoS testing
5. Document everything (sources required!)

**Common Cached Data Types:**
- PHP sessions: PHPSESSID*, sess:*
- User data: user:*, account:*, profile:*
- Auth tokens: auth:*, token:*, jwt:*
- Database results: cache:query:*, db:*
- API responses: api:*, response:*

**Version-Specific Techniques:**
- <1.4.31: Use "stats cachedump <slab> 0"
- >=1.4.31: Use "lru_crawler metadump all"
- All versions: libmemcached-tools work universally

**Limitations:**
- Only caches RAM data (volatile)
- Items expire (TTL-based)
- No persistence across restarts
- cachedump only dumps 1MB per slab (old versions)

**OSCP Relevance: HIGH**
- Manual enumeration skills
- Protocol understanding
- Data analysis
- Session hijacking
- Quick win potential (often unsecured)

**Time Estimates:**
- Version check: 30 seconds
- Statistics: 1 minute
- Slab/item enum: 2-3 minutes
- Key dumping: 5-10 minutes
- Value extraction: 1-2 min per key
- Total: 15-30 minutes for full enumeration

**Manual Exam Workflow:**
1. nc version check → Note version
2. nc stats → Check curr_items > 0
3. nc stats items → Find active slabs
4. nc metadump (new) OR cachedump (old) → Get keys
5. nc get <key> → Extract values
6. Analyze for session tokens, creds, sensitive data
7. Test session hijacking or lateral movement
8. Document sources for writeup

**References:**
- https://lzone.de/cheat-sheet/memcached
- HackTricks: 11211 - Pentesting Memcache
- Memcache protocol: github.com/memcached/memcached/blob/master/doc/protocol.txt
''',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'alternatives': []
            }
        })

        return tasks
