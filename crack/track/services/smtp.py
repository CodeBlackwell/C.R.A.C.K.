"""
SMTP service enumeration plugin

Generates tasks for SMTP enumeration including:
- Banner grabbing and connection testing
- NTLM authentication information disclosure
- Internal server name disclosure
- User enumeration (VRFY, RCPT TO, EXPN methods)
- Open relay testing
- Command enumeration
- Mail spoofing countermeasure analysis

Extracted from HackTricks: pentesting-smtp/README.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class SMTPPlugin(ServicePlugin):
    """SMTP enumeration plugin"""

    @property
    def name(self) -> str:
        return "smtp"

    @property
    def default_ports(self) -> List[int]:
        return [25, 465, 587]

    @property
    def service_names(self) -> List[str]:
        return ['smtp', 'smtps', 'esmtp', 'sendmail', 'submission']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect SMTP services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SMTP enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'smtp-enum-{port}',
            'name': f'SMTP Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner Grabbing
        if port == 25:
            # Standard SMTP
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTP)',
                'type': 'command',
                'metadata': {
                    'command': f'nc -vn {target} {port}',
                    'description': 'Connect to SMTP server and grab banner (reveals version and hostname)',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        '-v': 'Verbose output (shows connection details)',
                        '-n': 'Numeric IP addresses only (no DNS resolution - faster)',
                        f'{port}': f'Target SMTP port {port}'
                    },
                    'success_indicators': [
                        '220 response code (service ready)',
                        'Banner contains server software and version',
                        'Hostname disclosed in banner',
                        'Connection successful'
                    ],
                    'failure_indicators': [
                        'Connection refused (firewall or service down)',
                        'Connection timeout',
                        'No banner received'
                    ],
                    'next_steps': [
                        'Note exact version for exploit research',
                        'Document hostname for internal reconnaissance',
                        'Test SMTP commands (HELO, EHLO, VRFY)',
                        'Check for NTLM auth if Windows server'
                    ],
                    'alternatives': [
                        f'telnet {target} {port}',
                        f'nmap -p{port} -sV {target}',
                        f'nmap -p{port} --script banner {target}'
                    ],
                    'notes': 'Banner often reveals OS, mail server software (Sendmail, Postfix, Exchange), and version. Critical for exploit research.',
                    'time_estimate': '10-30 seconds'
                }
            })
        elif port == 465:
            # SMTPS (SSL without STARTTLS)
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTPS SSL)',
                'type': 'command',
                'metadata': {
                    'command': f'openssl s_client -crlf -connect {target}:{port}',
                    'description': 'Connect to SMTPS over SSL/TLS (port 465) and grab banner',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        's_client': 'OpenSSL SSL/TLS client tool',
                        '-crlf': 'Translate LF to CRLF (required for SMTP protocol)',
                        '-connect': 'Host:port to connect to'
                    },
                    'success_indicators': [
                        'SSL handshake successful',
                        '220 response code',
                        'Banner with version displayed'
                    ],
                    'failure_indicators': [
                        'SSL handshake failed',
                        'Connection refused',
                        'Wrong SSL/TLS version'
                    ],
                    'next_steps': [
                        'Note SSL/TLS version used',
                        'Check certificate for hostname/domain info',
                        'Test SMTP commands over SSL'
                    ],
                    'alternatives': [
                        f'nmap -p{port} -sV --script ssl-cert {target}',
                        f'nmap -p{port} --script smtp-commands {target}'
                    ],
                    'notes': 'Port 465 uses implicit SSL (no STARTTLS). Certificate may leak internal hostnames.'
                }
            })
        elif port == 587:
            # Submission port (STARTTLS)
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTP STARTTLS)',
                'type': 'command',
                'metadata': {
                    'command': f'openssl s_client -starttls smtp -crlf -connect {target}:{port}',
                    'description': 'Connect to SMTP submission port with STARTTLS upgrade',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        '-starttls smtp': 'Start plain connection, then upgrade to TLS via STARTTLS command',
                        '-crlf': 'Translate LF to CRLF (SMTP protocol requirement)',
                        '-connect': 'Host:port to connect to'
                    },
                    'success_indicators': [
                        'STARTTLS upgrade successful',
                        '220 response after TLS handshake',
                        'Banner displayed'
                    ],
                    'failure_indicators': [
                        'STARTTLS not supported',
                        'TLS upgrade failed',
                        'Connection closed unexpectedly'
                    ],
                    'next_steps': [
                        'Test SMTP commands over TLS',
                        'Check for authentication requirements',
                        'Note encryption strength'
                    ],
                    'alternatives': [
                        f'nmap -p{port} --script smtp-commands {target}',
                        f'telnet {target} {port} (then type STARTTLS manually)'
                    ],
                    'notes': 'Port 587 is submission port, often requires authentication. STARTTLS upgrades plain connection to encrypted.'
                }
            })

        # Task 2: Find MX Servers (if domain known)
        tasks['children'].append({
            'id': f'mx-lookup-{port}',
            'name': 'MX Server Discovery',
            'type': 'manual',
            'metadata': {
                'description': 'Find mail exchange (MX) servers for organization (requires domain name)',
                'tags': ['MANUAL', 'OSCP:MEDIUM', 'QUICK_WIN'],
                'notes': f'''
If you know the organization's domain, find their mail servers:

Command: dig +short mx <DOMAIN>

Example: dig +short mx google.com

Why: MX records reveal all mail servers for a domain. May discover:
- Multiple mail servers (redundancy)
- Cloud email providers (Office365, Google Workspace)
- Internal mail server hostnames
- Email infrastructure topology

Next Steps:
- Test each MX server for open relay
- Check for different configurations per server
- Look for misconfigured backup MX servers
''',
                'success_indicators': [
                    'MX records returned',
                    'Priority numbers shown',
                    'Multiple mail servers discovered'
                ],
                'alternatives': [
                    'nslookup -type=mx <DOMAIN>',
                    'host -t MX <DOMAIN>',
                    'Online tools: mxtoolbox.com'
                ]
            }
        })

        # Task 3: Command Enumeration
        tasks['children'].append({
            'id': f'command-enum-{port}',
            'name': 'SMTP Command Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p{port} --script smtp-commands {target}',
                'description': 'Enumerate available SMTP commands (VRFY, EXPN, RCPT TO, etc.)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    f'-p{port}': f'Target port {port}',
                    '--script smtp-commands': 'NSE script to enumerate SMTP commands via EHLO/HELP'
                },
                'success_indicators': [
                    'Command list returned',
                    'VRFY command available (user enumeration possible)',
                    'EXPN command available (mailing list expansion)',
                    'RCPT TO available'
                ],
                'failure_indicators': [
                    'Script timed out',
                    'No commands enumerated',
                    'Connection refused'
                ],
                'next_steps': [
                    'If VRFY enabled: Test user enumeration',
                    'If EXPN enabled: Try mailing list expansion',
                    'If RCPT TO only: Use RCPT TO for user enum',
                    'Document which commands are disabled'
                ],
                'alternatives': [
                    f'Manual: telnet {target} {port}, then type EHLO test, then HELP',
                    f'nc {target} {port}, type EHLO, observe response'
                ],
                'notes': 'Modern servers often disable VRFY/EXPN to prevent user enumeration. RCPT TO usually available.'
            }
        })

        # Task 4: NTLM Information Disclosure (Windows servers)
        if 'windows' in version.lower() or 'microsoft' in version.lower() or 'exchange' in version.lower():
            tasks['children'].append({
                'id': f'ntlm-info-{port}',
                'name': 'NTLM Authentication Info Disclosure',
                'type': 'parent',
                'children': [
                    {
                        'id': f'ntlm-manual-{port}',
                        'name': 'NTLM Info (Manual)',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Extract internal information via NTLM authentication headers',
                            'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                            'notes': f'''
Windows SMTP servers supporting NTLM auth leak internal information in auth headers:
- Internal hostname
- Domain name
- Windows version

Manual Steps:
1. Connect: telnet {target} {port}
2. Wait for 220 banner
3. Type: HELO test
4. Wait for 250 response
5. Type: AUTH NTLM 334
6. If you see "334 NTLM supported", type: TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
7. Server responds with Base64 NTLM challenge containing version info
8. Decode Base64 response to see internal hostname, domain, Windows version

Success: Internal hostname/domain/version disclosed
Failure: AUTH NTLM not supported, authentication required

Why This Works: NTLM Type 2 challenge response contains NetBIOS domain, computer name, DNS domain, DNS hostname, and Windows version. Server sends this BEFORE authentication completes.

Next Steps:
- Document exact Windows version for exploit research
- Note internal hostname for DNS/network recon
- Use domain name for AD enumeration
''',
                            'success_indicators': [
                                '334 NTLM supported',
                                'Base64 challenge response',
                                'Internal hostname visible after decoding'
                            ],
                            'failure_indicators': [
                                'AUTH NTLM not supported',
                                '535 Authentication failed',
                                'Connection closed'
                            ]
                        }
                    },
                    {
                        'id': f'ntlm-nmap-{port}',
                        'name': 'NTLM Info (Automated)',
                        'type': 'command',
                        'metadata': {
                            'command': f'nmap -p{port} --script smtp-ntlm-info {target}',
                            'description': 'Automated NTLM information extraction via nmap',
                            'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN', 'WINDOWS'],
                            'flag_explanations': {
                                '--script smtp-ntlm-info': 'NSE script to extract NTLM info disclosure'
                            },
                            'success_indicators': [
                                'NetBIOS domain name',
                                'NetBIOS computer name',
                                'DNS domain name',
                                'DNS computer name',
                                'Windows version disclosed'
                            ],
                            'failure_indicators': [
                                'NTLM not supported',
                                'Script failed',
                                'No info disclosed'
                            ],
                            'next_steps': [
                                'Research Windows version for exploits',
                                'Use domain info for AD enumeration',
                                'Check internal hostname for other services'
                            ],
                            'alternatives': [
                                'Manual method (see NTLM Info Manual task)',
                                'Metasploit: auxiliary/scanner/smtp/smtp_ntlm_domain'
                            ],
                            'notes': 'Works on Exchange and Windows SMTP servers. Info leaked before authentication.'
                        }
                    }
                ]
            })

        # Task 5: Internal Server Name Disclosure
        tasks['children'].append({
            'id': f'internal-name-{port}',
            'name': 'Internal Server Name Disclosure',
            'type': 'manual',
            'metadata': {
                'description': 'Extract internal server name via MAIL FROM auto-completion',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'notes': f'''
Some SMTP servers auto-complete sender address, disclosing internal hostname:

Manual Steps:
1. Connect: telnet {target} {port}
2. Wait for 220 banner
3. Type: EHLO test
4. Wait for 250 response
5. Type: MAIL FROM: me
6. Server may respond: 250 2.1.0 me@INTERNAL-HOSTNAME.domain.com....Sender OK

Success: Internal hostname disclosed in MAIL FROM response
Failure: Server requires full email address, no auto-completion

Why: Some mail servers helpfully "fix" incomplete addresses by appending their internal hostname. This is especially common on older Exchange servers.

Example Response:
250 2.1.0 me@PRODSERV01.contoso.local....Sender OK
                ^-- Internal hostname leaked

Next Steps:
- Document internal hostname for reconnaissance
- Try hostname in other services (SMB, RDP, HTTP)
- Check if hostname resolves internally
''',
                'success_indicators': [
                    '250 Sender OK response',
                    'Full email address with internal hostname',
                    'Internal domain name visible'
                ],
                'failure_indicators': [
                    '553 Sender address rejected',
                    '501 Syntax error',
                    'No auto-completion'
                ]
            }
        })

        # Task 6: User Enumeration (Primary Decision Tree)
        user_enum_tasks = {
            'id': f'user-enum-{port}',
            'name': 'User Enumeration',
            'type': 'parent',
            'children': []
        }

        # Method 1: VRFY (Primary)
        user_enum_tasks['children'].append({
            'id': f'vrfy-enum-{port}',
            'name': 'User Enum: VRFY Method (Primary)',
            'type': 'parent',
            'children': [
                {
                    'id': f'vrfy-manual-{port}',
                    'name': 'VRFY Manual Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manually enumerate users via VRFY command',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': f'''
VRFY (Verify) command checks if user exists on mail server. Often disabled on modern systems.

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: VRFY root
4. Responses:
   - 250 = User exists: "250 Super-User root@hostname"
   - 550 = User unknown: "550 root... User unknown"

Test common users:
- VRFY root
- VRFY admin
- VRFY administrator
- VRFY postmaster
- VRFY webmaster

Success: Different responses for valid vs invalid users
Failure: "252 Cannot VRFY user" (command disabled), same response for all users (enumeration protection)

If VRFY Disabled: Try RCPT TO method (fallback)

Why VRFY: Direct way to verify user accounts without sending mail. Attackers use for username harvesting before password attacks.
''',
                        'success_indicators': [
                            '250 response for valid users',
                            '550 response for invalid users',
                            'Clear differentiation between valid/invalid'
                        ],
                        'failure_indicators': [
                            '252 Cannot VRFY user (command disabled)',
                            'Same response for all users',
                            '502 Command not implemented'
                        ],
                        'next_steps': [
                            'If working: Test userlist with smtp-user-enum',
                            'If disabled: Try RCPT TO method',
                            'Document discovered users'
                        ]
                    }
                },
                {
                    'id': f'vrfy-auto-{port}',
                    'name': 'VRFY Automated (smtp-user-enum)',
                    'type': 'command',
                    'metadata': {
                        'command': f'smtp-user-enum -M VRFY -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -t {target} -p {port}',
                        'description': 'Automated user enumeration via VRFY command',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            '-M VRFY': 'Method: Use VRFY command',
                            '-U': 'Userlist file path',
                            '-t': 'Target IP address',
                            f'-p {port}': f'Target port {port}'
                        },
                        'success_indicators': [
                            'Valid users found',
                            'Users listed with 250 response codes',
                            'Tool completes without errors'
                        ],
                        'failure_indicators': [
                            'No users found',
                            'VRFY disabled (252 responses)',
                            'Connection errors'
                        ],
                        'next_steps': [
                            'Save discovered users to file',
                            'Attempt password spray on valid users',
                            'Research users for social engineering'
                        ],
                        'alternatives': [
                            f'nmap -p{port} --script smtp-enum-users --script-args smtp-enum-users.methods={{VRFY}} {target}',
                            'Metasploit: auxiliary/scanner/smtp/smtp_enum',
                            f'Manual: telnet {target} {port}, then VRFY <username>'
                        ],
                        'notes': 'Use small wordlist for speed. Common usernames: root, admin, administrator, postmaster, webmaster, info, sales, support.'
                    }
                }
            ]
        })

        # Method 2: RCPT TO (Fallback)
        user_enum_tasks['children'].append({
            'id': f'rcpt-enum-{port}',
            'name': 'User Enum: RCPT TO Method (Fallback)',
            'type': 'parent',
            'children': [
                {
                    'id': f'rcpt-manual-{port}',
                    'name': 'RCPT TO Manual Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Enumerate users via RCPT TO command (reliable fallback when VRFY disabled)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': f'''
RCPT TO method: More reliable than VRFY, rarely disabled (required for mail delivery).

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: MAIL FROM:test@example.com
4. Type: RCPT TO:root
5. Responses:
   - 250 = User exists: "250 2.1.5 root... Recipient ok"
   - 550 = User unknown: "550 5.1.1 root... User unknown"

Full Example:
$ telnet {target} {port}
220 mailserver ESMTP
HELO test
250 mailserver Hello
MAIL FROM:test@example.com
250 2.1.0 test@example.com... Sender ok
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:root
250 2.1.5 root... Recipient ok  <-- USER EXISTS

Why RCPT TO Works: Server must check if recipient exists to route mail. Rarely disabled. More reliable than VRFY.

Test Common Users: root, admin, administrator, postmaster, webmaster, user, test
''',
                        'success_indicators': [
                            '250 Recipient ok (user exists)',
                            '550 User unknown (user doesn\'t exist)',
                            'Clear differentiation in responses'
                        ],
                        'failure_indicators': [
                            'Authentication required',
                            'Same response for all users',
                            'Connection closed'
                        ],
                        'next_steps': [
                            'If working: Automate with smtp-user-enum',
                            'Document valid users',
                            'Try password spray on discovered accounts'
                        ]
                    }
                },
                {
                    'id': f'rcpt-auto-{port}',
                    'name': 'RCPT TO Automated',
                    'type': 'command',
                    'metadata': {
                        'command': f'smtp-user-enum -M RCPT -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -t {target} -p {port} -D example.com',
                        'description': 'Automated user enumeration via RCPT TO (most reliable method)',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            '-M RCPT': 'Method: Use RCPT TO command',
                            '-U': 'Userlist file path',
                            '-t': 'Target IP address',
                            f'-p {port}': f'Target port {port}',
                            '-D example.com': 'Domain to test (use target domain if known)'
                        },
                        'success_indicators': [
                            'Valid users discovered',
                            '250 responses for existing users',
                            'Tool completes successfully'
                        ],
                        'failure_indicators': [
                            'No users found',
                            'Authentication required before RCPT TO',
                            'All same responses (enum protection)'
                        ],
                        'next_steps': [
                            'Save valid usernames',
                            'Attempt credential attacks',
                            'Research user roles'
                        ],
                        'alternatives': [
                            f'nmap -p{port} --script smtp-enum-users --script-args smtp-enum-users.methods={{RCPT}} {target}',
                            'Metasploit: auxiliary/scanner/smtp/smtp_enum with RCPT method',
                            'Manual: See RCPT TO Manual Test'
                        ],
                        'notes': 'RCPT TO more reliable than VRFY. Required for mail delivery, rarely disabled. Replace example.com with actual target domain if known.'
                    }
                }
            ]
        })

        # Method 3: EXPN (Mailing Lists)
        user_enum_tasks['children'].append({
            'id': f'expn-enum-{port}',
            'name': 'User Enum: EXPN Method (Mailing Lists)',
            'type': 'manual',
            'metadata': {
                'description': 'Expand mailing lists via EXPN command',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': f'''
EXPN (Expand) command expands mailing lists/aliases to show member addresses.

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: EXPN root
4. Response: 250 2.1.5 ed.williams@mailserver (list members)

Example:
EXPN sshd
250 2.1.5 sshd privsep sshd@mailserver
EXPN test
550 5.1.1 test... User unknown

Common Aliases to Test:
- EXPN root (often maps to actual admin)
- EXPN postmaster
- EXPN admin
- EXPN all
- EXPN staff
- EXPN users

Success: Mailing list expanded, member emails disclosed
Failure: "252 Cannot EXPN" (command disabled), "550 User unknown"

Why: EXPN reveals actual user accounts behind aliases. Less common than VRFY/RCPT TO, often disabled.

If EXPN Disabled: Already tried VRFY and RCPT TO (better methods)
''',
                'success_indicators': [
                    '250 response with expanded list',
                    'Multiple email addresses returned',
                    'Alias resolved to real user'
                ],
                'failure_indicators': [
                    '252 Cannot EXPN',
                    '502 Command not implemented',
                    '550 User unknown for all tests'
                ],
                'next_steps': [
                    'Document revealed email addresses',
                    'Note username patterns (firstname.lastname, etc)',
                    'Cross-reference with other discovered users'
                ]
            }
        })

        # Add complete user enumeration tree
        tasks['children'].append(user_enum_tasks)

        # Task 7: Open Relay Testing
        tasks['children'].append({
            'id': f'open-relay-{port}',
            'name': 'Open Relay Testing',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p{port} --script smtp-open-relay {target} -v',
                'description': 'Test if SMTP server is an open relay (accepts mail from/to any address)',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    f'-p{port}': f'Target port {port}',
                    '--script smtp-open-relay': 'NSE script to test open relay configuration',
                    '-v': 'Verbose output (shows test attempts)'
                },
                'success_indicators': [
                    'Server is an open relay',
                    'Test email accepted from external source',
                    'Relay allowed for any sender/recipient'
                ],
                'failure_indicators': [
                    'Relay access denied',
                    '550 Relaying denied',
                    'Authentication required'
                ],
                'next_steps': [
                    'If open relay: Document critical vulnerability',
                    'Test email spoofing (send test mail)',
                    'Check SPF/DKIM/DMARC records for domain',
                    'Report as high-severity misconfiguration'
                ],
                'alternatives': [
                    f'''Manual test:
telnet {target} {port}
HELO test
MAIL FROM:attacker@external.com
RCPT TO:victim@external.com
(If accepted, it's an open relay)''',
                    'Metasploit: auxiliary/scanner/smtp/smtp_relay'
                ],
                'notes': '''
Open Relay: SMTP server configured to accept/forward email from any source to any destination.

Security Impact:
- Spammers abuse for bulk email
- Attackers use for phishing campaigns
- Can send mail appearing to come from organization
- May blacklist organization's mail server

Common Misconfigurations:
- mynetworks = 0.0.0.0/0 (accepts all IPs)
- No sender/recipient restrictions
- No authentication required

Modern servers rarely open relays, but still found on legacy systems.
'''
            }
        })

        # Task 8: Authentication Brute-force
        tasks['children'].append({
            'id': f'smtp-bruteforce-{port}',
            'name': 'Authentication Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} smtp -s {port} -v',
                'description': 'Brute-force SMTP authentication (try discovered users first)',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-l admin': 'Username to test (replace with discovered username)',
                    '-P': 'Password wordlist',
                    'smtp': 'Protocol/service to attack',
                    f'-s {port}': f'Service port {port}',
                    '-v': 'Verbose output (show attempts)'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[25][smtp] host: X login: Y password: Z',
                    'Authentication successful'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Connection rate-limited'
                ],
                'next_steps': [
                    'If successful: Document credentials',
                    'Test credentials on other services (SSH, SMB, HTTP)',
                    'Send test email as authenticated user',
                    'Check for mail access (IMAP/POP3)'
                ],
                'alternatives': [
                    f'medusa -h {target} -u admin -P passwords.txt -M smtp',
                    f'ncrack -p {port} -u admin -P passwords.txt {target}',
                    'Manual: telnet, AUTH PLAIN, test common passwords'
                ],
                'notes': '''
Only attempt after user enumeration. Use discovered usernames for targeted attack.

Smart Strategy:
1. Test default creds first: admin/admin, postmaster/postmaster
2. Password spray: Test one password across all users (avoid lockout)
3. Small custom wordlist: Company name, year, common passwords

OSCP Exam: SMTP brute-force rarely necessary. Try default credentials first.

Time: Can be slow. Allocate 10-30 minutes max for exam.
''',
                'time_estimate': '10-30 minutes (depending on wordlist size)'
            }
        })

        # Task 9: Mail Spoofing Checks (SPF/DKIM/DMARC)
        tasks['children'].append({
            'id': f'spoofing-checks-{port}',
            'name': 'Mail Spoofing Countermeasures',
            'type': 'manual',
            'metadata': {
                'description': 'Check SPF, DKIM, DMARC records for mail spoofing potential',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': f'''
Organizations use SPF, DKIM, DMARC to prevent email spoofing.

Commands (requires domain name):
1. SPF Check:
   dig txt <DOMAIN> | grep spf
   dig txt _spf.<DOMAIN>

2. DMARC Check:
   dig txt _dmarc.<DOMAIN>

3. DKIM Check:
   dig txt <SELECTOR>._domainkey.<DOMAIN>
   (selector found in email headers)

Success: Records exist and properly configured
Failure: No records found, weak policies

What to Look For:

SPF:
- "v=spf1 ~all" = SOFTFAIL (accepts but marks)
- "v=spf1 -all" = FAIL (rejects)
- "v=spf1 +all" = MISCONFIGURED (accepts all - spoofing possible!)

DMARC:
- "p=none" = Monitor only (spoofing possible)
- "p=quarantine" = Mark as spam
- "p=reject" = Reject spoofed mail

No Records: Email spoofing likely possible (old/small organizations)

Next Steps:
- If weak/missing: Test email spoofing via web contact forms
- If strong: Spoofing unlikely to succeed
- Document for social engineering assessment

Tools:
- mxtoolbox.com (online SPF/DMARC checker)
- checkdmarc (pip install checkdmarc)
''',
                'success_indicators': [
                    'SPF/DKIM/DMARC records found',
                    'Policy strengths determined',
                    'Spoofing potential assessed'
                ],
                'failure_indicators': [
                    'No DNS records for target domain',
                    'Domain name unknown',
                    'DNS resolution failed'
                ],
                'alternatives': [
                    'Online: mxtoolbox.com/spf.aspx',
                    'Tool: checkdmarc <DOMAIN>',
                    'dig queries as shown above'
                ]
            }
        })

        # Task 10: Exploit Research (if version detected)
        if version:
            tasks['children'].append({
                'id': f'exploit-research-{port}',
                'name': f'Exploit Research: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-smtp-{port}',
                        'name': f'SearchSploit: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit {version}',
                            'description': 'Search ExploitDB for known SMTP vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': [
                                'Exploits found for version',
                                'CVE numbers identified',
                                'PoC code available'
                            ],
                            'failure_indicators': [
                                'No exploits found',
                                'Version too new/old',
                                'Search returned unrelated results'
                            ],
                            'next_steps': [
                                'Review exploit code for applicability',
                                'Test PoC in safe environment first',
                                'Check exploit prerequisites',
                                'Read exploit documentation'
                            ],
                            'alternatives': [
                                f'searchsploit {product}',
                                'Google: "{version} exploit"',
                                'exploit-db.com search'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-smtp-{port}',
                        'name': f'CVE Lookup: {version}',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Search CVE databases for version-specific vulnerabilities',
                            'tags': ['RESEARCH', 'OSCP:HIGH'],
                            'notes': f'''
Research {version} vulnerabilities:

1. CVE Search:
   - cve.mitre.org
   - nvd.nist.gov
   - cvedetails.com

2. Search Terms:
   - "{version} vulnerability"
   - "{product} exploit"
   - "{version} CVE"

3. GitHub:
   - github.com/search?q={version}+exploit

Known SMTP Vulnerabilities to Check:
- Buffer overflows (old Sendmail versions)
- Command injection (VRFY/EXPN vulnerabilities)
- Authentication bypass
- Remote code execution

Common Vulnerable Versions:
- Sendmail < 8.12.9 (multiple CVEs)
- Exim < 4.92 (CVE-2019-10149 RCE)
- OpenSMTPD < 6.6.2 (CVE-2020-7247 RCE)

Next Steps:
- Download PoC exploits
- Verify version match
- Test in isolated environment
- Document exploit path
''',
                            'success_indicators': [
                                'CVE found for exact version',
                                'Exploit available',
                                'Verified vulnerability applies'
                            ]
                        }
                    }
                ]
            })

        return tasks
