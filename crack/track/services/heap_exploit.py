"""
Heap Exploitation Analysis Plugin

Generates tasks for heap vulnerability analysis and exploitation including:
- Heap structure inspection (chunks, bins, arenas)
- Common heap vulnerabilities (UAF, double-free, overflow, tcache/fastbin attacks)
- Debugging commands (gdb, pwndbg, heap visualization)
- Exploitation technique guidance

Extracted from HackTricks: binary-exploitation/libc-heap/
Generated for CRACK Track - Binary Exploitation Edition

NOTE: This plugin is NOT auto-detected. It must be manually triggered when
      analyzing binaries with potential heap vulnerabilities.
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class HeapExploitPlugin(ServicePlugin):
    """Heap exploitation analysis and debugging plugin"""

    @property
    def name(self) -> str:
        return "heap-exploit"

    @property
    def default_ports(self) -> List[int]:
        # Not port-based - manual activation
        return []

    @property
    def service_names(self) -> List[str]:
        # Not service-based - manual activation for binary analysis
        return ['heap-analysis', 'binary-exploitation', 'heap-vuln']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        This plugin is NOT auto-detected.
        Must be manually activated when analyzing binaries.

        To use: Manually add heap exploitation tasks to a target profile.
        """
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate heap exploitation analysis task tree

        Args:
            target: Binary file path or target identifier
            port: Not used (set to 0)
            service_info: Should contain:
                - 'binary_path': Path to binary for analysis
                - 'libc_version': Optional libc version (e.g., '2.31')
                - 'arch': Architecture (e.g., 'x86_64', 'arm64')

        Returns:
            Complete task tree for heap exploitation workflow
        """
        binary_path = service_info.get('binary_path', target)
        libc_version = service_info.get('libc_version', 'unknown')
        arch = service_info.get('arch', 'x86_64')

        tasks = {
            'id': 'heap-exploit-root',
            'name': f'Heap Exploitation Analysis: {binary_path}',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: INITIAL ANALYSIS ===
        tasks['children'].append(self._create_initial_analysis_tasks(binary_path, arch))

        # === PHASE 2: HEAP STRUCTURE INSPECTION ===
        tasks['children'].append(self._create_heap_inspection_tasks(binary_path))

        # === PHASE 3: VULNERABILITY IDENTIFICATION ===
        tasks['children'].append(self._create_vuln_identification_tasks(binary_path))

        # === PHASE 4: EXPLOITATION TECHNIQUES ===
        tasks['children'].append(self._create_exploitation_techniques_tasks(binary_path, libc_version))

        # === PHASE 5: DEBUGGING & ANALYSIS TOOLS ===
        tasks['children'].append(self._create_debugging_tasks(binary_path))

        return tasks

    def _create_initial_analysis_tasks(self, binary_path: str, arch: str) -> Dict[str, Any]:
        """Phase 1: Initial binary analysis"""
        return {
            'id': 'heap-initial-analysis',
            'name': 'Phase 1: Initial Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'checksec',
                    'name': 'Check Binary Protections',
                    'type': 'command',
                    'metadata': {
                        'command': f'checksec --file={binary_path}',
                        'description': 'Identify enabled security features (RELRO, Stack Canary, NX, PIE, FORTIFY)',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            '--file': 'Specify binary file to analyze',
                            'RELRO': 'Relocation Read-Only (Full=harder GOT overwrite, Partial=possible)',
                            'Stack Canary': 'Stack overflow protection (not heap-related)',
                            'NX': 'No-Execute bit (requires ROP/ret2libc, not shellcode on heap)',
                            'PIE': 'Position Independent Executable (ASLR for binary, complicates exploitation)',
                            'FORTIFY': 'Buffer overflow detection in libc functions'
                        },
                        'success_indicators': [
                            'Output shows protection status for each mechanism',
                            'Identifies weak points (No PIE = easier address calculation)'
                        ],
                        'failure_indicators': [
                            'checksec not installed (install with: sudo apt install checksec)',
                            'File not found - verify binary path'
                        ],
                        'next_steps': [
                            'If No PIE: addresses are static, easier exploitation',
                            'If Partial RELRO: GOT overwrite possible',
                            'If NX enabled: need ROP chain or ret2libc (no heap shellcode)',
                            'Note protections for exploit planning'
                        ],
                        'alternatives': [
                            f'readelf -l {binary_path} | grep GNU_STACK  # Check NX',
                            f'readelf -h {binary_path} | grep Type      # Check PIE',
                            f'rabin2 -I {binary_path}                   # radare2 binary info'
                        ],
                        'estimated_time': '30 seconds',
                        'notes': 'FORTIFY_SOURCE can be bypassed if used incorrectly (see CVE-2025-40597)'
                    }
                },
                {
                    'id': 'identify-libc',
                    'name': 'Identify libc Version',
                    'type': 'command',
                    'metadata': {
                        'command': f'ldd {binary_path}',
                        'description': 'Identify linked libc version (critical for exploit compatibility)',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            'ldd': 'List dynamic dependencies',
                            'libc.so.6': 'Main C library (contains malloc/free implementation)',
                            '=>': 'Shows actual library path being used'
                        },
                        'success_indicators': [
                            'libc path shown (e.g., /lib/x86_64-linux-gnu/libc.so.6)',
                            'Version visible in path or via strings'
                        ],
                        'failure_indicators': [
                            '"not a dynamic executable" - statically linked binary',
                            'Custom libc path - may need manual analysis'
                        ],
                        'next_steps': [
                            'Run: strings /path/to/libc.so.6 | grep "GNU C Library" # Get version',
                            'Check libc version: 2.26+ has tcache, older versions use only fastbin',
                            'Download libc symbols for debugging',
                            'Find libc-database matches for address leaks'
                        ],
                        'alternatives': [
                            f'readelf -d {binary_path} | grep NEEDED',
                            f'file {binary_path}',
                            'strings libc.so.6 | grep -i version'
                        ],
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'heap-functions-check',
                    'name': 'Identify Heap Functions',
                    'type': 'command',
                    'metadata': {
                        'command': f'nm {binary_path} | grep -E "(malloc|free|calloc|realloc)"',
                        'description': 'Check if binary uses heap allocation functions',
                        'tags': ['QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            'nm': 'List symbols from object files',
                            '-E': 'Extended regex pattern matching',
                            'malloc': 'Allocate heap memory',
                            'free': 'Deallocate heap memory',
                            'calloc': 'Allocate zeroed memory',
                            'realloc': 'Resize allocated memory'
                        },
                        'success_indicators': [
                            'Shows "U malloc" (undefined = imported from libc)',
                            'Multiple heap functions found'
                        ],
                        'failure_indicators': [
                            'No heap functions found - binary may not use heap',
                            'Statically linked - symbols not visible'
                        ],
                        'next_steps': [
                            'If malloc/free present: heap exploitation possible',
                            'If only malloc: look for memory leaks',
                            'Disassemble functions calling malloc to understand usage'
                        ],
                        'alternatives': [
                            f'objdump -T {binary_path} | grep malloc',
                            f'rabin2 -i {binary_path} | grep malloc',
                            'Dynamic analysis: ltrace ./binary (shows malloc calls)'
                        ],
                        'estimated_time': '30 seconds'
                    }
                }
            ]
        }

    def _create_heap_inspection_tasks(self, binary_path: str) -> Dict[str, Any]:
        """Phase 2: Heap structure inspection with gdb/pwndbg"""
        return {
            'id': 'heap-inspection',
            'name': 'Phase 2: Heap Structure Inspection',
            'type': 'parent',
            'children': [
                {
                    'id': 'gdb-heap-basics',
                    'name': 'GDB Heap Inspection Basics',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Core GDB commands for heap analysis',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ENUM'],
                        'notes': [
                            '# Launch with pwndbg (enhanced GDB)',
                            f'gdb {binary_path}',
                            '',
                            '# Set breakpoint after malloc',
                            'break main',
                            'run',
                            'break malloc',
                            'continue',
                            '',
                            '# Basic heap commands (pwndbg)',
                            'heap         # Show all heap chunks',
                            'bins         # Show fastbins, tcache, unsorted bins',
                            'arena        # Show arena information',
                            'vis_heap_chunks  # Visualize heap layout',
                            '',
                            '# Standard GDB heap inspection',
                            'x/40gx $rax-0x10    # Examine malloc return (include metadata)',
                            'p *(mchunkptr)($rax-0x10)  # Print chunk structure',
                            'x/gx &main_arena   # Examine main arena (if symbol available)'
                        ],
                        'alternatives': [
                            'pwndbg - Enhanced GDB with heap commands',
                            'gef - Another GDB enhancement with heap support',
                            'peda - Python Exploit Development Assistance'
                        ]
                    }
                },
                {
                    'id': 'pwndbg-heap-analysis',
                    'name': 'pwndbg Heap Analysis Commands',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Comprehensive pwndbg heap inspection workflow',
                        'tags': ['MANUAL', 'ENUM'],
                        'notes': [
                            '# Install pwndbg',
                            'git clone https://github.com/pwndbg/pwndbg',
                            'cd pwndbg && ./setup.sh',
                            '',
                            '# Key pwndbg heap commands',
                            'heap                    # Overview of all chunks',
                            'heap -v                 # Verbose chunk information',
                            'bins                    # Show all bins (fast, tcache, small, large, unsorted)',
                            'fastbins                # Fastbin linked lists',
                            'tcachebins              # Tcache bins (glibc 2.26+)',
                            'unsortedbin             # Unsorted bin contents',
                            'smallbins               # Small bins',
                            'largebins               # Large bins',
                            '',
                            '# Chunk-specific',
                            'malloc_chunk ADDRESS    # Parse chunk at address',
                            'vis_heap_chunks         # ASCII visualization',
                            'heap_config             # Show heap configuration',
                            '',
                            '# Arena inspection',
                            'arena                   # Current arena info',
                            'arenas                  # All arenas (multithreaded)',
                            'top_chunk               # Show top chunk',
                            '',
                            '# Finding chunks',
                            'find_fake_fast ADDRESS SIZE  # Find fake fast chunks for exploitation'
                        ],
                        'alternatives': [
                            'GEF: gef-heap commands',
                            'Manual: parse heap with Python pwntools + GDB'
                        ]
                    }
                },
                {
                    'id': 'heap-chunk-structure',
                    'name': 'Understanding Chunk Structure',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Learn heap chunk metadata layout',
                        'tags': ['MANUAL', 'RESEARCH'],
                        'notes': [
                            '# Chunk Structure (glibc malloc_chunk)',
                            'struct malloc_chunk {',
                            '  size_t mchunk_prev_size;  // Size of previous chunk if free',
                            '  size_t mchunk_size;       // Size + 3 flag bits (AMP)',
                            '  struct malloc_chunk* fd;  // Forward pointer (free chunks only)',
                            '  struct malloc_chunk* bk;  // Backward pointer (free chunks only)',
                            '  // Large chunks also have:',
                            '  struct malloc_chunk* fd_nextsize;',
                            '  struct malloc_chunk* bk_nextsize;',
                            '};',
                            '',
                            '# Flag Bits in mchunk_size (last 3 bits)',
                            'P (0x1): PREV_INUSE - Previous chunk is in use',
                            'M (0x2): IS_MMAPPED - Chunk obtained via mmap',
                            'A (0x4): NON_MAIN_ARENA - Chunk from thread arena',
                            '',
                            '# Example: size 0x91 means:',
                            '  Size: 0x90 (144 bytes)',
                            '  P=1: Previous chunk in use',
                            '  M=0: Not mmapped',
                            '  A=0: Main arena',
                            '',
                            '# Minimum chunk size',
                            'x86: 0x10 (16 bytes) - 8 byte header + 8 byte user data',
                            'x86_64: 0x20 (32 bytes) - 16 byte header + 16 byte user data',
                            '',
                            '# Alignment',
                            'All chunks 16-byte aligned (last 4 bits of address = 0)'
                        ],
                        'alternatives': [
                            'Read glibc source: malloc/malloc.c',
                            'HackTricks heap basics: https://book.hacktricks.xyz/binary-exploitation/libc-heap'
                        ]
                    }
                },
                {
                    'id': 'bins-explained',
                    'name': 'Understanding Bins (Fastbin, Tcache, Unsorted, Small, Large)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Learn heap bin organization for free chunks',
                        'tags': ['MANUAL', 'RESEARCH'],
                        'notes': [
                            '# Heap Bins Overview',
                            'Bins are data structures storing freed chunks for reuse.',
                            '',
                            '# 1. FASTBINS (sizes 0x20-0x80, 10 bins)',
                            '   - LIFO singly-linked list',
                            '   - No coalescing with neighbors',
                            '   - Fast allocation/deallocation',
                            '   - Exploitation: Fastbin attack (overwrite fd pointer)',
                            '',
                            '# 2. TCACHE (Thread Cache, glibc 2.26+)',
                            '   - Per-thread cache (7 chunks per size)',
                            '   - Sizes 0x20-0x410 (64 bins)',
                            '   - LIFO singly-linked list',
                            '   - Minimal security checks (easier to exploit)',
                            '   - Exploitation: Tcache poisoning (overwrite next pointer)',
                            '',
                            '# 3. UNSORTED BIN (recently freed chunks)',
                            '   - Doubly-linked list',
                            '   - All sizes',
                            '   - Temporary storage before sorting into small/large bins',
                            '   - Exploitation: Unsorted bin attack',
                            '',
                            '# 4. SMALL BINS (sizes < 1024 bytes, 62 bins)',
                            '   - Doubly-linked FIFO lists',
                            '   - Exact size match',
                            '   - Coalescing enabled',
                            '',
                            '# 5. LARGE BINS (sizes >= 1024 bytes)',
                            '   - Doubly-linked lists sorted by size',
                            '   - fd_nextsize/bk_nextsize for size traversal',
                            '   - Exploitation: Large bin attack',
                            '',
                            '# Allocation Order (glibc 2.26+):',
                            '  1. Tcache (if available)',
                            '  2. Fastbin',
                            '  3. Small bin',
                            '  4. Unsorted bin',
                            '  5. Large bin',
                            '  6. Top chunk',
                            '  7. mmap (if size > mmap_threshold)'
                        ],
                        'alternatives': [
                            'Visualize with: pwndbg> bins',
                            'Read: Azeria Labs heap exploitation series'
                        ]
                    }
                }
            ]
        }

    def _create_vuln_identification_tasks(self, binary_path: str) -> Dict[str, Any]:
        """Phase 3: Common heap vulnerability identification"""
        return {
            'id': 'heap-vuln-identification',
            'name': 'Phase 3: Vulnerability Identification',
            'type': 'parent',
            'children': [
                {
                    'id': 'uaf-check',
                    'name': 'Check for Use-After-Free (UAF)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify use-after-free vulnerabilities',
                        'tags': ['MANUAL', 'OSCP:LOW', 'VULN_SCAN'],
                        'notes': [
                            '# Use-After-Free: Accessing freed memory',
                            '',
                            '# Vulnerable Pattern:',
                            'char *ptr = malloc(0x20);',
                            'free(ptr);',
                            'printf("%s", ptr);  // UAF - reading freed memory',
                            'strcpy(ptr, "new");  // UAF - writing freed memory',
                            '',
                            '# Why Dangerous:',
                            '  - Freed memory reused for different object',
                            '  - Attacker controls "new" object content',
                            '  - Old pointer accesses attacker-controlled data',
                            '  - Can lead to: arbitrary read/write, RCE',
                            '',
                            '# Detection Methods:',
                            '1. Code Review:',
                            '   - Search for free() calls',
                            '   - Check if pointer used after free()',
                            '   - Look for missing ptr = NULL after free',
                            '',
                            '2. Dynamic Analysis:',
                            '   gdb> break free',
                            '   gdb> commands',
                            '   > bt  # Backtrace to see caller',
                            '   > continue',
                            '   > end',
                            '   # Watch if same address accessed later',
                            '',
                            '3. Valgrind:',
                            f'   valgrind --leak-check=full {binary_path}',
                            '   # Reports "Invalid read/write" for UAF',
                            '',
                            '# Exploitation:',
                            '  - Fill tcache/fastbin',
                            '  - Free vulnerable object',
                            '  - Allocate attacker-controlled object (same size)',
                            '  - Trigger UAF on old pointer',
                            '  - Old pointer now points to attacker data'
                        ],
                        'alternatives': [
                            'AddressSanitizer: compile with -fsanitize=address',
                            'Fuzzers: AFL, libFuzzer with ASAN'
                        ]
                    }
                },
                {
                    'id': 'double-free-check',
                    'name': 'Check for Double-Free',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify double-free vulnerabilities',
                        'tags': ['MANUAL', 'OSCP:LOW', 'VULN_SCAN'],
                        'notes': [
                            '# Double-Free: Freeing same chunk twice',
                            '',
                            '# Vulnerable Pattern:',
                            'char *ptr = malloc(0x20);',
                            'free(ptr);',
                            'free(ptr);  // Double-free!',
                            '',
                            '# Protection Bypass (Fastbin):',
                            'char *a = malloc(0x20);',
                            'char *b = malloc(0x20);',
                            'free(a);',
                            'free(b);  // Different chunk in between',
                            'free(a);  // Now double-free bypasses check!',
                            '',
                            '# Why Dangerous:',
                            '  - Corrupts bin linked list',
                            '  - Same chunk in bin twice',
                            '  - malloc() can return same address multiple times',
                            '  - Two pointers -> one memory = control both',
                            '',
                            '# Detection:',
                            '1. Double-free check (glibc):',
                            '   "free(): double free detected in tcache 2"',
                            '   (Only catches immediate double-free)',
                            '',
                            '2. GDB Watchpoint:',
                            '   gdb> watch -l *(void**)$chunk_address',
                            '   # Breaks when chunk fd pointer changes',
                            '',
                            '3. Valgrind:',
                            f'   valgrind {binary_path}',
                            '   # Reports "Invalid free()"',
                            '',
                            '# Exploitation:',
                            '  - Trigger double-free with bypass',
                            '  - Allocate chunk (gets first free)',
                            '  - Overwrite fd pointer to target address',
                            '  - Allocate again (gets legit chunk)',
                            '  - Allocate third time (gets target address)',
                            '  - Write arbitrary data to target'
                        ],
                        'alternatives': [
                            'ASAN: -fsanitize=address detects immediately',
                            'Manual: track all free() calls'
                        ]
                    }
                },
                {
                    'id': 'heap-overflow-check',
                    'name': 'Check for Heap Overflow',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify heap buffer overflow vulnerabilities',
                        'tags': ['MANUAL', 'OSCP:LOW', 'VULN_SCAN'],
                        'notes': [
                            '# Heap Overflow: Write beyond allocated size',
                            '',
                            '# Vulnerable Pattern:',
                            'char *buf = malloc(0x10);',
                            'strcpy(buf, user_input);  // No size check!',
                            'gets(buf);  // Unbounded read',
                            'sprintf(buf, "%s%s", str1, str2);  // No length check',
                            '',
                            '# Why Dangerous:',
                            '  - Overwrites next chunk metadata',
                            '  - Can modify: size, fd, bk pointers',
                            '  - Leads to: arbitrary write, code execution',
                            '',
                            '# Detection Methods:',
                            '1. Code Review:',
                            '   - Dangerous: strcpy, gets, sprintf, strcat',
                            '   - Safe: strncpy, fgets, snprintf, strncat',
                            '   - Check: input size vs allocation size',
                            '',
                            '2. Fuzzing:',
                            '   - Send oversized inputs',
                            '   - Monitor for crashes',
                            '   echo "A"*1000 | ./binary',
                            '',
                            '3. Pattern Matching:',
                            '   python3 -c "from pwn import *; print(cyclic(1000))" | ./binary',
                            '   # Use cyclic pattern to find offset',
                            '   gdb> x/gx $crashed_address',
                            '   cyclic_find(0x6161616161616165)  # Offset',
                            '',
                            '# Exploitation:',
                            '  - Overflow into next chunk',
                            '  - Overwrite chunk size field',
                            '  - Overwrite fd/bk pointers (when freed)',
                            '  - Trigger allocation/free to exploit corrupted metadata',
                            '',
                            '# Example: Chunk Consolidation',
                            '  - Overwrite prev_size and PREV_INUSE bit',
                            '  - Free next chunk',
                            '  - Heap manager thinks prev chunk is free',
                            '  - Consolidates in-use chunk -> corruption'
                        ],
                        'alternatives': [
                            'ASAN: detects heap overflows',
                            'Valgrind: sgcheck plugin',
                            'GDB: rwatch on chunk boundaries'
                        ]
                    }
                },
                {
                    'id': 'off-by-one-check',
                    'name': 'Check for Off-By-One',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify off-by-one heap vulnerabilities',
                        'tags': ['MANUAL', 'VULN_SCAN'],
                        'notes': [
                            '# Off-By-One: Write one byte past buffer',
                            '',
                            '# Vulnerable Pattern:',
                            'char *buf = malloc(0x10);',
                            'for(int i=0; i<=0x10; i++)  # Should be < not <=',
                            '    buf[i] = user_input[i];',
                            '',
                            '# Why Dangerous:',
                            '  - Overwrites 1 byte of next chunk metadata',
                            '  - Can clear PREV_INUSE bit',
                            '  - Triggers chunk consolidation attacks',
                            '',
                            '# Common Causes:',
                            '  - strncpy(buf, src, size+1);  # Off by one',
                            '  - for(i=0; i<=size; i++)      # Should be <',
                            '  - buf[strlen(buf)] = 0;       # Already null',
                            '',
                            '# Exploitation:',
                            '  - Overwrite next chunk size low byte',
                            '  - Change 0x101 -> 0x100 (clears PREV_INUSE)',
                            '  - Heap manager thinks previous chunk is free',
                            '  - Free next chunk -> consolidates wrong chunks',
                            '  - Overlapping chunks -> arbitrary read/write'
                        ],
                        'alternatives': [
                            'Manual code review for boundary conditions',
                            'ASAN: detects off-by-one'
                        ]
                    }
                }
            ]
        }

    def _create_exploitation_techniques_tasks(self, binary_path: str, libc_version: str) -> Dict[str, Any]:
        """Phase 4: Exploitation techniques"""

        children = [
            {
                'id': 'tcache-poisoning',
                'name': 'Tcache Poisoning Attack',
                'type': 'manual',
                'metadata': {
                    'description': 'Exploit tcache bins (glibc 2.26+) for arbitrary allocation',
                    'tags': ['EXPLOIT', 'OSCP:LOW'],
                    'notes': [
                        '# Tcache Poisoning: Overwrite tcache next pointer',
                        '',
                        '# Requirements:',
                        '  - glibc 2.26+ (tcache introduced)',
                        '  - UAF or overflow to modify freed chunk',
                        '',
                        '# Attack Steps:',
                        '1. Allocate chunk (size < 0x410 for tcache)',
                        '2. Free chunk (goes into tcache)',
                        '3. Use UAF to overwrite fd pointer to target address',
                        '4. Allocate same size (gets original chunk)',
                        '5. Allocate again (gets target address!)',
                        '',
                        '# Example Code:',
                        'chunk1 = malloc(0x80);',
                        'free(chunk1);  // Goes to tcache[0x80]',
                        '// UAF: overwrite chunk1->next',
                        '*(long*)chunk1 = (long)target_address;',
                        'chunk2 = malloc(0x80);  // Gets chunk1',
                        'chunk3 = malloc(0x80);  // Gets target_address!',
                        '',
                        '# Target Addresses:',
                        '  - __malloc_hook (write one_gadget)',
                        '  - __free_hook (write system)',
                        '  - GOT entry (overwrite libc function)',
                        '  - Stack address (overwrite return address)',
                        '',
                        '# Alignment Note:',
                        '  Target must be 16-byte aligned!',
                        '  Use: target & ~0xf',
                        '',
                        '# Detection Bypass (Modern glibc):',
                        '  "malloc(): unaligned tcache chunk detected"',
                        '  Solution: Pick aligned address or brute-force ASLR'
                    ],
                    'alternatives': [
                        'Fastbin attack (older glibc)',
                        'Unsorted bin attack',
                        'House of techniques (House of Orange, etc.)'
                    ]
                }
            },
            {
                'id': 'fastbin-attack',
                'name': 'Fastbin Attack',
                'type': 'manual',
                'metadata': {
                    'description': 'Exploit fastbin linked list for arbitrary allocation',
                    'tags': ['EXPLOIT', 'OSCP:LOW'],
                    'notes': [
                        '# Fastbin Attack: Overwrite fastbin fd pointer',
                        '',
                        '# Requirements:',
                        '  - Chunk size in fastbin range (0x20-0x80)',
                        '  - UAF or overflow to modify freed chunk',
                        '  - Tcache must be full (7 chunks) or disabled',
                        '',
                        '# Attack Steps:',
                        '1. Fill tcache (free 7 chunks of target size)',
                        '2. Free 8th chunk (goes to fastbin)',
                        '3. Use UAF to overwrite fd to fake chunk address',
                        '4. Allocate to empty tcache (7 times)',
                        '5. Next malloc returns fake chunk!',
                        '',
                        '# Fake Chunk Requirements:',
                        '  - Size field must match fastbin size',
                        '  - Address must be aligned (16-byte)',
                        '  - Example: target __malloc_hook-0x23',
                        '    (prev bytes look like size 0x7f for fastbin check)',
                        '',
                        '# Example:',
                        '# Fill tcache',
                        'for i in range(7):',
                        '    free(chunks[i])',
                        '',
                        '# Fastbin',
                        'free(chunk_a)',
                        'free(chunk_b)',
                        'free(chunk_a)  # Double-free in fastbin',
                        '',
                        '# Overwrite',
                        '*(long*)chunk_a = target - 0x23',
                        '',
                        '# Allocate',
                        'for i in range(9):  # Empty tcache + get fake chunk',
                        '    malloc(size)',
                        '',
                        '# Common Targets:',
                        '  - __malloc_hook - 0x23',
                        '  - __free_hook',
                        '  - stdout->_flags',
                        '  - Global function pointer'
                    ],
                    'alternatives': [
                        'Safe-linking bypass (glibc 2.32+)',
                        'Tcache poisoning (easier if tcache available)'
                    ]
                }
            },
            {
                'id': 'house-of-techniques',
                'name': 'House of Techniques Collection',
                'type': 'parent',
                'children': [
                    {
                        'id': 'house-of-force',
                        'name': 'House of Force',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Exploit top chunk size corruption',
                            'tags': ['EXPLOIT'],
                            'notes': [
                                '# House of Force: Corrupt top chunk size',
                                '',
                                '# Requirements:',
                                '  - Overflow to overwrite top chunk size',
                                '  - Control over malloc size parameter',
                                '',
                                '# Attack:',
                                '  1. Overwrite top chunk size to huge value (0xffffffffffffffff)',
                                '  2. Calculate offset to target address',
                                '  3. malloc(offset) - moves top chunk to target',
                                '  4. malloc(size) - allocates at target address',
                                '',
                                '# Offset Calculation:',
                                '  offset = target_addr - top_chunk_addr - 16',
                                '',
                                '# Modern glibc has checks, less reliable'
                            ]
                        }
                    },
                    {
                        'id': 'house-of-orange',
                        'name': 'House of Orange',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Exploit without free() using _IO_FILE structures',
                            'tags': ['EXPLOIT'],
                            'notes': [
                                '# House of Orange: Exploit without free()',
                                '',
                                '# When: No free() available in binary',
                                '',
                                '# Steps:',
                                '  1. Corrupt top chunk size to force sysmalloc',
                                '  2. Old top chunk goes to unsorted bin',
                                '  3. Leak libc via unsorted bin fd/bk',
                                '  4. Corrupt _IO_list_all via unsorted bin attack',
                                '  5. Trigger via abort() or __malloc_assert',
                                '  6. Fake _IO_FILE structure executes code',
                                '',
                                '# Complex - requires FILE vtable knowledge'
                            ]
                        }
                    }
                ]
            },
            {
                'id': 'ret2libc-heap',
                'name': 'ret2libc from Heap',
                'type': 'manual',
                'metadata': {
                    'description': 'Execute libc functions using heap overflow',
                    'tags': ['EXPLOIT', 'OSCP:LOW'],
                    'notes': [
                        '# ret2libc via Heap: Overwrite function pointers',
                        '',
                        '# Targets:',
                        '  - __malloc_hook: called before malloc()',
                        '  - __free_hook: called before free()',
                        '  - __realloc_hook: called before realloc()',
                        '',
                        '# Attack:',
                        '  1. Leak libc base address',
                        '  2. Calculate one_gadget or system address',
                        '  3. Use heap exploit to allocate chunk at hook address',
                        '  4. Overwrite hook with target function',
                        '  5. Trigger hook (malloc/free/realloc)',
                        '',
                        '# One Gadget:',
                        '  one_gadget /path/to/libc.so.6',
                        '  # Returns RCE addresses with constraints',
                        '',
                        '# Example:',
                        '  # Overwrite __free_hook with system',
                        '  __free_hook = system',
                        '  chunk = malloc(8)',
                        '  strcpy(chunk, "/bin/sh")',
                        '  free(chunk)  # Calls system("/bin/sh")!',
                        '',
                        '# Note: Hooks removed in glibc 2.34+'
                    ],
                    'alternatives': [
                        'GOT overwrite (if partial RELRO)',
                        'FSOP (File Stream Oriented Programming)',
                        'vtable hijacking'
                    ]
                }
            }
        ]

        # Add libc version-specific note
        if libc_version and libc_version != 'unknown':
            children.insert(0, {
                'id': 'libc-version-note',
                'name': f'Libc Version: {libc_version}',
                'type': 'manual',
                'metadata': {
                    'description': f'Exploitation considerations for glibc {libc_version}',
                    'tags': ['RESEARCH'],
                    'notes': [
                        f'Detected libc version: {libc_version}',
                        '',
                        'Version-specific features:',
                        '  - < 2.26: No tcache (use fastbin/smallbin attacks)',
                        '  - 2.26-2.31: Tcache available, weak protections',
                        '  - 2.32+: Safe-linking in fastbin/tcache',
                        '  - 2.34+: Removed __malloc_hook/__free_hook',
                        '',
                        'Adjust exploitation technique based on version!'
                    ]
                }
            })

        return {
            'id': 'heap-exploitation-techniques',
            'name': 'Phase 4: Exploitation Techniques',
            'type': 'parent',
            'children': children
        }

    def _create_debugging_tasks(self, binary_path: str) -> Dict[str, Any]:
        """Phase 5: Debugging and analysis tools"""
        return {
            'id': 'heap-debugging-tools',
            'name': 'Phase 5: Debugging & Analysis Tools',
            'type': 'parent',
            'children': [
                {
                    'id': 'pwntools-template',
                    'name': 'Pwntools Exploit Template',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Python pwntools script template for heap exploitation',
                        'tags': ['RESEARCH'],
                        'notes': [
                            '# Basic pwntools exploit template',
                            '',
                            'from pwn import *',
                            '',
                            '# Configuration',
                            f"binary = '{binary_path}'",
                            "libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')",
                            'elf = ELF(binary)',
                            '',
                            '# Start process',
                            'if args.REMOTE:',
                            "    p = remote('target.com', 1337)",
                            'else:',
                            '    p = process(binary)',
                            '    if args.GDB:',
                            '        gdb.attach(p, """',
                            '        break malloc',
                            '        break free',
                            '        continue',
                            '        """)',
                            '',
                            '# Helper functions',
                            'def malloc(size, data):',
                            '    p.sendlineafter(b"> ", b"1")',
                            '    p.sendlineafter(b"Size: ", str(size).encode())',
                            '    p.sendafter(b"Data: ", data)',
                            '',
                            'def free(idx):',
                            '    p.sendlineafter(b"> ", b"2")',
                            '    p.sendlineafter(b"Index: ", str(idx).encode())',
                            '',
                            'def show(idx):',
                            '    p.sendlineafter(b"> ", b"3")',
                            '    p.sendlineafter(b"Index: ", str(idx).encode())',
                            '    return p.recvline()',
                            '',
                            '# Exploitation',
                            'malloc(0x80, b"A"*8)',
                            'free(0)',
                            '# Leak libc',
                            'leak = u64(show(0).strip().ljust(8, b"\\x00"))',
                            'libc.address = leak - libc.symbols["main_arena"] - 96',
                            'log.info(f"Libc base: {hex(libc.address)}")',
                            '',
                            'p.interactive()'
                        ]
                    }
                },
                {
                    'id': 'heap-feng-shui',
                    'name': 'Heap Feng Shui / Grooming',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manipulate heap layout for reliable exploitation',
                        'tags': ['RESEARCH'],
                        'notes': [
                            '# Heap Feng Shui: Arrange heap for exploitation',
                            '',
                            '# Goal: Control which chunks are adjacent',
                            '',
                            '# Technique 1: Spray and Free',
                            '  1. Allocate many chunks of target size',
                            '  2. Free specific chunks to create holes',
                            '  3. Allocate vulnerable chunk - goes into hole',
                            '  4. Allocate victim chunk - likely adjacent',
                            '',
                            '# Technique 2: Fill Tcache',
                            '  1. Allocate 7 chunks (tcache limit)',
                            '  2. Free all 7 (fills tcache)',
                            '  3. Free 8th chunk (goes to fastbin)',
                            '  4. Now can perform fastbin attack',
                            '',
                            '# Technique 3: Chunk Consolidation',
                            '  1. Create fake free chunk',
                            '  2. Trigger backward consolidation',
                            '  3. Overlap chunks',
                            '',
                            '# Example: Spray Pattern',
                            'chunks = []',
                            'for i in range(100):',
                            '    chunks.append(malloc(0x80))',
                            '# Free alternating',
                            'for i in range(0, 100, 2):',
                            '    free(chunks[i])',
                            '# Next malloc likely surrounded by in-use chunks'
                        ]
                    }
                },
                {
                    'id': 'libc-database',
                    'name': 'Libc Database for Address Leaks',
                    'type': 'command',
                    'metadata': {
                        'command': 'git clone https://github.com/niklasb/libc-database && cd libc-database && ./get',
                        'description': 'Install libc-database for identifying libc from leaked addresses',
                        'tags': ['RESEARCH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'libc-database': 'Collection of libc libraries and searching tool',
                            './get': 'Download libc binaries'
                        },
                        'success_indicators': [
                            'libc-database cloned',
                            'Multiple libc versions downloaded'
                        ],
                        'next_steps': [
                            './find <symbol_name> <leaked_address> # Identify libc',
                            './dump <libc_id>  # Get symbol offsets',
                            'Example: ./find __libc_start_main 0x7ffff7a05740'
                        ],
                        'alternatives': [
                            'libc.blukat.me - online libc database',
                            'Manual: Download libc from target system'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                {
                    'id': 'one-gadget',
                    'name': 'Find one_gadget RCE Addresses',
                    'type': 'command',
                    'metadata': {
                        'command': 'gem install one_gadget',
                        'description': 'Install one_gadget tool for finding RCE gadgets in libc',
                        'tags': ['RESEARCH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'one_gadget': 'Tool to find execve("/bin/sh") gadgets in libc',
                            'gem': 'Ruby package manager'
                        },
                        'success_indicators': [
                            'one_gadget installed successfully'
                        ],
                        'next_steps': [
                            'one_gadget /path/to/libc.so.6',
                            '# Returns addresses of gadgets with constraints',
                            '# Use address in __malloc_hook or __free_hook'
                        ],
                        'alternatives': [
                            'Manual: find execve calls in libc with ROPgadget',
                            'Use system("/bin/sh") instead'
                        ],
                        'estimated_time': '2 minutes',
                        'notes': 'Not all gadgets work - check constraints like rsp & 0xf == 0'
                    }
                },
                {
                    'id': 'asan-testing',
                    'name': 'AddressSanitizer Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use ASAN to detect heap vulnerabilities during testing',
                        'tags': ['MANUAL', 'VULN_SCAN'],
                        'notes': [
                            '# AddressSanitizer: Detect memory errors at runtime',
                            '',
                            '# If you have source code:',
                            'gcc -fsanitize=address -g -o binary source.c',
                            './binary',
                            '# ASAN reports: UAF, double-free, heap overflow',
                            '',
                            '# If binary only (recompile if possible):',
                            '# Not possible without source',
                            '',
                            '# ASAN Output Example:',
                            '==12345==ERROR: AddressSanitizer: heap-use-after-free',
                            'READ of size 8 at 0x60300000eff0',
                            '#0 in main source.c:42',
                            '',
                            '# Advantages:',
                            '  - Precise error location',
                            '  - Stack trace',
                            '  - Detects subtle bugs',
                            '',
                            '# Disadvantages:',
                            '  - Requires recompilation',
                            '  - Performance overhead',
                            '  - Not available for CTF binaries'
                        ],
                        'alternatives': [
                            'Valgrind: works on binaries without recompilation',
                            'Electric Fence: library for heap debugging'
                        ]
                    }
                },
                {
                    'id': 'heap-exploitation-resources',
                    'name': 'Learning Resources',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Recommended resources for heap exploitation',
                        'tags': ['RESEARCH'],
                        'notes': [
                            '# Essential Heap Exploitation Resources',
                            '',
                            '# CTF Practice:',
                            '  - pwnable.kr: heap challenges',
                            '  - pwnable.tw: advanced heap exploits',
                            '  - HackTheBox: binary exploitation boxes',
                            '  - how2heap: https://github.com/shellphish/how2heap',
                            '',
                            '# Tutorials:',
                            '  - Azeria Labs: Heap Exploitation Series',
                            '    https://azeria-labs.com/heap-exploitation-part-1/',
                            '  - GuyInATuxedo: Heap Exploitation',
                            '    https://guyinatuxedo.github.io/',
                            '  - HackTricks: Libc Heap',
                            '    https://book.hacktricks.xyz/binary-exploitation/libc-heap',
                            '  - Dhaval Kapil: Heap Exploitation',
                            '    https://heap-exploitation.dhavalkapil.com/',
                            '',
                            '# Tools:',
                            '  - pwndbg: https://github.com/pwndbg/pwndbg',
                            '  - pwntools: https://github.com/Gallopsled/pwntools',
                            '  - ROPgadget: ROP chain automation',
                            '  - radare2: Reverse engineering framework',
                            '',
                            '# Books:',
                            '  - "The Shellcoder\'s Handbook"',
                            '  - "Hacking: The Art of Exploitation"',
                            '',
                            '# Papers:',
                            '  - "Malloc Des-Maleficarum" by Phantasmal Phantasmagoria',
                            '  - "The Malloc Maleficarum" by Phantasmal Phantasmagoria'
                        ]
                    }
                }
            ]
        }

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """
        Generate follow-up tasks based on completed task results

        This could be extended to parse tool output and suggest next steps
        """
        new_tasks = []

        # Example: If checksec shows no PIE, suggest address-based exploitation
        if 'checksec' in task_id and 'No PIE' in result:
            new_tasks.append({
                'id': 'no-pie-exploit-hint',
                'name': 'Exploitation Hint: No PIE',
                'type': 'manual',
                'metadata': {
                    'description': 'Binary has no PIE - static addresses available',
                    'tags': ['RESEARCH'],
                    'notes': [
                        'No PIE = addresses are static (no ASLR for binary)',
                        'Exploitation is easier:',
                        '  - GOT addresses are known',
                        '  - .bss addresses are known',
                        '  - Can directly target these addresses',
                        'Still need to leak libc for heap hooks'
                    ]
                }
            })

        return new_tasks

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Provide manual alternatives for automated tasks"""
        return [
            'Manual binary analysis with gdb/pwndbg',
            'Source code review if available',
            'Fuzzing with custom inputs',
            'Static analysis with radare2/ghidra'
        ]
