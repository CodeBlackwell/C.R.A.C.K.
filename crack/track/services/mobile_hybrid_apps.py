"""
Mobile Hybrid Application Pentesting plugin

Generates tasks for hybrid mobile app security testing including:
- Apache Cordova apps (Android/iOS)
- Xamarin .NET apps (Android/iOS)
- App cloning and reverse engineering
- WebView security analysis
- Dynamic instrumentation with Frida
- .NET assembly decompilation

Extracted from HackTricks: mobile-pentesting/cordova-apps.md, xamarin-apps.md
Generated by: CrackPot v1.0

Note: This plugin focuses on hybrid framework security testing.
OSCP Relevance: MEDIUM - Transferable reverse engineering skills for Windows/.NET
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MobileHybridAppsPlugin(ServicePlugin):
    """Mobile hybrid application security testing plugin"""

    @property
    def name(self) -> str:
        return "mobile-hybrid-apps"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based; APK/IPA analysis

    @property
    def service_names(self) -> List[str]:
        return ['cordova', 'xamarin', 'hybrid-app', 'mobile-app']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect mobile hybrid app analysis context

        This plugin does not auto-detect from network scans.
        It's designed for manual invocation during mobile app pentesting.
        """
        # Manual-only plugin for mobile app analysis
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate mobile hybrid app security testing task tree"""

        app_name = service_info.get('app_name', 'target-app')
        app_type = service_info.get('app_type', 'unknown')  # cordova, xamarin

        tasks = {
            'id': 'mobile-hybrid-apps',
            'name': f'Mobile Hybrid App Security Testing: {app_name}',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: Apache Cordova Apps
        tasks['children'].append({
            'id': 'cordova-analysis',
            'name': 'Apache Cordova App Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'cordova-detect',
                    'name': 'Detect Cordova Application',
                    'type': 'command',
                    'metadata': {
                        'command': f'unzip {app_name}.apk -d {app_name}-extracted && ls {app_name}-extracted/assets/www/',
                        'description': 'Extract APK and check for Cordova source code in assets/www',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'unzip': 'Extract APK (APK files are ZIP archives)',
                            '-d': 'Destination directory for extraction',
                            'assets/www/': 'Cordova apps store HTML/JS source here'
                        },
                        'notes': """
Cordova Detection Indicators:
- assets/www/cordova.js present
- assets/www/cordova_plugins.js lists installed plugins
- res/xml/config.xml contains app configuration
- HTML/JavaScript code visible (not compiled to native)

Key Files:
1. cordova.js - Core Cordova framework
2. cordova_plugins.js - Plugin manifest with versions
3. config.xml - App settings, permissions, allowed origins
4. index.html - Main application entry point

Unlike React Native, Cordova does NOT compile JavaScript.
Source code is directly readable after APK extraction.
                        """,
                        'success_indicators': [
                            'cordova.js found in assets/www/',
                            'cordova_plugins.js lists plugins',
                            'config.xml found in res/xml/'
                        ],
                        'failure_indicators': [
                            'No assets/www/ directory (not Cordova)',
                            'JavaScript is minified/obfuscated',
                            'Native-only app (React Native, Flutter, etc.)'
                        ],
                        'alternatives': [
                            'Manual: Rename .apk to .zip and extract with file manager',
                            'apktool d app.apk (decompiles resources too)',
                            'jadx-gui app.apk (GUI APK analyzer)'
                        ],
                        'next_steps': [
                            'Analyze cordova_plugins.js for vulnerable plugins',
                            'Review config.xml for security misconfigurations',
                            'Inspect JavaScript for hardcoded secrets'
                        ]
                    }
                },
                {
                    'id': 'cordova-config-audit',
                    'name': 'Audit config.xml Security Settings',
                    'type': 'command',
                    'metadata': {
                        'command': f'cat {app_name}-extracted/res/xml/config.xml | grep -E "access origin|Content-Security-Policy|debuggable"',
                        'description': 'Check for overly permissive access origins, missing CSP, and debug settings',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'grep -E': 'Extended regex search for security-critical settings',
                            'access origin': 'Allowed network origins (should be restrictive)',
                            'Content-Security-Policy': 'CSP enforcement (should be present)',
                            'debuggable': 'Debug mode flag (should be false in production)'
                        },
                        'notes': """
Critical Security Checks:

1. Access Origin Wildcard (CRITICAL):
   <access origin="*" /> = ALLOWS ALL DOMAINS
   - App can load content from ANY website
   - XSS attacks can exfiltrate data to attacker domains
   - Should be restricted: <access origin="https://api.example.com" />

2. Missing Content-Security-Policy:
   - CSP blocks inline JavaScript execution
   - Prevents XSS exploitation
   - Should be in index.html:
     <meta http-equiv="Content-Security-Policy" content="default-src 'self'">

3. Debug Mode Enabled:
   android:debuggable="true" in AndroidManifest.xml
   - Allows Chrome DevTools attachment
   - Enables runtime JavaScript injection
   - NEVER in production builds

4. Clear-text Traffic Allowed:
   android:usesCleartextTraffic="true"
   - Allows HTTP (non-TLS) connections
   - Man-in-the-middle attack risk
   - Should be false, use HTTPS only
                        """,
                        'success_indicators': [
                            'Specific access origins defined (not wildcard)',
                            'CSP meta tag present in HTML',
                            'android:debuggable="false"'
                        ],
                        'failure_indicators': [
                            '<access origin="*" /> found (critical vulnerability)',
                            'No CSP defined',
                            'android:debuggable="true" (allows JS injection)'
                        ],
                        'alternatives': [
                            'Manual: Open config.xml in text editor',
                            'xmllint --xpath "//access" config.xml (XML query)',
                            'grep -i "debuggable" AndroidManifest.xml'
                        ],
                        'next_steps': [
                            'Document wildcard access origins for report',
                            'Test XSS with injected JavaScript',
                            'Attempt Chrome DevTools attachment if debuggable'
                        ]
                    }
                },
                {
                    'id': 'cordova-plugin-audit',
                    'name': 'Audit Cordova Plugins for CVEs',
                    'type': 'command',
                    'metadata': {
                        'command': f'cd {app_name}-extracted/assets/www && npm audit --production || osv-scanner --lockfile=package-lock.json',
                        'description': 'Scan Cordova plugins for known vulnerabilities using npm audit or osv-scanner',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'MOBILE', 'CVE'],
                        'flag_explanations': {
                            'npm audit': 'Check npm packages against vulnerability database',
                            '--production': 'Only check production dependencies (not dev)',
                            'osv-scanner': 'Open Source Vulnerability scanner (Google)',
                            '--lockfile': 'Scan package-lock.json for exact versions'
                        },
                        'notes': """
Recent Cordova Plugin Vulnerabilities:

CVE-2023-2507 (CleverTap ≤ 2.6.2):
- Unvalidated deeplink input → XSS/RCE
- Crafted deeplink executes arbitrary JavaScript in WebView
- Fix: Update to ≥ 2.6.3 or sanitize URI parameters

MAL-2024-7845 (cordova-plugin-acuant):
- Malicious NPM package (removed July 2024)
- Dropped malware during npm install
- Compromised developer machines
- Fix: Remove package, audit package.json

Common Plugin Issues:
1. Deeplink/Intent injection (XSS via URLs)
2. Insecure file access (WebView file:// access)
3. Weak cryptography (deprecated algorithms)
4. Information disclosure (logging sensitive data)

High-Risk Plugins:
- File system access (cordova-plugin-file)
- Network requests (cordova-plugin-http)
- WebView bridges (any plugin exposing native → JS)
- Third-party SDKs (analytics, ads, payments)
                        """,
                        'success_indicators': [
                            'No critical vulnerabilities found',
                            'All plugins up-to-date',
                            'Package versions pinned in package-lock.json'
                        ],
                        'failure_indicators': [
                            'Critical CVEs detected (especially RCE)',
                            'Outdated plugins (2+ years old)',
                            'Malicious packages identified'
                        ],
                        'alternatives': [
                            'Manual: Check cordova_plugins.js versions against CVE databases',
                            'Snyk test (commercial vulnerability scanner)',
                            'cordova-check-plugins (Cordova-specific tool)'
                        ],
                        'next_steps': [
                            'Research CVEs for vulnerable plugins',
                            'Develop PoC exploits for critical issues',
                            'Document findings with CVSS scores'
                        ]
                    }
                },
                {
                    'id': 'cordova-source-review',
                    'name': 'Manual JavaScript Source Code Review',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review Cordova JavaScript for vulnerabilities, secrets, and insecure patterns',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'MOBILE'],
                        'notes': r"""
JavaScript Source Code Review Checklist:

1. Hardcoded Secrets:
   - API keys: grep -r "api.key\\|apiKey\\|API_KEY" www/
   - Passwords: grep -r "password\\|passwd\\|pwd" www/
   - Tokens: grep -r "token\\|secret\\|bearer" www/
   - Credentials in comments: grep -r "TODO\\|FIXME\\|HACK" www/

2. Dangerous Functions (XSS/Code Injection):
   - eval(): grep -r "eval(" www/
   - new Function(): grep -r "new Function(" www/
   - innerHTML: grep -r "innerHTML" www/
   - document.write(): grep -r "document.write" www/

3. Insecure Data Storage:
   - localStorage for sensitive data: grep -r "localStorage" www/
   - sessionStorage: grep -r "sessionStorage" www/
   - IndexedDB without encryption: grep -r "indexedDB" www/

4. Weak Cryptography:
   - MD5/SHA1 for passwords: grep -r "md5\\|sha1" www/
   - Base64 encoding as encryption: grep -r "btoa\\|atob" www/
   - Custom crypto implementations

5. Input Validation Issues:
   - Deeplink handlers: Search for URL parameter parsing
   - Form inputs without sanitization
   - WebView message handlers

6. Business Logic Flaws:
   - Client-side authentication checks
   - Price/quantity validation only in JS
   - Role-based access control in frontend

Example Dangerous Code:
```javascript
// BAD: eval() with user input
var userInput = location.hash.substring(1);
eval(userInput);  // XSS/RCE!

// BAD: Hardcoded API key
var API_KEY = "sk_live_51H...";  // Exposed!

// BAD: Client-side auth
if (username === "admin" && password === "secret123") {
  showAdminPanel();  // Bypassable!
}
```
                        """,
                        'success_indicators': [
                            'No hardcoded secrets found',
                            'Dangerous functions not used with user input',
                            'Sensitive data encrypted before storage'
                        ],
                        'failure_indicators': [
                            'API keys/passwords in JavaScript',
                            'eval() or innerHTML with user-controlled data',
                            'Client-side security checks'
                        ],
                        'alternatives': [
                            'Use VS Code search across workspace',
                            'semgrep --config=javascript www/ (SAST tool)',
                            'Retire.js for known vulnerable libraries'
                        ],
                        'next_steps': [
                            'Extract all secrets for report',
                            'Develop PoCs for XSS/injection findings',
                            'Test client-side bypass techniques'
                        ]
                    }
                },
                {
                    'id': 'cordova-webview-debug',
                    'name': 'Chrome DevTools WebView Debugging',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb forward tcp:9222 localabstract:chrome_devtools_remote && google-chrome --new-window "chrome://inspect/#devices"',
                        'description': 'Attach Chrome DevTools to debuggable Cordova WebView for runtime JS manipulation',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'MOBILE', 'DYNAMIC'],
                        'flag_explanations': {
                            'adb forward': 'Forward TCP port to Android device',
                            'tcp:9222': 'Local port for Chrome DevTools Protocol',
                            'localabstract:': 'Abstract UNIX socket on Android',
                            'chrome_devtools_remote': 'WebView debug socket name',
                            'chrome://inspect': 'Chrome DevTools remote device inspector'
                        },
                        'notes': """
WebView Debugging Requirements:
1. android:debuggable="true" in AndroidManifest.xml, OR
2. WebView.setWebContentsDebuggingEnabled(true) in app code

Capabilities with Chrome DevTools:
- Live JavaScript console (execute arbitrary JS)
- DOM inspector (view/modify HTML)
- Network traffic interception
- Breakpoints on JavaScript functions
- Local storage inspection
- Cookie viewer/editor

Attack Scenarios:

1. Bypass Client-Side Authentication:
   - Find auth check function in Sources tab
   - Set breakpoint on authentication function
   - Modify return value to true
   - Continue execution → authenticated!

2. Extract Session Tokens:
   - Console: localStorage.getItem("session_token")
   - Application tab → Local Storage → view all keys
   - Copy tokens for session hijacking

3. Modify Business Logic:
   - Override price calculation functions
   - Change user role variables
   - Skip payment verification

4. XSS Exploitation:
   - Console: alert(document.cookie)
   - Inject malicious scripts into DOM
   - Test for stored/reflected XSS

Example Commands:
```javascript
// View all localStorage
for (var i = 0; i < localStorage.length; i++) {
  console.log(localStorage.key(i) + " = " + localStorage.getItem(localStorage.key(i)));
}

// Bypass authentication
window.isAuthenticated = true;
window.userRole = "admin";

// Dump cookies
console.log(document.cookie);
```
                        """,
                        'success_indicators': [
                            'DevTools connects to WebView',
                            'JavaScript console accessible',
                            'Can execute arbitrary JavaScript'
                        ],
                        'failure_indicators': [
                            'No debuggable WebView found',
                            'android:debuggable="false"',
                            'Chrome inspect shows no devices'
                        ],
                        'alternatives': [
                            'Frida: Hook WebView.loadUrl() to inject JavaScript',
                            'mitmproxy: Inject JavaScript via MITM',
                            'Objection: objection explore (if jailbroken/rooted)'
                        ],
                        'next_steps': [
                            'Identify authentication bypass opportunities',
                            'Extract all stored credentials/tokens',
                            'Document business logic manipulation'
                        ]
                    }
                },
                {
                    'id': 'cordova-frida-hook',
                    'name': 'Frida Hook for Cordova Plugin Bridge',
                    'type': 'command',
                    'metadata': {
                        'command': f'frida -U -f com.example.{app_name} -l cordova_hook.js --no-pause',
                        'description': 'Hook org.apache.cordova.CordovaPlugin.execute() to monitor JS-to-native calls',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE', 'DYNAMIC'],
                        'flag_explanations': {
                            '-U': 'Connect to USB device',
                            '-f': 'Spawn (start) application with package name',
                            '-l': 'Load Frida JavaScript script',
                            '--no-pause': 'Don\'t pause on startup'
                        },
                        'notes': """
Cordova Plugin Bridge Hooking:

Entry Point: org.apache.cordova.CordovaPlugin.execute(action, args, callback)
- All plugin calls from JavaScript go through this method
- 'action' = plugin method name (string)
- 'args' = JSON array of parameters
- Can intercept/modify any plugin call

Frida Script (cordova_hook.js):
```javascript
Java.perform(function () {
  var CordovaPlugin = Java.use('org.apache.cordova.CordovaPlugin');

  CordovaPlugin.execute.overload(
    'java.lang.String',
    'org.json.JSONArray',
    'org.apache.cordova.CallbackContext'
  ).implementation = function(action, args, callback) {

    console.log('[Cordova] Plugin call intercepted');
    console.log('  Action: ' + action);
    console.log('  Args: ' + args.toString());

    // Tamper with arguments
    if (action === 'encrypt') {
      console.log('[!] Replacing encryption key');
      args.put(0, 'WEAK_KEY_12345');
    }

    // Call original method
    var result = this.execute(action, args, callback);

    console.log('  Result: ' + result);
    return result;
  };

  console.log('[+] Cordova plugin hook installed');
});
```

Attack Scenarios:
1. Sensitive Data Logging:
   - Log all plugin calls to see data flow
   - Identify authentication tokens, PINs, etc.

2. Parameter Tampering:
   - Modify encryption keys to weak values
   - Change transaction amounts
   - Alter user IDs

3. Return Value Manipulation:
   - Force authentication checks to return success
   - Modify server responses
                        """,
                        'success_indicators': [
                            'Frida attaches successfully',
                            'Plugin calls logged in console',
                            'Can modify arguments/return values'
                        ],
                        'failure_indicators': [
                            'Frida detection/anti-tampering active',
                            'App crashes on hook',
                            'No CordovaPlugin class found'
                        ],
                        'alternatives': [
                            'Xposed framework (requires rooted device)',
                            'Runtime proxy via mitmproxy + SSL unpinning',
                            'Rebuild APK with modified plugin code'
                        ],
                        'next_steps': [
                            'Identify security-critical plugin calls',
                            'Develop targeted tampering attacks',
                            'Document bypassable security controls'
                        ]
                    }
                },
                {
                    'id': 'cordova-app-clone',
                    'name': 'Clone and Rebuild Cordova App',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract source code, recreate Cordova project, modify code, and rebuild APK',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE'],
                        'notes': """
Cordova App Cloning Workflow:

Prerequisites:
- NodeJS installed (v16+)
- Android SDK, Java JDK, Gradle
- Cordova CLI: npm install -g cordova@latest

Step 1: Extract Source Code
```bash
unzip bank.apk -d bank-extracted
cd bank-extracted/assets/www
# Copy all files EXCEPT: cordova.js, cordova_plugins.js, cordova-js-src/, plugins/
```

Step 2: Create New Cordova Project
```bash
# Get package name from AndroidManifest.xml
PACKAGE="com.android.bank"
cordova create bank-new $PACKAGE Bank
cd bank-new
```

Step 3: Copy Source Code
```bash
# Copy HTML/JS/CSS from extracted app
cp -r ../bank-extracted/assets/www/* www/
# Remove Cordova auto-generated files
rm www/cordova.js www/cordova_plugins.js
rm -rf www/cordova-js-src www/plugins
```

Step 4: Determine Platform Version
```bash
# Check original cordova.js for version
grep "PLATFORM_VERSION_BUILD_LABEL" ../bank-extracted/assets/www/cordova.js
# Example output: 10.1.2
cordova platform add android@10.1.2
```

Step 5: Install Plugins
```bash
# Read cordova_plugins.js for plugin list
cat ../bank-extracted/assets/www/cordova_plugins.js
# Install each plugin with correct version
cordova plugin add cordova-plugin-dialogs@2.0.1
cordova plugin add cordova-plugin-file@6.0.2
# If plugin not on npm, use GitHub URL
cordova plugin add https://github.com/moderna/cordova-plugin-cache.git
```

Step 6: Modify Code (Security Bypass)
```bash
# Edit www/js/app.js to bypass authentication
vim www/js/auth.js
# Change: if (checkAuth()) { ... }
# To: if (true) { ... }  // Always authenticated!
```

Step 7: Build APK
```bash
cordova requirements  # Verify prerequisites
cordova build android --packageType=apk
# Output: platforms/android/app/build/outputs/apk/debug/app-debug.apk
```

Step 8: Sign APK
```bash
# Use Uber APK Signer for easy signing
java -jar uber-apk-signer.jar --apks app-debug.apk
# Or manual signing with keytool + jarsigner
```

Step 9: Install Modified APK
```bash
adb install -r app-debug-aligned-debugSigned.apk
```

Use Cases:
- Bypass SSL pinning by removing pin validation code
- Disable root detection
- Add logging to inspect data flow
- Inject XSS payloads for testing
- Bypass authentication/payment checks

Automation Tool: MobSecco
https://github.com/Anof-cyber/MobSecco
Automates the entire cloning process.
                        """,
                        'success_indicators': [
                            'Source code successfully extracted',
                            'Cordova project builds without errors',
                            'Modified APK installs and runs'
                        ],
                        'failure_indicators': [
                            'Missing plugins (build fails)',
                            'Platform version mismatch',
                            'Code tampering detection triggers'
                        ],
                        'alternatives': [
                            'MobSecco automation tool',
                            'apktool for smali-level modifications',
                            'Frida for runtime tampering (no rebuild needed)'
                        ],
                        'next_steps': [
                            'Test bypassed security controls',
                            'Document code modifications',
                            'Verify functionality after tampering'
                        ]
                    }
                }
            ]
        })

        # SECTION 2: Xamarin .NET Apps
        tasks['children'].append({
            'id': 'xamarin-analysis',
            'name': 'Xamarin .NET App Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'xamarin-detect',
                    'name': 'Detect Xamarin Application',
                    'type': 'command',
                    'metadata': {
                        'command': f'unzip {app_name}.apk -d {app_name}-xamarin && ls {app_name}-xamarin/assemblies/',
                        'description': 'Extract APK and check for .NET assemblies in assemblies/ folder',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'unzip': 'Extract APK file',
                            'assemblies/': 'Xamarin apps store .NET DLLs here',
                            '.dll': '.NET assembly files (compiled C# code)'
                        },
                        'notes': """
Xamarin Detection Indicators:
- assemblies/ or unknown/assemblies/ folder exists
- .dll files present (Mono.Android.dll, mscorlib.dll, etc.)
- assemblies.blob + assemblies.manifest (newer Xamarin)
- lib/*/libmonodroid.so (Mono runtime library)

Xamarin Architecture:
- C# .NET code compiled to .NET assemblies (.dll)
- Mono runtime executes .NET bytecode on Android
- AOT (Ahead-of-Time) or JIT compilation
- Shared C# codebase for Android + iOS

Assembly Types:
1. Application DLLs: App-specific code (YourApp.dll)
2. System DLLs: .NET framework (mscorlib.dll)
3. Mono DLLs: Android bindings (Mono.Android.dll)
4. Third-party DLLs: NuGet packages

Advantage for Pentesters:
- .NET assemblies are EASIER to reverse than native code
- Decompilers produce near-source-quality C# code
- Can directly read business logic, crypto keys, etc.

OSCP Relevance: HIGH
- Same .NET reversing skills apply to Windows apps
- dnSpy, ILSpy, dotPeek all work on Windows executables
- Understanding .NET Common Language Runtime (CLR)
                        """,
                        'success_indicators': [
                            'assemblies/ directory found',
                            '.dll files extracted',
                            'Mono.Android.dll or similar present'
                        ],
                        'failure_indicators': [
                            'No assemblies/ folder (not Xamarin)',
                            'Only .so files (native app)',
                            'APK is heavily obfuscated'
                        ],
                        'alternatives': [
                            'apktool d app.apk && ls unknown/assemblies/',
                            'jadx-gui app.apk (check for Mono references)',
                            r'strings app.apk | grep "\.dll"'
                        ],
                        'next_steps': [
                            'Decompress .dll files if compressed',
                            'Unpack assemblies.blob if present',
                            'Load DLLs into dnSpy for analysis'
                        ]
                    }
                },
                {
                    'id': 'xamarin-decompress-dlls',
                    'name': 'Decompress Xamarin DLL Files',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 xamarin-decompress.py -o {app_name}-xamarin/assemblies/',
                        'description': 'Decompress LZ4-compressed .dll files from Xamarin APK',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'xamarin-decompress.py': 'Tool to decompress LZ4-compressed DLLs',
                            '-o': 'Output directory for decompressed files'
                        },
                        'notes': """
Xamarin DLL Compression:
- Newer Xamarin apps compress .dll files with LZ4
- Reduces APK size significantly
- Must decompress before analysis with dnSpy/ILSpy

Tool: xamarin-decompress
- https://github.com/NickstaDB/xamarin-decompress
- Detects and decompresses LZ4-compressed assemblies
- Works on both individual DLLs and full APK extracts

Installation:
```bash
git clone https://github.com/NickstaDB/xamarin-decompress.git
cd xamarin-decompress
pip3 install lz4
```

Usage:
```bash
# Decompress entire assemblies/ folder
python3 xamarin-decompress.py -o /path/to/apk/assemblies/

# Or specific DLL
python3 xamarin-decompress.py -o YourApp.dll
```

Alternative Tool: XamAsmUnZ
- https://github.com/cihansol/XamAsmUnZ
- GUI tool for Windows
- Automatic decompression + dnSpy integration

Verification:
```bash
# Check if DLL is compressed (file magic bytes)
xxd YourApp.dll | head -1
# Decompressed: starts with 4D 5A (MZ = PE executable)
# Compressed: starts with other bytes

# After decompression
file YourApp.dll
# Should show: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly
```
                        """,
                        'success_indicators': [
                            'DLL files decompressed successfully',
                            'file command shows "PE32 executable"',
                            'dnSpy can load DLL without errors'
                        ],
                        'failure_indicators': [
                            'DLLs already decompressed (no change)',
                            'Decompression tool errors',
                            'Corrupted DLL files'
                        ],
                        'alternatives': [
                            'XamAsmUnZ (Windows GUI tool)',
                            'Manual LZ4 decompression with lz4 CLI',
                            'pyxamstore for assemblies.blob format'
                        ],
                        'next_steps': [
                            'Load decompressed DLLs into dnSpy',
                            'Search for sensitive strings/methods',
                            'Begin static analysis'
                        ]
                    }
                },
                {
                    'id': 'xamarin-unpack-blob',
                    'name': 'Unpack assemblies.blob File',
                    'type': 'command',
                    'metadata': {
                        'command': f'pyxamstore unpack -d {app_name}-xamarin/assemblies/',
                        'description': 'Extract .NET assemblies from assemblies.blob archive (newer Xamarin format)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'pyxamstore': 'Tool to unpack Xamarin assembly blob archives',
                            'unpack': 'Extract assemblies from blob file',
                            '-d': 'Directory containing assemblies.blob'
                        },
                        'notes': """
Assemblies.blob Format (Xamarin 2020+):
- Newer Xamarin apps bundle all DLLs into single blob file
- assemblies.blob = archive containing all assemblies
- assemblies.manifest = index of assemblies in blob
- More efficient storage, harder to extract

Tool: pyxamstore
- https://github.com/jakev/pyxamstore
- Python tool to unpack assemblies.blob
- Produces individual .dll files for analysis

Installation:
```bash
git clone https://github.com/jakev/pyxamstore.git
cd pyxamstore
pip3 install -r requirements.txt
```

Usage:
```bash
# Extract to current directory
cd /path/to/apk/assemblies/
pyxamstore unpack -d .

# Output: Individual DLL files extracted
# YourApp.dll, Mono.Android.dll, mscorlib.dll, etc.
```

Alternative Method (Manual):
```bash
# Read assemblies.manifest to get offsets
cat assemblies.manifest
# Format: <dll_name> <offset> <size>

# Extract each DLL manually with dd
dd if=assemblies.blob of=YourApp.dll bs=1 skip=<offset> count=<size>
```

Verification:
```bash
# Check extracted DLLs
ls -lh *.dll
# Should see multiple DLL files

# Verify DLL integrity
file YourApp.dll
# Should be: PE32 executable (DLL)
```

OSCP Relevance:
- Understanding archive formats (similar to .NET resources)
- File extraction skills transferable to Windows analysis
- Dealing with proprietary storage formats
                        """,
                        'success_indicators': [
                            'DLL files extracted from blob',
                            'Multiple assemblies recovered',
                            'Files loadable in dnSpy'
                        ],
                        'failure_indicators': [
                            'No assemblies.blob file (older format)',
                            'Extraction errors',
                            'Corrupted DLL output'
                        ],
                        'alternatives': [
                            'Manual extraction with dd command',
                            'Hex editor + assemblies.manifest parsing',
                            'Xamarin Studio decompiler (if available)'
                        ],
                        'next_steps': [
                            'Proceed to static analysis with dnSpy',
                            'Search for hardcoded credentials',
                            'Identify security-critical methods'
                        ]
                    }
                },
                {
                    'id': 'xamarin-dnspy-analysis',
                    'name': 'Static Analysis with dnSpy',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Decompile and analyze .NET assemblies with dnSpy (read/modify C# code)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'MOBILE', 'WINDOWS'],
                        'notes': """
dnSpy: .NET Assembly Debugger/Editor
- https://github.com/dnSpy/dnSpy
- Decompiles .NET assemblies to readable C# code
- Allows editing/patching IL (Intermediate Language)
- Supports debugging (if debuggable build)
- Works on Windows (use Wine on Linux if needed)

Installation:
1. Download latest release from GitHub
2. Extract dnSpy-netframework.zip
3. Run dnSpy.exe

Basic Workflow:

1. Load Assembly:
   File → Open → Select YourApp.dll
   - Decompilation happens automatically
   - Browse namespaces/classes/methods

2. Search for Sensitive Data:
   Edit → Search Assemblies (Ctrl+Shift+K)
   - Search for: password, api, key, token, secret
   - Case-insensitive by default
   - Shows all matches across all assemblies

3. Analyze Security Code:
   - Authentication methods (CheckPassword, ValidateUser)
   - Cryptography (AES, RSA, hashing)
   - Network communication (HttpClient, WebRequest)
   - Data storage (SQLite, preferences)

4. Identify Vulnerabilities:
   - Hardcoded credentials
   - Weak crypto (MD5, DES, hardcoded keys)
   - SQL injection (string concatenation in queries)
   - Input validation issues

5. Modify Code (Patching):
   - Right-click method → Edit IL Instructions
   - Change authentication checks to always return true
   - Remove root detection code
   - Disable SSL pinning validation
   - File → Save Module → Saves patched DLL

Example Findings:

Hardcoded API Key:
```csharp
public class ApiClient {
    private const string API_KEY = "sk_live_51H7...";  // EXPOSED!
    private const string API_URL = "https://api.internal.com";
}
```

Weak Authentication:
```csharp
public bool CheckPassword(string input) {
    return input == "admin123";  // Client-side check!
}
```

SQL Injection:
```csharp
string query = "SELECT * FROM users WHERE id = " + userId;  // SQLI!
db.Execute(query);
```

OSCP Relevance: CRITICAL
- Same dnSpy skills work on Windows .exe and .dll files
- Many Windows apps are .NET Framework/Core
- Post-exploitation: Analyze defender agents, management tools
- Privilege escalation: Reverse engineer custom Windows services
                        """,
                        'success_indicators': [
                            'DLL loads in dnSpy without errors',
                            'C# source code readable',
                            'Can search and navigate codebase'
                        ],
                        'failure_indicators': [
                            'Heavy obfuscation (unreadable code)',
                            'Native code compilation (no IL)',
                            'DLL corrupted or encrypted'
                        ],
                        'alternatives': [
                            'ILSpy (open-source alternative to dnSpy)',
                            'dotPeek (JetBrains .NET decompiler)',
                            'JustDecompile (Telerik, discontinued but works)'
                        ],
                        'next_steps': [
                            'Extract all hardcoded secrets',
                            'Document security vulnerabilities',
                            'Patch DLL to bypass protections'
                        ]
                    }
                },
                {
                    'id': 'xamarin-frida-hooks',
                    'name': 'Dynamic Analysis with Fridax',
                    'type': 'command',
                    'metadata': {
                        'command': f'frida -U -f com.example.{app_name} -l fridax.js',
                        'description': 'Hook .NET methods at runtime using Fridax (Frida for Xamarin)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE', 'DYNAMIC'],
                        'flag_explanations': {
                            'fridax': 'Frida extension for Xamarin/.NET apps',
                            '-U': 'Connect to USB device',
                            '-f': 'Spawn application',
                            '-l': 'Load Frida script'
                        },
                        'notes': """
Fridax: Frida for Xamarin
- https://github.com/NorthwaveSecurity/fridax
- Hooks .NET methods in Xamarin apps
- Bypasses anti-root, SSL pinning, authentication
- Monitors method calls and return values

Installation:
```bash
pip3 install frida-tools
git clone https://github.com/NorthwaveSecurity/fridax.git
```

Common Frida Scripts for Xamarin:

1. Bypass Root Detection:
https://codeshare.frida.re/@Gand3lf/xamarin-antiroot/
```javascript
// Hook RootBeer.isRooted() or similar
Java.perform(function() {
    var RootDetection = Java.use('com.yourapp.RootDetection');
    RootDetection.isRooted.implementation = function() {
        console.log('[+] Root check bypassed');
        return false;  // Always return not rooted
    };
});
```

2. SSL Pinning Bypass:
https://github.com/GoSecure/frida-xamarin-unpin
```javascript
// Hook certificate validation
// Disable ServicePointManager SSL validation
```

3. Method Monitoring:
```javascript
// Hook specific method to see arguments/return
var YourClass = Java.use('YourApp.YourClass');
YourClass.SensitiveMethod.implementation = function(arg1, arg2) {
    console.log('[!] SensitiveMethod called');
    console.log('  arg1: ' + arg1);
    console.log('  arg2: ' + arg2);

    var result = this.SensitiveMethod(arg1, arg2);
    console.log('  returned: ' + result);
    return result;
};
```

4. Bypass Authentication:
```javascript
var AuthManager = Java.use('YourApp.AuthManager');
AuthManager.CheckCredentials.implementation = function(user, pass) {
    console.log('[+] Auth bypass: ' + user);
    return true;  // Always authenticated
};
```

Workflow:
```bash
# 1. Start Fridax
frida -U -f com.target.app -l hook.js --no-pause

# 2. Interact with app
# Trigger authentication, network calls, etc.

# 3. Monitor Frida console
# See hooked method calls, arguments, return values

# 4. Analyze results
# Document bypassed security controls
```

OSCP Relevance:
- Runtime instrumentation skills (similar to debugging)
- Bypass techniques applicable to Windows processes
- Understanding program flow without source code
                        """,
                        'success_indicators': [
                            'Frida hooks .NET methods successfully',
                            'Can monitor method arguments/returns',
                            'Security controls bypassed'
                        ],
                        'failure_indicators': [
                            'Frida detection/anti-tampering',
                            'App crashes on hook',
                            'Method signatures not found'
                        ],
                        'alternatives': [
                            'Xposed framework (rooted device)',
                            'Runtime patching with dnSpy debugger',
                            'Rebuild APK with modified DLLs'
                        ],
                        'next_steps': [
                            'Document all bypassed security features',
                            'Test app functionality after tampering',
                            'Combine with static analysis findings'
                        ]
                    }
                },
                {
                    'id': 'xamarin-resign-apk',
                    'name': 'Resign Modified Xamarin APK',
                    'type': 'command',
                    'metadata': {
                        'command': f'java -jar uber-apk-signer.jar --apks {app_name}-modified.apk',
                        'description': 'Re-sign APK after modifying .NET assemblies (required for installation)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'MOBILE'],
                        'flag_explanations': {
                            'uber-apk-signer': 'Tool to sign APKs with debug/release keys',
                            '--apks': 'Input APK file(s) to sign',
                            'jar': 'Java Archive executable'
                        },
                        'notes': """
APK Signing Requirement:
- Android requires all APKs to be cryptographically signed
- Signature verifies app hasn't been tampered with
- After modifying DLLs, must re-sign APK to install

Uber APK Signer:
- https://github.com/patrickfav/uber-apk-signer
- Simplifies APK signing process
- Supports batch signing multiple APKs
- Auto-generates debug keystore if needed

Installation:
```bash
wget https://github.com/patrickfav/uber-apk-signer/releases/download/v1.3.0/uber-apk-signer-1.3.0.jar
```

Basic Usage:
```bash
# Sign with debug key (auto-generated)
java -jar uber-apk-signer.jar --apks app.apk

# Sign multiple APKs
java -jar uber-apk-signer.jar --apks *.apk

# Output: app-aligned-debugSigned.apk
```

Advanced: Custom Keystore
```bash
# Generate keystore
keytool -genkey -v -keystore my-release-key.jks \\
  -keyalg RSA -keysize 2048 -validity 10000 \\
  -alias my-key-alias

# Sign with custom key
java -jar uber-apk-signer.jar \\
  --apks app.apk \\
  --ks my-release-key.jks \\
  --ksAlias my-key-alias \\
  --ksPass mypassword
```

Manual Signing (Alternative):
```bash
# Align APK
zipalign -v -p 4 app.apk app-aligned.apk

# Sign with apksigner
apksigner sign --ks debug.keystore app-aligned.apk

# Verify signature
apksigner verify app-aligned.apk
```

Workflow:
1. Modify DLLs in dnSpy → Save Module
2. Replace DLL in APK: zip -r app.apk assemblies/YourApp.dll
3. Sign APK: uber-apk-signer
4. Install: adb install -r app-aligned-debugSigned.apk

Code Tampering Detection:
- Some apps verify signature at runtime
- If detected, app may refuse to run
- Bypass: Remove signature check in dnSpy before signing
                        """,
                        'success_indicators': [
                            'APK signed successfully',
                            'apksigner verify shows valid signature',
                            'APK installs without errors'
                        ],
                        'failure_indicators': [
                            'Signature verification fails',
                            'App detects tampering and quits',
                            'Installation blocked by Play Protect'
                        ],
                        'alternatives': [
                            'Manual signing with apksigner/jarsigner',
                            'Android Studio: Build → Generate Signed APK',
                            'apktool: apktool b app/ && sign'
                        ],
                        'next_steps': [
                            'Install modified APK on test device',
                            'Verify bypassed security controls work',
                            'Document successful tampering'
                        ]
                    }
                }
            ]
        })

        # SECTION 3: Hybrid App Security Best Practices
        tasks['children'].append({
            'id': 'hybrid-security-recommendations',
            'name': 'Security Recommendations (Blue Team)',
            'type': 'manual',
            'metadata': {
                'description': 'Hardening recommendations for Cordova and Xamarin applications',
                'tags': ['OSCP:LOW', 'DEFENSE', 'MOBILE'],
                'notes': """
Hybrid App Security Best Practices:

CORDOVA HARDENING:

1. Update Platforms & Plugins:
   - Use cordova-android@13+ (targets API 34, May 2024)
   - Run: npm audit --production regularly
   - Pin plugin versions in package-lock.json
   - Remove unused plugins

2. Enforce Strict Access Controls:
   - NO <access origin="*" /> (critical!)
   - Whitelist specific domains only
   - Use HTTPS-only origins

3. Implement Content Security Policy:
   <meta http-equiv="Content-Security-Policy"
         content="default-src 'self'; img-src 'self' data:;
                  object-src 'none'; frame-ancestors 'none'">
   - Blocks inline scripts (XSS mitigation)
   - Restricts external resource loading

4. Disable Debug Artifacts:
   - android:debuggable="false" (production)
   - Remove setWebContentsDebuggingEnabled() calls
   - Strip console.log() from production builds

5. Block Clear-text Traffic:
   - android:usesCleartextTraffic="false"
   - Enforce TLS with network-security-config

6. Code Obfuscation:
   - Minify JS with Terser/UglifyJS
   - Remove source maps from production
   - Obfuscate sensitive logic

XAMARIN HARDENING:

1. Enable AOT Compilation:
   - Full AOT compilation (Enterprise license)
   - Converts C# to native code
   - Harder to decompile than IL

2. Code Obfuscation:
   - Use .NET obfuscators (ConfuserEx, Dotfuscator)
   - Rename methods/classes/variables
   - Control flow obfuscation
   - String encryption

3. Assembly Encryption:
   - Encrypt assemblies.blob
   - Custom decryption at runtime
   - Increases reverse engineering difficulty

4. Root/Jailbreak Detection:
   - Detect rooted/jailbroken devices
   - Refuse to run or degrade functionality
   - Combine with anti-tampering checks

5. Certificate Pinning:
   - Pin server certificates in code
   - Prevent MITM attacks
   - Use HttpClient with custom handlers

6. Secure Data Storage:
   - Encrypt sensitive data before storage
   - Use Android Keystore / iOS Keychain
   - Never store secrets in SharedPreferences plaintext

GENERAL MOBILE HARDENING:

1. Runtime Application Self-Protection (RASP):
   - Detect debuggers (Frida, Xposed)
   - Verify app signature integrity
   - Monitor memory for hooks/patches

2. Code Integrity Checks:
   - Hash critical methods at runtime
   - Verify DLL/APK checksums
   - Detect code modifications

3. Secure Communication:
   - Always use HTTPS
   - Implement certificate pinning
   - Validate server certificates

4. Input Validation:
   - Sanitize all deeplink/intent inputs
   - Validate URL parameters
   - Prevent XSS/injection attacks

5. Logging Controls:
   - NO sensitive data in logs (passwords, tokens)
   - Disable logging in production
   - Use ProGuard to strip log calls

OSCP EXAM NOTE:
While mobile hardening isn't OSCP-specific, understanding
defensive measures helps identify weaknesses in similar
Windows/.NET applications during privilege escalation.
                """
            }
        })

        return tasks
