"""
Blockchain and Smart Contract Security Plugin

Generates tasks for blockchain security testing including:
- Smart contract vulnerability analysis (Solidity)
- DeFi/AMM exploitation techniques
- Web3 enumeration
- Blockchain privacy analysis

Extracted from HackTricks: blockchain/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BlockchainSecurityPlugin(ServicePlugin):
    """Blockchain and smart contract security testing plugin"""

    @property
    def name(self) -> str:
        return "blockchain-security"

    @property
    def default_ports(self) -> List[int]:
        return [8545, 8546, 30303, 3000, 8080]

    @property
    def service_names(self) -> List[str]:
        return ['ethereum', 'web3', 'geth', 'blockchain', 'smart-contract', 'rpc']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> float:
        """Detect blockchain-related services with confidence scoring

        Returns:
            Confidence score (0-100):
            - 100: Explicit blockchain service (ethereum, web3, geth in name)
            - 90: Blockchain product detected (Geth, Parity)
            - 40: Blockchain-specific port with unknown service
            - 0: Common web ports without blockchain indicators (defer to HTTP plugin)

        Note: Port 8080 is commonly used for Apache Tomcat/web apps. Only claim with high confidence.
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')

        # Perfect match: Explicit blockchain service names
        if any(svc in service for svc in ['ethereum', 'web3', 'geth', 'blockchain']):
            return 100

        # High confidence: Blockchain product detected
        if any(prod in product for prod in ['ethereum', 'geth', 'parity']):
            return 90

        # Low confidence: Blockchain-specific ports (8545, 8546, 30303, 3000)
        # but NOT common web ports like 8080
        if port in [8545, 8546, 30303, 3000]:
            # Only claim if service is unknown/generic
            if service in ['', 'unknown', 'tcpwrapped']:
                return 40
            return 0  # Explicit service - defer to appropriate plugin

        # Port 8080 is too generic (Tomcat, etc) - require explicit blockchain indicators
        if port == 8080:
            return 0  # Defer to HTTP plugin unless explicit blockchain service detected above

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate blockchain security task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', 'Ethereum Node')

        tasks = {
            'id': f'blockchain-security-{port}',
            'name': f'Blockchain Security Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Web3 RPC Enumeration
        tasks['children'].append({
            'id': f'web3-rpc-enum-{port}',
            'name': 'Web3 RPC Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': f'web3-version-{port}',
                    'name': 'Check Web3 Version',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST -H "Content-Type: application/json" --data \'{{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}}\' http://{target}:{port}',
                        'description': 'Enumerate Web3 client version via JSON-RPC',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            '-X POST': 'Use HTTP POST method for JSON-RPC',
                            '-H "Content-Type: application/json"': 'Set JSON content type header',
                            '--data': 'Send JSON-RPC request payload',
                            'web3_clientVersion': 'RPC method to get client version (Geth, Parity, etc.)'
                        },
                        'success_indicators': [
                            'JSON response with client version (e.g., Geth/v1.10.0)',
                            'HTTP 200 status code',
                            'Valid JSON-RPC 2.0 response'
                        ],
                        'failure_indicators': [
                            'Connection refused (RPC not exposed)',
                            'HTTP 403/401 (authentication required)',
                            'Invalid JSON-RPC response'
                        ],
                        'next_steps': [
                            'Enumerate blockchain network (eth_chainId)',
                            'Check for unlocked accounts (eth_accounts)',
                            'Test for dangerous RPC methods (personal_*, admin_*)'
                        ],
                        'alternatives': [
                            f'nc {target} {port} (manual HTTP POST)',
                            f'python3 -c "from web3 import Web3; w3 = Web3(Web3.HTTPProvider(\'http://{target}:{port}\')); print(w3.clientVersion)"',
                            f'Manual: telnet {target} {port} → POST / HTTP/1.1 + JSON payload'
                        ],
                        'notes': 'Web3 RPC often exposed on localhost only. If found externally, may indicate misconfiguration.',
                        'estimated_time': '1-2 minutes'
                    }
                },
                {
                    'id': f'web3-accounts-{port}',
                    'name': 'Enumerate Accounts',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST -H "Content-Type: application/json" --data \'{{"jsonrpc":"2.0","method":"eth_accounts","params":[],"id":1}}\' http://{target}:{port}',
                        'description': 'List Ethereum accounts (potential unlocked wallets)',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'eth_accounts': 'RPC method to list available accounts (HIGH RISK if unlocked)',
                            'params:[]': 'No parameters required for account listing'
                        },
                        'success_indicators': [
                            'Array of Ethereum addresses (0x...)',
                            'Non-empty result indicates unlocked accounts',
                            'Critical finding for exploitation'
                        ],
                        'failure_indicators': [
                            'Empty array (no unlocked accounts)',
                            'Method not found (disabled for security)',
                            'Authentication required'
                        ],
                        'next_steps': [
                            'Check account balances (eth_getBalance)',
                            'Attempt transaction signing (eth_sendTransaction)',
                            'Research account ownership'
                        ],
                        'alternatives': [
                            f'Manual: curl -s http://{target}:{port} -d \'{{"method":"eth_accounts"}}\'',
                            'Web3.py script for account enumeration'
                        ],
                        'notes': 'Unlocked accounts = immediate compromise. Can sign arbitrary transactions.'
                    }
                }
            ]
        })

        # Smart Contract Security Testing
        tasks['children'].append({
            'id': f'smart-contract-security-{port}',
            'name': 'Smart Contract Security Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'slither-install-{port}',
                    'name': 'Install Slither (Static Analysis)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Install Trail of Bits Slither for Solidity static analysis',
                        'tags': ['OSCP:LOW', 'RESEARCH'],
                        'alternatives': [
                            'pip3 install slither-analyzer',
                            'docker pull trailofbits/eth-security-toolbox',
                            'Manual: git clone https://github.com/crytic/slither && pip3 install .'
                        ],
                        'next_steps': [
                            'Obtain Solidity source code (.sol files)',
                            'Run Slither analysis on contracts',
                            'Review mutation testing results'
                        ],
                        'notes': 'Requires Solidity source code. Not applicable to deployed bytecode without decompilation.',
                        'estimated_time': '5 minutes'
                    }
                },
                {
                    'id': f'slither-mutate-{port}',
                    'name': 'Mutation Testing with Slither',
                    'type': 'command',
                    'metadata': {
                        'command': 'slither-mutate ./contracts --test-cmd="forge test" --list-mutators',
                        'description': 'Test your tests by introducing code mutations (reveals blind spots)',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'AUTOMATED'],
                        'flag_explanations': {
                            '--test-cmd': 'Command to run test suite (Foundry: forge test, Hardhat: npx hardhat test)',
                            '--list-mutators': 'List available mutation operators (e.g., CR=Comment Replacement, operator swaps)',
                            './contracts': 'Directory containing Solidity source files'
                        },
                        'success_indicators': [
                            'Mutants generated and tested',
                            'Mutation campaign report in ./mutation_campaign/',
                            'KILLED mutants = tests caught the change (good)',
                            'UNCAUGHT mutants = tests missed the change (test gap)'
                        ],
                        'failure_indicators': [
                            'All mutants UNCAUGHT (tests not asserting behavior)',
                            'Syntax errors in mutations',
                            'Test suite failing on original code'
                        ],
                        'next_steps': [
                            'Triage UNCAUGHT mutants (high priority)',
                            'Add missing assertions (balances, state, events)',
                            'Add boundary tests (==, overflow, zero-address)',
                            'Re-run until all mutants killed or justified'
                        ],
                        'alternatives': [
                            'Manual: slither-mutate ./src/contracts --test-cmd="forge test" &> mutation.results',
                            'Differential testing: compare against reference implementation',
                            'Invariant tests: property-based testing with Echidna'
                        ],
                        'notes': 'Mutation testing reveals test blind spots that coverage metrics miss. UNCAUGHT mutants on value transfers = critical risk (e.g., Arkis DeFi $8.3M exploit).',
                        'estimated_time': '30+ minutes (depends on test suite size)'
                    }
                },
                {
                    'id': f'smart-contract-vulns-{port}',
                    'name': 'Common Solidity Vulnerabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manual checklist for common smart contract vulnerabilities',
                        'tags': ['OSCP:LOW', 'MANUAL', 'RESEARCH'],
                        'alternatives': [
                            'Reentrancy: Check for external calls before state updates',
                            'Integer overflow/underflow: Use SafeMath or Solidity 0.8+',
                            'Unchecked return values: Verify success of low-level calls',
                            'Delegatecall to untrusted contracts: Preserve storage layout',
                            'Timestamp dependence: Avoid block.timestamp for critical logic',
                            'Access control: Ensure modifiers on sensitive functions',
                            'Front-running: MEV attacks on DEX swaps/auctions'
                        ],
                        'next_steps': [
                            'Review contract source for patterns',
                            'Test with Slither static analysis',
                            'Fuzz with Echidna/Foundry invariants',
                            'Consult SWC Registry: https://swcregistry.io/'
                        ],
                        'notes': 'Not OSCP-relevant (emerging tech), but critical for blockchain security assessments.'
                    }
                }
            ]
        })

        # DeFi/AMM Exploitation
        tasks['children'].append({
            'id': f'defi-amm-exploit-{port}',
            'name': 'DeFi/AMM Exploitation Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'uniswap-v4-hook-{port}',
                    'name': 'Uniswap v4 Hook Precision Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit rounding/precision flaws in Uniswap v4 custom hooks',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'EXPLOIT'],
                        'alternatives': [
                            'Step 1: Identify pools with hooks (PoolKey.hooks != address(0))',
                            'Step 2: Inspect hook bytecode for beforeSwap/afterSwap callbacks',
                            'Step 3: Model hook math (sqrtPriceX96, tick alignment, BalanceDelta rounding)',
                            'Step 4: Calibrate exactInput swaps to cross threshold boundaries',
                            'Step 5: Verify rounding discrepancy credits the caller',
                            'Step 6: Amplify with flash loan (Aave V3: 3M USDT, 2000 WETH)',
                            'Step 7: Loop swaps to accumulate credits, then withdraw'
                        ],
                        'success_indicators': [
                            'Positive BalanceDelta after boundary-crossing swap',
                            'Credits accumulate over repeated swaps',
                            'Withdrawal inflates balance beyond input',
                            'Flash loan repaid with profit'
                        ],
                        'failure_indicators': [
                            'Hook math is symmetric (no rounding bias)',
                            'Settlement burns residue instead of crediting caller',
                            'Rate limits prevent repeated swaps',
                            'Threshold logic prevents exact boundary crossing'
                        ],
                        'next_steps': [
                            'Use Foundry/Hardhat to simulate swap boundaries',
                            'Test both exactInput and exactOutput modes',
                            'Check for mulDiv, Q64.96 conversions, SafeCast inconsistencies',
                            'Verify tick alignment between paths',
                            'Audit LDF/rebalancing logic for precision loss'
                        ],
                        'notes': 'Case study: Bunni V2 exploit (2025-09-02) drained $8.3M via LDF rounding error. Not OSCP-relevant but high-impact for DeFi audits.',
                        'estimated_time': '4+ hours (research and PoC development)'
                    }
                },
                {
                    'id': f'flash-loan-attack-{port}',
                    'name': 'Flash Loan Attack Pattern',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use flash loans to amplify exploitation (Aave, dYdX)',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'EXPLOIT'],
                        'alternatives': [
                            'Aave V3: flashLoan() with executeOperation() callback',
                            'dYdX: flashloan via Solo Margin protocol',
                            'Uniswap V2: flash swaps (repay with 0.3% fee)',
                            'Balancer: flashLoan() with receiveFlashLoan() callback'
                        ],
                        'next_steps': [
                            'Borrow large notional atomically',
                            'Execute exploit in callback (swap loop, arbitrage, etc.)',
                            'Repay loan + premium in same transaction',
                            'Profit = (stolen_funds - loan - premium - gas)'
                        ],
                        'notes': 'Flash loans enable capital-free attacks. Entire attack must succeed in 1 transaction or revert (atomic).'
                    }
                }
            ]
        })

        # Blockchain Privacy Analysis
        tasks['children'].append({
            'id': f'blockchain-privacy-{port}',
            'name': 'Blockchain Privacy Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'bitcoin-privacy-{port}',
                    'name': 'Bitcoin Privacy Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Bitcoin transaction privacy and de-anonymization',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'ENUM'],
                        'alternatives': [
                            'Common Input Ownership: Two inputs in same tx → same owner',
                            'UTXO Change Address Detection: New address in outputs = change',
                            'Transaction Graph Analysis: Visualize fund flows',
                            'Forced Address Reuse: Send dust to old addresses, track future spends',
                            'Wallet Fingerprinting: Identify wallet software by tx patterns',
                            'Round Number Heuristic: Round output = payment, non-round = change',
                            'Traffic Analysis: Map transactions to IP addresses'
                        ],
                        'next_steps': [
                            'Use blockchain explorers (blockchain.com, blockchair.com)',
                            'Visualize transaction graphs (GraphSense, Maltego)',
                            'Identify mixer usage (CoinJoin, PayJoin patterns)',
                            'Correlate timestamps with known events'
                        ],
                        'notes': 'Bitcoin is pseudonymous, not anonymous. Most transactions are traceable without privacy tools.'
                    }
                },
                {
                    'id': f'ethereum-gas-{port}',
                    'name': 'Ethereum Gas Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand Ethereum gas mechanics for transaction analysis',
                        'tags': ['OSCP:LOW', 'RESEARCH'],
                        'alternatives': [
                            'Gas = computational units (measured in gwei: 1 ETH = 10^9 gwei)',
                            'Gas Limit: Max gas user willing to pay',
                            'Base Fee: Network-wide fee (burned, not to miners)',
                            'Priority Fee (tip): Incentive for miners to include tx',
                            'Max Fee: gasLimit * (baseFee + priorityFee)',
                            'Excess refunded: (maxFee - actualFee) returned to sender'
                        ],
                        'next_steps': [
                            'Analyze gas usage patterns for profiling',
                            'Identify high-value transactions (large gas fees)',
                            'Detect MEV attacks (sandwich, front-running)',
                            'Research smart contract gas optimization'
                        ],
                        'notes': 'Gas costs reveal transaction priority and complexity. Critical for DeFi attack cost/benefit analysis.'
                    }
                }
            ]
        })

        # Exploit Research (if version detected)
        if version:
            tasks['children'].append({
                'id': f'blockchain-exploit-research-{port}',
                'name': f'Exploit Research: {product} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-blockchain-{port}',
                        'name': f'SearchSploit: {product} {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{product} {version}"',
                            'description': 'Search ExploitDB for known blockchain client vulnerabilities',
                            'tags': ['OSCP:LOW', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'Local ExploitDB search tool',
                                f'"{product} {version}"': 'Search term (quoted for exact match)'
                            },
                            'success_indicators': [
                                'Known exploits found',
                                'CVE references provided',
                                'PoC code available'
                            ],
                            'failure_indicators': [
                                'No results (version too new or no public exploits)',
                                'Results not relevant to blockchain RPC'
                            ],
                            'next_steps': [
                                'Review exploit details and requirements',
                                'Download PoC: searchsploit -m <EDB-ID>',
                                'Test exploit in controlled environment',
                                'Research CVE on NVD/GitHub'
                            ],
                            'alternatives': [
                                f'Manual: https://www.exploit-db.com/search?q={product}+{version}',
                                'Google: "Geth RPC exploit" site:github.com',
                                'CVE search: cve.mitre.org'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-blockchain-{port}',
                        'name': f'CVE Lookup: {product} {version}',
                        'type': 'manual',
                        'metadata': {
                            'description': f'Search CVE databases for {product} {version}',
                            'tags': ['OSCP:LOW', 'RESEARCH'],
                            'alternatives': [
                                f'https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={product}',
                                f'https://nvd.nist.gov/vuln/search/results?query={product}+{version}',
                                'GitHub: Search for security advisories and issue trackers',
                                f'Google: "CVE {product} {version}"'
                            ],
                            'next_steps': [
                                'Document CVE IDs and CVSS scores',
                                'Download patches/advisories',
                                'Determine if target is vulnerable',
                                'Develop or adapt exploit if applicable'
                            ]
                        }
                    }
                ]
            })

        return tasks
