"""
Remote Access service enumeration plugin (RDP, VNC, Telnet)

Generates tasks for remote access service enumeration including:
- RDP: Enumeration, BlueKeep scanning, session hijacking, credential attacks
- VNC: Password decryption, authentication bypass, brute-force
- Telnet: Banner grabbing, CVE exploitation, credential sniffing

Extracted from HackTricks:
  - network-services-pentesting/pentesting-rdp.md
  - network-services-pentesting/pentesting-vnc.md
  - network-services-pentesting/pentesting-telnet.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class RemoteAccessPlugin(ServicePlugin):
    """Remote Access (RDP/VNC/Telnet) enumeration plugin"""

    @property
    def name(self) -> str:
        return "remote-access"

    @property
    def default_ports(self) -> List[int]:
        return [3389, 5900, 5901, 5800, 5801, 23]

    @property
    def service_names(self) -> List[str]:
        return ['rdp', 'ms-wbt-server', 'vnc', 'realvnc', 'tightvnc', 'telnet']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect remote access services (RDP, VNC, Telnet)"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate remote access enumeration task tree"""
        service = service_info.get('service', '').lower()
        version = service_info.get('version', '')
        product = service_info.get('product', '').lower()

        # Determine service type
        is_rdp = port == 3389 or 'rdp' in service or 'ms-wbt-server' in service
        is_vnc = port in [5900, 5901, 5800, 5801] or 'vnc' in service
        is_telnet = port == 23 or 'telnet' in service

        tasks = {
            'id': f'remote-access-enum-{port}',
            'name': f'Remote Access Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === RDP ENUMERATION ===
        if is_rdp:
            tasks['children'].extend(self._generate_rdp_tasks(target, port, version, product))

        # === VNC ENUMERATION ===
        elif is_vnc:
            tasks['children'].extend(self._generate_vnc_tasks(target, port, version))

        # === TELNET ENUMERATION ===
        elif is_telnet:
            tasks['children'].extend(self._generate_telnet_tasks(target, port, version))

        return tasks

    def _generate_rdp_tasks(self, target: str, port: int, version: str, product: str) -> List[Dict[str, Any]]:
        """Generate RDP enumeration tasks"""
        tasks = []

        # TASK 1: RDP Nmap Enumeration
        tasks.append({
            'id': f'rdp-nmap-enum-{port}',
            'name': 'RDP Nmap Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script "rdp-enum-encryption or rdp-vuln-ms12-020 or rdp-ntlm-info" -p {port} -T4 {target}',
                'description': 'Enumerate RDP encryption, check DoS vuln, extract NTLM info',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    '--script': 'Execute multiple NSE scripts',
                    'rdp-enum-encryption': 'Enumerate supported encryption methods',
                    'rdp-vuln-ms12-020': 'Check MS12-020 DoS vulnerability (safe check)',
                    'rdp-ntlm-info': 'Extract Windows version info via NTLM',
                    '-p': f'Target port {port}',
                    '-T4': 'Aggressive timing (faster scan)'
                },
                'success_indicators': [
                    'Encryption methods listed (e.g., TLS, RDP, CredSSP)',
                    'NTLM info returned (OS version, domain)',
                    'Vulnerability status displayed'
                ],
                'failure_indicators': [
                    'Connection refused (RDP disabled)',
                    'Timeout (firewall blocking)',
                    'Scripts fail to execute'
                ],
                'next_steps': [
                    'If vulnerable to MS12-020: Research DoS impact',
                    'If weak encryption: Potential downgrade attacks',
                    'Note OS version for exploit research',
                    'If NTLM info leaks domain: Use for domain enum'
                ],
                'alternatives': [
                    f'Manual: xfreerdp /v:{target}:{port} /cert-ignore (observe encryption)',
                    f'rdp_check.py {target} (impacket tool)',
                    'nmap -sV for basic version detection'
                ],
                'notes': 'MS12-020 is a CRITICAL DoS vulnerability (Blue Screen). Script checks safely without crashing. NTLM info leaks OS version useful for exploit matching.'
            }
        })

        # TASK 2: RDP Credential Check
        tasks.append({
            'id': f'rdp-cred-check-{port}',
            'name': 'Test Known Credentials',
            'type': 'command',
            'metadata': {
                'command': f'# If you have creds from enumeration:\nxfreerdp /v:{target}:{port} /u:username /p:password /cert-ignore\n# OR with hash (Pass-the-Hash):\nxfreerdp /v:{target}:{port} /u:username /pth:NTHASH /cert-ignore',
                'description': 'Authenticate to RDP with known credentials or NTLM hash',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    '/v:': 'Target IP:port',
                    '/u:': 'Username',
                    '/p:': 'Password (cleartext)',
                    '/pth:': 'NTLM hash for Pass-the-Hash',
                    '/cert-ignore': 'Ignore certificate warnings'
                },
                'success_indicators': [
                    'RDP desktop appears',
                    'Authentication successful',
                    'GUI access granted'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Account locked (too many attempts)',
                    'Restricted Admin mode disabled (PTH fails)'
                ],
                'next_steps': [
                    'If GUI access: Begin post-exploitation enumeration',
                    'Check for admin/SYSTEM privileges',
                    'Look for sensitive files on desktop',
                    'Check for other RDP sessions to hijack'
                ],
                'alternatives': [
                    f'rdesktop -u username -p password {target}:{port}',
                    f'rdp_check.py username:password@{target} (impacket)',
                    'Manual: Windows mstsc.exe client'
                ],
                'notes': 'Pass-the-Hash requires Restricted Admin mode (reg add "HKLM\\System\\CurrentControlSet\\Control\\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 0). For pentesting RDP execution techniques, see lateral_movement.py plugin (RDP-based execution).'
            }
        })

        # TASK 3: RDP Password Spraying
        tasks.append({
            'id': f'rdp-password-spray-{port}',
            'name': 'RDP Password Spraying (CAREFUL - Account Lockout)',
            'type': 'command',
            'metadata': {
                'command': f'# Crowbar method:\ncrowbar -b rdp -s {target}/32 -U users.txt -c "password123"\n# OR Hydra:\nhydra -L users.txt -p "password123" {target} rdp',
                'description': 'Test single common password against multiple users',
                'tags': ['OSCP:MEDIUM', 'NOISY', 'BRUTE_FORCE'],
                'flag_explanations': {
                    '-b rdp': 'Target RDP service (crowbar)',
                    '-s': 'Target specification (CIDR notation)',
                    '-U': 'Username list',
                    '-c': 'Single password (spray mode)',
                    '-L': 'Username list (hydra)',
                    '-p': 'Single password'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[+] Success: username:password',
                    'RDP authentication succeeded'
                ],
                'failure_indicators': [
                    'All authentication attempts failed',
                    'Account lockout triggered',
                    'Connection rate-limited',
                    'Multiple lockouts (bad password choice)'
                ],
                'next_steps': [
                    'If successful: Login via xfreerdp',
                    'Document credentials for reporting',
                    'Check if user is administrator',
                    'Avoid further brute-force (lockout risk)'
                ],
                'alternatives': [
                    'Manual: Test password manually via xfreerdp',
                    'CrackMapExec: crackmapexec rdp <target> -u users.txt -p password',
                    'Conservative: Test 1-2 passwords only'
                ],
                'notes': 'BE CAREFUL: RDP brute-force triggers account lockouts quickly. Password spraying (1 password, many users) safer than brute-force (many passwords, 1 user). For OSCP: Document lockout policy first if possible.'
            }
        })

        # TASK 4: RDP Session Hijacking
        tasks.append({
            'id': f'rdp-session-hijack-{port}',
            'name': 'RDP Session Hijacking (Post-Access)',
            'type': 'manual',
            'metadata': {
                'description': 'Hijack active RDP sessions with SYSTEM privileges',
                'tags': ['MANUAL', 'OSCP:HIGH', 'POST_ACCESS'],
                'notes': f'''
RDP Session Hijacking (Requires SYSTEM or Admin Access):

Prerequisites:
  - SYSTEM or Administrator access on Windows target
  - RDP enabled (port {port} open)
  - Other users logged in via RDP

Workflow:
  1. Enumerate active RDP sessions:
     query user
     # Shows: USERNAME, SESSIONNAME, ID, STATE

  2. Hijack session (as SYSTEM):
     tscon <SESSION_ID> /dest:<YOUR_SESSION_NAME>
     # Example: tscon 2 /dest:rdp-tcp#0

  3. Alternative: Mimikatz method:
     mimikatz.exe
     mimikatz# ts::sessions        # List sessions
     mimikatz# ts::remote /id:2    # Connect to session 2

Important Notes:
  - Hijacking KICKS OFF the original user (suspicious)
  - No password required (full session takeover)
  - Access to user's desktop, files, open apps
  - Credentials may be in plaintext (notepad, browser)
  - Can access user's RDP sessions to other machines

Privilege Escalation Path:
  - Low-priv user → SYSTEM via exploit
  - SYSTEM → Hijack admin RDP session
  - Admin session = domain admin credentials

OSCP Relevance: HIGH
  - Bypasses password requirements
  - Instant privilege escalation vector
  - Often contains credentials for lateral movement

Alternatives:
  - Mimikatz: ts::sessions + ts::remote
  - Process injection into RDP session (see lateral_movement.py)
  - Sticky keys/Utilman backdoor for persistent access
                ''',
                'success_indicators': [
                    'Session takeover successful',
                    'Desktop of target user appears',
                    'No password prompt'
                ],
                'failure_indicators': [
                    'Access denied (not SYSTEM)',
                    'No other sessions active',
                    'Session already locked'
                ],
                'next_steps': [
                    'Search desktop for credentials',
                    'Check browser saved passwords',
                    'Look for open RDP sessions to other hosts',
                    'Document everything for report'
                ]
            }
        })

        # TASK 5: Sticky Keys Backdoor Check
        tasks.append({
            'id': f'rdp-sticky-keys-{port}',
            'name': 'Check for Sticky Keys Backdoor',
            'type': 'command',
            'metadata': {
                'command': f'# Check if backdoor exists (requires network share access):\n# Manual check - connect to RDP and press Shift 5 times\n# Automated scanner:\n# git clone https://github.com/linuz/Sticky-Keys-Slayer\n# python Sticky-Keys-Slayer.py {target}',
                'description': 'Detect backdoored Sticky Keys or Utilman for CMD access at login',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'Sticky Keys': 'Accessibility feature (Shift x5) - can be backdoored to launch CMD',
                    'Utilman': 'Ease of Access button on login screen - same backdoor technique'
                },
                'success_indicators': [
                    'CMD opens at login screen (backdoor found)',
                    'sethc.exe or Utilman.exe replaced with cmd.exe',
                    'SYSTEM shell without authentication'
                ],
                'failure_indicators': [
                    'Normal Sticky Keys behavior',
                    'Backdoor not present',
                    'Cannot access system files'
                ],
                'next_steps': [
                    'If backdoor found: SYSTEM access without credentials',
                    'Create admin account via CMD',
                    'Dump SAM database for password hashes',
                    'Document for report (critical vulnerability)'
                ],
                'alternatives': [
                    'Manual: Press Shift 5 times at RDP login',
                    'Manual: Click Ease of Access icon',
                    'Check registry: HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe'
                ],
                'notes': 'Backdoor replaces C:\\Windows\\System32\\sethc.exe with cmd.exe. Press Shift 5x at login → SYSTEM CMD. Common in CTF/OSCP boxes. Sticky-Keys-Slayer automates detection: https://github.com/linuz/Sticky-Keys-Slayer'
            }
        })

        # TASK 6: RDP Automation Tools
        rdp_tools = {
            'id': f'rdp-auto-tools-{port}',
            'name': 'RDP Automation Tools',
            'type': 'parent',
            'children': [
                {
                    'id': f'autordpwn-{port}',
                    'name': 'AutoRDPwn - Shadow Attack',
                    'type': 'command',
                    'metadata': {
                        'command': f'# PowerShell framework for Shadow attack:\n# git clone https://github.com/JoelGMSec/AutoRDPwn\n# Import-Module .\\AutoRDPwn.ps1\n# AutoRDPwn -t {target} -u username -p password',
                        'description': 'Automated Shadow attack - view/control victim RDP session remotely',
                        'tags': ['OSCP:LOW', 'WINDOWS'],
                        'flag_explanations': {
                            'Shadow': 'Windows feature allowing remote desktop viewing',
                            '-t': 'Target IP',
                            '-u/-p': 'Credentials'
                        },
                        'success_indicators': [
                            'Shadow session established',
                            'Victim desktop visible',
                            'Control enabled'
                        ],
                        'failure_indicators': [
                            'Shadow feature disabled',
                            'Insufficient privileges',
                            'Connection refused'
                        ],
                        'alternatives': [
                            'Manual: query session && shadow <sessionid>',
                            'Built-in Windows: mstsc /shadow:<sessionid> /v:<target>'
                        ],
                        'notes': 'Shadow feature allows viewing victims desktop WITHOUT consent. Requires admin privileges. AutoRDPwn: https://github.com/JoelGMSec/AutoRDPwn'
                    }
                },
                {
                    'id': f'evilrdp-{port}',
                    'name': 'EvilRDP - Command Execution',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Python tool for RDP automation:\n# git clone https://github.com/skelsec/evilrdp\n# python3 evilrdp.py {target} -u username -p password --exec "whoami"',
                        'description': 'Execute commands, control clipboard, spawn SOCKS proxy via RDP',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '--exec': 'Execute command on target',
                            '--upload': 'Upload file to target',
                            '--socks': 'Spawn SOCKS proxy through RDP'
                        },
                        'success_indicators': [
                            'Command executed',
                            'Output returned',
                            'File transfer succeeded',
                            'SOCKS proxy active'
                        ],
                        'alternatives': [
                            'Manual RDP + manual commands',
                            'SharpRDP for command execution without GUI'
                        ],
                        'notes': 'EvilRDP features: mouse/keyboard automation, clipboard control, SOCKS proxy, command execution, file transfer. Works even when file transfers disabled. GitHub: https://github.com/skelsec/evilrdp'
                    }
                },
                {
                    'id': f'sharprdp-{port}',
                    'name': 'SharpRDP - Non-Interactive Execution',
                    'type': 'command',
                    'metadata': {
                        'command': f'# C# tool for non-interactive RDP command execution:\n# SharpRDP.exe computername=={target} command=="whoami" username==user password==pass',
                        'description': 'Execute commands on RDP without graphical interface',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                        'flag_explanations': {
                            'computername': 'Target hostname/IP',
                            'command': 'Command to execute',
                            'username/password': 'Credentials'
                        },
                        'success_indicators': [
                            'Command executed',
                            'Output captured',
                            'No GUI spawned'
                        ],
                        'alternatives': [
                            'Manual RDP session',
                            'WMI/WinRM for command execution (faster)',
                            'EvilRDP for similar functionality'
                        ],
                        'notes': 'SharpRDP: https://github.com/0xthirteen/SharpRDP. Useful when WinRM disabled but RDP enabled. Slower than WMI/WinRM for command execution.'
                    }
                }
            ]
        }
        tasks.append(rdp_tools)

        # TASK 7: Add User to RDP Group
        tasks.append({
            'id': f'rdp-add-user-{port}',
            'name': 'Add User to RDP Group (Post-Access)',
            'type': 'manual',
            'metadata': {
                'description': 'Add low-privilege user to Remote Desktop Users group',
                'tags': ['MANUAL', 'OSCP:HIGH', 'POST_ACCESS'],
                'notes': '''
Adding User to RDP Group (Privilege Escalation):

Prerequisites:
  - Low-privilege shell access on Windows target
  - Administrator/SYSTEM access achieved

Command:
  net localgroup "Remote Desktop Users" <username> /add

Full RDP Setup Workflow:
  1. Enable RDP:
     reg add "HKLM\\System\\CurrentControlSet\\Control\\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

  2. Open firewall:
     netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

  3. Add user to RDP group:
     net localgroup "Remote Desktop Users" hacker /add

  4. (Optional) Create new admin user:
     net user hacker P@ssw0rd /add
     net localgroup Administrators hacker /add

  5. Connect:
     xfreerdp /u:hacker /p:P@ssw0rd /v:<target>:3389

OSCP Relevance: HIGH
  - Establishes persistent GUI access
  - Easier post-exploitation than CLI shell
  - Can upload/download files via shared drives
  - Access to GUI tools (browser, file explorer)

Alternative Persistence Methods:
  - Add SSH key (if Windows OpenSSH enabled)
  - Create scheduled task for reverse shell
  - Sticky keys backdoor for login screen access
                ''',
                'success_indicators': [
                    'User added to group successfully',
                    'RDP login works',
                    'GUI access established'
                ],
                'next_steps': [
                    'Test RDP login with new user',
                    'Document credentials for report',
                    'Use for file transfer and post-exploitation'
                ]
            }
        })

        # TASK 8: Exploit Research
        if version:
            tasks.append({
                'id': f'rdp-exploit-research-{port}',
                'name': f'Exploit Research: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'rdp-searchsploit-{port}',
                        'name': f'SearchSploit: RDP {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit rdp {version}',
                            'description': 'Search ExploitDB for RDP vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': [
                                'Exploits found',
                                'BlueKeep (CVE-2019-0708) if Windows < 10',
                                'CVE numbers listed'
                            ],
                            'alternatives': [
                                'Google: "rdp exploit <version>"',
                                'CVE databases: nvd.nist.gov',
                                'Metasploit: search rdp'
                            ]
                        }
                    },
                    {
                        'id': f'rdp-bluekeep-{port}',
                        'name': 'BlueKeep Scanner (CVE-2019-0708)',
                        'type': 'command',
                        'metadata': {
                            'command': f'# Safe scanner (no exploit):\nnmap --script rdp-vuln-ms12-020 -p {port} {target}\n# OR Metasploit scanner:\nmsfconsole -q -x "use auxiliary/scanner/rdp/cve_2019_0708_bluekeep; set RHOSTS {target}; run; exit"',
                            'description': 'Check for BlueKeep RCE vulnerability (CRITICAL - wormable)',
                            'tags': ['OSCP:HIGH', 'EXPLOIT'],
                            'flag_explanations': {
                                'CVE-2019-0708': 'BlueKeep - pre-auth RCE in RDP',
                                'Wormable': 'Can spread automatically (like WannaCry)',
                                'Safe scanner': 'Detection only, does not exploit'
                            },
                            'success_indicators': [
                                'VULNERABLE status returned',
                                'Windows 7/2008 without KB4499175 patch',
                                'Pre-auth RCE confirmed'
                            ],
                            'failure_indicators': [
                                'Not vulnerable (patched)',
                                'Windows 10+ (not affected)',
                                'Scanner fails to detect'
                            ],
                            'next_steps': [
                                'If vulnerable: CRITICAL finding (report immediately)',
                                'Public exploits unstable (blue screen risk)',
                                'Consider safer exploitation paths first',
                                'Document for report as high-severity finding'
                            ],
                            'alternatives': [
                                'Metasploit: auxiliary/scanner/rdp/cve_2019_0708_bluekeep',
                                'Manual: Check Windows version (Win7/2008 unpatched = vuln)'
                            ],
                            'notes': 'BlueKeep is a WORMABLE RCE (like EternalBlue). Affects: Windows 7, Server 2008/2008 R2 without KB4499175. Public exploits are unstable (often crash). Scanner is SAFE (detection only). For OSCP: Document finding even if not exploiting.'
                        }
                    }
                ]
            })

        return tasks

    def _generate_vnc_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate VNC enumeration tasks"""
        tasks = []

        # TASK 1: VNC Nmap Enumeration
        tasks.append({
            'id': f'vnc-nmap-enum-{port}',
            'name': 'VNC Nmap Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV --script vnc-info,realvnc-auth-bypass,vnc-title -p {port} {target}',
                'description': 'Enumerate VNC info, check RealVNC auth bypass, grab desktop title',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    '--script': 'Execute NSE scripts',
                    'vnc-info': 'VNC server information (version, protocol)',
                    'realvnc-auth-bypass': 'Check CVE-2006-2369 (RealVNC auth bypass)',
                    'vnc-title': 'Grab desktop window title',
                    '-sV': 'Version detection',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'VNC version detected',
                    'Protocol version shown (RFB 3.x)',
                    'Desktop title revealed',
                    'Auth bypass vulnerability detected'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Timeout (firewall blocking)',
                    'Scripts fail to execute'
                ],
                'next_steps': [
                    'If auth bypass found: Connect without password',
                    'Note VNC version for exploit research',
                    'Check if password is required',
                    'Test for no-auth access'
                ],
                'alternatives': [
                    f'vncviewer {target}::{port} (manual connection)',
                    f'Metasploit: use auxiliary/scanner/vnc/vnc_none_auth'
                ],
                'notes': 'VNC uses ports 5900+ (display 0 = 5900, display 1 = 5901). RealVNC auth bypass (CVE-2006-2369) allows connection without password on old versions.'
            }
        })

        # TASK 2: VNC No-Auth Test
        tasks.append({
            'id': f'vnc-no-auth-{port}',
            'name': 'Test VNC No Authentication',
            'type': 'command',
            'metadata': {
                'command': f'# Metasploit scanner:\nmsfconsole -q -x "use auxiliary/scanner/vnc/vnc_none_auth; set RHOSTS {target}; set RPORT {port}; run; exit"\n# OR manual:\nvncviewer {target}::{port}',
                'description': 'Test if VNC allows connection without authentication',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'vnc_none_auth': 'MSF module to test no-auth VNC',
                    'vncviewer': 'VNC client (Kali default)',
                    '::': 'Port separator for vncviewer (IP::PORT)'
                },
                'success_indicators': [
                    'Connection established without password',
                    'Desktop visible',
                    'No authentication prompt'
                ],
                'failure_indicators': [
                    'Password required',
                    'Authentication failed',
                    'Connection refused'
                ],
                'next_steps': [
                    'If no-auth: Full desktop access (CRITICAL)',
                    'Screenshot desktop for evidence',
                    'Look for credentials in visible windows',
                    'Check for sensitive files on desktop'
                ],
                'alternatives': [
                    f'vncviewer -passwd /dev/null {target}::{port}',
                    'nmap --script vnc-info'
                ],
                'notes': 'No-auth VNC is CRITICAL vulnerability. Common on IoT devices, misconfigured servers. Gives full desktop access. For OSCP: Screenshot as evidence.'
            }
        })

        # TASK 3: VNC Password Decryption
        tasks.append({
            'id': f'vnc-password-decrypt-{port}',
            'name': 'VNC Password Decryption',
            'type': 'manual',
            'metadata': {
                'description': 'Decrypt VNC password from ~/.vnc/passwd file',
                'tags': ['MANUAL', 'OSCP:HIGH', 'POST_ACCESS'],
                'notes': '''
VNC Password Decryption (Post-Access):

Prerequisites:
  - File system access to VNC server (or client)
  - VNC password file located

Default Password Locations:
  Linux:
    ~/.vnc/passwd
    /root/.vnc/passwd

  Windows:
    Registry: HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4\\Password
    File: C:\\Users\\<USER>\\AppData\\Local\\RealVNC\\vncserver.log

Decryption Process:
  1. Locate password file:
     find / -name passwd 2>/dev/null | grep vnc
     cat ~/.vnc/passwd

  2. Decrypt with vncpwd:
     git clone https://github.com/jeroennijhof/vncpwd
     cd vncpwd && make
     ./vncpwd ~/.vnc/passwd

  3. Windows alternative:
     Download: https://www.raymond.cc/blog/download/did/232/
     Run: VNCPasswordView.exe

Technical Details:
  - VNC passwords encrypted with 3DES
  - Fixed key (reversed years ago)
  - Max password length: 8 characters
  - Decryption is TRIVIAL (not real encryption)

OSCP Relevance: HIGH
  - Common privilege escalation path
  - VNC server often runs as root/SYSTEM
  - Password reuse likely
  - Test decrypted password on other services

Example:
  $ ./vncpwd /home/user/.vnc/passwd
  Password: MyP@ss123

Next Steps:
  - Connect to VNC with decrypted password
  - Test password on SSH, RDP, SMB
  - Document for report
                ''',
                'success_indicators': [
                    'Password file found',
                    'Password decrypted successfully',
                    'VNC login works with decrypted password'
                ],
                'alternatives': [
                    'vncpwd: https://github.com/jeroennijhof/vncpwd',
                    'VNCPasswordView.exe (Windows)',
                    'Manual: Python script to decrypt 3DES'
                ]
            }
        })

        # TASK 4: VNC Brute Force
        tasks.append({
            'id': f'vnc-bruteforce-{port}',
            'name': 'VNC Password Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'# Hydra brute-force:\nhydra -P /usr/share/wordlists/rockyou.txt -t 4 vnc://{target}:{port}\n# OR Metasploit:\nmsfconsole -q -x "use auxiliary/scanner/vnc/vnc_login; set RHOSTS {target}; set RPORT {port}; set PASS_FILE /usr/share/wordlists/rockyou.txt; run; exit"',
                'description': 'Brute-force VNC password (max 8 chars, relatively fast)',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'AUTOMATED'],
                'flag_explanations': {
                    '-P': 'Password wordlist',
                    '-t 4': 'Parallel threads (4 = safe)',
                    'vnc://': 'VNC protocol handler (hydra)',
                    'PASS_FILE': 'Password list for MSF module'
                },
                'success_indicators': [
                    'Valid password found',
                    '[5900][vnc] host: X password: Y',
                    'Authentication successful'
                ],
                'failure_indicators': [
                    'All passwords failed',
                    'Connection rate-limited',
                    'Timeout on attempts'
                ],
                'next_steps': [
                    'Connect with found password: vncviewer -passwd <file>',
                    'Full desktop access',
                    'Screenshot for evidence',
                    'Look for credentials in open windows'
                ],
                'alternatives': [
                    f'medusa -h {target} -n {port} -M vnc -P passwords.txt',
                    'ncrack -p {port} -P passwords.txt {target}',
                    'Manual: vncviewer with common passwords'
                ],
                'notes': 'VNC passwords limited to 8 characters (easier brute-force). RFB protocol allows fast password attempts. Common passwords: password, admin, vnc, 123456, default.'
            }
        })

        # TASK 5: VNC Connection Test
        tasks.append({
            'id': f'vnc-connect-{port}',
            'name': 'Connect to VNC with Password',
            'type': 'command',
            'metadata': {
                'command': f'# If password file available:\nvncviewer -passwd passwd.txt {target}::{port}\n# OR interactive:\nvncviewer {target}::{port}',
                'description': 'Connect to VNC server using known password',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    '-passwd': 'Password file (encrypted VNC format)',
                    '::': 'Port separator (IP::PORT)',
                    target: 'Target IP or hostname'
                },
                'success_indicators': [
                    'Desktop displayed',
                    'Full GUI access',
                    'Mouse/keyboard control working'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Connection refused',
                    'Incorrect password'
                ],
                'next_steps': [
                    'Screenshot desktop as evidence',
                    'Check for credentials in visible windows',
                    'Look for sensitive files',
                    'Check for terminal/shell access',
                    'Document everything for report'
                ],
                'alternatives': [
                    'TightVNC client',
                    'RealVNC client',
                    'Browser-based: noVNC (if available)',
                    'Windows: UltraVNC client'
                ],
                'notes': 'VNC provides FULL desktop access (like RDP). Common on Linux servers for remote admin. Port 5900 = display :0, 5901 = display :1, etc. For OSCP: Screenshot is critical evidence.'
            }
        })

        return tasks

    def _generate_telnet_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate Telnet enumeration tasks"""
        tasks = []

        # TASK 1: Telnet Banner Grabbing
        tasks.append({
            'id': f'telnet-banner-{port}',
            'name': 'Telnet Banner Grabbing',
            'type': 'command',
            'metadata': {
                'command': f'nc -vn {target} {port}',
                'description': 'Grab Telnet banner to identify service version',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-v': 'Verbose output',
                    '-n': 'No DNS resolution',
                    str(port): 'Telnet port (usually 23)'
                },
                'success_indicators': [
                    'Banner displayed (login prompt)',
                    'Service version visible',
                    'OS information leaked'
                ],
                'failure_indicators': [
                    'Connection refused (service disabled)',
                    'Timeout (firewall blocking)',
                    'No banner displayed'
                ],
                'next_steps': [
                    'Note service version for exploit research',
                    'Test default credentials',
                    'Attempt credential brute-force',
                    'Research CVEs for identified version'
                ],
                'alternatives': [
                    f'telnet {target} {port}',
                    f'nmap -sV -p{port} {target}',
                    f'nmap --script telnet-ntlm-info -p{port} {target} (Windows NTLM info)'
                ],
                'notes': 'Telnet transmits EVERYTHING in cleartext (including passwords). Banner often reveals OS and version. Windows telnet may leak domain info via telnet-ntlm-info NSE script.'
            }
        })

        # TASK 2: Telnet Nmap Enumeration
        tasks.append({
            'id': f'telnet-nmap-enum-{port}',
            'name': 'Telnet Nmap Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -n -sV -Pn --script "*telnet* and safe" -p {port} {target}',
                'description': 'Comprehensive Telnet enumeration with safe NSE scripts',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    '-n': 'No DNS resolution',
                    '-sV': 'Service version detection',
                    '-Pn': 'Skip host discovery (assume up)',
                    '--script': 'Run NSE scripts matching pattern',
                    '"*telnet* and safe"': 'All telnet scripts marked as safe',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'Service version detected',
                    'NTLM info extracted (Windows)',
                    'Telnet options enumerated',
                    'Vulnerabilities found'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Scripts fail to execute',
                    'No useful information'
                ],
                'next_steps': [
                    'Research CVEs for detected version',
                    'Test default credentials',
                    'Check for known exploits',
                    'Attempt brute-force if needed'
                ],
                'alternatives': [
                    f'Metasploit: msfconsole -q -x "use auxiliary/scanner/telnet/telnet_version; set RHOSTS {target}; run; exit"',
                    'Manual banner grabbing with nc'
                ],
                'notes': 'telnet-ntlm-info.nse extracts Windows version info. Safe scripts avoid DoS/exploit attempts.'
            }
        })

        # TASK 3: Telnet Default Credentials
        tasks.append({
            'id': f'telnet-default-creds-{port}',
            'name': 'Test Telnet Default Credentials',
            'type': 'manual',
            'metadata': {
                'description': 'Test vendor-specific default Telnet credentials',
                'tags': ['MANUAL', 'OSCP:HIGH', 'QUICK_WIN'],
                'notes': f'''
Common Telnet Default Credentials:

Cisco:
  admin/admin, cisco/cisco, admin/cisco

Juniper:
  root/Juniper, admin/Juniper123

D-Link:
  admin/admin, admin/password, user/user

NETGEAR:
  admin/password, admin/admin, admin/1234

TP-Link:
  admin/admin, admin/admin123

Mikrotik:
  admin/<blank>

IoT/Embedded:
  root/root, admin/admin, root/1234, admin/1234
  root/admin, admin/password, user/user

Mirai Botnet Common:
  root/xc3511, root/vizxv, root/admin, admin/admin
  root/888888, root/xmhdipc, root/default, root/juantech

Test Workflow:
  1. Connect: telnet {target} {port}
  2. Try credentials from banner/device type
  3. Document successful login immediately
  4. Enumerate system after access

OSCP Relevance: HIGH
  - Telnet on IoT/embedded = likely default creds
  - Single valid login = full access (often root)
  - Common in CTF/OSCP lab environments

Alternative Method:
  - Hydra with default creds list:
    hydra -C /usr/share/wordlists/seclists/Passwords/Default-Credentials/telnet-betterdefaultpasslist.txt {target} telnet
                ''',
                'success_indicators': [
                    'Login successful',
                    'Shell prompt appears',
                    'Root/admin access gained'
                ],
                'alternatives': [
                    'Automated: hydra -C default-creds.txt telnet://<target>',
                    'SecLists: Default-Credentials/telnet-betterdefaultpasslist.txt'
                ]
            }
        })

        # TASK 4: Telnet Brute Force
        tasks.append({
            'id': f'telnet-bruteforce-{port}',
            'name': 'Telnet Credential Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'# Hydra (stop at first valid):\nhydra -L /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/wordlists/rockyou.txt -t 4 -f telnet://{target}:{port}\n# OR Medusa:\nmedusa -M telnet -h {target} -U users.txt -P passwords.txt -t 6 -f',
                'description': 'Brute-force Telnet credentials (mirrors IoT botnet tactics)',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    '-L': 'Username list',
                    '-P': 'Password list',
                    '-t 4': 'Parallel connections (4 = moderate)',
                    '-f': 'Stop at first valid credential',
                    'telnet://': 'Telnet protocol handler'
                },
                'success_indicators': [
                    'Valid credentials found',
                    '[23][telnet] host: X login: Y password: Z',
                    'Shell access gained'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Connection rate-limited',
                    'Account lockout (rare on embedded)'
                ],
                'next_steps': [
                    'Connect: telnet <target>',
                    'Check privileges: id, whoami',
                    'Enumerate system',
                    'Look for privilege escalation if not root'
                ],
                'alternatives': [
                    f'ncrack -p {port} --user root -P passwords.txt {target}',
                    'Manual testing with common passwords',
                    'Password spraying (1 password, many users)'
                ],
                'notes': 'Mirai and variants scan port 23 with small credential lists (60-120 pairs). Telnet brute-force faster than SSH (no encryption overhead). IoT devices rarely have account lockout.'
            }
        })

        # TASK 5: Telnet Credential Sniffing
        tasks.append({
            'id': f'telnet-sniff-{port}',
            'name': 'Telnet Credential Sniffing (MitM)',
            'type': 'manual',
            'metadata': {
                'description': 'Capture Telnet credentials via packet sniffing or MitM',
                'tags': ['MANUAL', 'OSCP:MEDIUM', 'NETWORK'],
                'notes': f'''
Telnet Credential Sniffing (Cleartext Transmission):

Passive Sniffing (Same Network):
  1. Capture traffic with tcpdump:
     sudo tcpdump -i eth0 -A 'tcp port 23 and not src host $(hostname -I | cut -d" " -f1)'

  2. Wireshark capture:
     Filter: tcp.port == 23 && (telnet.data || telnet.option)
     Right-click packet → Follow TCP Stream

  3. Look for login prompts:
     - "login:" followed by username
     - "Password:" followed by password (cleartext)

Active MitM (Switched Network):
  1. ARP spoofing:
     ettercap -T -M arp:remote /{{target}}// /{{gateway}}//
     # OR
     arpspoof -i eth0 -t {{target}} <gateway>

  2. Capture with tcpdump/Wireshark (as above)

  3. Credentials appear in cleartext stream

Detection:
  - Easy to detect (broadcast ARP, traffic anomalies)
  - Use carefully in OSCP exam

OSCP Relevance: MEDIUM
  - Telnet = cleartext = easy credential capture
  - Useful if Telnet in use on local network
  - Alternative to brute-force (stealthier)
  - Demonstrates protocol weakness for report

Post-Capture:
  - Test captured credentials on Telnet
  - Try credentials on SSH, RDP, SMB (password reuse)
  - Document for report with packet capture evidence

Example tcpdump output:
  login: admin
  Password: P@ssw0rd123
  # id
  uid=0(root) gid=0(root) groups=0(root)
                ''',
                'success_indicators': [
                    'Credentials captured in cleartext',
                    'Username and password visible',
                    'TCP stream shows login sequence'
                ],
                'alternatives': [
                    'Wireshark GUI capture',
                    'tshark command-line alternative',
                    'bettercap for modern MitM attacks'
                ]
            }
        })

        # TASK 6: Recent Telnet Vulnerabilities
        telnet_vulns = {
            'id': f'telnet-recent-cves-{port}',
            'name': 'Recent Telnet CVEs (2022-2025)',
            'type': 'parent',
            'children': [
                {
                    'id': f'telnet-cve-2024-45698-{port}',
                    'name': 'D-Link DIR-X4860 RCE (CVE-2024-45698)',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Check if D-Link router:\ntelnet {target} {port}\n# If D-Link DIR-X4860, check firmware version\n# Vulnerable: < 1.04B05\n# Exploit: Hard-coded credentials + command injection',
                        'description': 'D-Link Wi-Fi 6 router hard-coded Telnet credentials + RCE',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'IOT'],
                        'flag_explanations': {
                            'CVE-2024-45698': 'D-Link DIR-X4860 Telnet RCE',
                            'Hard-coded': 'Built-in credentials cannot be changed',
                            'Root RCE': 'Remote code execution as root'
                        },
                        'success_indicators': [
                            'D-Link router identified',
                            'Firmware < 1.04B05',
                            'Hard-coded credentials work',
                            'Command execution as root'
                        ],
                        'failure_indicators': [
                            'Not D-Link device',
                            'Firmware patched (>= 1.04B05)',
                            'Credentials changed'
                        ],
                        'alternatives': [
                            'Check banner for D-Link identification',
                            'Test default D-Link credentials'
                        ],
                        'notes': 'CVE-2024-45698: D-Link DIR-X4860 accepts hard-coded Telnet creds + fails to sanitize input → RCE as root. Fixed in firmware >= 1.04B05.'
                    }
                },
                {
                    'id': f'telnet-cve-2023-40478-{port}',
                    'name': 'NETGEAR RAX30 Buffer Overflow (CVE-2023-40478)',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Check if NETGEAR RAX30:\ntelnet {target} {port}\n# Exploit: Buffer overflow in passwd command\n# Allows auth bypass + RCE as root',
                        'description': 'NETGEAR RAX30 Telnet CLI passwd command buffer overflow',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'IOT'],
                        'flag_explanations': {
                            'CVE-2023-40478': 'NETGEAR RAX30 buffer overflow',
                            'passwd command': 'Telnet CLI password change function',
                            'Adjacent attacker': 'Same network required'
                        },
                        'success_indicators': [
                            'NETGEAR RAX30 identified',
                            'Vulnerable firmware',
                            'Buffer overflow triggered',
                            'Auth bypass successful'
                        ],
                        'alternatives': [
                            'Test default NETGEAR credentials first',
                            'Check firmware version'
                        ],
                        'notes': 'CVE-2023-40478: Stack buffer overflow in Telnet CLI passwd command. Adjacent network access required. Allows auth bypass and RCE as root.'
                    }
                },
                {
                    'id': f'telnet-cve-2022-39028-{port}',
                    'name': 'GNU inetutils telnetd DoS (CVE-2022-39028)',
                    'type': 'command',
                    'metadata': {
                        'command': f'# Check telnetd version:\ntelnet {target} {port}\n# DoS test sequence: 0xff 0xf7 or 0xff 0xf8\n# WARNING: Causes crash (persistent DoS)',
                        'description': 'GNU inetutils telnetd NULL pointer dereference DoS',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'DOS'],
                        'flag_explanations': {
                            'CVE-2022-39028': 'inetutils telnetd DoS',
                            '0xff 0xf7/0xf8': 'Telnet option sequences triggering crash',
                            'Persistent DoS': 'Service crashes repeatedly'
                        },
                        'success_indicators': [
                            'GNU inetutils telnetd identified',
                            'Service crashes on payload',
                            'Repeated crashes = persistent DoS'
                        ],
                        'alternatives': [
                            'Version detection via banner',
                            'nmap service detection'
                        ],
                        'notes': 'CVE-2022-39028: Two-byte sequence triggers NULL pointer dereference in GNU inetutils telnetd. Causes crash. Repeated crashes = persistent DoS. Affects un-patched legacy systems.'
                    }
                }
            ]
        }
        tasks.append(telnet_vulns)

        # TASK 7: Post-Exploitation
        tasks.append({
            'id': f'telnet-post-exploit-{port}',
            'name': 'Telnet Post-Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Post-exploitation actions after gaining Telnet access',
                'tags': ['MANUAL', 'OSCP:HIGH', 'POST_ACCESS'],
                'notes': '''
Telnet Post-Exploitation (After Gaining Access):

1. Upgrade Shell (if dumb TTY):
   python -c 'import pty;pty.spawn("/bin/bash")'
   # OR
   python3 -c 'import pty;pty.spawn("/bin/bash")'
   # See: HackTricks - Full TTYs

2. Enumerate System:
   uname -a              # Kernel version
   id                    # User/group info
   cat /etc/passwd       # Users
   sudo -l               # Sudo permissions
   find / -perm -4000 2>/dev/null  # SUID binaries

3. Check for Privilege Escalation:
   - Weak file permissions
   - Kernel exploits (searchsploit <kernel version>)
   - Sudo misconfigurations
   - Writable cron jobs

4. Establish Persistence:
   - Add SSH key: echo "<pubkey>" >> ~/.ssh/authorized_keys
   - Create backdoor user: useradd -m hacker -s /bin/bash
   - Cron job reverse shell

5. Lateral Movement:
   - Check /etc/hosts for other systems
   - Look for SSH keys: find / -name id_rsa 2>/dev/null
   - Check bash history: cat ~/.bash_history

6. Exfiltration:
   - Locate sensitive files: /etc/shadow, config files
   - Transfer via netcat, HTTP, base64 encoding

OSCP Tips:
  - Screenshot shell access as proof
  - Document exact command sequence
  - Test privilege escalation paths
  - Clean up artifacts (remove backdoors before exam end)

Config Files to Check:
  /etc/inetd.conf        # Telnet service config
  /etc/xinetd.d/telnet   # Alternative config
  /etc/xinetd.d/stelnet  # Secure telnet (rare)
                ''',
                'success_indicators': [
                    'Shell upgraded successfully',
                    'System enumerated',
                    'Privilege escalation path found',
                    'Persistence established'
                ],
                'next_steps': [
                    'Full system enumeration',
                    'Privilege escalation if not root',
                    'Lateral movement to other systems',
                    'Document everything for report'
                ]
            }
        })

        return tasks
