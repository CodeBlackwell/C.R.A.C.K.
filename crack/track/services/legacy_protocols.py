"""
Legacy Protocol Enumeration Plugin

Generates tasks for legacy network protocol enumeration including:
- Finger (port 79) - User enumeration
- IRC (ports 194, 6667, 6660-7000) - Chat server enumeration
- RTSP (ports 554, 8554) - Streaming media server enumeration
- Echo (port 7) - Echo service testing

Extracted from HackTricks:
- pentesting-finger.md
- pentesting-irc.md
- 554-8554-pentesting-rtsp.md
- 7-tcp-udp-pentesting-echo.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class FingerPlugin(ServicePlugin):
    """Finger protocol enumeration plugin (port 79)"""

    @property
    def name(self) -> str:
        return "finger"

    @property
    def default_ports(self) -> List[int]:
        return [79]

    @property
    def service_names(self) -> List[str]:
        return ['finger']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Finger services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if 'finger' in service:
            return True

        # Check port
        if port == 79:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Finger enumeration task tree"""

        tasks = {
            'id': f'finger-enum-{port}',
            'name': f'Finger User Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner Grabbing
        tasks['children'].append({
            'id': f'finger-banner-{port}',
            'name': 'Finger Banner Grabbing',
            'type': 'command',
            'metadata': {
                'command': f'nc -vn {target} {port}',
                'description': 'Connect to Finger service and grab banner',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'nc': 'Netcat - network connection tool',
                    '-v': 'Verbose output (show connection details)',
                    '-n': 'No DNS resolution (use IP directly)',
                    target: 'Target IP address',
                    str(port): 'Finger service port (typically 79)'
                },
                'success_indicators': [
                    'Connection established',
                    'Banner or prompt displayed',
                    'Service responds to input'
                ],
                'failure_indicators': [
                    'Connection refused (service not running)',
                    'Connection timeout (firewall blocking)',
                    'No response to commands'
                ],
                'next_steps': [
                    'Try listing all users with: finger @target',
                    'Enumerate specific users with: finger username@target',
                    'Test for command injection'
                ],
                'alternatives': [
                    f'echo "root" | nc -vn {target} {port}',
                    f'telnet {target} {port}',
                    f'finger @{target}'
                ],
                'notes': 'Finger is a legacy protocol for user enumeration. Rarely enabled on modern systems but common in older Unix/Linux boxes.',
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 2: User Enumeration - List All
        tasks['children'].append({
            'id': f'finger-list-users-{port}',
            'name': 'List All Users',
            'type': 'command',
            'metadata': {
                'command': f'finger @{target}',
                'description': 'List all logged-in users on the target system',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'finger': 'Finger client command',
                    '@': 'Query symbol for listing all users',
                    target: 'Target hostname or IP'
                },
                'success_indicators': [
                    'List of usernames returned',
                    'Login times shown',
                    'User details displayed (full names, idle time, etc.)'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Empty response',
                    'Service returns error'
                ],
                'next_steps': [
                    'Create username list for brute-force attacks',
                    'Query detailed info for each user',
                    'Test common usernames (root, admin, user, test)'
                ],
                'alternatives': [
                    f'echo "" | nc {target} {port}',
                    f'nmap --script finger -p {port} {target}'
                ],
                'notes': 'User lists are valuable for SSH/FTP brute-forcing and understanding system users.',
                'estimated_time': '1 minute'
            }
        })

        # Task 3: Specific User Enumeration
        tasks['children'].append({
            'id': f'finger-enum-users-{port}',
            'name': 'Enumerate Specific Users',
            'type': 'command',
            'metadata': {
                'command': f'finger root@{target}',
                'description': 'Get detailed information about specific user (root)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'finger': 'Finger client',
                    'root@': 'Username to query (change to other usernames)',
                    target: 'Target system'
                },
                'success_indicators': [
                    'User information returned',
                    'Login details, home directory, shell shown',
                    'Plan/project files displayed'
                ],
                'failure_indicators': [
                    'User not found',
                    'No such user message',
                    'Access denied'
                ],
                'next_steps': [
                    'Test common usernames: admin, user, test, guest',
                    'Enumerate from discovered user list',
                    'Look for .plan and .project file contents'
                ],
                'alternatives': [
                    f'echo "root" | nc {target} {port}',
                    f'finger admin@{target}',
                    f'finger user@{target}'
                ],
                'notes': 'Try multiple common usernames. Some systems leak sensitive info in .plan/.project files.',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 4: Automated User Enumeration
        tasks['children'].append({
            'id': f'finger-user-enum-{port}',
            'name': 'Automated User Enumeration (finger-user-enum)',
            'type': 'command',
            'metadata': {
                'command': f'finger-user-enum.pl -U /usr/share/wordlists/metasploit/unix_users.txt -t {target}',
                'description': 'Brute-force valid usernames using pentestmonkey finger-user-enum',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'finger-user-enum.pl': 'Pentestmonkey Finger user enumeration script',
                    '-U': 'Wordlist file containing usernames to test',
                    '/usr/share/wordlists/metasploit/unix_users.txt': 'Common Unix usernames wordlist',
                    '-t': 'Target IP or hostname'
                },
                'success_indicators': [
                    'Valid usernames discovered',
                    'List of existing users returned',
                    'Exit code 0'
                ],
                'failure_indicators': [
                    'All users return "not found"',
                    'Connection errors',
                    'Script timeout'
                ],
                'next_steps': [
                    'Save discovered usernames to file',
                    'Use usernames for SSH/FTP brute-force',
                    'Check for privilege escalation opportunities'
                ],
                'alternatives': [
                    f'for user in $(cat users.txt); do finger $user@{target}; done',
                    f'nmap --script finger -p {port} {target}',
                    'Metasploit: use auxiliary/scanner/finger/finger_users'
                ],
                'notes': 'Download finger-user-enum.pl from pentestmonkey.net/tools/user-enumeration/. Metasploit auxiliary module uses more detection tricks.',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 5: Command Injection Test
        tasks['children'].append({
            'id': f'finger-command-injection-{port}',
            'name': 'Test Command Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Test Finger service for command injection vulnerabilities',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                'alternatives': [
                    f'finger "|/bin/id@{target}"',
                    f'finger "|/bin/ls -a /@{target}"',
                    f'finger "|/bin/cat /etc/passwd@{target}"',
                    f'echo "|whoami" | nc {target} {port}'
                ],
                'success_indicators': [
                    'Command output returned',
                    'System responds to injected commands',
                    'File contents or command results displayed'
                ],
                'failure_indicators': [
                    'Syntax error',
                    'Command not executed',
                    'Service crashes or resets connection'
                ],
                'next_steps': [
                    'If successful, attempt reverse shell',
                    'Enumerate filesystem structure',
                    'Read sensitive files (/etc/passwd, config files)'
                ],
                'notes': 'Command injection in Finger is rare but devastating when present. Use quotes carefully. Test simple commands first (id, whoami).',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 6: Finger Bounce/Relay
        tasks['children'].append({
            'id': f'finger-bounce-{port}',
            'name': 'Finger Bounce/Relay Attack',
            'type': 'manual',
            'metadata': {
                'description': 'Use target Finger service as relay to enumerate internal hosts',
                'tags': ['OSCP:LOW', 'MANUAL', 'ADVANCED'],
                'alternatives': [
                    f'finger user@internal-host@{target}',
                    f'finger @internal-ip@{target}',
                    'Test: finger user@192.168.1.1@target'
                ],
                'success_indicators': [
                    'Internal host responds through relay',
                    'User information from internal system returned',
                    'Service acts as proxy'
                ],
                'failure_indicators': [
                    'Relay blocked',
                    'Service does not support forwarding',
                    'Syntax error'
                ],
                'next_steps': [
                    'Enumerate internal IP ranges',
                    'Map internal network topology',
                    'Use discovered internal hosts for pivoting'
                ],
                'notes': 'Finger bounce allows enumeration of internal networks through external Finger server. Rare but useful for network mapping.',
                'estimated_time': '10-15 minutes'
            }
        })

        # Task 7: Nmap NSE Scripts
        tasks['children'].append({
            'id': f'finger-nmap-{port}',
            'name': 'Nmap Finger Scripts',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script finger -p {port} {target}',
                'description': 'Run Nmap NSE scripts for Finger enumeration',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'nmap': 'Network mapper and scanner',
                    '--script finger': 'Run NSE finger enumeration scripts',
                    '-p': 'Specify port',
                    str(port): 'Finger port',
                    target: 'Target IP'
                },
                'success_indicators': [
                    'Users enumerated',
                    'Script output shows user details',
                    'No errors'
                ],
                'failure_indicators': [
                    'Script timeout',
                    'No users found',
                    'Connection refused'
                ],
                'next_steps': [
                    'Verify findings with manual tests',
                    'Cross-reference with other enumeration',
                    'Use usernames for credential attacks'
                ],
                'alternatives': [
                    'Manual enumeration with finger command',
                    'finger-user-enum.pl',
                    'Metasploit auxiliary/scanner/finger/finger_users'
                ],
                'notes': 'Nmap scripts provide quick automated baseline. Always verify manually for completeness.',
                'estimated_time': '2-3 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class IRCPlugin(ServicePlugin):
    """IRC protocol enumeration plugin"""

    @property
    def name(self) -> str:
        return "irc"

    @property
    def default_ports(self) -> List[int]:
        return [194, 6667, 6668, 6669, 7000]

    @property
    def service_names(self) -> List[str]:
        return ['irc', 'ircs', 'ircd']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect IRC services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if 'irc' in service:
            return True

        # Check port range
        if port in self.default_ports or (6660 <= port <= 7000):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate IRC enumeration task tree"""

        tasks = {
            'id': f'irc-enum-{port}',
            'name': f'IRC Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Banner Grabbing (Plaintext)
        tasks['children'].append({
            'id': f'irc-banner-{port}',
            'name': 'IRC Banner Grabbing',
            'type': 'command',
            'metadata': {
                'command': f'nc -vn {target} {port}',
                'description': 'Connect to IRC server and grab banner',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'nc': 'Netcat for raw TCP connections',
                    '-v': 'Verbose output',
                    '-n': 'No DNS resolution',
                    target: 'Target IP',
                    str(port): 'IRC port'
                },
                'success_indicators': [
                    'IRC server banner displayed',
                    'Server version shown',
                    'PING message received'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Timeout',
                    'No banner displayed'
                ],
                'next_steps': [
                    'Note IRC server version for exploit research',
                    'Proceed with manual enumeration',
                    'Test TLS connection if plaintext fails'
                ],
                'alternatives': [
                    f'telnet {target} {port}',
                    f'openssl s_client -connect {target}:{port} -quiet (for TLS)'
                ],
                'notes': 'IRC can support TLS. If plaintext fails, try TLS connection with openssl.',
                'estimated_time': '1 minute'
            }
        })

        # Task 2: TLS Connection Test
        tasks['children'].append({
            'id': f'irc-tls-{port}',
            'name': 'IRC TLS Connection',
            'type': 'command',
            'metadata': {
                'command': f'openssl s_client -connect {target}:{port} -quiet',
                'description': 'Connect to IRC server over TLS',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'openssl': 'OpenSSL command-line tool',
                    's_client': 'SSL/TLS client mode',
                    '-connect': 'Target host:port',
                    '-quiet': 'Minimal output (no cert details)'
                },
                'success_indicators': [
                    'TLS handshake successful',
                    'IRC banner displayed',
                    'Server responds'
                ],
                'failure_indicators': [
                    'Handshake failed',
                    'TLS not supported',
                    'Connection timeout'
                ],
                'next_steps': [
                    'Proceed with IRC enumeration over TLS',
                    'Note certificate details for intel',
                    'Test authentication'
                ],
                'alternatives': [
                    f'ncat --ssl {target} {port}',
                    f'socat - SSL:{target}:{port},verify=0'
                ],
                'notes': 'Some IRC servers require TLS. Check both plaintext and TLS connections.',
                'estimated_time': '2 minutes'
            }
        })

        # Task 3: Manual IRC Enumeration
        tasks['children'].append({
            'id': f'irc-manual-enum-{port}',
            'name': 'Manual IRC Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Enumerate IRC server using manual commands',
                'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                'alternatives': [
                    f'# Connect: nc -vn {target} {port}',
                    '# Register: USER random 0 * random',
                    '# Set nick: NICK random123',
                    '# Respond to PING: PONG :<value>',
                    '# Commands: VERSION, HELP, INFO, LINKS, ADMIN, USERS, TIME',
                    '# Stats: STATS a (operators only)',
                    '# Channels: NAMES, LIST',
                    '# User info: WHOIS <user>, USERHOST <user>, USERIP <user>',
                    '# Join channel: JOIN #channel',
                    '# Operator test: OPER <user> <pass>'
                ],
                'success_indicators': [
                    'Successfully registered with random nickname',
                    'Server responds to commands',
                    'Channel and user lists retrieved',
                    'Version and info displayed'
                ],
                'failure_indicators': [
                    'Connection closed',
                    'Commands not recognized',
                    'Authentication required',
                    'Banned or blocked'
                ],
                'next_steps': [
                    'List all channels and join interesting ones',
                    'Enumerate users in channels',
                    'Test default credentials (OPER)',
                    'Monitor chat for sensitive info'
                ],
                'notes': 'IRC enumeration workflow: Connect → Register random nick → Respond to PING → Run commands → Join channels → Enumerate users. Full command list: https://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands',
                'estimated_time': '10-15 minutes'
            }
        })

        # Task 4: Default Credentials Test
        tasks['children'].append({
            'id': f'irc-default-creds-{port}',
            'name': 'Test Default IRC Credentials',
            'type': 'manual',
            'metadata': {
                'description': 'Test default passwords for IRC server access',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                'alternatives': [
                    f'# Connect and try: PASS wealllikedebian',
                    f'# Then: NICK patrick',
                    f'# Then: USER test1 test2 {target} :test3',
                    '# ngIRCd default: wealllikedebian',
                    '# Other common: password, admin, 12345'
                ],
                'success_indicators': [
                    'Authentication successful',
                    'Access granted',
                    'Welcome message displayed'
                ],
                'failure_indicators': [
                    'Password incorrect',
                    'Authentication failed',
                    'No password required (unauthenticated access)'
                ],
                'next_steps': [
                    'If authenticated, enumerate with higher privileges',
                    'Test operator commands',
                    'Look for sensitive channels'
                ],
                'notes': 'ngIRCd default password is "wealllikedebian". Test common passwords if default fails.',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 5: Nmap IRC Scripts
        tasks['children'].append({
            'id': f'irc-nmap-{port}',
            'name': 'Nmap IRC Enumeration Scripts',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV --script irc-botnet-channels,irc-info,irc-unrealircd-backdoor -p {port} {target}',
                'description': 'Run Nmap NSE scripts for IRC enumeration and exploit detection',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'ENUM', 'VULN_SCAN'],
                'flag_explanations': {
                    'nmap': 'Network mapper',
                    '-sV': 'Service version detection',
                    '--script': 'Execute NSE scripts',
                    'irc-botnet-channels': 'Detect botnet command channels',
                    'irc-info': 'Retrieve IRC server info',
                    'irc-unrealircd-backdoor': 'Test for UnrealIRCd 3.2.8.1 backdoor',
                    '-p': 'Port specification',
                    str(port): 'IRC port',
                    target: 'Target IP'
                },
                'success_indicators': [
                    'IRC version identified',
                    'Channel list retrieved',
                    'Backdoor detected (if present)',
                    'Server info displayed'
                ],
                'failure_indicators': [
                    'Scripts timeout',
                    'No info retrieved',
                    'Connection refused'
                ],
                'next_steps': [
                    'If UnrealIRCd backdoor found, exploit immediately',
                    'Research identified version for exploits',
                    'Enumerate channels manually',
                    'Join public channels for intel'
                ],
                'alternatives': [
                    'Manual enumeration with nc/telnet',
                    'Metasploit: auxiliary/scanner/irc/*',
                    'Direct IRC client (irssi, weechat)'
                ],
                'notes': 'UnrealIRCd 3.2.8.1 backdoor is a critical RCE. Nmap script detects it. Exploit: Metasploit exploit/unix/irc/unreal_ircd_3281_backdoor',
                'estimated_time': '5-7 minutes'
            }
        })

        # Task 6: Operator Brute-force
        tasks['children'].append({
            'id': f'irc-oper-brute-{port}',
            'name': 'IRC Operator Credential Brute-force',
            'type': 'command',
            'metadata': {
                'command': f'# Manual: Connect → OPER <username> <password>',
                'description': 'Brute-force IRC operator credentials',
                'tags': ['OSCP:LOW', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    'OPER': 'IRC command to authenticate as operator',
                    '<username>': 'Operator username (try: admin, root, oper)',
                    '<password>': 'Operator password'
                },
                'success_indicators': [
                    'OPER command successful',
                    'Operator privileges granted',
                    'Access to restricted commands'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Account locked',
                    'Banned from server'
                ],
                'next_steps': [
                    'If successful, enumerate with STATS a',
                    'Access operator-only channels',
                    'Check for admin commands'
                ],
                'alternatives': [
                    'Hydra: hydra -L users.txt -P pass.txt irc://{target}',
                    'Medusa: medusa -h {target} -U users.txt -P pass.txt -M irc'
                ],
                'notes': 'IRC operator brute-force is noisy and often triggers bans. Use sparingly. Focus on manual enumeration first.',
                'estimated_time': '10-30 minutes'
            }
        })

        # Task 7: Channel Monitoring
        tasks['children'].append({
            'id': f'irc-monitor-{port}',
            'name': 'Monitor IRC Channels',
            'type': 'manual',
            'metadata': {
                'description': 'Join and monitor IRC channels for sensitive information',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'INTEL'],
                'alternatives': [
                    f'# Connect and register',
                    f'# List channels: LIST',
                    f'# Join channel: JOIN #general',
                    f'# Monitor chat for: credentials, server info, admin activity',
                    f'# Use IRC client for persistence: irssi -c {target} -p {port}'
                ],
                'success_indicators': [
                    'Successfully joined channels',
                    'Chat messages visible',
                    'User activity monitored'
                ],
                'failure_indicators': [
                    'Channel requires key/password',
                    'Banned from channel',
                    'No activity in channels'
                ],
                'next_steps': [
                    'Document interesting usernames',
                    'Note any credentials shared in chat',
                    'Identify server admins',
                    'Look for file sharing/DCC'
                ],
                'notes': 'IRC channels may leak credentials, internal IPs, admin credentials. Monitor patiently. Active users may reveal sensitive info.',
                'estimated_time': '15-30 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class RTSPPlugin(ServicePlugin):
    """RTSP streaming protocol enumeration plugin"""

    @property
    def name(self) -> str:
        return "rtsp"

    @property
    def default_ports(self) -> List[int]:
        return [554, 8554]

    @property
    def service_names(self) -> List[str]:
        return ['rtsp', 'rtsp-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect RTSP services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if 'rtsp' in service:
            return True

        # Check ports
        if port in [554, 8554]:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate RTSP enumeration task tree"""

        tasks = {
            'id': f'rtsp-enum-{port}',
            'name': f'RTSP Streaming Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: DESCRIBE Request (Unauthenticated)
        tasks['children'].append({
            'id': f'rtsp-describe-{port}',
            'name': 'RTSP DESCRIBE Request',
            'type': 'manual',
            'metadata': {
                'description': 'Send DESCRIBE request to check authentication and available streams',
                'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'alternatives': [
                    f'# Manual: nc {target} {port}',
                    f'DESCRIBE rtsp://{target}:{port} RTSP/1.0\\r\\nCSeq: 2\\r\\n\\r\\n',
                    f'# Python script:',
                    f'import socket',
                    f's = socket.socket(socket.AF_INET, socket.SOCK_STREAM)',
                    f's.connect(("{target}", {port}))',
                    f's.sendall(b"DESCRIBE rtsp://{target}:{port} RTSP/1.0\\r\\nCSeq: 2\\r\\n\\r\\n")',
                    f'print(s.recv(1024))'
                ],
                'success_indicators': [
                    '200 OK response (unauthenticated access)',
                    'Stream description returned (SDP)',
                    'Available streams listed'
                ],
                'failure_indicators': [
                    '401 Unauthorized (requires authentication)',
                    '404 Not Found (incorrect path)',
                    'Connection refused'
                ],
                'next_steps': [
                    'If 200 OK: Note stream paths, proceed to viewing',
                    'If 401: Note auth type (Basic/Digest), test credentials',
                    'Try common paths: /mpeg4, /live.sdp, /stream, /h264'
                ],
                'notes': 'RTSP DESCRIBE checks if authentication is required. Response format must include double \\r\\n. 200 OK = no auth needed (quick win).',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 2: Basic Authentication Test
        tasks['children'].append({
            'id': f'rtsp-basic-auth-{port}',
            'name': 'RTSP Basic Authentication',
            'type': 'manual',
            'metadata': {
                'description': 'Test RTSP access with Basic authentication',
                'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                'alternatives': [
                    f'# Base64 encode credentials: echo -n "admin:1234" | base64',
                    f'# Result: YWRtaW46MTIzNA==',
                    f'DESCRIBE rtsp://{target}:{port} RTSP/1.0\\r\\nCSeq: 2\\r\\nAuthorization: Basic YWRtaW46MTIzNA==\\r\\n\\r\\n',
                    f'# Python script:',
                    f'import socket, base64',
                    f'creds = base64.b64encode(b"admin:password").decode()',
                    f'req = f"DESCRIBE rtsp://{target}:{port} RTSP/1.0\\r\\nCSeq: 2\\r\\nAuthorization: Basic {{creds}}\\r\\n\\r\\n"',
                    f's = socket.socket(); s.connect(("{target}", {port})); s.sendall(req.encode()); print(s.recv(1024))'
                ],
                'success_indicators': [
                    '200 OK response',
                    'Stream accessible',
                    'SDP description returned'
                ],
                'failure_indicators': [
                    '401 Unauthorized',
                    'Invalid credentials',
                    'Digest auth required'
                ],
                'next_steps': [
                    'If successful: View stream, enumerate paths',
                    'If failed: Try default credentials, brute-force',
                    'Test: admin/admin, admin/password, admin/1234, root/root'
                ],
                'notes': 'Basic auth is simpler than Digest. Try common credentials first. Common defaults: admin/admin, admin/password, root/pass.',
                'estimated_time': '5 minutes'
            }
        })

        # Task 3: Nmap RTSP Scripts
        tasks['children'].append({
            'id': f'rtsp-nmap-{port}',
            'name': 'Nmap RTSP Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV --script "rtsp-*" -p {port} {target}',
                'description': 'Run Nmap NSE scripts for RTSP enumeration',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'ENUM'],
                'flag_explanations': {
                    'nmap': 'Network scanner',
                    '-sV': 'Service version detection',
                    '--script "rtsp-*"': 'Run all RTSP NSE scripts',
                    '-p': 'Port specification',
                    str(port): 'RTSP port',
                    target: 'Target IP'
                },
                'success_indicators': [
                    'RTSP methods discovered',
                    'Valid stream paths found',
                    'Authentication requirements identified'
                ],
                'failure_indicators': [
                    'No info retrieved',
                    'Scripts timeout',
                    'Connection refused'
                ],
                'next_steps': [
                    'Test discovered paths manually',
                    'Attempt authentication with found methods',
                    'View streams if unauthenticated'
                ],
                'alternatives': [
                    'Manual DESCRIBE requests',
                    'Cameradar tool',
                    'rtsp_authgrinder'
                ],
                'notes': 'Nmap RTSP scripts discover methods and paths. Good starting point for RTSP enumeration.',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 4: Stream Viewing with ffplay
        tasks['children'].append({
            'id': f'rtsp-ffplay-{port}',
            'name': 'View RTSP Stream (ffplay)',
            'type': 'command',
            'metadata': {
                'command': f'ffplay -rtsp_transport tcp rtsp://{target}/mpeg4 -x 1920 -y 1080',
                'description': 'View discovered RTSP stream using ffplay',
                'tags': ['OSCP:LOW', 'MANUAL', 'QUICK_WIN'],
                'flag_explanations': {
                    'ffplay': 'FFmpeg media player',
                    '-rtsp_transport tcp': 'Use TCP instead of UDP (more reliable)',
                    'rtsp://': 'RTSP protocol URL',
                    '/mpeg4': 'Stream path (change to discovered path)',
                    '-x': 'Video width in pixels',
                    '-y': 'Video height in pixels'
                },
                'success_indicators': [
                    'Video stream displayed',
                    'Real-time feed visible',
                    'No authentication error'
                ],
                'failure_indicators': [
                    'Authentication required',
                    'Stream not found (404)',
                    'Connection timeout',
                    'Codec error'
                ],
                'next_steps': [
                    'Document what is visible in stream (physical security intel)',
                    'Try other discovered paths',
                    'Capture screenshots for report',
                    'Test with credentials if needed: rtsp://user:pass@target/path'
                ],
                'alternatives': [
                    f'vlc rtsp://{target}/stream',
                    f'mplayer rtsp://{target}/live.sdp',
                    f'ffmpeg -i rtsp://{target}/mpeg4 -frames:v 1 screenshot.png'
                ],
                'notes': 'Common RTSP paths: /mpeg4, /live.sdp, /h264, /stream, /video. Try multiple. TCP transport is more stable than UDP.',
                'estimated_time': '2-3 minutes per path'
            }
        })

        # Task 5: Cameradar Automated Tool
        tasks['children'].append({
            'id': f'rtsp-cameradar-{port}',
            'name': 'Cameradar Automated RTSP Attack',
            'type': 'command',
            'metadata': {
                'command': f'cameradar -t {target} -p {port}',
                'description': 'Use Cameradar to automate RTSP enumeration and attack',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'BRUTE_FORCE'],
                'flag_explanations': {
                    'cameradar': 'Automated RTSP camera exploitation tool',
                    '-t': 'Target IP address',
                    '-p': 'Target port'
                },
                'success_indicators': [
                    'Streams discovered',
                    'Credentials brute-forced',
                    'Thumbnails generated',
                    'Valid routes found'
                ],
                'failure_indicators': [
                    'No streams found',
                    'All brute-force failed',
                    'Tool timeout'
                ],
                'next_steps': [
                    'View discovered streams',
                    'Test found credentials on other services',
                    'Document camera locations and views',
                    'Check for firmware vulnerabilities'
                ],
                'alternatives': [
                    f'rtsp_authgrinder -t {target} -p {port}',
                    'Manual brute-force with custom scripts',
                    'Hydra RTSP brute-force'
                ],
                'notes': 'Cameradar: https://github.com/Ullaakut/cameradar. Features: host detection, dictionary attacks for routes/creds, thumbnail generation, stream validation. Low OSCP relevance (IoT/cameras rare in OSCP).',
                'estimated_time': '10-20 minutes'
            }
        })

        # Task 6: Path Brute-force
        tasks['children'].append({
            'id': f'rtsp-path-brute-{port}',
            'name': 'RTSP Path Brute-force',
            'type': 'manual',
            'metadata': {
                'description': 'Brute-force common RTSP stream paths',
                'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                'alternatives': [
                    f'# Common paths to test:',
                    f'/mpeg4, /live.sdp, /h264, /stream, /video, /cam, /axis-media/media.amp',
                    f'/onvif/device_service, /live, /ch0, /ch1, /channel1',
                    f'# Manual test:',
                    f'for path in mpeg4 live.sdp h264 stream; do',
                    f'  echo "DESCRIBE rtsp://{target}/{port}/$path RTSP/1.0\\r\\nCSeq: 2\\r\\n\\r\\n" | nc {target} {port}',
                    f'done'
                ],
                'success_indicators': [
                    '200 OK response',
                    'Stream description returned',
                    'Valid path discovered'
                ],
                'failure_indicators': [
                    '404 Not Found (all paths)',
                    'Connection timeout',
                    'Authentication required'
                ],
                'next_steps': [
                    'View streams with ffplay',
                    'Document valid paths',
                    'Test with credentials if needed'
                ],
                'notes': 'RTSP path discovery is key. Common paths: /mpeg4, /live.sdp, /h264. Use Cameradar or rtsp_authgrinder for automation.',
                'estimated_time': '5-10 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class EchoPlugin(ServicePlugin):
    """Echo service enumeration plugin (port 7)"""

    @property
    def name(self) -> str:
        return "echo"

    @property
    def default_ports(self) -> List[int]:
        return [7]

    @property
    def service_names(self) -> List[str]:
        return ['echo']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Echo services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        protocol = port_info.get('protocol', 'tcp').lower()

        # Check service name
        if service == 'echo':
            return True

        # Check port (both TCP and UDP)
        if port == 7:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Echo service task tree"""

        protocol = service_info.get('protocol', 'tcp').lower()

        tasks = {
            'id': f'echo-enum-{port}',
            'name': f'Echo Service Testing (Port {port}/{protocol})',
            'type': 'parent',
            'children': []
        }

        # Task 1: Echo Service Test
        if protocol == 'udp':
            tasks['children'].append({
                'id': f'echo-test-udp-{port}',
                'name': 'Test Echo Service (UDP)',
                'type': 'command',
                'metadata': {
                    'command': f'nc -uvn {target} {port}',
                    'description': 'Test UDP echo service (sends back any data received)',
                    'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        'nc': 'Netcat network tool',
                        '-u': 'UDP mode',
                        '-v': 'Verbose output',
                        '-n': 'No DNS resolution',
                        target: 'Target IP',
                        str(port): 'Echo port (7/udp)'
                    },
                    'success_indicators': [
                        'Connection established',
                        'Sent data echoed back',
                        'Service responds'
                    ],
                    'failure_indicators': [
                        'No response',
                        'Connection timeout',
                        'Service not available'
                    ],
                    'next_steps': [
                        'Document that echo service is running',
                        'Check if service can be abused for DoS',
                        'Test TCP echo as well'
                    ],
                    'alternatives': [
                        f'echo "Hello" | nc -u {target} {port}',
                        f'nmap -sU -p {port} {target}'
                    ],
                    'notes': 'Echo service is legacy testing service. Minimal enumeration value. Primary risk is DoS by connecting echo to echo.',
                    'estimated_time': '1 minute'
                }
            })
        else:
            tasks['children'].append({
                'id': f'echo-test-tcp-{port}',
                'name': 'Test Echo Service (TCP)',
                'type': 'command',
                'metadata': {
                    'command': f'nc -vn {target} {port}',
                    'description': 'Test TCP echo service',
                    'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL'],
                    'flag_explanations': {
                        'nc': 'Netcat',
                        '-v': 'Verbose',
                        '-n': 'No DNS',
                        target: 'Target IP',
                        str(port): 'Echo port (7/tcp)'
                    },
                    'success_indicators': [
                        'Connection established',
                        'Data echoed back'
                    ],
                    'failure_indicators': [
                        'Connection refused',
                        'No response'
                    ],
                    'next_steps': [
                        'Document service presence',
                        'Move to higher-value targets'
                    ],
                    'alternatives': [
                        f'telnet {target} {port}'
                    ],
                    'notes': 'Echo service has minimal security value. Focus on other services.',
                    'estimated_time': '1 minute'
                }
            })

        # Task 2: Note about DoS (informational)
        tasks['children'].append({
            'id': f'echo-dos-note-{port}',
            'name': 'Echo Service DoS Risk',
            'type': 'manual',
            'metadata': {
                'description': 'Note: Echo service can be abused for DoS by connecting to itself or another echo service',
                'tags': ['OSCP:LOW', 'INFO'],
                'alternatives': [
                    'WARNING: DoS testing not recommended in OSCP',
                    'Info: Echo-to-echo creates packet loop',
                    'Mitigation: Disable echo service (inetd/xinetd)'
                ],
                'notes': 'Echo service DoS: Connecting echo to echo creates infinite packet loop. Not useful for OSCP enumeration. Focus on higher-value services.',
                'estimated_time': 'N/A'
            }
        })

        return tasks
