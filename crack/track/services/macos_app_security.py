"""
macOS Application Security Analysis Plugin

Generates tasks for macOS application reverse engineering, including:
- Static binary analysis (otool, objdump, nm, jtool2, disarm)
- Code signing verification and bypass techniques
- Entitlements extraction and analysis
- Dynamic analysis and debugging (lldb, dtrace, dtruss)
- Application fuzzing methodologies
- Anti-debugging detection and bypass
- Objective-C and Swift metadata extraction
- Memory analysis and runtime inspection

Extracted from HackTricks: macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSAppSecurityPlugin(ServicePlugin):
    """macOS application security analysis and reverse engineering plugin"""

    @property
    def name(self) -> str:
        return "macos-app-security"

    @property
    def default_ports(self) -> List[int]:
        return []  # This is not a network service

    @property
    def service_names(self) -> List[str]:
        return ['macos-app', 'darwin-binary', 'mach-o']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect macOS application analysis context"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # Check for macOS-specific indicators
        if any(keyword in service for keyword in ['macos', 'darwin', 'mach-o']):
            return True

        if any(keyword in product for keyword in ['macos', 'darwin', 'apple']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS application security analysis task tree"""

        binary_path = service_info.get('binary_path', '/path/to/binary')
        app_path = service_info.get('app_path', '/Applications/Target.app')

        tasks = {
            'id': 'macos-app-security',
            'name': 'macOS Application Security Analysis',
            'type': 'parent',
            'children': []
        }

        # ========================================
        # PHASE 1: STATIC ANALYSIS
        # ========================================
        static_analysis = {
            'id': 'static-analysis',
            'name': 'Static Binary Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Basic Binary Information with otool
        static_analysis['children'].append({
            'id': 'otool-basic-info',
            'name': 'Extract Binary Information (otool)',
            'type': 'command',
            'metadata': {
                'command': f'otool -L {binary_path}',
                'description': 'List dynamically linked libraries and dependencies',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'otool': 'Object file displaying tool (macOS/Darwin)',
                    '-L': 'List shared libraries used',
                    binary_path: 'Path to Mach-O binary to analyze'
                },
                'success_indicators': [
                    'Library paths displayed (/usr/lib/, /System/Library/)',
                    'Compatibility versions shown',
                    'Framework dependencies listed'
                ],
                'failure_indicators': [
                    'Not a Mach-O binary',
                    'File not found',
                    'Permission denied'
                ],
                'next_steps': [
                    'Identify vulnerable library versions',
                    'Check for non-standard library paths (injection vectors)',
                    'Map attack surface via imported frameworks'
                ],
                'alternatives': [
                    f'objdump -m --dylibs-used {binary_path}',
                    f'jtool2 -L {binary_path}',
                    'Manual: strings + grep for .dylib paths'
                ],
                'notes': 'Focus on non-system libraries and custom frameworks for attack surface'
            }
        })

        # Task 1.2: Disassemble with otool
        static_analysis['children'].append({
            'id': 'otool-disassemble',
            'name': 'Disassemble Binary (otool)',
            'type': 'command',
            'metadata': {
                'command': f'otool -tv {binary_path}',
                'description': 'Disassemble Mach-O binary to inspect code',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    '-t': 'Display text section (code)',
                    '-v': 'Verbose output with symbolic information',
                    binary_path: 'Binary to disassemble'
                },
                'success_indicators': [
                    'Assembly instructions displayed',
                    'Function names visible',
                    'Code section dumped'
                ],
                'failure_indicators': [
                    'Stripped binary (no symbols)',
                    'Encrypted/packed binary',
                    'Invalid Mach-O format'
                ],
                'next_steps': [
                    'Identify interesting functions (auth, crypto, validation)',
                    'Look for hardcoded credentials',
                    'Map control flow for vulnerability analysis'
                ],
                'alternatives': [
                    f'objdump -d {binary_path}',
                    f'jtool2 -d {binary_path}',
                    f'ARCH=arm64e disarm -c -d {binary_path} (for ARM64)',
                    'Hopper Disassembler (GUI)',
                    'IDA Pro / Ghidra'
                ],
                'notes': 'For stripped binaries, focus on string references and imported functions'
            }
        })

        # Task 1.3: Extract symbols with nm
        static_analysis['children'].append({
            'id': 'nm-symbols',
            'name': 'List Binary Symbols (nm)',
            'type': 'command',
            'metadata': {
                'command': f'nm -m {binary_path}',
                'description': 'Display symbol table (function names, globals)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'nm': 'Name list - display symbol table',
                    '-m': 'Display symbols in Mach-O symbol table format',
                    binary_path: 'Binary to analyze'
                },
                'success_indicators': [
                    'Function names listed',
                    'Global variables shown',
                    'External symbols identified'
                ],
                'failure_indicators': [
                    'No symbols (stripped binary)',
                    'Empty output'
                ],
                'next_steps': [
                    'Identify authentication/authorization functions',
                    'Look for debug/test functions',
                    'Map exported API surface'
                ],
                'alternatives': [
                    f'objdump -m --syms {binary_path}',
                    f'jtool2 -S {binary_path}',
                    'strings {binary_path} | grep -E "^[a-zA-Z_]"'
                ],
                'notes': 'If stripped, symbols won\'t be available - rely on dynamic analysis'
            }
        })

        # Task 1.4: Advanced analysis with jtool2
        static_analysis['children'].append({
            'id': 'jtool2-analysis',
            'name': 'Advanced Binary Analysis (jtool2)',
            'type': 'command',
            'metadata': {
                'command': f'jtool2 -l {binary_path}',
                'description': 'Get comprehensive Mach-O header information',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'jtool2': 'Enhanced jtool - Mach-O analyzer (successor to jtool)',
                    '-l': 'List load commands and headers',
                    binary_path: 'Binary to analyze'
                },
                'success_indicators': [
                    'Load commands displayed',
                    'Segment information shown',
                    'Architecture details visible'
                ],
                'failure_indicators': [
                    'jtool2 not installed',
                    'Invalid Mach-O format'
                ],
                'next_steps': [
                    'Check for LC_ENCRYPTION_INFO (App Store binaries)',
                    'Identify code signing requirements',
                    'Review entitlements in load commands'
                ],
                'alternatives': [
                    f'otool -l {binary_path}',
                    f'objdump -m -h {binary_path}',
                    f'ARCH=arm64e disarm -c -i -I --signature {binary_path}'
                ],
                'notes': 'Install: brew install --cask jtool2 | Download: http://www.newosxbook.com/tools/jtool.html'
            }
        })

        # Task 1.5: Disarm analysis (ARM64)
        static_analysis['children'].append({
            'id': 'disarm-analysis',
            'name': 'ARM64 Binary Analysis (disarm)',
            'type': 'command',
            'metadata': {
                'command': f'ARCH=arm64e disarm -c -i -I --signature {binary_path}',
                'description': 'Analyze ARM64 binary structure and code signature',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    'ARCH=arm64e': 'Set architecture to ARM64e (Apple Silicon)',
                    'disarm': 'ARM disassembler and analyzer (jtool successor)',
                    '-c': 'Analyze code',
                    '-i': 'Show import information',
                    '-I': 'Show detailed import information',
                    '--signature': 'Display code signature information',
                    binary_path: 'Binary to analyze'
                },
                'success_indicators': [
                    'ARM64 instructions decoded',
                    'Imports listed',
                    'Signature details shown'
                ],
                'failure_indicators': [
                    'disarm not installed',
                    'Not an ARM64 binary',
                    'Unsupported architecture'
                ],
                'next_steps': [
                    'Analyze ARM64-specific exploitation techniques',
                    'Check pointer authentication (PAC) usage',
                    'Review code signature for weaknesses'
                ],
                'alternatives': [
                    f'jtool2 -arch arm64e -d {binary_path}',
                    f'otool -arch arm64e -tv {binary_path}',
                    'Hopper Disassembler with ARM64 support'
                ],
                'notes': 'Download: https://newosxbook.com/tools/disarm.html | For Apple Silicon Macs'
            }
        })

        # Task 1.6: Check for packing/encryption
        static_analysis['children'].append({
            'id': 'check-packing',
            'name': 'Detect Packed/Encrypted Binaries',
            'type': 'manual',
            'metadata': {
                'description': 'Identify if binary is packed, obfuscated, or encrypted',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'High entropy detected (>7.0 = likely packed)',
                    'Few readable strings',
                    '__XHDR section present (UPX packer)',
                    'LC_ENCRYPTION_INFO_64 command present'
                ],
                'failure_indicators': [
                    'Normal entropy (~5-6)',
                    'Readable strings',
                    'Standard Mach-O structure'
                ],
                'next_steps': [
                    'If UPX: upx -d binary to unpack',
                    'If encrypted: Dump from memory at runtime',
                    'If obfuscated: Use dynamic analysis'
                ],
                'alternatives': [
                    'ent {binary_path} # Entropy calculation',
                    'strings {binary_path} | wc -l # String count',
                    'otool -l {binary_path} | grep -A5 LC_ENCRYPTION',
                    'Check for __XHDR section: otool -l | grep __XHDR'
                ],
                'notes': 'Packed/encrypted binaries require dynamic analysis or memory dumping'
            }
        })

        tasks['children'].append(static_analysis)

        # ========================================
        # PHASE 2: CODE SIGNING ANALYSIS
        # ========================================
        code_signing = {
            'id': 'code-signing',
            'name': 'Code Signing & Entitlements Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Verify code signature
        code_signing['children'].append({
            'id': 'codesign-verify',
            'name': 'Verify Code Signature',
            'type': 'command',
            'metadata': {
                'command': f'codesign -vv -d {app_path} 2>&1',
                'description': 'Verify application code signature validity',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'codesign': 'macOS code signing utility',
                    '-vv': 'Very verbose output (double verbose)',
                    '-d': 'Display signature information',
                    app_path: 'Path to .app bundle or binary',
                    '2>&1': 'Redirect stderr to stdout'
                },
                'success_indicators': [
                    'Valid signature',
                    'TeamIdentifier shown',
                    'Authority chain displayed',
                    'No modifications detected'
                ],
                'failure_indicators': [
                    'Invalid signature',
                    'Code object is not signed',
                    'Signature has been modified'
                ],
                'next_steps': [
                    'Check entitlements if signature valid',
                    'Attempt signature bypass if invalid',
                    'Investigate ad-hoc signatures (self-signed)'
                ],
                'alternatives': [
                    f'spctl --assess --verbose {app_path}',
                    f'ldid -h {binary_path} (iOS)',
                    'Manual: Check __LINKEDIT segment'
                ],
                'notes': 'Ad-hoc signatures (no Team ID) are often bypassable'
            }
        })

        # Task 2.2: Extract entitlements
        code_signing['children'].append({
            'id': 'codesign-entitlements',
            'name': 'Extract Entitlements',
            'type': 'command',
            'metadata': {
                'command': f'codesign -d --entitlements :- {app_path}',
                'description': 'Extract and display application entitlements (permissions)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-d': 'Display signature info',
                    '--entitlements :-': 'Output entitlements to stdout',
                    app_path: 'Application bundle to analyze'
                },
                'success_indicators': [
                    'XML entitlements displayed',
                    'Permission keys visible (com.apple.*)',
                    'TCC permissions identified'
                ],
                'failure_indicators': [
                    'No entitlements',
                    'Binary not signed'
                ],
                'next_steps': [
                    'Check for dangerous entitlements (get-task-allow, disable-library-validation)',
                    'Map TCC permissions for attack vectors',
                    'Compare with system apps for privilege gaps'
                ],
                'alternatives': [
                    f'ldid -e {binary_path} (iOS)',
                    f'jtool2 --ent {binary_path}',
                    'Manual: Extract from __LINKEDIT segment'
                ],
                'notes': 'Key entitlements: get-task-allow (debugging), com.apple.security.cs.* (hardened runtime)'
            }
        })

        # Task 2.3: Check Gatekeeper assessment
        code_signing['children'].append({
            'id': 'spctl-assess',
            'name': 'Gatekeeper Assessment',
            'type': 'command',
            'metadata': {
                'command': f'spctl --assess --verbose {app_path}',
                'description': 'Check if Gatekeeper allows application execution',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'spctl': 'System Policy Control - Gatekeeper management',
                    '--assess': 'Evaluate application against policy',
                    '--verbose': 'Detailed output',
                    app_path: 'Application to assess'
                },
                'success_indicators': [
                    'Accepted - application passes Gatekeeper',
                    'Source=Developer ID or Mac App Store',
                    'No quarantine rejection'
                ],
                'failure_indicators': [
                    'Rejected - does not pass Gatekeeper',
                    'Unsigned or ad-hoc signed',
                    'Developer ID certificate revoked'
                ],
                'next_steps': [
                    'If rejected: Right-click Open to bypass (user consent)',
                    'Check quarantine attribute: xattr -l',
                    'Attempt signature stripping and re-signing'
                ],
                'alternatives': [
                    f'xattr -l {app_path} | grep com.apple.quarantine',
                    f'codesign --verify --verbose {app_path}',
                    'sudo spctl --master-disable (disable Gatekeeper - requires admin)'
                ],
                'notes': 'Gatekeeper can be bypassed via user consent or quarantine attribute removal'
            }
        })

        # Task 2.4: Remove and re-sign binary
        code_signing['children'].append({
            'id': 'codesign-resign',
            'name': 'Strip and Re-sign Binary',
            'type': 'manual',
            'metadata': {
                'description': 'Remove existing signature and re-sign for debugging/modification',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'Signature removed',
                    'Binary successfully re-signed',
                    'Binary executes without Gatekeeper rejection'
                ],
                'failure_indicators': [
                    'codesign --remove-signature failed',
                    'Re-signing failed (no certificate)',
                    'SIP prevents modification'
                ],
                'next_steps': [
                    'Test modified binary execution',
                    'Inject debugging entitlements',
                    'Bypass runtime protections'
                ],
                'alternatives': [
                    f'codesign --remove-signature {binary_path}',
                    f'codesign -s - {binary_path} # Ad-hoc sign',
                    f'codesign -s <cert-name> {binary_path}',
                    f'ldid -S {binary_path} (iOS)',
                    'Use pre-signed binaries from other sources'
                ],
                'notes': 'Useful for instrumentation, requires SIP disabled or copy to /tmp'
            }
        })

        # Task 2.5: Inspect installer packages
        code_signing['children'].append({
            'id': 'suspicious-package',
            'name': 'Inspect .pkg Installer',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze .pkg installers for malicious pre/postinstall scripts',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Installer contents extracted',
                    'Pre/postinstall scripts visible',
                    'Payload files listed'
                ],
                'failure_indicators': [
                    'SuspiciousPackage not installed',
                    'Encrypted/protected package'
                ],
                'next_steps': [
                    'Review preinstall/postinstall bash scripts',
                    'Check for persistence mechanisms (LaunchAgents/Daemons)',
                    'Inspect payload for trojanized binaries'
                ],
                'alternatives': [
                    'pkgutil --expand installer.pkg /tmp/pkg_expanded',
                    'tar -xzvf installer.pkg',
                    'SuspiciousPackage.app (GUI tool)',
                    'Manual: Right-click Show Package Contents'
                ],
                'notes': 'Download SuspiciousPackage: https://mothersruin.com/software/SuspiciousPackage/'
            }
        })

        # Task 2.6: Mount DMG images
        code_signing['children'].append({
            'id': 'hdiutil-mount',
            'name': 'Mount and Inspect .dmg Images',
            'type': 'command',
            'metadata': {
                'command': 'hdiutil attach ~/Downloads/Installer.dmg',
                'description': 'Mount Apple disk image for inspection before execution',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'hdiutil': 'Disk image utility',
                    'attach': 'Mount disk image',
                    '~/Downloads/Installer.dmg': 'Path to .dmg file'
                },
                'success_indicators': [
                    'Image mounted to /Volumes/',
                    'Filesystem accessible',
                    'Contents visible in Finder'
                ],
                'failure_indicators': [
                    'Encrypted image (password required)',
                    'Corrupted disk image',
                    'Mount failed'
                ],
                'next_steps': [
                    'Inspect mounted contents: ls /Volumes/InstallerName/',
                    'Analyze binaries before installation',
                    'Check for hidden files: ls -la /Volumes/InstallerName/'
                ],
                'alternatives': [
                    'hdiutil mount installer.dmg',
                    'open installer.dmg (auto-mount)',
                    '7z x installer.dmg (extract without mount)',
                    'Unmount: hdiutil detach /Volumes/InstallerName'
                ],
                'notes': 'Always inspect DMG contents before running installers - persistence risk'
            }
        })

        tasks['children'].append(code_signing)

        # ========================================
        # PHASE 3: OBJECTIVE-C & SWIFT ANALYSIS
        # ========================================
        objc_swift = {
            'id': 'objc-swift-analysis',
            'name': 'Objective-C & Swift Metadata Extraction',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Dump Objective-C metadata with Dynadump
        objc_swift['children'].append({
            'id': 'dynadump',
            'name': 'Dump Objective-C Classes (dynadump)',
            'type': 'command',
            'metadata': {
                'command': f'dynadump dump {binary_path}',
                'description': 'Extract Objective-C class declarations and method signatures',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'dynadump': 'Objective-C class dumper (modern, works best)',
                    'dump': 'Extract class information',
                    binary_path: 'Mach-O binary or dylib to analyze'
                },
                'success_indicators': [
                    'Class declarations dumped',
                    'Method signatures visible',
                    'Instance variables listed'
                ],
                'failure_indicators': [
                    'Not an Objective-C binary',
                    'Stripped/encrypted binary',
                    'dynadump not installed'
                ],
                'next_steps': [
                    'Identify authentication/authorization methods',
                    'Look for insecure methods (validatePassword:, isAdmin:)',
                    'Map API surface for fuzzing targets'
                ],
                'alternatives': [
                    f'class-dump {binary_path} (old, unmaintained)',
                    f'icdump {binary_path} (Python-based)',
                    f'otool -ov {binary_path}',
                    f'objdump --macho --objc-meta-data {binary_path}'
                ],
                'notes': 'Install: https://github.com/DerekSelander/dynadump | Best tool as of 2024'
            }
        })

        # Task 3.2: Alternative - iCDump
        objc_swift['children'].append({
            'id': 'icdump',
            'name': 'Extract Objective-C Metadata (iCDump)',
            'type': 'command',
            'metadata': {
                'command': f'python3 -c "import icdump; print(icdump.objc.parse(\'{binary_path}\').to_decl())"',
                'description': 'Cross-platform Objective-C class dump with Python bindings',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    'icdump': 'Modern cross-platform Objective-C dumper',
                    'objc.parse()': 'Parse Objective-C metadata',
                    'to_decl()': 'Convert to declaration format',
                    binary_path: 'Binary to analyze'
                },
                'success_indicators': [
                    'Class declarations returned',
                    'Method signatures extracted',
                    'Python output successful'
                ],
                'failure_indicators': [
                    'icdump not installed',
                    'Import error',
                    'No Objective-C metadata found'
                ],
                'next_steps': [
                    'Parse output for interesting methods',
                    'Cross-reference with runtime behavior',
                    'Identify hook points for Frida/LLDB'
                ],
                'alternatives': [
                    'pip3 install icdump',
                    'dynadump (recommended)',
                    'Manual: otool -ov {binary_path}'
                ],
                'notes': 'Install: pip3 install icdump | GitHub: https://github.com/romainthomas/iCDump'
            }
        })

        # Task 3.3: Swift metadata analysis
        objc_swift['children'].append({
            'id': 'swift-metadata',
            'name': 'Extract Swift Metadata',
            'type': 'command',
            'metadata': {
                'command': f'jtool2 -l {binary_path} | grep __swift5',
                'description': 'Identify Swift sections and extract type information',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    'jtool2 -l': 'List load commands and sections',
                    'grep __swift5': 'Filter for Swift 5+ metadata sections',
                    binary_path: 'Swift binary to analyze'
                },
                'success_indicators': [
                    '__swift5_typeref section found',
                    '__swift5_reflstr section found',
                    '__swift5_fieldmd section found',
                    'Swift metadata present'
                ],
                'failure_indicators': [
                    'No __swift5 sections',
                    'Not a Swift binary',
                    'Objective-C only'
                ],
                'next_steps': [
                    'Use swift demangle to decode symbols',
                    'Extract type metadata for fuzzing',
                    'Identify Swift-specific attack surface'
                ],
                'alternatives': [
                    f'otool -l {binary_path} | grep -A5 __swift5',
                    f'swift demangle < mangled_symbols.txt',
                    'Ghidra with swift_demangler plugin',
                    'Manual: Analyze __swift5_* sections'
                ],
                'notes': 'Swift binaries retain more metadata than Objective-C - useful for reversing'
            }
        })

        # Task 3.4: Swift demangling
        objc_swift['children'].append({
            'id': 'swift-demangle',
            'name': 'Demangle Swift Symbols',
            'type': 'command',
            'metadata': {
                'command': f'nm {binary_path} | grep _T | swift demangle',
                'description': 'Decode mangled Swift symbol names to readable format',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'nm': 'List symbols',
                    'grep _T': 'Filter for Swift mangled symbols',
                    'swift demangle': 'Decode Swift name mangling',
                    binary_path: 'Binary with Swift symbols'
                },
                'success_indicators': [
                    'Readable Swift function names',
                    'Type information visible',
                    'Module names decoded'
                ],
                'failure_indicators': [
                    'No Swift symbols',
                    'swift command not found',
                    'Binary stripped'
                ],
                'next_steps': [
                    'Identify authentication/crypto functions',
                    'Map Swift API surface',
                    'Plan LLDB breakpoints on decoded functions'
                ],
                'alternatives': [
                    'swift demangle _TFC3App4User6verifyFSbT_',
                    'Ghidra swift_demangler.py plugin',
                    'https://github.com/ghidraninja/ghidra_scripts/blob/master/swift_demangler.py'
                ],
                'notes': 'Swift symbols often more informative than Objective-C for reversing'
            }
        })

        tasks['children'].append(objc_swift)

        # ========================================
        # PHASE 4: DYNAMIC ANALYSIS & DEBUGGING
        # ========================================
        dynamic_analysis = {
            'id': 'dynamic-analysis',
            'name': 'Dynamic Analysis & Debugging',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Basic LLDB debugging
        dynamic_analysis['children'].append({
            'id': 'lldb-basic',
            'name': 'Launch with LLDB Debugger',
            'type': 'command',
            'metadata': {
                'command': f'lldb {binary_path}',
                'description': 'Launch binary under LLDB debugger for runtime analysis',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'lldb': 'LLVM debugger (macOS default)',
                    binary_path: 'Binary to debug'
                },
                'success_indicators': [
                    'LLDB prompt appears',
                    'Binary loaded',
                    'Symbols available (or no symbols warning)'
                ],
                'failure_indicators': [
                    'PT_DENY_ATTACH detected (anti-debug)',
                    'SIP blocks debugging',
                    'Binary not found'
                ],
                'next_steps': [
                    'Set breakpoints: (lldb) b main',
                    'Run binary: (lldb) r',
                    'Inspect registers: (lldb) reg read',
                    'Disassemble: (lldb) dis -n main'
                ],
                'alternatives': [
                    f'lldb -p <PID> # Attach to running process',
                    f'lldb -n {binary_path} --waitfor # Wait for launch',
                    'codesign --remove-signature {binary_path} # Remove PT_DENY_ATTACH',
                    'Use Frida for anti-debug bypass'
                ],
                'notes': 'SIP must be disabled OR binary copied to /tmp and unsigned for system binaries'
            }
        })

        # Task 4.2: LLDB common commands
        dynamic_analysis['children'].append({
            'id': 'lldb-commands',
            'name': 'LLDB Command Reference',
            'type': 'manual',
            'metadata': {
                'description': 'Essential LLDB commands for macOS binary debugging',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH'],
                'success_indicators': [
                    'Breakpoints set successfully',
                    'Memory inspection working',
                    'Function calls traced'
                ],
                'alternatives': [
                    '(lldb) b main # Breakpoint at main',
                    '(lldb) b -a 0x100004bd9 # Break at address',
                    '(lldb) r # Run',
                    '(lldb) c # Continue',
                    '(lldb) n # Next instruction (step over)',
                    '(lldb) s # Step into',
                    '(lldb) reg read # Read all registers',
                    '(lldb) reg read $rax # Read specific register',
                    '(lldb) x/s $rax # Examine string at address',
                    '(lldb) x/i $rip # Examine instruction',
                    '(lldb) po $rax # Print object (Objective-C)',
                    '(lldb) memory read 0xADDRESS',
                    '(lldb) dis -n function_name # Disassemble',
                    '(lldb) image list # List loaded libraries',
                    '(lldb) thread backtrace # Stack trace'
                ],
                'notes': 'Create ~/.lldbinit with: settings set target.x86-disassembly-flavor intel'
            }
        })

        # Task 4.3: Breakpoint on Objective-C methods
        dynamic_analysis['children'].append({
            'id': 'lldb-objc-breakpoint',
            'name': 'Set Objective-C Method Breakpoints',
            'type': 'command',
            'metadata': {
                'command': 'lldb -o "b -[NSFileManager fileExistsAtPath:]" -o "r" -o "po $x0" {binary_path}',
                'description': 'Break on Objective-C method and inspect arguments',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'lldb -o': 'Execute LLDB command',
                    'b -[Class method:]': 'Breakpoint on instance method',
                    'b +[Class method:]': 'Breakpoint on class method',
                    'po $x0': 'Print object in register x0 (self)',
                    'po $x1': 'Print selector name (ARM64: x1 = _cmd)',
                    binary_path: 'Binary to debug'
                },
                'success_indicators': [
                    'Breakpoint hit',
                    'self object displayed',
                    'Method arguments visible'
                ],
                'failure_indicators': [
                    'Method not found',
                    'Binary crashes before breakpoint',
                    'Stripped binary (no symbols)'
                ],
                'next_steps': [
                    'Inspect method arguments: po $x2, po $x3, etc',
                    'Modify return value: reg write $x0 1',
                    'Trace all NSFileManager methods: b -r "\\[NSFileManager .*\\]$"'
                ],
                'alternatives': [
                    '(lldb) breakpoint set -r "\\[NSFileManager .*\\]$"',
                    '(lldb) b -a objc_msgSend # Break on all ObjC calls',
                    'Frida: Interceptor.attach(ObjC.classes.NSFileManager["- fileExistsAtPath:"].implementation)',
                    'dtrace/dtruss for syscall tracing'
                ],
                'notes': 'ARM64: x0=self, x1=_cmd, x2+=args | x86_64: rdi=self, rsi=_cmd, rdx+=args'
            }
        })

        # Task 4.4: Bypass PT_DENY_ATTACH
        dynamic_analysis['children'].append({
            'id': 'bypass-pt-deny-attach',
            'name': 'Bypass PT_DENY_ATTACH Anti-Debug',
            'type': 'manual',
            'metadata': {
                'description': 'Defeat PT_DENY_ATTACH anti-debugging protection',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'Debugger attaches successfully',
                    'No "exited with status = 45 (0x0000002d)" error',
                    'Binary runs under LLDB'
                ],
                'failure_indicators': [
                    'Process exits immediately',
                    'Status 45 error (PT_DENY_ATTACH detected)',
                    'Cannot attach debugger'
                ],
                'next_steps': [
                    'Hook ptrace() with Frida',
                    'Patch ptrace call in binary',
                    'Use kernel debugger (invasive)'
                ],
                'alternatives': [
                    'codesign --remove-signature {binary_path} # Remove signature',
                    'Copy to /tmp and re-sign',
                    'Frida script to hook ptrace: Interceptor.replace(Module.findExportByName(null, "ptrace"), new NativeCallback(...))',
                    'Patch binary: Search for ptrace syscall (B8 1A 00 00 02) and NOP it',
                    'lldb plugin: https://github.com/alexomara/lldb-ptrace-disable'
                ],
                'notes': 'Status 45 = PT_DENY_ATTACH | Blog: https://alexomara.com/blog/defeating-anti-debug-techniques-macos-ptrace-variants/'
            }
        })

        # Task 4.5: DTrace tracing
        dynamic_analysis['children'].append({
            'id': 'dtrace-syscalls',
            'name': 'Trace System Calls (dtrace)',
            'type': 'command',
            'metadata': {
                'command': f'sudo dtrace -n \'syscall:::entry /pid == $target/ {{}}\' -p <PID>',
                'description': 'Trace all system calls made by process',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'sudo': 'Root required for dtrace',
                    'dtrace': 'Dynamic tracing framework',
                    '-n': 'Inline D script',
                    'syscall:::entry': 'Probe on syscall entry',
                    '/pid == $target/': 'Filter for target PID',
                    '-p <PID>': 'Attach to process ID'
                },
                'success_indicators': [
                    'System calls traced',
                    'File operations visible',
                    'Network activity logged'
                ],
                'failure_indicators': [
                    'SIP blocks dtrace',
                    'Operation not permitted',
                    'Invalid probe'
                ],
                'next_steps': [
                    'Filter for file operations: dtrace -n "syscall::open*:entry"',
                    'Log network calls: dtrace -n "syscall::connect:entry"',
                    'Trace specific binary: dtrace -c /path/to/binary'
                ],
                'alternatives': [
                    'dtruss -c ls # Trace ls command',
                    'dtruss -p <PID> # Trace running process',
                    'fs_usage -w -f filesys <binary>',
                    'csrutil enable --without dtrace # Enable dtrace without full SIP disable'
                ],
                'notes': 'Requires SIP weakening: csrutil enable --without dtrace (reboot in Recovery)'
            }
        })

        # Task 4.6: File system activity monitoring
        dynamic_analysis['children'].append({
            'id': 'fs-usage',
            'name': 'Monitor File System Activity',
            'type': 'command',
            'metadata': {
                'command': f'sudo fs_usage -w -f filesys {binary_path}',
                'description': 'Monitor all file system operations of binary',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'sudo': 'Root required',
                    'fs_usage': 'File system usage monitor',
                    '-w': 'Wide output',
                    '-f filesys': 'Filter for filesystem operations',
                    binary_path: 'Process name to monitor'
                },
                'success_indicators': [
                    'File opens/reads/writes logged',
                    'Directory traversal visible',
                    'Real-time monitoring active'
                ],
                'failure_indicators': [
                    'No activity (wrong process name)',
                    'Permission denied'
                ],
                'next_steps': [
                    'Identify config files read',
                    'Monitor for credential storage',
                    'Check for persistence mechanisms (LaunchAgents)'
                ],
                'alternatives': [
                    'sudo fs_usage -w -f network curl # Network operations',
                    'FileMonitor.app (GUI)',
                    'opensnoop # DTrace-based file open monitor',
                    'fswatch /path # Watch directory for changes'
                ],
                'notes': 'Very useful for malware analysis and understanding app behavior'
            }
        })

        # Task 4.7: Network activity monitoring
        dynamic_analysis['children'].append({
            'id': 'network-monitoring',
            'name': 'Monitor Network Activity',
            'type': 'command',
            'metadata': {
                'command': f'sudo fs_usage -w -f network <process_name>',
                'description': 'Monitor network system calls and connections',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    'sudo': 'Root required',
                    'fs_usage': 'System call monitor',
                    '-f network': 'Filter for network operations',
                    '<process_name>': 'Process name (not full path)'
                },
                'success_indicators': [
                    'Connect() calls visible',
                    'DNS queries logged',
                    'Socket operations traced'
                ],
                'failure_indicators': [
                    'No network activity',
                    'Wrong process name'
                ],
                'next_steps': [
                    'Identify C2 servers',
                    'Capture with Wireshark for protocol analysis',
                    'Check for encrypted communications'
                ],
                'alternatives': [
                    'sudo tcpdump -i en0 -A',
                    'sudo nettop -p <PID>',
                    'lsof -i -n -P | grep <process>',
                    'dtrace -n "syscall::connect*:entry"'
                ],
                'notes': 'Combine with packet capture for full network analysis'
            }
        })

        # Task 4.8: Process monitoring
        dynamic_analysis['children'].append({
            'id': 'process-monitor',
            'name': 'Monitor Process Activity (ProcessMonitor)',
            'type': 'manual',
            'metadata': {
                'description': 'Monitor process creation, execution, and termination',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Child processes logged',
                    'Exec calls captured',
                    'Process tree visible'
                ],
                'failure_indicators': [
                    'ProcessMonitor not installed',
                    'No activity detected'
                ],
                'next_steps': [
                    'Identify persistence mechanisms',
                    'Map process injection attempts',
                    'Detect sandbox escapes'
                ],
                'alternatives': [
                    'ProcessMonitor.app (Objective-See)',
                    'sudo eslogger fork exec rename create > events.json',
                    'SpriteTree for visualization',
                    'ps aux | grep <parent_pid>'
                ],
                'notes': 'Download: https://objective-see.com/products/utilities.html#ProcessMonitor'
            }
        })

        # Task 4.9: Unified Logs inspection
        dynamic_analysis['children'].append({
            'id': 'unified-logs',
            'name': 'Inspect Unified Logs',
            'type': 'command',
            'metadata': {
                'command': 'log show --predicate \'process == "{binary_name}"\' --last 1h',
                'description': 'View system logs for application activity',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'flag_explanations': {
                    'log show': 'Display unified logs',
                    '--predicate': 'Filter logs by condition',
                    'process == "name"': 'Filter by process name',
                    '--last 1h': 'Show last hour of logs'
                },
                'success_indicators': [
                    'Log entries displayed',
                    'Error messages visible',
                    'Application behavior logged'
                ],
                'failure_indicators': [
                    'No logs (process not running)',
                    '<private> tags hide data'
                ],
                'next_steps': [
                    'Install log profile to reveal <private> data',
                    'Monitor in real-time: log stream',
                    'Export logs: log show > app_logs.txt'
                ],
                'alternatives': [
                    'log stream --predicate \'process == "app"\' # Real-time',
                    'Console.app (GUI log viewer)',
                    'Install profile: https://superuser.com/questions/1532031/how-to-show-private-data-in-macos-unified-log'
                ],
                'notes': '<private> tags can be revealed with privacy profile installation'
            }
        })

        # Task 4.10: Library preloading (DYLD_INSERT_LIBRARIES)
        dynamic_analysis['children'].append({
            'id': 'dyld-insert-libraries',
            'name': 'Inject Dylib with DYLD_INSERT_LIBRARIES',
            'type': 'manual',
            'metadata': {
                'description': 'Inject custom dynamic library for hooking/instrumentation',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'Dylib loaded into target process',
                    'Constructor function executed',
                    'Hooks active'
                ],
                'failure_indicators': [
                    'Hardened runtime blocks injection',
                    'SIP prevents injection',
                    'com.apple.security.cs.disable-library-validation not present'
                ],
                'next_steps': [
                    'Implement hook functions',
                    'Intercept sensitive APIs',
                    'Log function arguments'
                ],
                'alternatives': [
                    'DYLD_INSERT_LIBRARIES=/path/to/hook.dylib /path/to/target',
                    'DYLD_FORCE_FLAT_NAMESPACE=1 DYLD_INSERT_LIBRARIES=hook.dylib target',
                    'Frida (higher-level alternative)',
                    'Build with: clang -dynamiclib -o hook.dylib hook.c'
                ],
                'notes': 'Only works if target lacks hardened runtime or has disable-library-validation entitlement'
            }
        })

        tasks['children'].append(dynamic_analysis)

        # ========================================
        # PHASE 5: FUZZING
        # ========================================
        fuzzing = {
            'id': 'fuzzing',
            'name': 'Application Fuzzing',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Setup fuzzing environment
        fuzzing['children'].append({
            'id': 'fuzzing-setup',
            'name': 'Fuzzing Environment Setup',
            'type': 'manual',
            'metadata': {
                'description': 'Prepare macOS for stable fuzzing (prevent sleep, ensure SSH persistence)',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Mac will not sleep during fuzzing',
                    'SSH connection persistent',
                    'Crash reporting configured'
                ],
                'failure_indicators': [
                    'Mac sleeps during fuzzing',
                    'SSH disconnects',
                    'Crashes not logged'
                ],
                'next_steps': [
                    'Start fuzzing campaign',
                    'Monitor crash reports',
                    'Triage unique crashes'
                ],
                'alternatives': [
                    'sudo systemsetup -setsleep Never',
                    'pmset -g # Check power settings',
                    'KeepingYouAwake.app # Prevent sleep',
                    'SSH persistence: Edit /etc/ssh/sshd_config: TCPKeepAlive Yes, ClientAliveInterval 0',
                    'sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist'
                ],
                'notes': 'Download KeepingYouAwake: https://github.com/newmarcel/KeepingYouAwake'
            }
        })

        # Task 5.2: Configure crash reporting
        fuzzing['children'].append({
            'id': 'crash-reporting-config',
            'name': 'Configure Crash Reporting',
            'type': 'manual',
            'metadata': {
                'description': 'Enable/disable ReportCrash for fuzzing campaigns',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Crash reports saved to ~/Library/Logs/DiagnosticReports/',
                    'ReportCrash service running (or disabled)',
                    'Crashes logged'
                ],
                'failure_indicators': [
                    'Crash reports not generated',
                    'ReportCrash consuming CPU'
                ],
                'next_steps': [
                    'Monitor crash directory during fuzzing',
                    'Parse crash logs for exploitability',
                    'Deduplicate crashes'
                ],
                'alternatives': [
                    '# Enable crash reporting',
                    'launchctl load -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist',
                    'sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist',
                    '# Disable (reduces overhead)',
                    'launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist',
                    'sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist',
                    '# Check reports',
                    'ls ~/Library/Logs/DiagnosticReports/',
                    'ls /Library/Logs/DiagnosticReports/'
                ],
                'notes': 'Disable for high-speed fuzzing, enable for detailed crash analysis'
            }
        })

        # Task 5.3: AFL++ fuzzing
        fuzzing['children'].append({
            'id': 'afl-fuzzing',
            'name': 'Fuzz with AFL++',
            'type': 'command',
            'metadata': {
                'command': 'afl-fuzz -i inputs/ -o crashes/ -- {binary_path} @@',
                'description': 'Coverage-guided fuzzing for CLI tools',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                'flag_explanations': {
                    'afl-fuzz': 'American Fuzzy Lop++ fuzzer',
                    '-i inputs/': 'Input corpus directory',
                    '-o crashes/': 'Output directory for crashes',
                    '--': 'Separator for target command',
                    '@@': 'Placeholder for input file path',
                    binary_path: 'CLI binary to fuzz'
                },
                'success_indicators': [
                    'Fuzzing campaign starts',
                    'Paths discovered',
                    'Crashes found'
                ],
                'failure_indicators': [
                    'Binary not instrumented',
                    'No corpus provided',
                    'AFL++ not installed'
                ],
                'next_steps': [
                    'Triage crashes in crashes/ directory',
                    'Minimize crashing inputs',
                    'Develop exploit POC'
                ],
                'alternatives': [
                    '# Compile with AFL instrumentation',
                    'afl-clang-fast -o target target.c',
                    '# Minimize corpus',
                    'afl-cmin -i inputs/ -o min_corpus/ -- {binary_path} @@',
                    '# Minimize crashing input',
                    'afl-tmin -i crash.bin -o min_crash.bin -- {binary_path} @@',
                    'libFuzzer (LLVM-based alternative)',
                    'Honggfuzz'
                ],
                'notes': 'Install: brew install afl++ | GitHub: https://github.com/AFLplusplus/AFLplusplus'
            }
        })

        # Task 5.4: Litefuzz for GUI apps
        fuzzing['children'].append({
            'id': 'litefuzz-gui',
            'name': 'Fuzz GUI Apps (Litefuzz)',
            'type': 'command',
            'metadata': {
                'command': 'litefuzz -l -c "/Applications/Target.app/Contents/MacOS/Target FUZZ" -i inputs/ -o crashes/ -x 10 -n 100000 -ez',
                'description': 'Lightweight fuzzer for macOS GUI applications',
                'tags': ['OSCP:HIGH', 'AUTOMATED'],
                'flag_explanations': {
                    'litefuzz': 'macOS GUI app fuzzer',
                    '-l': 'Local mode (not network)',
                    '-c': 'Command line with FUZZ placeholder',
                    '-i': 'Input directory',
                    '-o': 'Output crashes directory',
                    '-x 10': 'Timeout 10 seconds per run',
                    '-n 100000': '100k fuzzing iterations',
                    '-e': 'Second round fuzzing (reuse crashes as seeds)',
                    '-z': 'Enable malloc debug helpers (libgmalloc)'
                },
                'success_indicators': [
                    'Fuzzing iterations running',
                    'Crashes detected and saved',
                    'Coverage increasing'
                ],
                'failure_indicators': [
                    'App crashes immediately on all inputs',
                    'Sandbox blocks file access',
                    'No crashes found'
                ],
                'next_steps': [
                    'Analyze crash logs',
                    'Reproduce crashes manually',
                    'Check exploitability with LLDB'
                ],
                'alternatives': [
                    '# Font Book fuzzing',
                    'litefuzz -l -c "/System/Applications/Font Book.app/Contents/MacOS/Font Book FUZZ" -i fonts/ -o crashes/ -x 2 -n 500000 -ez',
                    '# iBooks fuzzing',
                    'litefuzz -l -c "/System/Applications/Books.app/Contents/MacOS/Books FUZZ" -i epub/ -o crashes/ -t ~/Library/Containers/com.apple.iBooksX/Data/tmp -x 10 -n 100000 -ez',
                    '# Network fuzzing with pcap',
                    'litefuzz -lk -c "smbutil view smb://localhost:4455" -a tcp://localhost:4455 -i smb-resp/ -p -n 100000 -z'
                ],
                'notes': 'Install: https://github.com/sec-tools/litefuzz | Some apps need files in sandbox paths'
            }
        })

        # Task 5.5: Network fuzzing
        fuzzing['children'].append({
            'id': 'network-fuzzing',
            'name': 'Network Protocol Fuzzing',
            'type': 'manual',
            'metadata': {
                'description': 'Fuzz network services using pcap replay',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                'success_indicators': [
                    'Network traffic replayed',
                    'Mutations applied',
                    'Server crashes detected'
                ],
                'failure_indicators': [
                    'Server not listening',
                    'Pcap capture empty',
                    'Connection refused'
                ],
                'next_steps': [
                    'Analyze server crash dumps',
                    'Reverse engineer protocol',
                    'Craft exploit'
                ],
                'alternatives': [
                    '# SMB fuzzing',
                    'litefuzz -lk -c "smbutil view smb://localhost:4455" -a tcp://localhost:4455 -i smb-resp/ -p -n 100000 -z',
                    '# Screen sharing fuzzing',
                    'litefuzz -s -a tcp://localhost:5900 -i vnc-session/ --reportcrash screensharingd -p -n 100000',
                    '# Boofuzz (Python framework)',
                    '# Peach Fuzzer',
                    '# Sulley'
                ],
                'notes': 'Capture baseline protocol with Wireshark, then mutate with fuzzer'
            }
        })

        # Task 5.6: Libgmalloc for memory bugs
        fuzzing['children'].append({
            'id': 'libgmalloc-testing',
            'name': 'Test with libgmalloc (Guard Malloc)',
            'type': 'command',
            'metadata': {
                'command': 'lldb -o "settings set target.env-vars DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib" -o "run arg1 arg2" {binary_path}',
                'description': 'Detect memory corruption with Guard Malloc',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'flag_explanations': {
                    'DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib': 'Load Guard Malloc library',
                    'libgmalloc': 'Guard Malloc - immediately detect buffer overflows',
                    'settings set target.env-vars': 'Set environment variable in LLDB',
                    'run arg1 arg2': 'Run with arguments',
                    binary_path: 'Binary to test'
                },
                'success_indicators': [
                    'Memory errors detected immediately',
                    'Heap corruption caught',
                    'Crash with detailed backtrace'
                ],
                'failure_indicators': [
                    'Performance too slow',
                    'False positives',
                    'Binary incompatible'
                ],
                'next_steps': [
                    'Analyze crash backtrace',
                    'Identify memory corruption root cause',
                    'Develop exploit primitive'
                ],
                'alternatives': [
                    'export DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib && ./target',
                    'Address Sanitizer (ASan): clang -fsanitize=address',
                    'Valgrind (not macOS native)',
                    'MallocScribble=1 ./target'
                ],
                'notes': 'libgmalloc creates guard pages around allocations - crashes on overflow'
            }
        })

        tasks['children'].append(fuzzing)

        # ========================================
        # PHASE 6: ANTI-ANALYSIS TECHNIQUES
        # ========================================
        anti_analysis = {
            'id': 'anti-analysis',
            'name': 'Anti-Analysis Detection & Bypass',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: VM detection
        anti_analysis['children'].append({
            'id': 'vm-detection',
            'name': 'Detect VM/Sandbox Environment',
            'type': 'manual',
            'metadata': {
                'description': 'Identify if malware detects virtual machine or sandbox',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH'],
                'success_indicators': [
                    'VM detection logic found',
                    'Anti-debugging checks identified',
                    'Evasion techniques mapped'
                ],
                'failure_indicators': [
                    'No VM checks present',
                    'Binary runs normally in VM'
                ],
                'next_steps': [
                    'Patch VM detection checks',
                    'Spoof hardware identifiers',
                    'Use bare metal for analysis'
                ],
                'alternatives': [
                    '# Check for VM detection methods',
                    'sysctl hw.model # Returns "Mac" on real Mac, not on VM',
                    'sysctl hw.logicalcpu # CPU count check',
                    'sysctl hw.physicalcpu # Physical CPU check',
                    'ifconfig | grep 00:50:56 # VMware MAC address',
                    '# Search binary for strings',
                    'strings {binary_path} | grep -i vmware',
                    'strings {binary_path} | grep -i parallels',
                    'strings {binary_path} | grep sysctl'
                ],
                'notes': 'Common VM detection: sysctl hw.model, MAC address checks, CPU counts'
            }
        })

        # Task 6.2: Debug detection
        anti_analysis['children'].append({
            'id': 'debug-detection',
            'name': 'Identify Debugger Detection',
            'type': 'manual',
            'metadata': {
                'description': 'Find anti-debugging checks in binary',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'ptrace(PT_DENY_ATTACH) found',
                    'P_TRACED flag check identified',
                    'Debugger detection logic mapped'
                ],
                'failure_indicators': [
                    'No anti-debug checks',
                    'Binary debuggable'
                ],
                'next_steps': [
                    'Patch ptrace call',
                    'Hook sysctl to hide debugger',
                    'Use kernel debugger'
                ],
                'alternatives': [
                    '# Search for ptrace import',
                    'nm {binary_path} | grep ptrace',
                    'otool -L {binary_path} | grep ptrace',
                    '# Search for sysctl checks',
                    'strings {binary_path} | grep P_TRACED',
                    '# Check for status 45 exit',
                    'lldb {binary_path} # If exits with status=45 -> PT_DENY_ATTACH',
                    '# Disassemble and search for ptrace syscall',
                    'objdump -d {binary_path} | grep ptrace'
                ],
                'notes': 'Exit status 45 (0x2d) = PT_DENY_ATTACH detected | if(P_TRACED == (info.kp_proc.p_flag & P_TRACED))'
            }
        })

        # Task 6.3: String obfuscation bypass
        anti_analysis['children'].append({
            'id': 'string-deobfuscation',
            'name': 'Extract Obfuscated Strings',
            'type': 'manual',
            'metadata': {
                'description': 'Recover encrypted/obfuscated strings from binary',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Strings decryption routine identified',
                    'Obfuscated strings recovered',
                    'API names revealed'
                ],
                'failure_indicators': [
                    'No obfuscation detected',
                    'Strings in plaintext'
                ],
                'next_steps': [
                    'Hook string decryption function',
                    'Dump strings at runtime',
                    'Rebuild string table'
                ],
                'alternatives': [
                    '# Runtime string extraction with LLDB',
                    'lldb {binary_path}',
                    '(lldb) b <string_decrypt_function>',
                    '(lldb) r',
                    '(lldb) x/s $rax # Dump decrypted string',
                    '# Frida script to hook string decryption',
                    'Interceptor.attach(Module.findExportByName(null, "decrypt_string"), { onLeave(retval) { console.log(retval.readUtf8String()); } });',
                    '# Static XOR decryption',
                    'python3 xor_decrypt.py {binary_path}'
                ],
                'notes': 'Common obfuscation: XOR, RC4, AES, stack strings, encrypted sections'
            }
        })

        tasks['children'].append(anti_analysis)

        # ========================================
        # PHASE 7: ADVANCED TOOLS
        # ========================================
        advanced_tools = {
            'id': 'advanced-tools',
            'name': 'Advanced Analysis Tools',
            'type': 'parent',
            'children': []
        }

        # Task 7.1: Hopper Disassembler
        advanced_tools['children'].append({
            'id': 'hopper-analysis',
            'name': 'Analyze with Hopper Disassembler',
            'type': 'manual',
            'metadata': {
                'description': 'Use Hopper for advanced static analysis and decompilation',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Binary loaded in Hopper',
                    'Control flow graph visible',
                    'Pseudocode decompiled'
                ],
                'failure_indicators': [
                    'Hopper not installed',
                    'Demo version limitations',
                    'Stripped binary (no symbols)'
                ],
                'next_steps': [
                    'Navigate using Labels/Procedures/Strings panels',
                    'Rename functions for clarity',
                    'Export decompiled code'
                ],
                'alternatives': [
                    'Hopper Disassembler (https://www.hopperapp.com/)',
                    'IDA Pro/Free',
                    'Ghidra (free, NSA)',
                    'Binary Ninja',
                    'Radare2/Cutter'
                ],
                'notes': 'Hopper strengths: Native macOS support, Obj-C awareness, decompiler'
            }
        })

        # Task 7.2: Frida instrumentation
        advanced_tools['children'].append({
            'id': 'frida-instrumentation',
            'name': 'Dynamic Instrumentation (Frida)',
            'type': 'manual',
            'metadata': {
                'description': 'Hook and modify running application with Frida',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'Frida attached to process',
                    'Hooks active',
                    'Function calls intercepted'
                ],
                'failure_indicators': [
                    'Frida detection triggers',
                    'Anti-debugging kills process',
                    'SIP blocks injection'
                ],
                'next_steps': [
                    'Enumerate classes: ObjC.classes',
                    'Hook methods: Interceptor.attach()',
                    'Modify return values'
                ],
                'alternatives': [
                    '# Attach to process',
                    'frida -p <PID> -l hook.js',
                    'frida <process_name> -l hook.js',
                    '# Example hook',
                    'Interceptor.attach(Module.findExportByName(null, "open"), { onEnter(args) { console.log("open:", args[0].readUtf8String()); } });',
                    '# Objective-C method hook',
                    'Interceptor.attach(ObjC.classes.NSFileManager["- fileExistsAtPath:"].implementation, { onEnter(args) { console.log("Path:", ObjC.Object(args[2])); } });',
                    'LLDB scripting',
                    'Cycript (deprecated)'
                ],
                'notes': 'Install: pip3 install frida-tools | Website: https://frida.re'
            }
        })

        # Task 7.3: TaskExplorer
        advanced_tools['children'].append({
            'id': 'task-explorer',
            'name': 'Inspect with TaskExplorer',
            'type': 'manual',
            'metadata': {
                'description': 'View running processes, libraries, files, and network connections',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Process libraries listed',
                    'Network connections visible',
                    'Files in use displayed',
                    'VirusTotal results shown'
                ],
                'failure_indicators': [
                    'TaskExplorer not installed',
                    'No process information'
                ],
                'next_steps': [
                    'Identify suspicious libraries',
                    'Monitor network activity',
                    'Check VirusTotal reputation'
                ],
                'alternatives': [
                    'TaskExplorer.app (Objective-See)',
                    'Activity Monitor.app (built-in)',
                    'lsof -p <PID> # CLI alternative',
                    'vmmap <PID> # Memory map',
                    'netstat -anp | grep <PID>'
                ],
                'notes': 'Download: https://objective-see.com/products/taskexplorer.html'
            }
        })

        # Task 7.4: Crescendo
        advanced_tools['children'].append({
            'id': 'crescendo',
            'name': 'System Activity Monitor (Crescendo)',
            'type': 'manual',
            'metadata': {
                'description': 'Record and filter system events (file, process, network)',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Events recording',
                    'Filters applied',
                    'JSON export generated'
                ],
                'failure_indicators': [
                    'Crescendo not installed',
                    'No events captured'
                ],
                'next_steps': [
                    'Filter by file operations',
                    'Export to JSON for analysis',
                    'Correlate with other tools'
                ],
                'alternatives': [
                    'Crescendo (https://github.com/SuprHackerSteve/Crescendo)',
                    'ProcessMonitor.app',
                    'FileMonitor.app',
                    'eslogger (ES framework CLI)',
                    'sudo eslogger fork exec rename create > events.json'
                ],
                'notes': 'GUI similar to Windows Procmon - very useful for endpoint detection'
            }
        })

        tasks['children'].append(advanced_tools)

        # ========================================
        # PHASE 8: EXPLOIT DEVELOPMENT
        # ========================================
        exploit_dev = {
            'id': 'exploit-development',
            'name': 'Exploit Development',
            'type': 'parent',
            'children': []
        }

        # Task 8.1: Core dumps analysis
        exploit_dev['children'].append({
            'id': 'core-dump-analysis',
            'name': 'Analyze Core Dumps',
            'type': 'manual',
            'metadata': {
                'description': 'Extract crash information from core dumps',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'success_indicators': [
                    'Core dump generated in /cores/',
                    'Crash state preserved',
                    'Registers and backtrace available'
                ],
                'failure_indicators': [
                    'kern.coredump=0 (disabled)',
                    'AS_CORE limit = 0 (ulimit -c 0)',
                    'No core dump generated'
                ],
                'next_steps': [
                    'Load core dump in LLDB',
                    'Inspect crash state',
                    'Determine exploitability'
                ],
                'alternatives': [
                    '# Enable core dumps',
                    'sudo sysctl kern.coredump=1',
                    'ulimit -c unlimited',
                    '# Check settings',
                    'sysctl kern.coredump',
                    'sysctl kern.corefile',
                    'ulimit -c',
                    '# Load in LLDB',
                    'lldb -c /cores/core.12345',
                    '(lldb) bt # Backtrace',
                    '(lldb) reg read # Registers',
                    '# Save core dump manually in LLDB',
                    '(lldb) process save-core /tmp/core'
                ],
                'notes': 'Core dumps: /cores/core.<PID> | Disabled for suid/sgid by default'
            }
        })

        # Task 8.2: Exploitability assessment
        exploit_dev['children'].append({
            'id': 'exploitability-assessment',
            'name': 'Assess Crash Exploitability',
            'type': 'manual',
            'metadata': {
                'description': 'Determine if crash is exploitable for code execution',
                'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH'],
                'success_indicators': [
                    'PC/IP control achieved',
                    'Memory corruption confirmed',
                    'Exploitation path identified'
                ],
                'failure_indicators': [
                    'Null pointer dereference (likely DoS only)',
                    'Assertion failure (non-exploitable)',
                    'No control over crash'
                ],
                'next_steps': [
                    'Develop exploit primitive',
                    'Bypass ASLR/DEP',
                    'Chain ROP gadgets (if needed)'
                ],
                'alternatives': [
                    '# Check crash type',
                    'EXC_BAD_ACCESS (SIGSEGV) - memory corruption',
                    'EXC_BAD_INSTRUCTION (SIGILL) - code corruption',
                    'EXC_ARITHMETIC (SIGFPE) - integer issue',
                    '# Exploitability heuristics',
                    '- PC/RIP control = HIGH',
                    '- Heap corruption = MEDIUM',
                    '- Stack overflow = HIGH',
                    '- NULL deref = LOW (DoS)',
                    '- Use-after-free = HIGH',
                    '# Tools',
                    '!exploitable (Windows - no macOS port)',
                    'Manual analysis with LLDB/GDB'
                ],
                'notes': 'Focus on: PC control, heap metadata corruption, vtable overwrites'
            }
        })

        # Task 8.3: ROP gadget search
        exploit_dev['children'].append({
            'id': 'rop-gadget-search',
            'name': 'Find ROP Gadgets',
            'type': 'manual',
            'metadata': {
                'description': 'Locate ROP gadgets for exploit chains',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'success_indicators': [
                    'Gadgets found',
                    'Exploit chain possible',
                    'DEP bypass achieved'
                ],
                'failure_indicators': [
                    'No useful gadgets',
                    'ASLR prevents reliable exploit',
                    'Insufficient control'
                ],
                'next_steps': [
                    'Chain gadgets into exploit',
                    'Leak addresses to defeat ASLR',
                    'Test exploit reliability'
                ],
                'alternatives': [
                    '# ROPgadget',
                    'ROPgadget --binary {binary_path}',
                    'ROPgadget --binary {binary_path} --ropchain',
                    '# Ropper',
                    'ropper --file {binary_path} --search "pop rdi"',
                    '# Manual with objdump',
                    'objdump -d {binary_path} | grep -B2 "ret"',
                    '# radare2',
                    'r2 {binary_path}',
                    '/R pop rdi'
                ],
                'notes': 'Install: pip3 install ropgadget ropper | macOS: Often fewer gadgets than Linux'
            }
        })

        tasks['children'].append(exploit_dev)

        return tasks
