"""
Android Application Pentesting Plugin

Comprehensive Android security testing workflow including:
- APK extraction and analysis
- Static analysis (decompilation, manifest review, code inspection)
- Dynamic analysis (Frida, Drozer, runtime instrumentation)
- Component exploitation (Activities, Services, Broadcast Receivers, Content Providers)
- WebView attacks and JavaScript bridge exploitation
- SSL pinning bypass
- Root detection bypass
- Biometric authentication bypass
- Intent injection and deep link exploitation
- Native library analysis
- Automated security scanning

Extracted from HackTricks Android Pentesting Guide
Generated by: CrackPot v1.0
Source: mobile-pentesting/android-app-pentesting/
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class AndroidPentestingPlugin(ServicePlugin):
    """Android application security testing plugin"""

    @property
    def name(self) -> str:
        return "android-app"

    @property
    def default_ports(self) -> List[int]:
        return [5555]  # ADB default port

    @property
    def service_names(self) -> List[str]:
        return ['android', 'adb', 'android-debug-bridge']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Android/ADB services or trigger manually for APK analysis"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common ADB port
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Android application pentesting task tree"""

        tasks = {
            'id': f'android-pentest-{port}',
            'name': f'Android Application Pentesting',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: ADB CONNECTION & SETUP
        tasks['children'].append({
            'id': f'adb-connection-{port}',
            'name': 'ADB Connection & Device Setup',
            'type': 'parent',
            'children': [
                {
                    'id': f'adb-connect-{port}',
                    'name': 'Connect via ADB',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb connect {target}:{port}',
                        'description': 'Connect to Android device over network',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'connect': 'Connect to device via IP:PORT',
                            f'{target}:{port}': 'Target device address'
                        },
                        'success_indicators': [
                            'connected to {target}:{port}',
                            'Device appears in adb devices'
                        ],
                        'failure_indicators': [
                            'failed to connect',
                            'Connection refused',
                            'unauthorized (device not accepted)'
                        ],
                        'next_steps': [
                            'List connected devices: adb devices',
                            'Get shell access: adb shell',
                            'Check if device is rooted'
                        ],
                        'alternatives': [
                            f'adb tcpip 5555 (on device first)',
                            'USB connection: plug device and enable USB debugging'
                        ],
                        'notes': 'If "unauthorized" appears, unlock device and accept connection prompt'
                    }
                },
                {
                    'id': f'adb-devices-list-{port}',
                    'name': 'List Connected Devices',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb devices',
                        'description': 'List all connected Android devices',
                        'tags': ['QUICK_WIN', 'MANUAL'],
                        'success_indicators': ['List of devices attached', 'device status shown'],
                        'alternatives': ['adb -s DEVICE_ID shell (to target specific device)']
                    }
                },
                {
                    'id': f'adb-root-{port}',
                    'name': 'Attempt Root Access',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb root',
                        'description': 'Restart ADB daemon with root permissions',
                        'tags': ['OSCP:HIGH', 'PRIVESC'],
                        'flag_explanations': {
                            'root': 'Restart adbd daemon with root permissions (if available)'
                        },
                        'success_indicators': [
                            'restarting adbd as root',
                            'Root access granted'
                        ],
                        'failure_indicators': [
                            'adbd cannot run as root in production builds',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Reconnect: adb connect {target}:{port}',
                            'Verify root: adb shell whoami',
                            'Install Magisk/SuperSU if not rooted'
                        ],
                        'alternatives': [
                            'Root device manually with Magisk',
                            'Use custom ROM (LineageOS, OmniROM)',
                            'Exploit device-specific vulnerability'
                        ],
                        'notes': 'Root access greatly expands testing capabilities (Frida, file access, etc.)'
                    }
                },
                {
                    'id': f'adb-shell-{port}',
                    'name': 'Get Interactive Shell',
                    'type': 'command',
                    'metadata': {
                        'command': f'adb -s {target}:{port} shell',
                        'description': 'Get interactive shell on Android device',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-s': 'Specify device (use with multiple devices)',
                            'shell': 'Start interactive shell on device'
                        },
                        'success_indicators': ['Shell prompt appears', 'Can execute commands'],
                        'next_steps': [
                            'Check user: whoami',
                            'List apps: pm list packages',
                            'Check file system: ls /data/data/'
                        ],
                        'alternatives': ['adb shell <command> (non-interactive)'],
                        'notes': 'Root shell provides full system access'
                    }
                }
            ]
        })

        # PHASE 2: APK EXTRACTION & RECONNAISSANCE
        tasks['children'].append({
            'id': f'apk-extraction-{port}',
            'name': 'APK Extraction & Package Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': f'list-packages-{port}',
                    'name': 'List Installed Packages',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell pm list packages',
                        'description': 'List all installed applications on device',
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            'pm': 'Package manager',
                            'list packages': 'Display all installed packages'
                        },
                        'success_indicators': ['Package list displayed'],
                        'next_steps': [
                            'Filter third-party apps: pm list packages -3',
                            'Get package path: pm path <package>',
                            'Extract APK: adb pull <path>'
                        ],
                        'alternatives': [
                            'adb shell pm list packages -3 (third-party only)',
                            'adb shell pm list packages -s (system apps)',
                            'adb shell pm list packages -f (show APK paths)'
                        ],
                        'notes': 'Focus on third-party apps (-3 flag) for pentesting'
                    }
                },
                {
                    'id': f'filter-target-app-{port}',
                    'name': 'Find Target Application',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell pm list packages -f | grep -i <app_name>',
                        'description': 'Locate target application by name',
                        'tags': ['ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-f': 'Show APK file path',
                            'grep -i': 'Case-insensitive search for app name'
                        },
                        'success_indicators': ['Package name and path found'],
                        'next_steps': ['Get package details: pm dump <package>'],
                        'alternatives': ['adb shell pm list packages | grep <keyword>']
                    }
                },
                {
                    'id': f'get-package-path-{port}',
                    'name': 'Get APK File Path',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell pm path <package_name>',
                        'description': 'Get full path to APK file on device',
                        'tags': ['ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            'pm path': 'Print path to APK of given package'
                        },
                        'success_indicators': ['package:/data/app/...'],
                        'next_steps': ['Pull APK: adb pull <path>'],
                        'alternatives': ['pm list packages -f (shows all with paths)'],
                        'example': 'adb shell pm path com.example.app'
                    }
                },
                {
                    'id': f'pull-apk-{port}',
                    'name': 'Extract APK from Device',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb pull /data/app/<package>/base.apk ./app.apk',
                        'description': 'Download APK file from device to local machine',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'pull': 'Download file from device',
                            'source': 'APK path on device',
                            'destination': 'Local save location'
                        },
                        'success_indicators': ['File transferred successfully', 'APK file created locally'],
                        'failure_indicators': ['Permission denied', 'File not found'],
                        'next_steps': [
                            'Verify APK: file app.apk',
                            'Decompile with jadx',
                            'Analyze with MobSF'
                        ],
                        'alternatives': [
                            'Full extraction script with splits merging',
                            'Use APK downloader websites (APKPure, APKMirror)'
                        ],
                        'notes': 'Some apps use split APKs - need to merge with APKEditor'
                    }
                },
                {
                    'id': f'merge-split-apks-{port}',
                    'name': 'Merge Split APKs',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Merge split APK files into single APK',
                        'tags': ['MANUAL'],
                        'steps': [
                            'Create directory: mkdir splits',
                            'Pull all splits: adb shell pm path <package> | cut -d ":" -f 2 | xargs -n1 -i adb pull {} splits',
                            'Merge: java -jar APKEditor.jar m -i splits/ -o merged.apk',
                            'Sign: java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed'
                        ],
                        'notes': 'Required for apps with multiple APK splits (common in modern apps)',
                        'tools': ['APKEditor', 'uber-apk-signer']
                    }
                },
                {
                    'id': f'package-info-{port}',
                    'name': 'Get Package Information',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell dumpsys package <package_name>',
                        'description': 'Get detailed package information (permissions, components, etc.)',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'dumpsys': 'Dump system services information',
                            'package': 'Package manager service'
                        },
                        'success_indicators': ['Package details displayed', 'Permissions listed'],
                        'next_steps': [
                            'Identify exported components',
                            'Check dangerous permissions',
                            'Analyze attack surface'
                        ],
                        'alternatives': ['Drozer: run app.package.info -a <package>']
                    }
                }
            ]
        })

        # PHASE 3: STATIC ANALYSIS
        tasks['children'].append({
            'id': f'static-analysis-{port}',
            'name': 'Static Analysis (Decompilation & Code Review)',
            'type': 'parent',
            'children': [
                {
                    'id': f'jadx-decompile-{port}',
                    'name': 'Decompile APK with JADX',
                    'type': 'command',
                    'metadata': {
                        'command': 'jadx -d output_dir app.apk',
                        'description': 'Decompile APK to Java source code',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'flag_explanations': {
                            '-d': 'Output directory for decompiled code',
                            'app.apk': 'Target APK file'
                        },
                        'success_indicators': ['Decompilation complete', 'Java files created'],
                        'next_steps': [
                            'Review AndroidManifest.xml',
                            'Search for hardcoded secrets',
                            'Analyze exported components'
                        ],
                        'alternatives': [
                            'jadx-gui (GUI version)',
                            'apktool d app.apk (smali only)',
                            'JD-Gui, Bytecode-Viewer, CFR'
                        ],
                        'notes': 'JADX produces readable Java code (best for initial review)'
                    }
                },
                {
                    'id': f'apktool-decompile-{port}',
                    'name': 'Decompile with Apktool (Smali)',
                    'type': 'command',
                    'metadata': {
                        'command': 'apktool d app.apk -o app_decompiled',
                        'description': 'Decompile APK to Smali bytecode (for patching)',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'd': 'Decompile/decode APK',
                            '-o': 'Output directory'
                        },
                        'success_indicators': ['Smali files created', 'Resources extracted'],
                        'next_steps': [
                            'Modify smali code if needed',
                            'Rebuild: apktool b app_decompiled',
                            'Sign modified APK'
                        ],
                        'alternatives': ['baksmali (pure smali decompilation)'],
                        'notes': 'Use for code modification/patching, not readability'
                    }
                },
                {
                    'id': f'manifest-analysis-{port}',
                    'name': 'Analyze AndroidManifest.xml',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review manifest for security vulnerabilities',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'checks': [
                            'android:debuggable="true" (allows debugging)',
                            'android:allowBackup="true" (data backup risk)',
                            'Exported components (activities, services, receivers, providers)',
                            'Dangerous permissions (WRITE_EXTERNAL_STORAGE, etc.)',
                            'Custom permissions defined',
                            'android:networkSecurityConfig (SSL pinning)',
                            'minSdkVersion (outdated Android versions)',
                            'Deep links / URL schemes'
                        ],
                        'success_indicators': ['Vulnerabilities identified'],
                        'next_steps': [
                            'Test exported components',
                            'Exploit debuggable app',
                            'Test deep links for injection'
                        ],
                        'notes': 'Manifest is primary attack surface indicator'
                    }
                },
                {
                    'id': f'strings-analysis-{port}',
                    'name': 'Extract and Analyze Strings',
                    'type': 'command',
                    'metadata': {
                        'command': 'strings app.apk | grep -E "(http|api|key|token|password|secret)"',
                        'description': 'Search for sensitive strings in APK',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'strings': 'Extract printable strings from binary',
                            'grep -E': 'Search for sensitive patterns'
                        },
                        'success_indicators': [
                            'API keys found',
                            'URLs discovered',
                            'Hardcoded credentials'
                        ],
                        'next_steps': [
                            'Test discovered URLs',
                            'Try API keys',
                            'Check Firebase misconfiguration'
                        ],
                        'alternatives': [
                            'apkleaks (automated secret scanner)',
                            'grep -r "password" decompiled_code/'
                        ],
                        'notes': 'Look for API keys, tokens, URLs, Firebase URLs'
                    }
                },
                {
                    'id': f'apkleaks-scan-{port}',
                    'name': 'Automated Secret Scanning',
                    'type': 'command',
                    'metadata': {
                        'command': 'apkleaks -f app.apk -o secrets.txt',
                        'description': 'Automatically scan for leaked secrets in APK',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-f': 'Input APK file',
                            '-o': 'Output file for findings'
                        },
                        'success_indicators': ['Secrets found', 'Report generated'],
                        'tools': ['apkleaks (pip install apkleaks)'],
                        'alternatives': ['Manual: grep -r "api" decompiled/'],
                        'notes': 'Checks for API keys, tokens, URLs, subdomains, etc.'
                    }
                },
                {
                    'id': f'firebase-check-{port}',
                    'name': 'Check Firebase Misconfiguration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test Firebase database for public access',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'steps': [
                            'Extract Firebase URL from strings',
                            'Try accessing: https://<project>.firebaseio.com/.json',
                            'If accessible without auth = misconfigured',
                            'Read/write data to test permissions'
                        ],
                        'success_indicators': ['Database accessible without auth'],
                        'notes': 'Common critical vulnerability in Android apps'
                    }
                },
                {
                    'id': f'native-libraries-{port}',
                    'name': 'Analyze Native Libraries',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review native (.so) libraries in lib/ directory',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'steps': [
                            'Extract lib/ folder from APK',
                            'Identify architecture (armeabi, arm64, x86)',
                            'Use Ghidra/IDA Pro to reverse .so files',
                            'Look for JNI functions (Java_<package>_<class>_<method>)',
                            'Search for hardcoded secrets in native code'
                        ],
                        'tools': ['Ghidra', 'IDA Pro', 'radare2', 'strings'],
                        'notes': 'Native code often contains crypto keys and sensitive logic'
                    }
                },
                {
                    'id': f'mobsf-static-{port}',
                    'name': 'Automated Static Analysis (MobSF)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Run comprehensive static analysis with MobSF',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'steps': [
                            'Start MobSF: docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf',
                            'Upload APK via web interface (http://localhost:8000)',
                            'Review static analysis results',
                            'Check OWASP Mobile Top 10 findings',
                            'Export report'
                        ],
                        'success_indicators': ['Vulnerabilities identified', 'Risk rating provided'],
                        'alternatives': ['QARK', 'AndroBugs', 'SUPER Analyzer'],
                        'notes': 'MobSF provides comprehensive automated scanning'
                    }
                }
            ]
        })

        # PHASE 4: DYNAMIC ANALYSIS SETUP
        tasks['children'].append({
            'id': f'dynamic-setup-{port}',
            'name': 'Dynamic Analysis Setup',
            'type': 'parent',
            'children': [
                {
                    'id': f'install-apk-{port}',
                    'name': 'Install APK on Device',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb install app.apk',
                        'description': 'Install APK on connected Android device',
                        'tags': ['MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'install': 'Install APK on device',
                            '-r': 'Replace existing application (adb install -r)'
                        },
                        'success_indicators': ['Success message', 'App appears on device'],
                        'failure_indicators': [
                            'INSTALL_FAILED_ALREADY_EXISTS',
                            'INSTALL_FAILED_SIGNATURE_CONFLICT'
                        ],
                        'alternatives': [
                            'adb install -r app.apk (replace existing)',
                            'adb install -t app.apk (allow test APKs)',
                            'Manual: transfer APK and install via file manager'
                        ]
                    }
                },
                {
                    'id': f'burp-cert-install-{port}',
                    'name': 'Install Burp CA Certificate',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Install Burp Suite certificate for HTTPS interception',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'steps': [
                            'Export Burp cert: Proxy > Options > Export CA Certificate (DER)',
                            'Convert to Android format: openssl x509 -inform DER -in cacert.der -out cacert.pem',
                            'Get hash: openssl x509 -inform PEM -subject_hash_old -in cacert.pem',
                            'Rename: mv cacert.pem <hash>.0',
                            'Push to device: adb push <hash>.0 /system/etc/security/cacerts/',
                            'Set permissions: adb shell chmod 644 /system/etc/security/cacerts/<hash>.0',
                            'Reboot device'
                        ],
                        'success_indicators': ['Certificate installed', 'HTTPS traffic visible in Burp'],
                        'failure_indicators': [
                            'Certificate not trusted',
                            'SSL errors in app'
                        ],
                        'alternatives': [
                            'For Android 7+: Modify network security config',
                            'Use apk-mitm to patch APK'
                        ],
                        'notes': 'Android 7+ requires additional steps or APK modification'
                    }
                },
                {
                    'id': f'proxy-setup-{port}',
                    'name': 'Configure Proxy Settings',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Set up HTTP proxy for traffic interception',
                        'tags': ['MANUAL', 'QUICK_WIN'],
                        'steps': [
                            'Start Burp Suite listener (default: 8080)',
                            'Get host IP: ifconfig',
                            'On Android: Settings > Wi-Fi > Long press network > Modify',
                            'Set Proxy: Manual',
                            'Host: <your_IP>, Port: 8080',
                            'Save and reconnect'
                        ],
                        'success_indicators': ['Traffic appears in Burp HTTP history'],
                        'alternatives': [
                            'Command line: adb shell settings put global http_proxy <IP>:8080',
                            'Use iptables forwarding'
                        ],
                        'notes': 'Remember to disable proxy after testing'
                    }
                },
                {
                    'id': f'frida-server-install-{port}',
                    'name': 'Install Frida Server',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb root && adb push frida-server /data/local/tmp/ && adb shell "chmod 755 /data/local/tmp/frida-server" && adb shell "/data/local/tmp/frida-server &"',
                        'description': 'Install and run Frida server for dynamic instrumentation',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'flag_explanations': {
                            'push': 'Upload frida-server binary to device',
                            'chmod 755': 'Make frida-server executable',
                            '&': 'Run in background'
                        },
                        'success_indicators': [
                            'frida-server running',
                            'frida-ps -U works from host'
                        ],
                        'failure_indicators': [
                            'Permission denied (need root)',
                            'Architecture mismatch'
                        ],
                        'next_steps': [
                            'Verify: frida-ps -U',
                            'List processes: frida-ps -Uai',
                            'Attach to app: frida -U -n <package>'
                        ],
                        'alternatives': [
                            'Frida Gadget (no-root method - embed in APK)',
                            'Use Magisk to inject frida-server at boot'
                        ],
                        'notes': 'Download correct architecture from github.com/frida/frida/releases'
                    }
                },
                {
                    'id': f'frida-verify-{port}',
                    'name': 'Verify Frida Installation',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida-ps -U',
                        'description': 'List running processes via Frida',
                        'tags': ['QUICK_WIN'],
                        'flag_explanations': {
                            '-U': 'Connect to USB device',
                            'frida-ps': 'List processes'
                        },
                        'success_indicators': ['Process list displayed'],
                        'alternatives': ['frida-ps -Uai (show applications only)']
                    }
                },
                {
                    'id': f'drozer-install-{port}',
                    'name': 'Install Drozer Agent',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb install drozer-agent.apk',
                        'description': 'Install Drozer agent for component exploitation',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'success_indicators': ['Drozer agent installed'],
                        'next_steps': [
                            'Start Drozer agent on device',
                            'Enable server (toggle to ON)',
                            'Forward port: adb forward tcp:31415 tcp:31415',
                            'Connect: drozer console connect'
                        ],
                        'alternatives': ['Manual component testing with adb commands'],
                        'notes': 'Download from github.com/mwrlabs/drozer/releases'
                    }
                },
                {
                    'id': f'drozer-connect-{port}',
                    'name': 'Connect to Drozer',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb forward tcp:31415 tcp:31415 && drozer console connect',
                        'description': 'Establish Drozer console connection',
                        'tags': ['MANUAL'],
                        'success_indicators': ['Drozer console prompt appears'],
                        'next_steps': [
                            'List packages: run app.package.list',
                            'Check attack surface: run app.package.attacksurface <package>'
                        ]
                    }
                }
            ]
        })

        # PHASE 5: COMPONENT EXPLOITATION
        tasks['children'].append({
            'id': f'component-exploit-{port}',
            'name': 'Component Exploitation (Drozer)',
            'type': 'parent',
            'children': [
                {
                    'id': f'attack-surface-{port}',
                    'name': 'Identify Attack Surface',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.package.attacksurface <package_name>',
                        'description': 'Identify exported components and debuggable status',
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'success_indicators': [
                            'Exported activities found',
                            'Exported content providers',
                            'Exported services',
                            'is debuggable'
                        ],
                        'next_steps': [
                            'Test exported activities',
                            'Enumerate content providers',
                            'Exploit exported services'
                        ],
                        'notes': 'Drozer command - use inside drozer console'
                    }
                },
                {
                    'id': f'enum-activities-{port}',
                    'name': 'Enumerate Exported Activities',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.activity.info -a <package_name>',
                        'description': 'List all exported activities',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'success_indicators': ['Activity list displayed'],
                        'next_steps': ['Start activities: run app.activity.start --component <package> <activity>'],
                        'notes': 'Exported activities can be called by any app'
                    }
                },
                {
                    'id': f'start-activity-{port}',
                    'name': 'Start Exported Activity',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.activity.start --component <package> <activity>',
                        'description': 'Launch exported activity (bypass authentication)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'success_indicators': ['Activity launched', 'Authentication bypassed'],
                        'alternatives': [
                            'ADB: adb shell am start -n <package>/<activity>',
                            'Intent injection via deep link'
                        ],
                        'notes': 'Common auth bypass if sensitive activities are exported'
                    }
                },
                {
                    'id': f'enum-providers-{port}',
                    'name': 'Enumerate Content Providers',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.provider.info -a <package_name>',
                        'description': 'List exported content providers',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'success_indicators': ['Provider URIs listed'],
                        'next_steps': [
                            'Query provider: run app.provider.query <URI>',
                            'Test SQL injection',
                            'Test path traversal'
                        ]
                    }
                },
                {
                    'id': f'query-provider-{port}',
                    'name': 'Query Content Provider',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.provider.query <URI>',
                        'description': 'Extract data from content provider',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'success_indicators': ['Data extracted', 'Sensitive information leaked'],
                        'next_steps': [
                            'Test SQLi: run app.provider.query <URI> --selection "1=1"',
                            'Path traversal: content://.../../../etc/passwd'
                        ],
                        'notes': 'Content providers often expose database data'
                    }
                },
                {
                    'id': f'sqli-provider-{port}',
                    'name': 'Test SQL Injection in Provider',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.provider.query <URI> --projection "* FROM SQLITE_MASTER WHERE type=\'table\';--"',
                        'description': 'Test for SQL injection in content provider',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'success_indicators': ['SQL error', 'Table names leaked', 'Injection successful'],
                        'alternatives': [
                            'Manual: adb shell content query --uri <URI> --projection "<payload>"',
                            'Use --selection parameter'
                        ],
                        'notes': 'Try different SQLi payloads (union, blind, time-based)'
                    }
                },
                {
                    'id': f'enum-services-{port}',
                    'name': 'Enumerate Exported Services',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.service.info -a <package_name>',
                        'description': 'List exported services',
                        'tags': ['ENUM'],
                        'success_indicators': ['Service list displayed'],
                        'next_steps': [
                            'Start service: run app.service.start --component <package> <service>',
                            'Send data: run app.service.send <package> <service> <data>'
                        ]
                    }
                },
                {
                    'id': f'enum-receivers-{port}',
                    'name': 'Enumerate Broadcast Receivers',
                    'type': 'command',
                    'metadata': {
                        'command': 'run app.broadcast.info -a <package_name>',
                        'description': 'List broadcast receivers',
                        'tags': ['ENUM'],
                        'success_indicators': ['Receiver list with intent filters'],
                        'next_steps': ['Send broadcast: run app.broadcast.send --component <package> <receiver>']
                    }
                }
            ]
        })

        # PHASE 6: FRIDA DYNAMIC INSTRUMENTATION
        tasks['children'].append({
            'id': f'frida-instrumentation-{port}',
            'name': 'Frida Dynamic Instrumentation',
            'type': 'parent',
            'children': [
                {
                    'id': f'frida-attach-{port}',
                    'name': 'Attach Frida to App',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida -U -n <package_name>',
                        'description': 'Attach Frida to running application',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            '-U': 'Connect to USB device',
                            '-n': 'Attach to process by name',
                            '-f': 'Spawn app (frida -U -f <package>)'
                        },
                        'success_indicators': ['Frida REPL appears', 'Can execute JavaScript'],
                        'alternatives': [
                            'frida -U -f <package> (spawn mode)',
                            'frida -U -F (attach to frontmost app)',
                            'Python script with frida library'
                        ],
                        'notes': 'Use spawn mode (-f) to hook before app starts'
                    }
                },
                {
                    'id': f'ssl-pinning-bypass-{port}',
                    'name': 'Bypass SSL Pinning (Frida)',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida -U -f <package> -l ssl-bypass.js --no-pause',
                        'description': 'Bypass SSL certificate pinning with Frida',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-l': 'Load JavaScript file',
                            '--no-pause': 'Don\'t pause after spawning'
                        },
                        'success_indicators': [
                            'SSL pinning disabled',
                            'HTTPS traffic visible in Burp',
                            'No certificate errors'
                        ],
                        'alternatives': [
                            'objection: objection --gadget <package> explore --startup-command "android sslpinning disable"',
                            'apk-mitm (automatic APK patching)',
                            'Universal SSL Pinning Bypass scripts from codeshare.frida.re'
                        ],
                        'notes': 'Get bypass scripts from https://codeshare.frida.re/ or https://github.com/httptoolkit/frida-android-unpinning'
                    }
                },
                {
                    'id': f'root-detection-bypass-{port}',
                    'name': 'Bypass Root Detection',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida -U -f <package> -l root-bypass.js',
                        'description': 'Bypass root/jailbreak detection checks',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'success_indicators': ['Root detection bypassed', 'App runs on rooted device'],
                        'alternatives': [
                            'Magisk Hide / Zygisk DenyList',
                            'RootCloak module',
                            'Manual hooking of root check functions'
                        ],
                        'notes': 'Hook common root check methods (su exists, test-keys, etc.)'
                    }
                },
                {
                    'id': f'frida-hook-functions-{port}',
                    'name': 'Hook Java Methods (Frida)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hook Java methods to modify behavior',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'example_script': '''
Java.perform(function() {
    var MainActivity = Java.use("com.example.app.MainActivity");
    MainActivity.checkPassword.implementation = function(password) {
        console.log("[+] Password entered: " + password);
        return true; // Always return success
    };
});''',
                        'success_indicators': ['Method hooked', 'Custom logic executed'],
                        'notes': 'Use Java.perform() wrapper for all Java hooks'
                    }
                },
                {
                    'id': f'frida-dump-memory-{port}',
                    'name': 'Dump Application Memory',
                    'type': 'command',
                    'metadata': {
                        'command': 'python3 fridump3.py -u <package_name>',
                        'description': 'Dump app memory to search for sensitive data',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'success_indicators': ['Memory dumped to ./dump/'],
                        'next_steps': [
                            'Search for credentials: strings dump/* | grep -i password',
                            'Look for API keys, tokens, mnemonics'
                        ],
                        'tools': ['fridump3 (pip install fridump3)'],
                        'notes': 'Look for sensitive data in memory that shouldn\'t be there'
                    }
                },
                {
                    'id': f'objection-explore-{port}',
                    'name': 'Use Objection for Quick Exploitation',
                    'type': 'command',
                    'metadata': {
                        'command': 'objection --gadget <package> explore',
                        'description': 'Interactive Frida-based exploration toolkit',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN'],
                        'success_indicators': ['Objection REPL started'],
                        'common_commands': [
                            'android sslpinning disable',
                            'android root disable',
                            'android hooking list activities',
                            'android intent launch_activity <activity>',
                            'memory dump all <output>',
                            'android clipboard monitor'
                        ],
                        'notes': 'Objection automates common Frida tasks'
                    }
                },
                {
                    'id': f'biometric-bypass-{port}',
                    'name': 'Bypass Biometric Authentication',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <package>',
                        'description': 'Bypass fingerprint/face authentication',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'success_indicators': ['Biometric auth bypassed', 'Access granted'],
                        'alternatives': ['Manual hook of BiometricPrompt callbacks'],
                        'notes': 'Works on biometric prompt authentication'
                    }
                }
            ]
        })

        # PHASE 7: WEBVIEW EXPLOITATION
        tasks['children'].append({
            'id': f'webview-attacks-{port}',
            'name': 'WebView Security Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'webview-settings-review-{port}',
                    'name': 'Review WebView Security Settings',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check WebView configuration for vulnerabilities',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'checks': [
                            'setJavaScriptEnabled(true) - JavaScript enabled',
                            'setAllowFileAccess(true) - File access allowed',
                            'setAllowUniversalAccessFromFileURLs(true) - DEPRECATED & DANGEROUS',
                            'setAllowFileAccessFromFileURLs(true) - DEPRECATED & DANGEROUS',
                            'addJavascriptInterface() - JavaScript bridge exposed',
                            'setWebContentsDebuggingEnabled(true) - Remote debugging'
                        ],
                        'success_indicators': ['Insecure configuration found'],
                        'next_steps': [
                            'Test XSS if JavaScript enabled',
                            'Test LFI if file access enabled',
                            'Exploit JavaScript bridge'
                        ]
                    }
                },
                {
                    'id': f'webview-xss-{port}',
                    'name': 'Test WebView XSS',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for cross-site scripting in WebView',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'test_payloads': [
                            '<script>alert(1)</script>',
                            '<img src=x onerror=alert(1)>',
                            'javascript:alert(1)'
                        ],
                        'success_indicators': ['JavaScript executes', 'Alert displayed'],
                        'next_steps': [
                            'Exploit JavaScript bridge if available',
                            'Exfiltrate local files',
                            'Steal session data'
                        ],
                        'notes': 'Test in URL parameters, form inputs, deep links'
                    }
                },
                {
                    'id': f'webview-js-bridge-{port}',
                    'name': 'Exploit JavaScript Bridge',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Call native Android methods via JavaScript bridge',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'example': 'alert(javascriptBridge.getSensitiveData())',
                        'steps': [
                            'Identify bridge name: search for addJavascriptInterface',
                            'Enumerate methods: reflection or code review',
                            'Call methods via XSS or MitM',
                            'Extract sensitive data or execute native code'
                        ],
                        'success_indicators': ['Native methods called', 'Data exfiltrated'],
                        'notes': 'Pre-Android 4.2: RCE possible via reflection'
                    }
                },
                {
                    'id': f'webview-lfi-{port}',
                    'name': 'Test Local File Inclusion',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Access local files via WebView file:// URLs',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'test_urls': [
                            'file:///data/data/<package>/databases/sensitive.db',
                            'file:///data/data/<package>/shared_prefs/prefs.xml',
                            'file:///sdcard/Download/sensitive.txt'
                        ],
                        'success_indicators': ['File contents displayed', 'Database accessed'],
                        'notes': 'Check setAllowFileAccess and universal access settings'
                    }
                },
                {
                    'id': f'webview-remote-debug-{port}',
                    'name': 'Use Remote WebView Debugging',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Debug WebView via Chrome DevTools',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'steps': [
                            'Check if debugging enabled: setWebContentsDebuggingEnabled(true)',
                            'Connect device via ADB',
                            'Open chrome://inspect in Chrome',
                            'Select WebView and click "Inspect"',
                            'Execute arbitrary JavaScript in console'
                        ],
                        'success_indicators': ['DevTools opens', 'Can execute JavaScript'],
                        'notes': 'Often enabled in debug builds, rarely in production'
                    }
                }
            ]
        })

        # PHASE 8: DEEP LINK & INTENT EXPLOITATION
        tasks['children'].append({
            'id': f'deeplink-exploitation-{port}',
            'name': 'Deep Link & Intent Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'find-deeplinks-{port}',
                    'name': 'Discover Deep Links',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find URL schemes and deep links in manifest',
                        'tags': ['ENUM', 'QUICK_WIN'],
                        'search_for': [
                            '<data android:scheme=',
                            '<data android:host=',
                            'android.intent.action.VIEW',
                            'android.intent.category.BROWSABLE'
                        ],
                        'success_indicators': ['Deep links found in manifest'],
                        'alternatives': ['MobSF automatically extracts deep links']
                    }
                },
                {
                    'id': f'test-deeplink-{port}',
                    'name': 'Test Deep Link',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell am start -a android.intent.action.VIEW -d "scheme://host/path?param=value"',
                        'description': 'Trigger deep link via ADB',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'flag_explanations': {
                            'am start': 'Activity manager - start activity',
                            '-a': 'Specify action (VIEW for deep links)',
                            '-d': 'Data URI (deep link URL)'
                        },
                        'success_indicators': ['Activity launched', 'Parameter processed'],
                        'next_steps': [
                            'Test injection in parameters',
                            'Test path traversal: scheme://host/../../sensitive',
                            'Test XSS in deep link parameters'
                        ],
                        'alternatives': [
                            'Browser link: <a href="scheme://host/path">',
                            'HTML: window.location = "scheme://host/path"'
                        ],
                        'notes': 'Check onNewIntent() method for parameter handling'
                    }
                },
                {
                    'id': f'deeplink-injection-{port}',
                    'name': 'Test Deep Link Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for injection in deep link parameters',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'test_cases': [
                            'XSS: scheme://host/page?param=<script>alert(1)</script>',
                            'SQLi: scheme://host/user?id=1\' OR \'1\'=\'1',
                            'Path traversal: scheme://host/file?path=../../etc/passwd',
                            'Open redirect: scheme://host/redirect?url=http://evil.com'
                        ],
                        'success_indicators': ['Injection successful', 'Unexpected behavior'],
                        'notes': 'Deep links are untrusted input - treat like web parameters'
                    }
                },
                {
                    'id': f'intent-injection-{port}',
                    'name': 'Test Intent Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject malicious intents via exported components',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'attack_scenarios': [
                            'Redirect intents to access non-exported components',
                            'Inject intent extras to manipulate app behavior',
                            'Access restricted content providers'
                        ],
                        'notes': 'Similar to Open Redirect but for Android intents'
                    }
                }
            ]
        })

        # PHASE 9: DATA STORAGE ANALYSIS
        tasks['children'].append({
            'id': f'data-storage-{port}',
            'name': 'Data Storage Security Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'check-shared-prefs-{port}',
                    'name': 'Review Shared Preferences',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell cat /data/data/<package>/shared_prefs/*.xml',
                        'description': 'Check for sensitive data in shared preferences',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'success_indicators': [
                            'Passwords in clear text',
                            'API keys stored',
                            'Session tokens'
                        ],
                        'alternatives': ['Pull files: adb pull /data/data/<package>/shared_prefs/'],
                        'notes': 'SharedPreferences should NOT store sensitive data'
                    }
                },
                {
                    'id': f'check-databases-{port}',
                    'name': 'Analyze SQLite Databases',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell sqlite3 /data/data/<package>/databases/app.db',
                        'description': 'Review SQLite databases for sensitive data',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'common_commands': [
                            '.tables (list tables)',
                            '.schema <table> (show schema)',
                            'SELECT * FROM users; (query data)'
                        ],
                        'success_indicators': ['Sensitive data found', 'Plaintext passwords'],
                        'alternatives': ['Pull and open locally: adb pull /data/data/<package>/databases/'],
                        'notes': 'Check for unencrypted sensitive data, weak crypto'
                    }
                },
                {
                    'id': f'check-external-storage-{port}',
                    'name': 'Check External Storage',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell ls -la /sdcard/',
                        'description': 'Check for sensitive files on external storage',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'success_indicators': ['App data on SD card', 'World-readable files'],
                        'notes': 'External storage is world-readable - apps should NOT store sensitive data there'
                    }
                },
                {
                    'id': f'check-world-readable-{port}',
                    'name': 'Find World-Readable Files',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell find /data/data/<package> -type f -perm 0444',
                        'description': 'Find files with MODE_WORLD_READABLE',
                        'tags': ['OSCP:MEDIUM'],
                        'success_indicators': ['World-readable files found'],
                        'notes': 'MODE_WORLD_READABLE/WRITABLE are dangerous (deprecated)'
                    }
                },
                {
                    'id': f'backup-extraction-{port}',
                    'name': 'Extract App Backup',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb backup -f app_backup.ab -apk <package>',
                        'description': 'Backup app data for offline analysis',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            '-f': 'Output file',
                            '-apk': 'Include APK in backup'
                        },
                        'success_indicators': ['Backup created'],
                        'next_steps': [
                            'Extract: ( printf "\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00" ; tail -c +25 app_backup.ab ) | tar xfvz -',
                            'Analyze extracted files'
                        ],
                        'notes': 'Check if android:allowBackup="false" is set'
                    }
                },
                {
                    'id': f'keystore-analysis-{port}',
                    'name': 'Analyze Android Keystore',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check Keystore for sensitive data',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'steps': [
                            'Use Frida script: tracer-cipher.js',
                            'Monitor crypto operations',
                            'Check if sensitive data stored in Keystore is encrypted',
                            'Test if keys are hardware-backed or software'
                        ],
                        'notes': 'Keystore is best place for keys, but data should still be encrypted'
                    }
                }
            ]
        })

        # PHASE 10: TRAFFIC ANALYSIS & MitM
        tasks['children'].append({
            'id': f'traffic-analysis-{port}',
            'name': 'Network Traffic Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'capture-http-{port}',
                    'name': 'Capture HTTP/HTTPS Traffic',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Intercept and analyze network traffic',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'prerequisites': [
                            'Burp proxy configured',
                            'CA certificate installed',
                            'SSL pinning bypassed'
                        ],
                        'analysis_points': [
                            'API endpoints and parameters',
                            'Authentication tokens',
                            'Session management',
                            'Sensitive data in transit',
                            'HTTP vs HTTPS usage'
                        ],
                        'success_indicators': ['Traffic visible in Burp'],
                        'notes': 'Look for API keys, tokens, PII in requests/responses'
                    }
                },
                {
                    'id': f'test-api-auth-{port}',
                    'name': 'Test API Authentication',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test API security and authentication',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'test_cases': [
                            'Remove authentication header - still works?',
                            'Replay old session tokens',
                            'Test IDOR in API parameters',
                            'Test authorization bypasses',
                            'Brute force API keys'
                        ],
                        'success_indicators': ['Auth bypass found', 'IDOR exploited']
                    }
                },
                {
                    'id': f'detect-ssl-pinning-{port}',
                    'name': 'Detect SSL Pinning Implementation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify SSL pinning mechanism',
                        'tags': ['ENUM'],
                        'common_implementations': [
                            'OkHttp CertificatePinner',
                            'TrustManager override',
                            'Network Security Config (XML)',
                            'Custom native implementation'
                        ],
                        'detection_methods': [
                            'Static: grep for "CertificatePinner", "checkServerTrusted"',
                            'Dynamic: observe SSL errors when proxying',
                            'Use SSLPinDetect tool'
                        ],
                        'notes': 'Knowing implementation helps choose bypass method'
                    }
                },
                {
                    'id': f'iptables-forwarding-{port}',
                    'name': 'Force Traffic via iptables',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to-destination <proxy_ip>:8080',
                        'description': 'Force all HTTPS traffic through proxy using iptables',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'requirements': ['Root access'],
                        'success_indicators': ['Traffic captured even with no proxy set'],
                        'notes': 'Alternative when app ignores proxy settings'
                    }
                }
            ]
        })

        # PHASE 11: LOGGING & MONITORING
        tasks['children'].append({
            'id': f'logging-analysis-{port}',
            'name': 'Logging & Runtime Monitoring',
            'type': 'parent',
            'children': [
                {
                    'id': f'logcat-monitor-{port}',
                    'name': 'Monitor Application Logs',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb logcat | grep -i <package>',
                        'description': 'Monitor real-time application logs',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'logcat': 'View device logs',
                            'grep': 'Filter by package name'
                        },
                        'success_indicators': [
                            'Sensitive data logged',
                            'Stack traces visible',
                            'Debug messages'
                        ],
                        'alternatives': [
                            'pidcat <package> (better formatting)',
                            'adb logcat -d (dump and exit)',
                            'adb logcat *:E (errors only)'
                        ],
                        'notes': 'Look for passwords, tokens, API keys in logs'
                    }
                },
                {
                    'id': f'pidcat-monitor-{port}',
                    'name': 'Use pidcat for Readable Logs',
                    'type': 'command',
                    'metadata': {
                        'command': 'pidcat <package_name>',
                        'description': 'Monitor logs with color-coded output',
                        'tags': ['QUICK_WIN'],
                        'success_indicators': ['Readable, colorized log output'],
                        'tools': ['pidcat (https://github.com/JakeWharton/pidcat)'],
                        'notes': 'Much better than raw logcat'
                    }
                },
                {
                    'id': f'dumpsys-activity-{port}',
                    'name': 'Dump Activity Manager State',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell dumpsys activity <package>',
                        'description': 'Get detailed activity information',
                        'tags': ['ENUM'],
                        'success_indicators': ['Activity stack shown', 'Intent history'],
                        'alternatives': ['dumpsys meminfo (memory usage)']
                    }
                },
                {
                    'id': f'clipboard-monitor-{port}',
                    'name': 'Monitor Clipboard',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Monitor clipboard for sensitive data',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': 'Apps can read clipboard - sensitive data exposure risk',
                        'tools': ['Objection: android clipboard monitor'],
                        'success_indicators': ['Sensitive data copied to clipboard']
                    }
                },
                {
                    'id': f'screenshot-protection-{port}',
                    'name': 'Test Screenshot Protection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if FLAG_SECURE prevents screenshots',
                        'tags': ['OSCP:LOW'],
                        'test': 'Take screenshot of sensitive screen',
                        'success_indicators': ['Screenshot blocked or shows black screen'],
                        'notes': 'Banking apps should use FLAG_SECURE'
                    }
                }
            ]
        })

        # PHASE 12: AUTOMATED SCANNING
        tasks['children'].append({
            'id': f'automated-scanners-{port}',
            'name': 'Automated Security Scanners',
            'type': 'parent',
            'children': [
                {
                    'id': f'mobsf-dynamic-{port}',
                    'name': 'MobSF Dynamic Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Run comprehensive dynamic analysis with MobSF',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'features': [
                            'Automatic Frida instrumentation',
                            'SSL pinning bypass',
                            'Root detection bypass',
                            'API hooking and monitoring',
                            'Exported activity testing',
                            'HTTP traffic capture'
                        ],
                        'setup': [
                            'Install Genymotion emulator',
                            'Start MobSF dynamic analysis',
                            'Upload APK and start instrumentation'
                        ],
                        'notes': 'Requires Genymotion (not Docker)'
                    }
                },
                {
                    'id': f'qark-scan-{port}',
                    'name': 'QARK Security Scan',
                    'type': 'command',
                    'metadata': {
                        'command': 'qark --apk app.apk',
                        'description': 'Scan for security vulnerabilities with QARK',
                        'tags': ['AUTOMATED'],
                        'flag_explanations': {
                            '--apk': 'Scan compiled APK',
                            '--java': 'Scan Java source code'
                        },
                        'success_indicators': ['Vulnerabilities found', 'PoC APKs generated'],
                        'notes': 'QARK creates PoC exploits for found vulnerabilities'
                    }
                },
                {
                    'id': f'androbugs-scan-{port}',
                    'name': 'AndroBugs Framework Scan',
                    'type': 'command',
                    'metadata': {
                        'command': 'python androbugs.py -f app.apk',
                        'description': 'Comprehensive vulnerability analysis',
                        'tags': ['AUTOMATED'],
                        'success_indicators': ['Detailed vulnerability report generated'],
                        'notes': 'Checks for common Android security issues'
                    }
                },
                {
                    'id': f'super-analyzer-{port}',
                    'name': 'SUPER Android Analyzer',
                    'type': 'command',
                    'metadata': {
                        'command': 'super-analyzer app.apk',
                        'description': 'Rule-based security analysis',
                        'tags': ['AUTOMATED'],
                        'success_indicators': ['HTML/JSON report generated'],
                        'notes': 'Customizable rules via rules.json'
                    }
                },
                {
                    'id': f'apkid-scan-{port}',
                    'name': 'APKiD - Identify Compiler/Packer',
                    'type': 'command',
                    'metadata': {
                        'command': 'apkid app.apk',
                        'description': 'Identify compiler, packer, obfuscator used',
                        'tags': ['ENUM', 'QUICK_WIN'],
                        'success_indicators': ['Compiler/packer identified'],
                        'notes': 'Helps understand obfuscation/protection mechanisms'
                    }
                },
                {
                    'id': f'mariana-trench-{port}',
                    'name': 'Mariana Trench SAST',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Static taint analysis for vulnerabilities',
                        'tags': ['AUTOMATED'],
                        'notes': 'Facebook\'s tool - finds data flow vulnerabilities (sources to sinks)',
                        'tools': ['mariana-trench (https://github.com/facebook/mariana-trench)']
                    }
                }
            ]
        })

        # PHASE 13: EXPLOITATION & POST-EXPLOITATION
        tasks['children'].append({
            'id': f'exploitation-{port}',
            'name': 'Exploitation & Post-Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'exploit-debuggable-{port}',
                    'name': 'Exploit Debuggable Application',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit apps with android:debuggable="true"',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'steps': [
                            'Check manifest for debuggable="true"',
                            'Attach debugger: adb shell am set-debug-app -w <package>',
                            'Connect JDWP debugger',
                            'Execute arbitrary code',
                            'Extract runtime data'
                        ],
                        'success_indicators': ['Debugger attached', 'Code execution achieved'],
                        'notes': 'Should NEVER be enabled in production'
                    }
                },
                {
                    'id': f'smali-patching-{port}',
                    'name': 'Patch Smali Code',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Modify APK by editing Smali code',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'workflow': [
                            'Decompile: apktool d app.apk',
                            'Edit .smali files (bypass checks, log data, etc.)',
                            'Rebuild: apktool b app_modified',
                            'Sign: jarsigner, zipalign',
                            'Install modified APK'
                        ],
                        'common_patches': [
                            'Return true from authentication checks',
                            'Log sensitive data',
                            'Disable SSL pinning',
                            'Disable root detection'
                        ],
                        'notes': 'Alternative to Frida for persistent modifications'
                    }
                },
                {
                    'id': f'tapjacking-{port}',
                    'name': 'Test for Tapjacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overlay malicious UI to trick user',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'attack': 'Create transparent overlay that intercepts taps',
                        'protection': 'filterTouchesWhenObscured="true"',
                        'notes': 'Check if sensitive activities are protected'
                    }
                },
                {
                    'id': f'task-hijacking-{port}',
                    'name': 'Test Task Hijacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hijack app task with malicious activity',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'vulnerable_config': 'launchMode="singleTask" without taskAffinity',
                        'attack': 'Launch malicious app before legitimate app',
                        'notes': 'User thinks they\'re using legitimate app'
                    }
                },
                {
                    'id': f'credential-extraction-{port}',
                    'name': 'Extract Stored Credentials',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find and extract stored credentials',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'locations': [
                            'SharedPreferences XML files',
                            'SQLite databases',
                            'Keystore (requires root)',
                            'Memory dumps',
                            'Backup files'
                        ],
                        'success_indicators': ['Credentials found'],
                        'notes': 'Check encryption quality if credentials stored'
                    }
                },
                {
                    'id': f'insecure-in-app-update-{port}',
                    'name': 'Test Insecure In-App Update',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit insecure update mechanisms',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'attack': 'MitM update check and serve malicious APK',
                        'checks': [
                            'Update over HTTP (not HTTPS)',
                            'No signature verification',
                            'Can inject malicious update'
                        ],
                        'notes': 'Apps that self-update are high-risk targets'
                    }
                }
            ]
        })

        # PHASE 14: SPECIAL CASES
        tasks['children'].append({
            'id': f'special-cases-{port}',
            'name': 'Framework-Specific Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'react-native-{port}',
                    'name': 'React Native App Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze React Native applications',
                        'tags': ['OSCP:MEDIUM'],
                        'steps': [
                            'Extract assets/index.android.bundle',
                            'Deobfuscate JavaScript (if minified)',
                            'Review JS code for vulnerabilities',
                            'Check for sensitive data in bundle'
                        ],
                        'notes': 'React Native bundles JavaScript - easier to reverse than native'
                    }
                },
                {
                    'id': f'flutter-{port}',
                    'name': 'Flutter App Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Flutter applications',
                        'tags': ['OSCP:MEDIUM'],
                        'challenges': [
                            'Flutter has separate CA cert list',
                            'Need to patch libflutter.so for cert pinning bypass',
                            'Dart code compiled to native (harder to reverse)'
                        ],
                        'tools': ['reFlutter (https://github.com/ptswarm/reFlutter)'],
                        'notes': 'Use reFlutter for automatic SSL unpinning'
                    }
                },
                {
                    'id': f'xamarin-{port}',
                    'name': 'Xamarin App Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Xamarin (C#) applications',
                        'tags': ['OSCP:MEDIUM'],
                        'steps': [
                            'Extract assemblies/ folder',
                            'Decompile DLL files with dnSpy/ILSpy',
                            'Review C# code'
                        ],
                        'notes': 'Xamarin apps contain .NET DLLs - easy to reverse'
                    }
                },
                {
                    'id': f'cordova-ionic-{port}',
                    'name': 'Cordova/Ionic App Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Cordova/Ionic hybrid apps',
                        'tags': ['OSCP:LOW'],
                        'steps': [
                            'Extract assets/www/ folder',
                            'Review HTML/JS/CSS files',
                            'Check for exposed APIs'
                        ],
                        'notes': 'Hybrid apps are essentially web apps - standard web testing applies'
                    }
                }
            ]
        })

        # PHASE 15: REPORTING & DOCUMENTATION
        tasks['children'].append({
            'id': f'reporting-{port}',
            'name': 'Reporting & Documentation',
            'type': 'parent',
            'children': [
                {
                    'id': f'screenshot-evidence-{port}',
                    'name': 'Collect Screenshot Evidence',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell screencap /sdcard/screenshot.png && adb pull /sdcard/screenshot.png',
                        'description': 'Capture screenshot for documentation',
                        'tags': ['MANUAL'],
                        'success_indicators': ['Screenshot saved locally']
                    }
                },
                {
                    'id': f'record-exploitation-{port}',
                    'name': 'Record Video Proof',
                    'type': 'command',
                    'metadata': {
                        'command': 'adb shell screenrecord --time-limit 180 /sdcard/demo.mp4',
                        'description': 'Record video of exploitation',
                        'tags': ['MANUAL'],
                        'flag_explanations': {
                            '--time-limit': 'Max recording time in seconds (default: 180)'
                        },
                        'notes': 'Press Ctrl-C to stop early'
                    }
                },
                {
                    'id': f'export-mobsf-report-{port}',
                    'name': 'Export MobSF Report',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Generate comprehensive MobSF report',
                        'tags': ['MANUAL'],
                        'notes': 'MobSF provides PDF/JSON reports with all findings'
                    }
                },
                {
                    'id': f'vulnerability-summary-{port}',
                    'name': 'Create Vulnerability Summary',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Document all findings',
                        'tags': ['MANUAL'],
                        'include': [
                            'Executive summary',
                            'OWASP Mobile Top 10 mapping',
                            'Vulnerability details with PoC',
                            'Screenshots/videos',
                            'Remediation recommendations',
                            'Risk ratings (CVSS)'
                        ]
                    }
                }
            ]
        })

        return tasks


# Educational notes for OSCP preparation
ANDROID_PENTEST_NOTES = """
ANDROID PENTESTING - OSCP PREPARATION NOTES
===========================================

KEY CONCEPTS:
1. APK Structure: ZIP file with AndroidManifest.xml, classes.dex, lib/, res/, assets/
2. Dalvik/ART: Android runtime that executes DEX bytecode
3. Smali: Human-readable representation of DEX bytecode
4. Security Model: UID isolation, sandboxing, permissions, SELinux

CRITICAL CHECKS:
- android:debuggable="true"  Can attach debugger, extract runtime data
- android:allowBackup="true"  Can extract app data via adb backup
- Exported components  Can be accessed by any app (auth bypass, data leakage)
- Dangerous permissions  WRITE_EXTERNAL_STORAGE, READ_SMS, etc.
- SSL pinning  Must bypass for traffic interception
- Root detection  Must bypass on rooted test devices
- WebView configuration  XSS, LFI, JavaScript bridge risks

ESSENTIAL TOOLS:
- ADB: Device communication, shell access, file transfer
- Jadx: APK decompilation to Java (best for code review)
- Apktool: APK decompilation to Smali (best for modification)
- Frida: Dynamic instrumentation (hooking, SSL bypass, root bypass)
- Drozer: Component exploitation (activities, services, providers)
- Burp Suite: Traffic interception (requires cert install + SSL bypass)
- MobSF: Automated static/dynamic analysis
- Objection: Frida automation toolkit

COMMON VULNERABILITIES:
1. Insecure Data Storage: Plaintext credentials in SharedPrefs/DB
2. Weak Crypto: Hardcoded keys, weak algorithms (DES, MD5)
3. Exported Components: Auth bypass via exported activities
4. Intent Injection: Redirecting intents to non-exported components
5. WebView Attacks: XSS, LFI, JavaScript bridge exploitation
6. Insecure Communication: HTTP usage, no cert validation
7. Deep Link Injection: XSS/SQLi in deep link parameters
8. Insufficient Auth: Weak session management, no server-side validation

METHODOLOGY:
1. Recon: Extract APK, identify package name, list components
2. Static Analysis: Decompile, review manifest, search for secrets
3. Dynamic Setup: Install APK, root device, install Frida/Drozer
4. Traffic Analysis: Configure proxy, install cert, bypass SSL pinning
5. Component Testing: Test exported activities/services/providers
6. Data Storage: Check SharedPrefs, databases, external storage
7. Instrumentation: Hook methods with Frida, bypass protections
8. Exploitation: Exploit found vulnerabilities with PoC

EXAM TIPS:
- Always document source of findings (which tool, command, manual test)
- Take screenshots of every step
- Note time spent on each phase (for exam time management)
- Have manual alternatives ready (Frida may fail, use Smali patching)
- Focus on high-value targets: debuggable apps, exported components, insecure storage
- Don't waste time on obfuscated code without clear vulnerabilities

QUICK WINS (High impact, low effort):
1. Check for debuggable="true" in manifest
2. Search strings for API keys, URLs, passwords
3. Test Firebase misconfiguration
4. Check SharedPreferences for plaintext credentials
5. Test exported activities for auth bypass
6. Look for hardcoded secrets in code
7. Test deep links for injection
8. Check if sensitive data logged in logcat

MANUAL ALTERNATIVES (when tools fail):
- No Frida?  Patch Smali code with apktool
- No Drozer?  Use adb shell am/pm commands directly
- SSL pinning?  apk-mitm auto-patching or network security config modification
- No root?  Use Frida Gadget (embed in APK)
- Obfuscated code?  Focus on runtime analysis (Frida) over static

REFERENCES:
- OWASP Mobile Security Testing Guide (MSTG)
- HackTricks Android Pentesting
- Frida CodeShare: https://codeshare.frida.re/
- GTFOBins equivalent for Android: https://gtfobins.github.io/
"""
