# Heap Exploitation Plugin

**Related Mining Reports:** [Mining Report: Binary Exploitation](./BINARY_EXPLOIT_MINING_REPORT.md)
**Plugin Source:** [`../heap_exploit.py`](../heap_exploit.py)

---

## Table of Contents

- [Overview](#overview)
- [Key Features](#key-features)
- [Usage](#usage)
  - [Manual Activation Example](#manual-activation-example)
  - [Python API Usage](#python-api-usage)
- [Task Phases](#task-phases)
  - [Phase 1: Initial Analysis](#phase-1-initial-analysis)
  - [Phase 2: Heap Structure Inspection](#phase-2-heap-structure-inspection)
  - [Phase 3: Vulnerability Identification](#phase-3-vulnerability-identification)
  - [Phase 4: Exploitation Techniques](#phase-4-exploitation-techniques)
  - [Phase 5: Debugging & Analysis Tools](#phase-5-debugging--analysis-tools)
- [Heap Exploitation Techniques Covered](#heap-exploitation-techniques-covered)
  - [Use-After-Free (UAF)](#use-after-free-uaf)
  - [Double-Free](#double-free)
  - [Tcache Poisoning](#tcache-poisoning)
  - [Fastbin Attack](#fastbin-attack)
- [GDB/pwndbg Commands Reference](#gdbpwndbg-commands-reference)
- [Educational Metadata](#educational-metadata)
- [Testing](#testing)
- [Use Cases](#use-cases)
- [See Also](#see-also)

---

## Overview

**Status:** ✅ Complete
**OSCP Relevance:** LOW (CTF/advanced binary exploitation)

The **Heap Exploitation Plugin** provides comprehensive guidance for analyzing and exploiting heap vulnerabilities in binary exploitation scenarios. This plugin generates educational task trees covering heap structure analysis, vulnerability identification, and exploitation techniques.

**Source:** Extracted from HackTricks binary exploitation content (`libc-heap/`)

## Key Features

- **5 Comprehensive Phases:** Structured workflow from initial analysis to exploitation
- **50+ Educational Tasks:** Detailed guidance on heap internals and attack techniques
- **GDB/pwndbg Integration:** Complete debugging command reference
- **OSCP-Style Metadata:** Flag explanations, alternatives, success/failure indicators
- **Technique Coverage:** UAF, double-free, overflow, tcache poisoning, fastbin attacks, House of techniques

## Usage

This plugin is **NOT auto-detected**. It must be manually activated when analyzing binaries with potential heap vulnerabilities.

### Manual Activation Example

```bash
# Create target profile for binary analysis
crack track new binary-analysis

# Manually add heap exploitation tasks
# (This requires programmatic access to TargetProfile API)
```

### Python API Usage

```python
from crack.track.services.heap_exploit import HeapExploitPlugin
from crack.track.core.state import TargetProfile

# Create plugin instance
plugin = HeapExploitPlugin()

# Generate task tree for binary
service_info = {
    'binary_path': '/path/to/vulnerable_binary',
    'libc_version': '2.31',
    'arch': 'x86_64'
}

task_tree = plugin.get_task_tree(
    target='/path/to/vulnerable_binary',
    port=0,
    service_info=service_info
)

# Add to target profile
profile = TargetProfile.load('binary-analysis')
profile.task_tree.add_child(task_tree)
profile.save()
```

## Task Phases

### Phase 1: Initial Analysis

- **checksec**: Identify binary protections (RELRO, PIE, NX, etc.)
- **identify-libc**: Determine libc version for exploit compatibility
- **heap-functions-check**: Verify binary uses heap allocation

**Time:** ~5 minutes

### Phase 2: Heap Structure Inspection

- **gdb-heap-basics**: Core GDB commands for heap analysis
- **pwndbg-heap-analysis**: Advanced pwndbg heap commands
- **heap-chunk-structure**: Understanding malloc_chunk layout
- **bins-explained**: Comprehensive bin types (fastbin, tcache, unsorted, small, large)

**Educational Focus:** Deep understanding of glibc heap internals

### Phase 3: Vulnerability Identification

- **uaf-check**: Use-After-Free detection and exploitation
- **double-free-check**: Double-free vulnerability patterns
- **heap-overflow-check**: Buffer overflow into heap chunks
- **off-by-one-check**: Single-byte overflow exploitation

**Methods:** Code review, dynamic analysis, fuzzing, valgrind

### Phase 4: Exploitation Techniques

- **tcache-poisoning**: Overwrite tcache next pointers (glibc 2.26+)
- **fastbin-attack**: Exploit fastbin linked lists
- **house-of-force**: Top chunk size corruption
- **house-of-orange**: Exploit without free() using FILE structures
- **ret2libc-heap**: Overwrite __malloc_hook/__free_hook

**Libc Version Aware:** Techniques adapt based on detected libc version

### Phase 5: Debugging & Analysis Tools

- **pwntools-template**: Ready-to-use Python exploit template
- **heap-feng-shui**: Heap grooming techniques
- **libc-database**: Identify libc from leaked addresses
- **one-gadget**: Find RCE gadgets in libc
- **asan-testing**: AddressSanitizer for vulnerability detection

## Heap Exploitation Techniques Covered

### Use-After-Free (UAF)

```
Vulnerability: Accessing freed memory
Detection: Valgrind, ASAN, code review
Exploitation:
  1. Free vulnerable chunk
  2. Allocate attacker-controlled object (same size)
  3. Trigger access on old pointer
  4. Old pointer reads attacker data
```

### Double-Free

```
Vulnerability: Freeing same chunk twice
Bypass: free(a) → free(b) → free(a)
Exploitation:
  1. Trigger double-free
  2. Allocate chunk (first free)
  3. Overwrite fd to target
  4. Allocate twice more → get target address
```

### Tcache Poisoning

```
Requirements: glibc 2.26+, UAF or overflow
Attack:
  1. Free chunk (goes to tcache)
  2. Overwrite fd pointer to target
  3. Allocate twice → second allocation at target
Targets: __malloc_hook, __free_hook, GOT
```

### Fastbin Attack

```
Requirements: Fastbin size, tcache full/disabled
Attack:
  1. Fill tcache (7 chunks)
  2. Free 8th chunk (fastbin)
  3. Overwrite fd to fake chunk
  4. Empty tcache + allocate → fake chunk returned
Fake Chunk: Must have correct size field, aligned address
```

## GDB/pwndbg Commands Reference

### Basic Heap Inspection

```gdb
heap                    # Show all chunks
bins                    # Show all bins
arena                   # Arena information
vis_heap_chunks         # Visualize layout
```

### Specific Bins

```gdb
fastbins                # Fastbin linked lists
tcachebins              # Tcache bins (glibc 2.26+)
unsortedbin             # Unsorted bin
smallbins               # Small bins
largebins               # Large bins
```

### Chunk Analysis

```gdb
malloc_chunk ADDRESS    # Parse chunk structure
x/40gx ADDRESS-0x10     # Examine with metadata
top_chunk               # Show top chunk
```

### Finding Exploitation Targets

```gdb
find_fake_fast ADDR SIZE    # Find fake fast chunks
```

## Educational Metadata

Every task includes:

- **Flag Explanations:** What each flag does and why
- **Success Indicators:** How to verify task completion
- **Failure Indicators:** Common errors and solutions
- **Next Steps:** What to do after completing task
- **Alternatives:** Manual methods when tools unavailable
- **Estimated Time:** For planning analysis workflow

## Example Task Metadata

```python
{
    'command': 'checksec --file=/path/to/binary',
    'flag_explanations': {
        '--file': 'Specify binary file to analyze',
        'RELRO': 'Relocation Read-Only (Full=harder GOT overwrite)',
        'PIE': 'Position Independent Executable (ASLR for binary)',
        'NX': 'No-Execute bit (requires ROP/ret2libc)'
    },
    'success_indicators': [
        'Output shows protection status',
        'Identifies weak points'
    ],
    'failure_indicators': [
        'checksec not installed',
        'File not found'
    ],
    'next_steps': [
        'If No PIE: addresses static, easier exploitation',
        'If Partial RELRO: GOT overwrite possible'
    ],
    'alternatives': [
        'readelf -l binary | grep GNU_STACK',
        'rabin2 -I binary'
    ]
}
```

## Libc Version Considerations

The plugin adapts techniques based on libc version:

- **< 2.26:** No tcache (use fastbin/smallbin)
- **2.26-2.31:** Tcache with weak protections
- **2.32+:** Safe-linking in fastbin/tcache
- **2.34+:** Removed __malloc_hook/__free_hook

## Tools Referenced

- **pwndbg:** Enhanced GDB with heap commands
- **pwntools:** Python exploit development framework
- **one_gadget:** Find RCE gadgets in libc
- **libc-database:** Identify libc from leaks
- **checksec:** Binary protection scanner
- **valgrind:** Memory error detection
- **AddressSanitizer (ASAN):** Runtime vulnerability detection

## Learning Resources

Included in task tree:

- HackTricks: Libc Heap Exploitation
- Azeria Labs: Heap Exploitation Series
- GuyInATuxedo: Heap Exploitation Tutorials
- Dhaval Kapil: Heap Exploitation Guide
- how2heap: Heap exploitation techniques repository
- CTF Practice: pwnable.kr, pwnable.tw, HackTheBox

## Testing

Comprehensive test suite included:

```bash
# Run heap exploitation plugin tests
pytest crack/tests/track/test_heap_exploit.py -v

# All tests (26 tests)
# - Plugin interface compliance
# - Task tree structure
# - Phase completeness
# - OSCP metadata validation
# - Educational content quality
# - Integration tests
```

**Test Results:** ✅ 26/26 tests passing

## Contribution Guide Compliance

✅ **Plugin Structure**
- Inherits from ServicePlugin
- Decorated with @ServiceRegistry.register
- All required methods implemented

✅ **Detection Method**
- Returns False (manual activation only)
- Defensive coding with .get()

✅ **Task Generation**
- Valid hierarchical structure
- Unique IDs with descriptive names
- Proper parent/child relationships

✅ **OSCP Metadata**
- Command tasks have metadata.command
- All flags explained
- Success/failure indicators (2+ each)
- Next steps guide progression
- Manual alternatives provided
- Appropriate tags

✅ **Testing**
- Detection tests
- Task tree structure tests
- Metadata completeness tests
- Educational content tests

✅ **Documentation**
- Plugin docstring
- Complex logic commented
- Usage examples
- README provided

## Use Cases

### CTF Binary Exploitation

```
Scenario: pwnable.kr heap challenge
1. Run checksec → identify protections
2. Use pwndbg heap commands → understand structure
3. Identify UAF vulnerability
4. Apply tcache poisoning
5. Overwrite __free_hook with system
6. Get shell
```

### Real-World Binary Analysis

```
Scenario: Custom daemon analysis
1. Identify libc version
2. Check for heap functions
3. Fuzz for heap overflow
4. Use valgrind to confirm
5. Develop exploit with pwntools template
6. Test with ASAN-compiled version
```

### OSCP Exam (Not Typical)

```
Note: Heap exploitation is NOT common in OSCP.
OSCP focuses on web apps, network services, privesc.

However, if binary exploitation appears:
- Use manual GDB analysis (no pwndbg in exam)
- Focus on basic overflow techniques
- Simpler exploits more likely than heap
```

## Plugin Size

- **heap_exploit.py:** ~1500 lines
- **test_heap_exploit.py:** ~600 lines
- **Total:** ~2100 lines

Target met: Comprehensive coverage in maintainable size

## Future Enhancements

Potential additions:

- **Heap spray detection**
- **Kernel heap exploitation (SLUB/SLAB)**
- **Windows heap exploitation (LFH)**
- **Browser heap exploitation**
- **Automated exploit generation integration**
- **Angr/symbolic execution guidance**

## License

Part of CRACK Track (Comprehensive Recon & Attack Creation Kit)

---

## See Also

- [Binary Exploitation Plugin](./binary_exploit_plugin_readme.md)
- [Lua Exploitation Plugin](./lua_exploit_plugin_readme.md)
- [Plugin Contribution Guide](../PLUGIN_CONTRIBUTION_GUIDE.md)
- [Service Plugin Registry](../registry.py)

---

**Author:** CrackPot v1.0 (Mining HackTricks, Forging CRACK Track Plugins)

**Source Material:** HackTricks binary-exploitation/libc-heap/

**Generated:** 2025-10-07
