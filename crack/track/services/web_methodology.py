"""
Web Testing Methodology & Specialized Techniques Plugin

Comprehensive web application testing methodology covering:
- Systematic vulnerability discovery workflows
- Web fuzzing tools (wfuzz, ffuf)
- Specialized attacks (UUID insecurities, ReDoS, DApps)
- PoC templates and polyglot payloads
- Browser extension testing methodology
- Advanced HTTP smuggling and cache attacks
- Business logic testing
- Rate limiting and timing attacks

Extracted from HackTricks pentesting-web content
Generated by: CrackPot v1.0 (Phase 3 Agent 8 - Cleanup)
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class WebMethodologyPlugin(ServicePlugin):
    """
    Web Testing Methodology Plugin

    This plugin provides systematic methodology for web application testing,
    including tool usage, specialized attack vectors, and comprehensive
    testing checklists for OSCP preparation.
    """

    @property
    def name(self) -> str:
        return "web-methodology"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443, 3000, 5000, 8000, 8888]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP/HTTPS services for methodology testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # HTTP/HTTPS services
        if any(svc in service for svc in self.service_names):
            return True

        # Common web ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive web testing methodology task tree"""

        # Determine URL scheme
        service = service_info.get('service', '').lower()
        scheme = 'https' if 'https' in service or 'ssl' in service or port in [443, 8443] else 'http'
        url = f"{scheme}://{target}:{port}"

        tasks = {
            'id': f'web-methodology-{port}',
            'name': f'Web Testing Methodology (Port {port})',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: SYSTEMATIC VULNERABILITY DISCOVERY ===
        tasks['children'].append({
            'id': f'web-vuln-checklist-{port}',
            'name': 'Systematic Vulnerability Checklist',
            'type': 'parent',
            'children': [
                # Reflected values testing
                {
                    'id': f'reflected-testing-{port}',
                    'name': 'Reflected Values Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test all input points for reflection vulnerabilities',
                        'checklist': [
                            'XSS (reflected, stored, DOM-based)',
                            'SSTI (Server-Side Template Injection)',
                            'CSTI (Client-Side Template Injection)',
                            'Command Injection',
                            'SSRF (Server-Side Request Forgery)',
                            'Open Redirect',
                            'CRLF Injection',
                            'Dangling Markup',
                            'XSLT Injection'
                        ],
                        'tags': ['MANUAL', 'OSCP:HIGH', 'METHODOLOGY'],
                        'notes': 'Test with polyglot payloads first for quick wins',
                        'next_steps': [
                            'Use PoC templates for confirmed vulnerabilities',
                            'Test both GET and POST parameters',
                            'Check headers, cookies, and file uploads'
                        ]
                    }
                },
                # Search functionality testing
                {
                    'id': f'search-injection-{port}',
                    'name': 'Search Functionality Injection Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test search features for injection vulnerabilities',
                        'checklist': [
                            'SQL Injection',
                            'NoSQL Injection',
                            'LDAP Injection',
                            'XPath Injection',
                            'ReDoS (Regular Expression DoS)',
                            'Path Traversal in search'
                        ],
                        'tags': ['MANUAL', 'OSCP:HIGH', 'ENUM'],
                        'next_steps': [
                            'Try basic injection payloads',
                            'Test error-based detection',
                            'Check for time-based blind injection'
                        ]
                    }
                },
                # HTTP header security
                {
                    'id': f'header-security-{port}',
                    'name': 'HTTP Header Security Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze HTTP headers for security misconfigurations',
                        'checklist': [
                            'Missing security headers (CSP, X-Frame-Options, HSTS)',
                            'Clickjacking vulnerabilities',
                            'CORS misconfigurations',
                            'Cookie security (HttpOnly, Secure, SameSite)',
                            'Cache-Control issues'
                        ],
                        'tags': ['QUICK_WIN', 'OSCP:MEDIUM', 'RECON'],
                        'alternatives': [
                            f'curl -I {url}',
                            f'curl -v {url} 2>&1 | grep -E "(CSP|X-Frame|HSTS|Set-Cookie)"'
                        ]
                    }
                }
            ]
        })

        # === PHASE 2: WEB FUZZING TOOLS ===
        tasks['children'].append({
            'id': f'web-fuzzing-{port}',
            'name': 'Web Fuzzing with Wfuzz/Ffuf',
            'type': 'parent',
            'children': [
                # Directory fuzzing
                {
                    'id': f'wfuzz-dir-{port}',
                    'name': 'Directory/File Fuzzing (Wfuzz)',
                    'type': 'command',
                    'metadata': {
                        'command': f'wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hc 404 {url}/FUZZ',
                        'description': 'Fuzz directories and files using wfuzz (alternative to gobuster)',
                        'flag_explanations': {
                            '-c': 'Colorize output for readability',
                            '-z file,wordlist': 'Use wordlist as fuzzing source',
                            '--hc 404': 'Hide 404 responses (not found)',
                            'FUZZ': 'Placeholder replaced with wordlist values'
                        },
                        'tags': ['AUTOMATED', 'OSCP:HIGH', 'ENUM', 'NOISY'],
                        'success_indicators': [
                            'Status codes 200, 301, 302, 403 found',
                            'Hidden directories discovered',
                            'Admin panels located'
                        ],
                        'failure_indicators': [
                            'All responses return same status code',
                            'WAF blocking requests',
                            'Connection timeouts'
                        ],
                        'alternatives': [
                            f'ffuf -u {url}/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,301,302,403',
                            f'gobuster dir -u {url} -w /usr/share/wordlists/dirb/common.txt',
                            f'feroxbuster -u {url}'
                        ],
                        'notes': 'Wfuzz is more flexible than gobuster for custom payloads',
                        'estimated_time': '5-10 minutes'
                    }
                },
                # Parameter fuzzing
                {
                    'id': f'wfuzz-params-{port}',
                    'name': 'Parameter Discovery (Wfuzz)',
                    'type': 'command',
                    'metadata': {
                        'command': f'wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt --hc 404 {url}/?FUZZ=test',
                        'description': 'Discover hidden GET parameters',
                        'flag_explanations': {
                            '-z file,params.txt': 'Use parameter name wordlist',
                            '--hc 404': 'Hide 404 responses',
                            '?FUZZ=test': 'Fuzz parameter names with test value'
                        },
                        'tags': ['AUTOMATED', 'OSCP:MEDIUM', 'ENUM'],
                        'success_indicators': [
                            'Different response sizes/codes for specific parameters',
                            'Error messages revealing logic',
                            'Hidden functionality discovered'
                        ],
                        'alternatives': [
                            'Arjun: arjun -u ' + url,
                            'Manual: Try common params (id, user, page, file, debug)'
                        ],
                        'notes': 'Use Arjun from Seclists: /usr/share/seclists/Discovery/Web-Content/arjun-params.txt',
                        'estimated_time': '3-5 minutes'
                    }
                },
                # POST data fuzzing
                {
                    'id': f'wfuzz-post-{port}',
                    'name': 'POST Data Fuzzing (Login Bruteforce)',
                    'type': 'command',
                    'metadata': {
                        'command': f'wfuzz -c -z file,users.txt -z file,passwords.txt --sc 200,302 -d "username=FUZZ&password=FUZ2Z" {url}/login',
                        'description': 'Brute force login forms with two wordlists',
                        'flag_explanations': {
                            '-z file,users.txt': 'First wordlist (usernames)',
                            '-z file,passwords.txt': 'Second wordlist (passwords)',
                            '--sc 200,302': 'Show only successful status codes',
                            '-d "data"': 'POST data with FUZZ/FUZ2Z placeholders',
                            'FUZ2Z': 'Second FUZZ placeholder for second wordlist'
                        },
                        'tags': ['AUTOMATED', 'OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                        'success_indicators': [
                            'Different response for valid credentials',
                            'Redirect to dashboard/home page',
                            'Session cookie set in response'
                        ],
                        'failure_indicators': [
                            'Account lockout triggered',
                            'CAPTCHA appears',
                            'All responses identical'
                        ],
                        'alternatives': [
                            'hydra -L users.txt -P passwords.txt ' + target + ' http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"',
                            'Manual testing with common credentials'
                        ],
                        'notes': 'Watch for rate limiting and lockouts',
                        'estimated_time': '10-30 minutes depending on wordlist size'
                    }
                },
                # HTTP verb fuzzing
                {
                    'id': f'wfuzz-verbs-{port}',
                    'name': 'HTTP Method/Verb Fuzzing',
                    'type': 'command',
                    'metadata': {
                        'command': f'wfuzz -c -z list,GET-HEAD-POST-PUT-DELETE-TRACE-OPTIONS-PATCH -X FUZZ {url}/admin',
                        'description': 'Test HTTP methods for access control bypass',
                        'flag_explanations': {
                            '-z list,methods': 'Inline list of HTTP methods to test',
                            '-X FUZZ': 'Set HTTP method to FUZZ value'
                        },
                        'tags': ['QUICK_WIN', 'OSCP:HIGH', 'ENUM', 'MANUAL'],
                        'success_indicators': [
                            'Different responses for different methods',
                            'PUT/DELETE allowed (file upload/deletion)',
                            'OPTIONS reveals allowed methods'
                        ],
                        'alternatives': [
                            f'for method in GET POST PUT DELETE; do curl -X $method {url}/admin; done',
                            f'curl -X OPTIONS {url} -v'
                        ],
                        'next_steps': [
                            'If PUT allowed, try file upload',
                            'If DELETE allowed, try resource deletion',
                            'If TRACE enabled, check for XST vulnerability'
                        ],
                        'estimated_time': '1-2 minutes'
                    }
                },
                # vHost fuzzing
                {
                    'id': f'wfuzz-vhost-{port}',
                    'name': 'Virtual Host Discovery',
                    'type': 'command',
                    'metadata': {
                        'command': f'wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt --hc 400,404,403 -H "Host: FUZZ.{target}" {url}',
                        'description': 'Discover virtual hosts through Host header fuzzing',
                        'flag_explanations': {
                            '-H "Host: FUZZ.target"': 'Set Host header with fuzzed subdomain',
                            '--hc 400,404,403': 'Hide error responses',
                            '-w subdomains.txt': 'Subdomain wordlist'
                        },
                        'tags': ['AUTOMATED', 'OSCP:MEDIUM', 'RECON'],
                        'success_indicators': [
                            'Different content/size for specific subdomains',
                            'Valid virtual hosts discovered',
                            'Hidden applications found'
                        ],
                        'alternatives': [
                            f'ffuf -u {url} -H "Host: FUZZ.{target}" -w subdomains.txt',
                            f'gobuster vhost -u {url} -w subdomains.txt'
                        ],
                        'notes': 'Essential for penetration tests with multiple web apps on same IP',
                        'estimated_time': '2-5 minutes'
                    }
                }
            ]
        })

        # === PHASE 3: SPECIALIZED ATTACKS ===
        tasks['children'].append({
            'id': f'specialized-attacks-{port}',
            'name': 'Specialized Web Attacks',
            'type': 'parent',
            'children': [
                # UUID attacks
                {
                    'id': f'uuid-sandwich-{port}',
                    'name': 'UUID Insecurity Testing (Sandwich Attack)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for predictable UUID v1 tokens (password reset, sessions)',
                        'attack_flow': [
                            '1. Request password reset for controlled account 1',
                            '2. Note UUID in reset link (e.g., 99874128-7592-11e9-8201-bb2f15014a14)',
                            '3. Request password reset for TARGET victim account',
                            '4. Request password reset for controlled account 2',
                            '5. Note UUID in reset link (e.g., 998796b4-7592-11e9-8201-bb2f15014a14)',
                            '6. Brute force UUIDs between the two values',
                            '7. Test each UUID in password reset URL'
                        ],
                        'uuid_identification': {
                            'UUID v1': 'Time-based, predictable (MAC address + timestamp)',
                            'Format': 'xxxxxxxx-xxxx-1xxx-xxxx-xxxxxxxxxxxx (1 in position M = v1)',
                            'Vulnerable': 'Yes - time-based allows sandwich attack',
                            'UUID v4': 'Random, secure (xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx)'
                        },
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'EXPLOIT'],
                        'tools': [
                            'https://github.com/Lupin-Holmes/sandwich - Automated sandwich attack',
                            'Burp UUID Detector extension'
                        ],
                        'success_indicators': [
                            'UUID format shows v1 (position M = 1)',
                            'Sequential UUIDs can be generated',
                            'Password reset links accept brute-forced UUIDs'
                        ],
                        'failure_indicators': [
                            'UUID v4 in use (random)',
                            'Rate limiting prevents brute force',
                            'UUIDs expire quickly'
                        ],
                        'next_steps': [
                            'Identify UUID version from token format',
                            'Test with sandwich tool if v1 detected',
                            'Check for rate limiting'
                        ],
                        'alternatives': [
                            'Manual UUID generation with Python uuid module',
                            'Sequential testing without sandwich technique'
                        ],
                        'notes': 'UUID v1 exposes MAC address and timestamp - security risk'
                    }
                },
                # ReDoS attacks
                {
                    'id': f'redos-testing-{port}',
                    'name': 'Regular Expression DoS (ReDoS) Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test input validation for catastrophic backtracking in regex',
                        'evil_regex_patterns': [
                            '(a+)+',
                            '([a-zA-Z]+)*',
                            '(a|aa)+',
                            '(a|a?)+',
                            '(.*a){10}',
                            '(\\w*)+',
                            '(\\w*_)*\\w*'
                        ],
                        'payload_template': 'Send long string of repeating character + failing char',
                        'test_payloads': [
                            'aaaaaaaaaaaaaaaaaaaaaaaaaa!',
                            'v' + '_'*1000 + '!',
                            'a'*100 + 'X'
                        ],
                        'flag_explanations': {
                            'Backtracking': 'Regex engine tries multiple match paths',
                            'Catastrophic': 'Exponential time complexity with input size',
                            'Evil pattern': 'Nested quantifiers with overlapping matches'
                        },
                        'tags': ['MANUAL', 'OSCP:LOW', 'DOS'],
                        'tools': [
                            'regexploit - Find vulnerable regexes: pip install regexploit',
                            'https://devina.io/redos-checker - Online regex checker',
                            'https://github.com/tjenkinson/redos-detector'
                        ],
                        'success_indicators': [
                            'Response time increases exponentially with input length',
                            'Application timeout or hang',
                            'Server becomes unresponsive'
                        ],
                        'failure_indicators': [
                            'Linear response time (safe regex engine like RE2)',
                            'Input length limit enforced',
                            'Regex timeout configured'
                        ],
                        'next_steps': [
                            'Test with doubling input lengths (2^8, 2^10, 2^12)',
                            'Monitor response times for exponential growth',
                            'Test in username, search, email validation fields'
                        ],
                        'alternatives': [
                            'Blind ReDoS: Monitor for timeouts',
                            'String exfiltration via ReDoS timing'
                        ],
                        'notes': 'JavaScript, Python re, Java regex are vulnerable. RE2 is safe.',
                        'ctf_technique': 'Can exfiltrate strings char-by-char via timing'
                    }
                },
                # DApps testing
                {
                    'id': f'dapp-testing-{port}',
                    'name': 'Decentralized Application (DApp) Security',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test Web3 DApps for blockchain integration vulnerabilities',
                        'dapp_architecture_types': {
                            'API-less': 'Fully decentralized - only blockchain backend',
                            'API-enabled': 'Mostly decentralized - blockchain + centralized data API',
                            'Full-scale': 'Hybrid - blockchain + full backend server'
                        },
                        'web2_vulns_in_web3': [
                            'XSS - Higher impact (can interact with wallet)',
                            'Server-side vulns - May expose private keys',
                            'Account takeover - Can steal funds/NFTs',
                            'CSRF - Force unwanted blockchain transactions'
                        ],
                        'web3_attack_vectors': [
                            'Mishandled on-chain transactions',
                            'Smart-contract-driven backend attacks',
                            'Flawed crypto-asset operations',
                            'Backend/blockchain desync race conditions',
                            'Smart contract address validation bypass',
                            'Asset class confusion (scam tokens)'
                        ],
                        'test_scenarios': {
                            'Gas wasting': 'Force backend to execute expensive transactions',
                            'DoS': 'Keep HTTP requests open during transaction processing',
                            'Race condition': 'Use same coins twice before blockchain confirms',
                            'Fake contract': 'Deploy malicious contract, trick backend validation',
                            'Token confusion': 'Send scam NFTs, claim legitimate token value'
                        },
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED'],
                        'success_indicators': [
                            'Backend accepts fake smart contract address',
                            'Race condition allows double-spend',
                            'Token type confusion exploitable',
                            'Wallet interaction via XSS possible'
                        ],
                        'next_steps': [
                            'Identify DApp architecture type',
                            'Test transaction handling timing',
                            'Check smart contract address validation',
                            'Test with fake/scam tokens',
                            'Look for Web2 vulns with Web3 impact'
                        ],
                        'tools': [
                            'MetaMask - Web3 wallet for testing',
                            'Remix IDE - Smart contract interaction',
                            'Hardhat - Deploy test contracts'
                        ],
                        'notes': 'XSS in DApps can steal funds via wallet interaction - test thoroughly'
                    }
                }
            ]
        })

        # === PHASE 4: ADVANCED HTTP ATTACKS ===
        tasks['children'].append({
            'id': f'advanced-http-{port}',
            'name': 'Advanced HTTP Protocol Attacks',
            'type': 'parent',
            'children': [
                # HTTP request smuggling
                {
                    'id': f'http-smuggling-check-{port}',
                    'name': 'HTTP Request Smuggling Detection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for HTTP request smuggling via Content-Length/Transfer-Encoding discrepancies',
                        'smuggling_types': {
                            'CL.TE': 'Front-end uses Content-Length, back-end uses Transfer-Encoding',
                            'TE.CL': 'Front-end uses Transfer-Encoding, back-end uses Content-Length',
                            'TE.TE': 'Both use Transfer-Encoding but one can be obfuscated',
                            'H2C': 'HTTP/2 cleartext smuggling'
                        },
                        'detection_technique': 'Send ambiguous request and observe timing/responses',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED', 'NOISY'],
                        'tools': [
                            'Burp Suite Turbo Intruder with smuggling scripts',
                            'smuggler.py - https://github.com/defparam/smuggler',
                            'h2csmuggler - https://github.com/BishopFox/h2csmuggler'
                        ],
                        'success_indicators': [
                            'Second request gets prepended to first',
                            'Timing discrepancies between requests',
                            'Different responses when pipelined'
                        ],
                        'alternatives': [
                            'Manual crafting with netcat',
                            'Burp Repeater with manual header manipulation'
                        ],
                        'notes': 'Requires proxy chain (CDN, WAF, load balancer). Rare but critical.'
                    }
                },
                # Cache attacks
                {
                    'id': f'cache-poisoning-{port}',
                    'name': 'Cache Poisoning/Deception Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for cache poisoning via unkeyed headers',
                        'attack_types': {
                            'Cache poisoning': 'Poison cache to serve malicious content to all users',
                            'Cache deception': 'Trick cache into storing sensitive user data',
                            'Web cache deception': 'Access other users cached data via path confusion'
                        },
                        'unkeyed_headers': [
                            'X-Forwarded-Host',
                            'X-Forwarded-Proto',
                            'X-Forwarded-For',
                            'X-Original-URL',
                            'X-Rewrite-URL'
                        ],
                        'test_technique': 'Add malicious header, check if cached and served to others',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED'],
                        'success_indicators': [
                            'Injected header reflected in cached response',
                            'Other users receive poisoned cache',
                            'Sensitive data accessible via cache'
                        ],
                        'tools': [
                            'Burp Param Miner extension',
                            'Web Cache Vulnerability Scanner'
                        ],
                        'notes': 'Test with unique cache buster parameter to verify caching'
                    }
                },
                # Hop-by-hop header abuse
                {
                    'id': f'hop-by-hop-{port}',
                    'name': 'Hop-by-Hop Header Abuse',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Abuse hop-by-hop headers to bypass security controls',
                        'vulnerable_headers': [
                            'Connection: X-Custom-Header (removes X-Custom-Header)',
                            'Connection: Authorization (removes authentication)',
                            'Connection: Cookie (removes session)'
                        ],
                        'attack_technique': 'Add header to Connection to strip it before backend',
                        'tags': ['MANUAL', 'OSCP:LOW', 'ADVANCED'],
                        'test_payload': 'Connection: Authorization\\r\\nAuthorization: Bearer token',
                        'success_indicators': [
                            'Authentication bypass',
                            'Access to protected resources without credentials'
                        ],
                        'notes': 'Requires intermediary proxy. Test with curl/Burp.'
                    }
                }
            ]
        })

        # === PHASE 5: BUSINESS LOGIC & RATE LIMITING ===
        tasks['children'].append({
            'id': f'business-logic-{port}',
            'name': 'Business Logic & Timing Attacks',
            'type': 'parent',
            'children': [
                # IDOR testing
                {
                    'id': f'idor-testing-{port}',
                    'name': 'Insecure Direct Object Reference (IDOR)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for IDOR by modifying object IDs in requests',
                        'test_locations': [
                            'URL parameters: /user?id=123',
                            'Path segments: /api/users/123',
                            'POST data: {"user_id": 123}',
                            'Cookies: userid=123',
                            'Hidden form fields: <input type="hidden" name="id" value="123">'
                        ],
                        'test_technique': 'Increment/decrement IDs, try other user IDs',
                        'tags': ['MANUAL', 'OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': [
                            'Access to other users data/resources',
                            'Modified data belongs to different user',
                            'Unauthorized operations succeed'
                        ],
                        'alternatives': [
                            'Burp Intruder with number payload',
                            'Autorize extension for automated IDOR testing',
                            'Manual testing with two accounts'
                        ],
                        'notes': 'Test with different privilege levels (user vs admin)'
                    }
                },
                # Race conditions
                {
                    'id': f'race-condition-{port}',
                    'name': 'Race Condition Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for race conditions in state-changing operations',
                        'vulnerable_scenarios': [
                            'Coupon/discount code redemption',
                            'Balance/credit operations',
                            'File upload/processing',
                            'Voting/rating systems',
                            'Account creation with referral bonus'
                        ],
                        'test_technique': 'Send multiple identical requests simultaneously',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'EXPLOIT'],
                        'tools': [
                            'Burp Turbo Intruder with race condition threads',
                            'Race The Web - https://github.com/TheHackerDev/race-the-web',
                            'racepwn - https://github.com/racepwn/racepwn'
                        ],
                        'success_indicators': [
                            'Coupon applied multiple times',
                            'Balance credited multiple times',
                            'Same resource used/created multiple times'
                        ],
                        'alternatives': [
                            'Burp Repeater: Send to Intruder, use single payload, threads=20',
                            'Parallel curl requests with GNU parallel'
                        ],
                        'notes': 'Use Burp Turbo Intruder for best results (last-byte sync)'
                    }
                },
                # Rate limit bypass
                {
                    'id': f'rate-limit-bypass-{port}',
                    'name': 'Rate Limiting Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test various techniques to bypass rate limiting',
                        'bypass_techniques': [
                            'X-Forwarded-For: Spoof IP (127.0.0.1, 10.0.0.1)',
                            'X-Originating-IP, X-Remote-IP, X-Client-IP headers',
                            'Change User-Agent per request',
                            'Add null bytes to email: user@example.com\\x00',
                            'Case variation: UsEr vs user',
                            'Add whitespace: user vs user ',
                            'Different HTTP methods: GET vs POST',
                            'Different content-types: application/json vs application/x-www-form-urlencoded'
                        ],
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'BYPASS'],
                        'success_indicators': [
                            'Rate limit counter resets',
                            'Unlimited requests possible',
                            'Different IP seen by backend'
                        ],
                        'test_with': [
                            'Login brute force',
                            'Password reset spam',
                            'API endpoint enumeration'
                        ],
                        'notes': 'Combine multiple techniques for best results'
                    }
                },
                # Timing attacks
                {
                    'id': f'timing-attacks-{port}',
                    'name': 'Timing Side-Channel Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit timing differences to infer information',
                        'attack_scenarios': [
                            'Username enumeration (valid vs invalid user)',
                            'Password reset token validation',
                            'File existence checks',
                            'Cache hit vs miss',
                            'Database query optimization'
                        ],
                        'test_technique': 'Measure response times, look for consistent differences',
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'RECON'],
                        'tools': [
                            'Burp Intruder with response time column',
                            'Custom Python script with statistics'
                        ],
                        'success_indicators': [
                            'Consistent timing difference (>100ms)',
                            'Valid usernames take longer to process',
                            'Timing reveals information'
                        ],
                        'notes': 'Run multiple iterations for statistical significance'
                    }
                }
            ]
        })

        # === PHASE 6: BROWSER EXTENSION TESTING ===
        tasks['children'].append({
            'id': f'browser-extension-{port}',
            'name': 'Browser Extension Pentesting',
            'type': 'parent',
            'children': [
                {
                    'id': f'extension-recon-{port}',
                    'name': 'Extension Reconnaissance',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze browser extension attack surface',
                        'key_files': [
                            'manifest.json - Permissions and content scripts',
                            'background.js - Background page logic',
                            'content_scripts/ - Injected scripts',
                            'popup.html - Extension popup UI'
                        ],
                        'security_checks': [
                            'Excessive permissions (tabs, webRequest, cookies)',
                            'host_permissions - Broad domain access',
                            'Content Security Policy (CSP) weakness',
                            'Message passing vulnerabilities',
                            'XSS in extension pages',
                            'Clickjacking in popups'
                        ],
                        'tags': ['MANUAL', 'OSCP:LOW', 'RECON'],
                        'extraction': [
                            'Chrome: Navigate to chrome://extensions',
                            'Enable Developer Mode',
                            'Find extension ID in URL',
                            'Extract from: ~/.config/google-chrome/Default/Extensions/<ID>',
                            'Or download CRX and unzip'
                        ],
                        'notes': 'Extensions with webRequest permission can intercept all HTTP traffic'
                    }
                },
                {
                    'id': f'extension-xss-{port}',
                    'name': 'Extension XSS Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for XSS in browser extension contexts',
                        'vulnerable_areas': [
                            'Extension pages (popup.html, options.html)',
                            'Content scripts with user input',
                            'Message handlers with postMessage',
                            'chrome.storage data reflection'
                        ],
                        'xss_payloads': [
                            '<img src=x onerror=alert(1)>',
                            'javascript:alert(1)',
                            '<svg/onload=alert(1)>'
                        ],
                        'tags': ['MANUAL', 'OSCP:LOW', 'EXPLOIT'],
                        'impact': 'Extension XSS can access chrome.* APIs and steal data',
                        'notes': 'Test all user input points and storage interactions'
                    }
                }
            ]
        })

        # === PHASE 7: POLYGLOTS & POC TEMPLATES ===
        tasks['children'].append({
            'id': f'polyglot-testing-{port}',
            'name': 'Polyglot Payloads & PoC Templates',
            'type': 'manual',
            'metadata': {
                'description': 'Quick vulnerability detection with polyglot payloads',
                'polyglot_payloads': {
                    'XSS': '"><svg/onload=alert(1)>{{7*7}}${7*7}',
                    'SQLi': "' OR '1'='1' -- ",
                    'Command Injection': '; whoami; `whoami` $(whoami)',
                    'SSTI': '{{7*7}} ${7*7} <%= 7*7 %> ${{7*7}}',
                    'Path Traversal': '....//....//....//etc/passwd',
                    'XXE': '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                    'Universal': 'jaVasCript:/*-/*`/*\\`/*\'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//'
                },
                'quick_test_technique': 'Inject polyglot in all input fields, check response',
                'tags': ['QUICK_WIN', 'OSCP:HIGH', 'MANUAL'],
                'poc_templates': {
                    'XSS PoC': '<script>alert(document.domain)</script>',
                    'CSRF PoC': '<form method="POST" action="URL"><input name="param" value="value"><input type="submit"></form><script>document.forms[0].submit()</script>',
                    'Clickjacking PoC': '<iframe src="VULNERABLE_URL"></iframe>',
                    'Open Redirect': 'Redirect to attacker.com via parameter manipulation'
                },
                'success_indicators': [
                    'Mathematical expression evaluated (49 appears)',
                    'JavaScript executed',
                    'SQL error message',
                    'File contents disclosed'
                ],
                'next_steps': [
                    'Once vuln confirmed, craft specific exploit',
                    'Test for filtering/encoding bypass',
                    'Demonstrate impact with working PoC'
                ],
                'notes': 'Polyglots test multiple vulnerability types simultaneously'
            }
        })

        # === PHASE 8: PASSWORD RESET & 2FA BYPASS ===
        tasks['children'].append({
            'id': f'auth-bypass-testing-{port}',
            'name': 'Authentication Mechanism Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'password-reset-{port}',
                    'name': 'Password Reset Vulnerabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test password reset flow for security issues',
                        'test_checklist': [
                            'Token sent in URL (email logging risk)',
                            'Token predictable or brute-forceable',
                            'Token doesn\'t expire',
                            'Token reusable after password change',
                            'No rate limiting on reset requests',
                            'Host header injection (link manipulation)',
                            'Email parameter pollution (reset multiple accounts)',
                            'Response manipulation (change success message)',
                            'IDOR in reset endpoint'
                        ],
                        'tags': ['MANUAL', 'OSCP:HIGH', 'EXPLOIT'],
                        'success_indicators': [
                            'Password reset link interceptable',
                            'Token brute-forced successfully',
                            'Host header changes reset link domain',
                            'Multiple accounts reset with one request'
                        ],
                        'tools': [
                            'Burp Collaborator for out-of-band testing',
                            'Burp Intruder for token brute force'
                        ],
                        'notes': 'Check both GET and POST reset endpoints'
                    }
                },
                {
                    'id': f'2fa-bypass-{port}',
                    'name': '2FA/OTP Bypass Testing',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test two-factor authentication for bypass techniques',
                        'bypass_techniques': [
                            'Direct page access (skip 2FA page)',
                            'OTP not verified server-side',
                            'Response manipulation (success:false -> true)',
                            'OTP brute force (no rate limit)',
                            'Session fixation (use old session)',
                            'CSRF on 2FA setup/disable',
                            'Backup codes exposed',
                            'SMS OTP interception',
                            'Remember me bypass'
                        ],
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'BYPASS'],
                        'test_flow': [
                            '1. Login with credentials',
                            '2. At 2FA prompt, try direct access to protected page',
                            '3. Try invalid OTP, manipulate response',
                            '4. Test OTP brute force with Intruder',
                            '5. Check session cookies before/after 2FA'
                        ],
                        'success_indicators': [
                            'Access granted without 2FA',
                            'Invalid OTP accepted',
                            'Rate limiting bypassable'
                        ],
                        'notes': 'Always test in combination with other vulnerabilities'
                    }
                }
            ]
        })

        # === PHASE 9: PARAMETER POLLUTION & UNICODE ===
        tasks['children'].append({
            'id': f'parameter-pollution-{port}',
            'name': 'Parameter Pollution & Unicode Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'hpp-testing-{port}',
                    'name': 'HTTP Parameter Pollution (HPP)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for HPP by sending duplicate parameters',
                        'attack_examples': [
                            '?user=attacker&user=victim (backend takes second)',
                            '?amount=1&amount=99999 (which one is processed?)',
                            '?admin=false&admin=true (privilege escalation)'
                        ],
                        'backend_behavior': {
                            'PHP/Apache': 'Takes last occurrence',
                            'JSP/Tomcat': 'Takes first occurrence',
                            'ASP.NET/IIS': 'Concatenates with comma',
                            'Python/Flask': 'Returns list'
                        },
                        'tags': ['MANUAL', 'OSCP:MEDIUM', 'BYPASS'],
                        'test_technique': 'Send same parameter multiple times with different values',
                        'success_indicators': [
                            'Second parameter value used',
                            'Privilege escalation achieved',
                            'Filter bypass via pollution'
                        ],
                        'notes': 'Test in WAF bypass scenarios - split malicious payload'
                    }
                },
                {
                    'id': f'unicode-attacks-{port}',
                    'name': 'Unicode Normalization Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for Unicode normalization vulnerabilities',
                        'attack_vectors': [
                            'Homograph attacks: аdmin (Cyrillic a) vs admin',
                            'Case mapping: İstanbul vs istanbul',
                            'Normalization: café (NFC) vs café (NFD)',
                            'Overlong UTF-8: %c0%ae%c0%ae for ..',
                            'Width variants: ｓcript vs script'
                        ],
                        'test_scenarios': [
                            'Username registration (bypass existing user)',
                            'Email validation bypass',
                            'Path traversal via Unicode',
                            'Filter bypass (XSS, SQLi with Unicode)',
                            'Access control bypass'
                        ],
                        'tags': ['MANUAL', 'OSCP:LOW', 'BYPASS'],
                        'success_indicators': [
                            'Duplicate account created',
                            'Filter bypassed',
                            'Path traversal successful'
                        ],
                        'tools': [
                            'Unicode confusables: confusable_homoglyphs library',
                            'Burp Suite - Unicode normalization extension'
                        ],
                        'notes': 'Test if backend normalizes differently than frontend'
                    }
                }
            ]
        })

        return tasks


# Ensure plugin is auto-discovered
__all__ = ['WebMethodologyPlugin']
