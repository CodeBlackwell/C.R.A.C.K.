"""
Browser exploitation analysis plugin (Chrome V8, Firefox SpiderMonkey, Safari JSCore)

Generates comprehensive tasks for browser exploitation research including:
- JavaScript engine exploitation (V8, SpiderMonkey, JSCore)
- WebAssembly type confusion and JIT bugs
- Browser sandbox escape techniques
- Mojo/IPC privilege escalation
- Full-chain exploitation workflows

This plugin focuses on modern browser exploitation techniques with educational
emphasis on understanding layered browser security (V8 sandbox, renderer sandbox,
OS sandbox) and practical debugging workflows for security researchers.

Extracted from: HackTricks binary-exploitation/chrome-exploiting.md
Generated by: CrackPot v1.0 - Browser Exploitation Mining Agent
Target: CRACK Track OSCP/CTF preparation toolkit
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BrowserExploitPlugin(ServicePlugin):
    """Browser exploitation research and analysis plugin"""

    @property
    def name(self) -> str:
        return "browser-exploit"

    @property
    def default_ports(self) -> List[int]:
        # Browser exploitation often targets web services or custom research ports
        return [80, 443, 8080, 8000, 3000, 9222]  # HTTP/HTTPS + Chrome DevTools

    @property
    def service_names(self) -> List[str]:
        return [
            'http', 'https', 'http-proxy',
            'chrome', 'chromium', 'firefox', 'safari',
            'v8', 'spidermonkey', 'jscore',
            'web', 'browser'
        ]

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect browser exploitation research scenarios

        Activates when:
        - Web services hosting browser exploits (HTTP/HTTPS)
        - Chrome DevTools Protocol ports (9222, 9229)
        - Services mentioning browser engines (V8, SpiderMonkey)
        - CTF/research ports hosting browser challenges
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port', 0)
        version = port_info.get('version', '').lower()

        # Browser-related service names
        browser_indicators = [
            'chrome', 'chromium', 'firefox', 'safari',
            'v8', 'spidermonkey', 'jscore', 'webkit',
            'electron', 'node-webkit'
        ]

        # Chrome DevTools Protocol ports
        devtools_ports = [9222, 9229, 9230]

        # Check for browser-related services
        if any(indicator in service for indicator in browser_indicators):
            return True

        if any(indicator in product for indicator in browser_indicators):
            return True

        if any(indicator in version for indicator in browser_indicators):
            return True

        # Chrome DevTools Protocol detection
        if port in devtools_ports:
            return True

        # Web services could host browser exploits
        if service in ['http', 'https', 'http-proxy'] and port in [80, 443, 8000, 8080, 3000]:
            # Only activate if explicitly looking for browser exploitation
            # This prevents false positives on regular web services
            return False

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate browser exploitation research task tree"""

        version = service_info.get('version', 'unknown')
        product = service_info.get('product', 'unknown')
        service = service_info.get('service', 'unknown')

        tasks = {
            'id': f'browser-exploit-{port}',
            'name': f'Browser Exploitation Research (Port {port})',
            'type': 'parent',
            'children': []
        }

        # ===== PHASE 1: ENVIRONMENT SETUP & RECONNAISSANCE =====
        recon_tasks = {
            'id': f'browser-recon-{port}',
            'name': 'Phase 1: Reconnaissance & Environment Setup',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Chrome Architecture Analysis
        recon_tasks['children'].append({
            'id': f'chrome-arch-{port}',
            'name': 'Study Chrome Multi-Process Architecture',
            'type': 'manual',
            'metadata': {
                'description': 'Understand Chrome layered security: V8 sandbox → Renderer sandbox → OS sandbox',
                'tags': ['RESEARCH', 'OSCP:LOW', 'MANUAL', 'EDUCATIONAL'],
                'command': 'N/A - Study chromium.org architecture docs',
                'architecture_layers': [
                    '1. V8 Sandbox (Isolate): Memory permissions restrict JIT code arbitrary RW',
                    '2. Renderer Process: No direct OS access, IPC via Mojo to browser process',
                    '3. Browser Process: Full OS access, coordinates all operations',
                    '4. GPU Process: Restricted OS access for graphics operations',
                    '5. OS Sandbox: seccomp-bpf (Linux), Integrity Levels (Windows), profiles (macOS)'
                ],
                'exploitation_requirements': [
                    'Stage 1: Memory corruption in V8 for arbitrary RW in V8 heap',
                    'Stage 2: V8 sandbox escape to full renderer memory RW',
                    'Stage 3: Renderer sandbox escape for OS-level code execution'
                ],
                'notes': (
                    'Modern Chrome exploitation requires 3 separate bugs for full RCE. '
                    'Each sandbox layer must be defeated sequentially. Understanding this '
                    'architecture is critical before attempting exploit development.'
                ),
                'success_indicators': [
                    'Understand process isolation model',
                    'Can explain IPC/Mojo communication',
                    'Know which processes have OS access'
                ],
                'next_steps': [
                    'Identify target Chrome version and build',
                    'Setup local debugging environment',
                    'Research known vulnerabilities for target version'
                ],
                'references': [
                    'https://chromium.org/developers/design-documents/security',
                    'https://chromium.org/developers/design-documents/multi-process-architecture',
                    'https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/'
                ]
            }
        })

        # Task 1.2: Version Fingerprinting
        if port in [80, 443, 8000, 8080, 3000]:
            recon_tasks['children'].append({
                'id': f'browser-version-{port}',
                'name': 'Fingerprint Browser Version',
                'type': 'command',
                'metadata': {
                    'command': f'curl -s http://{target}:{port}/ | grep -i "chrome\\|firefox\\|safari\\|version"',
                    'description': 'Identify browser version from web service headers/content',
                    'tags': ['OSCP:MEDIUM', 'QUICK_WIN', 'RECON'],
                    'flag_explanations': {
                        '-s': 'Silent mode - no progress bar',
                        'grep -i': 'Case-insensitive search for browser indicators'
                    },
                    'success_indicators': [
                        'Browser version number identified (e.g., Chrome/130.0.6723.58)',
                        'JavaScript engine version detected',
                        'User-Agent header reveals browser details'
                    ],
                    'failure_indicators': [
                        'No browser version in headers',
                        'Service not HTTP-based',
                        'Connection refused'
                    ],
                    'alternatives': [
                        f'Manual: Visit http://{target}:{port}/ in browser, check DevTools Network tab',
                        f'nmap --script http-headers -p{port} {target}',
                        f'whatweb http://{target}:{port}/',
                        'Browser DevTools: navigator.userAgent in Console'
                    ],
                    'next_steps': [
                        'Search CVE databases for identified version',
                        'Check exploit-db for known browser exploits',
                        'Verify if version is vulnerable to recent CVEs'
                    ],
                    'notes': 'Accurate version fingerprinting is critical for exploit selection'
                }
            })

        # Task 1.3: Chrome DevTools Protocol Detection
        if port in [9222, 9229, 9230]:
            recon_tasks['children'].append({
                'id': f'devtools-detect-{port}',
                'name': 'Chrome DevTools Protocol Detection',
                'type': 'command',
                'metadata': {
                    'command': f'curl -s http://{target}:{port}/json/version',
                    'description': 'Query Chrome DevTools Protocol for browser version and capabilities',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON', 'CHROME'],
                    'flag_explanations': {
                        '/json/version': 'CDP endpoint returning browser version and WebSocket URL',
                        '-s': 'Silent curl output'
                    },
                    'success_indicators': [
                        'JSON response with Browser, Protocol-Version, User-Agent, V8-Version',
                        'webSocketDebuggerUrl present for remote debugging',
                        'Chrome version clearly identified'
                    ],
                    'failure_indicators': [
                        'Connection refused - DevTools not enabled',
                        '404 Not Found - wrong endpoint',
                        'Non-JSON response'
                    ],
                    'alternatives': [
                        f'Manual: Visit http://{target}:{port}/ in browser',
                        f'curl http://{target}:{port}/json/list - list all debuggable pages',
                        'Chrome: chrome://inspect/#devices - connect to remote instance'
                    ],
                    'next_steps': [
                        'Connect Chrome DevTools for remote debugging',
                        'Extract V8 version for targeted exploit research',
                        'Test if arbitrary JavaScript execution is possible'
                    ],
                    'notes': (
                        'Exposed Chrome DevTools Protocol is CRITICAL finding - allows remote '
                        'JavaScript execution, heap inspection, and direct browser control. '
                        'Document this immediately as HIGH severity vulnerability.'
                    )
                }
            })

        # Task 1.4: Exploit Development Environment Setup
        recon_tasks['children'].append({
            'id': f'lab-setup-{port}',
            'name': 'Setup Browser Exploitation Lab',
            'type': 'manual',
            'metadata': {
                'description': 'Configure local environment for browser exploit development and debugging',
                'tags': ['RESEARCH', 'SETUP', 'MANUAL'],
                'command': 'Multiple setup commands - see notes',
                'setup_steps': [
                    '1. Clone Chromium exploit research repo',
                    '2. Setup local HTTP server for PoC hosting',
                    '3. Configure debugger (WinDbg for Windows, GDB for Linux)',
                    '4. Download target Chrome version for testing'
                ],
                'commands': {
                    'clone_repo': 'git clone https://github.com/Petitoto/chromium-exploit-dev',
                    'http_server': 'npm i -g http-server && http-server -p 8000 -c -1',
                    'windbg_symbols': (
                        'windbgx.exe -symbolpath '
                        'srv*C:\\symbols*https://msdl.microsoft.com/download/symbols'
                    ),
                    'chrome_dev_flags': (
                        'chrome.exe --no-sandbox --disable-gpu --single-process '
                        '--js-flags="--allow-natives-syntax"'
                    )
                },
                'flag_explanations': {
                    '--no-sandbox': 'Disable all sandboxes (DANGEROUS - testing only)',
                    '--disable-gpu': 'Disable GPU process for simpler debugging',
                    '--single-process': 'Run all in one process (defeats multi-process architecture)',
                    '--allow-natives-syntax': 'Enable V8 internal functions like %DebugPrint(), %OptimizeFunctionOnNextCall()'
                },
                'success_indicators': [
                    'Local HTTP server running and accessible',
                    'Chrome launches with dev flags successfully',
                    'Debugger connects to Chrome process',
                    'Test PoC HTML/JS loads correctly'
                ],
                'failure_indicators': [
                    'Chrome crashes immediately with dev flags',
                    'HTTP server port conflict',
                    'Debugger cannot attach to process'
                ],
                'next_steps': [
                    'Test basic JavaScript execution in controlled environment',
                    'Verify debugger breakpoints work correctly',
                    'Load sample WebAssembly module to test infrastructure'
                ],
                'notes': (
                    'SECURITY WARNING: Never browse untrusted sites with --no-sandbox flag. '
                    'Development builds with these flags are for local testing only. '
                    'Production exploitation uses standard Chrome without debug flags.'
                ),
                'alternatives': [
                    'Docker container with vulnerable Chrome version',
                    'Virtual machine for isolated testing',
                    'Use Chromium instead of Chrome for easier symbol access'
                ]
            }
        })

        tasks['children'].append(recon_tasks)

        # ===== PHASE 2: STAGE 1 - V8 HEAP CORRUPTION =====
        stage1_tasks = {
            'id': f'v8-corruption-{port}',
            'name': 'Phase 2: Stage 1 - V8 Heap Corruption (Arbitrary R/W)',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: WebAssembly Type Confusion Research
        stage1_tasks['children'].append({
            'id': f'wasm-typeconf-{port}',
            'name': 'WebAssembly Type Confusion Analysis (CVE-2025-0291 class)',
            'type': 'manual',
            'metadata': {
                'description': (
                    'Research WebAssembly type confusion in TurboFan Turboshaft optimizer. '
                    'Focus on WasmGC reference type misclassification in single-block loops.'
                ),
                'tags': ['RESEARCH', 'OSCP:LOW', 'WASM', 'V8', 'JIT'],
                'vulnerability_class': 'Type Confusion in JIT Compiler Optimization',
                'affected_component': 'V8 TurboFan Turboshaft (WasmGC reference type handling)',
                'exploit_primitive': 'addrOf() and fakeObj() for arbitrary read/write in V8 heap',
                'bug_summary': (
                    'TurboFan mis-classifies WasmGC reference types (externref/anyref) as int64 '
                    'when value is produced and consumed in single basic block loop. Compiler '
                    'skips type checks, allowing object header overlap with attacker data.'
                ),
                'minimal_poc': '''
(module
  (type $t0 (func (param externref) (result externref)))
  (func $f (param $p externref) (result externref)
    (local $l externref)
    block $exit
      loop $loop
        local.get $p      ;; value with real ref-type
        ;; compiler incorrectly re-uses it as int64 in same block
        br_if $exit       ;; exit condition keeps single-block
        br   $loop
      end
    end)
  (export "f" (func $f)))
''',
                'exploitation_steps': [
                    '1. Compile malicious WebAssembly module with type confusion',
                    '2. Trigger JIT optimization (warm-up with 100k+ calls)',
                    '3. Spray objects to control heap layout',
                    '4. Construct addrOf() primitive (leak object addresses)',
                    '5. Construct fakeObj() primitive (create fake objects)',
                    '6. Achieve arbitrary read/write within V8 heap'
                ],
                'javascript_integration': '''
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

// Warm-up JIT compiler
for (let i = 0; i < 1e5; ++i) f({});

// Primitives
let victim = {m: 13.37};
let fake = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
''',
                'success_indicators': [
                    'WebAssembly module compiles successfully',
                    'JIT optimization triggered (verify with --trace-opt)',
                    'addrOf() returns consistent addresses',
                    'fakeObj() creates controllable objects',
                    'Arbitrary V8 heap read/write confirmed'
                ],
                'failure_indicators': [
                    'Type confusion patched in Chrome version',
                    'JIT optimization not triggered',
                    'Heap layout randomization defeats exploit',
                    'Chrome crashes before primitives established'
                ],
                'next_steps': [
                    'Test PoC in target Chrome version',
                    'Adapt exploit to specific V8 version heap layout',
                    'Verify primitives work reliably (test 100+ times)',
                    'Proceed to Stage 2 sandbox escape'
                ],
                'notes': (
                    'CVE-2025-0291 is example from HackTricks research. Check target Chrome '
                    'version for similar TurboFan/Turboshaft bugs. Modern V8 has extensive '
                    'JIT bug history - searchsploit "v8" shows many candidates.'
                ),
                'alternatives': [
                    'JIT type confusion in array operations',
                    'ArrayBuffer neutering bugs',
                    'RegExp JIT compilation bugs',
                    'Optimize-deoptimize confusion in Turbofan'
                ],
                'debugging_tips': [
                    'Use --trace-opt to verify JIT compilation',
                    'Use %DebugPrint(obj) to inspect V8 objects',
                    'Use %OptimizeFunctionOnNextCall(f) to force JIT',
                    'GDB: break v8::internal::Execution::Call for JS→native'
                ]
            }
        })

        # Task 2.2: Heap Spraying & Memory Layout
        stage1_tasks['children'].append({
            'id': f'heap-spray-{port}',
            'name': 'V8 Heap Spraying & Memory Layout Control',
            'type': 'manual',
            'metadata': {
                'description': 'Control V8 heap layout to ensure reliable exploitation',
                'tags': ['RESEARCH', 'MANUAL', 'V8', 'HEAP'],
                'techniques': [
                    'ArrayBuffer spraying for predictable large object layout',
                    'Typed array spraying for controlled data regions',
                    'Object spraying to surround target with known data',
                    'Hole spraying to create gaps for corruption targets'
                ],
                'spray_example': '''
// Spray ArrayBuffers to control large object space
let spray = [];
for (let i = 0; i < 1000; i++) {
    spray.push(new ArrayBuffer(0x100000));  // 1MB buffers
}

// Spray typed arrays for data control
let dataSpray = [];
for (let i = 0; i < 1000; i++) {
    let arr = new Uint32Array(0x1000);
    arr.fill(0x41414141);  // Marker pattern
    dataSpray.push(arr);
}
''',
                'success_indicators': [
                    'Heap layout becomes predictable across runs',
                    'Target objects allocated in expected regions',
                    'Corruption reaches intended victim objects',
                    'No random crashes from wrong memory targets'
                ],
                'failure_indicators': [
                    'Heap layout varies significantly between runs',
                    'Out-of-memory errors during spray',
                    'Corruption hits wrong objects causing crashes'
                ],
                'next_steps': [
                    'Integrate spray with Stage 1 type confusion',
                    'Test reliability (90%+ success rate target)',
                    'Minimize spray size for faster exploitation'
                ],
                'notes': (
                    'V8 has multiple heap spaces (new, old, large object). Understanding '
                    'object allocation patterns is key to reliable exploitation. Use '
                    '--trace-gc flag to observe allocations.'
                ),
                'alternatives': [
                    'GC manipulation to control compaction',
                    'Inline cache poisoning for predictable shapes',
                    'Feedback vector manipulation'
                ]
            }
        })

        # Task 2.3: Primitive Verification
        stage1_tasks['children'].append({
            'id': f'primitive-verify-{port}',
            'name': 'Verify V8 Heap R/W Primitives',
            'type': 'manual',
            'metadata': {
                'description': 'Test and validate arbitrary read/write primitives in V8 heap',
                'tags': ['RESEARCH', 'MANUAL', 'V8', 'VALIDATION'],
                'command': 'N/A - JavaScript testing in browser console',
                'verification_tests': [
                    '1. addrOf() consistency: Same object returns same address',
                    '2. Read primitive: Read known object properties via address',
                    '3. Write primitive: Modify object properties via address',
                    '4. Cross-object write: Modify object A by writing to object B address',
                    '5. Reliability: Primitives work 100/100 attempts without crash'
                ],
                'test_code': '''
// Test addrOf consistency
let obj = {test: 0x1337};
let addr1 = addrOf(obj);
let addr2 = addrOf(obj);
console.assert(addr1 === addr2, "addrOf inconsistent!");

// Test read primitive
let value = read64(addr1 + 0x10);  // Read property offset
console.log("Read value:", value.toString(16));

// Test write primitive
write64(addr1 + 0x10, 0x4141414142424242n);
console.assert(obj.test === 0x4141414142424242n, "Write failed!");
''',
                'success_indicators': [
                    'addrOf() returns consistent addresses',
                    'Read primitive retrieves correct values',
                    'Write primitive modifies target objects',
                    'No crashes during primitive operations',
                    '100% reliability in test runs'
                ],
                'failure_indicators': [
                    'addrOf() returns different addresses for same object',
                    'Read returns garbage data',
                    'Write causes crashes',
                    'Primitives fail intermittently'
                ],
                'next_steps': [
                    'Document primitive offsets for target V8 version',
                    'Build helper functions for complex operations',
                    'Proceed to Stage 2 V8 sandbox escape'
                ],
                'notes': (
                    'Reliable primitives are foundation for remaining exploit stages. '
                    'If success rate < 95%, revisit heap spray or type confusion trigger.'
                )
            }
        })

        tasks['children'].append(stage1_tasks)

        # ===== PHASE 3: STAGE 2 - V8 SANDBOX ESCAPE =====
        stage2_tasks = {
            'id': f'v8-sandbox-escape-{port}',
            'name': 'Phase 3: Stage 2 - V8 Sandbox Escape (Renderer R/W)',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Wasm Wrapper Bug Research
        stage2_tasks['children'].append({
            'id': f'wasm-wrapper-{port}',
            'name': 'WebAssembly Wrapper Tier-Up Bug (issue 379140430 class)',
            'type': 'manual',
            'metadata': {
                'description': (
                    'Exploit Wasm tier-up wrapper generation bug to escape V8 sandbox. '
                    'Bug causes wrapper to write past Tuple2 object during re-optimization.'
                ),
                'tags': ['RESEARCH', 'OSCP:LOW', 'WASM', 'SANDBOX_ESCAPE'],
                'vulnerability_class': 'Out-of-bounds write during JIT wrapper generation',
                'affected_component': 'V8 WebAssembly tier-up wrapper generator',
                'exploit_primitive': 'Full renderer process arbitrary read/write (bypasses V8 sandbox)',
                'bug_summary': (
                    'When Wasm function is re-optimized while still on call stack, tier-up '
                    'wrapper generation writes past end of trusted Tuple2 object. Corrupting '
                    'Tuple2 fields provides R/W anywhere in renderer process memory.'
                ),
                'exploitation_steps': [
                    '1. Create Wasm function and tier-up to optimized code',
                    '2. Alternate between turbofan/baseline to control tier-up state',
                    '3. Trigger tier-up while function reference is on stack (Function.apply)',
                    '4. Use Stage 1 primitives to find adjacent Tuple2 object',
                    '5. Corrupt Tuple2 64-bit fields to control R/W target',
                    '6. Achieve full renderer process arbitrary R/W'
                ],
                'trigger_code': '''
function wrapperGen(arg) {
  return f(arg);  // f is Wasm function
}

// Force tier-up (requires --allow-natives-syntax)
%WasmTierUpFunction(f);
wrapperGen(0x1337n);

// Alternate optimization levels
for (let i = 0; i < 10; i++) {
    %OptimizeFunctionOnNextCall(wrapperGen);
    wrapperGen(0);
    %DeoptimizeFunction(wrapperGen);
}
''',
                'tuple2_corruption': (
                    'Tuple2 is trusted V8 object with two 64-bit fields. Overwriting these '
                    'with attacker-controlled addresses breaks V8 sandbox isolation. '
                    'Use Stage 1 heap R/W to scan for Tuple2 pattern, then corrupt.'
                ),
                'success_indicators': [
                    'Tier-up wrapper generated successfully',
                    'Tuple2 object located in heap',
                    'Tuple2 corruption achieved without crash',
                    'Renderer process memory readable/writable',
                    'V8 sandbox constraints no longer apply'
                ],
                'failure_indicators': [
                    'Wrapper bug patched in target version',
                    'Tuple2 not found in expected heap region',
                    'Corruption causes immediate crash',
                    'R/W primitives still constrained to V8 heap'
                ],
                'next_steps': [
                    'Build renderer R/W primitives on top of Tuple2 corruption',
                    'Scan renderer memory for useful gadgets/pointers',
                    'Proceed to Stage 3 sandbox escape (IPC/Mojo)',
                    'Identify code execution targets in renderer process'
                ],
                'notes': (
                    'Issue 379140430 is example from research. Similar bugs exist in other '
                    'Wasm/JS interop scenarios. Key pattern: trusted object corruption during '
                    'optimization state transitions. Check Chrome bug tracker for similar issues.'
                ),
                'alternatives': [
                    'ArrayBuffer backing store pointer corruption',
                    'External pointer table corruption (V8 sandbox v2)',
                    'Trusted pointer field corruption in V8 objects',
                    'JIT code cache manipulation'
                ],
                'debugging_tips': [
                    'Use %DebugPrint() to dump Tuple2 object structure',
                    'GDB: break on WasmCode::tier_up_finished',
                    'Monitor wrapper generation with --trace-wasm-compiler',
                    'Check sandbox status: chrome://sandbox in Chrome'
                ]
            }
        })

        # Task 3.2: Renderer Memory Exploration
        stage2_tasks['children'].append({
            'id': f'renderer-memory-{port}',
            'name': 'Renderer Process Memory Layout Analysis',
            'type': 'manual',
            'metadata': {
                'description': 'Map renderer process memory to find exploitation targets',
                'tags': ['RESEARCH', 'MANUAL', 'MEMORY_ANALYSIS'],
                'analysis_targets': [
                    'Code regions: JIT code cache, native library code',
                    'Data regions: Heap objects, global variables, vtables',
                    'Stack regions: Return addresses, saved registers',
                    'Shared memory: Renderer↔Browser shared buffers'
                ],
                'useful_structures': [
                    'V8 Isolate pointer (entry point to all V8 internals)',
                    'Blink Document/Node objects (DOM manipulation)',
                    'Mojo interface pointers (IPC communication)',
                    'Function pointers (potential ROP/JOP gadgets)',
                    'Credential storage (session tokens, passwords)'
                ],
                'memory_scanning': '''
// Scan renderer memory for pointer patterns
function scanMemory(start, end, pattern) {
    for (let addr = start; addr < end; addr += 8n) {
        let value = read64(addr);
        if ((value & 0xFFFFFFFFFFFF0000n) === pattern) {
            console.log(`Found pattern at: ${addr.toString(16)}`);
        }
    }
}

// Look for Mojo interface pointers
scanMemory(0x100000000n, 0x200000000n, 0x0000555555550000n);
''',
                'success_indicators': [
                    'Key structures located reliably',
                    'Memory layout consistent across restarts',
                    'Useful pointers identified for Stage 3',
                    'No crashes during memory scanning'
                ],
                'failure_indicators': [
                    'ASLR makes addresses unpredictable',
                    'Memory scans cause crashes',
                    'Cannot find required structures',
                    'Layout varies too much between runs'
                ],
                'next_steps': [
                    'Document useful structure offsets',
                    'Build information leak primitives',
                    'Identify Mojo interface targets for Stage 3',
                    'Prepare ROP/JOP chains if needed'
                ],
                'notes': (
                    'Renderer process has ASLR but predictable relative offsets. '
                    'Leak one address, calculate others. Focus on Mojo interfaces '
                    'as they provide path to browser process.'
                )
            }
        })

        tasks['children'].append(stage2_tasks)

        # ===== PHASE 4: STAGE 3 - SANDBOX ESCAPE =====
        stage3_tasks = {
            'id': f'sandbox-escape-{port}',
            'name': 'Phase 4: Stage 3 - OS Sandbox Escape (RCE)',
            'type': 'parent',
            'children': []
        }

        # Task 4.1: Mojo IPC Interface Research
        stage3_tasks['children'].append({
            'id': f'mojo-ipc-{port}',
            'name': 'Mojo IPC Privilege Escalation (CVE-2024-11114 class)',
            'type': 'manual',
            'metadata': {
                'description': (
                    'Exploit logic flaws in Mojo IPC interfaces to escape sandbox. '
                    'Focus on DragService.startDragging() for arbitrary file execution.'
                ),
                'tags': ['RESEARCH', 'OSCP:LOW', 'IPC', 'SANDBOX_ESCAPE'],
                'vulnerability_class': 'Logic flaw in privileged IPC interface',
                'affected_component': 'blink.mojom.DragService',
                'exploit_primitive': 'Arbitrary file drag-and-drop execution from renderer',
                'bug_summary': (
                    'DragService.startDragging() accepts partially-trusted DragData from '
                    'renderer with attacker-controlled file path. Browser process performs '
                    'native drag-and-drop outside sandbox. Dragging executable to Desktop '
                    'triggers auto-execution on Windows.'
                ),
                'exploitation_steps': [
                    '1. Use Stage 2 primitives to craft malicious DragData structure',
                    '2. Drop payload executable to world-writable location (C:\\Users\\Public)',
                    '3. Call DragService.startDragging() with payload path',
                    '4. Browser process drags file to Desktop',
                    '5. Windows auto-executes file (or user double-clicks)',
                    '6. Payload runs outside all Chrome sandboxes'
                ],
                'poc_code': '''
// Simplified PoC (requires Mojo interface access from Stage 2)
const payloadPath = "C:\\\\Users\\\\Public\\\\explorer.exe";

// Craft drag data structure
const dragData = {
    type: "DragStart",
    data: {
        title: "MyFile",
        file_path: payloadPath,
        mime_type: "application/x-msdownload"
    }
};

// Trigger Mojo IPC (actual implementation requires Mojo bindings)
chrome.webview.postMessage(dragData);
''',
                'success_indicators': [
                    'Mojo DragService interface accessible from renderer',
                    'DragData structure crafted correctly',
                    'Browser process accepts drag request',
                    'File dragged to Desktop successfully',
                    'Payload executes outside sandbox',
                    'Full RCE achieved'
                ],
                'failure_indicators': [
                    'Mojo interface not accessible',
                    'DragData validation rejects payload path',
                    'Browser process crashes on drag attempt',
                    'File not executed automatically',
                    'Payload blocked by antivirus/AMSI'
                ],
                'next_steps': [
                    'Test full exploit chain end-to-end',
                    'Create reverse shell payload for C2',
                    'Evade antivirus detection if needed',
                    'Document complete RCE chain for report'
                ],
                'notes': (
                    'CVE-2024-11114 is one example. Other Mojo interfaces with logic flaws: '
                    'FileSystemManager (path traversal), ClipboardHost (data exfiltration), '
                    'GeolocationService (privacy), etc. Mojo audit is high-value target.'
                ),
                'alternatives': [
                    'GPU process escape via Vulkan/OpenGL bugs',
                    'Network service exploitation (DNS rebinding)',
                    'Extension API abuse (if extensions enabled)',
                    'Utility process privilege escalation'
                ],
                'alternative_platforms': {
                    'Linux': 'seccomp-bpf bypass or kernel exploit required',
                    'macOS': 'Sandbox profile bypass or signed code execution',
                    'Windows': 'DragDrop, COM, or Kernel exploit'
                }
            }
        })

        # Task 4.2: Full Chain Integration
        stage3_tasks['children'].append({
            'id': f'full-chain-{port}',
            'name': 'Integrate Full Exploitation Chain',
            'type': 'manual',
            'metadata': {
                'description': 'Combine all stages into reliable full-chain browser RCE exploit',
                'tags': ['RESEARCH', 'MANUAL', 'INTEGRATION'],
                'chain_overview': [
                    'Stage 1: WebAssembly type confusion → V8 heap R/W',
                    'Stage 2: Wasm wrapper bug → Renderer process R/W',
                    'Stage 3: Mojo IPC DragService → OS sandbox escape',
                    'Result: Remote Code Execution on host system'
                ],
                'integration_checklist': [
                    '✓ Stage 1 primitives work reliably (95%+ success)',
                    '✓ Stage 2 sandbox escape tested and validated',
                    '✓ Stage 3 payload delivers and executes',
                    '✓ Full chain tested end-to-end 10+ times',
                    '✓ Reliability optimized (heap spray, GC manipulation)',
                    '✓ Payload evades antivirus/EDR',
                    '✓ Exploit timing optimized for speed',
                    '✓ Cleanup code prevents forensic detection'
                ],
                'weaponization_steps': [
                    '1. Package all stages into single HTML/JS delivery',
                    '2. Obfuscate JavaScript to evade static analysis',
                    '3. Add browser version detection (fail gracefully)',
                    '4. Implement reverse shell or beacon payload',
                    '5. Test against target environment',
                    '6. Setup C2 infrastructure for callbacks'
                ],
                'delivery_methods': [
                    'Social engineering: Email with malicious link',
                    'Watering hole: Compromise frequently-visited site',
                    'Malvertising: Inject into ad networks',
                    'MITM: Inject into HTTP traffic on network',
                    'XSS: Deliver via reflected/stored XSS'
                ],
                'success_indicators': [
                    'User visits malicious page',
                    'All three stages execute successfully',
                    'Payload callback received on C2 server',
                    'Full system access achieved',
                    'Exploit works consistently across test runs'
                ],
                'failure_indicators': [
                    'Browser crashes during any stage',
                    'Sandbox escapes fail intermittently',
                    'Payload blocked by security software',
                    'Network detection alerts triggered'
                ],
                'next_steps': [
                    'Post-exploitation: Establish persistence',
                    'Lateral movement if in corporate network',
                    'Data exfiltration from compromised system',
                    'Clean up traces to avoid detection'
                ],
                'notes': (
                    'ETHICAL NOTE: Full-chain browser exploits are extremely powerful. '
                    'Only use in authorized security research, bug bounty programs, or '
                    'with explicit written permission. Unauthorized use is illegal.'
                ),
                'responsible_disclosure': [
                    'Report to Chrome security team: security@chromium.org',
                    'Follow 90-day disclosure policy',
                    'Provide detailed technical writeup',
                    'Do not publish exploit code until patched',
                    'Claim bug bounty if eligible (up to $100k+)'
                ]
            }
        })

        tasks['children'].append(stage3_tasks)

        # ===== PHASE 5: RESEARCH & CVE HUNTING =====
        research_tasks = {
            'id': f'browser-research-{port}',
            'name': 'Phase 5: Vulnerability Research & CVE Hunting',
            'type': 'parent',
            'children': []
        }

        # Task 5.1: Search Known Vulnerabilities
        research_tasks['children'].append({
            'id': f'cve-search-{port}',
            'name': 'Search Browser Vulnerability Databases',
            'type': 'command',
            'metadata': {
                'command': f'searchsploit chrome v8 | grep -i "remote"',
                'description': 'Search ExploitDB for Chrome/V8 remote code execution exploits',
                'tags': ['OSCP:HIGH', 'RESEARCH', 'QUICK_WIN'],
                'flag_explanations': {
                    'searchsploit': 'Search ExploitDB offline mirror',
                    'chrome v8': 'Search terms for Chrome browser and V8 engine',
                    'grep -i "remote"': 'Filter for remote exploitation (vs local)',
                },
                'success_indicators': [
                    'List of known Chrome/V8 exploits returned',
                    'CVE numbers identified for research',
                    'Exploit code available for study'
                ],
                'failure_indicators': [
                    'No results found',
                    'searchsploit not installed',
                    'Database outdated'
                ],
                'alternatives': [
                    'searchsploit firefox spidermonkey',
                    'searchsploit webkit safari',
                    'Online: https://www.exploit-db.com/',
                    'Google: site:bugs.chromium.org "remote code execution"',
                    'GitHub: chrome exploit OR v8 exploit language:javascript'
                ],
                'next_steps': [
                    'Review CVE technical details',
                    'Download PoC code for analysis',
                    'Test if target version is vulnerable',
                    'Adapt exploit to specific environment'
                ],
                'notes': (
                    'Chrome has extensive public bug tracker (bugs.chromium.org) with '
                    'detailed technical analysis. Many bugs have PoC code. V8 JIT bugs '
                    'are particularly common and well-documented.'
                )
            }
        })

        # Task 5.2: Chrome Bug Tracker Mining
        research_tasks['children'].append({
            'id': f'chrome-bugs-{port}',
            'name': 'Mine Chrome Bug Tracker for Security Issues',
            'type': 'manual',
            'metadata': {
                'description': 'Research public Chrome/Chromium bug tracker for vulnerability patterns',
                'tags': ['RESEARCH', 'OSCP:MEDIUM', 'MANUAL'],
                'command': 'N/A - Web browser research',
                'research_targets': [
                    'bugs.chromium.org - Official Chromium bug tracker',
                    'crbug.com - Short URL for bug tracker',
                    'chromium-review.googlesource.com - Code review platform'
                ],
                'search_queries': [
                    'Type=Bug-Security component:Blink>JavaScript',
                    'Type=Bug-Security component:Blink>WebAssembly',
                    'Security_Severity=High status:Fixed',
                    'CVE- component:V8 (find CVE-tagged bugs)',
                    'Sandbox escape Mojo (IPC sandbox bypasses)'
                ],
                'high_value_components': [
                    'Blink>JavaScript (V8 JIT bugs)',
                    'Blink>WebAssembly (Wasm compilation)',
                    'Blink>SecurityFeature>SiteIsolation',
                    'Internals>Mojo (IPC interfaces)',
                    'Internals>Sandbox (sandbox escapes)',
                    'Blink>DOM (DOM manipulation bugs)'
                ],
                'bug_analysis_checklist': [
                    '✓ Read bug description and root cause',
                    '✓ Find commit that fixed the bug',
                    '✓ Analyze patch to understand vulnerability',
                    '✓ Look for PoC in attachments or comments',
                    '✓ Check affected versions/branches',
                    '✓ Find similar bugs (duplicate/related)',
                    '✓ Test if variants exist in current version'
                ],
                'success_indicators': [
                    'Understand common bug patterns in Chrome',
                    'Found unfixed variants of patched bugs',
                    'Identified 0-day research directions',
                    'Built knowledge base of exploitation techniques'
                ],
                'next_steps': [
                    'Create bug pattern library for fuzzing',
                    'Develop custom fuzzers for identified patterns',
                    'Write proof-of-concept exploits',
                    'Submit bugs to Chrome VRP (Vulnerability Reward Program)'
                ],
                'notes': (
                    'Chrome VRP pays significant bounties: $5k-$100k+ for RCE chains. '
                    'Bug tracker often has detailed technical analysis before public CVE. '
                    'Study patch commits to understand what was broken.'
                ),
                'alternative_sources': [
                    'Mozilla Bugzilla - Firefox vulnerabilities',
                    'WebKit Bugzilla - Safari vulnerabilities',
                    'Zero Day Initiative advisories',
                    'Google Project Zero blog',
                    'Exodus Intelligence threat reports'
                ]
            }
        })

        # Task 5.3: Fuzzing & 0-day Research
        research_tasks['children'].append({
            'id': f'fuzzing-{port}',
            'name': 'Setup Browser Fuzzing Infrastructure',
            'type': 'manual',
            'metadata': {
                'description': 'Configure fuzzing tools for 0-day discovery in browser components',
                'tags': ['RESEARCH', 'OSCP:LOW', 'FUZZING', 'ADVANCED'],
                'fuzzing_tools': {
                    'domato': 'DOM fuzzer by Google Project Zero (JavaScript/HTML)',
                    'fuzzilli': 'JavaScript engine fuzzer (V8, SpiderMonkey, JSCore)',
                    'domfuzz': 'Mozilla DOM fuzzer',
                    'dharma': 'Grammar-based fuzzer framework',
                    'libfuzzer': 'Coverage-guided fuzzer (for V8/Chromium)',
                    'AFL++': 'American Fuzzy Lop (browser component fuzzing)'
                },
                'setup_commands': {
                    'domato': 'git clone https://github.com/googleprojectzero/domato',
                    'fuzzilli': 'git clone https://github.com/googleprojectzero/fuzzilli',
                    'chrome_instrumented': 'Build Chromium with ASAN and coverage flags'
                },
                'fuzzing_targets': [
                    'V8 JIT compiler (TurboFan, Turboshaft)',
                    'WebAssembly compiler and runtime',
                    'DOM manipulation APIs',
                    'IndexedDB and storage APIs',
                    'Audio/Video codecs',
                    'WebGL and Canvas rendering',
                    'CSS parser and layout engine'
                ],
                'instrumentation_flags': '''
# Build Chromium with sanitizers for fuzzing
gn args out/Fuzzer
is_asan = true
is_lsan = true
is_ubsan = true
use_libfuzzer = true
enable_nacl = false
''',
                'success_indicators': [
                    'Fuzzer running and generating test cases',
                    'Code coverage increasing over time',
                    'Crashes discovered and triaged',
                    'Unique bugs identified (not duplicates)',
                    'Reproducible PoCs created'
                ],
                'failure_indicators': [
                    'Fuzzer not finding new code paths',
                    'Only known crashes discovered',
                    'Performance too slow (< 100 exec/sec)',
                    'Crashes not reproducible'
                ],
                'next_steps': [
                    'Triage crashes to identify security impact',
                    'Develop exploits for high-impact bugs',
                    'Report bugs to Chrome VRP',
                    'Publish research on novel bug classes'
                ],
                'notes': (
                    'Fuzzing requires significant compute resources. Cloud fuzzing '
                    '(ClusterFuzz, OSS-Fuzz) can run 1000s of VMs. Local fuzzing useful '
                    'for targeted research. Expect days/weeks for meaningful results.'
                ),
                'responsible_research': [
                    'Report all security bugs to vendor',
                    'Do not weaponize unpatched 0-days',
                    'Follow coordinated disclosure timeline',
                    'Contribute fuzzers to OSS-Fuzz for community'
                ]
            }
        })

        tasks['children'].append(research_tasks)

        # ===== PHASE 6: ALTERNATIVE BROWSERS =====
        alternative_browsers = {
            'id': f'alt-browsers-{port}',
            'name': 'Phase 6: Alternative Browser Targets',
            'type': 'parent',
            'children': []
        }

        # Task 6.1: Firefox/SpiderMonkey
        alternative_browsers['children'].append({
            'id': f'firefox-{port}',
            'name': 'Firefox SpiderMonkey Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Research Firefox JavaScript engine (SpiderMonkey) vulnerabilities',
                'tags': ['RESEARCH', 'OSCP:LOW', 'FIREFOX'],
                'engine': 'SpiderMonkey (Mozilla JavaScript engine)',
                'key_differences_from_v8': [
                    'Different JIT compilers: IonMonkey (opt) vs Baseline',
                    'Different object model and shapes',
                    'Different sandbox implementation',
                    'Different IPC mechanism (not Mojo)',
                    'Different heap layout and GC'
                ],
                'common_bug_classes': [
                    'IonMonkey type inference bugs',
                    'Baseline compiler bugs',
                    'Shape/property optimization bugs',
                    'RegExp JIT bugs',
                    'WebAssembly compilation bugs'
                ],
                'research_resources': [
                    'Mozilla Bugzilla: https://bugzilla.mozilla.org/',
                    'SpiderMonkey source: https://searchfox.org/mozilla-central/source/js/src',
                    'Firefox exploits: searchsploit firefox',
                    'Pwn2Own Firefox exploits (disclosed after event)'
                ],
                'exploitation_differences': [
                    'Firefox: Often easier to get initial RW (fewer mitigations)',
                    'Firefox: Sandbox escape can be harder (Linux: seccomp tight)',
                    'Firefox: Less public research than Chrome',
                    'Firefox: Smaller attack surface (no Mojo complexity)'
                ],
                'next_steps': [
                    'Study recent Firefox CVEs',
                    'Build Firefox with debug symbols',
                    'Test PoCs from exploit-db',
                    'Adapt Chrome techniques to SpiderMonkey'
                ],
                'notes': (
                    'Firefox has smaller market share than Chrome but still significant. '
                    'SpiderMonkey bugs often overlooked compared to V8. Good target for '
                    'original research with less competition.'
                )
            }
        })

        # Task 6.2: Safari/WebKit
        alternative_browsers['children'].append({
            'id': f'safari-{port}',
            'name': 'Safari WebKit/JavaScriptCore Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Research Safari JavaScript engine (JSCore) and WebKit vulnerabilities',
                'tags': ['RESEARCH', 'OSCP:LOW', 'SAFARI', 'WEBKIT'],
                'engine': 'JavaScriptCore (Apple JavaScript engine in WebKit)',
                'key_differences': [
                    'Different JIT: DFG (Data Flow Graph) and FTL (Faster Than Light)',
                    'Different GC: Riptide generational GC',
                    'macOS/iOS specific sandbox',
                    'WebKit Bugzilla for bug tracker',
                    'Closed-source on iOS (reverse engineering required)'
                ],
                'high_value_target': (
                    'Safari iOS is extremely high-value target. iOS jailbreaks often '
                    'start with Safari WebKit bug. Apple pays up to $1M bounties for '
                    'iOS exploit chains. Pwn2Own offers $100k+ for Safari exploits.'
                ),
                'common_bug_classes': [
                    'DFG/FTL JIT type confusion',
                    'JSObject property storage bugs',
                    'WebKit DOM use-after-free',
                    'CSS/layout engine bugs',
                    'SVG parsing vulnerabilities'
                ],
                'research_resources': [
                    'WebKit Bugzilla: https://bugs.webkit.org/',
                    'WebKit source: https://github.com/WebKit/WebKit',
                    'iOS jailbreak source code (checkra1n, unc0ver, etc)',
                    'Apple Security Research Device Program'
                ],
                'ios_specific_challenges': [
                    'PAC (Pointer Authentication Codes) on A12+',
                    'PPL (Page Protection Layer) for kernel',
                    'Sandbox very restrictive',
                    'No ASLR slide leak from dyld on iOS 14+',
                    'No RWX pages (JIT hardening)'
                ],
                'next_steps': [
                    'Study Safari CVEs and patches',
                    'Setup macOS Safari debugging environment',
                    'Research iOS jailbreak techniques',
                    'Apply for Apple SRD program if serious researcher'
                ],
                'notes': (
                    'Safari/WebKit research requires macOS/iOS devices. Harder target '
                    'than Chrome due to platform restrictions but highest payouts. '
                    'Many Safari bugs affect all WebKit-based iOS browsers.'
                )
            }
        })

        tasks['children'].append(alternative_browsers)

        # ===== PHASE 7: DEFENSIVE RESEARCH =====
        defensive_tasks = {
            'id': f'defensive-{port}',
            'name': 'Phase 7: Defensive Analysis & Detection',
            'type': 'parent',
            'children': []
        }

        # Task 7.1: Exploit Detection
        defensive_tasks['children'].append({
            'id': f'exploit-detection-{port}',
            'name': 'Browser Exploit Detection Techniques',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze methods to detect browser exploitation attempts',
                'tags': ['RESEARCH', 'DEFENSIVE', 'DETECTION'],
                'detection_layers': [
                    'Network: IDS/IPS signatures for exploit delivery',
                    'Browser: Suspicious JavaScript patterns',
                    'OS: Process behavior anomalies',
                    'Memory: Heap spray detection',
                    'Execution: ROP/JOP chain detection'
                ],
                'browser_telemetry': [
                    'Chrome: SafeBrowsing reports suspicious pages',
                    'Chrome: Crash reporting (backtrace analysis)',
                    'Chrome: V8 security checks (typed arrays bounds)',
                    'Firefox: Content Security Policy violations',
                    'All: DevTools Protocol abuse detection'
                ],
                'heap_spray_detection': [
                    'Large ArrayBuffer allocations (>10MB)',
                    'Repetitive allocation patterns',
                    'Memory usage spikes',
                    'GC pressure anomalies'
                ],
                'shellcode_detection': [
                    'RWX memory regions (JIT code modification)',
                    'Unusual system calls from browser process',
                    'Network connections from renderer process',
                    'File writes from sandboxed process'
                ],
                'behavioral_indicators': [
                    'Browser spawning cmd.exe/powershell/bash',
                    'Renderer process making network requests (should use browser)',
                    'Excessive crashes (fuzzing or exploit attempts)',
                    'DevTools Protocol connections from unexpected sources'
                ],
                'mitigations': [
                    'Keep browsers updated (patch window is critical)',
                    'Enable site isolation (Spectre mitigation)',
                    'Disable JavaScript for untrusted sites',
                    'Use browser in VM/sandbox for risky browsing',
                    'Deploy EDR with browser exploit detection',
                    'Block Chrome DevTools Protocol on corporate networks'
                ],
                'notes': (
                    'Modern browsers have extensive telemetry and security checks. '
                    'Successful exploitation often triggers multiple alerts. '
                    'Detection is cat-and-mouse game with sophisticated attackers.'
                )
            }
        })

        # Task 7.2: Patch Analysis
        defensive_tasks['children'].append({
            'id': f'patch-analysis-{port}',
            'name': 'Security Patch Analysis & Variant Finding',
            'type': 'manual',
            'metadata': {
                'description': 'Analyze browser security patches to find bug variants and improve defenses',
                'tags': ['RESEARCH', 'DEFENSIVE', 'PATCH_ANALYSIS'],
                'patch_sources': [
                    'Chromium git commits (security labels)',
                    'Firefox Mercurial repository',
                    'WebKit git repository',
                    'Monthly browser security bulletins'
                ],
                'analysis_workflow': [
                    '1. Identify security patch commit',
                    '2. Read commit message and bug tracker entry',
                    '3. Analyze code changes (what was broken)',
                    '4. Understand root cause (why it was broken)',
                    '5. Search for similar patterns (variant analysis)',
                    '6. Test if variants exist (0-day hunting)',
                    '7. Report findings or improve defenses'
                ],
                'tools': [
                    'git log --grep=security',
                    'git diff (compare vulnerable vs patched)',
                    'CodeQL queries for variant finding',
                    'Semgrep rules for pattern matching',
                    'Custom static analysis tools'
                ],
                'red_team_perspective': (
                    'Patches reveal 1-day exploits. Reverse patches to understand '
                    'vulnerability. Target users/orgs slow to update. Find variants '
                    'of patched bugs for new 0-days.'
                ),
                'blue_team_perspective': (
                    'Understand what attackers target. Prioritize patch deployment. '
                    'Develop detection for exploitation attempts. Find variants '
                    'proactively and report to vendors.'
                ),
                'notes': (
                    'Patch analysis is critical skill for both offense and defense. '
                    'Many 0-days are variants of poorly-patched bugs. Study patches '
                    'to understand attacker mindset and improve security posture.'
                )
            }
        })

        tasks['children'].append(defensive_tasks)

        # ===== ADDITIONAL CONTEXT =====

        # If version information available, add exploit research
        if version and version != 'unknown':
            research_tasks['children'].insert(0, {
                'id': f'version-exploits-{port}',
                'name': f'Research Exploits for Detected Version: {version}',
                'type': 'command',
                'metadata': {
                    'command': f'searchsploit "{version}"',
                    'description': f'Search for known exploits targeting {version}',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RESEARCH'],
                    'success_indicators': [
                        'Exploits found for specific version',
                        'CVE numbers identified'
                    ],
                    'next_steps': [
                        'Download and analyze exploit code',
                        'Test PoC against target',
                        'Adapt exploit if needed'
                    ]
                }
            })

        # Add CTF-specific guidance if on common CTF port
        ctf_ports = [8000, 3000, 8080]
        if port in ctf_ports:
            tasks['children'].insert(0, {
                'id': f'ctf-context-{port}',
                'name': 'CTF/Challenge Context Detection',
                'type': 'manual',
                'metadata': {
                    'description': (
                        f'Port {port} commonly used for CTF browser challenges. '
                        'Look for challenge description, source code disclosure, '
                        'or hints about intended vulnerability.'
                    ),
                    'tags': ['CTF', 'QUICK_WIN'],
                    'ctf_checklist': [
                        '✓ Check for /source, /src, /challenge.zip endpoints',
                        '✓ Look for HTML comments with hints',
                        '✓ Check robots.txt and sitemap.xml',
                        '✓ Test for reflected XSS (inject JavaScript)',
                        '✓ Look for CSP bypass opportunities',
                        '✓ Check for postMessage vulnerabilities',
                        '✓ Test WebSocket connections if present',
                        '✓ Look for service workers or WebAssembly modules'
                    ],
                    'common_ctf_bugs': [
                        'Prototype pollution',
                        'postMessage origin bypass',
                        'CSP bypass via JSONP',
                        'DOM XSS in client-side routing',
                        'WebAssembly memory corruption',
                        'JavaScript sandbox escape'
                    ],
                    'notes': (
                        'CTF browser challenges often have intentional bugs with '
                        'hints. Unlike real-world research, source code may be provided. '
                        'Focus on code review over fuzzing.'
                    )
                }
            })

        return tasks
