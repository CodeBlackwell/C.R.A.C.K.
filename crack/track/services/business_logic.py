"""
Business Logic Exploitation service plugin

Generates tasks for business logic vulnerability testing including:
- IDOR (Insecure Direct Object References)
- Payment bypass
- Price manipulation
- Parameter pollution (HPP)
- Workflow bypass
- Dependency confusion
- Authorization flaws
- Race conditions in business logic
- Order manipulation
- Resource enumeration

Extracted from HackTricks:
- pentesting-web/idor.md
- pentesting-web/bypass-payment-process.md
- pentesting-web/dependency-confusion.md
- pentesting-web/parameter-pollution.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class BusinessLogicPlugin(ServicePlugin):
    """Business logic exploitation plugin for web applications"""

    @property
    def name(self) -> str:
        return "business-logic"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8000, 8080, 8443, 3000, 5000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect HTTP/HTTPS services where business logic flaws are testable"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Detect HTTP-based services
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate business logic testing task tree"""

        # Determine protocol
        service = service_info.get('service', '').lower()
        protocol = 'https' if 'ssl' in service or 'https' in service or port == 443 else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'business-logic-{port}',
            'name': f'Business Logic Testing (Port {port})',
            'type': 'parent',
            'children': []
        }

        # SECTION 1: IDOR (Insecure Direct Object References)
        idor_tree = {
            'id': f'idor-testing-{port}',
            'name': 'IDOR Testing',
            'type': 'parent',
            'children': []
        }

        # IDOR: Object enumeration
        idor_tree['children'].append({
            'id': f'idor-enum-{port}',
            'name': 'IDOR Object Enumeration',
            'type': 'manual',
            'metadata': {
                'description': 'Manually test for IDOR by manipulating object identifiers in URLs, params, JSON',
                'tags': ['OSCP:HIGH', 'MANUAL', 'IDOR', 'ENUM'],
                'flag_explanations': {
                    'Burp Repeater': 'Intercept request with object ID, modify ID, replay',
                    'Sequential IDs': 'Test id=42 → id=43, id=1234 → id=1233',
                    'UUID prediction': 'Test if UUIDs predictable or leaking in responses'
                },
                'success_indicators': [
                    'Access to other user data (horizontal privilege escalation)',
                    'Access to admin data with low-priv token (vertical escalation)',
                    'No authorization error when changing object ID',
                    'Response contains sensitive data from different user/resource'
                ],
                'failure_indicators': [
                    '403 Forbidden or 401 Unauthorized (proper access control)',
                    'Generic error without data disclosure',
                    'Session invalidation on tampering'
                ],
                'next_steps': [
                    'Document vulnerable endpoints: /api/user/ID, /files/ID',
                    'Test GET, PUT, PATCH, DELETE methods',
                    'Check if changing user_id in JSON body bypasses auth',
                    'Enumerate ID range: bash loop or Burp Intruder'
                ],
                'alternatives': [
                    'Burp Intruder: Sniper attack on ID parameter',
                    f'curl -H "Cookie: session=TOKEN" {base_url}/api/user/1234',
                    f'curl -X PUT {base_url}/api/lead -d \'{{"lead_id":1234}}\' -H "Cookie: auth=TOKEN"',
                    'ffuf -u http://target/api/user/FUZZ -H "Cookie: session=TOKEN" -w ids.txt'
                ],
                'notes': 'IDOR occurs when app exposes user-controllable ID without verifying caller is authorized. Look for params: id, user_id, file_id, invoice, order_id. Sequential IDs = high risk!'
            }
        })

        # IDOR: Automated enumeration
        idor_tree['children'].append({
            'id': f'idor-automate-{port}',
            'name': 'IDOR Automated Enumeration (Bash Loop)',
            'type': 'command',
            'metadata': {
                'command': f'for id in $(seq 1000 1100); do curl -s -X GET "{base_url}/api/user/$id" -H "Cookie: auth=YOUR_TOKEN" | grep -q "email" && echo "Hit: $id"; done',
                'description': 'Automate IDOR testing by iterating through sequential IDs',
                'tags': ['OSCP:HIGH', 'AUTOMATED', 'IDOR', 'QUICK_WIN'],
                'flag_explanations': {
                    'seq 1000 1100': 'Generate ID range (adjust based on discovered IDs)',
                    '-s': 'Silent curl output',
                    'grep -q "email"': 'Search for sensitive field in response (PII indicator)',
                    '&& echo': 'Print only successful ID hits'
                },
                'success_indicators': [
                    'Multiple IDs return data',
                    'Email, phone, address leaked for different users',
                    'Potential for mass-data exfiltration'
                ],
                'failure_indicators': [
                    'All IDs return 403/401',
                    'Rate limiting triggers (429 Too Many Requests)',
                    'IDs non-sequential or large gaps'
                ],
                'next_steps': [
                    'Document ID range that worked',
                    'Extract all PII for reporting',
                    'Test other endpoints with same IDOR pattern',
                    'Check if JWT tokens can be stolen via IDOR on /api/token endpoints'
                ],
                'alternatives': [
                    'Burp Intruder: Payloads → Numbers (sequential), Grep - Match "email"',
                    'Python script with requests library for better parsing',
                    'wfuzz -z range,1-1000 --hc 403,401 http://target/api/user/FUZZ'
                ],
                'notes': 'Adjust ID range based on YOUR account ID. If your ID is 64185742, test 64185740-64185750 first. McHire case: 64M records exposed via IDOR!'
            }
        })

        # IDOR: Error-based user enumeration
        idor_tree['children'].append({
            'id': f'idor-error-oracle-{port}',
            'name': 'IDOR Error Oracle for User/File Enumeration',
            'type': 'command',
            'metadata': {
                'command': f'ffuf -u "{base_url}/view.php?username=FUZZ&file=test.doc" -b "PHPSESSID=YOUR_SESSION" -w /usr/share/seclists/Usernames/Names/names.txt -fr "User not found"',
                'description': 'Use error message differences to enumerate valid usernames via IDOR',
                'tags': ['OSCP:HIGH', 'ENUM', 'IDOR'],
                'flag_explanations': {
                    '-u': 'Target URL with FUZZ placeholder',
                    '-b': 'Cookie header (authenticated session required)',
                    '-w': 'Wordlist for username fuzzing',
                    '-fr': 'Filter regex to hide "User not found" errors (shows only valid users)'
                },
                'success_indicators': [
                    'Valid usernames discovered (different error: "File does not exist")',
                    'File listing exposed in error messages',
                    'Access to other users\' files: /view.php?username=amanda&file=resume.pdf'
                ],
                'failure_indicators': [
                    'All usernames return same error',
                    'Session validation blocks enumeration',
                    'Rate limiting'
                ],
                'next_steps': [
                    'For valid users, fuzz file parameter: ?username=amanda&file=FUZZ.pdf',
                    'Try common filenames: privacy.odt, salary.xlsx, resume.pdf',
                    'Check if file path traversal possible: file=../../../etc/passwd'
                ],
                'alternatives': [
                    'Burp Intruder: Cluster bomb attack (username + file)',
                    f'Manual: curl "{base_url}/view.php?username=admin&file=test.doc" -b "PHPSESSID=..."',
                    'wfuzz -z file,users.txt -z file,files.txt --hc 404 http://target/view.php?username=FUZZ&file=FUZ2Z'
                ],
                'notes': 'Error oracles expose valid users! "User not found" vs "File does not exist" = username exists. From HTB Nocturnal writeup.'
            }
        })

        # IDOR: Testing different HTTP methods
        idor_tree['children'].append({
            'id': f'idor-methods-{port}',
            'name': 'IDOR Testing Across HTTP Methods',
            'type': 'manual',
            'metadata': {
                'description': 'Test IDOR on GET, PUT, PATCH, DELETE methods (not just GET)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'IDOR'],
                'flag_explanations': {
                    'GET': 'Read other users data',
                    'PUT': 'Update/overwrite other users data',
                    'PATCH': 'Partial update of other users data',
                    'DELETE': 'Delete other users resources'
                },
                'success_indicators': [
                    'PUT request changes victim user profile',
                    'DELETE removes victim resources',
                    'PATCH modifies sensitive fields (email, password, role)'
                ],
                'failure_indicators': [
                    'Method not allowed (405)',
                    'Authorization check on write operations',
                    'CSRF token validation blocks PUT/DELETE'
                ],
                'next_steps': [
                    'Document which methods are vulnerable',
                    'Test account takeover: PUT /api/user/VICTIM_ID {"email":"attacker@evil.com"}',
                    'Test privilege escalation: PATCH /api/user/123 {"role":"admin"}'
                ],
                'alternatives': [
                    f'curl -X PUT {base_url}/api/user/1234 -d \'{{"email":"attacker@test.com"}}\' -H "Cookie: auth=TOKEN"',
                    f'curl -X DELETE {base_url}/api/file/5678 -H "Cookie: auth=TOKEN"',
                    f'curl -X PATCH {base_url}/api/user/999 -d \'{{"role":"admin"}}\' -H "Content-Type: application/json"'
                ],
                'notes': 'Many apps validate auth on GET but forget PUT/DELETE/PATCH! Always test write methods for IDOR.'
            }
        })

        tasks['children'].append(idor_tree)

        # SECTION 2: Payment Bypass & Price Manipulation
        payment_tree = {
            'id': f'payment-bypass-{port}',
            'name': 'Payment Bypass Testing',
            'type': 'parent',
            'children': []
        }

        # Payment: Parameter tampering
        payment_tree['children'].append({
            'id': f'payment-param-tamper-{port}',
            'name': 'Payment Parameter Tampering',
            'type': 'manual',
            'metadata': {
                'description': 'Intercept payment requests and tamper with price, quantity, success flags',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Success parameter': 'Change success=false to success=true to bypass payment',
                    'Price parameter': 'Change price=100 to price=0.01 or negative value',
                    'Quantity': 'Change quantity=-1 to get refund instead of charge',
                    'Currency': 'Change currency=USD to currency=XXX (test currency)'
                },
                'success_indicators': [
                    'Order completed without payment',
                    'Price changed to $0.01 or negative',
                    'Success callback triggered without payment gateway confirmation',
                    'Free premium account/features'
                ],
                'failure_indicators': [
                    'Server-side price validation',
                    'Payment gateway signature verification',
                    'Transaction rollback on tampering'
                ],
                'next_steps': [
                    'Test all payment flow steps: cart → checkout → payment → confirmation',
                    'Check if callback URL can be manipulated',
                    'Test referrer parameter manipulation',
                    'Look for MD5 hash in callback - may be predictable'
                ],
                'alternatives': [
                    'Burp: Intercept POST to /checkout, change "price": 100 to "price": 0.01',
                    'Burp: Modify GET /payment/callback?success=false to success=true',
                    'Manual: Inspect form fields, change hidden price input before submit'
                ],
                'notes': 'Payment bypass via parameter tampering common! Look for: price, amount, success, status, callback, referrer params. Test negative quantities for refunds!'
            }
        })

        # Payment: Response tampering
        payment_tree['children'].append({
            'id': f'payment-response-tamper-{port}',
            'name': 'Payment Response Tampering',
            'type': 'manual',
            'metadata': {
                'description': 'Intercept payment gateway response and modify status to simulate successful payment',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Response interception': 'Burp: Intercept response from payment gateway',
                    'Status modification': 'Change "status": "failed" to "status": "success"',
                    'Transaction ID': 'Insert fake transaction ID to bypass validation'
                },
                'success_indicators': [
                    'Application accepts modified response',
                    'Order marked as paid without actual payment',
                    'Premium features unlocked'
                ],
                'failure_indicators': [
                    'Server-side verification with payment gateway',
                    'Response signature validation',
                    'Webhook callback to gateway for confirmation'
                ],
                'next_steps': [
                    'Document response structure',
                    'Test if application validates response signature',
                    'Check if webhook confirmation happens asynchronously'
                ],
                'alternatives': [
                    'Burp: Response tab → Modify JSON {"status":"failed"} to {"status":"success"}',
                    'Burp: Match/Replace rule to auto-modify payment responses',
                    'Manual: Browser DevTools → Network tab → Right-click response → Edit and resend'
                ],
                'notes': 'Response tampering works when app trusts client-side response without server validation. Gateway should use webhooks, not client response!'
            }
        })

        # Payment: Callback URL manipulation
        payment_tree['children'].append({
            'id': f'payment-callback-{port}',
            'name': 'Payment Callback URL Manipulation',
            'type': 'manual',
            'metadata': {
                'description': 'Manipulate payment callback URL to redirect to attacker-controlled page that confirms payment',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Callback URL': 'URL where payment gateway redirects after payment',
                    'URL manipulation': 'Change callback=site.com/success to callback=attacker.com/fake-success',
                    'MD5 hash': 'Pattern like /payment/MD5HASH may be predictable'
                },
                'success_indicators': [
                    'Redirect to attacker URL accepted',
                    'Attacker can craft fake success page that completes order',
                    'Application trusts callback without validating source'
                ],
                'failure_indicators': [
                    'Callback URL whitelist',
                    'Signature validation on callback',
                    'Server-side payment verification'
                ],
                'next_steps': [
                    'Copy legitimate callback URL structure',
                    'Host fake success page on attacker server',
                    'Test if app validates callback source',
                    'Check for SSRF via callback parameter'
                ],
                'alternatives': [
                    'Burp: Modify callback parameter in payment request',
                    f'Manual: Change callback URL in checkout form before submit',
                    'Test open redirect: callback=site.com/redirect?url=attacker.com'
                ],
                'notes': 'If callback URL contains MD5 hash, extract pattern. May be predictable: MD5(user_id + timestamp). Host fake page returning success JSON!'
            }
        })

        # Payment: Cookie tampering
        payment_tree['children'].append({
            'id': f'payment-cookie-tamper-{port}',
            'name': 'Payment Cookie Tampering',
            'type': 'manual',
            'metadata': {
                'description': 'Modify cookies related to payment status, cart total, or user tier',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Payment status cookie': 'paid=false → paid=true',
                    'Cart total cookie': 'total=100 → total=1',
                    'User tier cookie': 'tier=free → tier=premium',
                    'Discount cookie': 'discount=0 → discount=100'
                },
                'success_indicators': [
                    'Application trusts client-side cookies for payment logic',
                    'Premium features unlocked after cookie modification',
                    'Cart total recalculated from client cookie'
                ],
                'failure_indicators': [
                    'Server-side session validation',
                    'Cookie signature/encryption',
                    'Price stored server-side only'
                ],
                'next_steps': [
                    'Inspect all cookies during checkout flow',
                    'Decode Base64 cookies for hidden data',
                    'Test if cookies are signed (HMAC)',
                    'Try replaying old "premium" cookies'
                ],
                'alternatives': [
                    'Browser DevTools: Application → Cookies → Edit values',
                    'Burp: Proxy → Options → Match/Replace → Cookie modification',
                    'curl: -b "paid=true;total=1" to test'
                ],
                'notes': 'Never trust client-side data for payment! But many apps do. Look for: isPaid, hasPremium, accountType, cartTotal in cookies.'
            }
        })

        # Payment: Race condition
        payment_tree['children'].append({
            'id': f'payment-race-{port}',
            'name': 'Payment Race Condition',
            'type': 'manual',
            'metadata': {
                'description': 'Exploit race condition by using same payment/coupon multiple times simultaneously',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'RACE_CONDITION'],
                'flag_explanations': {
                    'Race condition': 'Send multiple payment requests simultaneously before validation completes',
                    'Single-use bypass': 'Coupon/credit marked as used AFTER transaction completes - race window',
                    'Burp Turbo Intruder': 'Tool to send requests in parallel with precise timing'
                },
                'success_indicators': [
                    'Single coupon applied multiple times',
                    'Account balance goes negative',
                    'Multiple orders completed with single payment',
                    'Gift card used beyond balance'
                ],
                'failure_indicators': [
                    'Database locks prevent double-spend',
                    'Idempotency key validation',
                    'Transaction serialization'
                ],
                'next_steps': [
                    'Test with Burp Turbo Intruder (send 20 parallel requests)',
                    'Try redeeming gift card code 10 times simultaneously',
                    'Test applying coupon during payment window',
                    'Check if account balance can go negative'
                ],
                'alternatives': [
                    'Burp Repeater: Right-click → Send to Turbo Intruder → race-single-packet-attack.py',
                    'Python: threading.Thread to send parallel requests',
                    'Bash: for i in {1..10}; do curl ... & done'
                ],
                'notes': 'Race conditions common in payment, coupon redemption, inventory. Look for single-use resources: coupons, gift cards, limited inventory.'
            }
        })

        tasks['children'].append(payment_tree)

        # SECTION 3: Parameter Pollution (HPP)
        hpp_tree = {
            'id': f'hpp-testing-{port}',
            'name': 'HTTP Parameter Pollution (HPP)',
            'type': 'parent',
            'children': []
        }

        # HPP: Basic testing
        hpp_tree['children'].append({
            'id': f'hpp-basic-{port}',
            'name': 'HPP Basic Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test parameter pollution by duplicating HTTP parameters to manipulate backend logic',
                'tags': ['OSCP:HIGH', 'MANUAL', 'HPP'],
                'flag_explanations': {
                    'Duplicate parameter': 'Add same param twice: ?from=A&to=B&from=C',
                    'PHP behavior': 'Uses LAST parameter (from=C)',
                    'Flask/Go behavior': 'Uses FIRST parameter (from=A)',
                    'Spring/Node behavior': 'CONCATENATES: from="A,C"'
                },
                'success_indicators': [
                    'Transaction charged to wrong account (duplicate from param)',
                    'OTP sent to attacker email (duplicate email param)',
                    'API key updated to attacker value (duplicate api_key param)',
                    'Bypass authentication/authorization checks'
                ],
                'failure_indicators': [
                    'Server validates single parameter only',
                    'Duplicate parameters rejected',
                    'All params must match for transaction'
                ],
                'next_steps': [
                    'Identify backend technology (PHP, Python, Java, Node, Go)',
                    'Test all critical params: email, user_id, from, to, api_key, role',
                    'Fuzz with Burp: Add duplicate params in URL, body, headers',
                    'Check if frontend uses first param but backend uses last'
                ],
                'alternatives': [
                    f'curl "{base_url}/send?from=accountA&to=accountB&amount=100&from=accountC"',
                    f'curl -X POST {base_url}/reset -d "email=victim@test.com&email=attacker@test.com"',
                    'Burp: Manually duplicate parameters in Repeater'
                ],
                'notes': 'HPP exploits inconsistent param parsing! PHP/Apache uses last, Flask/Go uses first, Spring concatenates. Test on: transactions, OTP, password reset, API keys!'
            }
        })

        # HPP: OTP bypass
        hpp_tree['children'].append({
            'id': f'hpp-otp-{port}',
            'name': 'HPP OTP Bypass (Duplicate Email Parameter)',
            'type': 'manual',
            'metadata': {
                'description': 'Intercept OTP request and duplicate email parameter to send OTP to attacker email',
                'tags': ['OSCP:HIGH', 'MANUAL', 'HPP', 'AUTH_BYPASS'],
                'flag_explanations': {
                    'Duplicate email': 'POST body: email=victim@test.com&email=attacker@test.com',
                    'Backend logic': 'Generates OTP for FIRST email, sends to LAST email',
                    'PHP vulnerable': 'PHP processes first for logic, last for email delivery'
                },
                'success_indicators': [
                    'OTP intended for victim sent to attacker email',
                    'Attacker receives OTP for victim account',
                    'Login bypass via intercepted OTP'
                ],
                'failure_indicators': [
                    'Single email parameter enforced',
                    'Email validation rejects duplicates',
                    'OTP sent to all emails (detection risk)'
                ],
                'next_steps': [
                    'Intercept OTP/password reset request with Burp',
                    'Duplicate email parameter',
                    'Check attacker inbox for OTP',
                    'Use OTP to login as victim'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/request-otp -d "email=victim@test.com&email=attacker@test.com"',
                    'Burp: Intercept OTP request → Duplicate email param → Forward',
                    'Manual: Add second email field in HTML form with DevTools'
                ],
                'notes': 'Real-world case: PHP backend generates OTP for first email but sends to last email. Critical auth bypass! Test on: OTP, password reset, 2FA.'
            }
        })

        # HPP: JSON array behavior
        hpp_tree['children'].append({
            'id': f'hpp-json-array-{port}',
            'name': 'HPP JSON Array Exploitation',
            'type': 'manual',
            'metadata': {
                'description': 'Test if backend interprets duplicate JSON keys differently than frontend',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'HPP', 'JSON'],
                'flag_explanations': {
                    'Duplicate JSON key': '{"role":"user","role":"admin"}',
                    'Frontend behavior': 'May use first value (role=user)',
                    'Backend behavior': 'May use last value (role=admin)',
                    'Parser inconsistency': 'Different JSON parsers handle duplicates differently'
                },
                'success_indicators': [
                    'Frontend validates user role, backend uses admin role',
                    'Privilege escalation via duplicate key',
                    'Access to admin functionality'
                ],
                'failure_indicators': [
                    'JSON parser rejects duplicate keys',
                    'Consistent handling across frontend/backend',
                    'Validation on both sides'
                ],
                'next_steps': [
                    'Test critical JSON fields: role, permissions, user_id, is_admin',
                    'Try comment injection: {"role":"admin/*","test":1,"role":"user"*/}',
                    'Test character truncation: {"role":"admin\\x0d"}',
                    'Check if frontend/backend use different JSON libraries'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/api/update -d \'{{"role":"user","role":"admin"}}\' -H "Content-Type: application/json"',
                    'Burp: Modify JSON in Repeater with duplicate keys',
                    'Test: {"test":1,"test\\x0d":2} - backend may see test=2'
                ],
                'notes': 'JSON parsers handle duplicates differently! Java GSON uses first, Ruby simdjson uses last. Frontend/backend inconsistency = bypass!'
            }
        })

        # HPP: Array notation bypass
        hpp_tree['children'].append({
            'id': f'hpp-array-notation-{port}',
            'name': 'HPP Array Notation Bypass',
            'type': 'manual',
            'metadata': {
                'description': 'Test if backend handles param[] notation differently, allowing array injection',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'HPP'],
                'flag_explanations': {
                    'param[]': 'Array notation: ?email[]=victim@test.com&email[]=attacker@test.com',
                    'PHP behavior': 'Recognizes email[] as array, may concatenate or pick last',
                    'Go behavior': 'Does NOT recognize [], treats as literal string',
                    'Bypass technique': 'Send both email and email[] - inconsistent handling'
                },
                'success_indicators': [
                    'Backend processes email[] as array',
                    'Email sent to multiple recipients via array injection',
                    'Bypass single-email validation'
                ],
                'failure_indicators': [
                    'Array notation not supported',
                    'Validation rejects [] in parameter names',
                    'Backend ignores array notation'
                ],
                'next_steps': [
                    'Test: ?param=value&param[]=value2',
                    'Check if backend prefers param or param[]',
                    'Try on: email, user_id, role fields',
                    'Identify backend tech to predict behavior'
                ],
                'alternatives': [
                    f'curl "{base_url}/reset?email=victim@test.com&email[]=attacker@test.com"',
                    'Burp: Add param[] alongside param in same request',
                    'Manual form injection: Add hidden field name="email[]"'
                ],
                'notes': 'PHP/Apache recognizes param[], Spring/Node may concatenate, Go/Flask ignores. Test both param and param[] together!'
            }
        })

        tasks['children'].append(hpp_tree)

        # SECTION 4: Workflow Bypass
        workflow_tree = {
            'id': f'workflow-bypass-{port}',
            'name': 'Workflow Bypass Testing',
            'type': 'parent',
            'children': []
        }

        # Workflow: Step skipping
        workflow_tree['children'].append({
            'id': f'workflow-skip-{port}',
            'name': 'Multi-Step Workflow Step Skipping',
            'type': 'manual',
            'metadata': {
                'description': 'Attempt to skip steps in multi-step workflows (registration, checkout, KYC)',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Step skipping': 'Jump from step 1 directly to step 3 without step 2 validation',
                    'URL manipulation': 'Change /checkout/step2 to /checkout/step4',
                    'Hidden form fields': 'Add step=4 to form POST'
                },
                'success_indicators': [
                    'Checkout completed without payment step',
                    'Account created without email verification',
                    'KYC bypassed by skipping identity verification',
                    'Premium features unlocked without subscription'
                ],
                'failure_indicators': [
                    'Server-side workflow state validation',
                    'Session tracks completed steps',
                    'Redirect to missing step'
                ],
                'next_steps': [
                    'Map all workflow steps: step1, step2, step3...',
                    'Try accessing final step directly',
                    'Test if session state is validated',
                    'Check for hidden step parameters in forms'
                ],
                'alternatives': [
                    f'curl {base_url}/checkout/step4 -b "session=TOKEN"',
                    'Burp: Skip POST to /step2, directly POST to /step3',
                    'Manual: Edit URL in browser to jump steps'
                ],
                'notes': 'Many apps validate frontend flow but not backend state! Test on: checkout, registration, multi-factor setup, subscription cancellation.'
            }
        })

        # Workflow: State manipulation
        workflow_tree['children'].append({
            'id': f'workflow-state-{port}',
            'name': 'Workflow State Manipulation',
            'type': 'manual',
            'metadata': {
                'description': 'Manipulate workflow state parameters to bypass business rules',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'State parameter': 'status=pending → status=approved',
                    'Stage parameter': 'stage=review → stage=complete',
                    'Approval flag': 'approved=false → approved=true'
                },
                'success_indicators': [
                    'Order approved without admin review',
                    'Account activated without email verification',
                    'Subscription renewed without payment',
                    'Refund issued without approval'
                ],
                'failure_indicators': [
                    'State validated server-side',
                    'State transitions require authorization',
                    'Audit log catches tampering'
                ],
                'next_steps': [
                    'Identify state parameters: status, stage, approved, verified',
                    'Test modifying state in requests',
                    'Check if state transitions are role-based',
                    'Try replaying old state values'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/api/order/123 -d \'{{"status":"approved"}}\' -H "Cookie: auth=TOKEN"',
                    'Burp: Intercept state update, change status value',
                    'Manual: Modify hidden form fields for status/stage'
                ],
                'notes': 'State machines should enforce valid transitions! But many don\'t. Test: pending→approved, inactive→active, trial→premium.'
            }
        })

        # Workflow: Reverse operations
        workflow_tree['children'].append({
            'id': f'workflow-reverse-{port}',
            'name': 'Reverse Operation Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if workflow can be reversed (cancel after completion, refund after shipping)',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Reverse operation': 'Call cancellation API after order shipped',
                    'State rollback': 'Try to revert completed transaction',
                    'Refund abuse': 'Request refund multiple times'
                },
                'success_indicators': [
                    'Refund issued after product delivered',
                    'Order cancelled after fulfillment',
                    'Subscription cancelled with full refund after use',
                    'Account deletion doesn\'t revoke access'
                ],
                'failure_indicators': [
                    'Operations locked after final state',
                    'Validation prevents reverse operations',
                    'Transaction log prevents rollback'
                ],
                'next_steps': [
                    'Complete workflow normally',
                    'Try calling earlier-stage APIs',
                    'Test cancellation/refund after completion',
                    'Check if delete operation is reversible'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/api/order/123/cancel -H "Cookie: auth=TOKEN"',
                    f'curl -X DELETE {base_url}/api/subscription/456 -H "Cookie: auth=TOKEN"',
                    'Burp: Replay old cancellation request after completion'
                ],
                'notes': 'Test irreversible operations: Can you cancel after shipping? Refund after delivery? Delete after completion?'
            }
        })

        tasks['children'].append(workflow_tree)

        # SECTION 5: Dependency Confusion (Supply Chain)
        dep_confusion_tree = {
            'id': f'dep-confusion-{port}',
            'name': 'Dependency Confusion (Supply Chain)',
            'type': 'parent',
            'children': []
        }

        # Dependency: Package enumeration
        dep_confusion_tree['children'].append({
            'id': f'dep-enum-packages-{port}',
            'name': 'Enumerate Internal Package Names',
            'type': 'manual',
            'metadata': {
                'description': 'Discover internal package/library names from exposed manifests or error messages',
                'tags': ['OSCP:LOW', 'ENUM', 'SUPPLY_CHAIN'],
                'flag_explanations': {
                    'Manifest files': 'package.json, requirements.txt, pom.xml, Gemfile',
                    'Error messages': 'ImportError, ModuleNotFoundError may leak internal packages',
                    'Source code': 'GitHub/GitLab may expose internal dependencies',
                    'CI configs': '.gitlab-ci.yml, .github/workflows may reference private packages'
                },
                'success_indicators': [
                    'Internal package names discovered: @company/*, company-*',
                    'Private npm scope identified',
                    'Maven groupId pattern found',
                    'Internal PyPI package names exposed'
                ],
                'failure_indicators': [
                    'Manifests not exposed',
                    'Generic error messages',
                    'Source code not public'
                ],
                'next_steps': [
                    'Check if internal names available on public registries',
                    'Test if resolver allows public registry fallback',
                    'Register internal names on public registry (RED TEAM ONLY)',
                    'Report to organization for defensive registration'
                ],
                'alternatives': [
                    f'curl {base_url}/package.json',
                    f'curl {base_url}/requirements.txt',
                    f'curl {base_url}/.well-known/security.txt',
                    'Google dork: site:github.com "company" package.json'
                ],
                'notes': 'Dependency confusion: attacker publishes malicious package with internal name to public registry. If resolver checks public registry, malicious package wins! DEFENSIVE: Register internal names publicly.'
            }
        })

        # Dependency: Typosquatting check
        dep_confusion_tree['children'].append({
            'id': f'dep-typosquat-{port}',
            'name': 'Check for Typosquatting Opportunities',
            'type': 'manual',
            'metadata': {
                'description': 'Identify common typos of popular packages to detect potential supply chain risks',
                'tags': ['OSCP:LOW', 'SUPPLY_CHAIN'],
                'flag_explanations': {
                    'Typosquatting': 'reqests vs requests, colour vs color',
                    'Misspellings': 'Common mistakes in package names',
                    'Public registry check': 'See if typosquatted version exists'
                },
                'success_indicators': [
                    'App imports typosquatted package',
                    'Malicious package with similar name found',
                    'Developer confusion led to wrong package'
                ],
                'failure_indicators': [
                    'Correct package names used',
                    'Dependency pinning prevents typosquat',
                    'Lockfiles enforce correct versions'
                ],
                'next_steps': [
                    'Review all imported packages for typos',
                    'Check public registries for malicious clones',
                    'Report typosquatted packages to registry',
                    'Recommend using lockfiles and hash verification'
                ],
                'alternatives': [
                    'Manual: Review package.json/requirements.txt for typos',
                    'npm: npm audit for known malicious packages',
                    'pip: pip-audit for vulnerability scanning'
                ],
                'notes': 'Typosquatting common: reqests, urllib4, colourlib. Attacker publishes malicious package hoping for developer typos. Check npm/PyPI for malicious versions!'
            }
        })

        # Dependency: Version confusion
        dep_confusion_tree['children'].append({
            'id': f'dep-version-confusion-{port}',
            'name': 'Test Dependency Version Confusion',
            'type': 'manual',
            'metadata': {
                'description': 'Check if resolver prefers higher version from public registry over internal registry',
                'tags': ['OSCP:LOW', 'SUPPLY_CHAIN'],
                'flag_explanations': {
                    'Version precedence': 'Internal v1.0.1 vs public v1.0.2 - which wins?',
                    'Resolver behavior': 'npm/pip may prefer "best" version globally',
                    'Unpinned versions': '^1.0.0 allows resolver to pick any 1.x.x'
                },
                'success_indicators': [
                    'Public registry version preferred',
                    'Higher version from untrusted source wins',
                    'Internal package overridden by public package'
                ],
                'failure_indicators': [
                    'Lockfiles enforce specific versions',
                    'Resolver scoped to internal registry only',
                    'Version pinning prevents confusion'
                ],
                'next_steps': [
                    'Review resolver configuration',
                    'Check if internal packages pinned',
                    'Test if publishing higher public version succeeds',
                    'Recommend scoped registries and lockfiles'
                ],
                'alternatives': [
                    'Manual: Check .npmrc for registry scoping',
                    'Manual: Check pip.conf for index-url settings',
                    'Defensive: Use --require-hashes in pip'
                ],
                'notes': 'Attacker publishes higher version to public registry. If resolver checks both registries, public wins! FIX: Scope internal packages to internal registry only.'
            }
        })

        tasks['children'].append(dep_confusion_tree)

        # SECTION 6: Authorization & Access Control
        authz_tree = {
            'id': f'authz-testing-{port}',
            'name': 'Authorization Testing',
            'type': 'parent',
            'children': []
        }

        # Authorization: Horizontal privilege escalation
        authz_tree['children'].append({
            'id': f'authz-horizontal-{port}',
            'name': 'Horizontal Privilege Escalation',
            'type': 'manual',
            'metadata': {
                'description': 'Test if authenticated user can access other users\' resources at same privilege level',
                'tags': ['OSCP:HIGH', 'MANUAL', 'AUTHZ'],
                'flag_explanations': {
                    'Horizontal escalation': 'User A accesses User B\'s data',
                    'Same privilege level': 'Both are regular users, not admin',
                    'IDOR subset': 'Horizontal escalation often via IDOR'
                },
                'success_indicators': [
                    'Access to other users\' profiles',
                    'Read other users\' messages/orders',
                    'Modify other users\' settings'
                ],
                'failure_indicators': [
                    'Authorization check per request',
                    'User ID validated against session',
                    '403 Forbidden on cross-user access'
                ],
                'next_steps': [
                    'Create two test accounts',
                    'Login as User A, try accessing User B resources',
                    'Test GET, POST, PUT, DELETE on other user IDs',
                    'Document all vulnerable endpoints'
                ],
                'alternatives': [
                    'Manual: Login as user1, access /profile/user2',
                    f'curl {base_url}/api/messages/USER2_ID -H "Cookie: auth=USER1_TOKEN"',
                    'Burp: Autorize extension to automate authz testing'
                ],
                'notes': 'Horizontal privilege escalation = same-level access. Test: profile, messages, orders, files. Always test with 2+ accounts!'
            }
        })

        # Authorization: Vertical privilege escalation
        authz_tree['children'].append({
            'id': f'authz-vertical-{port}',
            'name': 'Vertical Privilege Escalation',
            'type': 'manual',
            'metadata': {
                'description': 'Test if low-privilege user can access admin/high-privilege functionality',
                'tags': ['OSCP:HIGH', 'MANUAL', 'AUTHZ', 'PRIVESC'],
                'flag_explanations': {
                    'Vertical escalation': 'Regular user accesses admin functions',
                    'Role bypass': 'Accessing /admin endpoints without admin role',
                    'Method bypass': 'GET /admin blocked, but PUT /admin allowed'
                },
                'success_indicators': [
                    'Access to admin panel',
                    'Execute admin-only actions (user management, config)',
                    'Modify system settings',
                    'View sensitive logs/data'
                ],
                'failure_indicators': [
                    'Role-based access control (RBAC) enforced',
                    '403 Forbidden on admin endpoints',
                    'Session role validation'
                ],
                'next_steps': [
                    'Map admin endpoints: /admin, /api/admin, /manage',
                    'Test with low-priv user session',
                    'Try different HTTP methods: GET, POST, PUT',
                    'Test path traversal: /user/../admin'
                ],
                'alternatives': [
                    f'curl {base_url}/admin -H "Cookie: auth=USER_TOKEN"',
                    f'curl {base_url}/api/admin/users -H "Cookie: auth=USER_TOKEN"',
                    'Burp: Fuzz admin paths with low-priv session',
                    'Manual: Direct navigation to /admin URL'
                ],
                'notes': 'Vertical privilege escalation = higher privilege access. Common on: /admin, /api/admin, /manage. Test HTTP method bypass!'
            }
        })

        # Authorization: Missing function level access control
        authz_tree['children'].append({
            'id': f'authz-function-level-{port}',
            'name': 'Missing Function Level Access Control',
            'type': 'manual',
            'metadata': {
                'description': 'Test if API/functions enforce authorization on every endpoint',
                'tags': ['OSCP:HIGH', 'MANUAL', 'AUTHZ'],
                'flag_explanations': {
                    'Function-level control': 'Each function/endpoint should validate caller permissions',
                    'Missing checks': 'Admin function accessible to all authenticated users',
                    'API endpoints': 'Often forget authorization on DELETE, PUT'
                },
                'success_indicators': [
                    'DELETE /api/user/123 works without admin role',
                    'PUT /api/config works for regular user',
                    'Access to debug/internal endpoints'
                ],
                'failure_indicators': [
                    'Authorization decorator on all functions',
                    'Middleware validates permissions',
                    'Consistent 403 responses'
                ],
                'next_steps': [
                    'Enumerate all API endpoints',
                    'Test each endpoint with low-priv user',
                    'Focus on write operations: POST, PUT, DELETE',
                    'Check internal/debug endpoints'
                ],
                'alternatives': [
                    f'curl -X DELETE {base_url}/api/user/123 -H "Cookie: auth=USER_TOKEN"',
                    f'curl -X PUT {base_url}/api/config -d \'{{"debug":true}}\' -H "Cookie: auth=USER_TOKEN"',
                    'Burp: Autorize extension for systematic testing'
                ],
                'notes': 'API endpoints often forget authz! Test ALL endpoints, especially: DELETE, PUT, PATCH, admin functions, debug endpoints.'
            }
        })

        tasks['children'].append(authz_tree)

        # SECTION 7: Quantity & Limit Manipulation
        quantity_tree = {
            'id': f'quantity-manip-{port}',
            'name': 'Quantity & Limit Manipulation',
            'type': 'parent',
            'children': []
        }

        # Quantity: Negative values
        quantity_tree['children'].append({
            'id': f'quantity-negative-{port}',
            'name': 'Negative Quantity Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if negative quantities trigger refunds or inventory manipulation',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Negative quantity': 'quantity=-1 may result in refund instead of charge',
                    'Integer overflow': 'quantity=2147483647+1 may wrap to negative',
                    'Price calculation': 'price * (-quantity) = negative total'
                },
                'success_indicators': [
                    'Account credited instead of charged',
                    'Inventory increased instead of decreased',
                    'Negative total price',
                    'Free products received'
                ],
                'failure_indicators': [
                    'Input validation rejects negative',
                    'Business logic prevents negative calculation',
                    'Error message returned'
                ],
                'next_steps': [
                    'Test on cart quantity field',
                    'Test on transfer amount field',
                    'Check integer overflow: 2147483648',
                    'Try decimal negatives: -0.01'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/cart/add -d \'{{"product_id":1,"quantity":-10}}\' -H "Cookie: auth=TOKEN"',
                    'Burp: Modify quantity in checkout request to -1',
                    'Manual: Change quantity in HTML form to negative'
                ],
                'notes': 'Negative quantities common bug! Test: cart, transfers, inventory. May result in free products or account credits!'
            }
        })

        # Quantity: Integer overflow
        quantity_tree['children'].append({
            'id': f'quantity-overflow-{port}',
            'name': 'Integer Overflow Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test if large quantity values cause integer overflow leading to negative prices',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Integer overflow': 'Exceeding max int (2147483647) wraps to negative',
                    'Price calculation': 'price * large_quantity may overflow',
                    '32-bit vs 64-bit': '32-bit systems more vulnerable'
                },
                'success_indicators': [
                    'Total price becomes negative',
                    'Order processed with negative total',
                    'Account credited instead of charged',
                    'Free checkout'
                ],
                'failure_indicators': [
                    'Arbitrary precision arithmetic',
                    'Quantity validation limits',
                    'Error on overflow'
                ],
                'next_steps': [
                    'Test max int: 2147483647',
                    'Test max int + 1: 2147483648',
                    'Test on: quantity, price, amount fields',
                    'Check for uint vs int handling'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/cart/add -d \'{{"quantity":2147483648}}\' -H "Cookie: auth=TOKEN"',
                    'Burp: Set quantity to 2147483648 in request',
                    'Calculate: price * overflow_quantity to predict result'
                ],
                'notes': 'Integer overflow rare but critical! Max signed int32 = 2147483647. Overflow wraps to -2147483648. Test on price calculations!'
            }
        })

        # Quantity: Rate limit bypass
        quantity_tree['children'].append({
            'id': f'quantity-rate-limit-{port}',
            'name': 'Rate Limit Bypass via Quantity',
            'type': 'manual',
            'metadata': {
                'description': 'Bypass rate limits by using quantity parameter instead of multiple requests',
                'tags': ['OSCP:MEDIUM', 'MANUAL', 'BUSINESS_LOGIC'],
                'flag_explanations': {
                    'Rate limit': 'Max 10 requests/minute',
                    'Quantity bypass': 'Single request with quantity=1000',
                    'Resource exhaustion': 'Amplification via quantity param'
                },
                'success_indicators': [
                    'Single request processes 1000 items',
                    'Rate limit not triggered',
                    'Batch operation via quantity param',
                    'Resource exhaustion'
                ],
                'failure_indicators': [
                    'Quantity validation limits',
                    'Rate limit on items not requests',
                    'Error on excessive quantity'
                ],
                'next_steps': [
                    'Identify rate-limited endpoints',
                    'Test with large quantity values',
                    'Check if rate limit is per-request or per-item',
                    'Test resource exhaustion: quantity=999999'
                ],
                'alternatives': [
                    f'curl -X POST {base_url}/api/process -d \'{{"items":1000}}\' -H "Cookie: auth=TOKEN"',
                    'Burp: Modify quantity to 10000 in single request',
                    'Test: quantity=999999 for DoS'
                ],
                'notes': 'Rate limits often on requests, not items! Test: email sending, API calls, file generation. Single request with quantity=1000 may bypass!'
            }
        })

        tasks['children'].append(quantity_tree)

        return tasks
