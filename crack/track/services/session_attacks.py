"""
Session & CSRF Attack Enumeration Plugin

Generates tasks for testing session security including:
- CSRF bypass techniques (token validation, SameSite, referrer)
- Session fixation and hijacking
- Cookie manipulation and injection
- Cookie tossing and prefix bypass
- Session donation attacks

Extracted from HackTricks:
- pentesting-web/csrf-cross-site-request-forgery.md
- pentesting-web/hacking-with-cookies/README.md
- pentesting-web/hacking-with-cookies/cookie-tossing.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class SessionAttacksPlugin(ServicePlugin):
    """Session security and CSRF enumeration plugin"""

    @property
    def name(self) -> str:
        return "session-attacks"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443, 3000, 5000, 8000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt', 'ssl/http']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """Detect HTTP services for session testing"""
        service = port_info.get('service', '').lower()
        port = port_info.get('port')

        # Check service name
        if any(svc in service for svc in self.service_names):
            return True

        # Check common HTTP ports
        if port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate session attack enumeration task tree"""
        protocol = 'https' if port in [443, 8443] or 'ssl' in service_info.get('service', '') else 'http'
        base_url = f'{protocol}://{target}:{port}'

        tasks = {
            'id': f'session-attacks-{port}',
            'name': f'Session & CSRF Attacks (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Cookie Reconnaissance
        tasks['children'].append({
            'id': f'cookie-recon-{port}',
            'name': 'Cookie Reconnaissance',
            'type': 'parent',
            'children': [
                {
                    'id': f'cookie-inspect-{port}',
                    'name': 'Inspect Cookie Attributes',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze cookie security attributes (HttpOnly, Secure, SameSite, Path, Domain)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'success_indicators': [
                            'Cookies captured with attributes',
                            'Missing HttpOnly on session cookies (can steal via XSS)',
                            'Missing Secure flag (transmitted over HTTP)',
                            'SameSite=None or missing (CSRF vulnerable)',
                            'Domain=.example.com (subdomain exposure)'
                        ],
                        'failure_indicators': [
                            'No cookies set',
                            'All flags properly configured'
                        ],
                        'next_steps': [
                            'If HttpOnly missing: Test XSS to steal cookies',
                            'If Secure missing: Downgrade to HTTP and capture',
                            'If SameSite missing/None: Test CSRF attacks',
                            'Check for __Host- or __Secure- prefixes'
                        ],
                        'alternatives': [
                            f'Browser DevTools: Application > Cookies > {base_url}',
                            f'curl -i {base_url} | grep -i "set-cookie"',
                            f'Manual: Burp Suite > HTTP history > Response headers'
                        ],
                        'notes': 'Cookie attributes control browser security behavior. Missing flags = attack vectors. SameSite=Lax still allows GET-based CSRF.'
                    }
                },
                {
                    'id': f'cookie-decode-{port}',
                    'name': 'Decode and Analyze Cookie Values',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Decode Base64/hex cookies and analyze structure for manipulation',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ANALYSIS'],
                        'success_indicators': [
                            'Cookie decoded successfully',
                            'Readable data found (username, role, id)',
                            'Predictable structure identified'
                        ],
                        'failure_indicators': [
                            'Encrypted/signed cookies',
                            'Random session IDs'
                        ],
                        'next_steps': [
                            'Modify decoded values (change user=guest to user=admin)',
                            'Re-encode and test authorization bypass',
                            'Check for JWT tokens in cookies'
                        ],
                        'alternatives': [
                            'echo "COOKIE_VALUE" | base64 -d',
                            'CyberChef: From Base64',
                            'Burp Decoder tab'
                        ],
                        'notes': 'Many apps store user info in cookies as Base64. Decode, modify (user=admin), re-encode, test.'
                    }
                }
            ]
        })

        # TASK 2: CSRF Token Analysis
        tasks['children'].append({
            'id': f'csrf-token-analysis-{port}',
            'name': 'CSRF Token Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'csrf-token-missing-{port}',
                    'name': 'Test for Missing CSRF Token',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Remove CSRF token from request and check if state-changing action succeeds',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'flag_explanations': {
                            'POST request': 'State-changing operation (change email, delete account)',
                            'CSRF token parameter': 'Anti-CSRF protection (e.g., csrf=xxx, token=xxx)',
                            'Remove parameter': 'Delete entire parameter (not just value)'
                        },
                        'success_indicators': [
                            'Action succeeds without token',
                            'HTTP 200 response',
                            'Email changed / account modified'
                        ],
                        'failure_indicators': [
                            'HTTP 400/403 - Token required',
                            'Error message: Invalid CSRF token'
                        ],
                        'next_steps': [
                            'Craft CSRF PoC HTML form without token',
                            'Test auto-submit to victim',
                            'Document as critical finding (CSRF)'
                        ],
                        'alternatives': [
                            'Burp Repeater: Delete csrf parameter entirely',
                            'Manual: curl -X POST with params but no token',
                            'Browser DevTools: Edit form, remove hidden token field'
                        ],
                        'notes': 'Some apps validate tokens when present but skip validation if parameter missing. Always test removing entire parameter.'
                    }
                },
                {
                    'id': f'csrf-token-empty-{port}',
                    'name': 'Test Empty CSRF Token',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Submit request with empty token value (csrf=)',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'success_indicators': [
                            'Empty token accepted',
                            'State-changing action succeeds'
                        ],
                        'failure_indicators': [
                            'Validation error: Empty token rejected'
                        ],
                        'next_steps': [
                            'Create CSRF PoC with csrf="" in form',
                            'Test if server only checks token existence, not value'
                        ],
                        'alternatives': [
                            'Burp Repeater: Set csrf=',
                            'HTML form: <input name="csrf" value="">'
                        ],
                        'notes': 'Weak validation: if(isset($_POST["csrf"])) vs if($_POST["csrf"] == $valid_token)'
                    }
                },
                {
                    'id': f'csrf-token-global-{port}',
                    'name': 'Test Global CSRF Token Pool',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if CSRF tokens are tied to user session or global pool',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'success_indicators': [
                            'Attacker token works in victim request',
                            'Same token valid across sessions'
                        ],
                        'failure_indicators': [
                            'Token tied to session cookie',
                            'Invalid token error'
                        ],
                        'next_steps': [
                            '1. Login with your account, capture CSRF token',
                            '2. Use that token in CSRF PoC against victim',
                            '3. If succeeds: Victim performs action with attacker token'
                        ],
                        'alternatives': [
                            'Manual: Open 2 browsers, compare tokens',
                            'Burp: Compare tokens from different sessions'
                        ],
                        'notes': 'Tokens must be session-bound. Global pool = exploitable CSRF.'
                    }
                },
                {
                    'id': f'csrf-method-bypass-{port}',
                    'name': 'POST to GET Method Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Convert POST to GET request to bypass CSRF validation',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'BYPASS'],
                        'flag_explanations': {
                            'POST to GET': 'Some apps only validate CSRF on POST',
                            '?_method=PUT': 'Method override parameter',
                            'X-HTTP-Method-Override': 'Header-based method override'
                        },
                        'success_indicators': [
                            'GET request performs state-changing action',
                            'CSRF validation bypassed',
                            'Simple link triggers action'
                        ],
                        'failure_indicators': [
                            'GET not supported',
                            'Method not allowed error'
                        ],
                        'next_steps': [
                            'Craft simple GET CSRF: <img src="url?action=delete">',
                            'Test method override: POST with _method=DELETE',
                            'Test header override: X-HTTP-Method-Override: PUT'
                        ],
                        'alternatives': [
                            f'curl "{base_url}/account/delete?user=victim"',
                            'Burp: Change POST to GET, move body to query params',
                            'Manual: <a href="url?params">Click here</a>'
                        ],
                        'notes': 'Common PHP pattern: if($_SERVER["REQUEST_METHOD"] == "POST") check_csrf(); else skip. Frameworks: Laravel, Symfony, Express support method overrides.'
                    }
                },
                {
                    'id': f'csrf-method-override-{port}',
                    'name': 'HTTP Method Override CSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use _method parameter or override headers to bypass non-POST CSRF checks',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'success_indicators': [
                            'POST with _method=DELETE bypasses CSRF',
                            'Override header works'
                        ],
                        'next_steps': [
                            'Test: POST /delete with _method=DELETE',
                            'Test headers: X-HTTP-Method, X-HTTP-Method-Override, X-Method-Override'
                        ],
                        'alternatives': [
                            'HTML: <input type="hidden" name="_method" value="DELETE">',
                            'curl -X POST -H "X-HTTP-Method-Override: DELETE"'
                        ],
                        'notes': 'Laravel, Symfony, Rails support _method. Devs assume browsers can\'t send DELETE/PUT (wrong with override).'
                    }
                }
            ]
        })

        # TASK 3: SameSite Cookie Bypass
        tasks['children'].append({
            'id': f'samesite-bypass-{port}',
            'name': 'SameSite Cookie Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': f'samesite-lax-get-{port}',
                    'name': 'SameSite=Lax GET Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test GET-based CSRF with SameSite=Lax cookies',
                        'tags': ['OSCP:MEDIUM', 'CSRF', 'BYPASS'],
                        'success_indicators': [
                            'Cookies sent on top-level GET navigation',
                            'State change via GET link successful'
                        ],
                        'failure_indicators': [
                            'Cookies blocked on cross-site POST/iframe'
                        ],
                        'next_steps': [
                            'Find GET endpoints that modify state',
                            'Craft CSRF: <a href="url?action=delete">',
                            'Test form GET: <form method="GET">'
                        ],
                        'alternatives': [
                            'Manual: Send victim link to GET endpoint',
                            'Test: <link rel="prerender" href="url">',
                            'Social engineering: Embed link in email'
                        ],
                        'notes': 'SameSite=Lax allows cookies on: Links, Form GET, Prerender. Blocks: POST forms, AJAX, iframes. Chrome default since 2020.'
                    }
                },
                {
                    'id': f'samesite-none-{port}',
                    'name': 'SameSite=None Cookie Exploitation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test cross-site requests when SameSite=None (all CSRF allowed)',
                        'tags': ['OSCP:HIGH', 'CSRF'],
                        'success_indicators': [
                            'Cookies sent on all cross-site requests',
                            'CSRF PoC works (POST, iframe, AJAX)'
                        ],
                        'next_steps': [
                            'Create standard CSRF PoC (auto-submit form)',
                            'Test all state-changing endpoints',
                            'Chain with XSS for maximum impact'
                        ],
                        'alternatives': [
                            'CSRF PoC generator: Burp Professional',
                            'Manual HTML form with auto-submit'
                        ],
                        'notes': 'SameSite=None requires Secure flag. Cookies sent everywhere = classic CSRF.'
                    }
                }
            ]
        })

        # TASK 4: Referrer/Origin Header Bypass
        tasks['children'].append({
            'id': f'referrer-bypass-{port}',
            'name': 'Referrer/Origin Header Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': f'referrer-suppress-{port}',
                    'name': 'Suppress Referrer Header',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use meta tag to suppress Referrer header and bypass validation',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'flag_explanations': {
                            '<meta name="referrer" content="never">': 'Prevents browser from sending Referrer header',
                            'Referrer validation': 'Some apps check Referrer contains trusted domain'
                        },
                        'success_indicators': [
                            'Request succeeds without Referrer header',
                            'CSRF bypass confirmed'
                        ],
                        'failure_indicators': [
                            'Server rejects requests with missing Referrer/Origin'
                        ],
                        'next_steps': [
                            'Add meta tag to CSRF PoC HTML',
                            'Test if app validates only when header present',
                            'If blocked, try regex bypass'
                        ],
                        'alternatives': [
                            'HTML: <meta name="referrer" content="never">',
                            'Test: curl with no Referrer header'
                        ],
                        'notes': 'Proper defense: Validate Origin when present; if both Origin and Referrer absent, fail closed (reject). Weak: Only check when present.'
                    }
                },
                {
                    'id': f'referrer-regex-bypass-{port}',
                    'name': 'Referrer Regex Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass weak Referrer regex with crafted URLs',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'success_indicators': [
                            'Referrer validation bypassed with malicious domain',
                            'Request accepted'
                        ],
                        'next_steps': [
                            'Test: http://evil.com?victim.com (URL ends with trusted)',
                            'Test: http://victim.com.evil.com (starts with trusted)',
                            'Use history.pushState to inject domain in query'
                        ],
                        'alternatives': [
                            'CSRF PoC with history.pushState("", "", "?victim.com")',
                            '<meta name="referrer" content="unsafe-url"> to send full URL'
                        ],
                        'notes': 'Weak regex: /victim.com/ matches "evil.com?victim.com" or "victim.com.evil.com". Proper: Exact domain match.'
                    }
                }
            ]
        })

        # TASK 5: Content-Type Bypass
        tasks['children'].append({
            'id': f'content-type-bypass-{port}',
            'name': 'Content-Type CSRF Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': f'csrf-text-plain-{port}',
                    'name': 'Text/Plain JSON Smuggling',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Send JSON as text/plain to bypass CORS preflight',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'flag_explanations': {
                            'enctype="text/plain"': 'Prevents preflight request (no custom headers)',
                            'JSON parsing': 'Some backends parse as JSON regardless of Content-Type'
                        },
                        'success_indicators': [
                            'JSON data accepted as text/plain',
                            'No preflight triggered',
                            'CSRF successful'
                        ],
                        'next_steps': [
                            'Craft form with enctype="text/plain"',
                            'Encode JSON in form inputs',
                            'Test if backend parses Content-Type-agnostic JSON'
                        ],
                        'alternatives': [
                            'HTML: <form enctype="text/plain">',
                            'Input manipulation: name=\'{"key":"\' value=\'"value"}\'',
                            'Test: Content-Type: text/plain; application/json'
                        ],
                        'notes': 'CORS simple requests: application/x-www-form-urlencoded, multipart/form-data, text/plain. No preflight for these. Some APIs parse JSON from any Content-Type.'
                    }
                },
                {
                    'id': f'csrf-multipart-{port}',
                    'name': 'Multipart/Form-Data CSRF',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test CSRF with multipart encoding (file upload CSRF)',
                        'tags': ['OSCP:MEDIUM'],
                        'success_indicators': [
                            'Multipart request accepted',
                            'File upload or data modification via CSRF'
                        ],
                        'next_steps': [
                            'Create form with enctype="multipart/form-data"',
                            'Test file upload CSRF',
                            'Upload malicious files via victim session'
                        ],
                        'alternatives': [
                            'Fetch API with FormData object',
                            'XMLHttpRequest multipart POST'
                        ],
                        'notes': 'Multipart/form-data is CORS simple request (no preflight). Can upload files via CSRF if no token.'
                    }
                }
            ]
        })

        # TASK 6: Cookie Manipulation Attacks
        tasks['children'].append({
            'id': f'cookie-manipulation-{port}',
            'name': 'Cookie Manipulation Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'cookie-tossing-{port}',
                    'name': 'Cookie Tossing (Subdomain Injection)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Inject cookies from controlled subdomain to fixate parent domain sessions',
                        'tags': ['OSCP:MEDIUM', 'SESSION_FIXATION'],
                        'flag_explanations': {
                            'Domain=.example.com': 'Sets cookie for all subdomains',
                            'Cookie tossing': 'Subdomain sets cookie that affects parent domain',
                            'Session fixation': 'Attacker sets known session ID, victim uses it'
                        },
                        'success_indicators': [
                            'Cookie set from subdomain',
                            'Parent domain accepts subdomain cookie',
                            'Session fixation successful'
                        ],
                        'failure_indicators': [
                            '__Host- prefix blocks subdomain cookies',
                            'New session assigned on login'
                        ],
                        'next_steps': [
                            'Find XSS or control subdomain (e.g., sub.victim.com)',
                            'Set cookie: document.cookie="session=ATTACKER_SESSION; Domain=.victim.com"',
                            'Victim logs in with fixated session',
                            'Attacker uses same session to hijack account'
                        ],
                        'alternatives': [
                            'XSS payload: document.cookie="session=123; Domain=.example.com; Path=/"',
                            'Controlled subdomain: Inject via HTTP response',
                            'CRLF injection to set cookies'
                        ],
                        'notes': 'Defense: Use __Host- prefix (prevents Domain attribute, blocks subdomain tossing). Check if session changes after login.'
                    }
                },
                {
                    'id': f'cookie-prefix-bypass-{port}',
                    'name': '__Host- Prefix Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass __Host- cookie protection with parser tricks',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'BYPASS'],
                        'success_indicators': [
                            '__Host- cookie overwritten from subdomain',
                            'Parser normalization exploited'
                        ],
                        'next_steps': [
                            'Test Unicode whitespace: String.fromCodePoint(0x2000) + "__Host-name"',
                            'Test legacy parsing: $Version=1,__Host-name=injected',
                            'Test PHP normalization: Add chars that become underscores'
                        ],
                        'alternatives': [
                            'JS: document.cookie = `${String.fromCodePoint(0x2000)}__Host-session=evil`',
                            'Burp Bambda: CookiePrefixBypass.bambda',
                            'Test parsers: Django (trims Unicode), Java (legacy $Version)'
                        ],
                        'notes': 'Exploit: Browser sees "â€€__Host-name", server trims to "__Host-name" and overwrites. Unicode whitespace: U+2000–U+200A, U+0085, U+00A0.'
                    }
                },
                {
                    'id': f'cookie-jar-overflow-{port}',
                    'name': 'Cookie Jar Overflow Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Overflow cookie jar to delete HttpOnly cookies and replace with attacker cookies',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'success_indicators': [
                            'Victim cookie deleted due to overflow',
                            'Attacker cookie takes precedence'
                        ],
                        'next_steps': [
                            'Set ~180 cookies from subdomain (browser limit)',
                            'Oldest cookies deleted (including victim session)',
                            'Inject new session cookie without HttpOnly'
                        ],
                        'alternatives': [
                            'XSS: Loop to set 200 cookies',
                            'Subdomain: Set-Cookie headers in bulk'
                        ],
                        'notes': 'Browsers limit cookies per domain (~180). Overflow deletes oldest first. Can remove HttpOnly cookies indirectly.'
                    }
                },
                {
                    'id': f'cookie-smuggling-{port}',
                    'name': 'Cookie Smuggling (RFC2965 Legacy)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit legacy cookie parsing to smuggle/inject cookies',
                        'tags': ['OSCP:LOW', 'ADVANCED'],
                        'success_indicators': [
                            'Double-quoted cookie parsed as single value',
                            'Injected cookie interpreted server-side'
                        ],
                        'next_steps': [
                            'Test: Cookie: RENDER_TEXT="hello; JSESSIONID=attacker_session; END"',
                            'Check if server parses quoted cookies (Java: Jetty, Tomcat)',
                            'Bypass HttpOnly by exfiltrating via echo endpoint'
                        ],
                        'alternatives': [
                            'Burp: Craft Cookie header with quoted values',
                            'XSS: document.cookie = \'name="value;injected=evil"\''
                        ],
                        'notes': 'Java/Python legacy parsers read quoted values as single token. Bypass CSRF token validation by injecting spoofed tokens.'
                    }
                },
                {
                    'id': f'cookie-sandwich-{port}',
                    'name': 'Cookie Sandwich Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Steal HttpOnly cookies via reflection using RFC2109 cookie sandwiching',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'EXFILTRATION'],
                        'flag_explanations': {
                            '$Version=1': 'Enables legacy RFC2109 parsing',
                            'Cookie sandwich': 'Trap victim cookie between attacker cookies',
                            'Reflection': 'Victim cookie value reflected in HTTP response'
                        },
                        'success_indicators': [
                            'HttpOnly cookie value reflected in response',
                            'Cookie exfiltrated via XSS'
                        ],
                        'failure_indicators': [
                            'No cookie reflection endpoint',
                            'Server doesn\'t support $Version=1'
                        ],
                        'next_steps': [
                            '1. Find endpoint that reflects cookie value',
                            '2. Set $Version=1 cookie',
                            '3. Set param1="start (opens quote)',
                            '4. Victim cookie gets sandwiched',
                            '5. Set param2=end" (closes quote)',
                            '6. Fetch reflected response, extract cookie'
                        ],
                        'alternatives': [
                            'XSS: document.cookie = `$Version=1; param1="start; param2=end"`',
                            'Fetch reflection endpoint and regex extract cookie'
                        ],
                        'notes': 'Requirements: 1) Cookie reflection in response, 2) Server supports $Version=1 (Python frameworks). Bypasses HttpOnly protection.'
                    }
                }
            ]
        })

        # TASK 7: Session Fixation/Hijacking
        tasks['children'].append({
            'id': f'session-fixation-{port}',
            'name': 'Session Fixation Attacks',
            'type': 'parent',
            'children': [
                {
                    'id': f'session-fixation-login-{port}',
                    'name': 'Login Session Fixation',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test if session ID changes after login (session fixation vulnerability)',
                        'tags': ['OSCP:HIGH', 'SESSION_FIXATION'],
                        'success_indicators': [
                            'Session cookie unchanged after login',
                            'Pre-login session ID still valid post-login'
                        ],
                        'failure_indicators': [
                            'New session ID issued after authentication',
                            'Old session invalidated'
                        ],
                        'next_steps': [
                            '1. Capture session cookie before login',
                            '2. Login to application',
                            '3. Check if session cookie changed',
                            'If unchanged: Exploit with cookie tossing (set victim session before login)'
                        ],
                        'alternatives': [
                            'Burp: Compare pre/post-login session cookies',
                            'Browser DevTools: Monitor cookies during login',
                            'curl: Check Set-Cookie header on login response'
                        ],
                        'notes': 'Proper defense: Regenerate session on privilege change (session_regenerate_id()). If cookie persists after login, attacker can fixate session and hijack after victim logs in.'
                    }
                },
                {
                    'id': f'session-donation-{port}',
                    'name': 'Session Donation Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Trick victim into using attacker session (victim adds data to attacker account)',
                        'tags': ['OSCP:MEDIUM', 'SESSION_DONATION'],
                        'success_indicators': [
                            'Victim uses attacker session',
                            'Victim adds credit card/data to attacker account'
                        ],
                        'next_steps': [
                            '1. Attacker creates account, captures session cookie',
                            '2. Force victim to use attacker cookie (cookie tossing/XSS)',
                            '3. Victim thinks logged into their account',
                            '4. Victim adds credit card, searches, etc.',
                            '5. Attacker accesses own account to see victim data'
                        ],
                        'alternatives': [
                            'Cookie tossing from subdomain',
                            'Login CSRF to force login to attacker account'
                        ],
                        'notes': 'Victim believes in own account, but actually using attacker session. Attacker harvests victim activity (searches, payment methods, orders).'
                    }
                }
            ]
        })

        # TASK 8: Advanced CSRF Exploitation
        tasks['children'].append({
            'id': f'csrf-advanced-{port}',
            'name': 'Advanced CSRF Exploitation',
            'type': 'parent',
            'children': [
                {
                    'id': f'csrf-token-exfil-xss-{port}',
                    'name': 'CSRF Token Exfiltration via XSS',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Use XSS to steal CSRF token and perform authenticated CSRF',
                        'tags': ['OSCP:MEDIUM', 'XSS', 'CSRF'],
                        'success_indicators': [
                            'XSS executes fetch to get page with token',
                            'Token extracted via regex/DOM query',
                            'CSRF request sent with stolen token'
                        ],
                        'next_steps': [
                            '1. Find reflected/stored XSS',
                            '2. Fetch page containing CSRF token',
                            '3. Parse token from response (regex/querySelector)',
                            '4. Submit CSRF with stolen token'
                        ],
                        'alternatives': [
                            'XSS: fetch("/account").then(r => r.text()).then(html => {token = html.match(/csrf=([^"]+)/)[1]; submitCSRF(token);})',
                            'Dangling markup to exfiltrate token',
                            'Iframe + DOM access (if no X-Frame-Options)'
                        ],
                        'notes': 'XSS + CSRF = full account takeover. Steal token, bypass all CSRF defenses. Chain vulnerabilities for maximum impact.'
                    }
                },
                {
                    'id': f'csrf-login-chain-{port}',
                    'name': 'Login CSRF + Stored XSS Chain',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Force victim to login to attacker account, trigger stored XSS in attacker context',
                        'tags': ['OSCP:MEDIUM', 'CHAIN'],
                        'success_indicators': [
                            'Login CSRF forces victim into attacker account',
                            'Stored XSS executes in victim browser',
                            'Session hijack or data theft'
                        ],
                        'next_steps': [
                            '1. Create attacker account with stored XSS payload',
                            '2. Craft login CSRF to authenticate victim as attacker',
                            '3. Redirect to page with XSS',
                            '4. XSS executes, steals victim data or session'
                        ],
                        'alternatives': [
                            'CSRF PoC: Auto-submit login form with attacker creds',
                            'Redirect after login to XSS-vulnerable page'
                        ],
                        'notes': 'Low-impact login CSRF becomes critical when chained with stored XSS. Escalate from annoyance to account takeover.'
                    }
                },
                {
                    'id': f'csrf-get-html-tags-{port}',
                    'name': 'GET-based CSRF via HTML Tags',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit GET endpoints with auto-loading HTML tags',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': [
                            'GET request triggers state change',
                            'HTML tag auto-loads URL (img, iframe, script)'
                        ],
                        'next_steps': [
                            'Find GET endpoint that modifies state',
                            'Embed in HTML: <img src="url?action=delete">',
                            'Send to victim, tag auto-loads and executes'
                        ],
                        'alternatives': [
                            '<iframe src="url"></iframe>',
                            '<script src="url"></script>',
                            '<link rel="stylesheet" href="url">',
                            '<video src="url"></video>',
                            '<audio src="url"></audio>',
                            '<embed src="url">',
                            '<object data="url"></object>'
                        ],
                        'notes': 'HTML tags that auto-load resources: img, iframe, script, link, video, audio, embed, object, body background, div style. Perfect for GET CSRF.'
                    }
                },
                {
                    'id': f'csrf-head-method-{port}',
                    'name': 'HEAD Method CSRF Bypass',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass rate limiting or CSRF checks with HEAD requests',
                        'tags': ['OSCP:LOW', 'BYPASS'],
                        'success_indicators': [
                            'HEAD request processed as GET',
                            'Rate limiting bypassed',
                            'CSRF validation skipped'
                        ],
                        'next_steps': [
                            'Send HEAD request to GET endpoint',
                            'Check if processed without response body',
                            'Bypass rate limits on brute-force'
                        ],
                        'alternatives': [
                            'curl -I (HEAD request)',
                            'Burp: Change GET to HEAD'
                        ],
                        'notes': 'Some routers (Oak, Express) handle HEAD as GET with no body. Bypasses logging, rate limits, CSRF checks that only apply to GET/POST.'
                    }
                }
            ]
        })

        # TASK 9: CSRF Brute-Force (Advanced)
        tasks['children'].append({
            'id': f'csrf-bruteforce-{port}',
            'name': 'CSRF-Protected Login Brute-Force',
            'type': 'manual',
            'metadata': {
                'description': 'Brute-force login while handling CSRF tokens and rate limits',
                'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'NOISY'],
                'flag_explanations': {
                    'CSRF token refresh': 'Fetch new token for each login attempt',
                    'Session cookie': 'Maintain session across token fetches',
                    'X-Forwarded-For': 'Bypass IP-based rate limiting'
                },
                'success_indicators': [
                    'Login attempts bypass CSRF validation',
                    'Rate limiting evaded',
                    'Valid credentials found'
                ],
                'failure_indicators': [
                    'Account lockout',
                    'IP blocked',
                    'CAPTCHA triggered'
                ],
                'next_steps': [
                    'Script: GET page → Extract CSRF token → POST login → Repeat',
                    'Rotate X-Forwarded-For header to bypass IP blocks',
                    'Use session cookie from initial GET'
                ],
                'alternatives': [
                    'Python script with requests.Session()',
                    'Burp Intruder: Recursive grep to extract token',
                    'Hydra with CSRF handling (complex)'
                ],
                'notes': 'CSRF brute-force workflow: 1) GET login page, extract token, 2) POST with token + password, 3) Check response, 4) Repeat. Randomize X-Forwarded-For per attempt. Time estimate: 10-30 min for short wordlist.'
            }
        })

        # TASK 10: Cookie Security Analysis (Advanced)
        tasks['children'].append({
            'id': f'cookie-security-advanced-{port}',
            'name': 'Advanced Cookie Security Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': f'cookie-encryption-test-{port}',
                    'name': 'Cookie Encryption Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for weak cookie encryption (ECB, CBC, padding oracle)',
                        'tags': ['OSCP:LOW', 'ADVANCED', 'CRYPTO'],
                        'success_indicators': [
                            'ECB mode detected (same plaintext = same ciphertext)',
                            'Padding oracle vulnerability',
                            'Cookie decryption successful'
                        ],
                        'next_steps': [
                            'Test ECB: Create users "aaaaaaaaaaaaaaaa" and "bbbbbbbbbbbbbbbb", compare cookies',
                            'Test padding oracle: Use padbuster tool',
                            'Decrypt: padbuster <URL> <COOKIE> 8 -cookies name=value'
                        ],
                        'alternatives': [
                            'padbuster for padding oracle attacks',
                            'Manual ECB detection: Compare cookie patterns',
                            'CBC-MAC attack for integrity bypass'
                        ],
                        'notes': 'ECB mode: Same block plaintext → same ciphertext. Create long username, find repeating blocks. Padding oracle: Decrypt/encrypt arbitrary data. Time estimate: 30+ minutes for padbuster.'
                    }
                },
                {
                    'id': f'cookie-httponly-bypass-{port}',
                    'name': 'HttpOnly Cookie Bypass Methods',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Bypass HttpOnly protection to steal session cookies',
                        'tags': ['OSCP:MEDIUM', 'BYPASS'],
                        'success_indicators': [
                            'HttpOnly cookie exfiltrated',
                            'Session hijacked'
                        ],
                        'next_steps': [
                            'Check for phpinfo() or debug pages (cookies in response)',
                            'Test TRACE method (if enabled)',
                            'Cookie jar overflow to delete HttpOnly cookie',
                            'Cookie sandwich attack (reflection)',
                            'Server-side echo of session ID in HTML'
                        ],
                        'alternatives': [
                            'XSS: fetch("/phpinfo.php") to read cookies in response',
                            'TRACE: Not allowed in modern browsers (try IE6)',
                            'Regex extraction from debug HTML comments'
                        ],
                        'notes': 'HttpOnly blocks document.cookie access. Bypass: 1) Find reflection endpoint, 2) Cookie jar overflow, 3) TRACE (legacy), 4) Cookie sandwich, 5) Debug output.'
                    }
                }
            ]
        })

        return tasks
