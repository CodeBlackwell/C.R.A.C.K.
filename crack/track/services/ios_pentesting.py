"""
iOS Application Pentesting Plugin

Generates comprehensive iOS application security testing tasks including:
- Environment setup (jailbreak detection, tools)
- IPA structure analysis
- Static analysis (binary protections, crypto, insecure functions)
- Data storage testing (plist, Core Data, Keychain, SQLite)
- Dynamic analysis (hooking, runtime inspection)
- Binary reversing (otool, class-dump, disassembly)
- Local authentication bypass
- Network communication (MITM, certificate pinning)
- IPC testing (custom schemes, universal links, pasteboard)
- Backup analysis
- Memory analysis

Extracted from HackTricks iOS Pentesting guides
Generated by: CrackPot v1.0
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class iOSPentestingPlugin(ServicePlugin):
    """iOS Application Security Testing plugin"""

    @property
    def name(self) -> str:
        return "ios-pentesting"

    @property
    def default_ports(self) -> List[int]:
        # iOS testing doesn't use standard ports - detection by context
        return []

    @property
    def service_names(self) -> List[str]:
        return ['ios', 'ios-app', 'mobile-ios']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect iOS testing context (usually manual trigger)"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()

        # iOS testing context detection
        if 'ios' in service or 'ios' in product:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate iOS application pentesting task tree"""

        app_name = service_info.get('app_name', '<APP_NAME>')
        bundle_id = service_info.get('bundle_id', '<BUNDLE_ID>')

        tasks = {
            'id': 'ios-pentest',
            'name': f'iOS Application Pentesting: {app_name}',
            'type': 'parent',
            'children': []
        }

        # === PHASE 1: ENVIRONMENT SETUP ===
        tasks['children'].append({
            'id': 'ios-env-setup',
            'name': 'iOS Testing Environment Setup',
            'type': 'parent',
            'children': [
                {
                    'id': 'device-jailbreak-check',
                    'name': 'Verify Jailbreak Status',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Verify device is jailbroken for deep testing',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'SETUP'],
                        'notes': """
Check jailbreak indicators:
- Cydia app installed
- SSH access via port 22
- File system access to /var, /private

Common jailbreaks:
- checkra1n (iOS 12-14)
- unc0ver (iOS 11-14.8)
- Taurine (iOS 14-14.3)
- Chimera (iOS 12-12.5.7)

SSH credentials (default):
- User: root / Password: alpine
- CHANGE DEFAULT PASSWORD IMMEDIATELY

Without jailbreak:
- Limited to backup analysis
- Static IPA analysis only
- No runtime hooking
- No filesystem access
                        """,
                        'alternatives': [
                            'Use iOS Simulator for basic testing (limited)',
                            'Analyze IPA file statically without device',
                            'Use backup analysis for data inspection'
                        ]
                    }
                },
                {
                    'id': 'install-frida',
                    'name': 'Install Frida for Dynamic Analysis',
                    'type': 'command',
                    'metadata': {
                        'command': 'pip install frida-tools && ssh root@<DEVICE_IP> "apt-get install re.frida.server"',
                        'description': 'Install Frida for runtime instrumentation and hooking',
                        'tags': ['OSCP:HIGH', 'SETUP', 'AUTOMATED'],
                        'flag_explanations': {
                            'frida-tools': 'Python tools for Frida (frida, frida-ps, frida-trace)',
                            're.frida.server': 'Frida server for iOS (via Cydia)',
                        },
                        'success_indicators': [
                            'frida-ps -U shows device connected',
                            'frida-ps -Uai lists installed apps',
                            'No connection errors'
                        ],
                        'failure_indicators': [
                            'Device not found (USB not connected)',
                            'frida-server not running',
                            'Version mismatch between client and server'
                        ],
                        'next_steps': [
                            'Verify with: frida-ps -U',
                            'List apps: frida-ps -Uai',
                            'Install Objection for automated tasks'
                        ],
                        'alternatives': [
                            'Manual installation: Download frida-server .deb from GitHub releases',
                            'Use Sileo/Zebra package managers on newer jailbreaks',
                            'Build from source: https://github.com/frida/frida'
                        ],
                        'notes': 'Frida versions must match between host and device. Check with: frida --version'
                    }
                },
                {
                    'id': 'install-objection',
                    'name': 'Install Objection for Automated Hooking',
                    'type': 'command',
                    'metadata': {
                        'command': 'pip install objection',
                        'description': 'Install Objection for automated iOS app testing',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'SETUP'],
                        'success_indicators': [
                            'objection --help shows commands',
                            'objection explore works on test app'
                        ],
                        'next_steps': [
                            'Connect to app: objection -g <BUNDLE_ID> explore',
                            'List available commands: help',
                            'Start with: ios info binary'
                        ],
                        'alternatives': [
                            'Manual Frida scripts for specific tasks',
                            'Use Cycript for Objective-C runtime manipulation',
                            'r2frida for reverse engineering'
                        ],
                        'notes': 'Objection automates common tasks: bypass jailbreak detection, SSL pinning, dump keychain, hook methods'
                    }
                },
                {
                    'id': 'obtain-ipa',
                    'name': 'Obtain IPA File',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Obtain IPA file for static and dynamic analysis',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': """
Methods to obtain IPA:

1. **From jailbroken device** (if app installed):
   - SSH into device
   - Find app: find /var/containers/Bundle/Application -name "*.app"
   - Pull .app folder
   - Zip and rename to .ipa

2. **Using ipatool**:
   pip install ipatool
   ipatool download -b <BUNDLE_ID>

3. **Using Apple Configurator 2** (Mac only):
   - Download app to Mac
   - Locate in ~/Library/Group Containers/
   - Copy .ipa file

4. **Using iTunes (old versions)**:
   - Download app via iTunes
   - Locate in ~/Music/iTunes/iTunes Media/Mobile Applications/

5. **Client provides IPA** (most common in engagements)

Decryption (if encrypted):
- Use dumpdecrypted: https://github.com/stefanesser/dumpdecrypted
- Use Clutch: https://github.com/KJCracks/Clutch
- Use frida-ios-dump: https://github.com/AloneMonkey/frida-ios-dump
- Use bagbak: https://github.com/ChiChou/bagbak
                        """,
                        'alternatives': [
                            'Test on jailbroken device without IPA extraction',
                            'Use iOS Simulator with debug builds (if available)',
                            'Request unencrypted IPA from development team'
                        ]
                    }
                }
            ]
        })

        # === PHASE 2: IPA STRUCTURE ANALYSIS ===
        tasks['children'].append({
            'id': 'ipa-structure',
            'name': 'IPA Structure Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'extract-ipa',
                    'name': 'Extract IPA Contents',
                    'type': 'command',
                    'metadata': {
                        'command': f'unzip {app_name}.ipa -d {app_name}_extracted',
                        'description': 'Extract IPA file (essentially a zip archive)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-d': 'Destination directory for extracted contents'
                        },
                        'success_indicators': [
                            'Payload/ directory created',
                            'Payload/<APP>.app/ folder visible',
                            'Info.plist file present'
                        ],
                        'next_steps': [
                            'Navigate to Payload/<APP>.app/',
                            'Examine Info.plist for configuration',
                            'Locate main binary file'
                        ],
                        'alternatives': [
                            'Manual: mv app.ipa app.zip && unzip app.zip',
                            'macOS: Right-click IPA → Open With → Archive Utility',
                            '7-Zip on Windows/Linux'
                        ],
                        'notes': """
IPA structure:
- Payload/<APP>.app/         # Application bundle
  ├── <APP>                  # Main executable binary
  ├── Info.plist             # App configuration
  ├── _CodeSignature/        # Code signing data
  ├── Assets.car             # Compressed assets
  ├── Frameworks/            # Embedded frameworks (.dylib, .framework)
  ├── PlugIns/               # App extensions (.appex)
  ├── Base.lproj/            # Default localization
  ├── en.lproj/              # English resources
  └── ...
                        """
                    }
                },
                {
                    'id': 'analyze-infoplist',
                    'name': 'Analyze Info.plist Configuration',
                    'type': 'command',
                    'metadata': {
                        'command': f'plutil -convert xml1 Payload/{app_name}.app/Info.plist && cat Payload/{app_name}.app/Info.plist',
                        'description': 'Convert and inspect Info.plist for sensitive config',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-convert xml1': 'Convert binary plist to XML format',
                            'plutil': 'macOS native plist utility (10.2+)'
                        },
                        'success_indicators': [
                            'XML output displayed',
                            'App permissions visible (UsageDescription keys)',
                            'URL schemes listed (CFBundleURLTypes)',
                            'ATS config visible (NSAppTransportSecurity)'
                        ],
                        'failure_indicators': [
                            'Binary format not readable',
                            'Permission denied'
                        ],
                        'next_steps': [
                            'Search for sensitive keys: grep -i "UsageDescription"',
                            'Check URL schemes: grep -i "CFBundleURLTypes"',
                            'Review ATS exceptions: grep -i "NSAppTransportSecurity"',
                            'Look for API keys: grep -i "key\\|token\\|secret"'
                        ],
                        'alternatives': [
                            'Linux: apt install libplist-utils && plistutil -i Info.plist -o Info_xml.plist',
                            'Objection: ios plist cat /path/to/Info.plist',
                            'Manual: strings Info.plist | less'
                        ],
                        'notes': """
Critical Info.plist keys:

Permissions (search for "*UsageDescription"):
- NSCameraUsageDescription (Camera access)
- NSPhotoLibraryUsageDescription (Photo access)
- NSLocationWhenInUseUsageDescription (Location)
- NSContactsUsageDescription (Contacts)
- NSMicrophoneUsageDescription (Microphone)

Security config:
- NSAppTransportSecurity (ATS config - check for exceptions!)
- CFBundleURLTypes (Custom URL schemes - IPC attack surface)
- UIRequiredDeviceCapabilities (Required hardware)
- UIApplicationExitsOnSuspend (Background behavior)

Identify bundle info:
- CFBundleIdentifier (Bundle ID)
- CFBundleVersion (Build number)
- CFBundleShortVersionString (Version)
                        """
                    }
                },
                {
                    'id': 'identify-custom-schemes',
                    'name': 'Identify Custom URL Schemes',
                    'type': 'command',
                    'metadata': {
                        'command': f'grep -A 10 "CFBundleURLTypes" Payload/{app_name}.app/Info.plist',
                        'description': 'Find registered custom URL schemes (IPC attack surface)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-A 10': 'Show 10 lines after match (capture full scheme definition)'
                        },
                        'success_indicators': [
                            'CFBundleURLSchemes array found',
                            'Custom schemes listed (e.g., myapp://)'
                        ],
                        'failure_indicators': [
                            'No CFBundleURLTypes key (no custom schemes)',
                            'Empty array'
                        ],
                        'next_steps': [
                            'Test scheme handling: xcrun simctl openurl booted <scheme>://<payload>',
                            'Check for input validation in scheme handlers',
                            'Test injection: myapp://param=<script>alert(1)</script>',
                            'Document all schemes for IPC testing phase'
                        ],
                        'alternatives': [
                            'Manual: Open Info.plist in text editor and search "URL"',
                            'Use PlistBuddy: /usr/libexec/PlistBuddy -c "Print CFBundleURLTypes" Info.plist'
                        ],
                        'notes': """
Custom URL schemes enable deep linking and IPC:
- Format: scheme://[host]/[path]?[params]
- Example: myapp://user/profile?id=123

Security risks:
1. URL injection attacks
2. Sensitive data exposure in URLs
3. CSRF via crafted links
4. Missing input validation
5. Scheme hijacking (another app registers same scheme)

Test cases:
- myapp://test
- myapp://test?param=<script>alert(1)</script>
- myapp://test?param=../../../../etc/passwd
- myapp://test?redirect=javascript:alert(1)
                        """
                    }
                },
                {
                    'id': 'check-ats-config',
                    'name': 'Check App Transport Security (ATS) Config',
                    'type': 'command',
                    'metadata': {
                        'command': f'grep -A 20 "NSAppTransportSecurity" Payload/{app_name}.app/Info.plist',
                        'description': 'Check for ATS exceptions (insecure HTTP allowed)',
                        'tags': ['OSCP:HIGH'],
                        'flag_explanations': {
                            '-A 20': 'Show 20 lines after match (full ATS config)'
                        },
                        'success_indicators': [
                            'NSAppTransportSecurity key found',
                            'NSAllowsArbitraryLoads = True (INSECURE)',
                            'NSExceptionDomains with HTTP exceptions'
                        ],
                        'failure_indicators': [
                            'No NSAppTransportSecurity key (ATS enforced - GOOD)',
                            'NSAllowsArbitraryLoads = False (SECURE)'
                        ],
                        'next_steps': [
                            'If ATS disabled: Test for cleartext HTTP communication',
                            'Test MitM without SSL pinning bypass',
                            'Document insecure domains in report'
                        ],
                        'alternatives': [
                            'Use MobSF static analysis to auto-detect ATS issues',
                            'Runtime test: Intercept traffic with Burp without pinning bypass'
                        ],
                        'notes': """
App Transport Security (ATS) enforces HTTPS connections.

Insecure configurations:
- NSAllowsArbitraryLoads = YES (allows all HTTP)
- NSAllowsArbitraryLoadsInWebContent = YES (WebViews can load HTTP)
- NSExceptionDomains with NSExceptionAllowsInsecureHTTPLoads = YES

Example insecure config:
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>

This is HIGH RISK in production apps (MITM vulnerability).
                        """
                    }
                }
            ]
        })

        # === PHASE 3: STATIC BINARY ANALYSIS ===
        tasks['children'].append({
            'id': 'binary-static-analysis',
            'name': 'Static Binary Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'check-binary-protections',
                    'name': 'Check Binary Security Protections',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-pie',
                            'name': 'Check PIE (Position Independent Executable)',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -hv Payload/{app_name}.app/{app_name} | grep PIE',
                                'description': 'Verify PIE is enabled (ASLR protection)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-h': 'Display Mach-O header',
                                    '-v': 'Verbose output',
                                    'PIE': 'Position Independent Executable flag'
                                },
                                'success_indicators': [
                                    'PIE flag present in output',
                                    'ASLR enabled (GOOD)'
                                ],
                                'failure_indicators': [
                                    'No PIE flag (VULNERABLE to memory attacks)',
                                    'Binary loads at fixed address'
                                ],
                                'next_steps': [
                                    'If PIE missing: Document as HIGH risk vulnerability',
                                    'Test memory corruption exploits (if PIE disabled)',
                                    'Check other protections (stack canaries, ARC)'
                                ],
                                'alternatives': [
                                    'Use MobSF for automated protection analysis',
                                    'Ghidra: Check binary base address (should be 0x0 for PIE)',
                                    'Manual: otool -l <binary> | grep -A 3 LC_MAIN'
                                ],
                                'notes': 'PIE enables ASLR (Address Space Layout Randomization), making memory exploits harder. Should ALWAYS be enabled in production apps.'
                            }
                        },
                        {
                            'id': 'check-stack-canaries',
                            'name': 'Check Stack Canaries',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -I -v Payload/{app_name}.app/{app_name} | grep stack_chk',
                                'description': 'Verify stack canaries are present (buffer overflow protection)',
                                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-I': 'Display indirect symbol table',
                                    '-v': 'Verbose output',
                                    'stack_chk': 'Stack check symbols (canaries)'
                                },
                                'success_indicators': [
                                    'stack_chk_guard symbol found',
                                    'stack_chk_fail symbol found',
                                    'Stack protection enabled (GOOD)'
                                ],
                                'failure_indicators': [
                                    'No stack_chk symbols (VULNERABLE)',
                                    'Stack overflow protection missing'
                                ],
                                'next_steps': [
                                    'If missing: Document as MEDIUM risk',
                                    'Search for vulnerable C functions (gets, strcpy, etc.)',
                                    'Test for buffer overflow vulnerabilities'
                                ],
                                'alternatives': [
                                    'Ghidra: Search for __stack_chk_guard references',
                                    'Hopper: Check for stack canary initialization'
                                ],
                                'notes': 'Stack canaries detect buffer overflows before function returns. Missing canaries = exploitable buffer overflows.'
                            }
                        },
                        {
                            'id': 'check-arc',
                            'name': 'Check ARC (Automatic Reference Counting)',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -I -v Payload/{app_name}.app/{app_name} | grep objc_release',
                                'description': 'Verify ARC is enabled (memory safety)',
                                'tags': ['OSCP:MEDIUM'],
                                'flag_explanations': {
                                    'objc_release': 'Symbol indicating ARC is active'
                                },
                                'success_indicators': [
                                    '_objc_release symbol found',
                                    'ARC enabled (prevents memory leaks)'
                                ],
                                'failure_indicators': [
                                    'No _objc_release (manual memory management)',
                                    'Higher risk of use-after-free bugs'
                                ],
                                'next_steps': [
                                    'If ARC missing: Look for memory management bugs',
                                    'Test for use-after-free vulnerabilities',
                                    'Check for double-free issues'
                                ],
                                'alternatives': [
                                    'Check Xcode build settings for ARC enabled',
                                    'Source code review for retain/release calls'
                                ],
                                'notes': 'ARC automates memory management in Objective-C. Without ARC, manual retain/release = higher risk of memory bugs.'
                            }
                        },
                        {
                            'id': 'check-encryption',
                            'name': 'Check Binary Encryption Status',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -arch all -Vl Payload/{app_name}.app/{app_name} | grep -A5 LC_ENCRYPT',
                                'description': 'Check if binary is encrypted (App Store DRM)',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-arch all': 'Check all architectures (arm64, armv7)',
                                    '-Vl': 'Verbose load command display',
                                    'LC_ENCRYPTION_INFO': 'Encryption info load command',
                                    'cryptid': 'Encryption status (0=decrypted, 1=encrypted)'
                                },
                                'success_indicators': [
                                    'cryptid = 0 (decrypted - ready for analysis)',
                                    'LC_ENCRYPTION_INFO_64 section found'
                                ],
                                'failure_indicators': [
                                    'cryptid = 1 (encrypted - needs decryption)',
                                    'Cannot analyze encrypted binary'
                                ],
                                'next_steps': [
                                    'If encrypted: Use dumpdecrypted or frida-ios-dump',
                                    'If decrypted: Proceed to disassembly/decompilation',
                                    'Document encryption status'
                                ],
                                'alternatives': [
                                    'Use Clutch for batch decryption',
                                    'Use frida-ios-dump: python dump.py <BUNDLE_ID>',
                                    'Use bagbak: bagbak <BUNDLE_ID>'
                                ],
                                'notes': """
App Store apps are encrypted by Apple FairPlay DRM.
Decryption requires jailbroken device.

Decryption tools:
1. dumpdecrypted (most reliable)
2. frida-ios-dump (automated)
3. Clutch (batch processing)
4. bagbak (modern, maintained)

Without decryption: Limited to Info.plist and resource analysis.
                                """
                            }
                        }
                    ]
                },
                {
                    'id': 'identify-insecure-functions',
                    'name': 'Identify Insecure Functions',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'check-weak-crypto',
                            'name': 'Check for Weak Cryptography',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -Iv Payload/{app_name}.app/{app_name} | grep -E "_(CC_MD5|CC_SHA1|_random|_srand|_rand)"',
                                'description': 'Detect weak hashing and random functions',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    '-I': 'Display indirect symbol table',
                                    '-v': 'Verbose',
                                    '-E': 'Extended regex for multiple patterns',
                                    'CC_MD5': 'MD5 hashing (DEPRECATED)',
                                    'CC_SHA1': 'SHA-1 hashing (WEAK)',
                                    '_random/_rand': 'Non-cryptographic random (INSECURE)'
                                },
                                'success_indicators': [
                                    'Weak functions found (DOCUMENT AS VULNERABILITY)',
                                    '_CC_MD5 present = using MD5',
                                    '_CC_SHA1 present = using SHA-1',
                                    '_rand present = weak randomness'
                                ],
                                'failure_indicators': [
                                    'No weak functions = good crypto hygiene',
                                    'Modern functions used (SHA-256+, SecRandomCopyBytes)'
                                ],
                                'next_steps': [
                                    'If MD5/SHA1 found: Check if used for passwords (CRITICAL)',
                                    'If weak random found: Check if used for crypto keys/tokens',
                                    'Recommend SecRandomCopyBytes() for random',
                                    'Recommend SHA-256+ or PBKDF2 for passwords'
                                ],
                                'alternatives': [
                                    'Ghidra: Search for crypto function calls in decompiler',
                                    'Frida: Hook crypto functions at runtime',
                                    'Static analysis: grep -r "CC_MD5\\|CC_SHA1" <source>'
                                ],
                                'notes': """
Deprecated/Weak crypto:
- MD5: Collision attacks, DO NOT USE for passwords
- SHA-1: Collision attacks (Google SHAttered), deprecated
- rand()/srand(): Predictable, DO NOT USE for crypto

Secure alternatives:
- Hashing: SHA-256, SHA-384, SHA-512
- Password hashing: PBKDF2, bcrypt, Argon2
- Random: SecRandomCopyBytes(), /dev/urandom
                                """
                            }
                        },
                        {
                            'id': 'check-vulnerable-functions',
                            'name': 'Check for Vulnerable C Functions',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -Iv Payload/{app_name}.app/{app_name} | grep -E "_(gets|strcpy|strncpy|sprintf|vsprintf|memcpy)"',
                                'description': 'Detect dangerous C functions prone to buffer overflows',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    'gets': 'No bounds checking (NEVER USE)',
                                    'strcpy': 'No bounds checking',
                                    'sprintf': 'No bounds checking',
                                    'memcpy': 'Can overflow if size unchecked'
                                },
                                'success_indicators': [
                                    'Dangerous functions found (POTENTIAL VULNERABILITIES)',
                                    'Buffer overflow attack surface identified'
                                ],
                                'failure_indicators': [
                                    'No dangerous functions (secure coding practices)'
                                ],
                                'next_steps': [
                                    'Document each dangerous function usage',
                                    'Prioritize gets() and strcpy() for testing',
                                    'Test buffer overflow with long inputs',
                                    'Recommend safe alternatives (strncpy_s, snprintf)'
                                ],
                                'alternatives': [
                                    'Source code review for vulnerable patterns',
                                    'Fuzzing inputs to trigger buffer overflows'
                                ],
                                'notes': """
Vulnerable C functions:
- gets(): No bounds checking, ALWAYS vulnerable
- strcpy(): No bounds checking
- sprintf(): No bounds checking
- strcat(): No bounds checking
- scanf(): Can overflow buffers
- memcpy(): Unsafe if size not validated

Safe alternatives:
- gets() → fgets()
- strcpy() → strncpy_s() or strlcpy()
- sprintf() → snprintf()
- strcat() → strncat() or strlcat()
                                """
                            }
                        }
                    ]
                },
                {
                    'id': 'check-jailbreak-detection',
                    'name': 'Identify Jailbreak Detection',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Search for jailbreak detection mechanisms',
                        'tags': ['OSCP:HIGH'],
                        'notes': """
Common jailbreak detection methods:

1. **File System Checks**:
   - /Applications/Cydia.app
   - /Library/MobileSubstrate/MobileSubstrate.dylib
   - /bin/bash
   - /usr/sbin/sshd
   - /etc/apt
   - /private/var/lib/apt/

2. **Sandbox Violations**:
   - Try writing to /private
   - Try reading /etc/fstab

3. **API Checks**:
   - fork() succeeds (not allowed on non-jailbroken)
   - system() executes /bin/sh

4. **Process Checks**:
   - Cydia process running
   - Substrate daemons
   - SSH daemon

5. **Kernel Exploits**:
   - Check for known exploit signatures

6. **Environment Variables**:
   - DYLD_INSERT_LIBRARIES set

7. **Library Checks**:
   - Check loaded dylibs for MobileSubstrate

8. **Custom URL Schemes**:
   - canOpenURL("cydia://")

Detection bypass:
- Use Objection: ios jailbreak disable
- Use Shadow (Jailbreak detection bypass tweak)
- Hook detection functions with Frida
- Patch binary to NOP detection code

Search strings:
grep -r "Cydia\\|/bin/bash\\|/usr/sbin/sshd\\|MobileSubstrate" <decompiled>
                        """,
                        'alternatives': [
                            'Use Objection automated bypass',
                            'Hook detection functions with Frida',
                            'Patch binary with Hopper/Ghidra'
                        ]
                    }
                },
                {
                    'id': 'check-anti-debugging',
                    'name': 'Identify Anti-Debugging Mechanisms',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Search for anti-debugging protections',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': """
Common anti-debugging techniques:

1. **Debugger Checks**:
   - sysctl() with P_TRACED flag
   - isatty() checks
   - ptrace(PT_DENY_ATTACH)

2. **Timing Checks**:
   - Measure execution time
   - Detect debugger slowdown

3. **Memory Checks**:
   - Scan for debugger signatures
   - Check for breakpoints (0xCC)

4. **Environment Variables**:
   - Check for debug-related env vars

5. **Mach Ports**:
   - Check exception ports (used by debuggers)

Detection in binary:
otool -Iv <binary> | grep ptrace
strings <binary> | grep -i debug

Bypass techniques:
- Patch ptrace() call to NOP
- Hook sysctl() to hide debugger
- Use Frida to bypass checks
- Substrate tweak to disable checks

Frida bypass example:
Interceptor.attach(Module.findExportByName(null, "ptrace"), {
    onEnter: function(args) {
        if (args[0].toInt32() == 31) { // PT_DENY_ATTACH
            args[0] = ptr(0);
        }
    }
});
                        """,
                        'alternatives': [
                            'Use Objection for automated bypass',
                            'Patch binary with Hopper',
                            'Dynamic patching with Frida'
                        ]
                    }
                }
            ]
        })

        # === PHASE 4: DATA STORAGE ANALYSIS ===
        tasks['children'].append({
            'id': 'data-storage-analysis',
            'name': 'Data Storage Security Testing',
            'type': 'parent',
            'children': [
                {
                    'id': 'analyze-plist-files',
                    'name': 'Analyze Plist Files for Sensitive Data',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'find-plist-files',
                            'name': 'Find All Plist Files',
                            'type': 'command',
                            'metadata': {
                                'command': 'ssh root@<DEVICE_IP> "find /private/var/mobile/Containers/Data/Application/<APP_UUID>/ -name \'*.plist\'"',
                                'description': 'Locate all plist files in app sandbox',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    'find': 'Search filesystem',
                                    '-name': 'Filter by filename pattern',
                                    '*.plist': 'All property list files'
                                },
                                'success_indicators': [
                                    'List of .plist files displayed',
                                    'Library/Preferences/<BundleID>.plist found (NSUserDefaults)',
                                    'Configuration plists discovered'
                                ],
                                'next_steps': [
                                    'Download and examine each plist',
                                    'Focus on Preferences/<BundleID>.plist (NSUserDefaults)',
                                    'Search for passwords, tokens, API keys'
                                ],
                                'alternatives': [
                                    'Objection: ios plist cat <path>',
                                    'Use iExplorer/iFunBox to browse filesystem',
                                    'Analyze backup files'
                                ],
                                'notes': """
Common plist locations:
- Library/Preferences/<BundleID>.plist (NSUserDefaults)
- Library/Preferences/*.plist (various settings)
- Documents/*.plist (app-specific)
- tmp/*.plist (temporary data)

NSUserDefaults is commonly misused for:
- User credentials
- API tokens
- Session cookies
- Encryption keys

All plist data is UNENCRYPTED by default!
                                """
                            }
                        },
                        {
                            'id': 'dump-nsuserdefaults',
                            'name': 'Dump NSUserDefaults',
                            'type': 'command',
                            'metadata': {
                                'command': f'objection -g {bundle_id} explore --quiet --exec "ios nsuserdefaults get"',
                                'description': 'Extract NSUserDefaults key-value pairs',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                                'success_indicators': [
                                    'Key-value pairs displayed',
                                    'Sensitive data found (passwords, tokens)',
                                    'Configuration data exposed'
                                ],
                                'failure_indicators': [
                                    'Empty NSUserDefaults',
                                    'Connection failed'
                                ],
                                'next_steps': [
                                    'Search output for: password, token, secret, api, key',
                                    'Document any sensitive data storage',
                                    'Test if data persists after logout',
                                    'Check if data removed on app uninstall'
                                ],
                                'alternatives': [
                                    'Manual: ssh + plutil on Library/Preferences/<BundleID>.plist',
                                    'Read from backup analysis',
                                    'Parse with Python plistlib'
                                ],
                                'notes': """
NSUserDefaults common misuse:
- Storing passwords in plaintext
- API keys/secrets
- Session tokens
- OAuth credentials
- Encryption keys

NEVER store sensitive data in NSUserDefaults!
Use Keychain instead.

Check after:
1. Initial install
2. Login
3. All app features used
4. Logout (data should be cleared!)
5. App uninstall + reinstall (data should be gone!)
                                """
                            }
                        }
                    ]
                },
                {
                    'id': 'analyze-sqlite-databases',
                    'name': 'Analyze SQLite Databases',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'find-sqlite-databases',
                            'name': 'Find SQLite Databases',
                            'type': 'command',
                            'metadata': {
                                'command': 'ssh root@<DEVICE_IP> "find /private/var/mobile/Containers/Data/Application/<APP_UUID>/ -name \'*.sqlite\' -o -name \'*.db\'"',
                                'description': 'Locate all SQLite database files',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-name *.sqlite': 'Find .sqlite files',
                                    '-o': 'OR operator',
                                    '-name *.db': 'Find .db files'
                                },
                                'success_indicators': [
                                    'Database files listed',
                                    'Core Data stores found (*.sqlite)',
                                    'Custom databases discovered'
                                ],
                                'next_steps': [
                                    'Download each database file',
                                    'Open with SQLite browser',
                                    'Search for sensitive data in tables',
                                    'Check encryption status'
                                ],
                                'alternatives': [
                                    'Use iExplorer to browse and export',
                                    'Objection: ios sqlite connect <db_path>',
                                    'Extract from backup'
                                ],
                                'notes': """
Common SQLite locations:
- Library/Application Support/*.sqlite (Core Data)
- Documents/*.db (custom databases)
- Library/Caches/*.db (cached data)

SQLite file types:
- *.sqlite - main database
- *.sqlite-shm - shared memory file
- *.sqlite-wal - write-ahead log

Check for:
- User credentials
- Session tokens
- Cached API responses
- Message history
- File paths
- Metadata
                                """
                            }
                        },
                        {
                            'id': 'query-sqlite-databases',
                            'name': 'Query SQLite Databases for Sensitive Data',
                            'type': 'command',
                            'metadata': {
                                'command': 'sqlite3 <database.sqlite> "SELECT name FROM sqlite_master WHERE type=\'table\';" && sqlite3 <database.sqlite> "SELECT * FROM <table_name>;"',
                                'description': 'List tables and query for sensitive data',
                                'tags': ['OSCP:HIGH'],
                                'flag_explanations': {
                                    'sqlite_master': 'Metadata table containing all DB objects',
                                    'type=\'table\'': 'Filter for tables only',
                                    'SELECT *': 'Retrieve all rows and columns'
                                },
                                'success_indicators': [
                                    'Tables listed',
                                    'Sensitive data found in queries',
                                    'Credentials, tokens, or PII discovered'
                                ],
                                'next_steps': [
                                    'Query each table for sensitive content',
                                    'Search for: password, token, email, credit_card, ssn',
                                    'Check if encryption is used',
                                    'Test Core Data encryption status'
                                ],
                                'alternatives': [
                                    'GUI: DB Browser for SQLite',
                                    'Objection: ios sqlite connect <path> → .tables → SELECT * FROM <table>;',
                                    'Python: sqlite3 module for scripting'
                                ],
                                'notes': """
Core Data uses SQLite by default (unencrypted).

Encrypted Core Data:
- Use encrypted-core-data library
- Check for PRAGMA key presence
- Test decryption without key

Sensitive data checks:
SELECT * FROM <table> WHERE column LIKE '%password%';
SELECT * FROM <table> WHERE column LIKE '%token%';
SELECT * FROM <table> WHERE column LIKE '%secret%';

Document findings:
- What data is stored?
- Is it encrypted?
- Does it persist after logout?
- Is it backed up?
                                """
                            }
                        }
                    ]
                },
                {
                    'id': 'analyze-keychain',
                    'name': 'Analyze Keychain Storage',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'dump-keychain',
                            'name': 'Dump Keychain Items',
                            'type': 'command',
                            'metadata': {
                                'command': f'objection -g {bundle_id} explore --quiet --exec "ios keychain dump"',
                                'description': 'Extract all keychain items accessible to the app',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'success_indicators': [
                                    'Keychain items displayed',
                                    'Generic passwords revealed',
                                    'Internet passwords shown',
                                    'Certificates/keys listed'
                                ],
                                'failure_indicators': [
                                    'Empty keychain',
                                    'Access denied (needs jailbreak)'
                                ],
                                'next_steps': [
                                    'Review all keychain items for sensitive data',
                                    'Check kSecAttrAccessible attributes',
                                    'Test if data persists after app uninstall',
                                    'Document insecure accessibility settings'
                                ],
                                'alternatives': [
                                    'Keychain-Dumper: https://github.com/ptoomey3/Keychain-Dumper',
                                    'Manual: security dump-keychain (jailbroken)',
                                    'Parse from backup (if unencrypted)'
                                ],
                                'notes': """
Keychain item types:
- kSecClassGenericPassword (generic secrets)
- kSecClassInternetPassword (web credentials)
- kSecClassCertificate (certificates)
- kSecClassKey (cryptographic keys)
- kSecClassIdentity (certificate + private key)

Accessibility attributes (kSecAttrAccessible):
- kSecAttrAccessibleAlways (INSECURE - always accessible)
- kSecAttrAccessibleWhenUnlocked (locked when device locked)
- kSecAttrAccessibleAfterFirstUnlock (most common)
- kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly (most secure)

WARNING: Keychain data persists after app uninstall!
Test scenario:
1. Install app → login → uninstall
2. Reinstall app
3. Check if keychain data still present

This can leak previous user's credentials on resold devices!
                                """
                            }
                        },
                        {
                            'id': 'dump-nsurlcredentials',
                            'name': 'Dump NSURLCredentialStorage',
                            'type': 'command',
                            'metadata': {
                                'command': f'objection -g {bundle_id} explore --quiet --exec "ios nsurlcredentialstorage dump"',
                                'description': 'Extract credentials stored via NSURLCredential',
                                'tags': ['OSCP:HIGH'],
                                'success_indicators': [
                                    'Stored credentials displayed',
                                    'HTTP authentication credentials revealed',
                                    'Username/password pairs shown'
                                ],
                                'next_steps': [
                                    'Document any exposed credentials',
                                    'Test credential reuse',
                                    'Check if credentials cleared on logout'
                                ],
                                'alternatives': [
                                    'Parse directly from Keychain dump',
                                    'Intercept at runtime with Frida hook'
                                ],
                                'notes': """
NSURLCredentialStorage stores HTTP auth credentials in Keychain.

Common usage:
- HTTP Basic Authentication
- HTTP Digest Authentication
- Client certificates
- Server trust (certificate pinning)

Security considerations:
- Stored in Keychain (good)
- Persistence: NSURLCredentialPersistencePermanent
- May persist across app reinstalls
- Check protection level (kSecAttrAccessible)

Hook NSURLCredential with Frida to capture at runtime:
Interceptor.attach(
    ObjC.classes.NSURLCredential['- initWithUser:password:persistence:'].implementation,
    {
        onEnter: function(args) {
            console.log("User:", ObjC.Object(args[2]).toString());
            console.log("Pass:", ObjC.Object(args[3]).toString());
        }
    }
);
                                """
                            }
                        }
                    ]
                },
                {
                    'id': 'check-cookies',
                    'name': 'Analyze Cookie Storage',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "ios cookies get --json"',
                        'description': 'Extract stored cookies (may contain session tokens)',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': [
                            'Cookies displayed in JSON format',
                            'Session cookies found',
                            'Authentication cookies discovered'
                        ],
                        'next_steps': [
                            'Check for session tokens in cookies',
                            'Test if cookies have secure flag',
                            'Test if cookies have HttpOnly flag',
                            'Test cookie persistence after logout'
                        ],
                        'alternatives': [
                            'Manual: ssh + parse Library/Cookies/cookies.binarycookies',
                            'Python script: https://github.com/mdegrazia/Safari-Binary-Cookie-Parser',
                            'Extract from backup'
                        ],
                        'notes': """
Cookie storage location:
Library/Cookies/cookies.binarycookies (binary format)

Cookie security attributes:
- Secure flag: Cookie only sent over HTTPS
- HttpOnly flag: Cookie not accessible to JavaScript
- SameSite: CSRF protection

Common issues:
1. Session tokens in cookies (should be in Keychain)
2. Missing Secure flag (MITM risk)
3. Missing HttpOnly flag (XSS risk)
4. Cookies persist after logout
5. Long expiration times

Some developers store sensitive data in Keychain instead of cookies (better practice).
                        """
                    }
                },
                {
                    'id': 'check-cache',
                    'name': 'Analyze Cache Storage',
                    'type': 'command',
                    'metadata': {
                        'command': 'ssh root@<DEVICE_IP> "sqlite3 /private/var/mobile/Containers/Data/Application/<APP_UUID>/Library/Caches/<BundleID>/Cache.db \\"SELECT * FROM cfurl_cache_response;\\""',
                        'description': 'Check NSURLSession cache for sensitive data',
                        'tags': ['OSCP:MEDIUM'],
                        'flag_explanations': {
                            'Cache.db': 'NSURLSession cache database',
                            'cfurl_cache_response': 'Table containing cached HTTP responses'
                        },
                        'success_indicators': [
                            'Cached responses displayed',
                            'Sensitive data in cached requests/responses',
                            'API tokens, credentials in cache'
                        ],
                        'next_steps': [
                            'Review cached requests for sensitive data',
                            'Check if cache cleared after logout',
                            'Test if ephemeral sessions used for sensitive requests',
                            'Recommend removeAllCachedResponses() on logout'
                        ],
                        'alternatives': [
                            'Objection: ios sqlite connect Cache.db',
                            'Parse with Python sqlite3 module',
                            'Extract from backup'
                        ],
                        'notes': """
NSURLSession cache location:
Library/Caches/<BundleID>/Cache.db

Cache types:
- .default: Stores to disk
- .ephemeral: Stores to RAM only (recommended for sensitive)

Disable caching:
URLCache.shared.removeAllCachedResponses()

Or use ephemeral session:
let config = URLSessionConfiguration.ephemeral
let session = URLSession(configuration: config)

Cache can contain:
- API responses with sensitive data
- Authentication tokens in headers
- User PII
- Session identifiers

Should be cleared on logout!
                        """
                    }
                },
                {
                    'id': 'check-snapshots',
                    'name': 'Check App Snapshots for Data Leakage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check if app backgrounds show sensitive data',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': """
iOS takes snapshots when app backgrounds (home button pressed).

Snapshot locations:
- Library/Caches/Snapshots/
- Library/SplashBoard/Snapshots/

Risk: Sensitive data visible in app switcher.

Test procedure:
1. Display sensitive data in app (password, credit card, etc.)
2. Press home button
3. Double-tap home to see app switcher
4. Check if sensitive data visible

Via SSH:
ssh root@<DEVICE_IP>
cd /private/var/mobile/Containers/Data/Application/<APP_UUID>/Library/Caches/Snapshots/
ls -la
# Download and inspect images

Mitigation:
Implement applicationDidEnterBackground() to:
- Overlay blank screen
- Remove sensitive data from view
- Show placeholder image

Swift example:
func applicationDidEnterBackground(_ application: UIApplication) {
    let overlay = UIImageView(image: UIImage(named: "placeholder"))
    overlay.frame = UIScreen.main.bounds
    overlay.tag = 999
    window?.addSubview(overlay)
}

func applicationWillEnterForeground(_ application: UIApplication) {
    window?.viewWithTag(999)?.removeFromSuperview()
}
                        """,
                        'alternatives': [
                            'Extract snapshots from backup',
                            'Use Xcode Instruments to monitor'
                        ]
                    }
                },
                {
                    'id': 'check-keyboard-cache',
                    'name': 'Check Keyboard Cache',
                    'type': 'command',
                    'metadata': {
                        'command': 'ssh root@<DEVICE_IP> "cat /private/var/mobile/Library/Keyboard/dynamic-text.dat"',
                        'description': 'Check autocorrect cache for sensitive data',
                        'tags': ['OSCP:MEDIUM'],
                        'success_indicators': [
                            'Cached text displayed',
                            'User input history revealed',
                            'Sensitive data typed found'
                        ],
                        'next_steps': [
                            'Check if passwords/PINs cached',
                            'Verify secure text entry for sensitive fields',
                            'Test autocorrection disabled for passwords'
                        ],
                        'alternatives': [
                            'Check locale-specific: Library/Keyboard/en-dynamic-text.dat',
                            'Extract from backup',
                            'Reset keyboard dictionary to test'
                        ],
                        'notes': """
Keyboard cache location:
/private/var/mobile/Library/Keyboard/dynamic-text.dat
/private/var/mobile/Library/Keyboard/<locale>-dynamic-text.dat

iOS keyboard caches user input for autocorrect/suggestions.

Risk: Passwords, PINs, credit cards cached.

Mitigation:
1. Set autocorrectionType = UITextAutocorrectionTypeNo
2. Set secureTextEntry = YES for sensitive fields

UITextField *passwordField = [[UITextField alloc] init];
passwordField.autocorrectionType = UITextAutocorrectionTypeNo;
passwordField.secureTextEntry = YES;

Also disable custom keyboards for sensitive fields:
textField.keyboardType = UIKeyboardType.asciiCapable

User can reset cache:
Settings → General → Reset → Reset Keyboard Dictionary
                        """
                    }
                },
                {
                    'id': 'check-logs',
                    'name': 'Check Application Logs',
                    'type': 'command',
                    'metadata': {
                        'command': f'idevicesyslog -u <DEVICE_ID> | grep {bundle_id}',
                        'description': 'Monitor system logs for sensitive data leakage',
                        'tags': ['OSCP:HIGH'],
                        'flag_explanations': {
                            '-u': 'Specify device by UUID',
                            'grep': 'Filter logs for specific app'
                        },
                        'success_indicators': [
                            'Log stream displayed',
                            'App logs captured',
                            'Sensitive data in logs (VULNERABILITY)'
                        ],
                        'failure_indicators': [
                            'No logs (good - minimal logging)',
                            'Only benign logs'
                        ],
                        'next_steps': [
                            'Search logs for: password, token, secret, key, api',
                            'Test all app features while monitoring',
                            'Document any sensitive data exposure',
                            'Recommend removing NSLog statements in production'
                        ],
                        'alternatives': [
                            'Xcode: Window → Devices → Open Console',
                            'SSH + socat: socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock',
                            'libimobiledevice: idevicesyslog'
                        ],
                        'notes': """
Common logging sources:
- NSLog() (Objective-C)
- print() (Swift)
- os_log() (Unified Logging)
- Custom logging frameworks

Search for:
NSLog(@"Password: %@", password);  // BAD!
print("API Token: \\(token)")       // BAD!

Logs persist and are accessible:
- Via device logs
- In crash reports
- In Xcode console
- Via libimobiledevice

Production apps should:
- Remove/disable debug logs
- Use conditional logging (#if DEBUG)
- Never log sensitive data

Check crash logs:
/private/var/mobile/Library/Logs/CrashReporter/<app>*
                        """
                    }
                }
            ]
        })

        # === PHASE 5: DYNAMIC ANALYSIS ===
        tasks['children'].append({
            'id': 'dynamic-analysis',
            'name': 'Dynamic Runtime Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'list-installed-apps',
                    'name': 'List Installed Applications',
                    'type': 'command',
                    'metadata': {
                        'command': 'frida-ps -Uai',
                        'description': 'List all installed apps with bundle identifiers',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-U': 'Connect to USB device',
                            '-a': 'List applications',
                            '-i': 'Include bundle identifiers'
                        },
                        'success_indicators': [
                            'List of apps displayed',
                            'Target app visible with bundle ID'
                        ],
                        'next_steps': [
                            'Note bundle ID for target app',
                            'Attach to app with objection',
                            'Start dynamic instrumentation'
                        ],
                        'alternatives': [
                            'SSH: ls /var/mobile/Containers/Bundle/Application/',
                            'Xcode: Window → Devices → Installed Apps'
                        ],
                        'notes': 'Bundle ID format: com.company.appname (e.g., com.apple.mobilesafari)'
                    }
                },
                {
                    'id': 'attach-objection',
                    'name': 'Attach Objection to Running App',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore',
                        'description': 'Attach Objection for interactive runtime testing',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-g': 'Gadget mode (attach to app)',
                            'explore': 'Start interactive REPL'
                        },
                        'success_indicators': [
                            'Objection REPL prompt displayed',
                            'Connection successful',
                            'Can execute commands'
                        ],
                        'next_steps': [
                            'Get binary info: ios info binary',
                            'List classes: ios hooking list classes',
                            'Start SSL pinning bypass: ios sslpinning disable',
                            'Bypass jailbreak detection: ios jailbreak disable'
                        ],
                        'alternatives': [
                            'Frida CLI: frida -U -f <bundle_id> -l script.js',
                            'Cycript: cycript -p <PID>',
                            'r2frida: r2 frida://usb//<bundle_id>'
                        ],
                        'notes': """
Common Objection commands:

Information gathering:
- env (app paths)
- ios info binary (binary info)
- ios plist cat <path> (read plist)

Hooking:
- ios hooking list classes (list Objective-C classes)
- ios hooking search classes <pattern>
- ios hooking list class_methods <class>
- ios hooking watch class <class>
- ios hooking watch method <method> --dump-args --dump-return

Bypass:
- ios jailbreak disable
- ios sslpinning disable
- ios ui biometrics_bypass

Data extraction:
- ios keychain dump
- ios cookies get
- ios nsuserdefaults get

Filesystem:
- file download <remote> <local>
- file upload <local> <remote>
                        """
                    }
                },
                {
                    'id': 'enumerate-classes',
                    'name': 'Enumerate Objective-C Classes',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "ios hooking list classes"',
                        'description': 'List all Objective-C classes in the application',
                        'tags': ['OSCP:MEDIUM'],
                        'success_indicators': [
                            'Long list of classes displayed',
                            'Custom app classes visible',
                            'Framework classes listed'
                        ],
                        'next_steps': [
                            'Search for interesting classes: ios hooking search classes <keyword>',
                            'List methods: ios hooking list class_methods <ClassName>',
                            'Hook interesting methods for monitoring'
                        ],
                        'alternatives': [
                            'class-dump on decrypted binary',
                            'Frida: ObjC.enumerateLoadedClasses()',
                            'Cycript: [c for (c in ObjectiveC.classes)]'
                        ],
                        'notes': """
Look for interesting class patterns:
- *ViewController (UI logic)
- *Manager (business logic)
- *Service (API/network)
- *Auth* (authentication)
- *Login* (login flow)
- *Crypto* (cryptography)
- *Database* (data storage)
- *Network* (networking)

Example workflow:
1. ios hooking search classes Auth
2. ios hooking list class_methods AuthManager
3. ios hooking watch method "-[AuthManager login:password:]" --dump-args
                        """
                    }
                },
                {
                    'id': 'hook-crypto-functions',
                    'name': 'Monitor Cryptography Functions',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "ios monitor crypt"',
                        'description': 'Auto-hook common crypto functions to monitor keys/algorithms',
                        'tags': ['OSCP:HIGH', 'AUTOMATED'],
                        'success_indicators': [
                            'Crypto hooks installed',
                            'Encryption/decryption calls logged',
                            'Keys and algorithms visible'
                        ],
                        'next_steps': [
                            'Trigger crypto operations in app',
                            'Analyze logged keys and algorithms',
                            'Check for weak crypto (DES, MD5, hardcoded keys)'
                        ],
                        'alternatives': [
                            'Frida script to hook CCCrypt manually',
                            'Hook CommonCrypto functions individually'
                        ],
                        'notes': """
Objection monitors:
- CCCrypt (encryption/decryption)
- CCHmac (HMAC)
- CCKeyDerivationPBKDF (key derivation)
- SecKeyEncrypt/Decrypt
- CommonDigest functions (hashing)

Look for:
1. Hardcoded keys in code
2. Weak algorithms (DES, RC4, MD5)
3. ECB mode (insecure)
4. Short key lengths
5. Keys derived from predictable data

Example Frida script:
Interceptor.attach(Module.findExportByName(null, "CCCrypt"), {
    onEnter: function(args) {
        console.log("Algorithm:", args[0]);
        console.log("Key:", hexdump(args[3]));
    }
});
                        """
                    }
                },
                {
                    'id': 'dump-memory',
                    'name': 'Dump Process Memory',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "memory dump all <output_dir>"',
                        'description': 'Dump app memory for offline analysis',
                        'tags': ['OSCP:MEDIUM'],
                        'success_indicators': [
                            'Memory dump created',
                            'Multiple memory regions dumped',
                            'Files created in output directory'
                        ],
                        'next_steps': [
                            'Search for strings: strings memory.dmp | grep -i "password\\|token\\|secret"',
                            'Use radare2: r2 memory.dmp → /w <search>',
                            'Extract crypto keys from memory'
                        ],
                        'alternatives': [
                            'Fridump: python3 fridump.py -U -n <bundle_id>',
                            'Manual: gdb attach → gcore',
                            'r2frida: r2 frida://usb//<bundle_id> → dm → dc'
                        ],
                        'notes': """
Memory dump analysis:
1. Extract strings:
   strings memory.dmp > strings.txt
   grep -i "password\\|token\\|secret\\|key" strings.txt

2. Search for patterns:
   - Credit card: [0-9]{16}
   - SSN: [0-9]{3}-[0-9]{2}-[0-9]{4}
   - Email: [a-z0-9]+@[a-z]+\\.[a-z]+

3. Find crypto keys:
   - AES keys (16/24/32 bytes)
   - RSA keys (modulus/exponent)

4. Use r2 for deep analysis:
   r2 memory.dmp
   /w api_key=
   /x 414243  # hex search

Best time to dump:
- After login (credentials in memory)
- During crypto operations (keys loaded)
- After API calls (tokens in memory)
                        """
                    }
                }
            ]
        })

        # === PHASE 6: BINARY REVERSING ===
        tasks['children'].append({
            'id': 'binary-reversing',
            'name': 'Binary Reverse Engineering',
            'type': 'parent',
            'children': [
                {
                    'id': 'otool-inspection',
                    'name': 'Binary Inspection with otool',
                    'type': 'parent',
                    'children': [
                        {
                            'id': 'otool-header',
                            'name': 'Inspect Mach-O Header',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -Vh Payload/{app_name}.app/{app_name}',
                                'description': 'Display binary header with compilation flags',
                                'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-V': 'Verbose output',
                                    '-h': 'Display Mach-O header'
                                },
                                'success_indicators': [
                                    'Header displayed',
                                    'Architecture shown (ARM64)',
                                    'Flags visible (PIE, NOUNDEFS, etc.)'
                                ],
                                'next_steps': [
                                    'Verify PIE flag present',
                                    'Check architecture (should be ARM64)',
                                    'Note any unusual flags'
                                ],
                                'alternatives': [
                                    'MachOView GUI tool',
                                    'Hopper Disassembler header view'
                                ],
                                'notes': 'Common architectures: ARM64 (iOS 11+), ARMV7 (legacy)'
                            }
                        },
                        {
                            'id': 'otool-libraries',
                            'name': 'List Linked Libraries',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -L Payload/{app_name}.app/{app_name}',
                                'description': 'List all dynamically linked libraries and frameworks',
                                'tags': ['OSCP:MEDIUM', 'QUICK_WIN'],
                                'flag_explanations': {
                                    '-L': 'List shared libraries used'
                                },
                                'success_indicators': [
                                    'Libraries listed with paths',
                                    'System frameworks visible',
                                    'Third-party libraries identified'
                                ],
                                'next_steps': [
                                    'Research third-party libraries for known vulns',
                                    'Check library versions',
                                    'Note unusual/suspicious libraries'
                                ],
                                'alternatives': [
                                    'class-dump to see framework classes',
                                    'Hopper: View → Segments → External Symbols'
                                ],
                                'notes': """
Common iOS frameworks:
- Foundation.framework (basic types)
- UIKit.framework (UI)
- Security.framework (Keychain, crypto)
- LocalAuthentication.framework (Touch ID/Face ID)
- CoreData.framework (database)

Look for:
- Third-party libraries (potential vulns)
- Analytics frameworks (privacy concerns)
- Ad frameworks (data collection)
- Crypto libraries (implementation flaws)

Example third-party:
- Alamofire (networking)
- Realm (database)
- Firebase (analytics/backend)
                                """
                            }
                        },
                        {
                            'id': 'otool-symbols',
                            'name': 'List Symbols (Functions/Methods)',
                            'type': 'command',
                            'metadata': {
                                'command': f'otool -I -v Payload/{app_name}.app/{app_name} | less',
                                'description': 'List imported symbols (functions called)',
                                'tags': ['OSCP:MEDIUM'],
                                'flag_explanations': {
                                    '-I': 'Display indirect symbol table',
                                    '-v': 'Verbose (symbol names)'
                                },
                                'success_indicators': [
                                    'Long list of symbols',
                                    'Function names visible',
                                    'Crypto/network functions identifiable'
                                ],
                                'next_steps': [
                                    'Search for interesting functions: grep "auth\\|login\\|crypt"',
                                    'Identify entry points for hooking',
                                    'Note custom vs system functions'
                                ],
                                'alternatives': [
                                    'nm -u <binary> (list undefined symbols)',
                                    'rabin2 -i <binary> (radare2)',
                                    'Hopper: View → Procedures'
                                ],
                                'notes': 'Symbols useful for identifying functions to hook with Frida/Cycript'
                            }
                        }
                    ]
                },
                {
                    'id': 'class-dump-analysis',
                    'name': 'Extract Objective-C Headers',
                    'type': 'command',
                    'metadata': {
                        'command': f'class-dump Payload/{app_name}.app/{app_name} > {app_name}_headers.h',
                        'description': 'Extract Objective-C class/method declarations',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': [
                            'Header file created',
                            '@interface declarations visible',
                            'Method signatures extracted'
                        ],
                        'failure_indicators': [
                            'Binary encrypted (cryptid=1)',
                            'No Objective-C runtime info'
                        ],
                        'next_steps': [
                            'Review for interesting classes/methods',
                            'Identify authentication logic',
                            'Find crypto implementations',
                            'Use headers for manual reversing reference'
                        ],
                        'alternatives': [
                            'class-dump-z (improved version)',
                            'Hopper: Generate Pseudo-Code',
                            'Ghidra: View → Decompiler'
                        ],
                        'notes': """
class-dump output structure:
@interface ClassName : SuperClass
- (returnType)methodName:(argType)arg;
+ (returnType)classMethod:(argType)arg;
@property (attributes) type *propertyName;
@end

Download class-dump:
http://stevenygard.com/projects/class-dump/

Look for:
- Authentication methods (login, verify, validate)
- Crypto methods (encrypt, decrypt, hash)
- Network methods (request, response, API)
- Data storage (save, load, persist)
- Validation methods (check, verify, validate)

Example interesting findings:
- (BOOL)validatePIN:(NSString *)pin;
- (NSString *)decryptData:(NSData *)data withKey:(NSString *)key;
- (void)bypassJailbreakCheck;
                        """
                    }
                },
                {
                    'id': 'disassemble-with-hopper',
                    'name': 'Disassemble with Hopper/Ghidra',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Deep binary analysis with disassembler',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': """
Recommended disassemblers:

1. **Hopper Disassembler** (macOS) - BEST for iOS
   - https://www.hopperapp.com/
   - Native Objective-C/Swift support
   - Excellent decompiler
   - ARM64 optimized
   - $99 (Demo available)

2. **Ghidra** (Free, cross-platform)
   - https://ghidra-sre.org/
   - NSA tool, very powerful
   - Good ARM support
   - Free and open source

3. **IDA Pro** ($$$ - Professional)
   - Best in class
   - Expensive ($$$)
   - Excellent ARM/Thumb support

4. **radare2/Cutter** (Free, CLI + GUI)
   - https://rada.re/
   - Cutter = GUI frontend
   - Steep learning curve
   - Very powerful

Analysis workflow:
1. Load decrypted binary in Hopper/Ghidra
2. Let auto-analysis complete
3. Search for interesting strings
4. Follow cross-references to functions
5. Analyze authentication logic
6. Identify crypto implementations
7. Find jailbreak/debug checks
8. Document findings

Key areas to analyze:
- Application:didFinishLaunching: (entry point)
- viewDidLoad methods (UI initialization)
- Authentication view controllers
- Network request methods
- Crypto function calls
- Jailbreak detection functions

Hopper tips:
- Shift+X: Cross-references
- Option+Enter: Follow jump/call
- Cmd+Shift+D: Decompile
- Cmd+F: Search strings

Ghidra tips:
- Window → Defined Strings (search strings)
- Right-click function → Decompile
- Display → Function Call Graph
                        """
                    }
                }
            ]
        })

        # === PHASE 7: LOCAL AUTHENTICATION BYPASS ===
        tasks['children'].append({
            'id': 'local-auth-bypass',
            'name': 'Local Authentication Bypass',
            'type': 'parent',
            'children': [
                {
                    'id': 'detect-local-auth',
                    'name': 'Detect Local Authentication Framework',
                    'type': 'command',
                    'metadata': {
                        'command': f'otool -L Payload/{app_name}.app/{app_name} | grep LocalAuthentication',
                        'description': 'Check if app uses LocalAuthentication framework',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN'],
                        'success_indicators': [
                            'LocalAuthentication.framework found',
                            'Touch ID/Face ID likely used'
                        ],
                        'failure_indicators': [
                            'No LocalAuthentication (custom auth or none)'
                        ],
                        'next_steps': [
                            'If found: Test Objection biometrics bypass',
                            'Hook evaluatePolicy method with Frida',
                            'Test if auth can be bypassed'
                        ],
                        'alternatives': [
                            'Runtime detection: ios hooking list classes | grep LAContext',
                            'Static: Search for LAContext in class-dump output'
                        ],
                        'notes': """
LocalAuthentication framework provides:
- Touch ID authentication
- Face ID authentication
- Device passcode fallback

Key class: LAContext
Key method: evaluatePolicy:localizedReason:reply:

Two policies:
1. LAPolicyDeviceOwnerAuthenticationWithBiometrics (biometrics only)
2. LAPolicyDeviceOwnerAuthentication (biometrics + passcode)

Vulnerable implementation:
Relies only on boolean return value without transmitting proof of authentication.

This is bypassable by hooking the callback!
                        """
                    }
                },
                {
                    'id': 'bypass-biometrics-objection',
                    'name': 'Bypass Biometrics with Objection',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "ios ui biometrics_bypass"',
                        'description': 'Auto-bypass Touch ID/Face ID authentication',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                        'success_indicators': [
                            'Hook registered',
                            'Auth prompt triggered',
                            'Bypass successful (access granted without biometrics)'
                        ],
                        'failure_indicators': [
                            'Hook failed',
                            'App uses secure auth (Keychain + biometrics)'
                        ],
                        'next_steps': [
                            'If successful: Document as critical vulnerability',
                            'Test if local auth used for critical functions',
                            'Recommend using Keychain with SecAccessControl',
                            'If failed: Analyze custom authentication logic'
                        ],
                        'alternatives': [
                            'Manual Frida script (see notes)',
                            'Patch evaluatePolicy in Hopper/Ghidra',
                            'Cycript hooking'
                        ],
                        'notes': """
Objection biometrics bypass works by:
1. Hooking LAContext.evaluatePolicy
2. Intercepting the callback
3. Forcing success=True

Manual Frida bypass:
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
    onEnter: function(args) {
        var block = new ObjC.Block(args[4]);
        const callback = block.implementation;
        block.implementation = function (error, value) {
            console.log("Bypassing biometrics...");
            return callback(1, null); // Force success
        };
    }
});

Why this works:
LocalAuthentication only returns boolean.
No cryptographic proof sent to server.
Purely local check.

Secure alternative:
Store sensitive data in Keychain with SecAccessControl:
- Require biometrics to access Keychain item
- Keychain protected by Secure Enclave
- Cannot be bypassed by hooking
                        """
                    }
                },
                {
                    'id': 'test-custom-pin',
                    'name': 'Test Custom PIN/Password Auth',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test custom authentication implementations',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': """
If app uses custom PIN/password (not LocalAuthentication):

1. **Identify auth method** (class-dump or runtime):
   - Search for: validate, verify, authenticate, checkPassword, checkPIN
   - Example: - (BOOL)validatePIN:(NSString *)pin;

2. **Hook the method with Frida**:
   var ClassName = ObjC.classes.AuthViewController;
   Interceptor.attach(ClassName["- validatePIN:"].implementation, {
       onLeave: function(retval) {
           console.log("Original return:", retval);
           retval.replace(ptr(1)); // Force return YES/true
       }
   });

3. **Or hook in Objection**:
   ios hooking watch method "-[AuthViewController validatePIN:]" --dump-args --dump-return

4. **Patch binary**:
   - Disassemble in Hopper
   - Find comparison (CMP, BNE)
   - Change to always branch (B)

5. **Test for hardcoded credentials**:
   - Search strings for: pin=, password=, default
   - Check Info.plist, config files
   - Dump NSUserDefaults

6. **Brute force** (if limited tries):
   - Script rapid PIN attempts
   - Check for rate limiting
   - Test account lockout

7. **Storage analysis**:
   - Where is correct PIN stored?
   - Is it hashed? Encrypted?
   - Can it be extracted?

Common vulns:
- PIN stored in NSUserDefaults (plaintext)
- Hardcoded default PIN
- Client-side only validation
- No rate limiting
- Weak hashing (MD5)
                        """
                    }
                }
            ]
        })

        # === PHASE 8: NETWORK COMMUNICATION ===
        tasks['children'].append({
            'id': 'network-analysis',
            'name': 'Network Communication Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'setup-burp-proxy',
                    'name': 'Configure Burp Suite Proxy',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Set up MITM proxy for traffic interception',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'SETUP'],
                        'notes': """
Burp Suite proxy setup for iOS:

1. **Configure Burp**:
   - Proxy → Options
   - Add new listener: 0.0.0.0:8080
   - Enable "All interfaces"

2. **Configure iOS device**:
   - Settings → Wi-Fi
   - Tap connected network → Configure Proxy
   - Manual: <YOUR_IP>:8080

3. **Install Burp CA certificate**:
   - iOS Safari: http://<BURP_IP>:8080
   - Tap "CA Certificate" → Allow → Install
   - Settings → General → Profile → Install
   - Settings → General → About → Certificate Trust Settings
   - Enable "Burp Suite CA" (CRITICAL!)

4. **Test connection**:
   - Browse to http://example.com
   - Check Burp HTTP history

5. **If no traffic appears**:
   - App may use certificate pinning (bypass needed)
   - App may use non-HTTP protocol
   - Check iOS proxy settings still enabled

Alternative proxies:
- Charles Proxy (macOS friendly)
- mitmproxy (CLI, scriptable)
- Fiddler (Windows)
- ZAP (free alternative to Burp)
                        """
                    }
                },
                {
                    'id': 'bypass-ssl-pinning',
                    'name': 'Bypass SSL Certificate Pinning',
                    'type': 'command',
                    'metadata': {
                        'command': f'objection -g {bundle_id} explore --quiet --exec "ios sslpinning disable"',
                        'description': 'Disable SSL pinning to allow MITM',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'AUTOMATED'],
                        'success_indicators': [
                            'SSL pinning hooks installed',
                            'Traffic visible in Burp',
                            'HTTPS requests intercepted'
                        ],
                        'failure_indicators': [
                            'No traffic in Burp (pinning not bypassed)',
                            'SSL errors in app',
                            'App crashes'
                        ],
                        'next_steps': [
                            'Interact with all app features',
                            'Capture API endpoints and parameters',
                            'Test for web vulnerabilities',
                            'Document sensitive data in requests'
                        ],
                        'alternatives': [
                            'SSL Kill Switch 2: Cydia tweak (system-wide)',
                            'Burp Mobile Assistant app',
                            'Manual Frida script for custom pinning',
                            'Patch binary to remove pinning'
                        ],
                        'notes': """
SSL pinning implementations:

1. **NSURLSession delegate**:
   - didReceiveChallenge method
   - Custom certificate validation

2. **TrustKit** (common library):
   - Certificate/public key pinning

3. **AFNetworking**:
   - SSLPinningMode

4. **Custom implementations**

Objection bypass works for common cases.

For stubborn pinning:
1. Use SSL Kill Switch 2 (system-wide):
   - Cydia: https://github.com/nabla-c0d3/ssl-kill-switch2
   - Installs system-wide hooks

2. Custom Frida script:
   - Hook specific pinning implementation
   - Example: Hook TrustKit methods

3. Patch binary:
   - Find pinning check in Hopper
   - NOP the validation
   - Repackage IPA

Without pinning bypass:
- Cannot intercept HTTPS traffic
- Limited to non-TLS analysis
- Check for cleartext HTTP (ATS bypass)
                        """
                    }
                },
                {
                    'id': 'test-web-vulns',
                    'name': 'Test for Web Vulnerabilities',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test intercepted API for common web vulns',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': """
With traffic intercepted in Burp, test for:

1. **Authentication/Session**:
   - Weak session tokens
   - Token expiration
   - Logout functionality
   - Concurrent sessions

2. **Authorization**:
   - IDOR (change user IDs)
   - Privilege escalation
   - Direct object references

3. **Injection**:
   - SQL injection
   - NoSQL injection
   - Command injection
   - XML/XXE injection

4. **Business Logic**:
   - Price manipulation
   - Negative quantities
   - Race conditions
   - Parameter tampering

5. **Sensitive Data Exposure**:
   - API keys in responses
   - PII in error messages
   - Debug info leakage
   - Stack traces

6. **Security Misconfig**:
   - Verbose errors
   - Default credentials
   - Unnecessary endpoints
   - CORS misconfig

7. **API-Specific**:
   - Mass assignment
   - Excessive data exposure
   - Lack of rate limiting
   - Missing resource restrictions

Use Burp Suite tools:
- Repeater (manual testing)
- Intruder (fuzzing)
- Scanner (automated)
- Sequencer (token analysis)

Document all findings with:
- Request/response
- Steps to reproduce
- Impact assessment
                        """
                    }
                },
                {
                    'id': 'check-cleartext-http',
                    'name': 'Check for Cleartext HTTP Traffic',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Verify no sensitive data sent over HTTP',
                        'tags': ['OSCP:HIGH'],
                        'notes': """
If ATS disabled (NSAllowsArbitraryLoads=YES):

1. **Test without SSL pinning bypass**:
   - Set up Burp proxy
   - DON'T bypass pinning
   - Use app normally
   - Check for HTTP (not HTTPS) traffic

2. **Look for in HTTP requests**:
   - Credentials
   - Session tokens
   - API keys
   - Personal data
   - Any sensitive information

3. **Document findings**:
   - Which endpoints use HTTP
   - What data is exposed
   - Impact assessment

4. **Recommend fix**:
   - Remove ATS exceptions
   - Use HTTPS for all traffic
   - Implement certificate pinning

Common HTTP endpoints:
- http://api.example.com/
- http://example.com/api/
- http://img.example.com/ (often images)

Even if images over HTTP:
- Cookies may leak
- Session tokens in headers
- MITM injection possible

CRITICAL: Credentials/tokens over HTTP = CRITICAL vulnerability!
                        """
                    }
                }
            ]
        })

        # === PHASE 9: IPC TESTING ===
        tasks['children'].append({
            'id': 'ipc-testing',
            'name': 'Inter-Process Communication Testing',
            'type': 'parent',
            'children': [
                {
                    'id': 'test-custom-schemes',
                    'name': 'Test Custom URL Scheme Handling',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test deep links and custom URL schemes',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': """
Custom URL schemes found in Info.plist (CFBundleURLSchemes).

Testing methodology:

1. **Basic invocation**:
   xcrun simctl openurl booted <scheme>://test

   Real device:
   - Create HTML: <a href="myapp://test">Open</a>
   - Host on server, open in Safari

2. **Test cases**:
   - myapp://                    (basic)
   - myapp://host/path           (structure)
   - myapp://host/path?param=val (parameters)
   - myapp://?redirect=http://evil.com (open redirect)
   - myapp://?param=<script>alert(1)</script> (XSS)
   - myapp://?file=../../etc/passwd (path traversal)
   - myapp://javascript:alert(1) (JS injection)

3. **Identify handler method**:
   Search class-dump for:
   - application:openURL:options:
   - application:handleOpenURL:

   Hook with Frida:
   var AppDelegate = ObjC.classes.AppDelegate;
   Interceptor.attach(AppDelegate["- application:openURL:options:"].implementation, {
       onEnter: function(args) {
           console.log("URL:", ObjC.Object(args[3]).toString());
       }
   });

4. **Common vulnerabilities**:
   - No input validation
   - URL injection (redirect to external)
   - XSS in WebView loading URL
   - Path traversal
   - Sensitive actions exposed
   - No authentication check

5. **Sensitive actions to test**:
   - myapp://logout
   - myapp://delete_account
   - myapp://transfer?amount=1000
   - myapp://change_password?new=test

6. **Scheme hijacking**:
   - Create test app registering same scheme
   - iOS will prompt user which app to open
   - First-installed typically wins
   - Can intercept sensitive data

Example exploits:
- Open redirect: myapp://redirect?url=http://evil.com
- XSS: myapp://webview?url=javascript:alert(document.cookie)
- CSRF: <img src="myapp://delete_account">
                        """
                    }
                },
                {
                    'id': 'test-universal-links',
                    'name': 'Test Universal Links',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test universal link implementation and AASA file',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': """
Universal Links = iOS 9+ deep linking using HTTPS.

1. **Check for universal links**:
   Info.plist → com.apple.developer.associated-domains
   Example: applinks:example.com

2. **Download AASA file**:
   https://example.com/.well-known/apple-app-site-association
   OR
   https://example.com/apple-app-site-association

3. **Analyze AASA file**:
   {
     "applinks": {
       "apps": [],
       "details": [{
         "appID": "TEAM.BUNDLE.ID",
         "paths": ["/buy/*", "/products/*"]
       }]
     }
   }

4. **Test cases**:
   - https://example.com/buy/item123
   - https://example.com/products/../admin (path traversal)
   - https://example.com/buy/?redirect=evil.com
   - https://example.com/buy/?param=<script>

5. **Verify implementation**:
   - application:continueUserActivity:restorationHandler:
   - Check URL parsing and validation

6. **Common issues**:
   - Overly broad paths (paths: ["*"])
   - No input validation
   - Path traversal
   - Open redirects
   - XSS in WebViews

7. **Security checklist**:
   - [ ] AASA file properly configured
   - [ ] HTTPS only (never HTTP)
   - [ ] Specific paths (not wildcard)
   - [ ] URL validation in handler
   - [ ] No sensitive actions without auth
   - [ ] No open redirects

Universal Links vs Custom Schemes:
- UL: More secure (domain ownership verified)
- UL: HTTPS requirement
- UL: No scheme hijacking
- CS: Easier to test
- CS: Can be hijacked

Test on device (not simulator):
- Simulator may not validate AASA properly
                        """
                    }
                },
                {
                    'id': 'test-uipasteboard',
                    'name': 'Test UIPasteboard Data Leakage',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Check for sensitive data in clipboard',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': """
UIPasteboard = iOS clipboard (shared across apps!).

Risk: App copies sensitive data → any app can read it.

1. **Monitor pasteboard**:
   Objection:
   ios pasteboard monitor

   Frida script:
   setInterval(function() {
       var pb = ObjC.classes.UIPasteboard.generalPasteboard();
       var content = pb.string();
       if (content) console.log("Clipboard:", content.toString());
   }, 1000);

2. **Test scenarios**:
   - Copy password from password field
   - Copy credit card number
   - Copy authentication token
   - Copy personal data
   - Copy API responses

3. **Check what app copies**:
   - Use all copy functions in app
   - Monitor with Frida script
   - Document any sensitive data

4. **Check what app reads**:
   - Pre-fill clipboard with test data
   - Launch app
   - Check if app reads clipboard

5. **Security recommendations**:
   - Never copy passwords/tokens to general pasteboard
   - Use UIPasteboard with private name:
     UIPasteboard.withName("com.app.private")
   - Set expiration:
     pasteboard.setData(data, forPasteboardType: type, expirationDate: date)
   - Disable copy on sensitive fields:
     textField.isUserInteractionEnabled = false

6. **Additional context**:
   - Clipboard accessible to all apps
   - Persists across app switches
   - Can leak to other apps/devices (Universal Clipboard)
   - Keyboard managers can access clipboard

Example Frida script:
var UIPasteboard = ObjC.classes.UIPasteboard;
Interceptor.attach(UIPasteboard['- setString:'].implementation, {
    onEnter: function(args) {
        console.log("[Pasteboard WRITE]:", ObjC.Object(args[2]).toString());
    }
});
Interceptor.attach(UIPasteboard['- string'].implementation, {
    onLeave: function(retval) {
        if (retval.isNull() === false)
            console.log("[Pasteboard READ]:", ObjC.Object(retval).toString());
    }
});
                        """
                    }
                },
                {
                    'id': 'test-webviews',
                    'name': 'Test WebView Security',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Analyze WebView usage and JavaScript bridges',
                        'tags': ['OSCP:HIGH', 'MANUAL'],
                        'notes': """
iOS WebView types:
1. UIWebView (deprecated, still in old apps)
2. WKWebView (modern, iOS 8+)
3. SFSafariViewController (uses Safari)

Security checks:

1. **Identify WebView type**:
   class-dump or runtime:
   ios hooking search classes WebView

2. **Check JavaScript enabled**:
   WKWebView: javaScriptEnabled property
   UIWebView: javaScriptEnabled property

   If disabled: Limited attack surface (good)
   If enabled: Test XSS and JS bridge

3. **Check file:// access**:
   WKWebView: allowFileAccessFromFileURLs
   WKWebView: allowUniversalAccessFromFileURLs

   If true: Can access local files (HIGH RISK)

4. **Test JavaScript bridge** (critical!):
   Search for:
   - evaluateJavaScript (WKWebView)
   - stringByEvaluatingJavaScriptFromString (UIWebView)
   - addScriptMessageHandler (WKWebView JS → Native)
   - JSContext (JavaScriptCore bridge)

   Hook with Frida:
   var WKWebView = ObjC.classes.WKWebView;
   Interceptor.attach(WKWebView['- evaluateJavaScript:completionHandler:'].implementation, {
       onEnter: function(args) {
           console.log("JS:", ObjC.Object(args[2]).toString());
       }
   });

5. **Test XSS**:
   If WebView loads user input:
   - Test <script>alert(1)</script>
   - Test <img src=x onerror=alert(1)>
   - Test DOM-based XSS

6. **Test file:// access**:
   If file:// allowed:
   - Load file://etc/passwd
   - Load file://private/var/mobile/Containers/...
   - Access app sandbox files

7. **Test postMessage bridge**:
   If JS can call native:
   window.webkit.messageHandlers.<handler>.postMessage(data)

   Test:
   - Can you call sensitive functions?
   - Is input validated?
   - Can you exfiltrate data?

8. **Common vulnerabilities**:
   - XSS if loading untrusted content
   - File access if file:// enabled
   - Native function exposure via bridge
   - No input validation on JS bridge
   - Sensitive data exposure to JS

9. **Security recommendations**:
   - Disable javaScriptEnabled if not needed
   - Never enable file:// access
   - Validate all JS bridge inputs
   - Use allowlist for bridge functions
   - Sanitize URLs before loading
   - Use SFSafariViewController for external content

Example JS bridge exploit:
// If bridge exposes deleteAccount function:
<script>
window.webkit.messageHandlers.nativeBridge.postMessage({
    action: 'deleteAccount'
});
</script>
                        """
                    }
                }
            ]
        })

        # === PHASE 10: BACKUP ANALYSIS ===
        tasks['children'].append({
            'id': 'backup-analysis',
            'name': 'iTunes/Finder Backup Analysis',
            'type': 'parent',
            'children': [
                {
                    'id': 'create-backup',
                    'name': 'Create Device Backup',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Create encrypted/unencrypted backup for analysis',
                        'tags': ['OSCP:MEDIUM', 'MANUAL'],
                        'notes': """
Create backup via:

1. **macOS Catalina+** (Finder):
   - Connect device
   - Open Finder
   - Select device in sidebar
   - General tab → Back Up Now
   - Optional: Encrypt backup (more data included)

2. **macOS Mojave-** (iTunes):
   - Connect device
   - Open iTunes
   - Select device icon
   - Summary → Back Up Now

3. **idevicebackup2** (libimobiledevice):
   idevicebackup2 backup --full <backup_directory>

Backup locations:
- macOS: ~/Library/Application Support/MobileSync/Backup/
- Windows: %APPDATA%\\Apple Computer\\MobileSync\\Backup\\

Backup contains:
- App data (Documents, Library, tmp)
- Keychain items (if encrypted backup)
- Device settings
- Messages
- Photos
- Call history

Backup does NOT contain:
- Apple Pay info
- Touch ID/Face ID settings
- App bundles (only data)
- HealthKit data (unless encrypted)

Encrypted vs Unencrypted:
- Encrypted: Includes keychain, health data
- Unencrypted: Limited data access
- Password-protected backups more complete

For pentesting:
- Create UNENCRYPTED backup (easier analysis)
- Use after app has been used extensively
- Create multiple backups (before/after login)
                        """
                    }
                },
                {
                    'id': 'analyze-backup-contents',
                    'name': 'Analyze Backup for Sensitive Data',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract and analyze app data from backup',
                        'tags': ['OSCP:HIGH'],
                        'notes': """
Tools for backup analysis:

1. **iMazing** (GUI, $$):
   - https://imazing.com/
   - Easy browsing
   - File extraction
   - App data viewer

2. **iExplorer** (GUI, $):
   - https://macroplant.com/iexplorer
   - Browse backup
   - Extract files
   - View databases

3. **iOSbackup** (Python, free):
   pip install iOSbackup

   from iOSbackup import iOSbackup
   backup = iOSbackup("backup_path")
   backup.getAppDomains("<bundle_id>")
   backup.getFileDecryptedCopy("<file_path>")

4. **Manual extraction**:
   Backup files stored as:
   <2 char>/<40 char SHA1 hash>

   Find app files:
   sqlite3 Manifest.db "SELECT * FROM Files WHERE domain LIKE '%<bundle_id>%';"

Analysis procedure:

1. **Locate app data**:
   - Open Manifest.db
   - Search for bundle ID
   - List all app files

2. **Extract databases**:
   - Find .sqlite, .db files
   - Copy and open with SQLite browser
   - Search for sensitive data

3. **Extract plists**:
   - Find .plist files
   - Convert binary → XML (plutil)
   - Search for keys, tokens, passwords

4. **Extract other files**:
   - Images (check for screenshots)
   - Documents
   - Cache files
   - Logs

5. **Check encryption status**:
   Open Manifest.plist
   Look for IsEncrypted key

6. **Search for patterns**:
   strings Manifest.db | grep -i "password\\|token\\|secret\\|api"

7. **Compare backups**:
   - Before login
   - After login
   - After logout
   - What data persists?

Common findings:
- Credentials in NSUserDefaults plist
- Session tokens in SQLite
- Cached API responses
- User PII
- Chat history
- Photos/files

Security issues:
- Sensitive data not excluded from backup
- Data persists after logout
- Data not encrypted
- Easy extraction without device passcode
                        """
                    }
                },
                {
                    'id': 'test-backup-modification',
                    'name': 'Test Backup Modification Attack',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Modify backup data and restore to alter app behavior',
                        'tags': ['OSCP:MEDIUM'],
                        'notes': """
Backup modification attack:
1. Create backup
2. Modify app data in backup
3. Restore backup
4. Altered data loads in app

Example: Bither Bitcoin Wallet
- PIN stored in plist file (net.bither.plist)
- Key: pin_code
- Remove key from plist
- Restore backup
- PIN bypass!

Attack procedure:

1. **Create baseline backup**:
   idevicebackup2 backup <dir>

2. **Identify target file**:
   - NSUserDefaults: Library/Preferences/<bundle_id>.plist
   - SQLite: Library/Application Support/*.sqlite
   - Config: Documents/*.plist

3. **Extract file**:
   # Find file hash in Manifest.db
   sqlite3 Manifest.db "SELECT fileID, relativePath FROM Files WHERE relativePath LIKE '%<bundle_id>.plist';"

   # Copy file
   cp <hash_prefix>/<hash> modified_file.plist

4. **Modify file**:
   # Convert binary → XML
   plutil -convert xml1 modified_file.plist

   # Edit (remove PIN, change premium status, etc.)
   vim modified_file.plist

   # Convert back to binary
   plutil -convert binary1 modified_file.plist

5. **Replace in backup**:
   cp modified_file.plist <backup_dir>/<hash_prefix>/<hash>

6. **Update Manifest.db** (if needed):
   - Update file size
   - Update hash

7. **Restore backup**:
   idevicebackup2 restore <dir>

8. **Test modification**:
   - Launch app
   - Check if modification effective

Common targets:
- Authentication bypass (remove PIN)
- Premium features (set isPremium=true)
- In-app purchases (add credits)
- Configuration changes (enable debug mode)

Tools:
- iBackupBot (GUI, Windows/Mac)
- iPhone Backup Extractor
- Custom Python scripts

Detection:
- App should validate data integrity
- Use code signing for config files
- Detect backup restoration (check timestamps)
                        """
                    }
                }
            ]
        })

        return tasks


# Additional helper function for quick iOS testing trigger
def create_ios_manual_profile(app_name: str, bundle_id: str) -> Dict[str, Any]:
    """Helper to create iOS pentesting task tree without service detection

    Usage:
        from crack.track.services.ios_pentesting import create_ios_manual_profile
        tasks = create_ios_manual_profile("MyApp", "com.example.myapp")
    """
    plugin = iOSPentestingPlugin()
    service_info = {
        'app_name': app_name,
        'bundle_id': bundle_id
    }
    return plugin.get_task_tree(
        target='ios-device',
        port=0,
        service_info=service_info
    )
