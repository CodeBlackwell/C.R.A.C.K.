"""
Tests for Tier 5 Exploitation Plugin Finding-Based Activation

Validates that exploitation plugins activate correctly when specific
vulnerabilities or attack vectors are detected.

Coverage:
- binary_exploit.py
- injection_attacks.py
- deserialization_attacks.py
- ssrf_attacks.py
- ssti_attacks.py
- xss_attacks.py
"""

import pytest
from crack.track.services.binary_exploit import BinaryExploitPlugin
from crack.track.services.injection_attacks import InjectionAttacksPlugin
from crack.track.services.deserialization_attacks import DeserializationAttacksPlugin
from crack.track.services.ssrf_attacks import SSRFAttacksPlugin
from crack.track.services.ssti_attacks import SSTIAttacksPlugin
from crack.track.services.xss_attacks import XSSAttacksPlugin
from crack.track.core.constants import FindingTypes


# ===================================================================
# BINARY EXPLOIT PLUGIN TESTS
# ===================================================================

def test_binary_exploit_activates_on_vulnerable_binary():
    """Binary exploit activates on BINARY_VULNERABLE finding"""
    plugin = BinaryExploitPlugin()

    finding = {
        'type': FindingTypes.BINARY_VULNERABLE,
        'description': 'Vulnerable binary service detected',
        'source': 'nmap'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on BINARY_VULNERABLE"


def test_binary_exploit_activates_on_buffer_overflow():
    """Binary exploit activates on buffer overflow detection"""
    plugin = BinaryExploitPlugin()

    # Test via finding type
    finding = {
        'type': FindingTypes.BUFFER_OVERFLOW,
        'description': 'Buffer overflow detected in service',
        'source': 'manual_testing'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 90, "Should activate with 90% confidence on BUFFER_OVERFLOW"

    # Test via description keyword
    finding2 = {
        'type': 'vulnerability',
        'description': 'Service crashes with BOF in input handler',
        'source': 'fuzzing'
    }

    confidence2 = plugin.detect_from_finding(finding2)
    assert confidence2 == 90, "Should activate on 'bof' keyword in description"


def test_binary_exploit_activates_on_format_string():
    """Binary exploit activates on format string vulnerability"""
    plugin = BinaryExploitPlugin()

    finding = {
        'type': FindingTypes.FORMAT_STRING_VULN,
        'description': 'Format string vulnerability in printf call',
        'source': 'source_code_audit'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 90, "Should activate with 90% confidence on format string vuln"


def test_binary_exploit_activates_on_use_after_free():
    """Binary exploit activates on use-after-free detection"""
    plugin = BinaryExploitPlugin()

    finding = {
        'type': FindingTypes.USE_AFTER_FREE,
        'description': 'Use after free vulnerability in heap management',
        'source': 'valgrind'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 85, "Should activate with 85% confidence on use-after-free"


def test_binary_exploit_activates_on_memory_corruption_keywords():
    """Binary exploit activates on memory corruption indicators"""
    plugin = BinaryExploitPlugin()

    test_cases = [
        ('heap overflow in allocation', 70),
        ('stack overflow detected', 70),
        ('integer overflow in size calculation', 70),
        ('double free vulnerability', 70),
        ('null pointer dereference', 70)
    ]

    for description, expected_confidence in test_cases:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'fuzzing'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == expected_confidence, f"Should activate on '{description}'"


def test_binary_exploit_no_activation_on_irrelevant_finding():
    """Binary exploit does not activate on irrelevant findings"""
    plugin = BinaryExploitPlugin()

    finding = {
        'type': 'directory',
        'description': '/admin directory found',
        'source': 'gobuster'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 0, "Should not activate on directory finding"


# ===================================================================
# INJECTION ATTACKS PLUGIN TESTS
# ===================================================================

def test_injection_attacks_activates_on_sqli():
    """Injection plugin activates on SQL injection detection"""
    plugin = InjectionAttacksPlugin()

    finding = {
        'type': FindingTypes.SQL_INJECTION,
        'description': 'SQL injection in login form',
        'source': 'sqlmap'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on SQLi"


def test_injection_attacks_activates_on_command_injection():
    """Injection plugin activates on command injection"""
    plugin = InjectionAttacksPlugin()

    finding = {
        'type': FindingTypes.COMMAND_INJECTION,
        'description': 'OS command injection in file parameter',
        'source': 'manual_testing'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on command injection"


def test_injection_attacks_activates_on_xss_ssrf_ssti():
    """Injection plugin activates on other injection types"""
    plugin = InjectionAttacksPlugin()

    test_cases = [
        (FindingTypes.XSS_FOUND, 'XSS in search parameter', 95),
        (FindingTypes.SSRF_FOUND, 'SSRF via URL parameter', 95),
        (FindingTypes.SSTI_FOUND, 'SSTI in template engine', 95),
        (FindingTypes.XXE_FOUND, 'XXE in XML parser', 95)
    ]

    for finding_type, description, expected_confidence in test_cases:
        finding = {
            'type': finding_type,
            'description': description,
            'source': 'scanner'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == expected_confidence, f"Should activate on {finding_type}"


def test_injection_attacks_activates_on_injection_keywords():
    """Injection plugin activates on generic injection keywords"""
    plugin = InjectionAttacksPlugin()

    keywords = ['injection', 'sqli', 'xss', 'ssrf', 'ssti', 'command injection', 'xxe']

    for keyword in keywords:
        finding = {
            'type': 'vulnerability',
            'description': f'Potential {keyword} vulnerability detected',
            'source': 'scanner'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 85, f"Should activate on '{keyword}' keyword"


# ===================================================================
# DESERIALIZATION ATTACKS PLUGIN TESTS
# ===================================================================

def test_deserialization_activates_on_deserialization_vuln():
    """Deserialization plugin activates on deserialization vulnerability"""
    plugin = DeserializationAttacksPlugin()

    finding = {
        'type': FindingTypes.DESERIALIZATION_VULN,
        'description': 'Unsafe deserialization in Java application',
        'source': 'code_review'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on deserialization vuln"


def test_deserialization_activates_on_pickle():
    """Deserialization plugin activates on pickle detection"""
    plugin = DeserializationAttacksPlugin()

    test_cases = [
        'Python pickle deserialization detected',
        'PHP unserialize() call found',
        'Java serialization vulnerability',
        'ysoserial payload effective',
        'Unsafe marshalling in .NET',
        'Object unmarshalling without validation'
    ]

    for description in test_cases:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'analysis'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 90, f"Should activate on description: '{description}'"


def test_deserialization_activates_on_serialization_frameworks():
    """Deserialization plugin activates on serialization framework detection"""
    plugin = DeserializationAttacksPlugin()

    frameworks = ['jackson', 'gson', 'fastjson', 'xstream', 'yaml', 'pyyaml']

    for framework in frameworks:
        finding = {
            'type': 'tech_detected',
            'description': f'Application uses {framework} library',
            'source': 'dependency_check'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 75, f"Should activate on framework: {framework}"


# ===================================================================
# SSRF ATTACKS PLUGIN TESTS
# ===================================================================

def test_ssrf_attacks_activates_on_ssrf_found():
    """SSRF plugin activates on SSRF detection"""
    plugin = SSRFAttacksPlugin()

    finding = {
        'type': FindingTypes.SSRF_FOUND,
        'description': 'SSRF vulnerability in webhook parameter',
        'source': 'burp_scanner'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on SSRF_FOUND"


def test_ssrf_attacks_activates_on_ssrf_keyword():
    """SSRF plugin activates on SSRF keywords"""
    plugin = SSRFAttacksPlugin()

    test_cases = [
        'SSRF detected in URL fetcher',
        'Server-side request forgery vulnerability',
        'ssrf via file upload'
    ]

    for description in test_cases:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'manual'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 90, f"Should activate on description: '{description}'"


def test_ssrf_attacks_activates_on_prone_patterns():
    """SSRF plugin activates on SSRF-prone URL parameters"""
    plugin = SSRFAttacksPlugin()

    patterns = [
        'URL parameter accepts external URLs',
        'Webhook endpoint without validation',
        'Callback URL parameter discovered',
        'Proxy parameter found',
        'Redirect URL not validated'
    ]

    for description in patterns:
        finding = {
            'type': 'misconfiguration',
            'description': description,
            'source': 'parameter_discovery'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 70, f"Should activate on pattern: '{description}'"


# ===================================================================
# SSTI ATTACKS PLUGIN TESTS
# ===================================================================

def test_ssti_attacks_activates_on_ssti_found():
    """SSTI plugin activates on SSTI detection"""
    plugin = SSTIAttacksPlugin()

    finding = {
        'type': FindingTypes.SSTI_FOUND,
        'description': 'Server-side template injection in Jinja2',
        'source': 'tplmap'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on SSTI_FOUND"


def test_ssti_attacks_activates_on_template_engines():
    """SSTI plugin activates on template engine detection"""
    plugin = SSTIAttacksPlugin()

    engines = ['ssti', 'template injection', 'jinja', 'jinja2', 'twig',
              'freemarker', 'velocity', 'thymeleaf', 'mustache', 'handlebars']

    for engine in engines:
        finding = {
            'type': 'tech_detected',
            'description': f'Application uses {engine}',
            'source': 'whatweb'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 90, f"Should activate on engine: {engine}"


def test_ssti_attacks_activates_on_template_processing():
    """SSTI plugin activates on template processing indicators"""
    plugin = SSTIAttacksPlugin()

    test_cases = [
        'Template render function identified',
        'Template evaluate without sanitization',
        'Template compile vulnerability'
    ]

    for description in test_cases:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'code_review'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == 75, f"Should activate on: '{description}'"


# ===================================================================
# XSS ATTACKS PLUGIN TESTS
# ===================================================================

def test_xss_attacks_activates_on_xss_found():
    """XSS plugin activates on XSS detection"""
    plugin = XSSAttacksPlugin()

    finding = {
        'type': FindingTypes.XSS_FOUND,
        'description': 'XSS in search parameter',
        'source': 'xsstrike'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 100, "Should activate with perfect confidence on XSS_FOUND"


def test_xss_attacks_activates_on_xss_keywords():
    """XSS plugin activates on XSS keywords"""
    plugin = XSSAttacksPlugin()

    test_cases = [
        ('XSS vulnerability in comment field', 90),
        ('Cross-site scripting detected', 90)
    ]

    for description, expected_confidence in test_cases:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'burp'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == expected_confidence, f"Should activate on: '{description}'"


def test_xss_attacks_activates_on_xss_contexts():
    """XSS plugin activates on XSS context indicators"""
    plugin = XSSAttacksPlugin()

    # Note: Descriptions with "xss" keyword get 90% (higher priority than contexts)
    # Contexts without "xss" keyword get 85%
    contexts_with_xss = [
        ('Reflected XSS in URL parameter', 90),  # Contains "xss" keyword
        ('Stored XSS in profile field', 90),  # Contains "xss" keyword
        ('DOM-based XSS vulnerability', 90),  # Contains "xss" keyword
        ('DOM XSS via innerHTML', 90),  # Contains "xss" keyword
        ('XSS in JavaScript context', 90),  # Contains "xss" keyword
    ]

    contexts_without_xss = [
        ('HTML injection without filtering', 85),  # Context match only
        ('DOM-based vulnerability via innerHTML', 85),  # Context match only
    ]

    for description, expected_confidence in contexts_with_xss + contexts_without_xss:
        finding = {
            'type': 'vulnerability',
            'description': description,
            'source': 'manual'
        }

        confidence = plugin.detect_from_finding(finding)
        assert confidence == expected_confidence, f"Should activate with {expected_confidence}% on: '{description}'"


def test_xss_attacks_activates_on_reflected_parameter():
    """XSS plugin activates on reflected parameters"""
    plugin = XSSAttacksPlugin()

    # "reflected" is in the contexts list, so it matches at 85% before the specific reflected+parameter check at 70%
    finding = {
        'type': 'misconfiguration',
        'description': 'Reflected parameter without sanitization',
        'source': 'burp_reflection_check'
    }

    confidence = plugin.detect_from_finding(finding)
    assert confidence == 85, "Should activate on reflected context (contained in contexts list)"


# ===================================================================
# CROSS-PLUGIN VALIDATION TESTS
# ===================================================================

def test_all_plugins_ignore_irrelevant_findings():
    """All exploitation plugins ignore irrelevant findings"""
    plugins = [
        BinaryExploitPlugin(),
        InjectionAttacksPlugin(),
        DeserializationAttacksPlugin(),
        SSRFAttacksPlugin(),
        SSTIAttacksPlugin(),
        XSSAttacksPlugin()
    ]

    irrelevant_finding = {
        'type': 'directory',
        'description': '/backup directory found',
        'source': 'gobuster'
    }

    for plugin in plugins:
        confidence = plugin.detect_from_finding(irrelevant_finding)
        assert confidence == 0, f"{plugin.name} should not activate on directory finding"


def test_all_plugins_return_numeric_confidence():
    """All plugins return numeric confidence scores"""
    plugins = [
        BinaryExploitPlugin(),
        InjectionAttacksPlugin(),
        DeserializationAttacksPlugin(),
        SSRFAttacksPlugin(),
        SSTIAttacksPlugin(),
        XSSAttacksPlugin()
    ]

    test_finding = {
        'type': 'vulnerability',
        'description': 'Test vulnerability',
        'source': 'test'
    }

    for plugin in plugins:
        confidence = plugin.detect_from_finding(test_finding)
        assert isinstance(confidence, (int, float)), f"{plugin.name} should return numeric confidence"
        assert 0 <= confidence <= 100, f"{plugin.name} confidence should be 0-100"


def test_plugins_handle_missing_finding_fields():
    """Plugins handle findings with missing fields gracefully"""
    plugins = [
        BinaryExploitPlugin(),
        InjectionAttacksPlugin(),
        DeserializationAttacksPlugin(),
        SSRFAttacksPlugin(),
        SSTIAttacksPlugin(),
        XSSAttacksPlugin()
    ]

    # Finding with missing fields
    incomplete_finding = {
        'type': 'vulnerability'
        # Missing description
    }

    for plugin in plugins:
        try:
            confidence = plugin.detect_from_finding(incomplete_finding)
            assert isinstance(confidence, (int, float)), f"{plugin.name} should handle missing fields"
        except Exception as e:
            pytest.fail(f"{plugin.name} raised exception on incomplete finding: {e}")


# ===================================================================
# INTEGRATION TEST
# ===================================================================

def test_tier5_plugins_integration_scenario():
    """Integration test: Multiple exploitation plugins activate on relevant findings"""

    # Simulate a pentest discovering multiple vulnerabilities
    findings = [
        {
            'type': FindingTypes.SQL_INJECTION,
            'description': 'SQL injection in login form',
            'source': 'sqlmap'
        },
        {
            'type': FindingTypes.XSS_FOUND,
            'description': 'Reflected XSS in search',
            'source': 'xsstrike'
        },
        {
            'type': FindingTypes.BUFFER_OVERFLOW,
            'description': 'Buffer overflow in custom service',
            'source': 'fuzzing'
        }
    ]

    injection_plugin = InjectionAttacksPlugin()
    xss_plugin = XSSAttacksPlugin()
    binary_plugin = BinaryExploitPlugin()

    # First finding should activate injection plugin strongly
    assert injection_plugin.detect_from_finding(findings[0]) == 100
    # XSS plugin doesn't activate on pure SQLi (no XSS-specific keywords)
    assert xss_plugin.detect_from_finding(findings[0]) == 0
    assert binary_plugin.detect_from_finding(findings[0]) == 0  # Binary doesn't care

    # Second finding should activate both XSS and injection plugins
    assert xss_plugin.detect_from_finding(findings[1]) == 100  # Perfect match: type=xss_found
    assert injection_plugin.detect_from_finding(findings[1]) == 95  # Injection also handles XSS
    assert binary_plugin.detect_from_finding(findings[1]) == 0  # Binary doesn't care

    # Third finding should activate binary plugin
    assert binary_plugin.detect_from_finding(findings[2]) == 90
    assert injection_plugin.detect_from_finding(findings[2]) == 0  # Injection doesn't care
    assert xss_plugin.detect_from_finding(findings[2]) == 0  # XSS doesn't care


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
