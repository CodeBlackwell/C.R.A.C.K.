"""
Tests for iOS Binary Exploitation Plugin

Validates iOS kernel exploitation research task generation including:
- iOS security mitigations (PAC, PPL, SPTM, KTRR)
- Old vs modern kernel heap analysis
- Physical UAF via IOSurface
- CVE-2021-30807 (IOMobileFrameBuffer)
- CVE-2020-27950 (Mach message trailer leak)
"""

import pytest
from crack.track.services.ios_binary_exploit import iOSBinaryExploitPlugin


class TestiOSBinaryExploitPlugin:
    """Test suite for iOS binary exploitation plugin"""

    @pytest.fixture
    def plugin(self):
        """Create plugin instance"""
        return iOSBinaryExploitPlugin()

    def test_name(self, plugin):
        """PROVES: Plugin has correct name"""
        assert plugin.name == "ios-binary-exploit"

    def test_detect_returns_false(self, plugin):
        """PROVES: Plugin is manual-only, does not auto-detect"""
        # iOS research plugin should never auto-detect from network scans
        port_info = {
            'port': 22,
            'service': 'ssh',
            'product': 'OpenSSH'
        }
        assert plugin.detect(port_info) is False

        # Even with iOS-like service names
        ios_port_info = {
            'port': 62078,
            'service': 'ios-lockdown',
            'product': 'Apple iOS'
        }
        assert plugin.detect(ios_port_info) is False

    def test_task_tree_structure(self, plugin):
        """PROVES: Task tree has valid hierarchical structure"""
        service_info = {
            'service': 'ios-kernel',
            'version': 'iOS 14.7',
            'product': 'iPhone 12'
        }

        tree = plugin.get_task_tree('192.168.1.100', 0, service_info)

        # Root structure
        assert tree['id'] == 'ios-kernel-exploit'
        assert tree['type'] == 'parent'
        assert 'children' in tree
        assert len(tree['children']) > 0

        # Verify major sections exist
        section_ids = [child['id'] for child in tree['children']]
        assert 'ios-mitigations-analysis' in section_ids
        assert 'old-heap-analysis' in section_ids
        assert 'modern-heap-analysis' in section_ids
        assert 'physical-uaf-iosurface' in section_ids
        assert 'cve-2021-30807' in section_ids
        assert 'cve-2020-27950' in section_ids
        assert 'ios-research-tools' in section_ids
        assert 'ios-exploit-education' in section_ids

    def test_ios_mitigations_section(self, plugin):
        """PROVES: iOS security mitigations section is comprehensive"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        mitigations_section = next(
            child for child in tree['children']
            if child['id'] == 'ios-mitigations-analysis'
        )

        assert mitigations_section['type'] == 'parent'
        assert len(mitigations_section['children']) >= 4

        # Check key mitigation tasks
        task_ids = [task['id'] for task in mitigations_section['children']]
        assert 'code-signing-check' in task_ids
        assert 'dep-aslr-check' in task_ids
        assert 'pac-ktrr-check' in task_ids
        assert 'ppl-sptm-check' in task_ids

    def test_old_heap_analysis_section(self, plugin):
        """PROVES: Old kernel heap analysis covers kalloc zones and freelist"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        old_heap = next(
            child for child in tree['children']
            if child['id'] == 'old-heap-analysis'
        )

        assert old_heap['type'] == 'parent'
        task_ids = [task['id'] for task in old_heap['children']]

        # Core old heap concepts
        assert 'kalloc-zones-enum' in task_ids
        assert 'freelist-analysis' in task_ids
        assert 'heap-feng-shui' in task_ids

        # Verify heap feng shui task has detailed notes
        feng_shui = next(
            task for task in old_heap['children']
            if task['id'] == 'heap-feng-shui'
        )
        assert 'metadata' in feng_shui
        assert 'notes' in feng_shui['metadata']
        assert 'spray allocations' in feng_shui['metadata']['notes'].lower()

    def test_modern_heap_analysis_section(self, plugin):
        """PROVES: Modern heap analysis covers kalloc_type and safe-linking"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        modern_heap = next(
            child for child in tree['children']
            if child['id'] == 'modern-heap-analysis'
        )

        assert modern_heap['type'] == 'parent'
        task_ids = [task['id'] for task in modern_heap['children']]

        # Modern heap hardening
        assert 'kalloc-type-system' in task_ids
        assert 'safe-linking-analysis' in task_ids
        assert 'guarded-zones-analysis' in task_ids

    def test_physical_uaf_section(self, plugin):
        """PROVES: Physical UAF section covers IOSurface exploitation"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        puaf = next(
            child for child in tree['children']
            if child['id'] == 'physical-uaf-iosurface'
        )

        assert puaf['type'] == 'parent'
        task_ids = [task['id'] for task in puaf['children']]

        # PUAF exploitation steps
        assert 'puaf-concept' in task_ids
        assert 'iosurface-spray' in task_ids
        assert 'iosurface-krw' in task_ids
        assert 'puaf-limitations' in task_ids

        # Verify IOSurface spray has command
        spray_task = next(
            task for task in puaf['children']
            if task['id'] == 'iosurface-spray'
        )
        assert spray_task['type'] == 'command'
        assert 'metadata' in spray_task
        assert 'command' in spray_task['metadata']

    def test_cve_2021_30807_section(self, plugin):
        """PROVES: CVE-2021-30807 section covers IOMobileFrameBuffer OOB"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        cve = next(
            child for child in tree['children']
            if child['id'] == 'cve-2021-30807'
        )

        assert cve['type'] == 'parent'
        task_ids = [task['id'] for task in cve['children']]

        # CVE exploitation flow
        assert 'iomfb-bug-analysis' in task_ids
        assert 'iomfb-dos-poc' in task_ids
        assert 'iomfb-arb-read' in task_ids

        # Verify DoS PoC has flag explanations
        dos_poc = next(
            task for task in cve['children']
            if task['id'] == 'iomfb-dos-poc'
        )
        assert 'metadata' in dos_poc
        assert 'flag_explanations' in dos_poc['metadata']
        assert 'selector 83' in dos_poc['metadata']['flag_explanations']

    def test_cve_2020_27950_section(self, plugin):
        """PROVES: CVE-2020-27950 section covers Mach message trailer leak"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        cve = next(
            child for child in tree['children']
            if child['id'] == 'cve-2020-27950'
        )

        assert cve['type'] == 'parent'
        task_ids = [task['id'] for task in cve['children']]

        # Mach message exploitation
        assert 'mach-trailer-bug' in task_ids
        assert 'mach-trailer-basic-leak' in task_ids
        assert 'mach-trailer-kaddr-leak' in task_ids

    def test_research_tools_section(self, plugin):
        """PROVES: Research tools section covers Ghidra, BinDiff, Corellium"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        tools = next(
            child for child in tree['children']
            if child['id'] == 'ios-research-tools'
        )

        assert tools['type'] == 'parent'
        task_ids = [task['id'] for task in tools['children']]

        # Essential research tools
        assert 'ghidra-bindiff-setup' in task_ids
        assert 'xnu-version-mapping' in task_ids
        assert 'corellium-setup' in task_ids

    def test_education_section(self, plugin):
        """PROVES: Education section provides learning path and OSCP context"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        education = next(
            child for child in tree['children']
            if child['id'] == 'ios-exploit-education'
        )

        assert education['type'] == 'parent'
        task_ids = [task['id'] for task in education['children']]

        # Educational resources
        assert 'recommended-reading' in task_ids
        assert 'oscp-relevance' in task_ids

        # Verify OSCP relevance disclaimer exists
        oscp_task = next(
            task for task in education['children']
            if task['id'] == 'oscp-relevance'
        )
        assert 'metadata' in oscp_task
        assert 'notes' in oscp_task['metadata']
        assert 'NOT on OSCP exam' in oscp_task['metadata']['notes']

    def test_metadata_completeness(self, plugin):
        """PROVES: Tasks include comprehensive OSCP-style metadata"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        # Flatten all tasks
        def collect_tasks(node):
            tasks = []
            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    tasks.append(child)
                    tasks.extend(collect_tasks(child))
            return tasks

        all_tasks = collect_tasks(tree)
        command_tasks = [t for t in all_tasks if t.get('type') in ['command', 'manual']]

        assert len(command_tasks) > 0, "Should have command/manual tasks"

        # Check metadata fields on sample tasks
        for task in command_tasks[:5]:  # Check first 5
            metadata = task.get('metadata', {})

            # Core fields
            assert 'description' in metadata, f"Task {task['id']} missing description"
            assert 'tags' in metadata, f"Task {task['id']} missing tags"

            # Educational fields
            if 'notes' in metadata:
                assert len(metadata['notes']) > 50, "Notes should be detailed"

            # At least one educational field present
            educational_fields = [
                'alternatives',
                'success_indicators',
                'failure_indicators',
                'next_steps'
            ]
            has_education = any(field in metadata for field in educational_fields)
            assert has_education, f"Task {task['id']} lacks educational metadata"

    def test_tag_consistency(self, plugin):
        """PROVES: Tasks use consistent tag standards"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        def collect_all_tags(node):
            tags = []
            if 'metadata' in node and 'tags' in node['metadata']:
                tags.extend(node['metadata']['tags'])
            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    tags.extend(collect_all_tags(child))
            return tags

        all_tags = collect_all_tags(tree)
        unique_tags = set(all_tags)

        # Expected tag categories
        expected_tags = {
            'OSCP:LOW', 'OSCP:MEDIUM', 'OSCP:HIGH',
            'MANUAL', 'RESEARCH', 'IOS', 'CVE',
            'EDUCATION', 'TOOLS', 'DOS'
        }

        # All used tags should be from expected set
        for tag in unique_tags:
            # Allow OSCP:*, but check others
            if not tag.startswith('OSCP:'):
                assert tag in expected_tags, f"Unexpected tag: {tag}"

    def test_ios_version_context(self, plugin):
        """PROVES: Plugin adapts to iOS version in service_info"""
        service_info_14 = {
            'service': 'ios-kernel',
            'version': 'iOS 14.7',
            'product': 'iPhone 11'
        }

        service_info_16 = {
            'service': 'ios-kernel',
            'version': 'iOS 16.0',
            'product': 'iPhone 14 Pro'
        }

        tree_14 = plugin.get_task_tree('test', 0, service_info_14)
        tree_16 = plugin.get_task_tree('test', 0, service_info_16)

        # Both should generate tasks
        assert len(tree_14['children']) > 0
        assert len(tree_16['children']) > 0

        # Structure should be identical (version doesn't change tasks)
        assert tree_14['id'] == tree_16['id']
        assert len(tree_14['children']) == len(tree_16['children'])

    def test_no_empty_notes(self, plugin):
        """PROVES: All manual tasks have substantial documentation"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        def check_manual_tasks(node):
            if node.get('type') == 'manual':
                metadata = node.get('metadata', {})
                notes = metadata.get('notes', '')
                assert len(notes) > 100, f"Task {node['id']} has insufficient notes"

            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    check_manual_tasks(child)

        check_manual_tasks(tree)

    def test_cve_tasks_have_references(self, plugin):
        """PROVES: CVE-related tasks include research references"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        # Find CVE sections
        cve_2021 = next(
            child for child in tree['children']
            if child['id'] == 'cve-2021-30807'
        )
        cve_2020 = next(
            child for child in tree['children']
            if child['id'] == 'cve-2020-27950'
        )

        # Check for references in notes/alternatives
        def has_references(section):
            for task in section['children']:
                metadata = task.get('metadata', {})
                content = str(metadata.get('notes', '')) + str(metadata.get('alternatives', []))
                if 'http' in content.lower() or 'cve-' in content.lower():
                    return True
            return False

        assert has_references(cve_2021), "CVE-2021-30807 should have references"
        assert has_references(cve_2020), "CVE-2020-27950 should have references"

    def test_heap_spray_task_has_code_examples(self, plugin):
        """PROVES: Heap spray tasks include code snippets for learning"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        puaf = next(
            child for child in tree['children']
            if child['id'] == 'physical-uaf-iosurface'
        )

        spray_task = next(
            task for task in puaf['children']
            if task['id'] == 'iosurface-spray'
        )

        notes = spray_task['metadata']['notes']

        # Should contain code-like content
        assert 'IOSurface' in notes
        assert 'spray' in notes.lower()
        assert '```' in notes or 'spray_iosurface' in notes  # Code blocks or function names

    def test_plugin_registration(self, plugin):
        """PROVES: Plugin is properly decorated for auto-registration"""
        # Check plugin class has registry decorator applied
        from crack.track.services.registry import ServiceRegistry

        # Plugin should be in registered plugins
        registered_names = [p.name for p in ServiceRegistry.get_all_plugins()]
        assert 'ios-binary-exploit' in registered_names

    def test_task_tree_unique_ids(self, plugin):
        """PROVES: All task IDs are unique within tree"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        def collect_ids(node):
            ids = [node['id']]
            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    ids.extend(collect_ids(child))
            return ids

        all_ids = collect_ids(tree)
        unique_ids = set(all_ids)

        assert len(all_ids) == len(unique_ids), "Duplicate task IDs found"

    def test_alternatives_provide_manual_methods(self, plugin):
        """PROVES: Alternatives field provides manual exploitation methods"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        def check_alternatives(node):
            if 'metadata' in node and 'alternatives' in node['metadata']:
                alts = node['metadata']['alternatives']
                assert isinstance(alts, list), "Alternatives should be list"
                assert len(alts) > 0, f"Task {node['id']} has empty alternatives"

            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    check_alternatives(child)

        check_alternatives(tree)

    def test_success_failure_indicators_present(self, plugin):
        """PROVES: Manual tasks include success/failure indicators"""
        tree = plugin.get_task_tree('test', 0, {'service': 'ios-kernel'})

        manual_tasks = []

        def collect_manual(node):
            if node.get('type') == 'manual':
                manual_tasks.append(node)
            if node.get('type') == 'parent' and 'children' in node:
                for child in node['children']:
                    collect_manual(child)

        collect_manual(tree)

        # Check sample of manual tasks
        for task in manual_tasks[:5]:
            metadata = task.get('metadata', {})
            # At least one indicator type should be present
            has_indicators = (
                'success_indicators' in metadata or
                'failure_indicators' in metadata
            )
            assert has_indicators, f"Task {task['id']} missing indicators"
