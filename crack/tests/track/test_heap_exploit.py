"""
Heap Exploitation Plugin Tests

PROVES: HeapExploitPlugin provides comprehensive heap analysis guidance
"""

import pytest
from crack.track.services.heap_exploit import HeapExploitPlugin
from crack.track.services.registry import ServiceRegistry


class TestHeapExploitPlugin:
    """Test suite for Heap Exploitation Plugin"""

    @pytest.fixture
    def plugin(self):
        """Create plugin instance"""
        return HeapExploitPlugin()

    def test_plugin_name(self, plugin):
        """PROVES: Plugin has correct name"""
        assert plugin.name == "heap-exploit"

    def test_plugin_not_auto_detected(self, plugin):
        """PROVES: Plugin is NOT auto-detected (manual activation only)"""
        # Heap exploitation is not port-based, must be manually triggered
        port_info = {'port': 1337, 'service': 'custom', 'state': 'open'}
        assert plugin.detect(port_info) == False

        # Even with heap-related service names
        port_info = {'port': 0, 'service': 'heap-analysis', 'state': 'open'}
        assert plugin.detect(port_info) == False

    def test_default_ports_empty(self, plugin):
        """PROVES: Plugin has no default ports (not port-based)"""
        assert isinstance(plugin.default_ports, list)
        assert len(plugin.default_ports) == 0

    def test_service_names_present(self, plugin):
        """PROVES: Plugin has service names for identification"""
        assert isinstance(plugin.service_names, list)
        assert len(plugin.service_names) > 0
        assert 'heap-analysis' in plugin.service_names
        assert 'binary-exploitation' in plugin.service_names

    def test_task_tree_structure(self, plugin):
        """PROVES: Plugin generates valid task tree structure"""
        service_info = {
            'binary_path': '/path/to/binary',
            'libc_version': '2.31',
            'arch': 'x86_64'
        }

        tree = plugin.get_task_tree(
            target='/path/to/binary',
            port=0,
            service_info=service_info
        )

        # Validate root structure
        assert isinstance(tree, dict)
        assert 'id' in tree
        assert tree['id'] == 'heap-exploit-root'
        assert 'name' in tree
        assert 'Heap Exploitation Analysis' in tree['name']
        assert tree['type'] == 'parent'
        assert 'children' in tree

        # Should have multiple phase children
        children = tree['children']
        assert len(children) >= 5, "Should have at least 5 phases"

    def test_phase_1_initial_analysis(self, plugin):
        """PROVES: Phase 1 includes initial analysis tasks"""
        service_info = {
            'binary_path': '/bin/vulnerable',
            'arch': 'x86_64'
        }

        tree = plugin.get_task_tree('target', 0, service_info)
        phase1 = tree['children'][0]

        assert 'initial-analysis' in phase1['id']
        assert 'Phase 1' in phase1['name']
        assert phase1['type'] == 'parent'

        # Check for critical tasks
        task_ids = [task['id'] for task in phase1['children']]
        assert 'checksec' in task_ids
        assert 'identify-libc' in task_ids
        assert 'heap-functions-check' in task_ids

    def test_phase_2_heap_inspection(self, plugin):
        """PROVES: Phase 2 includes heap inspection tasks"""
        tree = plugin.get_task_tree('target', 0, {'binary_path': 'test'})
        phase2 = tree['children'][1]

        assert 'heap-inspection' in phase2['id']
        assert 'Phase 2' in phase2['name']

        # Check for GDB/pwndbg commands
        task_ids = [task['id'] for task in phase2['children']]
        assert 'gdb-heap-basics' in task_ids
        assert 'pwndbg-heap-analysis' in task_ids
        assert 'heap-chunk-structure' in task_ids
        assert 'bins-explained' in task_ids

    def test_phase_3_vulnerability_identification(self, plugin):
        """PROVES: Phase 3 includes vulnerability identification"""
        tree = plugin.get_task_tree('target', 0, {'binary_path': 'test'})
        phase3 = tree['children'][2]

        assert 'vuln-identification' in phase3['id']
        assert 'Phase 3' in phase3['name']

        # Check for vulnerability types
        task_ids = [task['id'] for task in phase3['children']]
        assert 'uaf-check' in task_ids  # Use-After-Free
        assert 'double-free-check' in task_ids
        assert 'heap-overflow-check' in task_ids
        assert 'off-by-one-check' in task_ids

    def test_phase_4_exploitation_techniques(self, plugin):
        """PROVES: Phase 4 includes exploitation techniques"""
        tree = plugin.get_task_tree('target', 0, {'binary_path': 'test'})
        phase4 = tree['children'][3]

        assert 'exploitation-techniques' in phase4['id']
        assert 'Phase 4' in phase4['name']

        # Find all technique IDs recursively
        def get_all_ids(node):
            ids = [node['id']]
            for child in node.get('children', []):
                ids.extend(get_all_ids(child))
            return ids

        all_ids = get_all_ids(phase4)

        # Check for key exploitation techniques
        assert any('tcache' in id for id in all_ids), "Should include tcache poisoning"
        assert any('fastbin' in id for id in all_ids), "Should include fastbin attack"
        assert any('house' in id for id in all_ids), "Should include House of techniques"
        assert any('ret2libc' in id for id in all_ids), "Should include ret2libc"

    def test_phase_5_debugging_tools(self, plugin):
        """PROVES: Phase 5 includes debugging and analysis tools"""
        tree = plugin.get_task_tree('target', 0, {'binary_path': 'test'})
        phase5 = tree['children'][4]

        assert 'debugging-tools' in phase5['id']
        assert 'Phase 5' in phase5['name']

        task_ids = [task['id'] for task in phase5['children']]
        assert 'pwntools-template' in task_ids
        assert 'heap-feng-shui' in task_ids
        assert 'libc-database' in task_ids
        assert 'one-gadget' in task_ids


class TestHeapExploitMetadata:
    """Test OSCP-required metadata in tasks"""

    @pytest.fixture
    def plugin(self):
        return HeapExploitPlugin()

    def test_checksec_task_metadata(self, plugin):
        """PROVES: checksec task has complete OSCP metadata"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})
        phase1 = tree['children'][0]

        # Find checksec task
        checksec_task = None
        for task in phase1['children']:
            if task['id'] == 'checksec':
                checksec_task = task
                break

        assert checksec_task is not None
        metadata = checksec_task['metadata']

        # Required fields
        assert 'command' in metadata
        assert 'checksec' in metadata['command']
        assert 'description' in metadata
        assert 'flag_explanations' in metadata
        assert 'tags' in metadata
        assert 'success_indicators' in metadata
        assert 'failure_indicators' in metadata
        assert 'next_steps' in metadata
        assert 'alternatives' in metadata

        # Flag explanations should be detailed
        flags = metadata['flag_explanations']
        assert '--file' in flags
        assert 'RELRO' in flags
        assert 'PIE' in flags
        assert 'NX' in flags

        # Should have OSCP tag
        tags = metadata['tags']
        assert any('OSCP' in tag for tag in tags)

    def test_manual_tasks_have_notes(self, plugin):
        """PROVES: Manual tasks include detailed notes"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        # Collect all manual tasks
        def get_manual_tasks(node):
            tasks = []
            if node.get('type') == 'manual':
                tasks.append(node)
            for child in node.get('children', []):
                tasks.extend(get_manual_tasks(child))
            return tasks

        manual_tasks = get_manual_tasks(tree)
        assert len(manual_tasks) > 0, "Should have manual tasks"

        # Check each manual task has notes
        for task in manual_tasks:
            metadata = task.get('metadata', {})
            assert 'notes' in metadata, f"Task {task['id']} missing notes"
            notes = metadata['notes']
            assert isinstance(notes, list)
            assert len(notes) > 0, f"Task {task['id']} has empty notes"

    def test_command_tasks_have_alternatives(self, plugin):
        """PROVES: Command tasks include manual alternatives"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        # Collect all command tasks
        def get_command_tasks(node):
            tasks = []
            if node.get('type') == 'command':
                tasks.append(node)
            for child in node.get('children', []):
                tasks.extend(get_command_tasks(child))
            return tasks

        command_tasks = get_command_tasks(tree)
        assert len(command_tasks) > 0, "Should have command tasks"

        # Check command tasks have alternatives
        for task in command_tasks:
            metadata = task.get('metadata', {})
            assert 'alternatives' in metadata, f"Task {task['id']} missing alternatives"
            alts = metadata['alternatives']
            assert isinstance(alts, list)
            assert len(alts) > 0, f"Task {task['id']} has no alternatives"


class TestHeapExploitTechniques:
    """Test specific exploitation technique coverage"""

    @pytest.fixture
    def plugin(self):
        return HeapExploitPlugin()

    def test_tcache_poisoning_details(self, plugin):
        """PROVES: Tcache poisoning technique has detailed guidance"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test', 'libc_version': '2.31'})

        # Find tcache poisoning task
        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        tcache_task = find_task_by_id(tree, 'tcache-poisoning')
        assert tcache_task is not None, "Tcache poisoning task should exist"

        metadata = tcache_task['metadata']
        assert 'description' in metadata
        assert 'tcache' in metadata['description'].lower()
        assert 'notes' in metadata

        # Check for comprehensive notes
        notes = metadata['notes']
        notes_text = '\n'.join(notes)
        assert 'Requirements' in notes_text
        assert 'Attack Steps' in notes_text or 'Steps' in notes_text
        assert 'target address' in notes_text.lower()

    def test_fastbin_attack_details(self, plugin):
        """PROVES: Fastbin attack technique has detailed guidance"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        fastbin_task = find_task_by_id(tree, 'fastbin-attack')
        assert fastbin_task is not None, "Fastbin attack task should exist"

        metadata = fastbin_task['metadata']
        notes = metadata['notes']
        notes_text = '\n'.join(notes)

        # Should explain tcache bypass
        assert 'tcache' in notes_text.lower()
        assert 'fill' in notes_text.lower() or 'full' in notes_text.lower()

    def test_uaf_vulnerability_guide(self, plugin):
        """PROVES: Use-After-Free vulnerability guide is comprehensive"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        uaf_task = find_task_by_id(tree, 'uaf-check')
        assert uaf_task is not None

        metadata = uaf_task['metadata']
        notes = metadata['notes']
        notes_text = '\n'.join(notes)

        # Should explain vulnerability pattern
        assert 'free' in notes_text.lower()
        assert 'why dangerous' in notes_text.lower()
        assert 'detection' in notes_text.lower()
        assert 'exploitation' in notes_text.lower()

    def test_libc_version_awareness(self, plugin):
        """PROVES: Plugin adapts to libc version"""
        # With known libc version
        tree_with_version = plugin.get_task_tree(
            'test', 0,
            {'binary_path': 'test', 'libc_version': '2.31'}
        )

        # Find phase 4 (exploitation)
        phase4 = tree_with_version['children'][3]

        # Should have libc version note
        first_child = phase4['children'][0]
        assert 'libc-version-note' in first_child['id']
        assert '2.31' in first_child['name']


class TestHeapExploitIntegration:
    """Test plugin integration with CRACK Track"""

    def test_plugin_registered(self):
        """PROVES: Plugin is registered in ServiceRegistry"""
        ServiceRegistry.initialize_plugins()
        plugin = ServiceRegistry.get_plugin_by_name('heap-exploit')
        assert plugin is not None
        assert isinstance(plugin, HeapExploitPlugin)

    def test_get_manual_alternatives(self):
        """PROVES: Plugin provides manual alternatives"""
        plugin = HeapExploitPlugin()
        alternatives = plugin.get_manual_alternatives('any-task')

        assert isinstance(alternatives, list)
        assert len(alternatives) > 0
        # Should mention manual analysis methods
        alts_text = ' '.join(alternatives).lower()
        assert 'gdb' in alts_text or 'manual' in alts_text

    def test_on_task_complete_no_pie(self):
        """PROVES: Plugin generates follow-up tasks based on results"""
        plugin = HeapExploitPlugin()

        # Simulate checksec finding no PIE
        result = "No PIE: Enabled"
        new_tasks = plugin.on_task_complete(
            task_id='checksec',
            result=result,
            target='test'
        )

        assert isinstance(new_tasks, list)
        assert len(new_tasks) > 0
        # Should suggest exploitation approach
        first_task = new_tasks[0]
        assert 'no-pie' in first_task['id'].lower() or 'exploit' in first_task['id'].lower()


class TestHeapExploitEducational:
    """Test educational value of plugin"""

    @pytest.fixture
    def plugin(self):
        return HeapExploitPlugin()

    def test_gdb_commands_comprehensive(self, plugin):
        """PROVES: GDB commands are educational and comprehensive"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        gdb_task = find_task_by_id(tree, 'gdb-heap-basics')
        assert gdb_task is not None

        metadata = gdb_task['metadata']
        notes = metadata['notes']
        notes_text = '\n'.join(notes)

        # Should include actual commands
        assert 'gdb' in notes_text
        assert 'heap' in notes_text or 'bins' in notes_text
        # Should explain what commands do (indicated by comments)
        assert '#' in notes_text

    def test_pwndbg_commands_detailed(self, plugin):
        """PROVES: pwndbg commands are detailed with explanations"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        pwndbg_task = find_task_by_id(tree, 'pwndbg-heap-analysis')
        assert pwndbg_task is not None

        notes = pwndbg_task['metadata']['notes']
        notes_text = '\n'.join(notes)

        # Should cover multiple pwndbg commands
        assert 'heap' in notes_text
        assert 'bins' in notes_text or 'fastbins' in notes_text
        assert 'tcache' in notes_text or 'tcachebins' in notes_text

    def test_chunk_structure_explained(self, plugin):
        """PROVES: Heap chunk structure is clearly explained"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        chunk_task = find_task_by_id(tree, 'heap-chunk-structure')
        assert chunk_task is not None

        notes = chunk_task['metadata']['notes']
        notes_text = '\n'.join(notes)

        # Should explain malloc_chunk structure
        assert 'malloc_chunk' in notes_text
        assert 'prev_size' in notes_text or 'mchunk_prev_size' in notes_text
        assert 'size' in notes_text
        # Should explain flag bits
        assert 'flag' in notes_text.lower() or 'bit' in notes_text.lower()

    def test_bins_explained_comprehensive(self, plugin):
        """PROVES: Bins are comprehensively explained"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        bins_task = find_task_by_id(tree, 'bins-explained')
        assert bins_task is not None

        notes = bins_task['metadata']['notes']
        notes_text = '\n'.join(notes)

        # Should cover all bin types
        assert 'fastbin' in notes_text.lower()
        assert 'tcache' in notes_text.lower()
        assert 'unsorted' in notes_text.lower()
        assert 'small' in notes_text.lower()
        assert 'large' in notes_text.lower()

    def test_pwntools_template_provided(self, plugin):
        """PROVES: Plugin provides pwntools exploit template"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': '/path/to/binary'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        template_task = find_task_by_id(tree, 'pwntools-template')
        assert template_task is not None

        notes = template_task['metadata']['notes']
        notes_text = '\n'.join(notes)

        # Should include pwntools code
        assert 'from pwn import' in notes_text
        assert 'malloc' in notes_text or 'free' in notes_text
        # Should include helper functions
        assert 'def ' in notes_text

    def test_learning_resources_included(self, plugin):
        """PROVES: Plugin includes learning resources"""
        tree = plugin.get_task_tree('test', 0, {'binary_path': 'test'})

        def find_task_by_id(node, target_id):
            if target_id in node.get('id', ''):
                return node
            for child in node.get('children', []):
                result = find_task_by_id(child, target_id)
                if result:
                    return result
            return None

        resources_task = find_task_by_id(tree, 'heap-exploitation-resources')
        assert resources_task is not None

        notes = resources_task['metadata']['notes']
        notes_text = '\n'.join(notes)

        # Should include URLs and resources
        assert 'http' in notes_text.lower()
        # Should mention specific resources
        assert 'azeria' in notes_text.lower() or 'hacktricks' in notes_text.lower()
