"""
Test suite for Lua exploitation service plugin

Validates:
- Detection logic for Lua scripting engines
- Task tree generation with comprehensive exploitation paths
- OSCP-focused metadata completeness
- Educational content quality
"""

import pytest
from crack.track.services.lua_exploit import LuaExploitPlugin


class TestLuaExploitPlugin:
    """Test suite for LuaExploitPlugin"""

    @pytest.fixture
    def plugin(self):
        """Create plugin instance"""
        return LuaExploitPlugin()

    def test_plugin_name(self, plugin):
        """PROVES: Plugin has correct name"""
        assert plugin.name == "lua-exploit"

    def test_service_names(self, plugin):
        """PROVES: Plugin recognizes Lua service variants"""
        expected_names = ['lua', 'luajit', 'lua5.1', 'lua5.2', 'lua5.3', 'lua-script', 'script-engine']
        assert plugin.service_names == expected_names

    # ===== DETECTION TESTS =====

    def test_detect_lua_service_name(self, plugin):
        """PROVES: Plugin detects 'lua' in service name"""
        port_info = {
            'port': 8080,
            'service': 'lua',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_luajit_service(self, plugin):
        """PROVES: Plugin detects LuaJIT services"""
        port_info = {
            'port': 8080,
            'service': 'luajit',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_lua_in_product(self, plugin):
        """PROVES: Plugin detects Lua mentioned in product field"""
        port_info = {
            'port': 8080,
            'service': 'unknown',
            'product': 'Custom Lua Scripting Engine',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_lua_in_version(self, plugin):
        """PROVES: Plugin detects Lua version information"""
        port_info = {
            'port': 8080,
            'service': 'custom',
            'version': 'lua5.1',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_lua_in_extrainfo(self, plugin):
        """PROVES: Plugin detects Lua in extra information"""
        port_info = {
            'port': 8080,
            'service': 'custom',
            'extrainfo': 'powered by lua',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_scripting_service(self, plugin):
        """PROVES: Plugin detects generic scripting services"""
        port_info = {
            'port': 8080,
            'service': 'script-engine',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_game_server_port_wow(self, plugin):
        """PROVES: Plugin detects World of Warcraft port (Lua scripting)"""
        port_info = {
            'port': 3724,
            'service': 'unknown',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_game_server_port_minecraft(self, plugin):
        """PROVES: Plugin detects Minecraft port (Lua mods)"""
        port_info = {
            'port': 25565,
            'service': 'minecraft',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_game_server_port_gmod(self, plugin):
        """PROVES: Plugin detects Garry's Mod port (Lua scripting)"""
        port_info = {
            'port': 27015,
            'service': 'unknown',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_roblox_port(self, plugin):
        """PROVES: Plugin detects Roblox port (Lua scripting)"""
        port_info = {
            'port': 53640,
            'service': 'unknown',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_negative_http(self, plugin):
        """PROVES: Plugin does not detect unrelated HTTP service"""
        port_info = {
            'port': 80,
            'service': 'http',
            'product': 'Apache httpd',
            'state': 'open'
        }
        assert plugin.detect(port_info) == False

    def test_detect_negative_ssh(self, plugin):
        """PROVES: Plugin does not detect SSH service"""
        port_info = {
            'port': 22,
            'service': 'ssh',
            'product': 'OpenSSH',
            'state': 'open'
        }
        assert plugin.detect(port_info) == False

    def test_detect_handles_missing_fields(self, plugin):
        """PROVES: Plugin handles missing fields gracefully"""
        port_info = {
            'port': 8080
            # Missing service, product, version, extrainfo
        }
        assert plugin.detect(port_info) == False

    # ===== TASK TREE STRUCTURE TESTS =====

    def test_task_tree_structure(self, plugin):
        """PROVES: Task tree has valid structure"""
        service_info = {
            'port': 8080,
            'service': 'lua',
            'version': '5.1',
            'product': 'Lua Scripting Engine'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Verify root structure
        assert 'id' in tree
        assert tree['id'] == 'lua-exploit-8080'
        assert 'name' in tree
        assert 'Lua Sandbox Exploitation' in tree['name']
        assert 'type' in tree
        assert tree['type'] == 'parent'
        assert 'children' in tree
        assert len(tree['children']) > 0

    def test_task_tree_has_reconnaissance_phase(self, plugin):
        """PROVES: Task tree includes reconnaissance phase"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Find reconnaissance phase
        recon_phase = None
        for child in tree['children']:
            if 'recon' in child['id'].lower():
                recon_phase = child
                break

        assert recon_phase is not None
        assert 'children' in recon_phase
        assert len(recon_phase['children']) > 0

    def test_task_tree_has_command_execution_phase(self, plugin):
        """PROVES: Task tree includes command execution phase"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Find command execution phase
        cmd_exec_phase = None
        for child in tree['children']:
            if 'command-exec' in child['id'].lower():
                cmd_exec_phase = child
                break

        assert cmd_exec_phase is not None
        assert 'children' in cmd_exec_phase

    def test_task_tree_has_advanced_exploitation_phase(self, plugin):
        """PROVES: Task tree includes advanced exploitation techniques"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Find advanced phase
        advanced_phase = None
        for child in tree['children']:
            if 'advanced' in child['id'].lower():
                advanced_phase = child
                break

        assert advanced_phase is not None

    def test_task_tree_includes_banner_analysis(self, plugin):
        """PROVES: Task tree includes Lua banner analysis"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find banner task
        banner_tasks = [t for t in all_tasks if 'banner' in t.get('id', '').lower()]
        assert len(banner_tasks) > 0

    def test_task_tree_includes_globals_enumeration(self, plugin):
        """PROVES: Task tree includes _G enumeration"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find globals enumeration task
        globals_tasks = [t for t in all_tasks if 'globals' in t.get('id', '').lower()]
        assert len(globals_tasks) > 0

        # Verify it mentions _G
        globals_task = globals_tasks[0]
        metadata = globals_task.get('metadata', {})
        description = metadata.get('description', '').lower()
        assert '_g' in description

    def test_task_tree_includes_io_os_testing(self, plugin):
        """PROVES: Task tree includes io/os command execution testing"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find io/os test task
        io_os_tasks = [t for t in all_tasks if 'io-os' in t.get('id', '').lower()]
        assert len(io_os_tasks) > 0

    def test_task_tree_includes_bytecode_exploitation(self, plugin):
        """PROVES: Task tree includes bytecode loading exploitation"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find bytecode tasks
        bytecode_tasks = [t for t in all_tasks if 'bytecode' in t.get('id', '').lower()]
        assert len(bytecode_tasks) > 0

    def test_task_tree_includes_luajit_ffi(self, plugin):
        """PROVES: Task tree includes LuaJIT FFI exploitation"""
        service_info = {
            'port': 8080,
            'service': 'luajit'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find FFI tasks
        ffi_tasks = [t for t in all_tasks if 'ffi' in t.get('id', '').lower()]
        assert len(ffi_tasks) > 0

    def test_task_tree_includes_auto_run_callbacks(self, plugin):
        """PROVES: Task tree includes auto-run callback injection"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Flatten all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find auto-run task
        autorun_tasks = [t for t in all_tasks if 'auto-run' in t.get('id', '').lower()]
        assert len(autorun_tasks) > 0

    # ===== OSCP METADATA TESTS =====

    def test_command_tasks_have_required_metadata(self, plugin):
        """PROVES: All command tasks have required OSCP metadata"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all command tasks
        command_tasks = []
        def collect_command_tasks(node):
            if node.get('type') == 'command':
                command_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_command_tasks(child)

        for child in tree['children']:
            collect_command_tasks(child)

        assert len(command_tasks) > 0, "No command tasks found"

        # Verify each command task has required metadata
        for task in command_tasks:
            metadata = task.get('metadata', {})

            assert 'command' in metadata, f"Task {task['id']} missing 'command'"
            assert 'description' in metadata, f"Task {task['id']} missing 'description'"
            assert 'tags' in metadata, f"Task {task['id']} missing 'tags'"
            assert len(metadata['tags']) > 0, f"Task {task['id']} has empty tags"
            assert 'flag_explanations' in metadata, f"Task {task['id']} missing 'flag_explanations'"
            assert 'success_indicators' in metadata, f"Task {task['id']} missing 'success_indicators'"
            assert 'failure_indicators' in metadata, f"Task {task['id']} missing 'failure_indicators'"
            assert 'next_steps' in metadata, f"Task {task['id']} missing 'next_steps'"
            assert 'alternatives' in metadata, f"Task {task['id']} missing 'alternatives'"

    def test_manual_tasks_have_required_metadata(self, plugin):
        """PROVES: All manual tasks have required OSCP metadata"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all manual tasks
        manual_tasks = []
        def collect_manual_tasks(node):
            if node.get('type') == 'manual':
                manual_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_manual_tasks(child)

        for child in tree['children']:
            collect_manual_tasks(child)

        assert len(manual_tasks) > 0, "No manual tasks found"

        # Verify each manual task has metadata
        for task in manual_tasks:
            metadata = task.get('metadata', {})

            assert 'description' in metadata, f"Task {task['id']} missing 'description'"
            assert 'tags' in metadata, f"Task {task['id']} missing 'tags'"

            # Manual tasks should have alternatives (manual methods)
            if 'alternatives' in metadata:
                assert len(metadata['alternatives']) > 0

    def test_flag_explanations_present(self, plugin):
        """PROVES: Command tasks explain their flags"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Find banner analysis task (has nc command)
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        banner_tasks = [t for t in all_tasks if 'banner' in t.get('id', '').lower()]
        assert len(banner_tasks) > 0

        banner_task = banner_tasks[0]
        metadata = banner_task.get('metadata', {})

        # Verify flag explanations exist
        assert 'flag_explanations' in metadata
        flag_exp = metadata['flag_explanations']

        # Should explain nc command
        assert 'nc' in flag_exp
        assert len(flag_exp['nc']) > 0

    def test_success_indicators_present(self, plugin):
        """PROVES: Tasks include success indicators"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all command tasks
        command_tasks = []
        def collect_command_tasks(node):
            if node.get('type') == 'command':
                command_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_command_tasks(child)

        for child in tree['children']:
            collect_command_tasks(child)

        # Verify success indicators
        for task in command_tasks:
            metadata = task.get('metadata', {})
            assert 'success_indicators' in metadata
            assert len(metadata['success_indicators']) >= 1

    def test_failure_indicators_present(self, plugin):
        """PROVES: Tasks include failure indicators"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all command tasks
        command_tasks = []
        def collect_command_tasks(node):
            if node.get('type') == 'command':
                command_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_command_tasks(child)

        for child in tree['children']:
            collect_command_tasks(child)

        # Verify failure indicators
        for task in command_tasks:
            metadata = task.get('metadata', {})
            assert 'failure_indicators' in metadata
            assert len(metadata['failure_indicators']) >= 1

    def test_next_steps_present(self, plugin):
        """PROVES: Tasks include next steps guidance"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all command tasks
        command_tasks = []
        def collect_command_tasks(node):
            if node.get('type') == 'command':
                command_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_command_tasks(child)

        for child in tree['children']:
            collect_command_tasks(child)

        # Verify next steps
        for task in command_tasks:
            metadata = task.get('metadata', {})
            assert 'next_steps' in metadata
            assert len(metadata['next_steps']) >= 1

    def test_alternatives_present(self, plugin):
        """PROVES: Tasks include manual alternatives"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all command tasks
        command_tasks = []
        def collect_command_tasks(node):
            if node.get('type') == 'command':
                command_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_command_tasks(child)

        for child in tree['children']:
            collect_command_tasks(child)

        # Verify alternatives
        for task in command_tasks:
            metadata = task.get('metadata', {})
            assert 'alternatives' in metadata
            assert len(metadata['alternatives']) >= 1

    def test_oscp_tags_present(self, plugin):
        """PROVES: Tasks include OSCP priority tags"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all tasks with tags
        all_tasks = []
        def collect_tasks(node):
            if 'metadata' in node and 'tags' in node['metadata']:
                all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Verify OSCP tags used
        oscp_tags_found = False
        for task in all_tasks:
            tags = task['metadata']['tags']
            if any('OSCP:' in tag for tag in tags):
                oscp_tags_found = True
                break

        assert oscp_tags_found, "No OSCP priority tags found"

    # ===== EDUCATIONAL CONTENT TESTS =====

    def test_tasks_include_lua_code_examples(self, plugin):
        """PROVES: Tasks include Lua code examples for learning"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find tasks with Lua code
        lua_code_found = False
        for task in all_tasks:
            metadata = task.get('metadata', {})

            # Check in alternatives or notes
            alternatives = metadata.get('alternatives', [])
            notes = metadata.get('notes', '')

            for alt in alternatives:
                if '```lua' in alt or 'function' in alt or 'pairs(_G)' in alt:
                    lua_code_found = True
                    break

            if '```lua' in notes or 'io.popen' in notes or 'os.execute' in notes:
                lua_code_found = True
                break

        assert lua_code_found, "No Lua code examples found in tasks"

    def test_tasks_explain_sandbox_escape_methodology(self, plugin):
        """PROVES: Tasks explain sandbox escape concepts"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Find globals enumeration task
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        globals_tasks = [t for t in all_tasks if 'globals' in t.get('id', '').lower()]
        assert len(globals_tasks) > 0

        # Verify educational content
        globals_task = globals_tasks[0]
        metadata = globals_task.get('metadata', {})
        notes = metadata.get('notes', '')

        # Should explain dangerous primitives
        assert 'io' in notes.lower() or 'os' in notes.lower()
        assert 'load' in notes.lower() or 'bytecode' in notes.lower()

    def test_tasks_include_oscp_relevance_notes(self, plugin):
        """PROVES: Tasks explain OSCP relevance for learning"""
        service_info = {
            'port': 8080,
            'service': 'lua'
        }

        tree = plugin.get_task_tree('192.168.45.100', 8080, service_info)

        # Collect all tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Find tasks with OSCP notes
        oscp_notes_found = False
        for task in all_tasks:
            metadata = task.get('metadata', {})
            notes = metadata.get('notes', '')

            if 'oscp' in notes.lower():
                oscp_notes_found = True
                break

        assert oscp_notes_found, "No OSCP relevance notes found"

    # ===== ON_TASK_COMPLETE TESTS =====

    def test_on_task_complete_detects_io_os(self, plugin):
        """PROVES: Plugin spawns additional tasks when io/os detected"""
        result = "io = table: 0x12345678\nos = table: 0x87654321"

        new_tasks = plugin.on_task_complete(
            'lua-enum-globals-8080',
            result,
            '192.168.45.100'
        )

        assert len(new_tasks) > 0
        # Should spawn command execution confirmation task
        cmd_exec_tasks = [t for t in new_tasks if 'cmd-exec' in t['id'].lower()]
        assert len(cmd_exec_tasks) > 0

    def test_on_task_complete_detects_ffi(self, plugin):
        """PROVES: Plugin spawns LuaJIT FFI task when ffi detected"""
        result = "ffi = table: 0xabcdef00\njit = table: 0x11111111"

        new_tasks = plugin.on_task_complete(
            'lua-enum-globals-8080',
            result,
            '192.168.45.100'
        )

        assert len(new_tasks) > 0
        # Should spawn FFI exploitation task
        ffi_tasks = [t for t in new_tasks if 'ffi' in t['id'].lower()]
        assert len(ffi_tasks) > 0

    def test_on_task_complete_detects_bytecode_loaders(self, plugin):
        """PROVES: Plugin spawns bytecode task when load/loadstring detected"""
        result = "load = function: 0x12345678\nloadstring = function: 0x87654321"

        new_tasks = plugin.on_task_complete(
            'lua-enum-globals-8080',
            result,
            '192.168.45.100'
        )

        assert len(new_tasks) > 0
        # Should spawn bytecode exploitation task
        bytecode_tasks = [t for t in new_tasks if 'bytecode' in t['id'].lower()]
        assert len(bytecode_tasks) > 0

    def test_on_task_complete_spawns_shell_task_on_success(self, plugin):
        """PROVES: Plugin spawns shell establishment task after command execution"""
        result = "Command executed successfully"

        new_tasks = plugin.on_task_complete(
            'lua-io-os-test-8080',
            result,
            '192.168.45.100'
        )

        assert len(new_tasks) > 0
        # Should spawn reverse shell task
        shell_tasks = [t for t in new_tasks if 'shell' in t['id'].lower()]
        assert len(shell_tasks) > 0

    # ===== MANUAL ALTERNATIVES TESTS =====

    def test_get_manual_alternatives_globals_enum(self, plugin):
        """PROVES: Plugin provides manual alternatives for _G enumeration"""
        alternatives = plugin.get_manual_alternatives('lua-enum-globals-8080')

        assert len(alternatives) > 0
        # Should include pairs(_G) method
        assert any('pairs' in alt.lower() and '_g' in alt.lower() for alt in alternatives)

    def test_get_manual_alternatives_io_os(self, plugin):
        """PROVES: Plugin provides manual alternatives for command execution"""
        alternatives = plugin.get_manual_alternatives('lua-io-os-test-8080')

        assert len(alternatives) > 0
        # Should include io.popen or os.execute
        assert any('io.popen' in alt.lower() or 'os.execute' in alt.lower() for alt in alternatives)

    def test_get_manual_alternatives_bytecode(self, plugin):
        """PROVES: Plugin provides manual alternatives for bytecode exploitation"""
        alternatives = plugin.get_manual_alternatives('lua-bytecode-8080')

        assert len(alternatives) > 0
        # Should mention IDA/Ghidra or luac
        assert any('ida' in alt.lower() or 'ghidra' in alt.lower() or 'luac' in alt.lower() for alt in alternatives)

    def test_get_manual_alternatives_ffi(self, plugin):
        """PROVES: Plugin provides manual alternatives for FFI exploitation"""
        alternatives = plugin.get_manual_alternatives('luajit-ffi-8080')

        assert len(alternatives) > 0
        # Should include ffi.C.system or ffi.cdef
        assert any('ffi' in alt.lower() for alt in alternatives)

    # ===== INTEGRATION TESTS =====

    def test_complete_workflow_luajit(self, plugin):
        """
        PROVES: Complete workflow for LuaJIT exploitation

        Workflow:
        1. Detect LuaJIT service
        2. Generate task tree
        3. Verify FFI exploitation tasks present
        4. Verify educational metadata complete
        """
        # Step 1: Detection
        port_info = {
            'port': 8080,
            'service': 'luajit',
            'version': '2.1.0',
            'product': 'LuaJIT scripting engine'
        }
        assert plugin.detect(port_info) == True

        # Step 2: Task generation
        tree = plugin.get_task_tree('192.168.45.100', 8080, port_info)
        assert tree is not None

        # Step 3: Verify FFI tasks
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        ffi_tasks = [t for t in all_tasks if 'ffi' in t.get('id', '').lower()]
        assert len(ffi_tasks) > 0, "No FFI exploitation tasks found"

        # Step 4: Verify educational metadata
        ffi_task = ffi_tasks[0]
        metadata = ffi_task.get('metadata', {})
        assert 'description' in metadata
        assert 'alternatives' in metadata
        assert len(metadata['alternatives']) > 0
        assert 'notes' in metadata
        assert 'ffi' in metadata['notes'].lower()

    def test_complete_workflow_game_server(self, plugin):
        """
        PROVES: Complete workflow for game server with Lua scripting

        Workflow:
        1. Detect game server port
        2. Generate comprehensive task tree
        3. Verify all exploitation paths covered
        """
        # Step 1: Detection (Garry's Mod)
        port_info = {
            'port': 27015,
            'service': 'source-engine',
            'product': 'Garry\'s Mod Server'
        }
        assert plugin.detect(port_info) == True

        # Step 2: Task generation
        tree = plugin.get_task_tree('192.168.45.100', 27015, port_info)

        # Step 3: Verify comprehensive coverage
        all_tasks = []
        def collect_tasks(node):
            all_tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    collect_tasks(child)

        for child in tree['children']:
            collect_tasks(child)

        # Should have recon tasks
        recon_tasks = [t for t in all_tasks if 'recon' in t.get('id', '').lower()]
        assert len(recon_tasks) > 0

        # Should have command execution tasks
        cmd_tasks = [t for t in all_tasks if 'command-exec' in t.get('id', '').lower() or 'io-os' in t.get('id', '').lower()]
        assert len(cmd_tasks) > 0

        # Should have advanced exploitation tasks
        advanced_tasks = [t for t in all_tasks if 'advanced' in t.get('id', '').lower() or 'bytecode' in t.get('id', '').lower()]
        assert len(advanced_tasks) > 0
