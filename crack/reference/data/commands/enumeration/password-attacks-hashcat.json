{
  "category": "enumeration",
  "description": "Password hash cracking using Hashcat (GPU/CPU accelerated)",
  "commands": [
    {
      "id": "hashcat-benchmark",
      "name": "Hashcat Benchmark Hash Rates",
      "category": "enumeration",
      "command": "hashcat -b",
      "description": "Benchmark all hash algorithms to determine cracking speed",
      "tags": ["HASHCAT", "BENCHMARK", "PERFORMANCE", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [],
      "flag_explanations": {
        "-b": "Benchmark mode - Tests all supported hash algorithms and displays hash rate (hashes per second). Critical for: 1) Calculating cracking time before starting 2) Comparing GPU vs CPU performance 3) Determining hardware bottlenecks. Results in MH/s (millions of hashes/second). GPU typically 10-100x faster than CPU for most algorithms."
      },
      "success_indicators": [
        "Speed.#1.........: ",
        "MH/s",
        "Benchmark completed"
      ],
      "failure_indicators": [
        "No devices found",
        "OpenCL initialization failed",
        "CUDA initialization failed"
      ],
      "troubleshooting": {
        "No devices found": "No GPU detected or drivers missing. Install: apt install ocl-icd-opencl-dev nvidia-opencl-icd (NVIDIA) or amdgpu-pro (AMD)",
        "OpenCL initialization failed": "OpenCL runtime not installed. Solution: apt install ocl-icd-libopencl1",
        "Running on CPU": "Expected in Kali VM without GPU passthrough. Use --force flag to suppress warnings"
      },
      "notes": "OSCP TIP: Run benchmark BEFORE exam to understand your hardware capabilities. Calculate cracking time = keyspace / hash_rate. Example: MD5 @ 68,000 MH/s vs SHA256 @ 9,000 MH/s. GPU benchmark requires GPU passthrough in VM or physical machine. VM without GPU will use CPU (much slower).",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-md5-crack",
      "name": "Crack MD5 Hash (Mode 0)",
      "category": "enumeration",
      "command": "hashcat -m 0 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack MD5 hashes using dictionary attack",
      "tags": ["HASHCAT", "MD5", "DICTIONARY_ATTACK", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing MD5 hash(es) - one per line",
          "example": "md5_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 0": "Hash mode 0 - MD5 algorithm. Use 'hashcat --help' or hashcat wiki to find modes. Common: 0=MD5, 100=SHA1, 1400=SHA256, 1000=NTLM, 3200=bcrypt, 1800=sha512crypt. Mode MUST match hash type or cracking fails silently.",
        "--force": "Force execution - Ignore warnings about drivers/OpenCL. REQUIRED in Kali VM without GPU. WARNING: May produce incorrect results in edge cases - verify found passwords manually when using --force. Only use when necessary (VM testing, driver issues)."
      },
      "success_indicators": [
        "Cracked",
        "Status...........: Cracked",
        "<HASH>:<PASSWORD>"
      ],
      "failure_indicators": [
        "Exhausted",
        "Status...........: Exhausted",
        "No hashes loaded"
      ],
      "next_steps": [
        "hashcat-show-cracked",
        "hashcat-rule-attack",
        "password-reuse-test"
      ],
      "alternatives": [
        "john --format=raw-md5 <HASH_FILE> --wordlist=<WORDLIST>",
        "Manual: for pw in $(cat wordlist); do echo -n \"$pw\" | md5sum; done"
      ],
      "troubleshooting": {
        "No hashes loaded": "Hash format incorrect. Solution: Ensure one hash per line, no extra spaces. Remove usernames if present (user:hash → hash only unless hash:pass format expected)",
        "Token length exception": "Hash format doesn't match mode. Solution: Verify hash type with hash-identifier or hashid",
        "Separator unmatched": "Hash file has incorrect format. For username:hash format, use --username flag"
      },
      "notes": "OSCP TIP: MD5 is FAST (68,000 MH/s on GPU = 68 billion hashes/second). 8-char password with full charset = 6.5 hours. Always try straight dictionary attack before rules. Remove 'username:' prefix from hash file unless using --username flag. Verify mode matches hash type.",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-sha256-crack",
      "name": "Crack SHA256 Hash (Mode 1400)",
      "category": "enumeration",
      "command": "hashcat -m 1400 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack SHA-256 hashes using dictionary attack",
      "tags": ["HASHCAT", "SHA256", "DICTIONARY_ATTACK", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing SHA-256 hash(es)",
          "example": "sha256_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 1400": "Hash mode 1400 - SHA-256 algorithm. Slower than MD5 but still fast (9,000 MH/s on GPU vs 68,000 for MD5). Common in modern applications. SHA-256 hash = 64 hex characters."
      },
      "success_indicators": [
        "Status...........: Cracked",
        "Recovered........: 1/1"
      ],
      "notes": "SHA-256 hash length: 64 characters. Example: 5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6 = 'secret1'. Slower than MD5 but still GPU-friendly.",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-ntlm-crack",
      "name": "Crack NTLM Hash (Mode 1000)",
      "category": "enumeration",
      "command": "hashcat -m 1000 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack Windows NTLM hashes",
      "tags": ["HASHCAT", "NTLM", "WINDOWS", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing NTLM hash(es)",
          "example": "ntlm_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 1000": "Hash mode 1000 - NTLM (Windows password hashes). VERY FAST to crack (even faster than MD5). Extracted from SAM database, memory (mimikatz), or SMB authentication. Format: 32 hex characters. No salt = rainbow table vulnerable."
      },
      "success_indicators": [
        "Cracked",
        "Recovered........: 1/1"
      ],
      "notes": "OSCP TIP: NTLM hashes from Windows SAM, memory dumps, or SMBv1/v2 captures. EXTREMELY fast cracking (no salt). Common in Windows domain environments. Extract with: mimikatz, secretsdump.py, reg save HKLM\\SAM sam.save",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-rule-attack",
      "name": "Hashcat Rule-Based Attack",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Apply mutation rules to wordlist passwords",
      "tags": ["HASHCAT", "RULES", "MUTATION", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash type mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Path to rule file",
          "example": "/usr/share/hashcat/rules/best64.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r": "Rule file - Apply mutation rules to wordlist. Rules modify passwords (append, prepend, capitalize, etc.). Hashcat includes proven rules in /usr/share/hashcat/rules/. Best rules: best64.rule (fast), rockyou-30000.rule (thorough), dive.rule (comprehensive). Custom rules format: one rule per line, uses hashcat rule syntax ($1 = append '1', c = capitalize, etc.)"
      },
      "success_indicators": [
        "Guess.Mod........: Rules",
        "Cracked"
      ],
      "prerequisites": [
        "hashcat-create-rules"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "notes": "OSCP TIP: Rule-based attacks crack passwords that don't exist in wordlist. Password policies require complexity = users modify base words (Password → Password123!). Best rules for OSCP: best64.rule (fast testing), rockyou-30000.rule (designed for rockyou.txt). Dramatically increases keyspace (14M passwords × 30,000 rules = 420B attempts). Monitor with --status to track progress.",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-keepass-crack",
      "name": "Crack KeePass Database (Mode 13400)",
      "category": "enumeration",
      "command": "hashcat -m 13400 <KEEPASS_HASH> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack KeePass master password",
      "tags": ["HASHCAT", "KEEPASS", "PASSWORD_MANAGER", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<KEEPASS_HASH>",
          "description": "KeePass hash file (from keepass2john)",
          "example": "keepass.hash",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for mutations",
          "example": "/usr/share/hashcat/rules/rockyou-30000.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 13400": "Hash mode 13400 - KeePass 1 (AES/Twofish) and KeePass 2 (AES). Password manager master password. SLOW algorithm (by design - bcrypt-based KDF with iterations). CPU cracking may be comparable to GPU for KeePass. Hash extracted with keepass2john tool."
      },
      "success_indicators": [
        "Cracked",
        "$keepass$*...:PASSWORD"
      ],
      "prerequisites": [
        "keepass2john-extract"
      ],
      "alternatives": [
        "john --format=keepass <HASH_FILE> --wordlist=<WORDLIST> --rules=<RULE>"
      ],
      "troubleshooting": {
        "Token length exception": "Hash format invalid. Solution: Ensure keepass2john output is correct format, remove 'filename:' prefix before first $keepass$"
      },
      "notes": "OSCP TIP: KeePass databases found in user Documents, Desktop, or network shares. Extract hash with keepass2john Database.kdbx > keepass.hash. Remove 'Database:' prefix. KeePass uses strong KDF (slow hashing) - cracking takes longer than simple hashes. Focus on targeted wordlists based on user password patterns. Common user behavior: reuse password fragments with policy modifications (Password1! → Password123!).",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-ssh-key-crack",
      "name": "Crack SSH Private Key Passphrase (Mode 22921)",
      "category": "enumeration",
      "command": "hashcat -m 22921 <SSH_HASH> <WORDLIST> -r <RULE_FILE> --force",
      "description": "Crack SSH private key passphrase (aes-256-cbc cipher)",
      "tags": ["HASHCAT", "SSH", "PRIVATE_KEY", "PASSPHRASE", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<SSH_HASH>",
          "description": "SSH key hash file (from ssh2john)",
          "example": "ssh.hash",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist",
          "example": "custom_wordlist.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file for mutations",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 22921": "Hash mode 22921 - SSH private keys (RSA/DSA/EC) encrypted with aes-256-cbc cipher ($6$ in hash). WARNING: Modern SSH keys may use aes-256-ctr cipher which Hashcat does NOT support. If you get 'Token length exception', use John the Ripper instead (john supports aes-256-ctr)."
      },
      "success_indicators": [
        "Cracked",
        "$sshng$...:PASSPHRASE"
      ],
      "failure_indicators": [
        "Token length exception",
        "Hashfile on line X: Token length exception"
      ],
      "prerequisites": [
        "ssh2john-extract"
      ],
      "alternatives": [
        "john --format=SSH <HASH_FILE> --wordlist=<WORDLIST> --rules=<RULE> (supports aes-256-ctr)"
      ],
      "troubleshooting": {
        "Token length exception": "SSH key uses unsupported cipher (likely aes-256-ctr). Solution: Use John the Ripper instead - it supports more SSH ciphers including aes-256-ctr",
        "No hashes loaded": "Hash format incorrect. Ensure ssh2john output format, remove 'filename:' prefix"
      },
      "notes": "OSCP TIP: SSH private keys found in ~/.ssh/id_rsa, web server file disclosure vulnerabilities, or backup files. Extract hash with ssh2john id_rsa > ssh.hash. Remove 'id_rsa:' prefix. Check hash for cipher type: $6$ = aes-256-cbc (Hashcat OK), others may require JtR. Modern keys often use aes-256-ctr (JtR required). Build custom wordlists from user information (names, dates, common words found in notes.txt).",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-combination-attack",
      "name": "Hashcat Combination Attack",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 1 <HASH_FILE> <WORDLIST1> <WORDLIST2> --force",
      "description": "Combine words from two wordlists (word1+word2)",
      "tags": ["HASHCAT", "COMBINATION", "HYBRID", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST1>",
          "description": "First wordlist (left side)",
          "example": "words1.txt",
          "required": true
        },
        {
          "name": "<WORDLIST2>",
          "description": "Second wordlist (right side)",
          "example": "words2.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 1": "Attack mode 1 - Combination attack. Concatenates each word from wordlist1 with each word from wordlist2. Example: wordlist1=['pass','admin'] + wordlist2=['word','123'] = passwords: password, pass123, adminword, admin123. Keyspace = wordlist1_size × wordlist2_size. Useful for passwords like firstname+lastname, word+year, prefix+suffix."
      },
      "success_indicators": [
        "Guess.Base.......: File, File (combination)",
        "Cracked"
      ],
      "notes": "Combination attack for compound passwords. Example: First names + Last names, Words + Years, Common prefixes + Common words. Keyspace explodes quickly (1000 × 1000 = 1M passwords). Consider using small focused lists.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-mask-attack",
      "name": "Hashcat Mask Attack (Brute-Force Pattern)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> <MASK> --force",
      "description": "Brute-force attack using character mask pattern",
      "tags": ["HASHCAT", "MASK", "BRUTE_FORCE", "HASH_CRACKING", "OSCP:LOW"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Character mask pattern",
          "example": "?u?l?l?l?l?d?d?d?s",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 3": "Attack mode 3 - Mask attack (pure brute-force with pattern). Define character positions: ?l=lowercase, ?u=uppercase, ?d=digit, ?s=special. Example: ?u?l?l?l?l?d?d?d?s = Uppercase + 4 lowercase + 3 digits + 1 special (Password123!). Faster than full brute-force by constraining character sets per position. Use when password policy is known.",
        "<MASK>": "Character mask - ?l=lowercase (a-z), ?u=uppercase (A-Z), ?d=digits (0-9), ?s=special (!@#$%...), ?a=all. Example masks: ?d?d?d?d?d?d (6 digits), ?u?l?l?l?l?d?d?s (Pass12!), ?a?a?a?a?a?a?a?a (8-char full brute). Keyspace = charset_size^positions."
      },
      "success_indicators": [
        "Guess.Mask.......: <MASK>",
        "Cracked"
      ],
      "notes": "Use mask attacks when password policy is known. Example: 'Must start with capital, end with number and special char, 8 chars min' → ?u?l?l?l?l?d?d?s. WARNING: Brute-force is SLOW. 8-char full charset (?a?a?a?a?a?a?a?a) = years on CPU. Only use for short passwords or constrained charsets.",
      "oscp_relevance": "low"
    },
    {
      "id": "hashcat-hybrid-attack",
      "name": "Hashcat Hybrid Attack (Wordlist + Mask)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 6 <HASH_FILE> <WORDLIST> <MASK> --force",
      "description": "Append mask pattern to wordlist words",
      "tags": ["HASHCAT", "HYBRID", "MASK", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hashes",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Mask to append",
          "example": "?d?d?s",
          "required": true
        }
      ],
      "flag_explanations": {
        "-a 6": "Attack mode 6 - Hybrid wordlist + mask. Appends mask to each wordlist word. Example: wordlist='password' + mask='?d?d?s' = password00!, password01!, password00@, etc. Mode 7 prepends mask instead. Efficient for 'base word + numbers + special' pattern (common user behavior)."
      },
      "success_indicators": [
        "Guess.Base.......: File, Mask",
        "Cracked"
      ],
      "notes": "Hybrid attacks for common password patterns: base_word + digits + special. Example: rockyou.txt + ?d?d?s (2 digits + 1 special) = Password12!, Welcome99#, etc. More efficient than full rule-based attack for this specific pattern.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-show-cracked",
      "name": "Show Cracked Passwords",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> --show",
      "description": "Display previously cracked passwords from potfile",
      "tags": ["HASHCAT", "RESULTS", "OUTPUT", "HASH_CRACKING", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Original hash file",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--show": "Show cracked - Display passwords from hashcat.potfile (persistent storage). Hashcat automatically saves cracked hashes to ~/.hashcat/hashcat.potfile. Use --show to view results without re-running attack. Format: hash:password or username:hash:password."
      },
      "success_indicators": [
        "<HASH>:<PASSWORD>",
        "Recovered........: X/Y"
      ],
      "notes": "OSCP TIP: Hashcat saves ALL cracked passwords to ~/.hashcat/hashcat.potfile permanently. Use --show to retrieve results. Critical for documentation - always run --show after successful crack to capture passwords for report. Potfile persists across sessions.",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-output-format",
      "name": "Hashcat Output Format Control",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> --show --outfile-format=2",
      "description": "Control output format for cracked passwords",
      "tags": ["HASHCAT", "OUTPUT", "FORMAT", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--outfile-format": "Output format - Controls --show output. Values: 1=hash, 2=plain, 3=hex_plain, 5=hash:plain (default). Use format 2 for password-only output (useful for scripting). Format 5 shows hash:password pairs (best for documentation)."
      },
      "success_indicators": [
        "PASSWORD (format 2)",
        "HASH:PASSWORD (format 5)"
      ],
      "notes": "Output formats: 2=password only (scripting), 5=hash:password (documentation). Default format 5 is best for OSCP reporting.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-status-timer",
      "name": "Hashcat Auto-Status Updates",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --status --status-timer=10",
      "description": "Display progress status every N seconds",
      "tags": ["HASHCAT", "STATUS", "PROGRESS", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--status": "Status display - Show progress updates. Press 's' key manually for on-demand status. Displays: Progress %, Speed (H/s), Time (running/estimated), Recovered hashes, Rejected, Temperature, etc.",
        "--status-timer": "Auto-status interval - Seconds between automatic status displays. Default: manual only. Use 10-60 for long-running attacks to monitor progress. Lower values = more output spam."
      },
      "success_indicators": [
        "Progress.........: X/Y",
        "Speed.#1.........: ",
        "Time.Estimated...: "
      ],
      "notes": "OSCP TIP: Use --status --status-timer=30 for long attacks (rule-based, large wordlists). Provides ETA for completion. Critical for time management in exam - know when to abandon attack if ETA exceeds available time.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-increment",
      "name": "Hashcat Increment Mode (Progressive Length)",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> ?a?a?a?a?a?a --increment --increment-min=<MIN> --increment-max=<MAX> --force",
      "description": "Brute-force with incrementing password length",
      "tags": ["HASHCAT", "INCREMENT", "BRUTE_FORCE", "HASH_CRACKING", "OSCP:LOW"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<MIN>",
          "description": "Minimum password length",
          "example": "4",
          "required": true
        },
        {
          "name": "<MAX>",
          "description": "Maximum password length",
          "example": "8",
          "required": true
        }
      ],
      "flag_explanations": {
        "--increment": "Increment mode - Start with --increment-min length, progressively increase to --increment-max. Example: min=4, max=8 → tries all 4-char, then all 5-char, then 6, 7, 8. More efficient than starting at max length. Short passwords crack first.",
        "--increment-min": "Minimum length - Starting password length for increment mode. Use known password policy minimum. Default: 1 (usually wasteful).",
        "--increment-max": "Maximum length - Maximum password length for increment mode. Constrained by mask length. Example: mask=?a?a?a?a?a?a?a?a (8 chars) with --increment-max=8 tries lengths 1-8."
      },
      "notes": "Increment mode for brute-force when password length is unknown but constrained (policy: 4-12 chars). WARNING: Still extremely slow. 8-char full charset = years. Only viable for fast hashes (MD5, NTLM) and short passwords (≤6 chars).",
      "oscp_relevance": "low"
    },
    {
      "id": "hashcat-potfile-disable",
      "name": "Hashcat Disable Potfile",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --potfile-disable --force",
      "description": "Disable automatic saving of cracked hashes",
      "tags": ["HASHCAT", "POTFILE", "CONFIG", "HASH_CRACKING", "OSCP:LOW"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--potfile-disable": "Disable potfile - Don't save cracked hashes to hashcat.potfile. Use when: 1) Testing/debugging 2) Don't want persistent storage 3) Privacy concerns. WARNING: Results lost after session unless manually saved with --outfile."
      },
      "notes": "Rarely needed - potfile is BENEFICIAL for OSCP (persistent results, no re-cracking same hashes). Only disable for testing or privacy. Always use --outfile if potfile disabled.",
      "oscp_relevance": "low"
    },
    {
      "id": "hashcat-username-format",
      "name": "Hashcat Username:Hash Format",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> --username --force",
      "description": "Handle hash files with username:hash format",
      "tags": ["HASHCAT", "USERNAME", "FORMAT", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "1000",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File with username:hash format",
          "example": "ntlm_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "--username": "Username parsing - Enable if hash file format is 'username:hash' (one per line). Hashcat extracts username for output. Results show: 'username:hash:password'. Common for NTLM dumps (user:hash from SAM or secretsdump.py output). Without flag, Hashcat treats entire line as hash (fails)."
      },
      "success_indicators": [
        "Separator unmatched (without --username flag)",
        "username:hash:password (with flag)"
      ],
      "troubleshooting": {
        "Separator unmatched": "Hash file contains colons (username:hash format). Solution: Add --username flag or remove usernames (extract hash-only column)"
      },
      "notes": "OSCP TIP: secretsdump.py, mimikatz, and SAM dumps often output username:hash format. Use --username flag to preserve username-password mapping for documentation. Output format: user:hash:password (critical for privilege escalation reporting).",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-custom-charset",
      "name": "Hashcat Custom Character Set",
      "category": "enumeration",
      "command": "hashcat -m <MODE> -a 3 <HASH_FILE> -1 <CHARSET> <MASK> --force",
      "description": "Define custom character set for mask attack",
      "tags": ["HASHCAT", "CUSTOM_CHARSET", "MASK", "HASH_CRACKING", "OSCP:LOW"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<CHARSET>",
          "description": "Custom character set definition",
          "example": "abc123!@#",
          "required": true
        },
        {
          "name": "<MASK>",
          "description": "Mask using custom charset (use ?1 for -1 charset)",
          "example": "?1?1?1?1?1?1",
          "required": true
        }
      ],
      "flag_explanations": {
        "-1": "Custom charset 1 - Define custom character set. Use ?1 in mask to reference it. Up to -4 custom charsets (-1, -2, -3, -4). Example: -1 'aeiou' ?1?1?1?1 = 4-char passwords using only vowels. Useful for: Limited charset passwords, hex-only, specific symbols, etc.",
        "?1": "Reference to custom charset 1 (defined with -1 flag). ?2 = charset 2 (-2), ?3 = charset 3 (-3), ?4 = charset 4 (-4)."
      },
      "notes": "Custom charsets for constrained brute-force. Example: Hex passwords → -1 '0123456789abcdef' ?1?1?1?1?1?1. Reduces keyspace dramatically (16^6 vs 95^6 for 6-char).",
      "oscp_relevance": "low"
    },
    {
      "id": "hashcat-bcrypt-crack",
      "name": "Crack bcrypt Hash (Mode 3200)",
      "category": "enumeration",
      "command": "hashcat -m 3200 <HASH_FILE> <WORDLIST> --force",
      "description": "Crack bcrypt hashes (SLOW algorithm)",
      "tags": ["HASHCAT", "BCRYPT", "SLOW_HASH", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<HASH_FILE>",
          "description": "File containing bcrypt hashes",
          "example": "bcrypt_hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Password wordlist (use focused list)",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m 3200": "Hash mode 3200 - bcrypt algorithm. INTENTIONALLY SLOW (designed to resist cracking). Hash rate: ~100-10,000 H/s (compared to MD5: 68,000,000,000 H/s). GPU advantage minimal for bcrypt - CPU may be comparable. Common in modern web apps (Linux /etc/shadow $2y$, password managers). Requires FOCUSED wordlists (rockyou.txt = months/years)."
      },
      "success_indicators": [
        "Cracked",
        "Speed.#1.........: XXX H/s (not MH/s or GH/s)"
      ],
      "troubleshooting": {
        "Extremely slow progress": "Expected behavior - bcrypt is slow by design. Solution: 1) Use small focused wordlist 2) Rule-based attack with best rules only 3) Consider if viable given time constraints"
      },
      "notes": "OSCP WARNING: bcrypt cracking is VERY SLOW (1000-10000 passwords/second vs billions for MD5). 14M rockyou.txt = 23-233 hours for straight dictionary. NOT viable for exam time constraints unless: 1) Small focused wordlist 2) Password reuse suspected 3) No other attack vectors. Focus on other vulnerabilities first.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-debug-mode",
      "name": "Hashcat Debug Mode (Test Rules)",
      "category": "enumeration",
      "command": "hashcat <WORDLIST> -r <RULE_FILE> --stdout",
      "description": "Test rule mutations without cracking (debug mode)",
      "tags": ["HASHCAT", "DEBUG", "RULES", "TESTING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist to mutate",
          "example": "test_words.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file to test",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "--stdout": "Debug mode - Output mutated passwords to stdout instead of cracking. No hash mode (-m) required. Used for: 1) Testing custom rules before cracking 2) Generating mutated wordlists 3) Verifying rule syntax. Can pipe output to file: hashcat wordlist -r rules --stdout > mutated.txt"
      },
      "success_indicators": [
        "Password1",
        "password!",
        "mutated output displayed"
      ],
      "notes": "OSCP TIP: Always test custom rules with --stdout before running full crack. Verify mutations match expected password policy. Example: echo 'password' | hashcat -r rules --stdout (test single word). Saves time vs discovering rule errors mid-crack.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-optimized-kernel",
      "name": "Hashcat Optimized Kernel",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -O --force",
      "description": "Use optimized kernel for speed boost (password length ≤31)",
      "tags": ["HASHCAT", "OPTIMIZATION", "PERFORMANCE", "HASH_CRACKING", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "Hash file",
          "example": "hashes.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Wordlist path",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-O": "Optimized kernel - Enable performance-optimized kernels for faster cracking. LIMITATION: Password length restricted to ≤31 characters (vs ≤256 without -O). Speed increase: ~2x for many algorithms. Use when: 1) Password policy has length limit ≤31 2) No evidence of long passwords. WARNING: Will NOT crack passwords >31 chars."
      },
      "success_indicators": [
        "Optimized kernel based on rules file",
        "Faster H/s rate"
      ],
      "notes": "Speed boost (~2x) but limits password length to 31 chars. Safe for most real-world passwords (policies rarely allow >31). Check password policy before using.",
      "oscp_relevance": "medium"
    }
  ]
}
