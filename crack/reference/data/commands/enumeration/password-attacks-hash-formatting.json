{
  "category": "enumeration",
  "description": "Hash extraction and formatting tools for password cracking",
  "commands": [
    {
      "id": "keepass2john-extract",
      "name": "Extract KeePass Database Hash",
      "category": "enumeration",
      "command": "keepass2john <KEEPASS_DB> > <OUTPUT_FILE>",
      "description": "Convert KeePass database to John/Hashcat compatible hash format",
      "tags": ["HASH_FORMATTING", "KEEPASS", "PASSWORD_MANAGER", "JOHN", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<KEEPASS_DB>",
          "description": "Path to KeePass database file (.kdbx)",
          "example": "Database.kdbx",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output file for hash",
          "example": "keepass.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "keepass2john": "Extraction tool from JtR suite. Extracts master password hash from KeePass database. Supports KeePass 1.x and 2.x formats. Output format: filename:$keepass$*version*rounds*...*hash. For Hashcat: remove 'filename:' prefix. For John: use as-is."
      },
      "success_indicators": [
        "$keepass$*2*",
        "Database:$keepass$"
      ],
      "failure_indicators": [
        "Error opening file",
        "Not a valid KeePass file"
      ],
      "next_steps": [
        "hashcat-keepass-crack",
        "john-keepass-crack"
      ],
      "troubleshooting": {
        "Not a valid KeePass file": "File corrupted or not KeePass format. Verify: file Database.kdbx (should show 'Keepass password database')",
        "Command not found": "Install john: apt install john"
      },
      "notes": "OSCP TIP: KeePass databases found in: ~/Documents, Desktop, network shares, Downloads. Search: find / -name '*.kdbx' 2>/dev/null. After extraction, REMOVE 'Database:' prefix for Hashcat (keep for John). Hash format: $keepass$*2*60*0*hash_data. The *2* indicates KeePass 2.x, *60* is transform rounds (in thousands).",
      "oscp_relevance": "high"
    },
    {
      "id": "ssh2john-extract",
      "name": "Extract SSH Private Key Hash",
      "category": "enumeration",
      "command": "ssh2john <PRIVATE_KEY> > <OUTPUT_FILE>",
      "description": "Convert SSH private key to John/Hashcat compatible hash format",
      "tags": ["HASH_FORMATTING", "SSH", "PRIVATE_KEY", "JOHN", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<PRIVATE_KEY>",
          "description": "Path to SSH private key file",
          "example": "id_rsa",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output file for hash",
          "example": "ssh.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "ssh2john": "Extraction tool from JtR suite. Extracts passphrase hash from encrypted SSH private keys. Supports RSA, DSA, EC keys. Supports all OpenSSH ciphers (aes-256-cbc, aes-256-ctr, etc.). Output format: filename:$sshng$*cipher*...*hash. For Hashcat: remove 'filename:' prefix AND verify cipher support (mode 22921 = aes-256-cbc only). For John: use as-is (supports all ciphers)."
      },
      "success_indicators": [
        "$sshng$",
        "id_rsa:$sshng$"
      ],
      "failure_indicators": [
        "Error: Not an encrypted key",
        "Command not found"
      ],
      "next_steps": [
        "hashcat-ssh-key-crack",
        "john-ssh-key-crack"
      ],
      "troubleshooting": {
        "Not an encrypted key": "SSH key has no passphrase - can use directly without cracking. Test: ssh -i id_rsa user@target (if no passphrase prompt = no encryption)",
        "Token length exception in Hashcat": "SSH key uses aes-256-ctr cipher (Hashcat unsupported). Use John the Ripper instead"
      },
      "notes": "OSCP TIP: SSH keys found in: ~/.ssh/id_rsa, /root/.ssh/id_rsa, web server file disclosure, backup files. Search: find / -name id_rsa 2>/dev/null. After extraction, check hash for cipher: $sshng$X$ where X=cipher indicator ($6$=aes-256-cbc, etc.). Modern keys often use aes-256-ctr (John only, NOT Hashcat). Remove 'id_rsa:' prefix before cracking.",
      "oscp_relevance": "high"
    },
    {
      "id": "zip2john-extract",
      "name": "Extract Encrypted ZIP Hash",
      "category": "enumeration",
      "command": "zip2john <ZIP_FILE> > <OUTPUT_FILE>",
      "description": "Convert encrypted ZIP file to crackable hash format",
      "tags": ["HASH_FORMATTING", "ZIP", "ARCHIVE", "JOHN", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<ZIP_FILE>",
          "description": "Path to encrypted ZIP file",
          "example": "encrypted.zip",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "zip.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "zip2john": "Extraction tool for password-protected ZIP archives. Extracts hash from ZIP encryption metadata. Supports ZipCrypto (traditional) and AES encryption. Output includes all encrypted files in archive. Multiple files = multiple hash lines (crack any to access all if same password)."
      },
      "success_indicators": [
        "$zip2$",
        "encrypted.zip/"
      ],
      "failure_indicators": [
        "Error: Not a ZIP file",
        "No encrypted files found"
      ],
      "next_steps": [
        "john-wordlist-attack",
        "hashcat-zip-crack"
      ],
      "notes": "ZIP files often contain: backup data, sensitive documents, password lists. After cracking, extract with: unzip encrypted.zip (enter cracked password). Check if ZIP actually requires password: unzip -l encrypted.zip (if succeeds = no password needed).",
      "oscp_relevance": "medium"
    },
    {
      "id": "rar2john-extract",
      "name": "Extract Encrypted RAR Hash",
      "category": "enumeration",
      "command": "rar2john <RAR_FILE> > <OUTPUT_FILE>",
      "description": "Convert encrypted RAR archive to crackable hash format",
      "tags": ["HASH_FORMATTING", "RAR", "ARCHIVE", "JOHN", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<RAR_FILE>",
          "description": "Path to encrypted RAR file",
          "example": "encrypted.rar",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "rar.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "rar2john": "Extraction tool for password-protected RAR archives. Supports RAR3 and RAR5 formats. RAR5 significantly slower to crack (stronger KDF). Output format indicates RAR version. Single password for all files in archive."
      },
      "success_indicators": [
        "$rar5$",
        "$rar3$"
      ],
      "notes": "RAR5 uses much stronger encryption than RAR3 (similar to bcrypt slowness). After cracking, extract with: unrar x encrypted.rar (or 7z x encrypted.rar).",
      "oscp_relevance": "medium"
    },
    {
      "id": "office2john-extract",
      "name": "Extract Microsoft Office Document Hash",
      "category": "enumeration",
      "command": "office2john <OFFICE_FILE> > <OUTPUT_FILE>",
      "description": "Convert password-protected Office documents to crackable hash",
      "tags": ["HASH_FORMATTING", "OFFICE", "DOCUMENT", "JOHN", "OSCP:MEDIUM"],
      "variables": [
        {
          "name": "<OFFICE_FILE>",
          "description": "Path to encrypted Office file (.docx, .xlsx, .pptx)",
          "example": "encrypted.docx",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "office.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "office2john": "Extraction tool for password-protected Office documents (Word, Excel, PowerPoint). Supports Office 2007+ formats (.docx, .xlsx, .pptx). Uses strong encryption (AES) - slow cracking. Output indicates Office version and encryption type."
      },
      "success_indicators": [
        "$office$",
        "encrypted.docx:"
      ],
      "notes": "Office 2007+ uses AES encryption (slow cracking). Focus on targeted wordlists. Common scenario: password-protected spreadsheets with credentials, macros, sensitive data.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hash-identifier",
      "name": "Identify Hash Type",
      "category": "enumeration",
      "command": "hash-identifier",
      "description": "Interactive hash type identifier tool",
      "tags": ["HASH_IDENTIFICATION", "HASH_TYPE", "ANALYSIS", "OSCP:MEDIUM"],
      "variables": [],
      "flag_explanations": {
        "hash-identifier": "Interactive tool - paste hash, get possible hash types. Lists multiple possibilities (many hashes look similar - MD2/MD4/MD5 all 32 hex chars). Use context clues (source system, application) to determine correct type. Alternative: hashid (command-line, non-interactive)."
      },
      "success_indicators": [
        "Possible Hashs:",
        "[+] MD5",
        "[+] NTLM"
      ],
      "notes": "OSCP TIP: Hash identification by characteristics - Length 32 hex: MD5/MD4/MD2/NTLM, Length 40 hex: SHA1, Length 64 hex: SHA256. Context helps: Windows = NTLM, Linux /etc/shadow = sha512crypt ($6$), Web apps = MD5/bcrypt. Cannot always distinguish - may need to try multiple modes.",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashid",
      "name": "Hashid - Modern Hash Identifier",
      "category": "enumeration",
      "command": "hashid '<HASH>' -m",
      "description": "Identify hash type with Hashcat/John mode numbers",
      "tags": ["HASH_IDENTIFICATION", "HASH_TYPE", "HASHCAT", "JOHN", "OSCP:HIGH"],
      "variables": [
        {
          "name": "<HASH>",
          "description": "Hash string to identify (quote if contains special chars)",
          "example": "5f4dcc3b5aa765d61d8327deb882cf99",
          "required": true
        }
      ],
      "flag_explanations": {
        "-m": "Mode numbers - Display Hashcat (-m) and John (--format) mode numbers for identified hash types. Extremely useful - directly tells you which mode to use. Saves time vs manual lookup in --help."
      },
      "success_indicators": [
        "[+] MD5",
        "Hashcat Mode: 0",
        "JtR Format: raw-md5"
      ],
      "notes": "OSCP TIP: Use hashid instead of hash-identifier for modern workflows. Command-line (scriptable) + shows exact modes for Hashcat/John. Example: hashid '$6$rounds=5000$...' -m → identifies sha512crypt with Hashcat mode 1800 and JtR format sha512crypt. Quote hashes to prevent shell interpretation of special chars ($, !).",
      "oscp_relevance": "high"
    },
    {
      "id": "pdf2john-extract",
      "name": "Extract PDF Password Hash",
      "category": "enumeration",
      "command": "pdf2john <PDF_FILE> > <OUTPUT_FILE>",
      "description": "Convert password-protected PDF to crackable hash",
      "tags": ["HASH_FORMATTING", "PDF", "DOCUMENT", "JOHN", "OSCP:LOW"],
      "variables": [
        {
          "name": "<PDF_FILE>",
          "description": "Path to encrypted PDF file",
          "example": "encrypted.pdf",
          "required": true
        },
        {
          "name": "<OUTPUT_FILE>",
          "description": "Output hash file",
          "example": "pdf.hash",
          "required": true
        }
      ],
      "flag_explanations": {
        "pdf2john": "Extraction tool for password-protected PDFs. PDFs can have two password types: 1) User password (open document), 2) Owner password (modify/print). Tool extracts both if present. PDF encryption varies - some versions weaker than others."
      },
      "success_indicators": [
        "$pdf$",
        "encrypted.pdf:"
      ],
      "notes": "PDFs often contain: documentation, password lists, network diagrams. Two password types: user (viewing) and owner (editing). May only need user password for access.",
      "oscp_relevance": "low"
    },
    {
      "id": "python-hash-generator",
      "name": "Generate Hash for Testing",
      "category": "enumeration",
      "command": "echo -n '<PASSWORD>' | md5sum",
      "description": "Generate MD5 hash for testing/verification",
      "tags": ["HASH_GENERATION", "TESTING", "MD5", "VERIFICATION", "OSCP:LOW"],
      "variables": [
        {
          "name": "<PASSWORD>",
          "description": "Plaintext password to hash",
          "example": "password123",
          "required": true
        }
      ],
      "flag_explanations": {
        "echo -n": "No newline - Essential flag! Without -n, newline is appended to string, changing the hash. Compare: echo 'test' | md5sum (includes \\n) vs echo -n 'test' | md5sum (excludes \\n). Always use -n for password hashing.",
        "md5sum": "Generate MD5 hash. Alternatives: sha1sum, sha256sum, sha512sum. Used for: 1) Testing hash cracking setup 2) Verifying cracked passwords 3) Understanding hash behavior"
      },
      "success_indicators": [
        "32 hex character hash",
        "hash  -"
      ],
      "notes": "OSCP TIP: Verify crack success by regenerating hash. Example: Cracked password = 'secret1', verify: echo -n 'secret1' | sha256sum (compare to original hash). Use for understanding: same plaintext → same hash, different plaintext → different hash. Generate test hashes: for pw in pass password 123456; do echo -n \"$pw\" | md5sum; done",
      "oscp_relevance": "low"
    },
    {
      "id": "base64-decode-hash",
      "name": "Base64 Decode Hash",
      "category": "enumeration",
      "command": "echo '<ENCODED_STRING>' | base64 -d",
      "description": "Decode base64-encoded strings (sometimes contain hashes)",
      "tags": ["DECODING", "BASE64", "HASH_FORMATTING", "OSCP:LOW"],
      "variables": [
        {
          "name": "<ENCODED_STRING>",
          "description": "Base64-encoded string",
          "example": "cGFzc3dvcmQxMjM=",
          "required": true
        }
      ],
      "flag_explanations": {
        "base64 -d": "Decode base64 - Sometimes passwords/hashes are base64-encoded for transport/storage. Not encryption (easily reversible). Encoding != security. Decode to reveal actual hash or password. Identify base64: Ends with = or ==, uses A-Z, a-z, 0-9, +, /"
      },
      "success_indicators": [
        "decoded plaintext output"
      ],
      "notes": "Base64 is encoding, NOT encryption. Some applications store passwords/hashes base64-encoded. Always try decoding suspicious base64 strings. Encode: echo -n 'password123' | base64. Decode: echo 'cGFzc3dvcmQxMjM=' | base64 -d",
      "oscp_relevance": "low"
    }
  ]
}
