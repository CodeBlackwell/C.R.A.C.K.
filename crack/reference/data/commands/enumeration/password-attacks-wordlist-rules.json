{
  "category": "enumeration",
  "description": "Rule-based password mutation for wordlist attacks",
  "commands": [
    {
      "id": "rule-append-digit",
      "name": "Append Single Digit Rule",
      "category": "enumeration",
      "command": "echo '$[0-9]' > <RULE_FILE>",
      "description": "Create rule to append digits 0-9 to passwords",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_MUTATION",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "append-digit.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "$[0-9]": "Append character - The $ operator appends the following character to the end of the word. [0-9] is character class notation - creates 10 rules (one for each digit). Password → Password0, Password1, ... Password9. Common pattern: users add single digit to comply with password policies."
      },
      "success_indicators": [
        "Rule file created",
        "File contains $0 through $9"
      ],
      "notes": "OSCP TIP:\nRule syntax - $ (append), ^ (prepend), c (capitalize), r (reverse), d (duplicate), t (toggle case).\n\nCombine operators:\nc $1 (Capitalize + append 1) → password → Password1.\n\nTest rules:\njohn --wordlist=words.txt --rules --stdout > mutated.txt.\n\nEach operator creates separate mutations - 1 word with 10 $[0-9] rules = 10 passwords.",
      "oscp_relevance": "high"
    },
    {
      "id": "rule-prepend-year",
      "name": "Prepend Year Rule",
      "category": "enumeration",
      "command": "echo '^2 ^0 ^2 ^4' > <RULE_FILE>",
      "description": "Create rule to prepend year (e.g., 2024) to passwords",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_MUTATION",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "prepend-year.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "^": "Prepend character - The ^ operator prepends characters to the START of the word. Applied RIGHT-TO-LEFT: ^4 ^2 ^0 ^2 reads as ^4 first (adds 4 to start), then ^2 (adds 2 before 4), etc. Final result: 2024password. Common in corporate environments (current year prefix for password rotation)."
      },
      "success_indicators": [
        "Rule file created",
        "File contains: ^2 ^0 ^2 ^4"
      ],
      "notes": "OSCP TIP:\nPrepend operators stack right-to-left.\n\nFor 2024:\n^4 adds '4' first, ^2 adds '2' before it (24), ^0 adds '0' (024), final ^2 adds '2' (2024).\n\nAlternative years:\n2023 = ^3 ^2 ^0 ^2, 2025 = ^5 ^2 ^0 ^2.\n\nCombine with other rules:\n^2 ^0 ^2 ^4 c (Prepend 2024 AND capitalize) → password → 2024Password.\n\nCommon corporate pattern:\nYYYYpassword! or password!YYYY.",
      "oscp_relevance": "high"
    },
    {
      "id": "rule-capitalize-append",
      "name": "Capitalize + Append Special Char Rule",
      "category": "enumeration",
      "command": "echo 'c $!' > <RULE_FILE>",
      "description": "Create rule to capitalize first letter and append exclamation mark",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_MUTATION",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "cap-special.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "c": "Capitalize first letter - Lowercase first letter becomes uppercase. password → Password. Extremely common - many policies require uppercase letter. Users typically capitalize ONLY first letter (path of least resistance).",
        "$!": "Append exclamation mark - Special character requirement often satisfied by appending ! to existing password. Combines with c to create: password → Password! (satisfies: uppercase + special char requirements)."
      },
      "success_indicators": [
        "Rule file created",
        "File contains: c $!"
      ],
      "notes": "OSCP TIP:\nMulti-operator rules combine effects.\n\nc $! transforms 'password' → 'Password!'.\n\nCommon corporate password policy:\n8+ chars, 1 uppercase, 1 special char.\n\nUsers modify existing passwords minimally:\npassword → Password!, welcome → Welcome!, spring2024 → Spring2024!.\n\nTest multiple special chars:\nc $!, c $@, c $#, c $$.\n\nPriority testing order:\n! @ # $ % (most to least common).",
      "oscp_relevance": "high"
    },
    {
      "id": "rule-leet-speak",
      "name": "Leet Speak (1337) Substitution Rule",
      "category": "enumeration",
      "command": "echo -e 'sa@\\nse3\\nsi1\\nso0\\nss$' > <RULE_FILE>",
      "description": "Create rule to substitute common leet speak characters",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_MUTATION",
        "LEET_SPEAK",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "leet.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "s": "Substitute character - Format: sXY (replace all X with Y). sa@ = replace 'a' with '@', se3 = replace 'e' with '3', si1 = replace 'i' with '1', so0 = replace 'o' with '0', ss$ = replace 's' with '$'. Common leet speak: a→@/4, e→3, i→1/!, o→0, s→$/5, t→7, l→1. Multiple rules in same file = John/Hashcat try each separately.",
        "echo -e": "Enable escape sequences - The -e flag allows \\n (newline) to create multiple rules in one command. Each line = separate rule. Alternative: Create file manually with text editor, one rule per line."
      },
      "success_indicators": [
        "Rule file created",
        "File contains 5 lines",
        "sa@, se3, si1, so0, ss$"
      ],
      "notes": "OSCP TIP:\nLeet speak remains surprisingly common.\n\n'password' with leet rules → p@ssw0rd, p@ssword, passw0rd, etc.\n\nUsers think it increases security (it doesn't significantly - just increases keyspace slightly).\n\nFull leet transform:\npassword → p@55w0rd.\n\nTest incrementally:\nsingle substitutions first (faster), then combinations.\n\nHashcat has built-in toggles for common substitutions.\n\nJohn rule syntax identical to Hashcat for basic s/^/$ operators.",
      "oscp_relevance": "medium"
    },
    {
      "id": "rule-duplicate-word",
      "name": "Duplicate Word Rule",
      "category": "enumeration",
      "command": "echo 'd' > <RULE_FILE>",
      "description": "Create rule to duplicate entire word",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_MUTATION",
        "WORDLIST",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "duplicate.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "d": "Duplicate word - Appends entire word to itself. password → passwordpassword. Surprisingly common for length requirements. Users need 16+ char password, pick 8-char word, double it. Satisfies length without memorizing complex string. Also common: password123password123, welcome1welcome1."
      },
      "success_indicators": [
        "Rule file created",
        "File contains: d"
      ],
      "notes": "OSCP TIP:\nDuplication common when minimum length > typical word length.\n\nCorporate policies often require 12-16 chars - users duplicate short passwords.\n\nCombine with other rules:\nd $! (duplicate + append !) → password → passwordpassword!.\n\nAlso test:\nd $1 $2 $3 (duplicate + append digits).\n\nSimilar patterns:\nword + reversed word (password + drowssap = rule:\nd r).",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-test-rules",
      "name": "Test Hashcat Rules with Stdout",
      "category": "enumeration",
      "command": "hashcat <WORDLIST> -r <RULE_FILE> --stdout | head -20",
      "description": "Preview rule mutations without cracking",
      "tags": [
        "RULE_TESTING",
        "HASHCAT",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Input wordlist to mutate",
          "example": "passwords.txt",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Rule file to apply",
          "example": "custom.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r": "Rule file - Apply mutations from rule file to wordlist. Each rule in file processed separately. Multiple -r flags chain rules (apply sequentially).",
        "--stdout": "Standard output mode - Print mutated passwords to terminal instead of cracking. CRITICAL for testing - verify rules work as expected BEFORE running hours-long crack session. Shows exactly what passwords will be tested.",
        "| head -20": "Limit output to first 20 lines - Rules can generate millions of mutations. Preview prevents terminal flood. Remove for full output or redirect: --stdout > mutated.txt"
      },
      "success_indicators": [
        "Mutated passwords displayed",
        "Each line shows one password candidate"
      ],
      "notes": "OSCP TIP:\nALWAYS test rules before cracking.\n\nBad rule syntax = wasted time (hours/days of cracking with 0 results).\n\nTesting workflow:\n1) Create small test wordlist (10 words), 2) Run with --stdout, 3) Verify mutations match intent, 4) Run full crack.\n\nExample:\necho 'password' | hashcat -r best64.rule --stdout (shows all 64 mutations of 'password').\n\nCount mutations:\nhashcat wordlist.txt -r rule.rule --stdout | wc -l",
      "oscp_relevance": "high"
    },
    {
      "id": "john-test-rules",
      "name": "Test John Rules with Stdout",
      "category": "enumeration",
      "command": "john --wordlist=<WORDLIST> --rules=<RULESET> --stdout | head -20",
      "description": "Preview John the Ripper rule mutations",
      "tags": [
        "RULE_TESTING",
        "JOHN",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<WORDLIST>",
          "description": "Input wordlist to mutate",
          "example": "passwords.txt",
          "required": true
        },
        {
          "name": "<RULESET>",
          "description": "Rule set name from john.conf or custom rule file",
          "example": "KoreLogic",
          "required": true
        }
      ],
      "flag_explanations": {
        "--rules": "Rule set - Apply named rule set from john.conf OR custom rule file. Named sets: Wordlist, Single, KoreLogic, Jumbo. Custom: --rules=./custom.rule (loads external file). No argument = default Wordlist rules.",
        "--stdout": "Standard output mode - Print mutated passwords to terminal without cracking. Same purpose as Hashcat --stdout. Essential for rule verification before committing to long crack session."
      },
      "success_indicators": [
        "Mutated passwords displayed",
        "Press Ctrl+C to stop (infinite generation possible)"
      ],
      "notes": "OSCP TIP:\nJohn rules more complex than Hashcat (support conditionals, variables, multiple operations per line).\n\nTest before using.\n\nCommon rulesets:\nWordlist (1600+ rules - aggressive), Single (smaller, username-based), KoreLogic (popular, balanced).\n\nShow available rules:\njohn --list=rules.\n\nExample:\necho 'password' | john --stdin --rules=Wordlist --stdout | head -100 (first 100 mutations).\n\nRule syntax differences:\nJohn uses [] for character classes, Hashcat uses literal notation.",
      "oscp_relevance": "high"
    },
    {
      "id": "hashcat-best64-rules",
      "name": "Hashcat Best64 Rules",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/best64.rule --force",
      "description": "Apply proven 64-rule set optimized for common password patterns",
      "tags": [
        "RULE_ATTACK",
        "HASHCAT",
        "PASSWORD_CRACKING",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash type mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hash to crack",
          "example": "hash.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r /usr/share/hashcat/rules/best64.rule": "Best64 ruleset - 64 PROVEN rules covering most common password mutations. Includes: capitalize, append digits, append special chars, leet speak, combinations. Developed from real-world password analysis. EXCELLENT first rule attack - fast (only 64 rules) + high success rate. Alternative location: /opt/hashcat/rules/best64.rule"
      },
      "success_indicators": [
        "Session started",
        "Progress shows: Base * 64 candidates",
        "Cracked: [hash]:[password]"
      ],
      "next_steps": [
        "hashcat-show-cracked"
      ],
      "notes": "OSCP TIP:\nRule priority for time-constrained scenarios (exams):\n1) Straight wordlist (no rules), 2) best64.rule (fast, proven), 3) rockyou-30000.rule (aggressive but slower), 4) dive.rule (most comprehensive).\n\nBest64 with rockyou.txt:\n14M words * 64 rules = 896M candidates (few minutes on GPU).\n\nSuccess rate:\n30-50% on weak passwords.\n\nFaster than brute-force, smarter than straight wordlist.\n\nAlternative:\nJohn's Wordlist ruleset (1600+ rules, more aggressive) - john --wordlist=<WORDLIST> --rules=Wordlist <HASH_FILE>",
      "oscp_relevance": "high",
      "alternatives": []
    },
    {
      "id": "hashcat-rockyou-rules",
      "name": "Hashcat RockYou-30000 Rules",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/rockyou-30000.rule --force",
      "description": "Apply comprehensive 30,000-rule set for aggressive mutation",
      "tags": [
        "RULE_ATTACK",
        "HASHCAT",
        "PASSWORD_CRACKING",
        "OSCP:MEDIUM"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash type mode number",
          "example": "1000",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hash to crack",
          "example": "ntlm.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r /usr/share/hashcat/rules/rockyou-30000.rule": "RockYou-30000 ruleset - 30,000 rules generated from analysis of RockYou breach (32M real passwords). HIGHLY effective but SLOW. Covers: complex substitutions, multi-character appends, case variations, insertions. Use when best64 fails and you have time. Generates: rockyou.txt (14M) * 30,000 rules = 420 BILLION candidates (hours/days depending on hash type)."
      },
      "success_indicators": [
        "Session started",
        "Progress shows: Base * 30000 candidates",
        "Status shows ETA"
      ],
      "prerequisites": [
        "hashcat-best64-rules"
      ],
      "notes": "OSCP TIP:\nUse when:\n1) Fast rules (best64) failed, 2) Hash type is fast (MD5, NTLM - millions of H/s), 3) You have time (not during exam pressure).\n\nAVOID for slow hashes (bcrypt, KeePass - hundreds of H/s) unless desperate.\n\nTime estimate:\nNTLM on GPU = few hours, bcrypt = weeks.\n\nAlternative approach:\nUse smaller custom ruleset targeting observed password policy (if known).",
      "oscp_relevance": "medium"
    },
    {
      "id": "hashcat-dive-rules",
      "name": "Hashcat Dive Rules",
      "category": "enumeration",
      "command": "hashcat -m <MODE> <HASH_FILE> <WORDLIST> -r /usr/share/hashcat/rules/dive.rule --force",
      "description": "Apply dive.rule (comprehensive ruleset for thorough cracking)",
      "tags": [
        "RULE_ATTACK",
        "HASHCAT",
        "PASSWORD_CRACKING",
        "OSCP:LOW"
      ],
      "variables": [
        {
          "name": "<MODE>",
          "description": "Hash type mode number",
          "example": "0",
          "required": true
        },
        {
          "name": "<HASH_FILE>",
          "description": "File containing hash to crack",
          "example": "hash.txt",
          "required": true
        },
        {
          "name": "<WORDLIST>",
          "description": "Base wordlist for mutations",
          "example": "/usr/share/wordlists/rockyou.txt",
          "required": true
        }
      ],
      "flag_explanations": {
        "-r /usr/share/hashcat/rules/dive.rule": "Dive ruleset - Most comprehensive built-in ruleset (100,000+ rules). Covers virtually every common mutation pattern. EXTREMELY slow (generates trillions of candidates). Use as LAST resort when all other attacks fail. Typically used with SMALL targeted wordlists (company name, usernames, known phrases) - NOT rockyou.txt."
      },
      "success_indicators": [
        "Session started",
        "Progress shows massive candidate count"
      ],
      "notes": "OSCP TIP:\nDive.rule is overkill for 99% of OSCP scenarios.\n\nTime investment rarely justified in 24-hour exam.\n\nBetter strategy:\nFocus on intelligence gathering (find password policy, leaked credentials, default passwords).\n\nUse dive.rule for offline practice when learning password behavior.\n\nPractical usage:\nSmall custom wordlist (10-100 words) + dive.rule = manageable.\n\nrockyou.txt + dive.rule = exam time wasted.",
      "oscp_relevance": "low"
    },
    {
      "id": "john-custom-rules-conf",
      "name": "Add Custom Rules to john.conf",
      "category": "enumeration",
      "command": "echo -e '[List.Rules:Custom]\\nc $1\\nc $2\\nc $3' >> ~/.john/john.conf",
      "description": "Create custom rule set in John configuration",
      "tags": [
        "RULE_CREATION",
        "JOHN",
        "CONFIGURATION",
        "OSCP:MEDIUM"
      ],
      "variables": [],
      "flag_explanations": {
        "[List.Rules:Custom]": "Rule section header - Defines new rule set named 'Custom'. Use with: john --rules=Custom. Can create multiple sections with different names: [List.Rules:YearAppend], [List.Rules:CompanyPolicy], etc. Stored in ~/.john/john.conf (user-specific) or /etc/john/john.conf (system-wide).",
        "echo -e '...' >> ~/.john/john.conf": "Append to config - The >> operator APPENDS to file (doesn't overwrite). -e enables escape sequences (\\n = newline). Alternative: Edit ~/.john/john.conf directly with text editor. Format: [Section header] followed by rules (one per line)."
      },
      "success_indicators": [
        "Rules added to john.conf",
        "john --list=rules shows 'Custom'"
      ],
      "notes": "OSCP TIP:\nCustom rules allow targeted attacks based on discovered password policy.\n\nExample:\nPolicy requires uppercase, digit, special char → Create rules:\nc $1 $!, c $2 $@, c $3 $#.\n\nRule syntax same as Hashcat for basic operations (s, ^, $, c, d, r, t).\n\nJohn also supports advanced features:\nconditionals (>[1-9] = reject if length < N), character position operations, context-sensitive mutations.\n\nView all built-in rules:\njohn --list=rules (shows Wordlist, Single, etc.).",
      "oscp_relevance": "medium"
    },
    {
      "id": "create-policy-rules",
      "name": "Generate Rules from Password Policy",
      "category": "enumeration",
      "command": "echo -e 'c $<YEAR> $!\\nc $<YEAR> $@\\nc $<YEAR> $#' > <RULE_FILE>",
      "description": "Create rules matching discovered password policy requirements",
      "tags": [
        "RULE_CREATION",
        "PASSWORD_POLICY",
        "WORDLIST",
        "OSCP:HIGH"
      ],
      "variables": [
        {
          "name": "<YEAR>",
          "description": "Current year or company-specific year",
          "example": "2024",
          "required": true
        },
        {
          "name": "<RULE_FILE>",
          "description": "Output rule file path",
          "example": "policy.rule",
          "required": true
        }
      ],
      "flag_explanations": {
        "c $<YEAR> $!": "Multi-mutation rule - Combines 3 operations: 1) c (capitalize first letter), 2) $<YEAR> (append year digits - $2 $0 $2 $4), 3) $! (append exclamation). Transforms: password → Password2024!. Satisfies common policy: uppercase + digit + special char. Pattern extremely common in corporate environments.",
        "Multiple variations": "Same base rule with different special chars (!@#) - Users pick one special char, typically from keyboard top row. Testing all three covers 90% of special char choices. Order by frequency: ! (most common), @ (second), # (third)."
      },
      "success_indicators": [
        "Rule file created",
        "Contains 3 rule variations"
      ],
      "notes": "OSCP TIP:\nIntelligence-driven rule creation.\n\nScenario:\nDiscovered policy via error message ('Password must contain:\n1 uppercase, 1 digit, 1 special char, min 12 characters').\n\nCreate targeted rules:\nc $2 $0 $2 $4 $! (Capitalize + 2024 + ! = 'Password2024!', 12 chars).\n\nAlso test:\nSeason + Year patterns (Spring2024!, Summer2024!).\n\nCombine with company-specific wordlist (company name, products, locations).\n\n100-word targeted list + smart rules > 14M-word generic list.",
      "oscp_relevance": "high"
    }
  ]
}