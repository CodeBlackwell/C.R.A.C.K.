{
  "cheatsheets": [
    {
      "id": "hash-cracking-methodology",
      "name": "Hash Cracking Methodology",
      "description": "Complete workflow for identifying, preparing, and cracking password hashes using Hashcat and John the Ripper",
      "educational_header": {
        "how_to_recognize": [
          "You've extracted password hashes from: /etc/shadow (Linux), SAM database (Windows), database dumps (SQL injection), configuration files (.env, config.php)",
          "Hash format patterns: 32 hex chars (MD5/NTLM), 40 hex (SHA1), 64 hex (SHA256), $6$ prefix (sha512crypt), $2b$ (bcrypt)",
          "Application password fields show hashed values instead of plaintext in database dumps",
          "Web application uses password_hash() or bcrypt() functions (source code review)",
          "Obtained hashes but need plaintext passwords for authentication"
        ],
        "when_to_look_for": [
          "After successful SQL injection with admin table access (SELECT username,password FROM users)",
          "Post-exploitation on Linux: cat /etc/shadow reveals sha512crypt hashes ($6$)",
          "Post-exploitation on Windows: mimikatz or secretsdump.py extracts NTLM hashes",
          "During source code review: Found password hashes in configuration files, backups, or git history",
          "OSCP exam scenarios: Need to pivot laterally using cracked domain credentials"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Linux /etc/shadow Hash Cracking",
          "context": "You've compromised a Linux web server via file upload vulnerability. You exfiltrated /etc/shadow and discovered user 'john' with hash: john:$6$salt$long_hash. The $6$ prefix indicates sha512crypt. Hash rate benchmark shows 10,000 H/s on your GPU. You have 4 hours of exam time remaining. Goal: Crack john's password for privilege escalation.",
          "approach": "1. Identify hash type: $6$ = sha512crypt (Linux default since 2011). 2. Benchmark: hashcat -b -m 1800 (mode 1800 = sha512crypt). Result: 10 kH/s. 3. Calculate time: rockyou.txt (14M) ÷ 10,000 H/s = 1,400 seconds = 23 minutes (straight wordlist). 4. Strategy: Start with straight rockyou, then rockyou + best64.rule. 5. Extract hash to file (john.hash). 6. Run: hashcat -m 1800 john.hash rockyou.txt. 7. Monitor progress with status updates. 8. If straight fails, escalate to rules.",
          "commands": [
            "hash-rate-benchmark",
            "calculate-crack-time",
            "hashcat-sha512crypt-crack",
            "hashcat-show-cracked",
            "hashcat-status-timer",
            "hashcat-rule-attack"
          ],
          "expected_outcome": "Hashcat tests rockyou.txt passwords against sha512crypt hash at ~10,000 H/s. Progress: 0% → 50% (7M tested) → CRACKED after 15 minutes. Output: john:$6$salt$hash:password123. Verification: su john (enter password123, gain shell). Time saved: Straight wordlist faster than rules (no extra time for exam). Next: Check john's sudo privileges, enumerate cron jobs, search for credentials in john's home directory.",
          "why_this_works": "sha512crypt is SLOW by design (key derivation function with 5,000 rounds by default). Slows down brute-force but also dictionary attacks. Hashcat uses GPU acceleration (10,000 H/s vs CPU: 1,000 H/s). rockyou.txt contains real passwords from RockYou breach (32M users). Sorted by frequency - most common passwords tested first. Password123 is in top 1,000 (high probability). Success because: 1) User chose common password, 2) Wordlist contains password, 3) Time estimate aligned with exam constraints. If straight fails: Add rules (best64 = 14M × 64 = 896M candidates, ~24 hours)."
        },
        {
          "title": "Scenario 2: NTLM Hash Cracking with Rules",
          "context": "You've dumped NTLM hashes from Windows domain controller using secretsdump.py: Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::. The second hash (31d6...) is LM, third is NTLM. You need Administrator plaintext for RDP access. NTLM cracks MUCH faster than LM. Benchmark: 50 GH/s (50 billion H/s). Current time: 1 hour into exam.",
          "approach": "1. Extract NTLM hash (after third colon): 31d6cfe0d16ae931b73c59d7e0c089c0. 2. Save to file: admin.ntlm. 3. Identify: 32 hex chars = MD5 or NTLM (use hashid to confirm). Mode 1000 for NTLM. 4. Benchmark: hashcat -b -m 1000 → 50 GH/s. 5. Time estimate: rockyou (14M) ÷ 50B H/s = 0.28 seconds (straight). Rules: 14M × 64 ÷ 50B = 18 seconds (best64). 6. Strategy: Straight first, then best64, then rockyou-30000 if needed. 7. Run with session management for resume capability.",
          "commands": [
            "hashid",
            "hash-rate-benchmark",
            "hashcat-ntlm-crack",
            "hashcat-best64-rules",
            "hashcat-show-cracked",
            "session-management"
          ],
          "expected_outcome": "Straight wordlist completes in <1 second (NTLM extremely fast). If no hit, best64 rules complete in ~18 seconds. Expected hit with rules: Password1, Welcome1, Admin123! Success: Administrator:31d6...:Admin123! Verification: xfreerdp /u:Administrator /p:Admin123! /v:192.168.45.100. Gain Domain Admin access. Next: Dump all domain hashes (ntdsutil), enumerate group policy, check for domain trusts. Time investment: <1 minute total (NTLM speed enables aggressive rule attacks).",
          "why_this_works": "NTLM is FAST hash (no salt, no iterations, simple MD4). Designed for speed (backwards compatibility), not security. GPU acceleration: 50 GH/s = 50 billion attempts per second. At this speed, entire rockyou + best64 rules (896M candidates) = 18 seconds. Rule-based success: Administrators often use: Seasonal passwords (Summer2024!), Policy compliance (Password1!), Company name + year. Rules generate these variations automatically. Success factors: 1) Weak NTLM algorithm, 2) GPU power, 3) Rule intelligence (targeted mutations). Even slow algorithms crack with good wordlist."
        },
        {
          "title": "Scenario 3: Time-Constrained Bcrypt Cracking",
          "context": "You've dumped bcrypt hashes from web application database (WordPress): admin:$2b$10$salt$hash. bcrypt is SLOW (designed to resist GPU cracking). Benchmark shows 100 H/s (100 attempts per second). Exam has 3 hours remaining. You need to crack this or find alternative. Calculate if attack is viable.",
          "approach": "1. Identify: $2b$ = bcrypt, $10$ = cost factor (2^10 = 1,024 rounds). 2. Benchmark: hashcat -b -m 3200 → 100 H/s. 3. Calculate keyspace: rockyou.txt = 14M passwords. Time: 14M ÷ 100 = 140,000 seconds = 39 hours. 4. Decision: Full rockyou NOT viable in exam. 5. Alternative strategy: Top 10,000 rockyou (head -10000 rockyou.txt > top10k.txt). Time: 10k ÷ 100 = 100 seconds = 1.6 minutes. 6. If fails: Try top 100k (17 minutes). 7. If still fails: ABANDON - find alternative (password reset, SQL injection, RCE).",
          "commands": [
            "hashid",
            "hash-rate-benchmark",
            "calculate-crack-time",
            "attack-mode-decision",
            "hashcat-bcrypt-crack",
            "wordlist-effectiveness"
          ],
          "expected_outcome": "Top 10k test completes in ~2 minutes. Success rate: 15-20% (common passwords). If MISS: Top 100k in ~17 minutes (success rate 30-35%). If still MISS: STOP - attack not viable. Redirect effort: Look for password reset function, check for hardcoded credentials in source, search for backup files with plaintext passwords. Time saved: Recognize unfeasible attack early. Exam strategy: Don't waste hours on low-probability cracks.",
          "why_this_works": "bcrypt DESIGNED to be slow (exponential cost factor). $10 = 1,024 rounds, $12 = 4,096 rounds (4x slower). GPU advantage reduced (bcrypt memory-hard). 100 H/s vs NTLM 50 GH/s = 500 million times slower. Mathematics: Full rockyou = 39 hours (exceeds exam time). Top 10k = feasible (1.6 min). Decision tree: Fast hash (NTLM, MD5) = Aggressive attacks viable. Slow hash (bcrypt, scrypt) = Targeted attacks only. Success depends on: Password in top N of wordlist. Alternative attacks: Password reset tokens, configuration file passwords, default credentials."
        },
        {
          "title": "Scenario 4: Custom Rule Creation Based on Policy",
          "context": "You've obtained NTLM hash from Windows workstation. Active Directory password policy discovered via LDAP query: Minimum 10 characters, 1 uppercase, 1 digit, 1 special character, No dictionary words allowed. Observed pattern from other systems: Company name (Contoso) + Season + Year + special char. You have 2 hours to crack.",
          "approach": "1. Create custom wordlist: Seasons (Spring, Summer, Fall, Winter), Years (2020-2024), Company (Contoso, Contoso123). Total: ~50 words. 2. Create custom rule: c $2 $0 $2 $4 $! (Capitalize + append 2024!). 3. Test rule with --stdout: hashcat wordlist.txt -r custom.rule --stdout | head. Verify: Contoso → Contoso2024! 4. Calculate: 50 words × 1 rule = 50 candidates ÷ 50 GH/s = instantaneous. 5. Expand rules: Try all years (2020-2024), Try special chars (!@#$), Total: 50 words × 5 years × 4 special = 1,000 candidates. 6. Run attack with custom wordlist + custom rules.",
          "commands": [
            "create-policy-rules",
            "hashcat-test-rules",
            "wordlist-effectiveness",
            "hashcat-rule-attack",
            "hashcat-show-cracked"
          ],
          "expected_outcome": "Custom attack completes in <1 second (NTLM speed + small wordlist). Success: Contoso:31d6...:Contoso2024! Hit rate: 60-70% (targeted attack based on intelligence). Verification: Use credential for SMB shares, RDP access, lateral movement. Key insight: Intelligence-driven attack (policy + patterns) beats brute force. 1,000 targeted candidates > 14M generic candidates. Time to craft rules: 10 minutes. Time to crack: <1 second. Total: 10 minutes vs 39 hours (brute force).",
          "why_this_works": "Humans are predictable. Password policies force patterns: Policy requires special char → Users append ! (easiest key). Policy requires digit → Users append year (easy to remember). Policy requires uppercase → Users capitalize first letter. Policy bans dictionary words → Users modify existing words (Contoso not in dict). Custom rules exploit psychology: c = capitalize (first letter easiest), $ = append (path of least resistance), Year = memorable (current year), Special = minimal effort (!). Success rate: Targeted attack (60%) vs Generic attack (15%) for policy-compliant passwords. Lesson: Gather intelligence (policy, patterns, company info) BEFORE attacking."
        },
        {
          "title": "Scenario 5: Incremental Mode and Mask Attack for Unknown Password",
          "context": "You've exhausted wordlists against MD5 hash from PHP web app. Straight rockyou failed, rules failed. You KNOW password exists (critical for exam point). Last resort: Brute force with masks. You observed: Username format is 'firstlast', Password pattern might be: firstlast + digits (john1234). Hash type: MD5 (fast, 20 GH/s). Time remaining: 8 hours.",
          "approach": "1. Extract username from hash file: john. 2. Create mask based on hypothesis: john?d?d?d?d (john + 4 digits). Charset: ?d = digit (0-9). 3. Calculate keyspace: 4-digit = 10^4 = 10,000 combinations. Time: 10,000 ÷ 20B H/s = 0.0005 seconds. 4. Expand if failed: john?d?d?d?d?d?d (6 digits = 1M combinations, 0.05 seconds). 5. Try variations: John?d?d?d?d (capitalized), JOHN?d?d?d?d (uppercase). 6. If still fails: Try incremental: ?l?l?l?l?l?l?l?l (8 lowercase letters = 208B combinations, 2.9 hours).",
          "commands": [
            "calculate-keyspace",
            "hashcat-mask-attack",
            "hashcat-increment",
            "hashcat-custom-charset",
            "calculate-crack-time",
            "session-management"
          ],
          "expected_outcome": "Mask john?d?d?d?d tests in <1 second (10k combinations). Success: john:5f4dcc3b5aa765d61d8327deb882cf99:john1234. If failed, expand to 6 digits (1M combinations, still <1 second). Capitalization variations add 3x multiplier (still fast). Incremental mode (8 lowercase) = 2.9 hours (viable if exam time allows). Key: Start specific (mask based on pattern), expand gradually (more characters/positions). Avoid: Full brute force (8-char alphanumeric = 62^8 = 218T combinations = 3 hours even on MD5).",
          "why_this_works": "Mask attack targets KNOWN patterns (username-based common). Keyspace reduction: 62^8 (218T) → 10^4 (10k) = 21.8 million times smaller. MD5 speed enables brute-force for small keyspaces. Pattern recognition: Developers/admins use: Username + digits (easy to remember), Keyboard patterns (qwerty123), Repeated characters (aaaa1111). Incremental mode: Hashcat/John try SHORT passwords first (length 1, 2, 3...), Most passwords 8-12 chars, Starting from 1 optimizes discovery. Success factors: 1) Fast hash (MD5), 2) Pattern hypothesis (username-based), 3) Small keyspace (4-6 digits). Lesson: When wordlists fail, think patterns before full brute-force."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Hash Identification and Analysis",
          "notes": "First step: Identify hash type correctly. Use hashid for automated detection (shows Hashcat/John modes). Manually verify: Length (32=MD5/NTLM, 40=SHA1, 64=SHA256), Prefix ($6$=sha512crypt, $2b$=bcrypt, $1$=md5crypt), Format (hex vs base64 vs custom). Extract hash cleanly: Remove usernames, salts handled by tools. Understand algorithm speed: Fast (MD5, NTLM, SHA1) = Aggressive attacks viable. Slow (bcrypt, scrypt, PBKDF2) = Targeted attacks only.",
          "commands": [
            "hashid",
            "hash-identifier",
            "hash-rate-benchmark"
          ]
        },
        {
          "title": "Phase 2: Benchmark and Time Estimation",
          "notes": "Before attacking, estimate time investment. Run benchmark for EXACT hash type (don't assume). Calculate crack time: Total passwords ÷ Hash rate ÷ Parallel tasks. Create decision matrix: <1 hour = Proceed immediately, 1-4 hours = Consider exam time constraints, 4-24 hours = Overnight only, >24 hours = Alternative strategy. Factor in: GPU temperature (throttling reduces speed), Other processes (reduce GPU availability), Exam time remaining (critical constraint).",
          "commands": [
            "hash-rate-benchmark",
            "calculate-keyspace",
            "calculate-crack-time",
            "wordlist-effectiveness",
            "attack-mode-decision"
          ]
        },
        {
          "title": "Phase 3: Attack Strategy Selection",
          "notes": "Choose attack mode based on hash speed + time available. FAST hashes (MD5, NTLM, SHA1): Try straight wordlist → rules (best64) → rules (rockyou-30000) → mask attack. SLOW hashes (bcrypt, sha512crypt): Try top 10k → top 100k → custom targeted wordlist → ABANDON if exceeds time. PATTERN-BASED: Known policy/pattern → Create custom rules → Targeted wordlist. Session management critical: Save session for pause/resume, Monitor progress regularly, Adjust strategy based on ETA.",
          "commands": [
            "attack-mode-decision",
            "hashcat-md5-crack",
            "hashcat-ntlm-crack",
            "hashcat-sha256-crack",
            "hashcat-bcrypt-crack",
            "hashcat-sha512crypt-crack",
            "john-wordlist-attack",
            "john-rules-attack"
          ]
        },
        {
          "title": "Phase 4: Rule-Based Attacks",
          "notes": "Rules multiply wordlist effectiveness. Start conservative (best64 = 64 rules, fast), escalate to aggressive (rockyou-30000, slow). Test rules first with --stdout (verify mutations match expectations). Custom rules for intelligence-driven attacks: Create rules matching discovered policy, Use company-specific patterns (names, products), Target seasonal/year patterns (Spring2024!). Rule syntax: $ (append), ^ (prepend), c (capitalize), s (substitute), d (duplicate). Combine operators: c $2 $0 $2 $4 $! = Capitalize + append 2024!",
          "commands": [
            "hashcat-best64-rules",
            "hashcat-rockyou-rules",
            "hashcat-rule-attack",
            "hashcat-test-rules",
            "john-rules-attack",
            "john-test-rules",
            "create-policy-rules",
            "rule-capitalize-append",
            "rule-leet-speak"
          ]
        },
        {
          "title": "Phase 5: Advanced Techniques and Fallback",
          "notes": "If standard attacks fail, use advanced techniques: Mask attacks for known patterns (username?d?d?d?d), Hybrid attacks (wordlist + mask: rockyou.txt ?d?d?d), Combinator attacks (merge two wordlists), Incremental mode (John's smart brute-force). Fallback strategies when cracking fails: Look for password reset functionality, Search for configuration files with plaintext passwords, Check for default credentials (admin:admin), Attempt SQL injection for password change, Find alternative exploitation paths (RCE, file upload, XXE).",
          "commands": [
            "hashcat-mask-attack",
            "hashcat-hybrid-attack",
            "hashcat-combination-attack",
            "hashcat-increment",
            "john-incremental-mode",
            "calculate-keyspace"
          ]
        },
        {
          "title": "Phase 6: Results Management and Documentation",
          "notes": "When hash cracks: Verify immediately (attempt authentication with plaintext), Document in notes (hash, plaintext, service, timestamp), Test password reuse (same password on other services), Check hashcat.potfile for persistent storage. Session management: Use --session for named sessions, Resume with --restore, Check status without interrupting (--status). Output management: Save to file with -o, Use --outfile-format=2 for plaintext only, Review hashcat.potfile for all historical cracks.",
          "commands": [
            "hashcat-show-cracked",
            "session-management",
            "monitor-crack-progress",
            "optimize-crack-performance"
          ]
        }
      ],
      "tags": ["PASSWORD_ATTACKS", "HASH_CRACKING", "HASHCAT", "JOHN", "METHODOLOGY", "OSCP:HIGH"]
    }
  ]
}
