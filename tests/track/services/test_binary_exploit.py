"""
Tests for Binary Exploitation service plugin

PROVES:
- Plugin correctly detects custom/unknown services
- Task tree generation follows OSCP best practices
- Educational metadata is comprehensive
- Format string, integer overflow, and array indexing techniques included
- Manual alternatives provided for all automated tasks
"""

import pytest
from crack.track.services.binary_exploit import BinaryExploitPlugin


class TestBinaryExploitPlugin:
    """Test suite for Binary Exploitation plugin"""

    @pytest.fixture
    def plugin(self):
        """Create plugin instance"""
        return BinaryExploitPlugin()

    def test_plugin_name(self, plugin):
        """PROVES: Plugin has correct name"""
        assert plugin.name == "binary-exploit"

    def test_default_ports_empty(self, plugin):
        """PROVES: Binary exploit plugin doesn't restrict to specific ports"""
        # Binary exploitation happens on various custom ports
        assert plugin.default_ports == []

    def test_service_names(self, plugin):
        """PROVES: Plugin handles custom/unknown service names"""
        assert 'binary' in plugin.service_names
        assert 'custom' in plugin.service_names
        assert 'unknown' in plugin.service_names

    # ===== DETECTION TESTS =====

    def test_detect_unknown_service(self, plugin):
        """PROVES: Plugin detects unknown services as potential binaries"""
        port_info = {
            'port': 9999,
            'service': 'unknown',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_custom_service(self, plugin):
        """PROVES: Plugin detects custom services"""
        port_info = {
            'port': 31337,
            'service': 'custom',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_tcpwrapped(self, plugin):
        """PROVES: Plugin detects tcpwrapped services (often custom)"""
        port_info = {
            'port': 10000,
            'service': 'tcpwrapped',
            'state': 'open'
        }
        assert plugin.detect(port_info) == True

    def test_detect_native_code_indicators(self, plugin):
        """PROVES: Plugin detects C/C++ application indicators"""
        test_cases = [
            {'service': 'unknown', 'product': 'C application'},
            {'service': 'custom', 'product': 'C++ application'},
            {'service': 'unknown', 'product': 'native binary'},
            {'service': 'unknown', 'product': 'ELF binary'}
        ]

        for port_info in test_cases:
            port_info['port'] = 9999
            port_info['state'] = 'open'
            assert plugin.detect(port_info) == True, f"Failed for {port_info}"

    def test_detect_ctf_ports(self, plugin):
        """PROVES: Plugin detects common CTF/practice challenge ports"""
        ctf_ports = [9999, 31337, 10000, 10001, 1337]

        for port in ctf_ports:
            port_info = {
                'port': port,
                'service': 'unknown',
                'state': 'open'
            }
            assert plugin.detect(port_info) == True, f"Failed to detect CTF port {port}"

    def test_detect_negative_http(self, plugin):
        """PROVES: Plugin does not detect standard HTTP services"""
        port_info = {
            'port': 80,
            'service': 'http',
            'product': 'Apache httpd'
        }
        assert plugin.detect(port_info) == False

    def test_detect_negative_ssh(self, plugin):
        """PROVES: Plugin does not detect SSH services"""
        port_info = {
            'port': 22,
            'service': 'ssh',
            'product': 'OpenSSH'
        }
        assert plugin.detect(port_info) == False

    # ===== TASK TREE STRUCTURE TESTS =====

    def test_task_tree_structure(self, plugin):
        """PROVES: Task tree has valid hierarchical structure"""
        service_info = {
            'port': 9999,
            'service': 'unknown',
            'version': 'unknown'
        }

        tree = plugin.get_task_tree('192.168.45.100', 9999, service_info)

        # Root structure
        assert 'id' in tree
        assert tree['id'] == 'binary-exploit-9999'
        assert 'name' in tree
        assert 'type' in tree
        assert tree['type'] == 'parent'
        assert 'children' in tree
        assert len(tree['children']) > 0

    def test_task_tree_has_recon_phase(self, plugin):
        """PROVES: Task tree includes reconnaissance phase"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        # Find recon parent task
        recon_task = None
        for child in tree['children']:
            if 'recon' in child['id'].lower():
                recon_task = child
                break

        assert recon_task is not None, "Reconnaissance phase missing"
        assert recon_task['type'] == 'parent'
        assert len(recon_task['children']) > 0

    def test_task_tree_has_vulnerability_identification(self, plugin):
        """PROVES: Task tree includes vulnerability identification phase"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        # Find vulnerability identification task
        vuln_task = None
        for child in tree['children']:
            if 'vuln' in child['id'].lower() or 'identification' in child['id'].lower():
                vuln_task = child
                break

        assert vuln_task is not None, "Vulnerability identification phase missing"
        assert vuln_task['type'] == 'parent'

    def test_task_tree_has_format_string_tasks(self, plugin):
        """PROVES: Task tree includes format string vulnerability tasks"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        # Flatten tree to find format string tasks
        all_tasks = self._flatten_task_tree(tree)
        format_string_tasks = [t for t in all_tasks if 'format-string' in t['id']]

        assert len(format_string_tasks) >= 3, "Should have multiple format string tasks"

        # Check for detection, offset finding, and exploitation
        task_ids = [t['id'] for t in format_string_tasks]
        assert any('detect' in tid or 'basic' in tid for tid in task_ids), "Missing detection task"
        assert any('offset' in tid for tid in task_ids), "Missing offset finding task"
        assert any('exploit' in tid for tid in task_ids), "Missing exploitation task"

    def test_task_tree_has_integer_overflow_tasks(self, plugin):
        """PROVES: Task tree includes integer overflow vulnerability tasks"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        integer_tasks = [t for t in all_tasks if 'integer-overflow' in t['id'] or 'integer-underflow' in t['id']]

        assert len(integer_tasks) >= 2, "Should have integer overflow detection and exploitation tasks"

    def test_task_tree_has_array_indexing_tasks(self, plugin):
        """PROVES: Task tree includes array indexing vulnerability tasks"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        array_tasks = [t for t in all_tasks if 'array-indexing' in t['id'] or 'array' in t['id']]

        assert len(array_tasks) >= 1, "Should have array indexing vulnerability task"

    def test_task_tree_has_exploitation_resources(self, plugin):
        """PROVES: Task tree includes exploitation resources and tools"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Should include pwntools, binary analysis tools, templates
        resource_keywords = ['pwntools', 'resource', 'tool', 'template']
        resource_tasks = [t for t in all_tasks if any(kw in t['id'].lower() or kw in t['name'].lower() for kw in resource_keywords)]

        assert len(resource_tasks) >= 2, "Should have multiple resource tasks"

    # ===== METADATA QUALITY TESTS =====

    def test_metadata_completeness_command_tasks(self, plugin):
        """PROVES: Command tasks have complete OSCP-required metadata"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        command_tasks = [t for t in all_tasks if t['type'] == 'command']

        assert len(command_tasks) > 0, "Should have command tasks"

        for task in command_tasks:
            metadata = task.get('metadata', {})

            # Required fields for command tasks
            assert 'command' in metadata, f"Task {task['id']} missing command"
            assert 'description' in metadata, f"Task {task['id']} missing description"
            assert 'flag_explanations' in metadata, f"Task {task['id']} missing flag_explanations"
            assert 'success_indicators' in metadata, f"Task {task['id']} missing success_indicators"
            assert 'alternatives' in metadata, f"Task {task['id']} missing alternatives"
            assert 'tags' in metadata, f"Task {task['id']} missing tags"

            # Quality checks
            assert len(metadata['flag_explanations']) > 0, f"Task {task['id']} has empty flag_explanations"
            assert len(metadata['success_indicators']) >= 1, f"Task {task['id']} needs success indicators"
            assert len(metadata['alternatives']) >= 1, f"Task {task['id']} needs manual alternatives"
            assert len(metadata['tags']) > 0, f"Task {task['id']} needs tags"

    def test_metadata_completeness_manual_tasks(self, plugin):
        """PROVES: Manual tasks have educational guidance"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        manual_tasks = [t for t in all_tasks if t['type'] == 'manual']

        assert len(manual_tasks) > 0, "Should have manual tasks"

        for task in manual_tasks:
            metadata = task.get('metadata', {})

            # Manual tasks should have description and guidance
            assert 'description' in metadata, f"Manual task {task['id']} missing description"
            assert 'tags' in metadata, f"Manual task {task['id']} missing tags"

            # Should have either alternatives or notes for guidance
            has_guidance = 'alternatives' in metadata or 'notes' in metadata or 'next_steps' in metadata
            assert has_guidance, f"Manual task {task['id']} needs guidance (alternatives/notes/next_steps)"

    def test_flag_explanations_quality(self, plugin):
        """PROVES: Flag explanations are detailed and educational"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        command_tasks = [t for t in all_tasks if t['type'] == 'command']

        for task in command_tasks:
            flag_exp = task['metadata'].get('flag_explanations', {})

            # Each explanation should be substantive (not just the flag name)
            for flag, explanation in flag_exp.items():
                assert len(explanation) > 10, f"Flag explanation for '{flag}' too brief: {explanation}"
                # Should explain purpose, not just restate the flag
                assert flag.lower() not in explanation.lower() or len(explanation) > 30, \
                    f"Flag explanation should explain purpose, not just restate: {explanation}"

    def test_success_indicators_present(self, plugin):
        """PROVES: All command tasks have clear success indicators"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        command_tasks = [t for t in all_tasks if t['type'] == 'command']

        for task in command_tasks:
            success = task['metadata'].get('success_indicators', [])
            assert len(success) >= 1, f"Task {task['id']} needs success indicators"

            # Each indicator should be specific
            for indicator in success:
                assert len(indicator) > 15, f"Success indicator too vague: {indicator}"

    def test_alternatives_for_oscp(self, plugin):
        """PROVES: Manual alternatives provided for OSCP exam scenarios"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        command_tasks = [t for t in all_tasks if t['type'] == 'command']

        for task in command_tasks:
            alternatives = task['metadata'].get('alternatives', [])
            assert len(alternatives) >= 1, f"Task {task['id']} needs manual alternatives for OSCP"

            # Alternatives should be different from main command
            main_command = task['metadata'].get('command', '')
            for alt in alternatives:
                # Should not be identical to main command
                assert alt != main_command, f"Alternative identical to main command: {alt}"

    # ===== TAG VALIDATION TESTS =====

    def test_oscp_priority_tags(self, plugin):
        """PROVES: Tasks are tagged with OSCP priority levels"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Should have mix of OSCP:HIGH, OSCP:MEDIUM, OSCP:LOW
        oscp_high = [t for t in all_tasks if 'OSCP:HIGH' in t.get('metadata', {}).get('tags', [])]
        oscp_medium = [t for t in all_tasks if 'OSCP:MEDIUM' in t.get('metadata', {}).get('tags', [])]

        assert len(oscp_high) > 0, "Should have OSCP:HIGH priority tasks"
        # Format string is HIGH priority, integer overflow is MEDIUM

    def test_quick_win_tags(self, plugin):
        """PROVES: Fast, high-value tasks tagged as QUICK_WIN"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        quick_wins = [t for t in all_tasks if 'QUICK_WIN' in t.get('metadata', {}).get('tags', [])]

        assert len(quick_wins) >= 1, "Should have QUICK_WIN tasks"

        # Quick wins should have time estimates or be obviously fast
        for task in quick_wins:
            metadata = task['metadata']
            # Either has time estimate < 5 minutes or uses simple commands (nc, echo)
            command = metadata.get('command', '')
            has_fast_estimate = 'estimated_time' in metadata and ('2-3' in metadata['estimated_time'] or '1-2' in metadata['estimated_time'])
            uses_simple_tools = any(tool in command for tool in ['nc ', 'echo ', 'python3 -c'])

            assert has_fast_estimate or uses_simple_tools, f"QUICK_WIN task {task['id']} should be demonstrably fast"

    def test_manual_tags(self, plugin):
        """PROVES: Manual action tasks properly tagged"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        for task in all_tasks:
            if task['type'] == 'manual':
                tags = task.get('metadata', {}).get('tags', [])
                assert 'MANUAL' in tags, f"Manual task {task['id']} should have MANUAL tag"

    # ===== FORMAT STRING SPECIFIC TESTS =====

    def test_format_string_formatters_explained(self, plugin):
        """PROVES: Format string formatters are thoroughly explained"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        format_tasks = [t for t in all_tasks if 'format-string' in t['id']]

        # Should explain key formatters: %p, %x, %s, %n
        all_explanations = []
        for task in format_tasks:
            flag_exp = task.get('metadata', {}).get('flag_explanations', {})
            all_explanations.extend(flag_exp.keys())

        # Check that format string specifiers are covered
        key_formatters = ['%p', '%s', '%n']  # Core format string primitives
        found_formatters = [fmt for fmt in key_formatters if any(fmt in exp for exp in all_explanations)]

        assert len(found_formatters) > 0, f"Should explain format string specifiers. Found: {all_explanations}"

    def test_format_string_offset_guidance(self, plugin):
        """PROVES: Format string offset finding is explained"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        offset_tasks = [t for t in all_tasks if 'offset' in t['id'] and 'format' in t['id']]

        assert len(offset_tasks) >= 1, "Should have format string offset finding task"

        # Check that offset task has educational notes
        offset_task = offset_tasks[0]
        notes = offset_task.get('metadata', {}).get('notes', '')
        alternatives = offset_task.get('metadata', {}).get('alternatives', [])

        # Should mention AAAA and 0x41414141 pattern
        has_offset_guidance = ('AAAA' in notes or 'AAAA' in str(alternatives)) and \
                             ('41414141' in notes or '41414141' in str(alternatives))

        assert has_offset_guidance, "Offset task should explain AAAA pattern matching technique"

    def test_format_string_exploitation_primitives(self, plugin):
        """PROVES: Format string exploitation primitives are documented"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        exploit_tasks = [t for t in all_tasks if 'exploit' in t['id'] and 'format' in t['id']]

        assert len(exploit_tasks) >= 1, "Should have format string exploitation task"

        # Check that exploitation techniques are covered
        for task in exploit_tasks:
            notes = task.get('metadata', {}).get('notes', '')
            alternatives = task.get('metadata', {}).get('alternatives', [])
            combined_text = notes + str(alternatives)

            # Should cover key concepts
            key_concepts = ['arbitrary read', 'arbitrary write', 'GOT']
            found_concepts = [c for c in key_concepts if c.lower() in combined_text.lower()]

            if found_concepts:  # At least one exploitation task should cover these
                assert len(found_concepts) >= 2, f"Exploitation task should cover read/write primitives. Found: {found_concepts}"

    # ===== INTEGER OVERFLOW SPECIFIC TESTS =====

    def test_integer_overflow_boundary_values(self, plugin):
        """PROVES: Integer overflow tasks mention boundary values"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        integer_tasks = [t for t in all_tasks if 'integer' in t['id']]

        assert len(integer_tasks) >= 1, "Should have integer overflow tasks"

        # Check that boundary values are documented
        all_content = []
        for task in integer_tasks:
            metadata = task.get('metadata', {})
            content = str(metadata.get('notes', '')) + str(metadata.get('alternatives', [])) + str(metadata.get('description', ''))
            all_content.append(content.lower())

        combined = ' '.join(all_content)

        # Should mention key integer types and limits
        boundary_indicators = ['int_max', '2147483647', '4294967296', '2^32', 'uint32', 'overflow', 'underflow']
        found_indicators = [ind for ind in boundary_indicators if ind in combined]

        assert len(found_indicators) >= 2, f"Integer tasks should mention boundary values. Found: {found_indicators}"

    def test_integer_overflow_exploitation_chain(self, plugin):
        """PROVES: Integer overflow exploitation chain is explained"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        integer_exploit_tasks = [t for t in all_tasks if 'integer' in t['id'] and 'exploit' in t['id']]

        assert len(integer_exploit_tasks) >= 1, "Should have integer overflow exploitation task"

        # Check that chain is explained: overflow → small alloc → big copy → heap overflow
        for task in integer_exploit_tasks:
            notes = task.get('metadata', {}).get('notes', '')

            # Should explain the exploitation chain
            chain_concepts = ['heap', 'overflow', 'alloc']
            found_concepts = [c for c in chain_concepts if c in notes.lower()]

            if found_concepts:  # If this is the detailed exploitation task
                assert len(found_concepts) >= 2, "Should explain integer overflow to heap overflow chain"

    # ===== PWNTOOLS AND TOOL REFERENCES =====

    def test_pwntools_reference_with_manual_alternative(self, plugin):
        """PROVES: Pwntools tasks warn about OSCP exam limitations"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        pwntools_tasks = [t for t in all_tasks if 'pwntools' in t['id'].lower() or 'pwntools' in t.get('name', '').lower()]

        if len(pwntools_tasks) > 0:
            # Should mention OSCP exam limitations
            for task in pwntools_tasks:
                notes = task.get('metadata', {}).get('notes', '')
                alternatives = task.get('metadata', {}).get('alternatives', [])

                # Should warn that pwntools not available in OSCP
                has_oscp_warning = 'oscp' in notes.lower() and ('not available' in notes.lower() or 'exam' in notes.lower())
                has_manual_alternatives = len(alternatives) > 0

                assert has_oscp_warning or has_manual_alternatives, \
                    "Pwntools task should warn about OSCP limitations and provide alternatives"

    def test_binary_analysis_tools_reference(self, plugin):
        """PROVES: Binary analysis tools are documented"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        tool_tasks = [t for t in all_tasks if 'tool' in t['id'].lower() or 'analysis' in t['id'].lower()]

        assert len(tool_tasks) >= 1, "Should have binary analysis tools reference"

        # Should mention essential tools
        essential_tools = ['gdb', 'checksec', 'file', 'strings', 'readelf']

        for task in tool_tasks:
            alternatives = task.get('metadata', {}).get('alternatives', [])
            notes = task.get('metadata', {}).get('notes', '')
            combined = str(alternatives) + notes

            found_tools = [tool for tool in essential_tools if tool in combined.lower()]

            if len(found_tools) >= 3:  # This is the main tools reference
                assert len(found_tools) >= 3, f"Should reference essential tools. Found: {found_tools}"
                break

    # ===== EDUCATIONAL QUALITY TESTS =====

    def test_educational_notes_present(self, plugin):
        """PROVES: Tasks include educational notes explaining concepts"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Count tasks with substantive educational notes
        tasks_with_education = 0
        for task in all_tasks:
            notes = task.get('metadata', {}).get('notes', '')
            # Substantive notes are longer than simple reminders
            if len(notes) > 100:
                tasks_with_education += 1

        # Should have significant educational content
        assert tasks_with_education >= 3, \
            f"Should have multiple tasks with educational notes. Found: {tasks_with_education}"

    def test_next_steps_guidance(self, plugin):
        """PROVES: Tasks provide next-step guidance"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)
        tasks_with_next_steps = [t for t in all_tasks if 'next_steps' in t.get('metadata', {})]

        assert len(tasks_with_next_steps) >= 2, "Should have multiple tasks with next-step guidance"

        # Next steps should be actionable
        for task in tasks_with_next_steps:
            next_steps = task['metadata']['next_steps']
            assert len(next_steps) >= 2, f"Task {task['id']} should have 2+ next steps"

            # Each step should be reasonably detailed
            for step in next_steps:
                assert len(step) > 10, f"Next step too brief: {step}"

    def test_oscp_exam_focus(self, plugin):
        """PROVES: Plugin emphasizes OSCP exam preparation"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Count OSCP-related mentions
        oscp_mentions = 0
        for task in all_tasks:
            metadata_str = str(task.get('metadata', {}))
            if 'oscp' in metadata_str.lower():
                oscp_mentions += 1

        assert oscp_mentions >= 3, "Plugin should emphasize OSCP exam preparation throughout"

    # ===== TASK COMPLETENESS TESTS =====

    def test_complete_vulnerability_lifecycle(self, plugin):
        """PROVES: Plugin covers complete vulnerability lifecycle"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Should cover: reconnaissance → detection → exploitation → post-exploit
        lifecycle_phases = {
            'recon': any('recon' in t['id'] for t in all_tasks),
            'detect': any('detect' in t['id'] or 'test' in t['id'] for t in all_tasks),
            'exploit': any('exploit' in t['id'] for t in all_tasks),
            'resources': any('resource' in t['id'] or 'tool' in t['id'] for t in all_tasks)
        }

        for phase, present in lifecycle_phases.items():
            assert present, f"Missing lifecycle phase: {phase}"

    def test_multiple_vulnerability_classes(self, plugin):
        """PROVES: Plugin covers multiple vulnerability classes"""
        tree = plugin.get_task_tree('192.168.45.100', 9999, {'service': 'unknown'})

        all_tasks = self._flatten_task_tree(tree)

        # Should cover format string, integer overflow, array indexing
        vuln_classes = {
            'format_string': any('format-string' in t['id'] or 'format string' in t.get('name', '').lower() for t in all_tasks),
            'integer_overflow': any('integer' in t['id'] or 'overflow' in t['id'] for t in all_tasks),
            'array_indexing': any('array' in t['id'] or 'indexing' in t.get('name', '').lower() for t in all_tasks)
        }

        covered_classes = [name for name, present in vuln_classes.items() if present]

        assert len(covered_classes) >= 3, \
            f"Should cover all vulnerability classes. Found: {covered_classes}"

    # ===== HELPER METHODS =====

    def _flatten_task_tree(self, tree):
        """Flatten hierarchical task tree to list of all tasks"""
        tasks = []

        def traverse(node):
            tasks.append(node)
            if 'children' in node:
                for child in node['children']:
                    traverse(child)

        traverse(tree)
        return tasks

    # ===== ON_TASK_COMPLETE TESTS =====

    def test_on_task_complete_format_string_confirmed(self, plugin):
        """PROVES: Plugin spawns advanced tasks when format string confirmed"""
        # Simulate format string vulnerability confirmed
        result = "0x7ffe12345678 0x41414141 0x7f8d2a3b4c5d"
        new_tasks = plugin.on_task_complete('format-string-basic-9999', result, '192.168.45.100')

        assert len(new_tasks) > 0, "Should spawn additional tasks when format string confirmed"

        # Should spawn advanced exploitation task
        assert any('advanced' in t['id'] or 'exploit' in t['id'] for t in new_tasks), \
            "Should spawn advanced format string exploitation task"

    def test_on_task_complete_integer_overflow_confirmed(self, plugin):
        """PROVES: Plugin spawns exploit tasks when integer overflow found"""
        result = "Integer overflow detected: wrapped to 0"
        new_tasks = plugin.on_task_complete('integer-overflow-test-9999', result, '192.168.45.100')

        assert len(new_tasks) > 0, "Should spawn tasks when integer overflow confirmed"

    def test_on_task_complete_no_spawn_unrelated(self, plugin):
        """PROVES: Plugin doesn't spawn tasks for unrelated completions"""
        result = "Some unrelated output"
        new_tasks = plugin.on_task_complete('unrelated-task-9999', result, '192.168.45.100')

        # Should not spawn tasks for unrelated completions
        # (empty list is acceptable)
        assert isinstance(new_tasks, list), "Should return list even if empty"

    # ===== MANUAL ALTERNATIVES TESTS =====

    def test_manual_alternatives_format_string(self, plugin):
        """PROVES: Manual alternatives provided for format string tasks"""
        alternatives = plugin.get_manual_alternatives('format-string-basic-9999')

        assert len(alternatives) > 0, "Should provide manual alternatives for format string"

        # Should mention manual techniques
        combined = ' '.join(alternatives).lower()
        assert 'manual' in combined or 'nc' in combined or 'echo' in combined

    def test_manual_alternatives_integer_overflow(self, plugin):
        """PROVES: Manual alternatives provided for integer overflow tasks"""
        alternatives = plugin.get_manual_alternatives('integer-overflow-test-9999')

        assert len(alternatives) > 0, "Should provide manual alternatives for integer overflow"

    def test_manual_alternatives_pwntools(self, plugin):
        """PROVES: Manual alternatives provided for pwntools tasks"""
        alternatives = plugin.get_manual_alternatives('pwntools-setup-9999')

        assert len(alternatives) > 0, "Should provide manual alternatives to pwntools"

        # Should mention struct module or manual packing
        combined = ' '.join(alternatives).lower()
        assert 'struct' in combined or 'socket' in combined or 'manual' in combined

    # ===== REAL-WORLD SCENARIO TESTS =====

    def test_ctf_port_complete_workflow(self, plugin):
        """PROVES: Plugin generates complete workflow for CTF challenge port"""
        # Simulate CTF challenge on port 9999
        port_info = {
            'port': 9999,
            'service': 'unknown',
            'product': 'custom binary',
            'state': 'open'
        }

        # Detection
        assert plugin.detect(port_info) == True

        # Task generation
        tree = plugin.get_task_tree('192.168.45.100', 9999, port_info)

        # Should have comprehensive task tree
        all_tasks = self._flatten_task_tree(tree)

        # Verify key phases present
        has_recon = any('recon' in t['id'] or 'connect' in t['id'] for t in all_tasks)
        has_vuln_detection = any('format' in t['id'] or 'integer' in t['id'] or 'detect' in t['id'] for t in all_tasks)
        has_exploitation = any('exploit' in t['id'] for t in all_tasks)
        has_resources = any('tool' in t['id'] or 'template' in t['id'] or 'resource' in t['id'] for t in all_tasks)

        assert has_recon, "Should have reconnaissance tasks"
        assert has_vuln_detection, "Should have vulnerability detection tasks"
        assert has_exploitation, "Should have exploitation tasks"
        assert has_resources, "Should have resources/tools reference"

    def test_unknown_service_oscp_scenario(self, plugin):
        """PROVES: Plugin handles unknown service in OSCP-like scenario"""
        # Simulate OSCP exam: unknown service found
        port_info = {
            'port': 31337,
            'service': 'tcpwrapped',
            'state': 'open'
        }

        # Should detect
        assert plugin.detect(port_info) == True

        # Should generate educational task tree
        tree = plugin.get_task_tree('192.168.45.100', 31337, port_info)

        # Should prioritize manual techniques (OSCP exam readiness)
        all_tasks = self._flatten_task_tree(tree)
        manual_tasks = [t for t in all_tasks if 'MANUAL' in t.get('metadata', {}).get('tags', [])]
        high_priority = [t for t in all_tasks if 'OSCP:HIGH' in t.get('metadata', {}).get('tags', [])]

        assert len(manual_tasks) >= 3, "Should have multiple manual tasks for OSCP"
        assert len(high_priority) >= 2, "Should have OSCP:HIGH priority tasks"
